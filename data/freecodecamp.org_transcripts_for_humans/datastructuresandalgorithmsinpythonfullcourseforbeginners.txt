With timestamps:

00:00 - this is a beginner-friendly introduction
00:02 - to common data structures and algorithms
00:04 - in python this course is taught by akash
00:07 - ns the co-founder and ceo of jovian
00:11 - data structures and algorithms in python
00:13 - is a practical beginner friendly and
00:16 - coding focused online course that will
00:18 - help you improve your programming skills
00:20 - solve coding challenges and ace
00:22 - technical interviews
00:24 - you can also earn a verified certificate
00:26 - of accomplishment by completing this
00:28 - course
00:29 - learn more and register at pythondsa.com
00:33 - this course runs over six weeks with two
00:35 - hour video lectures every week with live
00:38 - interactive coding using the python
00:40 - programming language you will get a
00:42 - chance to practice and improve your
00:44 - coding skills with weekly programming
00:46 - assignments consisting of real interview
00:48 - questions and you will also build a
00:51 - course project that you can showcase on
00:52 - your resume or linkedin profile this is
00:55 - a beginner-friendly course and some
00:57 - basic programming knowledge will help
00:58 - you follow along with the course don't
01:00 - worry if you're new to programming you
01:02 - can learn it as you work on this course
01:04 - with a little extra effort
01:06 - you will also get to access the course
01:08 - community forum where you can ask
01:10 - questions participate in discussions and
01:12 - share what you're working on during the
01:14 - course this course is created by jovian
01:16 - a platform for learning data science and
01:18 - machine learning with a global community
01:21 - of tens of thousands of learners from
01:23 - over 150 countries i'm your instructor
01:26 - akash co-founder and ceo of jovian and
01:29 - i'm really excited to kick off this
01:31 - course with you
01:32 - register now and invite your friends to
01:34 - join the course at pythondsa.com
01:43 - hello and welcome to data structures and
01:45 - algorithms in python
01:48 - this is an online certification course
01:51 - brought to you by jovian
01:53 - and today we are at lesson one binary
01:55 - search linked lists and complexity
01:57 - analysis
02:00 - my name is akash
02:01 - i am the ceo and co-founder of jovian
02:04 - and i will be your instructor
02:06 - you can find me on twitter at rcacheness
02:11 - this course runs over six weeks and over
02:13 - the six weeks if you enroll with for the
02:15 - course work on four programming
02:17 - assignments and build a course project
02:19 - you can earn a certificate of
02:20 - accomplishment
02:22 - along the process you will also learn
02:23 - about common data structures and
02:25 - algorithms in python
02:26 - and how to use these skills to
02:29 - ace coding interviews and technical
02:31 - assessments
02:32 - so let's get started then
02:34 - to begin we need to go to the course
02:36 - website pythondsa.com
02:39 - so if you open up pythondsa.com in your
02:42 - browser that will bring you to this page
02:44 - this is the course page and you can
02:45 - watch an introductory video about the
02:47 - course here you can enroll for the
02:49 - course for free you will need to sign in
02:51 - into jovian you can use your google
02:54 - github or email to sign in into jovian
02:58 - and once you're enrolled into the course
03:00 - you can also invite your friends to join
03:01 - the course the course is still open for
03:03 - enrollments
03:04 - so please invite your friends and
03:06 - colleagues
03:08 - this course is a beginner friendly
03:09 - introduction to common data structures
03:11 - and algorithms in python and this course
03:14 - will help you prepare for coding
03:15 - interviews
03:17 - we have coding focused hands-on video
03:19 - tutorials every week
03:21 - so you can either follow along with this
03:23 - video you can pause and run the code as
03:25 - we speak
03:27 - and you can practice coding on the cloud
03:29 - or you can watch the video right now and
03:30 - you can practice later
03:35 - in this course we will solve questions
03:37 - from real programming interviews
03:39 - and you can earn a verified certificate
03:41 - of accomplishment
03:44 - so let's go to lesson one binary search
03:46 - linked lists and complexity
03:48 - on the lesson one page you can see a
03:50 - recording of the lesson once it is
03:53 - completed
03:55 - and you will also be able to see a hindi
03:56 - version here
03:58 - and all the code used in this lesson is
04:00 - linked below
04:02 - so the first
04:04 - set of code that we will look at today
04:06 - is called linear and binary search so
04:09 - let's open it up
04:12 - so this is the first tutorial that we
04:13 - will work through in this lesson
04:15 - and you will be able to work through
04:17 - with it as well
04:19 - and this is part one
04:20 - and there are a total of 12
04:23 - notebooks or 12 tutorials we will go
04:25 - through
04:28 - now this course assumes very little
04:30 - background in programming and
04:31 - mathematics but you still do need to
04:33 - know a little bit for instance you do
04:35 - need to know basic programming with
04:36 - python things like variables data types
04:39 - loops and functions and don't worry if
04:41 - you don't know them already you can
04:43 - click through and follow these links
04:45 - each of these is a separate tutorial the
04:47 - tutorial will take you about half an
04:49 - hour or so each of these and you can
04:51 - learn the basic programming with python
04:53 - in just a couple of hours
04:55 - you will also need to know some high
04:56 - school mathematics
04:58 - and if you want to brush up things like
05:01 - polynomials vectors matrices and
05:02 - probabilities you can click through and
05:04 - read these
05:06 - but no prior knowledge of data
05:07 - structures or algorithms is required you
05:09 - do not need to have an extensive coding
05:11 - background
05:12 - and we will cover any additional
05:14 - mathematical and theoretical concepts as
05:16 - we
05:17 - we need as we go along
05:21 - so how to run the code what you will see
05:23 - here
05:24 - is that some explanations and then you
05:26 - will also see some code so you can see
05:27 - here that there is some code written
05:29 - here and there is some
05:31 - func so the library is imported and a
05:33 - function from the library is used here
05:36 - now to run this code you have two
05:37 - options you can either run this code
05:40 - using free online resources which is
05:41 - what we recommend or you can run it on
05:43 - your computer locally and you can read
05:45 - these instructions i am going to use
05:48 - free online resources provided by jovin
05:50 - so we just scroll up here at the top of
05:53 - this page and click run and then click
05:55 - run on binder
05:58 - so this will take a second or two and
06:00 - what we're doing here essentially is
06:01 - setting up a machine for you on the
06:03 - cloud using a software called binder
06:05 - it's an open source software
06:07 - and now what you were looking at here
06:10 - this was actually not a
06:12 - blog post this is actually something
06:14 - called a jupiter notebook a jupiter
06:16 - notebook
06:18 - is something that can
06:21 - not only contain explanations but can
06:23 - also contain code and you can look at
06:25 - the code and its outputs right here in
06:27 - an interactive fashion so if i scroll
06:29 - down here you can see that we have all
06:31 - the same content that we were looking at
06:33 - except this time we can actually run
06:34 - this code so we can click the run button
06:36 - here
06:38 - and the run button will run the code
06:40 - and here we click the second run button
06:42 - that is going to run the second
06:43 - line of code
06:45 - now we will be using jupyter notebooks
06:47 - extensively throughout this course
06:49 - because jupyter notebooks are a great
06:51 - way to do interactive programming you
06:53 - can change the code
06:55 - for example instead of the math mat dot
06:57 - square root you can use mat dot seal and
07:00 - you can change the value here
07:02 - so jupyter notebooks are great for
07:04 - experimenting with code
07:06 - now just a couple of tips that you want
07:08 - to do as soon as you run a jupyter
07:10 - notebook
07:11 - you can click on kernel and click
07:14 - restart and clear output
07:17 - what this will do is this will remove
07:19 - all the pre-executed outputs from your
07:21 - code
07:23 - so you can now see that the output of
07:25 - the function is gone and you can see
07:26 - that the numbers here go away so now you
07:28 - can execute the code
07:30 - line by line yourself and see the output
07:32 - discover the output
07:37 - and then one other thing you can do if
07:38 - you want to hide the ui a little bit is
07:41 - to toggle the header
07:43 - and also toggle the toolbar
07:45 - now you might need the toolbar for the
07:46 - run button but there's a tip here
07:49 - instead of pressing the run button you
07:50 - can use shift plus enter so if you press
07:53 - shift plus enter that will execute a
07:55 - cell and that's a pretty handy shortcut
08:02 - so once again you go on the lesson page
08:06 - on the lesson page you will find a link
08:08 - to the notebook called linear and binary
08:10 - search
08:11 - on the linear and binary search you can
08:13 - read the explanations but you can't run
08:15 - them to run the code you need to click
08:16 - run and then select run on binder and
08:19 - clicking run on binder will
08:21 - set up a cloud machine for you
08:24 - and all the code that you see here will
08:26 - get executed on the cloud
08:28 - so you do not need to set up anything on
08:30 - your computer you do not need to
08:32 - download anything we've done all that
08:33 - for you
08:35 - so let's get started then
08:38 - this course takes a coding focused
08:40 - approach towards learning and in each
08:42 - notebook or each tutorial we will focus
08:44 - on solving one problem and then learn
08:46 - the techniques algorithms and data
08:48 - structures to device an efficient
08:50 - solution for that specific problem we
08:52 - will then generalize the technique and
08:54 - apply it to other problems
08:56 - so in this specific tutorial we will
08:58 - focus on solving this problem
09:00 - and here's the problem we're solving
09:02 - and this is a typical problem that you
09:04 - will come across in a coding challenge
09:06 - or a coding interview so here's how the
09:08 - problem goes alice has some cards with
09:11 - numbers written on them and then she
09:13 - arranges the cards in decreasing order
09:15 - and lays them out face down in a
09:16 - sequence on a table so this is what it
09:19 - looks like these are cards each of these
09:21 - cards has a number below it and the
09:23 - numbers are in decreasing order she
09:26 - challenges bob to pick out the card
09:27 - containing a given number for example
09:30 - she could say bob i want you to pick out
09:32 - the number 7
09:33 - by turning over as few cards as possible
09:37 - so this is a puzzle that's given to us
09:39 - and we're not told how many cards alice
09:41 - has so you need to write a function to
09:43 - help bob locate the card
09:45 - so alice can put down any number of
09:47 - cards and the target number that bob has
09:49 - to pick out could be anything so we have
09:51 - to tell bob
09:53 - not
09:54 - us not the solution for a specific
09:56 - problem but a general strategy that he
09:58 - can use
09:59 - to turn over as few cards as possible
10:02 - so for instance look at these seven
10:04 - cards and maybe put some imaginary
10:06 - imaginary numbers before them below them
10:09 - and try to figure out a strategy try to
10:11 - start thinking about the problem
10:13 - and this may seem like a simple problem
10:15 - especially if you're familiar with the
10:17 - concept of binary search but the
10:18 - strategy and technique that we're
10:20 - learning here will be widely applicable
10:22 - and we will soon use it to solve harder
10:25 - problems
10:27 - now before while you think about the
10:28 - problem and before we start solving it
10:31 - i just want to talk about why you should
10:32 - learn data structures and algorithms and
10:34 - whether you're pursuing a career in
10:36 - software development or data science
10:37 - it's almost certain that you will be
10:39 - asked programming problems like
10:40 - reversing a linked list or balancing a
10:42 - binary tree in a technical interview or
10:44 - coding assessment now it's well known
10:46 - that you never face these problems in
10:48 - your job as a software developer so it's
10:51 - okay to wonder why such problems are
10:52 - asked in interviews
10:54 - and they're asked because they
10:55 - demonstrate the following traits and
10:57 - these are very important traits for a
10:59 - programmer number one is that you can
11:01 - think about a problem systematically and
11:04 - then solve it systematically step by
11:05 - step too
11:07 - and the number two is that you can
11:08 - envision the different inputs and
11:10 - outputs in edge cases for your problem
11:13 - because programs when you put them out
11:15 - in the wild as part of software can
11:16 - encounter any kind of inputs and
11:19 - as you have thousands or millions of
11:21 - users you will encounter any and every
11:23 - possible input
11:25 - and often this has many security
11:27 - implications it can take down the server
11:29 - it can take down your application or you
11:31 - can have a loss of data or loss of
11:33 - property
11:35 - you can communicate your ideas clearly
11:37 - to co-workers that's a very important
11:39 - part of problem solving
11:41 - and most importantly you can convert
11:43 - your thoughts and ideas into working
11:44 - code
11:45 - and the code should also be readable to
11:47 - other people so it's not really the
11:49 - knowledge of specific data structures or
11:51 - algorithms that's tested in an interview
11:53 - but it is your approach towards the
11:55 - problem so you may fail to solve the
11:57 - problem but you may still clear the
11:58 - interview or vice versa you may solve
12:01 - the problem
12:02 - and still not clear the interview so in
12:04 - this course we will focus on the skills
12:07 - to both solve the problem and to clear
12:09 - interviews successfully
12:11 - so that's why you need to learn data
12:13 - structures and algorithms
12:17 - so coming back to the problem at hand
12:19 - now you've read the problem and you may
12:21 - have been thinking about it and maybe
12:22 - you have some ideas on how to solve it
12:24 - and your first instinct might be to just
12:26 - start writing the code for it
12:27 - but that is not the optimal strategy and
12:29 - you may actually end up spending a
12:31 - longer time
12:32 - to solve the problem due to coding
12:34 - errors or you may not be able to solve
12:36 - the problem at all
12:37 - so what we are going to cover here is a
12:39 - systematic strategy that you should
12:41 - apply in interviews or in coding
12:43 - problems
12:45 - on encoding assessments or in general
12:47 - whenever you are faced with a problem
12:49 - like this
12:51 - so here's the strategy that we will
12:52 - apply step one state the problem clearly
12:56 - identify the input and output formats
12:59 - step two come up with some example
13:01 - inputs and outputs and try to cover all
13:03 - the edge cases
13:05 - step three come up with a correct
13:06 - solution for the problem it can be as
13:09 - simple as possible and state it in plain
13:11 - english
13:12 - step four
13:13 - and this is a step that is optional
13:14 - sometimes implement the solution and
13:17 - test it using example inputs and then
13:19 - fix any bugs in your in your first
13:21 - solution
13:22 - in step five analyze the algorithms
13:25 - complexity and identify any
13:26 - inefficiencies
13:28 - and finally step six
13:30 - apply the right technique to overcome
13:32 - the inefficiency and then go back to
13:34 - step three which is come up with a new
13:36 - correct solution which is also efficient
13:38 - then implement the solution and analyze
13:40 - the algorithms complexity so this is the
13:42 - technique that we will apply over and
13:44 - over for the course of
13:45 - six weeks to many different problems
13:48 - and applying the right technique is
13:50 - where the knowledge of common data
13:51 - structures and algorithms comes in handy
13:54 - so this is the method we'll be using so
13:56 - let's jump into the solution
13:57 - step one state the problem clearly
14:00 - now you will often encounter detailed
14:02 - word problems in coding challenges and
14:03 - interviews they will go on for
14:05 - paragraphs and paragraphs for instance
14:06 - here we are talking about alice having a
14:08 - deck of cards and then shuffling them
14:11 - putting them out on a table talking to
14:12 - bob etc etc etc
14:15 - the first step is to state the problem
14:17 - clearly and precisely in abstract terms
14:19 - because computers don't understand
14:22 - people computers don't understand cards
14:24 - computers understand numbers so for in
14:26 - this case we can represent the sequence
14:29 - of cards as a list of numbers so a list
14:32 - is a basic data structure in python
14:35 - and the turning over of a specific card
14:37 - is equivalent to the accessing of the
14:39 - value of the number at a certain
14:42 - position in the list for instance if we
14:44 - think of
14:45 - this set of cards being represented by
14:48 - this list
14:49 - you can see here that this list is
14:50 - sorted in decreasing order then turning
14:52 - over a certain card is equivalent to
14:54 - accessing that specific element from the
14:56 - list so turning over card number two or
14:59 - as we say in computer science card
15:01 - number one because this is card number
15:02 - zero and this is one thing that you
15:04 - might want to get into your head as well
15:06 - that whenever you're counting always
15:08 - start counting from zero otherwise you
15:10 - may run into many off by one errors
15:13 - so this is position zero and this is
15:15 - position one so if you turn over the
15:17 - card at position one it is as good as
15:19 - accessing an element from a given list
15:23 - which in this case will turn out to be
15:24 - 11. so these are the positions in the
15:26 - list starting from 0.
15:28 - and now what we have to figure out is
15:30 - how many elements do we need to access
15:32 - so we need to access the minimum number
15:34 - of elements
15:36 - to get to a particular element right so
15:38 - the problem can now be stated as follows
15:41 - we need to write a program to find the
15:42 - position of a given number in a list
15:45 - arranged in decreasing order
15:48 - we also need to minimize the number of
15:49 - times we access the elements from a list
15:52 - so we're finding the position of the
15:54 - given number 7 and the position in this
15:56 - case is 3
15:58 - and we want to minimize the
16:00 - number of times we access elements from
16:02 - the list so if we go in this direction
16:03 - for example we would need to access 13
16:06 - 11 12 and finally we discover 7 we come
16:08 - from this end we may discover 7 6 5 4
16:11 - and finally we may discover 7. so
16:13 - definitely coming from the left is
16:14 - better than coming from the right but is
16:16 - that the best
16:18 - that's what we're solving
16:20 - now once we've defined the problem and
16:22 - what you should do is you should try to
16:23 - write down the problem in your own words
16:25 - and primarily this is for you to make it
16:27 - clear to yourself uh either speak it out
16:30 - loud to the interviewer or write it down
16:32 - in your own words as short as make it as
16:35 - short as as long as possible so that you
16:37 - clearly understand what's in it and then
16:40 - come up with the inputs and the outputs
16:41 - so there are two inputs here there's the
16:43 - input cards which is a list of numbers
16:45 - sorted in decreasing order
16:47 - and then the second input is a query
16:49 - which is a number whose position in the
16:51 - array is to be determined
16:53 - and there is one output which is
16:54 - position and the position is simply the
16:56 - position of query in the list of cards
16:59 - for example seven is at position three
17:01 - counting from zero of course and as soon
17:04 - as you've written the input and output
17:06 - out you can now write what is called the
17:08 - signature of our function which is a
17:10 - structure of our function without any
17:12 - actual code inside it so now we can call
17:14 - it def locate card
17:16 - with cards and query and the single
17:19 - statement inside it called pass because
17:20 - a function in python cannot have an
17:22 - empty body you need to put in at least
17:24 - one statement so you always put in the
17:26 - pass statement first because
17:28 - it doesn't do anything
17:30 - there you go so now we have framed our
17:33 - problem
17:34 - in abstract terms
17:37 - and now we have a function signature to
17:39 - work with
17:40 - now a couple of tips here this is
17:42 - something that
17:43 - interviewers specifically will look for
17:45 - but also encoding assessments because
17:47 - your code is also shared with the
17:48 - company so you may want to name your
17:50 - functions properly and think carefully
17:52 - about the signature for example here you
17:55 - should not call your function f1 or func
17:58 - one or f or something like that it's
18:00 - better to call it locate card because
18:01 - that's what it is doing
18:03 - and the similar thing
18:04 - is true for variable names as well
18:07 - use descriptive variable names one
18:09 - because it's good for coding practice
18:11 - and second because
18:12 - as you work on the problem you may lose
18:14 - track of what a variable represents for
18:16 - example if you call this a and you call
18:17 - this b now
18:19 - 20 minutes down the line
18:21 - talking about the problem writing
18:23 - different lines of code you may forget
18:25 - what a and b represent so please call
18:26 - them what they represent even if it can
18:29 - get a little long
18:30 - and finally if you're unable to come up
18:32 - with a function signature if you're
18:34 - unable to come up with a simple
18:35 - description then discuss the problem
18:36 - with the interviewer if you're unsure
18:38 - how to frame it in abstract terms
18:41 - so keep that in mind and this is really
18:43 - the first and most important step
18:45 - which is stating the clarifying the
18:47 - problem statement and stating it clearly
18:50 - do not start coding before you have done
18:52 - this otherwise you may get halfway into
18:54 - the code and realize that you have not
18:56 - understood the problem at all
18:59 - so step two
19:01 - now we will come up with some examples
19:07 - take some example inputs and outputs and
19:09 - our goal will be to cover all the edge
19:11 - cases so before we start implementing a
19:13 - function
19:14 - we want to have some examples so that
19:16 - once we implement it the first thing we
19:18 - want to know is is it correct
19:20 - and in general the answer is no because
19:23 - coding especially when you get getting
19:25 - started is hard because you have to
19:26 - think about many different scenarios
19:29 - so and especially especially interviews
19:31 - or coding assessments are also stressful
19:33 - situations so you may not be able to
19:35 - focus and think about all the different
19:37 - things that you need to keep in mind so
19:39 - simplest way to reduce the risk of going
19:42 - wrong is to use
19:44 - a test cases
19:46 - so here's one test case that we came up
19:48 - with you know we what we've done is
19:50 - we've taken the information that we've
19:52 - listed above in the inputs and outputs
19:54 - and we've written it in as code so now
19:56 - we have a variable called cards which is
19:59 - a list of cards a list of numbers then
20:01 - we have a query which has the value 7
20:03 - and then we have the output which has
20:05 - the value three so the expected output
20:08 - from the function is three
20:10 - and once you have a test case you can
20:11 - test your function at any point anything
20:13 - you want to test you can simply pass the
20:16 - input for example cards and query into
20:18 - the locate card function and get back
20:20 - the result
20:23 - and you can see here right now because
20:24 - there's nothing inside the function the
20:26 - result you get back is none but later
20:28 - you'll start getting back a proper
20:29 - result from your function and what you
20:31 - can then do is you can compare the
20:32 - result with the output of the test case
20:34 - so in this case when we compare them
20:36 - obviously the output is 3 the result is
20:38 - none we get back false
20:42 - now one thing we will do in this course
20:44 - to make testing easier because we will
20:46 - be testing our algorithms again and
20:48 - again as we keep improving them
20:50 - is that we will represent our test cases
20:52 - as dictionaries
20:54 - so here for example this this test case
20:57 - will be represented or every test case
20:58 - will be represented as a dictionary
21:00 - containing two keys input
21:02 - and output
21:03 - and the input
21:05 - will contain one key for each argument
21:08 - to the function so if your function
21:09 - arguments are called cards and query
21:12 - in the function signature and that's why
21:14 - we wrote down a function signature first
21:16 - so that we don't get
21:18 - confused here so if your function
21:19 - arguments are called cards and query
21:21 - then we can take
21:23 - one one key called cards
21:25 - and put the value of cards there one key
21:28 - called query put the value of query
21:29 - there and then in in the output we
21:31 - simply contain
21:32 - we simply put the output that we expect
21:35 - from the function
21:36 - and now you can test this function like
21:37 - this
21:38 - so how you might want to test it first
21:41 - is maybe by actually passing values like
21:43 - this so you have test input cards and
21:46 - then test input query
21:49 - but there's a trick here whenever you
21:50 - have a dictionary so here we have a
21:52 - dictionary with two keys and we want to
21:54 - pass these two keys as two arguments to
21:56 - a function so we want to pass cards as
21:58 - the cards argument to the function
21:59 - locate card and query as a query
22:01 - argument to locate cards what you can do
22:03 - is you can simply
22:05 - put the dictionary itself
22:07 - and just write star star
22:11 - now if you write star star what python
22:12 - does is it takes the keys from this
22:14 - dictionary and the values are then used
22:16 - as arguments for
22:19 - parameters with these names
22:21 - so there we are now calling locate card
22:23 - on test input and we can compare it with
22:26 - test output
22:27 - and you can see that we get back false
22:30 - so that's one test case for us
22:33 - but is that enough is that enough for
22:34 - you to now start writing code
22:37 - probably not because
22:39 - out in the wild your function should be
22:40 - able to handle any number or any set of
22:42 - valid inputs that we pass into it
22:45 - and here are some possible variations
22:47 - that we might encounter and it really
22:49 - helps to list them in fact while i was
22:51 - writing these variations i realized that
22:53 - there are many cases that i had not
22:54 - thought of
22:56 - so even after coding for 12 15 years
22:59 - almost i still find it really useful to
23:02 - list out all the scenarios that
23:04 - we can find our input in
23:07 - so the simplest scenario is that the
23:09 - query occurs somewhere in the middle on
23:11 - the list of cards this is what you
23:12 - imagine when you read the question this
23:14 - is what is called the general case
23:16 - but then there are some special
23:17 - scenarios as well what if the query is
23:20 - the first element in cards and what if
23:22 - the query is the last element in cards
23:26 - what if the
23:27 - list cards contains just one element
23:29 - which is the query itself
23:32 - or and this is something that i had not
23:34 - thought of what if the list cards does
23:36 - not even contain the number query what
23:37 - if
23:38 - alice is bluffing
23:40 - so what should be bob's strategy then to
23:43 - figure out that the number does not
23:44 - exist
23:46 - what if the list of cards is empty
23:49 - and what if the list contains repeating
23:51 - numbers this is again another
23:52 - interesting thing that may not come to
23:54 - mind because we said a list of numbers
23:56 - and we did not specify that the numbers
23:58 - are unique so the list can contain
24:00 - repeating numbers and finally what if
24:02 - the number the query itself occurs more
24:05 - in more than one position in cards so
24:07 - those are eight cases that i could think
24:09 - of and just see if you can think of any
24:11 - more variations
24:14 - and it's likely that when you first
24:16 - heard the problem you did not think of
24:19 - all these cases
24:21 - because you often tend to just focus on
24:23 - one generic case it's hard to hold too
24:24 - many cases in mind and that's why it
24:26 - helps to list them down actually write
24:28 - them down in a coding interview or in a
24:31 - coding assessment or an interview you
24:33 - may want to put this in comments if you
24:35 - have a
24:36 - page coding page you can just create a
24:38 - comments and list out all the test cases
24:40 - and some of these
24:42 - especially things like the empty array
24:44 - or query not occurring in cards are
24:46 - called edge cases because they represent
24:48 - rare or extreme examples and while edge
24:51 - cases may not occur very frequently your
24:53 - program should be able to handle edge
24:55 - cases otherwise they may fail in
24:57 - unexpected ways or somebody with the
25:01 - with male intentions can use the edge
25:03 - cases
25:04 - to hack your software
25:08 - so let's create some more test cases for
25:10 - the variations that we've listed and
25:12 - we'll store all our test cases in a list
25:14 - for easier testing
25:16 - so here we are creating a list called
25:17 - tests and this time we will
25:20 - create all our test cases in the format
25:22 - that we discussed which is a dictionary
25:23 - format and we will keep appending them
25:25 - to our list
25:26 - now if you do not understand lists and
25:29 - dictionaries and appending then you can
25:31 - go back and review some of the basic
25:33 - material on python which is linked at
25:35 - the top of this notebook
25:37 - so first we take the one test case that
25:39 - we already have we put that and we take
25:41 - maybe one more example of the query
25:43 - occurring somewhere in the middle so
25:44 - here you can see this is the cards list
25:46 - and then the query one occurs somewhere
25:48 - in the middle although it's closer to
25:49 - one end
25:51 - then here's one case where the query is
25:52 - the first element
25:54 - four and the output obviously the output
25:56 - expected is zero here's one case where
25:59 - the query is the last element minus 127
26:02 - and this is another thing the numbers
26:03 - could be negative as well something you
26:05 - may want to keep in mind
26:09 - here's another one the weather card
26:11 - contains where cards contains just one
26:13 - element the query itself
26:16 - now the problem does not state what to
26:18 - do if the list cards does not contain
26:20 - the number query
26:22 - and you may often face these questions
26:24 - where
26:26 - it may not be clear what to do in a
26:27 - certain situation or if a certain
26:29 - situation can occur and when you have
26:30 - questions like this this is a process
26:33 - you should follow step one read the
26:35 - problem statement carefully or ask the
26:37 - interviewer to repeat the question
26:39 - so read the problem statement carefully
26:41 - and you me you will often find hints and
26:43 - sometimes these hints are just single
26:44 - number single words somewhere often you
26:47 - will also find some examples provided
26:49 - with the problem you will also find if
26:51 - you scroll down to the bottom you will
26:52 - find some conditions you will find
26:54 - limits on what the numbers can be
26:56 - whether they can be integers or can be
26:57 - decimals whether they can be negative or
26:59 - positive so it's important to read the
27:01 - problem carefully before you start
27:03 - coding
27:04 - and look through the examples
27:06 - and then ask the interviewer or maybe
27:08 - post a question on the platform for a
27:10 - clarification often it happens that
27:12 - interviewers because they take so many
27:14 - interviews they may forget to specify a
27:16 - certain detail and or they might expect
27:18 - you to ask the question because you
27:20 - should not be coding with an
27:22 - insufficient requirement so to clarify
27:24 - the specifications of the problem is
27:26 - very important so if you have any doubt
27:28 - ask the interviewer even if you are
27:30 - somewhat sure about it but just want to
27:32 - verify
27:33 - it's a good idea to ask
27:36 - then finally if you
27:39 - are
27:40 - done with all of these and you still do
27:41 - not have a solution then you just make a
27:43 - reasonable assumption state it and move
27:45 - forward
27:46 - so we will assume that our function will
27:48 - return -1 in case cards does not contain
27:51 - query
27:52 - so if cards does not contain query
27:56 - then
27:58 - we return we expect the function to
28:00 - return -1 now here's one other case
28:02 - where the card's array is empty and
28:04 - obviously then it does not contain the
28:05 - query as well
28:06 - and finally there's one last case which
28:08 - is the number itself can repeat
28:11 - in cards
28:13 - numbers can repeat in cards and then the
28:15 - query itself can repeat in cards so here
28:17 - the query does not repeat three does not
28:19 - repeat but the numbers on the
28:22 - in the cards that i do repeat
28:24 - and the last case is when the query
28:26 - itself repeats so you can see here in
28:28 - cards the query occurs many times
28:32 - once again it is not specified what to
28:34 - do here and sometimes it may be okay
28:36 - sometimes the problem statement may just
28:38 - say that return any one position but
28:41 - more likely than not what you will want
28:43 - to do is you may want to make it more
28:44 - deterministic
28:46 - and that will also make it easy for you
28:48 - to test the function so what we can say
28:50 - we can impose this additional
28:52 - restriction
28:53 - that we will
28:55 - expect our function to return the first
28:57 - occurrence of query
28:59 - and that will make it easier for us to
29:00 - test so that when we when we're testing
29:02 - our problem we we know that if we're
29:04 - getting a failure it's not because
29:08 - of multiple possible answers but it's
29:11 - because of some issue in our code right
29:13 - so you want to get good feedback from
29:15 - failures and that's why you want your
29:16 - tests to be deterministic so here is the
29:19 - final test
29:21 - and now we can see the full list of test
29:23 - cases
29:25 - so now we can see the list of test cases
29:27 - here
29:31 - so you have about eight or ten test
29:33 - cases here you may not need to create
29:34 - this many test cases in an interview or
29:36 - a coding assessment depending on how
29:38 - much time you have but you should create
29:41 - at least a few at least cover the
29:43 - three or four edge cases a good number
29:46 - to aim for would be five and this will
29:49 - not only help you in the coding
29:51 - interview help you solve the problem
29:52 - this will also be appreciated by the
29:55 - interviewer because it shows that you're
29:57 - thinking about the problem
29:59 - so definitely take a minute or two now
30:01 - we've spent 10 15 minutes talking about
30:03 - this but once you start applying this
30:06 - technique over and over you will see
30:07 - that you will start creating test cases
30:09 - in seconds so as soon as you read the
30:12 - problem and you state the problem
30:14 - find the
30:15 - find the input format find the output
30:17 - format write a function signature
30:20 - and write the test and then you will
30:21 - start working on tests the ideas will
30:23 - automatically start coming to you and
30:25 - within maybe two or three minutes you
30:27 - will be done with both all to both of
30:29 - these steps
30:32 - so great we now have a fairly exhaustive
30:34 - set of test cases
30:36 - and creating test cases beforehand
30:38 - allows you to identify different
30:40 - variations and edge cases and sometimes
30:42 - it may happen that you may have no clue
30:43 - how to work on the problem you may feel
30:45 - completely confused but if you simply
30:48 - start writing multiple test cases and
30:50 - start looking at them like literally
30:51 - list just staring at the test cases the
30:54 - question and the answer the solution
30:56 - will reveal itself to you
30:58 - so don't underestimate the power of
31:00 - writing things down
31:03 - and don't stress it don't stress out if
31:05 - you can't come up with an exhaustive
31:06 - list of test cases because this takes
31:08 - time it's a skill that you cultivate
31:10 - with time so what you can do is you can
31:12 - list out maybe the test cases that come
31:14 - to your mind right now and put them in a
31:16 - single place and keep coming back
31:17 - whenever a new test case comes to mind
31:19 - while coding or while discussing or
31:21 - while analyzing you can just come back
31:23 - to the same place and
31:25 - write down the test case the important
31:27 - thing is that you have a single place
31:28 - where you're listing all test cases
31:31 - so we've written our test cases now
31:33 - and now we can come up with a correct
31:35 - solution and how do you come up with the
31:36 - correct solution
31:37 - not by writing code but by first stating
31:40 - it in plain english so your first
31:42 - goal
31:44 - and
31:44 - by correct we do not mean the best
31:48 - or the most efficient solution
31:50 - first we want to solve the problem we
31:51 - want to figure out
31:53 - where the particular number lies in the
31:55 - list
31:56 - and not to minimize because that's
31:59 - solving two problems at once and
32:00 - sometimes that can get tricky so first
32:02 - aim for correctness then aim for
32:04 - efficiency
32:06 - and the simplest or the most obvious
32:08 - solution which almost always exists and
32:10 - is almost always very easy to see
32:13 - involves checking all the possible
32:15 - answers and this is also called the
32:17 - brute force solution so in this problem
32:20 - coming up with the brute force solution
32:21 - is quite easy
32:22 - bob can simply turn over the cards in
32:25 - order one by one till he finds the card
32:27 - with the given number on it so this is
32:29 - what this is how it might work
32:31 - if we want to implement it in code and
32:33 - this is where writing it in your own
32:35 - words becomes important
32:38 - so we create a variable called position
32:40 - inside a function with the value 0 then
32:42 - we check that the number at the index
32:45 - position in the card list
32:47 - equals query or not now if it does since
32:50 - we're starting from the beginning if it
32:51 - does then position is the answer and we
32:54 - can return it from our function but if
32:56 - it doesn't then we simply increment the
32:58 - value of position by one and then we
33:00 - repeat the steps so we go back to step
33:02 - two and then we check whether the number
33:05 - at the index position on in cards equals
33:07 - query and once again if it does we
33:10 - return position if not we increment the
33:12 - position once again and repeat and we
33:14 - repeat that till we reach the last
33:16 - position and if the number was not found
33:18 - we return -1 so it's a simple
33:21 - four-five-step description
33:23 - doesn't take very long you can either
33:25 - say it out loud to the interviewer they
33:27 - will also appreciate it that they will
33:29 - know you know you may know that you know
33:31 - the brute force solution and you may not
33:32 - say it because
33:34 - it seems too simple or obvious but the
33:36 - interview does the interviewer doesn't
33:38 - know that so it's important to state the
33:40 - brute force solution you may say that i
33:42 - the brute force solution is fairly
33:44 - straightforward and it goes like this
33:46 - steps one two three four just take 30
33:48 - seconds but at the very least it informs
33:50 - the interviewer that you're able to
33:51 - think of
33:52 - some solution
33:54 - and it happens very often i've seen it
33:57 - in interviews where
33:58 - 30 40 minutes have passed out of 45
34:00 - minutes and not a single solution has
34:02 - been proposed so far even though many
34:04 - lines of code have been written so it's
34:06 - important to state your solution and if
34:07 - you state your solution the interviewer
34:09 - will also help you and correct you as
34:11 - you go forward right so it is a
34:12 - collaborative experience it is a
34:14 - discussion so use that and if you are in
34:16 - a coding assessment you may just want to
34:18 - write out a few comments
34:21 - and what we've
34:22 - implemented here is congratulations is
34:25 - just our first algorithm and an
34:27 - algorithm is simply a list of statements
34:29 - a list of
34:30 - steps that can be converted into code
34:33 - and executed by a computer on different
34:35 - sets of inputs
34:40 - so
34:41 - this particular algorithm
34:43 - is called linear search because it
34:45 - involves searching through a list in a
34:48 - linear fashion element by element
34:55 - so now we're ready to implement the
34:57 - solution
34:58 - and just a quick tip
35:00 - as i've already said always try to
35:02 - express the algorithm in your own words
35:05 - and it can be as brief or as detailed as
35:07 - you like
35:09 - and don't underestimate the power of
35:10 - writing writing can be a great tool for
35:12 - thinking it's likely that you will find
35:14 - that some part of the solution is
35:15 - difficult for you to express and that
35:17 - simply suggests that you are probably
35:19 - unable to think about that part clearly
35:21 - so the most more clearly you are able to
35:23 - express your thoughts the easier it will
35:25 - be for you to turn it into code and you
35:27 - will not have to come up with a strategy
35:30 - while you're writing the code so you can
35:32 - focus on coding and focus on avoiding
35:33 - errors
35:35 - and that brings us to the next step
35:37 - implement the solution
35:40 - and then test it using the example input
35:42 - so now you can see how everything comes
35:44 - together
35:45 - we've already know what the function
35:47 - signature looks like what the inputs
35:49 - look like we already have some test
35:51 - cases and through the test cases we've
35:52 - also identified what are the different
35:54 - edge cases we need to handle and we've
35:56 - already written out a description a
35:57 - rough description of what the algorithm
36:00 - looks like and in fact what you can do
36:02 - is you can simply write out comments
36:03 - within your function
36:05 - as the english description then you
36:07 - simply need to fill out code for those
36:08 - comments so for instance here are the
36:10 - five steps that we have just written
36:12 - down create a variable position with the
36:14 - value zero set up a loop check if the
36:16 - element is matches the query
36:18 - if yes the answer is found if not
36:20 - increment the position
36:21 - and then go back and then check if
36:23 - you've reached the end of the array if
36:26 - we have then we return -1
36:29 - so then the code now is pretty
36:31 - straightforward we create the position
36:33 - variable 0
36:35 - we set while true so while true kicks
36:37 - off a loop and we just want to first set
36:39 - up a loop and then we can break out of
36:41 - it when we need to
36:42 - then we check if the element at the
36:46 - value position matches the query if it
36:48 - does we return the position if it
36:50 - doesn't so if it doesn't then this we
36:53 - come to this part if it does then we say
36:54 - the function exits and none of this code
36:56 - gets executed but if it doesn't then we
36:59 - increment the position
37:00 - and then we check if we have reached the
37:02 - end now if you have the hdn obviously we
37:04 - don't want to continue so
37:06 - we can simply return minus one and exit
37:08 - the loop and exit the function itself
37:11 - but if it if we have not reached the end
37:14 - then we go back to the top of the loop
37:15 - and now position starts out with value
37:17 - one so we check value zero one two three
37:19 - so on up to the end of the array
37:22 - simple enough
37:23 - great so now we have our first function
37:26 - and let's test our function with the
37:27 - first test case
37:29 - so here's our test case once again
37:32 - and we can simply call
37:33 - locate card with the test input and the
37:36 - test the cards in the query
37:38 - and this is the result we get and you
37:40 - can already see that the result matches
37:42 - the output and that's why when we
37:43 - compare them we get the value true
37:46 - so yeah the results match the output and
37:49 - because this is something that you
37:50 - should be doing very often in this
37:52 - course we have put together a small
37:54 - function for you within the jovian
37:55 - python library so the jovian platform
37:57 - also offers a python helper library that
38:00 - is
38:01 - that contains some utility functions so
38:03 - we've put together a small function for
38:05 - you called evaluate test case and you
38:07 - can write it on your own as well but you
38:09 - can use this library version so let's
38:11 - install the library we will install
38:14 - the jovian library using pip install
38:16 - jovian minus minus upgrade
38:19 - and then from jovian.python dsa so joven
38:22 - is the name of the library and then
38:23 - inside the joven library since we have
38:25 - many courses the python dsa course the
38:27 - utilities for this course are present
38:29 - inside the python dsa module
38:31 - from that module we import the function
38:33 - evaluate test case
38:36 - and finally we can
38:37 - call evaluate test case and then we can
38:39 - give it the function that we want to
38:40 - test so you know test the locate card
38:42 - function and the test case the test case
38:44 - needs to be defined in this format
38:47 - so all it is going to do is it is going
38:49 - to pick out the input pass it into the
38:51 - function
38:52 - get the output compare that output
38:54 - with the expected output and also print
38:57 - some information for you to see
39:00 - so here's what it does it prints out the
39:02 - input
39:03 - it prints out the expected output
39:06 - it prints out the actual output
39:08 - it prints the execution time
39:10 - and
39:11 - this is something that will become
39:13 - important later and it tells you whether
39:14 - the test has passed or not
39:16 - so it's nice to have this you know
39:18 - because so we don't have to look through
39:20 - the output
39:21 - and input and compare them especially
39:23 - when you are
39:24 - in a situation where you need to think
39:26 - fast it's helpful to create a small
39:28 - function that can just print pass or
39:30 - fail for a test case
39:33 - so now while it may seem like we have a
39:35 - working solution because our test case
39:37 - has passed we can't be sure about it
39:39 - until we test the function with all the
39:41 - test cases
39:42 - so for doing that we can use the
39:44 - evaluate test cases function so just as
39:46 - you have evaluated test case you have
39:48 - evaluate test cases
39:50 - also part of the jovian library
39:52 - and you can call evaluate test cases
39:54 - with the same function locate card and
39:56 - this time pass it a list of test cases
39:58 - each of the test cases is a dictionary
40:01 - again you don't have to use this
40:03 - function you can simply put things into
40:05 - a loop so you can always just do for
40:07 - test in tests
40:09 - and then simply call evaluate test
40:12 - with locate card
40:14 - and test or you can even just directly
40:16 - call
40:18 - locate card
40:19 - with
40:21 - the test
40:23 - inputs
40:29 - and the test out and compare the output
40:31 - with the test output right so you can do
40:34 - this as well and you can simply print
40:35 - that
40:36 - so here's a simple way to do this what
40:38 - we are doing here
40:42 - but what we'll do is we'll use the
40:43 - evaluate test cases function because it
40:45 - prints out a lot of useful information
40:47 - for us
40:48 - so now you can see that it prints out
40:50 - case case by case now test k0 we have
40:52 - input expected output actual output
40:55 - the
40:56 - case has test cases passed that's what
40:57 - we saw it in fact it's the same test we
40:59 - just did
41:00 - test case one passes as well test case
41:02 - two passes test is three four five six
41:05 - okay all of them are fine okay test case
41:07 - six seems to have caused an error so
41:10 - here is the error it says list index out
41:12 - of range
41:13 - so that's okay it's perfectly all right
41:15 - for your functions to encounter an error
41:18 - so the first thing the most important
41:20 - thing is not to panic
41:22 - in fact it's a good thing that we know
41:24 - exactly where the function is failing if
41:26 - you look back here you can see what the
41:27 - issue is and then we'll see how to fix
41:29 - the error but one one good strategy to
41:32 - approach this is to keep in mind that
41:36 - there will always be bugs in your code
41:38 - and
41:39 - approach
41:40 - writing code not with the assumption
41:42 - that your code will be correct but go
41:44 - with the default assumption that your
41:45 - code will be wrong that there will be
41:47 - issues what that lets you do is one you
41:50 - do not feel
41:51 - demotivated or you do not panic when you
41:54 - see an error and second you then tend to
41:57 - be a little more careful while actually
41:59 - writing the code so the way you should
42:00 - be writing code is every time you write
42:02 - a line of code you should be asking
42:03 - yourself
42:04 - how can this line of code go wrong
42:07 - or in this particular case how can
42:09 - card's position equals equals query in
42:12 - an if statement go wrong and throw an
42:14 - error
42:15 - and let's look at it one easy way to
42:17 - check this is to add what is called a
42:20 - logging or what is called printing the
42:23 - information inside a function so we'll
42:25 - just rewrite our function
42:27 - in in our locate card function we will
42:29 - put in cards and we will written query
42:31 - the exact same function that we have
42:33 - we'll set the position
42:34 - but before we create the value we'll
42:36 - simply print the cards in the query so
42:38 - just for our information just so that we
42:40 - can see what the function is working
42:41 - through we can get some visibility into
42:42 - the function we print out cards and
42:44 - query and then while
42:46 - true so this is the same loop
42:48 - at the beginning of the loop we will
42:49 - print out the position that we are
42:51 - tracking
42:52 - okay so let's do that we've simply added
42:54 - some print statements and this print
42:56 - statement will
42:57 - give us an insight into the inner
42:59 - working of the function now if you do
43:01 - not put in a print statement then you
43:02 - will have to work it out yourself by
43:04 - reading the code and executing it in
43:06 - your head it's always easier to just
43:08 - print all the all the information and
43:10 - then print it nicely just say cards and
43:12 - query you know we could also have done
43:14 - this without saying cards here but then
43:16 - that would make it a little harder to
43:18 - read then that would be more cognitive
43:20 - overload apart from already dealing with
43:22 - the stress of solving an error right so
43:24 - just add nice pretty print statements to
43:27 - make it very obvious what we are
43:28 - printing
43:30 - so let's see now let us get the test
43:33 - case out so let's get from test 6 get
43:35 - the input get the cards get the query as
43:38 - well and pass it into locate card
43:40 - and now we see that initially the cards
43:42 - array is empty
43:44 - and the query is seven
43:46 - and the position is zero
43:48 - and then we encounter an error we
43:50 - encounter the error list index out of
43:52 - range
43:53 - on the line cards position
43:56 - equals equals query and now at this
43:58 - point it should be fairly obvious what
44:00 - the issue is the issue obviously is that
44:02 - we have an empty list an empty list has
44:04 - no elements but we're trying to access
44:06 - the position 0 which is
44:08 - in
44:09 - normal human conversation the first
44:10 - element of a list
44:13 - but there is no first element to access
44:14 - and that is why we get the error list
44:16 - index out of range
44:18 - so this is very important whenever you
44:19 - get an error do not try to start looking
44:22 - at the code first just try to understand
44:24 - the error first and if you're unable to
44:27 - understand the error just add some print
44:29 - statements there are tools like
44:30 - debuggers that people use but i
44:32 - personally in 15 years haven't used a
44:34 - debugger i maybe used it a couple of
44:36 - times but i don't know how to use it
44:38 - print statements are really simple you
44:40 - just put them in
44:41 - chuck them into the function wherever
44:43 - you need them as many print statements
44:45 - as you need with nice clear messages
44:47 - make it very obvious
44:49 - and that will
44:50 - almost certainly solve the issue for you
44:53 - so the cards area is empty we cannot
44:55 - access position zero so what's the
44:57 - solution here the solution obviously is
44:59 - that before we access anything from
45:02 - a list we need to make sure that we can
45:05 - access that list
45:07 - and this is the way to do it so now
45:08 - we've rewritten our function slightly we
45:11 - once again start out with position 0 but
45:12 - this time instead of putting in a while
45:14 - true instead of assuming that we can
45:16 - access the zeroth element
45:18 - of the list we say that
45:20 - the position should be less than the
45:22 - length of cards now if you have a cards
45:25 - list of n elements
45:27 - the indices go from zero to n minus one
45:30 - or in the case of zero elements there
45:32 - are no indices to access
45:34 - so
45:34 - the position
45:36 - has to be less than the length of cards
45:37 - for you to be able to access it and in
45:39 - this case the length of the cards will
45:40 - be zero so zero is not less than zero so
45:43 - the while loop will not run at all and
45:45 - we will directly return -1
45:47 - but if the card does have elements then
45:50 - we can check the element at the value
45:53 - position compare it to the query and
45:55 - return the position
45:57 - if it does not if it does not match the
45:59 - query we can increment the position
46:02 - so that was a fairly straightforward fix
46:04 - easy save
46:06 - so let's test the failing case again
46:10 - great so looks like the failing case is
46:12 - now passing because we have output minus
46:14 - one and
46:15 - the expected output matches the actual
46:17 - output of the function minus one because
46:20 - the query does not exist in the
46:22 - array which is empty of course
46:25 - now this is not enough it is every time
46:27 - you make a change to the code you want
46:29 - to go back and test all the test cases
46:31 - because what have what may happen is
46:33 - while fixing one error you may introduce
46:35 - another error and that is where having a
46:37 - good set of test cases is very important
46:40 - so let's run evaluate test cases once
46:42 - again you can see here this time that
46:44 - all the test cases are passing
46:47 - and it's just nice to
46:48 - it just makes you feel good as well
46:50 - makes you feel motivated as well to see
46:52 - that a bunch of test cases are passing
46:57 - now in a real coding assessment or a
47:00 - real interview you can probably skip the
47:02 - step of implementing and testing the
47:04 - brute force solution in the interest of
47:06 - time
47:07 - because it may take about five to ten
47:09 - minutes to implement the solution and
47:11 - then if you have errors in the solution
47:12 - it may take some more time to fix those
47:14 - errors so it's generally
47:17 - quite easy to figure out the complexity
47:19 - which we'll talk about in a second of
47:21 - the brute force solution from the plain
47:23 - english description and that is why you
47:24 - should first state it in plain english
47:26 - which only takes
47:28 - around 20 seconds or so and
47:30 - the computer doesn't throw errors at you
47:32 - for speaking so you can just state the
47:34 - plain english description and move on
47:37 - talk about the complexity and start
47:38 - optimizing it but while you're
47:40 - practicing
47:41 - always always
47:43 - implement the brute force solution too
47:45 - and there's an important reason why you
47:47 - should know how to implement the brute
47:48 - force solution because in case you're
47:50 - not able to figure out the optimal
47:52 - solution to the problem
47:54 - you can still go back and implement the
47:55 - brute force solution and in a lot of
47:57 - cases that's okay sometimes interviewers
47:59 - ask hard questions just to push your
48:01 - boundaries a little bit but if you're
48:03 - unable to figure out the optimal
48:05 - solution then they will allow you to
48:08 - implement a brute force solution so that
48:09 - is why you should state it and that is
48:11 - why you should know how to implement it
48:15 - okay
48:16 - so we are done with
48:19 - so we're done now with
48:22 - the implementation of our brute force or
48:24 - simplest solution
48:26 - and now we need to analyze it
48:28 - and this is where we'll now learn about
48:30 - what is called the complexity of an
48:32 - algorithm what does it mean now recall
48:35 - the statement from the original question
48:37 - alice challenges bob to pick out the
48:38 - card containing the given number by
48:40 - turning over as few cards as possible
48:43 - but right now what we're doing is we can
48:44 - say we're simply turning over cards one
48:45 - by one and before we talk about what
48:49 - does it mean to minimize the number of
48:50 - times we turn over cards or the number
48:52 - of times we access elements we need a
48:54 - way to measure it and let's think about
48:57 - it you know it's it's as simple as just
48:58 - thinking about it since we access the
49:00 - list element once in every iteration so
49:02 - here's the code
49:04 - our code is pretty straightforward and
49:06 - this is where we are accessing an
49:07 - element from the list
49:09 - so since we access the element
49:14 - since we access the element once
49:17 - in every iteration
49:18 - for a list of size n
49:21 - we access the elements
49:23 - from the list up to n times because we
49:25 - may have to access this element and then
49:27 - this element and this element and so on
49:31 - so bob may need to overturn up to n
49:33 - cards in the worst case to find the
49:35 - required card
49:36 - now let's introduce an additional
49:38 - condition that suppose bob is only
49:39 - allowed to overturn one card per minute
49:41 - so that means it may take him 30 minutes
49:43 - to find the required card in the worst
49:45 - case if 30 cards are laid out on the
49:47 - table
49:48 - now is this really the best he can do
49:51 - or is there a way for bob to arrive at
49:53 - the answer by turning over just five
49:55 - cards and save 25 minutes instead of
49:57 - turning over all 30
49:59 - and this field of study and
50:02 - by the way bob in this case
50:04 - is represented of what our computer does
50:07 - and a computer takes some amount of
50:09 - finite time to perform each instruction
50:11 - so each array access actually takes some
50:13 - time although it's so fast that we do
50:15 - not see it especially for small inputs
50:18 - but this is something that will become
50:20 - increasingly important as we go week
50:21 - over week where we see that
50:24 - we will start to see the limits of how
50:26 - long it takes computers to solve certain
50:28 - problems
50:30 - so the field of study concerned with
50:31 - finding the amount of time or the amount
50:33 - of space or the amount of other
50:35 - resources required to complete the
50:36 - execution of a program is called the
50:38 - analysis of algorithms and the process
50:41 - of figuring out the best algorithm to
50:42 - solve a problem is called algorithm
50:44 - design and that is what we are doing
50:46 - here we are actually doing the analysis
50:48 - of algorithms right now and algorithm
50:50 - design next
50:53 - so there are a couple of terms we need
50:55 - to understand and then we will go back
50:57 - to writing code
50:58 - first thing is complexity and the second
51:00 - thing is the big o notation and both of
51:02 - these are terms that you will hear very
51:04 - frequently in
51:05 - when you're talking about data
51:06 - structures and algorithms when you're
51:08 - talking about coding interviews
51:10 - assessments
51:12 - so these are terms that you need to
51:13 - understand and they're fairly simple
51:15 - terms although
51:17 - the term itself is complexity but all it
51:19 - means
51:20 - is that the complexity of an algorithm
51:22 - is simply a measure some some measure of
51:24 - the amount of time or space required by
51:27 - an algorithm
51:30 - to process an input of a given size
51:32 - example if you have a list of size n
51:36 - then the complexity is the amount of
51:37 - time required or the amount of space
51:39 - required on the ram to process an input
51:42 - of that size
51:44 - now unless otherwise stated the term
51:46 - complexity always refers to worst case
51:48 - complexity so
51:50 - it's possible that the bob turns over
51:52 - the first card and that is the answer
51:54 - but we always talk about what is the
51:55 - longest or the highest possible time or
51:57 - space that may be taken by the program
51:59 - to process an input right so we need to
52:01 - design our programs keeping the worst
52:04 - case in mind
52:05 - now in case of a linear search which is
52:07 - what we've implemented just now the time
52:10 - complexity of the algorithm is some
52:12 - constant c times n assuming n is the
52:15 - size of the list
52:17 - n is the number of cards
52:18 - right so now this constant c obviously
52:20 - depends on the number of operations that
52:22 - we perform in each iteration so in each
52:24 - loop for example we have four to five
52:26 - statements
52:27 - and then the time taken to execute a
52:30 - statement on your specific hardware now
52:32 - if you have a two gigahertz computer
52:34 - that may be twice as fast as a one
52:35 - gigahertz computer if you're running it
52:37 - on a phone it may be different so the c
52:39 - captures all of these things so
52:41 - information about the number of specific
52:43 - operations that we perform in each
52:45 - iteration and information about
52:47 - the actual hardware that you're running
52:49 - on
52:51 - so cn is the time complexity and n is
52:54 - the size of the input so in some sense
52:56 - what we understand from this is that the
52:57 - time complexity is proportional to the
52:59 - size of the input and that's the
53:01 - important part here the constant you
53:02 - know it doesn't change as you change the
53:04 - input the constant doesn't really change
53:07 - now similarly the space complexity now
53:09 - since we are already given an array the
53:11 - additional space that our linear search
53:13 - requires
53:14 - is simply a single constant when we are
53:17 - calling it c prime or c dash
53:19 - and it is independent of n so no matter
53:22 - how many uh no matter how large a list
53:23 - is given to you and the list is already
53:25 - present in memory we just need to
53:27 - allocate one new variable called
53:28 - position and that variable is used to
53:31 - iterate through the array and it
53:33 - occupies a constant space in the
53:34 - computer memory because we keep go on
53:36 - updating the variable right so the space
53:38 - complexity is c or constant it is
53:40 - independent of n
53:42 - now
53:44 - what we do normally is to represent the
53:47 - worst case complexity we often use the
53:49 - big o notation
53:51 - and in the big o notation what we do is
53:52 - we drop any fixed constants
53:56 - and we lower the powers of the and we
53:59 - drop any fixed constants and we drop any
54:01 - lower powers of variables so
54:04 - the idea here is to capture just the
54:06 - trend just the trend of the relationship
54:08 - between the size of the input and the
54:10 - complexity of the algorithm for example
54:12 - if the time complexity of an algorithm
54:14 - is some constant times n cube plus some
54:16 - constant times n square plus some
54:18 - constant time n plus some constant
54:21 - where n is the size of the input in the
54:23 - big o notation we simply say that it is
54:25 - order of n cube
54:27 - which is that you know in the long run
54:29 - in the if you just study the trend it
54:31 - the trend will be
54:33 - some
54:34 - something which looks a little bit like
54:35 - the n cube function and it may be offset
54:38 - by a constant or such
54:41 - so putting it this way the time
54:42 - complexity of linear search is order n
54:45 - because we just drop the constant c and
54:47 - the space complexity is order one so we
54:50 - again drop the constant c prime
54:53 - and we'll see why it's okay to drop the
54:55 - constant sometimes you may find that
54:57 - okay we're not exactly doing n
54:58 - iterations but we're doing n minus one
55:00 - iteration so we drop the minus one
55:02 - sometimes you'll find that we are just
55:03 - doing n by two iterations and that's
55:05 - simply half of n so we drop the half
55:07 - and you might wonder that okay that that
55:09 - might take twice or three times the
55:11 - amount of time how why are we dropping
55:12 - that constant because that's probably an
55:14 - important thing to keep in mind but
55:16 - we'll see we'll see soon as we implement
55:18 - our efficient solution to the problem
55:23 - so before we move forward before we
55:25 - optimize the algorithm
55:27 - we are just going to save our work
55:29 - because this notebook as i mentioned to
55:32 - you is
55:33 - running on an online platform we've set
55:35 - up everything for you you've not had to
55:36 - install anything but because thousands
55:38 - of people are using this
55:41 - using this platform this will shut down
55:43 - this will not keep running forever and
55:46 - what you need to do is you need to save
55:47 - your work from time to time
55:49 - and here is how you can save your work
55:51 - and then pick it up everything happens
55:52 - on the jovian platform there's no need
55:54 - to download anything although you could
55:56 - download it if you want but you there's
55:58 - no need to download anything so all you
55:59 - need to do is use the jobin library once
56:02 - again we've got another helpful function
56:04 - for you so you say import jovian and
56:06 - then run jovian.commit so you run
56:09 - joven.commit and then give it a project
56:11 - name the
56:13 - project name
56:14 - by which you want to identify this
56:16 - specific notebook
56:18 - and then there are some other arguments
56:20 - it's not too important so you can even
56:22 - skip this and that should be perfectly
56:24 - fine
56:25 - so now when you run jobin dot commit
56:27 - we will capture a snapshot of your
56:29 - notebook
56:30 - from this online platform
56:32 - or wherever it is running even if you're
56:34 - running it on your own computer we will
56:35 - capture a snapshot of your notebook from
56:38 - your computer
56:39 - wherever it's running and we will upload
56:41 - it and give you a link where you can
56:43 - access it
56:44 - so let's open up this link here
56:46 - so now you will be able to see this page
56:50 - called python binary search and it will
56:51 - be on your profile
56:54 - and you can see you can scroll down and
56:55 - see that it contains all the
56:56 - explanations and it contains all the
56:58 - code so this is a read-only version of
57:01 - the jupyter notebook so the read-only
57:02 - version of the jupyter notebook
57:03 - obviously does not require us to keep
57:05 - servers running so that you can run this
57:07 - code and when when you need to run it
57:09 - you know your work is saved to whatever
57:11 - extent you have executed things and now
57:14 - when you need to run it you simply click
57:15 - run
57:17 - and then click run on binder once again
57:24 - okay so and that is how you resume your
57:26 - work so what this will do is this will
57:28 - set up a new machine for you and on the
57:30 - new machine it will post the jupyter
57:31 - notebook
57:33 - and it will start up the machine for you
57:35 - open up the jupyter notebook and you
57:36 - will be able to start running the code
57:38 - and not just you now you can make your
57:40 - notebooks public or you can keep them
57:41 - private you have multiple viewership
57:43 - options so you're public and private not
57:46 - just you but anybody else so you can
57:47 - take this link
57:49 - and
57:50 - tweet it out
57:51 - if there's an interesting problem that
57:53 - you worked on you want to tweet it out
57:54 - you can just share this link online and
57:56 - anybody will be able to read through
57:57 - your solution
57:59 - and they can run it as well right in
58:01 - fact the notebook that i have shared
58:02 - with you is hosted on my profile so
58:04 - jovin is not just a platform for you to
58:07 - learn it's also a platform for you to
58:09 - build a repository of projects now if
58:10 - you go back to your profile you click on
58:12 - your profile or click on the jovian logo
58:15 - and you can see here that you will find
58:17 - a notebooks tab and in the notebooks tab
58:19 - you will find all the notebooks that you
58:21 - have worked on in the past okay so
58:23 - anything that you have committed using
58:24 - juventus comment you will be able to
58:26 - resume working on it
58:29 - so that's uh that's how you
58:32 - save your work and keep saving your work
58:34 - from time to time all you need to do is
58:35 - run jobian.comit you do not even need to
58:37 - put in this project argument this is
58:39 - just something if you want to actually
58:40 - give your project a name otherwise the
58:42 - name will be picked automatically so
58:44 - just keep running jovian.com from time
58:45 - to time especially if you're leaving
58:47 - your computer for half an hour or so
58:49 - then and your computer get goes to sleep
58:51 - then this server will shut down and you
58:53 - may lose your work coming back to our
58:55 - problem
58:55 - we've just implemented linear search and
58:58 - we understood that it has the complexity
59:01 - of order n which is
59:02 - and that's why it's called linear it
59:04 - runs in a linear time is another
59:06 - expression that is used it is also
59:08 - called linear because we are going
59:10 - through the array step by step
59:14 - now the next step is to apply the right
59:16 - technique to overcome this efficiency
59:18 - now of course we've not learned any
59:20 - techniques yet but we can probably
59:21 - figure it out if you think about it and
59:22 - maybe this is something that occurred to
59:24 - you right at the beginning and
59:26 - the idea that occurred to you is
59:27 - something that we will now
59:30 - implement so at the moment we are simply
59:32 - going over the cards one by one and not
59:34 - even utilizing the fact that they are
59:36 - sorted and that's why our approach is
59:38 - pretty poor we're basically checking
59:40 - everything
59:42 - so it's not a great solution but it
59:44 - would be great if somehow this would be
59:46 - the this would be the best case if
59:48 - somehow bob realized somehow bob could
59:51 - guess the card at the first attempt
59:55 - that would be perfect then that would be
59:56 - an order one
59:58 - that would be a constant time solution
60:00 - but
60:01 - with all the cards turned over it's
60:02 - simply impossible to guess the right
60:04 - card
60:06 - now the next best idea is to maybe pick
60:08 - a random card so maybe let's say bob
60:10 - picks this card
60:11 - and this card turns out to be a nine
60:16 - now bob can use the fact that the cards
60:18 - are in sorted order so if this card
60:19 - turns out to be nine that means all of
60:21 - these cards
60:23 - have numbers greater than nine and the
60:25 - target card is seven so the target card
60:27 - cannot lie in this region
60:30 - so the target card has to lie in this
60:32 - region and just by picking a random card
60:34 - rather than picking the first card
60:36 - bob has eliminated
60:39 - four out of seven cards to be checked
60:41 - right so with one check bob has
60:43 - eliminated a total of five cards one two
60:46 - three four five and of course if this
60:47 - number turns out to be seven perfect
60:49 - great guess but even if it doesn't we've
60:51 - still eliminated quite a few if this
60:53 - number turns out to be less than seven
60:55 - we've still eliminated three cards
60:57 - so that's the basic idea here that we
61:00 - pick something
61:01 - not from the edges but somewhere in the
61:03 - middle now what is the best place to
61:05 - pick something in the middle now
61:06 - obviously when we are picking a card we
61:08 - do not know whether it is going to be
61:10 - less than or greater than the number
61:12 - that we want
61:13 - especially when everything is close so
61:15 - we it's best to just pick the middle
61:17 - card so that whichever case turns it
61:20 - turns out to be
61:22 - we're still left with ads
61:24 - at most three cards to process right so
61:27 - if you pick this card and it doesn't
61:28 - turn out to be seven you either need to
61:30 - look at these three or you need to look
61:32 - at these three
61:34 - so that is the strategy we'll follow
61:36 - and this technique is called binary
61:38 - search
61:39 - and why do it just once
61:41 - just keep repeating it so each time you
61:43 - pick the middle card and you can
61:45 - eliminate half of the array
61:47 - and this is what the strategy looks like
61:49 - so here we have the array
61:51 - and in the array we want to figure out
61:53 - the number six so the slightly different
61:55 - problem but still decreasing order we
61:57 - want to figure out the number six so we
61:59 - access the middle element
62:00 - okay we compare it with six now it is
62:02 - not six okay it was a bad guess no
62:05 - problem but we know that four is less
62:07 - than six so that means that six lies to
62:10 - the left of four so we've
62:12 - suddenly eliminated half of the array
62:15 - we've done one access and eliminated
62:16 - half of it and now we're left with three
62:18 - numbers we pick the middle number
62:21 - we get seven
62:23 - seven is greater than six that means the
62:25 - number lies on the right now we are left
62:27 - with just one card we overturned that
62:29 - last card or we checked that last number
62:31 - okay it is equal to six great if it is
62:33 - not
62:34 - well nothing more left to check all the
62:36 - numbers here are greater than 6 are less
62:38 - than 6 and all the numbers before this
62:40 - are greater than 6. so if this number
62:42 - isn't 6 then there's no 6.
62:45 - and just like that for an array of
62:48 - seven elements we have done just three
62:50 - checks and arrived at the answer and
62:52 - that was the worst case right it mean it
62:54 - will never take you can verify that it
62:56 - will never take more than three checks
62:57 - if six comes at this position we guess
62:59 - it immediately if six comes at this
63:01 - position or this position we guess it in
63:04 - two checks and then if six comes at any
63:06 - of the other positions we will guess it
63:07 - in three checks
63:09 - so that's pretty good
63:12 - and now the idea if you if you read this
63:15 - part it says
63:16 - apply the right technique to overcome
63:18 - the inefficiency and then repeat the
63:20 - steps three to six so now we're going to
63:21 - go back to step three which was come up
63:23 - with a correct solution for the problem
63:25 - and stated in plain english and we have
63:27 - come up with a solution already we just
63:28 - need to state it so here is how this
63:30 - technique called binary search is
63:31 - applied to the problem it's called
63:33 - binary because
63:35 - well we take a left and right decision
63:37 - so
63:38 - first we find the middle element of the
63:40 - list
63:41 - if it matches the query number then we
63:43 - return the middle position as the answer
63:46 - and if it is less than the queried
63:48 - number
63:49 - then we search the first half of the
63:51 - list
63:52 - and if it's greater than the query
63:53 - number then we search the second half of
63:54 - the list so the exact thing that we saw
63:56 - here
63:57 - we apply it here
63:59 - and finally if no more elements remain
64:01 - we simply return -1
64:04 - so let's just save our work now let's
64:06 - from this point on we'll keep saving our
64:07 - work from time to time using
64:09 - jovian.commit so now we've come up with
64:11 - the algorithm and you can
64:13 - again it's important to write it in your
64:15 - own words
64:16 - whether you want to write a short
64:18 - description a paragraph or a step by
64:20 - step guide but write it in your own
64:21 - words and you'll do this in the
64:23 - assignment
64:26 - so let's implement the solution now and
64:28 - test it using the example inputs so
64:30 - here's the implementation so what we'll
64:32 - do is
64:34 - we will look at once again let's go back
64:36 - to this visual representation and we
64:38 - will keep a track of our search space so
64:40 - current initially our search space is
64:42 - the entire array so that means we have
64:44 - an array of seven numbers so our search
64:46 - space goes from position zero to
64:48 - position six
64:49 - and slowly we'll keep reducing our
64:51 - search space over time so to keep track
64:53 - of the search space we will create two
64:55 - variables low and high
64:57 - low will have the value 0 which is it
64:59 - will point to the first position in the
65:02 - array and high will have the value
65:06 - pointing to the last position last valid
65:08 - position in the array which is
65:10 - which is len cards minus one
65:14 - so while low
65:16 - and then the while loop becomes very
65:18 - simple because as long as we have at
65:20 - least one element in our search space we
65:23 - can go ahead now to have at least one
65:25 - element in a search space
65:28 - the low value which is the starting
65:29 - index
65:30 - should
65:32 - be less than or equal to the end value
65:35 - right so while low is less than equal to
65:37 - high because if the starting index is
65:39 - higher than the
65:41 - end index basically we've exhausted and
65:43 - we've covered the entire list
65:46 - and there's nothing more that we can
65:47 - search for so we should exit at this
65:49 - point okay so now once we have uh once
65:52 - this condition is satisfied and it is
65:54 - initially let's say you have seven cards
65:55 - lower zero
65:57 - cards is uh len cards minus one is six
66:00 - then you find the middle position and
66:02 - you can get the middle position by doing
66:04 - low plus i divided by two
66:06 - and now let's start applying that
66:08 - strategy here where we say that every
66:10 - time we write a line of code we should
66:12 - think about how it can go wrong now if
66:14 - you write it like this low plus high
66:16 - divided by two
66:18 - and think about how it can go wrong okay
66:20 - low plus high may not be divisible by 2.
66:22 - if low plus is not divisible by 2 you
66:24 - may end up with a decimal number now if
66:26 - you do end up with a decimal number in
66:28 - fact
66:29 - the division operator in python always
66:32 - retains a floating point number
66:34 - then you cannot use it as an array index
66:36 - because we want to use this as a
66:37 - position within the array so that's why
66:39 - we need the double slash which is the
66:42 - which is the integer division which
66:43 - simply returns the quotient
66:46 - so we get the middle position
66:48 - and then we get the number at the middle
66:50 - position so we also get cards made so we
66:52 - access that element from the array now
66:54 - this is where we it makes it easy for us
66:56 - to count the number of times we access
66:58 - because here is one axis happening
66:59 - inside the list and there are no other
67:01 - accesses then we get the mid number and
67:04 - remember
67:06 - last time we faced an error and we had
67:07 - to add print statements
67:09 - you might as well just add print
67:10 - statements right away
67:13 - so here's what you can do we can just
67:15 - print the value of low the value of high
67:17 - the value of mid and the value of mid
67:19 - number what this will do is this will
67:21 - help you check
67:22 - whether the number is working as expect
67:24 - whether the function is working as
67:25 - expected or not so now here comes the
67:29 - actual check and the meat of the problem
67:31 - if the middle number matches the query
67:33 - then we return the middle number great
67:36 - we found it well done
67:38 - now if the middle number is less than
67:40 - the query now remember the elements are
67:42 - in sorted array and we are looking for
67:44 - the number
67:45 - query
67:47 - now the middle number is less than the
67:48 - query
67:51 - so that means the query probably lies to
67:53 - the left of it because the query
67:55 - because the elements are in a decreasing
67:57 - order
67:58 - right
67:59 - so if
68:00 - the query lies to the left of it so then
68:02 - we need to search we decrease the search
68:04 - space from the beginning
68:07 - to the position just before the middle
68:09 - number right
68:11 - so what we can do is we can simply set
68:12 - high to mid minus one
68:15 - on the other hand if mid number is
68:17 - greater than query
68:19 - so that means because of the decreasing
68:21 - order of the array the query lies to the
68:22 - right now we need to move the starting
68:25 - of the search space to beyond the middle
68:27 - number so we simply said low to mid plus
68:29 - one
68:30 - and that's it and you can see that we've
68:32 - written a we've used if lf lf loop here
68:35 - so lf stands for elsif in python
68:39 - and here the last condition could might
68:41 - as well just have been else because
68:43 - there are only three possibilities
68:44 - either they're equal or mid number is
68:46 - less or it's greater but sometimes it's
68:48 - nice to list out all possibilities just
68:50 - to make it super clear and it makes it
68:52 - easy for you while debugging fixing
68:54 - issues as well okay
68:56 - so that's our binary search
68:59 - based
69:00 - algorithm and finally when we exit out
69:01 - of the loop
69:02 - if you have not returned the middle
69:04 - number if you have not exited the
69:06 - function yet then we return -1 that the
69:08 - number was not found
69:10 - so let's test it out using our test
69:11 - cases
69:13 - and we have our handy evaluate test
69:14 - cases function here but you can also
69:16 - test it manually if you want by passing
69:18 - individual test cases but i'll just do
69:20 - this from now on
69:22 - so great so now we have test case 0 this
69:24 - is the input
69:26 - and this is the query
69:28 - and it passed
69:29 - here we have test case 1 this is the
69:31 - input and this is the query and it
69:32 - passed and now because we have these
69:34 - print statements we can clearly look
69:36 - into our test cases and actually tell
69:39 - if the if this is tested correctly or
69:41 - not because now you can see here that we
69:43 - started out with low 0 high 7
69:45 - and a mid mid value of three
69:48 - so zero one two three we we found the
69:50 - number seven the query is one
69:52 - so we need to check this half of the
69:54 - array and that's exactly what we did we
69:56 - moved low to four and high remained
69:58 - seven
70:00 - then mid number became three
70:02 - so that means once again we need to
70:04 - check this half of the array and then we
70:06 - check this number and then we found the
70:07 - output so now you can see exactly how
70:09 - the algorithm works and this is in
70:11 - general what you want as a programmer
70:13 - you want to have a full understanding of
70:15 - the code that you've written you don't
70:17 - want your code to work incidentally
70:20 - you don't want it to you don't want to
70:21 - be in a position where you are just
70:23 - fixing things
70:25 - trying out different things and somehow
70:26 - at once the code works you want to be in
70:29 - complete control you want to know that
70:31 - these this is exactly what the code is
70:33 - doing and if it is failing why it is
70:35 - failing so we go to test case two three
70:37 - four five six
70:39 - uh looks good looks like we may have
70:41 - solved everything ah probably not so
70:44 - test case eight seems to have failed
70:46 - so test case eight is this number this
70:49 - list and this list contains repeating
70:51 - numbers and not just repeating numbers
70:53 - but the query itself occurs multiple
70:55 - times
70:56 - and now if we look here
70:59 - and maybe let's go go down and evaluate
71:01 - just a test case separately
71:02 - so here we are now using the singular
71:04 - version of the evaluate function so if
71:06 - you look here
71:08 - you can see you have eight eight six six
71:10 - a bunch of sixes then three two two zero
71:13 - the query is six so we start out with a
71:14 - low of zero higher fourteen total of
71:16 - fifteen elements that gives you a middle
71:18 - position of seven
71:21 - and the mid number at that position so
71:24 - let's count one zero one two three four
71:26 - five six seven okay and the mid number
71:29 - at that position is six
71:31 - great uh six is also the query so that's
71:34 - why our function returns seven
71:36 - but remember that we had decided that
71:38 - our function should return the first
71:40 - position
71:42 - of the number within the array
71:45 - so
71:46 - a function is failing that condition
71:49 - and why is that happening because unlike
71:51 - linear search where we start from the
71:52 - left and so we'll always bump into the
71:54 - first position because of the decreasing
71:56 - order of elements
71:58 - so we'll hit we'll encounter this six
72:00 - before we encounter this six
72:03 - binary search does not access elements
72:05 - in an order it access elements sort of
72:08 - randomly there's still a strategy but it
72:10 - goes left and right and it also depends
72:12 - on the values of specific elements
72:14 - whether this element is accessed before
72:16 - this element can depend on the value of
72:18 - let's say this element right so
72:20 - as such it's kind of a pseudo random
72:22 - kind of order
72:25 - and so we need an additional condition
72:27 - condition to keep track of it right
72:30 - so
72:30 - how do we fix it
72:32 - so the way to fix it is actually quite
72:34 - simple
72:36 - when we find that the middle position in
72:39 - a particular range is equal to the query
72:42 - we simply need to check whether it is
72:44 - the first occurrence of the query
72:47 - in the list
72:48 - or not that is whether the number come
72:52 - that comes before it is it equal to
72:54 - query or not if the number that comes
72:55 - before the middle element is also equal
72:58 - to query then obviously the middle
73:00 - element is not the first occurrence so
73:02 - that simply means that we can go back
73:04 - and because it can occur multiple times
73:06 - before that simply means that we can go
73:08 - we can now search the left half on the
73:10 - other hand if the middle element if the
73:12 - number before the middle element is not
73:14 - equal to query and obviously because it
73:16 - is a sorted list it will be greater than
73:18 - query
73:20 - then all the numbers here are going to
73:21 - be greater than the query and you know
73:23 - the the and and so
73:25 - this must be the first or the only
73:27 - position
73:29 - okay so make sure you understand that
73:32 - this must be the first or the only
73:33 - position where the query occurs
73:37 - so once again to make it easier what we
73:39 - will do
73:40 - is because there is some logic involved
73:42 - here what we'll do is we'll define a
73:43 - helper function called test location
73:46 - and this is a very helpful thing that
73:48 - you can do every time you find that okay
73:49 - you have to you have to cover these
73:51 - special cases and your function may
73:53 - start to get slightly longer and
73:55 - slightly more complicated what you may
73:57 - want to do is create a helper function
74:00 - and a good rule of thumb is not to have
74:02 - functions that are more than 10 lines of
74:05 - code or so i try to keep my functions
74:07 - below seven lines of code because seven
74:10 - eight lines is
74:12 - approximately the amount of information
74:13 - that you can hold in your head at once
74:15 - so if a function is about
74:16 - seven eight lines you can probably take
74:18 - a quick glance and tell what it's doing
74:20 - identify issues but anywhere beyond that
74:23 - it's very hard and
74:24 - if you're writing functions that are
74:26 - going into hundreds of lines please stop
74:28 - doing that please start breaking your
74:30 - code into small functions
74:32 - there's a there's a code by
74:35 - i forget who it is by but he's a creator
74:38 - of
74:38 - i think it's eric meyer he created the
74:40 - rx library for reactive programming and
74:44 - he said that great programmers write
74:46 - baby code which is
74:48 - really small bits of code that
74:51 - anybody can understand with a single
74:52 - look so you should be writing as many
74:54 - functions as many small pieces of code
74:57 - small pieces of logic as possible
75:01 - so let's see our test location function
75:03 - its purpose
75:04 - is to take the query and then take just
75:07 - a specific position so forget about
75:08 - binary search for now just take a
75:10 - specific position and tell if that
75:13 - position
75:15 - is the answer and how do we do that we
75:18 - first get the mid number from the cards
75:20 - so we get a mid number from cards
75:23 - so we then we print out mid and we print
75:25 - out mid number and then we compare the
75:27 - mid number with the query
75:29 - so this is the special case that we need
75:31 - to handle this is where we had the error
75:33 - now what we need to check is if the
75:35 - element before the mid number
75:38 - is also equal to query so if the element
75:40 - before the mid number is also equal to
75:41 - query then we need to go left so just to
75:44 - make it super clear what we'll do is
75:46 - instead of setting high low etc we'll
75:48 - simply say that we need to go left so
75:50 - we'll return the the actual string left
75:53 - but one thing to keep in mind here
75:54 - because once again whenever you're
75:56 - accessing an array you need to make sure
75:58 - that the index is valid so we simply
76:01 - check that mid minus one should be
76:02 - greater than or equal to zero that we
76:04 - made is not this position and which can
76:06 - happen as your search space decreases
76:08 - for example if this is your search space
76:10 - your mid will actually be this position
76:14 - so if
76:15 - it is equal to if the number before the
76:17 - mid number is equal to query then we
76:19 - return left
76:20 - otherwise we return found once again
76:22 - making it very obvious that we have
76:25 - found the number so we return found
76:29 - else the other case is if the mid number
76:31 - is less than query
76:33 - that means that the query lies on the
76:35 - left because of the decreasing order of
76:36 - the list so once again we need to search
76:38 - on the left else it returns right so a
76:40 - test location simply tells us whether we
76:42 - found the solution or we need to look on
76:45 - the left or we need to look on the right
76:47 - now
76:48 - in sometimes you will see programs
76:50 - especially in c plus plus java return
76:52 - something like minus 1 0 and 1 and then
76:55 - use that to represent whether you should
76:56 - go left and right but python is a high
76:58 - level language and strings are a first
77:00 - class
77:01 - things are first class feature of the
77:02 - language so just use strings because
77:04 - they are really descriptive they make
77:05 - your code readable somebody else reading
77:07 - your code will be able to understand now
77:09 - if you're looking at minus one plus one
77:10 - etc
77:12 - that is going to be difficult for people
77:13 - to understand
77:14 - so now we can now simplify a locate card
77:16 - function once again we have our low high
77:19 - len cards minus one uh zero and len cart
77:22 - minus one
77:23 - the while loop is the same and we print
77:25 - low and high as well so we are planting
77:27 - row and high inside the locate card
77:28 - function and then we are printing mid
77:30 - and mid number inside the test location
77:31 - function wherever is the right place to
77:33 - print something you print it
77:35 - then we get the mid position
77:38 - and now we simply call test location so
77:40 - we are testing if
77:42 - mid
77:43 - is the answer and if it is not the
77:45 - answer should we go left or should we go
77:46 - right now that makes it really simple
77:49 - because now we get this result and we
77:50 - check this result and if it says found
77:53 - then we return mid
77:54 - that's the answer if it says left then
77:56 - we return mid minus one and then we
77:58 - simply move high to mid minus one and if
78:00 - it returns right then we simply set low
78:03 - to mid plus one so we are simply
78:05 - changing the start position of the
78:06 - search space
78:08 - to after the middle element and here we
78:10 - are changing the end position of the
78:11 - search space to before the middle
78:12 - element right so this makes it extremely
78:15 - obvious and it's really hard to go wrong
78:17 - when you write code like this
78:20 - especially so when you have and binary
78:22 - search problems are specially tricky
78:24 - because they always have certain these
78:26 - special cases that you need to handle
78:28 - and if you start handling them within
78:29 - this if loop so now you have a while
78:31 - loop inside which you have an if loop
78:32 - inside which you have another another if
78:35 - statement and it can get pretty tricky
78:37 - and difficult to debug
78:39 - so let's evaluate that test case and
78:42 - looks like that test case has passed
78:44 - this time
78:45 - perfectly you can go through the
78:47 - logs here to verify it
78:50 - let's evaluate the test case all the
78:52 - test cases as well we should do this
78:54 - every time we change the function and
78:55 - that is why it's helpful to have a
78:57 - function where you can every time you
78:58 - make a change you can just run the test
79:01 - and on a coding platform like elite code
79:04 - or hacker rank you will be given some
79:06 - test cases although those test cases
79:08 - will not be visible to you so you can
79:10 - submit your solution but you may not get
79:12 - an actual result you may not get to know
79:14 - what the test case was or where your
79:16 - answer was wrong and that's where you
79:17 - may want to create your own test cases
79:19 - if you're getting a lot of errors
79:24 - and in fact once you've written out the
79:25 - algorithm you may realize that okay
79:27 - maybe you need to add more test cases
79:29 - what if the number lies in the first
79:30 - half of the array what if the number
79:31 - lies in the second half of the rate so
79:33 - this was not an important factor when we
79:34 - were not thinking about binary search
79:36 - but now that we are thinking in this
79:37 - direction of splitting the array into
79:39 - half we may want to add some test cases
79:41 - where the number lies exactly in the
79:42 - middle in the left in the right and the
79:45 - simplest way to do that is now go back
79:46 - to the tests array so you can open you
79:48 - can create a new cell here
79:51 - by pressing the character b so if you
79:53 - click outside and press the character b
79:55 - you can create a new cell and then you
79:57 - can simply do tests dot append and then
79:59 - write your test case
80:01 - so here is the final code for the
80:03 - algorithm
80:05 - without
80:06 - without the print statements
80:09 - so we have test location and then we
80:10 - have locate card
80:12 - and try creating a few more test cases
80:14 - to test your algorithm more extensively
80:17 - and once again at every step we are
80:19 - going to save our work by running
80:21 - jobin.commit
80:23 - so now we are down to analyzing the
80:25 - algorithms complexity and identifying
80:28 - inefficiencies if there are any now you
80:30 - may have just read online you can
80:32 - actually look it up say just search for
80:33 - complexity of binary search and you will
80:36 - read and you will find an answer
80:38 - but
80:39 - and and you may even just say that in
80:41 - interviews but it's always nice to just
80:44 - come up with that answer from first
80:46 - principles it's always nice especially
80:48 - in an interview if you can talk through
80:50 - it if you can talk through why it is
80:51 - order why it is whatever it is and we'll
80:53 - see what that is
80:55 - so now let's once again try to count the
80:57 - number of iterations in the algorithm
80:59 - because
81:00 - we need to minimize the number of times
81:01 - we access elements from the array
81:04 - and
81:05 - to do that we know that in each
81:08 - iteration we are accessing the element
81:10 - just once
81:11 - and then we are comparing it so we're
81:13 - doing a bunch of other operations but in
81:14 - each iteration we're accessing one
81:16 - element
81:17 - so we need to count just the number of
81:18 - iterations the number of times the while
81:20 - loop was executed now if we start out
81:22 - with an array of n elements then each
81:25 - time
81:27 - each time the size of the array reduces
81:29 - to half for the next iteration now
81:31 - that's roughly true because
81:33 - when you come when you check the middle
81:34 - element and then you decide whether to
81:36 - go left or right it's actually probably
81:38 - n by 2 minus 1 if n is
81:42 - if n is even and if n is odd it is the
81:45 - floor of n by two but again
81:48 - with algorithms with complexities we are
81:50 - generally
81:51 - interested in studying the trend so we
81:53 - can ignore that small part in the
81:54 - calculation so let's say
81:56 - uh the important part is that
81:58 - even if it's okay to overestimate a
82:00 - little bit but try not to underestimate
82:02 - so after the first iteration we may be
82:05 - left with the search space of size n by
82:06 - two
82:07 - it may be slightly less than that but
82:09 - it's okay to overestimate
82:11 - so we have n so we after n we have after
82:14 - the first iteration we we are left with
82:15 - the search space of n by two then we
82:17 - split it into half again so next time we
82:19 - may be left with a search space of n by
82:21 - four which is n divided by 2 square and
82:24 - then we may be left by we may be left
82:26 - with n by 8
82:28 - and it's possible that at any of these
82:29 - iterations we may just exit because we
82:31 - may have found the right number but what
82:34 - we always try to analyze is the worst
82:36 - case complexity of an algorithm what is
82:38 - the longest possible
82:40 - amount of time or the largest amount of
82:42 - space it can take so right now we are
82:44 - talking about time because we are
82:45 - counting iterations and each iteration
82:47 - takes some time
82:49 - so n by 8 after iteration 3 that's 2 to
82:51 - the power 3 and i think then you can
82:53 - start to see the trend here that after
82:55 - the kth iteration you will end up with
82:58 - n divided by 2 to the power k elements
83:00 - now when does the iteration stop so the
83:02 - final iteration is on an array of length
83:05 - 1 and that is when we access that last
83:07 - element and check whether after all this
83:09 - checking the last element is equal to
83:11 - the index or not
83:14 - so we can do n divided by 2 to the power
83:16 - k and if we set that to 1 we can
83:19 - rearrange the terms
83:21 - and we get back n equals 2 to the power
83:23 - k
83:24 - so
83:25 - after the kth iteration if you want to
83:27 - be left with one element then that means
83:29 - n divided by 2 to the k should be equal
83:31 - to 1 or n should be 2 to the k or in
83:33 - other words
83:34 - k should be equal to log
83:36 - log n remember logarithms
83:39 - and here obviously log refers to log to
83:41 - the base 2
83:42 - but what i will argue is that you can
83:44 - change the base of the logarithm and
83:46 - that will simply add a constant
83:48 - so that will simply if you're taking the
83:50 - natural log then that will simply add a
83:52 - constant here
83:53 - and remember when we talk about time
83:56 - complexity we ignore constants so
83:59 - we can just generally say that our
84:01 - algorithm binary search
84:03 - has the time complexity of order of log
84:05 - n
84:06 - that means as the input grows
84:10 - the amount of time taken by binary
84:12 - search is proportional to the logarithm
84:14 - of the number of elements in the list
84:16 - passed to it
84:17 - or the amount of time taken is logarithm
84:20 - to the size of the initial search space
84:23 - and you can verify this you can verify
84:25 - that the space complex you can you can
84:27 - check this out by simply writing it out
84:29 - as well you can take some examples let's
84:30 - say you take a card list of size 10
84:34 - and then work through it the worst case
84:36 - and count how many iterations you have
84:38 - and compare if that is close to login or
84:40 - not
84:42 - and then as an exercise you can verify
84:44 - that the space complexity of binary
84:46 - search is order one
84:48 - can you you can try posting in the
84:49 - youtube comments or in the youtube live
84:51 - chat how the space complexity of binary
84:53 - search is order one
84:55 - i'll let that
84:56 - steam so let's now compare linear search
85:00 - with binary search
85:04 - how are the two different and what we'll
85:06 - do is we will create a large test case
85:08 - because
85:09 - you start to see the benefits of the
85:11 - difference between the order n algorithm
85:13 - and the order login algorithm
85:16 - only when you have larger test cases
85:18 - because small test cases everything runs
85:20 - instantly so it's not really that much
85:22 - of a hassle
85:23 - so here we have a locate card linear
85:26 - and this is the linear version of the
85:28 - algorithm where we simply go through
85:30 - each of the cards one by one
85:33 - and then we have a really large test
85:34 - case here so we have the input and then
85:37 - we have the cards which goes in the
85:39 - range okay let's see
85:41 - so that's
85:42 - one two three so that's thousand another
85:44 - three that's million so we have 10
85:46 - million elements here so we have 10
85:48 - million elements
85:53 - and
85:55 - we are looking and so we are actually
85:57 - creating a range here so we are using a
85:59 - function in python so we are creating a
86:01 - list of numbers
86:02 - going down from 10 million all the way
86:04 - to one so a decreasing list going from
86:08 - 10 million to one and this is how you
86:10 - create it and you can check it out
86:12 - and in this list we are looking for the
86:14 - number two which occurs at the very end
86:15 - so we are sort of creating this is as we
86:18 - will see if you want to really analyze
86:20 - it this is going to be a worst case
86:21 - scenario both for linear search and for
86:23 - binary search
86:25 - approximately worst case
86:27 - so the query is two
86:29 - and then the output is
86:31 - this is the output that we expect
86:32 - obviously because 0 to nine nine nine
86:35 - nine nine nine nine is are the array
86:37 - indices and the last element is one so
86:40 - the element just before is two so this
86:41 - is the expected output
86:44 - great so now we have this large test
86:46 - let us call evaluate test case and let
86:48 - us pass a check the linear
86:51 - search pass in the last test and
86:54 - because this is a huge list we may want
86:56 - to turn off the display of the output we
86:58 - may not not want to actually see the
87:01 - input being displayed so we can simply
87:03 - turn off the display by passing display
87:05 - equals false
87:06 - and we can just get back the result from
87:08 - the evaluate test case function so the
87:10 - result will give the output the actual
87:12 - output of the function whether the test
87:14 - passed and the running time of the
87:15 - algorithm
87:18 - so it takes a second so it looks like
87:21 - the test did pass our algorithm is
87:24 - correct so that's great
87:26 - and it took one two two four point two
87:28 - nine one milliseconds or
87:30 - about 1.2 seconds to answer it
87:35 - and you can probably tell why because it
87:38 - because this is the result so it
87:40 - probably took nine nine nine nine nine
87:42 - nine eight iterations so it had to go
87:44 - through all the elements to get to the
87:46 - very end
87:47 - on the other hand when we talk about
87:49 - binary search so now we are passing in
87:50 - the binary search version once again
87:53 - turning display to false
87:55 - and we are displaying the output
87:57 - okay so this time the result is the same
87:59 - the test did pass but the execution time
88:02 - is
88:02 - 0.019 milliseconds so that's
88:05 - 55 000 times faster than the linear
88:08 - search version and in fact you can tell
88:10 - how many elements we actually had to
88:12 - access so if we just check log of
88:18 - so log of this number is about seven
88:21 - and maybe you know if you're checking
88:23 - log two we can maybe check something
88:24 - like this so not more than twenty
88:26 - elements had to be accessed so where we
88:28 - linear search needed to access about
88:33 - 10 million elements binary search was
88:36 - able to get to the answer with just
88:37 - about 20
88:39 - checks
88:41 - so that's a lot of time saved
88:43 - and you can increase the size of the
88:45 - array by a factor of 10
88:47 - and increase this by a factor of 10 as
88:49 - well and then you will see far bigger
88:51 - difference where
88:54 - for a 10 times larger array
88:56 - linear search would run for 10 times
88:58 - longer whereas binary search would only
88:59 - require three additional operations
89:02 - so the linear search would
89:04 - go from 10 million operations to 100
89:06 - million operations binary search would
89:08 - go from 20 operations to 23
89:11 - and that is the real difference between
89:12 - the complexities order n and order login
89:15 - and as the size of as the size of the
89:18 - arrays grows bigger another way to look
89:20 - at it is that if you just divide the
89:22 - complexities binary search runs n by
89:25 - login times faster than linear search
89:27 - for some fixed constant because there's
89:29 - always some constraints involved and as
89:31 - the size of the input grows larger the
89:33 - difference only gets bigger the
89:34 - difference in performance
89:38 - and that is what algorithm analysis of
89:41 - algorithms and optimization of
89:42 - algorithms is all about
89:45 - it's about
89:46 - overcoming the limitations of computers
89:49 - by devising clever techniques to solve
89:51 - problems
89:56 - and it's something that you can actually
89:57 - apply in real life as well in a lot of
89:59 - cases there are a lot of things that you
90:01 - may
90:02 - see a brute force solution to but if you
90:04 - just apply your mind you may find a more
90:06 - optimal solution a more easy way or a
90:09 - more lazy way to do it with less work
90:12 - so think about that
90:14 - and here is a graph showing
90:16 - how the comp how you can compare common
90:19 - functions
90:20 - how the
90:21 - how the running times of common
90:24 - functions vary so we will look at all
90:26 - kinds of functions we look at constant
90:28 - time functions order one for example
90:30 - accessing an element from an array is
90:32 - order one so even if you have an element
90:33 - of
90:34 - 10 a list of 10 million elements you can
90:36 - access the last element in constant time
90:39 - on the other hand we've looked at binary
90:41 - search which has which is order log n
90:43 - and we've also looked at linear search
90:45 - which is order n now in the future we
90:47 - will look at other techniques which have
90:49 - complexities of
90:51 - n square n cube n to the power n are far
90:54 - far higher and somewhere in between
90:56 - there is a very nice
90:58 - special type of complexity called n log
91:00 - n which is rather nice so we'll talk
91:02 - about that as well n login in fact a lot
91:04 - of questions in
91:06 - coding assessments and coding interviews
91:08 - tend to be
91:10 - taking algorithms which would be
91:13 - which would have n square complexity in
91:17 - in a brute force approach
91:19 - and optimizing them either to order n
91:21 - or to order n log n
91:24 - so we'll we'll discuss all of this so
91:25 - don't worry if this doesn't make sense
91:27 - just yet
91:28 - but i hope you see now why we ignore
91:30 - constants and lower order terms while
91:32 - expressing the complexity of the big-o
91:33 - notation
91:35 - so we've covered binary search but
91:38 - we've seen it in the context of a
91:39 - problem
91:40 - and now we can step away one more step
91:43 - and abstract it out further and identify
91:45 - the general strategy behind binary
91:47 - search and this general strategy is
91:49 - actually applicable to a wide variety of
91:51 - problems and this is what you want to
91:53 - keep doing as a programmer you need to
91:56 - abstract away peel away the layers of
91:58 - specific problem specific details and
92:01 - find the general technique find the
92:02 - general strategy and then encode that
92:05 - using your functions and programs so
92:07 - here's the general strategy
92:09 - come up with a condition
92:11 - to determine whether
92:13 - the answer
92:14 - lies before
92:15 - after or at a given position so we are
92:18 - assuming here that we have some kind of
92:20 - a range
92:20 - and we have to identify a position
92:22 - within a range or maybe an element
92:24 - within that range but we can access
92:26 - elements using the position so come up
92:27 - with a condition that that first tells
92:29 - you whether given a position the answer
92:32 - lies at
92:33 - or before or after that position
92:36 - once you have that condition
92:38 - first retrieve the midpoint
92:41 - and the middle element of the list now
92:43 - if the middle element or the midpoint is
92:44 - the answer then return the middle
92:46 - position that is the answer you're done
92:49 - if the answer lies before it
92:51 - repeat the search so repeat the process
92:54 - with the first half of the list
92:56 - or the first half of the search space
92:59 - and if the answer lies after it repeat
93:01 - the search with the second half of the
93:02 - search space
93:04 - so here is the generic algorithm for
93:06 - binary search
93:07 - implemented in python
93:11 - and you can see a
93:13 - classic detailed documentation here
93:17 - so while
93:19 - so here you have the binary search is
93:21 - going to take a search space low and
93:23 - high so low is going to be zero
93:25 - and high is going to be
93:29 - well we will pass in maybe the final
93:31 - we will pass it may be the final
93:32 - position the final index of the array
93:34 - but writing it this way rather than
93:36 - passing passing an array also allows you
93:38 - to use binary search for problems that
93:40 - are not based on arrays sometimes these
93:41 - could just be numbers
93:43 - for example
93:45 - if i ask you to find a number
93:48 - between 1 million and 10 million that is
93:51 - a perfect square
93:53 - then you can use binary search to do
93:54 - that
93:59 - then it takes a condition
94:01 - so what it does is it starts a loop so
94:04 - while low less than equals high
94:07 - we get the midpoint so low plus high
94:10 - divided by 2 that gives us a midpoint
94:12 - then remember earlier we had this
94:14 - condition
94:16 - test location so our condition simply is
94:19 - supposed to take the middle position and
94:21 - identify
94:23 - if the middle position is the answer or
94:25 - we need to go left or right so the
94:27 - condition should return either found
94:29 - left or right so if the condition
94:31 - returns found we return the midpoint as
94:34 - the answer if the condition returns left
94:36 - we return the high we we move to the
94:41 - left side so which is we take the end of
94:43 - the search space and set it to before
94:45 - the midpoint so we set high equal to mid
94:47 - minus one and if the condition returns
94:49 - right which is the else case here we set
94:51 - low to mid plus one so we take the start
94:53 - point of the search space and move it
94:55 - after the element then we return minus
94:57 - one so that's your binary generic binary
94:58 - search algorithm and if you start using
95:00 - this
95:02 - what will happen is now this is a tested
95:04 - piece of code and in fact we can see it
95:05 - here
95:06 - now now we can rewrite locate card
95:09 - and locate card can be
95:11 - we are passing in cards and we are
95:12 - passing in the query and we need to
95:14 - write a condition and here we're using a
95:16 - very interesting feature of python
95:19 - we are writing a function inside a
95:21 - function so this is called function
95:23 - closure and it's a very handy feature so
95:24 - now we can simply write condition inside
95:27 - locate card and what that does is
95:29 - binary search is going to pass the
95:30 - middle value the middle position
95:33 - but condition can also access cards and
95:35 - query so which is because it lies inside
95:38 - locate
95:39 - so what we do inside condition is okay
95:41 - we check them we get the middle element
95:43 - cards made if cards made is equal to
95:45 - query then here we have that check we
95:48 - check whether it is the first
95:50 - occurrence of query or can query occur
95:52 - before it if query occurs before it we
95:54 - return left else we return found and
95:56 - then these are the original conditions
95:58 - that we already had so you can verify
96:00 - this by going back and checking
96:01 - but the important part here is now the
96:03 - while loop has gone away now we can
96:05 - simply call binary search with zero
96:08 - len cards minus one so the
96:10 - start index the end index
96:13 - and the condition
96:15 - and we can evaluate the test cases and
96:16 - you can see that the test cases are
96:18 - correct
96:22 - and now you can use this binary search
96:23 - function because we have not tested it
96:25 - with one problem you can use this exact
96:26 - same function to solve other problems
96:28 - too in some sense it is a tested piece
96:30 - of logic so here's what we'll do we'll
96:33 - take a quick question and we will
96:35 - implement it now we've spent what one
96:37 - and a half hour talking about a
96:39 - particular problem but let's spend maybe
96:43 - two minutes talking about a new problem
96:45 - and solving it
96:46 - so now here's a slightly related
96:48 - question given an array of integers
96:50 - sorted in increasing order find the
96:52 - starting and ending position of a given
96:54 - number so once again you have a sorted
96:56 - array this time they are increasing the
96:58 - only difference is now apart from the
97:00 - fact that they are sorted in increasing
97:02 - order the other
97:04 - difference is that we are looking for
97:06 - both the
97:07 - start index
97:11 - and the end index so we're looking for
97:13 - both the start index and the end index
97:16 - of a particular number because the
97:17 - number can repeat like we saw one
97:20 - example
97:21 - and
97:22 - there's a very simple way to solve this
97:23 - a simple strategy is
97:26 - do binary search once to find the first
97:28 - position and that's what this function
97:30 - does i'll let you
97:31 - read through
97:32 - it the only changes here are this
97:36 - variable
97:37 - this has changed this order because now
97:40 - the
97:41 - now the elements are in increasing order
97:43 - and then the second change and there's
97:45 - no other change here so that there's
97:46 - just one change here and then there is
97:48 - another function called last position
97:50 - here
97:52 - instead of checking the left we are
97:54 - checking the right so instead of
97:55 - checking mid minus 1 we are checking mid
97:58 - plus 1 and if mid plus 1 equals the
98:00 - target we go to the right and of course
98:02 - we have the same change here in this
98:04 - code because instead of decreasing we
98:06 - have increasing order right so now we
98:07 - write two position now we write two
98:09 - functions first position last position
98:12 - and then first and last position is
98:13 - simply getting the first position once
98:15 - so that's one binary search and getting
98:16 - the last position once that's two binary
98:18 - searches and that's not bad now the
98:20 - complexity is still order login two
98:23 - times login or two times some constant
98:25 - times login when you express it in the
98:26 - big o notation is still login so that's
98:29 - okay
98:30 - and that was quick we were able to reuse
98:32 - most of the code that we have written
98:34 - and that's the benef benefit of
98:36 - making generic functions like binary
98:38 - search and in fact we can test a
98:40 - solution by making a submission here
98:42 - so let's go to leadcode.com
98:45 - let us
98:46 - here what i've done is i have already
98:49 - copied over the binary search
98:52 - function the first position function
98:55 - and the last position function so by the
98:56 - way lead code is a great platform for
98:58 - practicing so you can go to leadcode.com
99:00 - sign up with
99:02 - any account and you will find a lot of
99:04 - problems especially on the
99:05 - in the problems tab
99:07 - and here you can see that this is
99:09 - exactly the problem that we have been
99:10 - solving just now
99:12 - so we just post the code here binary
99:14 - search first position last position
99:16 - first and last position and lead code
99:18 - requires you to write this class called
99:19 - solution this is something that they
99:20 - give you beforehand and inside the
99:22 - solution you need to define a function
99:24 - called search range where we are simply
99:26 - calling our first and last position
99:29 - here i'll let you see
99:30 - and we simply we can test this code with
99:32 - a test case so you can pass a test case
99:35 - here
99:36 - and test it out
99:37 - great
99:38 - or we can simply submit it
99:42 - and here you can see that the problem
99:44 - was submitted successfully
99:47 - and it tells you things like how much
99:48 - runtime it used what was the memory it
99:50 - used and your solution was accepted
99:53 - right so check out leadcode.com go to
99:55 - the problem section
99:57 - and you can see all the different
99:59 - problems that they have you can also
100:01 - explore
100:02 - and you have different problems that
100:03 - come up every day it's a great place to
100:05 - practice
100:07 - so that's binary search for you but i
100:09 - just want to revisit the method once
100:10 - again so this is the systematic strategy
100:12 - that we've applied for solving the
100:14 - problem we state the problem clearly and
100:16 - we identify the input and the output
100:18 - formats
100:21 - this this shows that you've understood
100:23 - the problem you know what the solution
100:24 - will look like then come up with some
100:26 - example inputs and outputs and try to
100:28 - cover all the edge cases so this shows
100:30 - that
100:31 - you are envisioning what are the
100:32 - different inputs that can come in
100:34 - before you write code
100:37 - then you come up with the correct
100:38 - solution not necessarily the most
100:40 - efficient one and state it in plain
100:41 - english
100:42 - now when you try to state it you will
100:44 - have to clarify it
100:45 - and that will help you clarify your own
100:47 - thoughts and then you can
100:50 - analyze the algorithms complexity and
100:53 - you can implement the solution and test
100:54 - it using example inputs so this is the
100:56 - basic solution now in interviews and in
100:59 - coding assessments maybe you know where
101:01 - there is a time limit you may not want
101:02 - to implement the brute force brute force
101:04 - solution because then you may get stuck
101:07 - in fixing issues with brute force and
101:08 - you can directly jump ahead to step five
101:11 - but while you're practicing always
101:13 - implement brute force then step five
101:15 - analyze the algorithms complexity and
101:17 - most of the time it is simply a matter
101:19 - of counting the number of iterations how
101:20 - many times a while loop or maybe a loop
101:23 - within a loop is getting executed
101:26 - and identify inefficiencies and if it is
101:28 - a brute force solution
101:29 - it's generally quite easy to see the
101:31 - inefficiency for example in this case
101:33 - the inefficiency was that we know that
101:35 - the array is sorted that anything we do
101:37 - will be better than going line by line
101:39 - right we could pick a random element and
101:42 - that would help us eliminate a good
101:44 - chunk of the array
101:46 - so that is the inefficiency and then
101:48 - apply the right technique and we are
101:50 - learning the techniques so we've learned
101:52 - binary search today and then we are
101:53 - going to learn a lot more techniques
101:55 - that are asked in interviews so apply
101:56 - the right technique to overcome the
101:58 - inefficiency and repeat steps three to
102:00 - six
102:01 - which is go back and come up with the
102:03 - correct solution with the optimized
102:04 - technique implement the solution and
102:06 - test it using some example inputs and
102:08 - then analyze that algorithm's complexity
102:11 - and identify any inefficiencies
102:14 - so what we've done for you is we have
102:16 - created a
102:19 - template
102:21 - so you can see this python problem
102:23 - solving template
102:24 - and how you can use this template
102:27 - is to
102:30 - simply run it so you run the code you
102:32 - run this template and then when you run
102:35 - the template inside it you will see this
102:36 - question mark in a bunch of places so
102:38 - you can give it a nice project name and
102:40 - you can commit it to your profile one
102:42 - way you can save a copy over this
102:43 - template to your profile is by clicking
102:45 - the duplicate button now if you click
102:47 - the duplicate button you can copy it in
102:48 - your profile and you don't have to look
102:50 - for it you can just find it on your
102:52 - jovian profile but anyway once you have
102:54 - it copied you can
102:56 - click the run button and then click run
102:58 - on binder
103:00 - and run run the template then you go
103:02 - down once you run it and you can copy
103:04 - over a problem statement
103:05 - you can copy over a link to the problem
103:07 - so that when you need to make a
103:08 - submission you can go back and refer
103:10 - and then here the method is summarized
103:12 - for you
103:13 - and here we have
103:15 - created sections for you so you can
103:16 - simply start filling out this method
103:18 - step one step two step three step four
103:21 - step five so whenever you're faced with
103:23 - a difficult problem just use this
103:24 - template and
103:26 - i guarantee it one if you work through
103:28 - this course you will be able to solve a
103:30 - majority of the problems that you come
103:32 - across
103:33 - and specifically even if you are able to
103:35 - follow
103:36 - maybe about 30 to 40 percent of this
103:38 - course you will easily be able to solve
103:41 - most questions that are asked in
103:42 - interviews
103:43 - because questions asked in interviews
103:45 - are fairly simple in terms of the data
103:46 - structures or algorithms they test but
103:48 - the intention there is more to test your
103:51 - approach look at the quality of your
103:53 - code and see how clearly you're
103:54 - expressing yourself right and this is
103:56 - what this is exactly what this method
103:59 - teaches you to do
104:01 - now to encourage you to do this to
104:02 - encourage you to try it out and you can
104:04 - take problems from places like lead code
104:07 - uh code chef code forces there are a few
104:10 - links listed here you can see practice
104:12 - problems there are a bunch of links
104:14 - listed here so that was today's lesson
104:16 - for the next lesson
104:19 - common data structures in python
104:22 - so this is data structures and
104:23 - algorithms in python
104:25 - an online certification course brought
104:26 - to you by jovian
104:29 - thank you hello and welcome to data
104:31 - structures and algorithms in python this
104:34 - is an online certification course
104:36 - being offered by jovian
104:38 - today we're looking at assignment one
104:40 - binary search practice
104:43 - so let's get started
104:44 - first thing we'll do is go to the course
104:46 - website
104:47 - pythondsa.com
104:49 - on the course website you can enroll for
104:51 - the course and view all the previous
104:54 - lectures and assignments
104:56 - for assignment 1 you may want to review
104:57 - the video and notebook for lesson 1.
105:01 - let's open up assignment one
105:03 - it's called binary search practice
105:07 - now in this assignment you will apply
105:09 - and practice the concepts that we
105:10 - covered in the first lesson so you will
105:12 - understand and solve a system
105:14 - solve a problem systematically
105:17 - implement linear search and analyze it
105:19 - and optimize the solution using binary
105:21 - search and ask questions and help others
105:23 - on the forum
105:25 - let's open up the starter notebook for
105:27 - the assignment
105:29 - which contains that problem statement
105:31 - and other information
105:34 - now this is a notebook you're looking at
105:36 - hosted on jovian
105:38 - you can see some description here and if
105:40 - you scroll down below you can also see
105:42 - some code
105:43 - and you will need to execute this
105:45 - notebook modify the code with within it
105:47 - and record a new version which you can
105:49 - then submit
105:51 - to see your score
105:53 - so let's start reading through it
105:55 - as you go through the notebook you will
105:57 - find three question marks in certain
105:59 - places to complete the assignment you
106:01 - have to replace the question marks with
106:02 - appropriate values expressions or
106:04 - statements to ensure that the notebook
106:06 - runs properly end to end
106:09 - now keep in mind that you need to run
106:11 - all the cells
106:12 - otherwise you may get errors like name
106:14 - error or undefined variables
106:17 - you should not be changing any variable
106:18 - names or deleting any cells or disturb
106:20 - any existing code
106:22 - you can add new code cells or new
106:24 - statements
106:26 - but do not redefine or do not change
106:28 - some of the existing variables
106:31 - you will be using a temporary online
106:33 - service for code execution and we'll see
106:35 - how to use it in a moment so keep saving
106:38 - your work by running jobin.com at
106:40 - regular intervals
106:41 - and then the question marks optional
106:43 - will not be considered for evaluation
106:45 - although we recommend doing them they
106:46 - are for your learning but you can make a
106:49 - submission before you have solved the
106:51 - optional questions
106:53 - now you can make a submission back on
106:55 - the assignment notebook page and we'll
106:57 - see how to do that
106:58 - and if you're stuck you can ask for help
107:00 - on the community forum
107:02 - it's listed here
107:05 - and we'll see how to do that as well
107:09 - now one final thing i want to mention is
107:11 - you can get help with errors or ask for
107:14 - hints you can even share your code and
107:16 - errors that you are getting in the code
107:18 - but please don't ask or share
107:20 - the full working answer code on the
107:23 - forum this is so that everybody has the
107:25 - opportunity to work through the problem
107:28 - statement on their own make mistakes
107:30 - learn from their own mistakes and arrive
107:32 - at the right solution
107:35 - now how do you run this code the
107:37 - recommended way to run this code is by
107:39 - clicking the run button at the top of
107:41 - the page and selecting run on binder but
107:43 - you can also run it using some other
107:45 - options like google collab or kagger
107:48 - or you can run it on your computer
107:49 - locally
107:53 - so we're going to use the recommended
107:55 - method run on binder
108:00 - now we have the notebook running in
108:01 - front of us
108:03 - the first thing i like to do is go to
108:05 - kernel and click restart and clear
108:07 - output so that we can see all the
108:09 - outputs of the notebook from scratch
108:13 - and i'm also going to toggle the header
108:15 - and the toolbar
108:19 - so that we can zoom in a bit
108:27 - so now the same jupyter notebook is now
108:29 - running online on a platform called
108:31 - binder
108:34 - and before starting the assignment let's
108:36 - save a snapshot of the assignment to our
108:38 - jovian profile so that we can access it
108:40 - later and continue our work i'm going to
108:42 - run pip install jovian
108:44 - this is going to install the jovian
108:45 - library
108:47 - then run import jovian to import the
108:50 - library
108:51 - and set a project name
108:53 - here i'm just calling it binary search
108:55 - assignment and run jovian.commit now you
108:58 - have taken a starter notebook which was
109:00 - hosted on my profile and then you've run
109:02 - it on binder where as soon as you run
109:04 - jovian.comit a copy of the starter
109:06 - notebook gets saved to your profile so
109:08 - what you will see here is a link to a
109:10 - notebook hosted on your jovian profile
109:12 - let's open it up here and see so now
109:15 - this
109:16 - is your personal copy of the assignment
109:18 - notebook any changes that you make here
109:21 - and run jovian.comit will get added to
109:23 - your profile so if you want to come back
109:25 - and continue your work then you do not
109:27 - have to go back to the original starter
109:29 - notebook which contains all blanks
109:31 - rather you can come back to your profile
109:34 - and you can come to your profile simply
109:35 - by opening jobin.ai
109:37 - and on your profile you can go to the
109:39 - notebooks tab
109:40 - and on the notebooks tab you will be
109:42 - able to find
109:44 - as you can see here you will be able to
109:46 - find the
109:49 - binary search assignment here
109:51 - there you go this is the binary search
109:53 - assignment that we just created
109:56 - and you can open it and run it on binder
109:58 - to continue your work
110:01 - so moving along this is the problem
110:03 - we're looking at here
110:06 - you are given a list of numbers obtained
110:08 - by rotating a sorted list an unknown
110:10 - number of times
110:11 - okay so we have two new terms here
110:14 - rotating a sorted list and don't worry
110:16 - if you don't know what that means
110:17 - normally if you see any new terms in a
110:20 - problem
110:21 - they will be explained somewhere within
110:23 - the problem itself
110:26 - for instance here you can see that
110:28 - there's a definition we define rotating
110:31 - a list as removing the last element of
110:33 - the list and adding it before the first
110:36 - element for instance rotating the number
110:38 - the list three two four one
110:42 - leads to removal of the last number and
110:45 - then placing it at the very beginning so
110:47 - you end up with the list one three two
110:49 - four this is a new operation that we are
110:51 - defining this is not something standard
110:54 - but you will find that a lot of problems
110:56 - will define new terms or new operations
110:58 - so that they it becomes easier for you
111:01 - to understand the problem so that's
111:03 - rotating a list now rotating a list once
111:05 - produces one three two four now if you
111:07 - rotate that list again the resulting
111:09 - list one more time then you will end up
111:11 - with four one three two and so on
111:15 - and then the other term is sorted so
111:17 - sorted refers to a list where the
111:19 - elements are arranged in increasing
111:21 - order
111:22 - in this case we have numbers and the
111:23 - numbers 1 3 5 7 are increased arranged
111:27 - in increasing order so this is a sorted
111:29 - list
111:29 - but if this was 3 2 4 1 well that's not
111:33 - the numbers are not arranged in
111:34 - increasing order so that's not a sorted
111:36 - list
111:37 - so you are given a list of numbers
111:38 - update obtained by rotating a sorted
111:41 - list an unknown number of times for
111:43 - instance this sorted list 0 2 3 4 5 6 9
111:46 - is rotated a certain number of times and
111:48 - you can verify that if you rotate this
111:50 - three times you end up with the list
111:51 - five six nine
111:53 - zero two three four right you can see
111:55 - that first
111:56 - nine comes to the beginning then six
111:57 - comes comes to the beginning and then
111:59 - five comes to the beginning
112:03 - so you need to write a function
112:06 - and you're given just this the list
112:08 - you're not given the original sorted
112:09 - list you're given the list obtained by
112:11 - rotating some sorted list and unknown
112:13 - number of times now you need to write a
112:15 - function to determine the minimum number
112:17 - of times the original sorted list was
112:19 - rotated to obtain the given list
112:21 - your function should have the worst case
112:23 - complexity of order log n where n is the
112:25 - length of the list
112:27 - and you can assume that all the numbers
112:28 - in the list are unique okay so three
112:31 - parts write a function to determine the
112:33 - minimum number of times you need to
112:35 - rotate the original sorted list in this
112:37 - in this case it is three the function
112:39 - should have the worst case complexity of
112:40 - log n so this determines correctness and
112:44 - this determines efficiency
112:46 - and then this is some additional
112:48 - information to help you that you can
112:49 - assume all the numbers in the list are
112:51 - unique
112:53 - if this was not mentioned you would also
112:55 - have to handle the case where your list
112:57 - does not contain unique numbers
113:02 - now we will apply the method that we
113:04 - have been applying all throughout
113:07 - this course for solving the problems
113:10 - number one state the problem clearly
113:12 - identify the input and output formats
113:14 - number two come up with some example
113:16 - inputs and outputs and try to cover all
113:18 - the edge cases number three come up with
113:21 - a correct solution for the problem and
113:23 - state it in plain english
113:25 - number four implement the solution and
113:27 - test it using some example inputs and
113:30 - having test cases and then
113:32 - implementing a solution allows you to
113:34 - test them using the example inputs and
113:36 - fix any bugs that's why it's very
113:38 - important to have some test cases number
113:40 - five analyze the algorithm's complexity
113:42 - and identify any inefficiencies and
113:44 - number six apply the right technique to
113:46 - overcome the inefficiency
113:49 - and then you go back and repeat steps
113:51 - three to six come up with the correct
113:52 - solution implement the solution and test
113:55 - it and analyze the algorithm's
113:56 - complexity
113:58 - and you can review lesson one for a
114:00 - detailed explanation of this method
114:03 - now let's apply it step by step
114:05 - the first step is to state the problem
114:06 - clearly and identify the input and
114:08 - output formats now while it is stated
114:11 - clearly enough it always helps to
114:13 - express it in your own words in the way
114:14 - that it makes it most clear for you and
114:17 - this is something that you can keep
114:18 - returning to rather than the original
114:20 - problem statement
114:22 - because this is something that you will
114:23 - understand better
114:24 - and it's okay if your problem
114:27 - overlaps with the original problem
114:28 - statement but do try to express it in
114:30 - your own words so in this case what i've
114:32 - just done is i have double clicked here
114:35 - once you double click you can now edit
114:37 - this text cell and now we can start
114:39 - writing a problem
114:41 - so let's say given a rotated list
114:45 - we need to find the
114:47 - number of times
114:50 - it was rotated and okay i think what
114:53 - i've probably missed here is that it is
114:56 - a sorted list so given a
115:00 - sorted list that was
115:03 - rotated
115:06 - some unknown number of times
115:13 - we need to find the number of times it
115:15 - was rotated right maybe i'm just going
115:17 - to say given a rotated sorted list
115:19 - because technically the input is not a
115:20 - sorted list it's a rotated sorted list
115:22 - so given a rotated short test list that
115:24 - was rotated an unknown number of times
115:26 - we need to find the number of times it
115:27 - was rotated now doing this exercise
115:29 - helps you
115:31 - determine
115:33 - if you've understood the problem
115:34 - correctly
115:36 - and you may often find that okay there's
115:38 - a certain detail in the problem that you
115:39 - missed
115:40 - okay but at this point i'm happy with my
115:42 - description
115:43 - and you will see that it is matching the
115:46 - description to a large extent
115:49 - but it's something that i understand
115:51 - better so i'll just refer to this from
115:53 - this point
115:55 - now i'm assuming here that i know what
115:56 - rotation and sorted means otherwise i
115:58 - could also include those
116:00 - then
116:01 - here's a question
116:02 - the function will you will write will
116:04 - take one input called nums
116:06 - what does it represent and give an
116:08 - example okay so
116:10 - once again we double click on this and
116:14 - one input is
116:17 - nums so this is
116:22 - a sorted
116:23 - rotated list
116:26 - and let's give an example here
116:29 - let's say we take the sorted list three
116:31 - five
116:32 - six seven
116:34 - nine
116:36 - and then we rotate it a few times
116:38 - let's say we rotate it a couple of times
116:42 - so we end up with this
116:43 - sorted rotated list
116:46 - so that's our input so we've answered
116:48 - the question here now the first question
116:50 - was to express the problem in your own
116:52 - words this is the solution
116:54 - the second question was what does the
116:56 - input norms represent give an example it
116:58 - represents a sorted rotated list 79356
117:02 - the third question is the function you
117:04 - will write will return a single output
117:06 - called rotations what does that
117:08 - represent well you have to write a
117:09 - function that identifies how many times
117:11 - the list was rotated so
117:14 - this is the number of times the sorted
117:17 - list was
117:19 - rotated
117:21 - okay
117:23 - and in this case the example that we
117:25 - have is that this sorted list was
117:27 - rotated twice
117:29 - three five six seven nine was rotated
117:31 - two times
117:33 - so you mentioned two here now you can
117:35 - see these back quotes that i'm using
117:37 - here this is next to
117:40 - the number one on your keyboard or below
117:42 - the escape key
117:44 - what these backwards let you do is they
117:46 - let you
117:47 - express text as code within markdown you
117:50 - can see that they have a gray background
117:51 - and they have a different font this
117:53 - looks a lot more like code same is here
117:55 - true for nums so you can use markdown
117:58 - and its features
118:01 - to your advantage to organize your
118:03 - descriptions and your text better
118:07 - okay so now based on the above we can
118:09 - now create a signature of our functions
118:11 - we have a function called counts
118:12 - rotations it takes the num list of
118:14 - numbers and it returns well right now
118:17 - we're just putting pass in here but we
118:19 - know that it's going to return a single
118:21 - number rotations
118:24 - now after each step remember to save
118:26 - your notebook so we are going to just
118:28 - run joven dot commit
118:31 - and now if you leave your computer you
118:33 - do not have to be worried that your work
118:36 - may be lost
118:37 - so you can go in here
118:39 - and you can
118:40 - open up this notebook from your joven
118:42 - profile and
118:44 - press run at any point to run this
118:46 - notebook
118:53 - now step two is to come up with some
118:55 - example inputs and outputs and try to
118:57 - cover all the edge cases and our
118:59 - function should be able to handle any
119:00 - set of valid inputs so here is some
119:03 - variations that you can encounter
119:05 - a list of size 10 rotated three times a
119:08 - list of size eight rotated five times so
119:10 - these are two generic examples and then
119:12 - a list that wasn't rotated at all a list
119:15 - that was rotated just once a list that
119:17 - was rotated n minus 1 times
119:20 - where n is the size of the list
119:22 - a list that was rotated n times
119:25 - and what do you mean by rotating the
119:26 - list n times well
119:29 - let's see
119:30 - an empty list and a list containing just
119:32 - one element and if you can think of more
119:34 - test cases you should definitely add
119:36 - more test cases here
119:38 - and what we'll do is we will express our
119:41 - test cases as dictionaries so
119:45 - this will help us
119:46 - organize the test cases and test them
119:48 - all at once more easily using helper
119:51 - functions
119:52 - so you can see here that we've organized
119:54 - one test case here and we've expressed
119:56 - the task as a dictionary so here we have
119:59 - the input to the test case that is the
120:01 - input key and then we have the output to
120:03 - the test case now because a function can
120:05 - take many arguments
120:07 - the input itself is going to be a
120:09 - dictionary and then for each argument in
120:11 - this case there's just one so we just
120:13 - call it nums
120:15 - we have the input here
120:18 - and this is the size of the output
120:22 - okay
120:22 - so
120:24 - let's create this test case
120:26 - and let us then
120:28 - if you want to fetch the actual input
120:31 - and output out of it so here we can
120:33 - fetch test input nums that's going to
120:35 - give us the nums we can use test input
120:39 - the output should be
120:41 - test outputs
120:42 - this seems to be an error
120:46 - and the result is count rotations num0
120:50 - okay so this is the actual result
120:52 - obtained by passing the test case into
120:54 - count rotations
120:56 - and you can see that the result we get
120:59 - back is none because right now we do not
121:01 - have any code we it just says pass
121:03 - inside
121:06 - and the result and the output are not
121:08 - equal because the output is the number
121:10 - three but the result is none so that's
121:12 - okay our test case is failing right now
121:14 - because we have not yet implemented the
121:16 - function
121:17 - but as soon as we implement it we expect
121:19 - to see the test case passing
121:20 - now to help you avoid all of this work
121:23 - we have given you a function called
121:24 - evaluate test case so from jovian.python
121:28 - dsa you can just import evaluate test
121:30 - case and then call evaluate test case
121:32 - with the function you want to test and
121:34 - the actual test case
121:37 - and you can see here it prints the out
121:39 - input that was passed in the expected
121:41 - output the actual output that was
121:43 - obtained and the test result in this
121:45 - case the test result was failed
121:47 - and the execution time is also printed
121:49 - here if you just want to evaluate
121:52 - if a certain implementation is faster
121:54 - than another
121:56 - so now your job is to create test cases
121:59 - for each of the scenarios listed above
122:02 - so here is test zero that is same as the
122:04 - original test case that we had created
122:06 - now here is test one a size a list of
122:09 - size eight rotated five times i will let
122:12 - you create this
122:13 - but it will look something like this you
122:15 - will open up you'll replace the three
122:17 - question marks with let's say a list of
122:19 - size eight so one two three four five
122:22 - six seven eight
122:24 - and you can imagine that if this was
122:26 - rotated five times then one two three
122:29 - four five four five of these numbers
122:32 - will then move
122:33 - to the first position
122:36 - and you get this as the input
122:39 - numbers and the output well
122:42 - it was rotated five times so i think you
122:44 - can guess that the output here should be
122:45 - five
122:47 - now here is a list that wasn't rotated
122:50 - at all
122:52 - what should be the output here
122:55 - i'm sure you can guess that the output
122:56 - here should be zero so i'll let you fill
122:58 - this out here is a list that was rotated
123:01 - just once
123:03 - so let's try let's fill out this one
123:08 - so this
123:12 - this list rotated once would give us
123:15 - seven three five
123:21 - there you go
123:23 - a list that was rotated n minus one
123:25 - times where n is the size of the list
123:28 - okay i'll let you do that
123:30 - a list that was rotated n times where n
123:32 - is the size of the list okay what does
123:33 - that look like
123:42 - so you take this list and then you first
123:44 - put 10 in the first position and then
123:46 - you put 9 in the first position so 9 10
123:48 - comes to the beginning and 3 5 7 8 comes
123:51 - after it
123:52 - then you move 8 to the first position
123:53 - then you move 7 then you move five then
123:55 - you move three if you if you move all of
123:57 - these back to the first position you end
123:59 - up with the same list
124:00 - so you've rotated it n times
124:04 - now what should be the output in this
124:06 - case there are about six numbers here
124:09 - so is the output 6
124:13 - i don't know i'm not so sure because
124:15 - remember the question the original
124:17 - question says
124:20 - write a function to determine the
124:22 - minimum number of times the original
124:23 - sorted list was rotated to obtain the
124:25 - given list so it has to be the minimum
124:27 - number of times we may want to just go
124:30 - back and change this
124:31 - we need to find not
124:33 - the number of times it was rotated but
124:35 - the minimum number of times it was
124:36 - rotated or it needs to be rotated right
124:39 - so
124:40 - coming back here
124:44 - the output should be not six
124:47 - but
124:48 - zero
124:49 - so keep that in mind
124:51 - then here's an empty list i'll let you
124:53 - figure out what should be the nums and
124:55 - the output here
124:57 - and here is a list containing just one
124:59 - element
125:00 - once again should be pretty
125:02 - straightforward can you rotate a list
125:04 - with one element
125:06 - i'll let you decide
125:08 - and then we're taking
125:10 - all the tests and putting them into a
125:12 - single list now since i have not defined
125:14 - all the tests i am not going to use this
125:17 - definition which contains all the tests
125:18 - but i'm just going to pick the number of
125:20 - tests that i have defined
125:22 - so we have defined here test 0
125:26 - test 1
125:28 - test 3
125:30 - test 5
125:32 - i'm just going to put in
125:35 - test 0 test 1
125:37 - test 3
125:40 - and test 5
125:45 - and that's the full set of tests that we
125:48 - have
125:49 - you definitely need to fill out all the
125:51 - test cases and if you can think of some
125:54 - other cases that you should be testing
125:57 - then you should include those test cases
125:59 - here as well
126:01 - okay
126:08 - now to evaluate your function against
126:10 - all the test cases together you can use
126:12 - the evaluate test cases helper function
126:15 - from jovian so there are two functions
126:17 - evaluate test case works with a single
126:19 - test case and evaluate test cases works
126:22 - with
126:23 - a list of test cases
126:25 - so we have a list of test cases here i
126:26 - have four but you should have about
126:28 - eight at least and a few more if you
126:31 - have created them
126:33 - so we can import from juvenile python
126:35 - dsa evaluate test cases and then invoke
126:37 - evaluate test cases
126:39 - with
126:40 - the count rotations function
126:42 - still it we don't
126:46 - have any logic in the function so all
126:48 - the test cases should pass and the list
126:50 - of test cases we've created so you can
126:51 - see test cases zero fails one fails two
126:54 - fails three fails
126:56 - so out of the four test cases none of
126:58 - them
126:59 - have passed
127:02 - no problem
127:03 - we have completed step two which is to
127:05 - create some test cases and we'll know
127:08 - once we've defined a function whether
127:10 - the function definition is correct
127:13 - now the next step is to come up with a
127:14 - correct solution for the problem and
127:15 - state it in plain english
127:18 - and there's a hint here for you already
127:21 - coming up with the correct solution is
127:22 - quite easy and it's based on this simple
127:25 - insight if a list of sorted numbers is
127:27 - rotated k times so you keep rotating it
127:30 - step by step moving the last number to
127:33 - the
127:34 - first position
127:36 - then the smallest number in the list
127:38 - ends up at position key
127:40 - and you can verify this it's very simple
127:43 - to do this
127:44 - whenever you have a doubt just create a
127:46 - new cell by the way you can create a new
127:48 - cell by clicking on the left side of a
127:50 - cell
127:50 - and clicking insert cell below
127:53 - or if you're in a code cell just click
127:56 - here near the prompt and press the b
127:57 - character
128:00 - and that adds a new cell below
128:03 - so let's take the list 1 3 5 7
128:07 - 5 6 7
128:09 - and let's rotate it k times let's try
128:12 - with k equals 2 so if you set k equal to
128:15 - 2 then you're going to take two of these
128:17 - numbers from the very end
128:19 - and move them to the beginning so that
128:22 - means zero comes at position
128:24 - six comes at position zero seven comes
128:26 - at position one
128:27 - and the starting element in the sorted
128:30 - list now comes at position two
128:33 - that's interesting let's
128:35 - move the third element as well
128:38 - okay so now we've moved three elements
128:40 - or rotated the list three times and the
128:42 - smallest element ends up at position
128:44 - three
128:45 - so it seems to hold true
128:48 - and you can verify this now with a
128:49 - larger list smaller list empty list and
128:51 - all the test cases that you have but if
128:53 - a list was sorted
128:54 - k times sorted list was rotated k times
128:57 - then the smallest number in the list
128:58 - ends up at position k
129:00 - counting from zero
129:02 - further it is the only number in the
129:04 - list which is smaller than the number
129:06 - before it and you can see this once
129:08 - again the smallest number is at position
129:10 - 3 and all of these numbers are
129:13 - higher than the numbers that come before
129:15 - them
129:16 - except the number 1 which is smaller
129:19 - than 7.
129:22 - so
129:24 - we simply need to check for each number
129:26 - in the list whether it is smaller than
129:28 - the number that comes before it if there
129:30 - is a number before it then our answer is
129:33 - simply which is the number of rotations
129:35 - is simply the position of this number
129:36 - right so if you can find the position of
129:39 - the number
129:40 - which is smaller than the number that
129:42 - comes before it the position of the
129:44 - number is also equal to the number of
129:46 - times the sorted list was rotated
129:48 - and if we cannot find such a number then
129:50 - the list wasn't rotated at all
129:54 - and that's it
129:55 - you can see here in this list now
129:57 - applying this logic 3 is the number
130:00 - the smallest number
130:02 - and not only that 3 is the only number
130:04 - which is lower than the number that
130:06 - precedes it the predecessor which is 29
130:09 - and since 3 occurs at position 4
130:12 - well actually three occurs at position
130:14 - three
130:17 - zero one two three
130:26 - the list was rotated exactly three times
130:31 - now we can use the linear search
130:33 - algorithm as a first attempt to solve
130:35 - this problem in the linear search simply
130:37 - involves working through
130:39 - this list walking through this list from
130:41 - the left to the right
130:43 - so now the
130:44 - task for use to describe the linear
130:46 - search solution in your own words and
130:48 - please write it in your own words but
130:49 - here's how i'm going to write it
130:54 - let's say create a variable
130:57 - position
130:58 - with values zero
131:00 - so this is the
131:02 - position for tracking this is for
131:03 - tracking the position
131:05 - then
131:07 - look at
131:08 - the number
131:11 - at
131:13 - the given position and not only look at
131:15 - it but
131:18 - compare the number at the let's say the
131:20 - current position
131:22 - to the
131:23 - number before it
131:26 - now if you're starting position with the
131:28 - value 0 maybe
131:31 - we may not there's no number before it
131:33 - so we may not be able to compare it with
131:34 - something
131:36 - we may even just start with the value
131:38 - one that's all right
131:41 - if the number is
131:46 - smaller than
131:49 - its
131:50 - predecessor
131:54 - then return position because position is
131:57 - the answer we found the number that is
131:58 - smaller than its predecessor there's
132:00 - only one such number
132:03 - otherwise
132:05 - increment
132:07 - position and repeat
132:10 - till we exhaust
132:14 - all the numbers
132:18 - okay
132:20 - simple
132:22 - now you can add more steps if
132:25 - your
132:26 - description of the algorithm requires
132:28 - more steps that's perfectly all right
132:30 - but at this point we have a very clear
132:32 - description of the solution now we're
132:34 - starting with the position
132:36 - 1 not 0 because we also want to track
132:38 - the previous position
132:40 - now we import jovian here and commit our
132:42 - project once again
132:44 - and keep saving your work after every
132:46 - step so that you can continue your work
132:51 - so now we're talking about
132:53 - implementing the solution and testing it
132:55 - so let's implement the solution we said
132:56 - that we want to start with position
133:00 - we want to start with position one
133:03 - and while
133:05 - when should the loop be terminated well
133:06 - while position
133:08 - is less than the length of nums
133:11 - i guess that's fair
133:13 - and then what is the success criteria so
133:15 - we have if position greater than zero
133:17 - and
133:19 - nums of position less than numbers of
133:23 - position minus one okay so that's the
133:26 - success criteria here now you can see
133:28 - that there's a condition if position
133:30 - greater than zero here so we don't
133:31 - really need to start position at zero we
133:33 - can start position at we don't really
133:36 - need to start position at one we can
133:38 - start position at zero as well and all
133:40 - that will happen is this condition will
133:41 - get skipped and position will get
133:42 - incremented and this is
133:46 - a good practice because whenever you
133:48 - iterate over a list you normally just
133:50 - want to start with 0 just to avoid any
133:53 - confusion
133:54 - later when you're reading the code that
133:56 - did you intend to write 0 here a 1 etc
133:58 - etc
134:00 - so just put in position equal 0 here and
134:03 - simply skip the check
134:05 - here or simply skip this comparison if
134:07 - position is not valid right so whenever
134:09 - you're accessing an element from inside
134:12 - a list or inside a dictionary you always
134:14 - want to make sure that that
134:17 - index
134:18 - or that key is valid okay here we are
134:20 - making sure that the
134:22 - key position minus 1 is valid by
134:24 - checking position greater than zero
134:27 - in any case we now have the logic and
134:29 - finally
134:30 - [Music]
134:31 - we are saying that if the number at
134:33 - position is less than the number that
134:35 - comes before it then we return that
134:38 - and that's just going to if it's not
134:39 - then it's going to increment the
134:40 - position and it's going to check again
134:42 - and again and again till we run out of
134:44 - numbers now if you've exa exhausted the
134:46 - entire list
134:49 - then it follows that
134:52 - there were no rotations or there were n
134:54 - rotations exactly in either case the
134:57 - number we returned should be zero okay
135:00 - so
135:01 - keep this in mind the sum
135:03 - you may have the doubt should you be
135:05 - returning -1 here or should you be
135:06 - returning 0 here
135:08 - well
135:09 - the question does specify clearly that
135:12 - you are given a sorted rotated list and
135:14 - you have to find the number of times it
135:16 - was rotated now obviously minus 1
135:18 - rotations are not possible so minus 1
135:20 - would not be a valid return value from
135:22 - your function
135:24 - and this is the reason we write test
135:25 - cases too
135:28 - now let's evaluate the test case
135:30 - so let's call evaluate test case for a
135:32 - single test case on count rotations
135:34 - linear and let's see what the test case
135:36 - is
135:39 - this is the test case here and this is
135:41 - the output
135:42 - we call evaluate test case with count
135:44 - rotations linear and test
135:46 - and that gives us a linear search result
135:50 - you can see here this was the number
135:52 - the list of numbers this was the
135:54 - expected output and this was the actual
135:56 - output so grade our function seems to
135:59 - have passed the test case
136:00 - now we can evaluate all the test cases
136:02 - by calling count rotations linear on all
136:04 - the test cases together and give that
136:07 - gives us a whole list of test results
136:10 - test case 0 and 1 and 2 and 3
136:13 - all of them have passed now if you had
136:15 - put n minus 1 here
136:21 - you would see
136:22 - that
136:26 - one of the test cases would fail
136:28 - which is
136:29 - the case where the list wasn't rotated
136:31 - at all or was rotated n times
136:35 - so that should tell you that the answer
136:37 - here should be
136:38 - zero
136:39 - [Music]
136:41 - so that's our linear search algorithm
136:44 - and
136:45 - at this point
136:47 - you may face issues
136:49 - you may feel stuck you may not be able
136:51 - to figure out how to write the code
136:54 - and that's perfectly all right that's
136:55 - part of learning
136:57 - you may face errors you may face
136:59 - exceptions for instance if you did not
137:01 - have this check here
137:03 - position greater than zero or maybe you
137:06 - what you had here was
137:09 - some other condition
137:10 - like position less than equals position
137:13 - plus one
137:15 - and that's okay
137:16 - then you can go to the forum and post
137:18 - your issue so let's open up the forum
137:21 - here
137:23 - this is the
137:27 - forum discussion for assignment one
137:29 - and you can go into the original topic
137:31 - here
137:33 - which is a
137:35 - longer discussion so this is where
137:37 - everybody is posting small issues so you
137:38 - can see that there's about 321 messages
137:41 - that have been posted you can start
137:42 - looking through this forum you can start
137:44 - reading through some of the posts you
137:46 - can even search if you press ctrl f and
137:48 - you can even search for questions here
137:50 - now if you want to post your own
137:52 - question
137:53 - scroll down to the very end or you can
137:55 - just click this button here
137:57 - and click reply
137:59 - okay and mention your question here i
138:01 - have a
138:02 - [Music]
138:04 - an issue
138:06 - should i return -1 or 0 in the case
138:10 - the list
138:11 - has not been rotated
138:14 - okay maybe that's and
138:16 - if you want if you have
138:18 - code that's not working or there's an
138:19 - error you can also include a screenshot
138:21 - of your code or i'll show you another
138:23 - trick
138:24 - you can actually include
138:27 - let's say you commit your notebook
138:30 - so let me come up here i've committed my
138:32 - notebook
138:36 - and if you have a particular line of
138:38 - code that you want to share
138:40 - you can actually click
138:42 - copy cell link
138:44 - and paste it here
138:47 - so that will give a link to the entire
138:49 - cell
138:50 - and if somebody clicks on the link then
138:52 - they can view that specific cell of the
138:55 - notebook directly let's see
139:04 - you can see here that it brings us
139:06 - directly to this specific cell
139:09 - there's another option you can even
139:11 - click on
139:12 - embed cell
139:15 - okay for embed for secret notebooks we
139:17 - do not allow embedding but copying the
139:19 - cell link should work
139:24 - and then click reply and your question
139:26 - will be posted and somebody will reply
139:29 - to your
139:30 - question just come back to the forum in
139:33 - a few hours or maybe the next day and
139:34 - you should see an answer you will also
139:36 - receive an email
139:42 - so that's the discussion topic you can
139:44 - also go back to the topic here the
139:46 - category here and create a new
139:49 - question you can see that if you want to
139:50 - start your own thread
139:52 - if you think your question deserves a
139:55 - deeper discussion where multiple people
139:57 - can reply you can also create a new
139:59 - thread by clicking new
140:00 - topic okay so keep this in mind and do
140:04 - make use of the forum what we've seen is
140:06 - people who are active on the forum are
140:08 - at least four to five times more likely
140:10 - to complete the course and earn the
140:11 - certificate of accomplishment
140:13 - and continue working on these topics
140:17 - after the course as well
140:24 - okay so the next step is to analyze the
140:26 - algorithms complexity
140:29 - and the way to do this if you've seen
140:30 - lesson one is to simply count the number
140:32 - of iterations the number of executions
140:34 - of the while loop
140:38 - now if you have a list of numbers of
140:40 - size n
140:42 - then you can see here that this is the
140:45 - key loop here
140:47 - while position less than the num length
140:48 - of numbers
140:49 - so then there will be n loops or n
140:52 - iterations and then inside each each
140:54 - iteration we're performing certain
140:55 - comparisons and returning things so all
140:57 - of these are
140:58 - in effect constant time and based on
141:00 - this you can probably tell
141:03 - that the complexity of linear search is
141:06 - order of n so you can just put in
141:09 - a big o
141:10 - and in the big o notation this would be
141:12 - order n
141:14 - so that's the first part of the
141:15 - assignment linear search
141:17 - now the next step is to apply the right
141:18 - technique to overcome the inefficiency
141:20 - and that's where you can now
141:22 - you can now read through the rest of the
141:24 - assignment now the idea here is this
141:27 - binary search is the technique we'll
141:29 - apply
141:30 - and the key question
141:33 - we need to answer in binary search is
141:35 - given the middle element
141:37 - can you decide if it is the answer which
141:40 - means if it is
141:42 - let's say the smallest number in the
141:44 - list
141:45 - or whether the answer lies to the left
141:48 - or the right of it okay so given the
141:50 - middle given if the middle element is
141:52 - smaller than its predecessor
141:55 - then it is the answer we already know
141:56 - that because there's only one number in
141:58 - the list that is smaller than its
141:59 - predecessor so you can see here for
142:01 - example
142:02 - now if the middle element was 1 which
142:05 - it's not but suppose the middle element
142:07 - was 1 and you can see that 1 is smaller
142:09 - than 8 then we know that 1 is the answer
142:11 - so the position of the middle element is
142:13 - the answer
142:15 - however if it isn't
142:17 - then we need a way to determine whether
142:19 - the answer lies to the left of the
142:20 - middle element or to the right of it
142:23 - and consider these examples so here you
142:25 - can see that the middle element is 3
142:27 - and the answer is
142:30 - the position
142:31 - 2
142:32 - so
142:34 - in this case the answer or the smallest
142:37 - element lies to the left
142:40 - on the other hand in this case you can
142:41 - see the middle element is 4 and the
142:43 - smallest element minus 1 lies to the
142:45 - right of it
142:47 - so now you need to apply your mind and
142:48 - think of a check that will help you
142:50 - determine if the middle element
142:53 - given the middle element if the answer
142:55 - lies to the left or the right of it
142:57 - right and we're looking for the smallest
142:58 - element remember so the logic here if
143:00 - you just spend a couple of minutes you
143:02 - will come up with this quite easily if
143:04 - the middle element of the list is
143:06 - smaller than the last last element of
143:08 - the list okay
143:10 - or the last element of the range that we
143:12 - are currently looking at that means that
143:14 - all the numbers here are in increasing
143:16 - order
143:18 - so then the answer lies to the left of
143:20 - it
143:22 - on the other hand if the middle element
143:25 - of the list is
143:27 - larger than the
143:30 - last element of the range
143:32 - that means that because we know that the
143:34 - list is a rotated sorted list so that
143:36 - means that the numbers increase up to a
143:38 - point and then there's a decrease and
143:40 - then they continue increasing that's the
143:42 - only way in which the final element can
143:43 - be smaller
143:48 - so that means the answer lies to the
143:49 - right of it so that's the logic here for
143:51 - binary search
143:53 - and now what you have to do is describe
143:55 - the binary search solution in your own
143:58 - words so here once again you have these
144:00 - four five
144:01 - lines
144:02 - it's very important that you do this
144:04 - because if you cannot express it then
144:06 - coding it is also going to be difficult
144:08 - for you so always do this exercise of
144:10 - expressing the solution in your own
144:12 - words when you're practicing when you're
144:14 - solving a coding challenge or something
144:16 - even in an interview it's also very
144:18 - important
144:19 - because the first thing you need to do
144:21 - is to communicate to the interviewer
144:23 - your thought process and how you're
144:25 - thinking about the problem so the first
144:26 - thing you need to do is describe a
144:27 - simple solution in your in simple words
144:30 - and then they may or may not ask you to
144:31 - code that solution and then the next
144:33 - thing is to identify the
144:35 - complexity or identify the inefficiency
144:39 - then the next step for you is to
144:41 - describe the optimal solution or the
144:43 - binary search solution in your own words
144:45 - okay now
144:48 - if you don't describe the solution in
144:49 - your own words and you start writing the
144:51 - code they may not be able to follow your
144:52 - code
144:53 - so even if you've written mostly correct
144:55 - code maybe with one or two edge cases
144:57 - wrong
144:58 - they may still have a feeling that you
145:00 - don't know what you're writing but if
145:02 - you explain the solution clearly to them
145:04 - they will know that now you understand
145:06 - the solution
145:07 - and they will be able to follow the code
145:09 - as you write it
145:10 - and they will be able to pick up
145:12 - mistakes or errors and help you with the
145:15 - errors
145:16 - one secret is that interviews are always
145:18 - open to helping you
145:20 - unless you
145:22 - make them really confused
145:24 - so keep that in mind and describe the
145:26 - solution in your words
145:28 - once you do that you can commit now the
145:31 - next step is to implement the solution
145:33 - now the implement the binary search
145:35 - solution as described in the previous
145:37 - step
145:41 - let's run this again
145:52 - so you run count rotations define the
145:54 - function count rotations binary now you
145:56 - may want to review lesson one here on
145:58 - how to start it out
146:00 - you'll see that low starts out at zero
146:03 - and high starts out at length
146:06 - nums minus 1
146:08 - and i will not solve the rest of this
146:11 - but there is a certain condition here
146:13 - between low and high so in binary search
146:15 - we are starting with the entire list as
146:17 - the range then we are looking at the mid
146:19 - number so we're getting the first the
146:20 - mid position and we look at the number
146:22 - at the mid position
146:24 - then
146:25 - we check if the middle position is the
146:27 - answer so if the middle person is the
146:29 - answer we return the middle position
146:31 - then we check if the answer lies in the
146:33 - left half so here's a condition where
146:35 - you decide if the answer lies in the
146:36 - left half and we
146:38 - once if the condition holds true all we
146:41 - do is we change the high so which we
146:43 - change the end point of the range
146:45 - to mid minus one and then we check if
146:48 - the answer lies in the right half
146:50 - in that case we change the starting
146:51 - point of the range to mid plus one and
146:53 - the while loop repeats okay so that's
146:55 - the general logic of binary search and
146:57 - one thing you have to keep in mind is if
147:00 - none of the elements satisfy the
147:02 - criteria that you have what is the
147:04 - answer and this is a very important
147:06 - condition this is where
147:09 - it is very easy to go wrong
147:11 - it is also called the edge case or the
147:13 - trivial case so you should handle and
147:15 - think about this carefully
147:17 - and then once you've done that you can
147:19 - evaluate the test case and you can a
147:21 - single test case you can evaluate
147:23 - multiple test cases now if your test
147:25 - cases are failing you may want to enable
147:28 - this print statement inside by
147:29 - uncommenting it
147:31 - but make sure to comment it out at the
147:32 - end once again
147:34 - and the print statement will help you
147:36 - see what the low high and mid points
147:38 - were now you may want to then take a pen
147:40 - and paper look at an example that is
147:42 - failing
147:43 - and see if the printed numbers match
147:46 - what you expect to see
147:48 - debugging your function is a very
147:51 - important skill
147:52 - so keep that in mind
147:57 - and use a debugging technique like this
147:59 - by adding print statements and working
148:00 - out the same problem side by side on
148:02 - paper to fix your issues
148:04 - otherwise you may feel lost if you're
148:06 - not able to look into the internal
148:08 - workings of the function
148:13 - next you have to analyze the algorithms
148:15 - complexity and identify inefficiencies
148:18 - this should be straightforward enough
148:20 - we've already looked at the complexity
148:21 - of binary search but all you need to do
148:23 - is make sure that what you're doing
148:24 - within the algorithm matches the
148:26 - analysis that we've done earlier so the
148:29 - problem size reduces by half each time
148:31 - and then we are doing constant work
148:33 - in each step before solving a problem of
148:35 - half the size
148:37 - so that should roughly give you an
148:38 - answer
148:40 - and keep committing your work
148:44 - now finally to make a submission you
148:46 - have two options
148:48 - now one option is to take this link so
148:50 - your notebook has been committed here
148:53 - and you can come to the
148:55 - assignment page let's open up the
148:57 - assignment page binary search practice
148:59 - come down here and paste this
149:03 - link here and click submit
149:06 - now once you click submit the assignment
149:09 - will be submitted and
149:12 - it will go into automated evaluation so
149:14 - in about
149:16 - a couple of minutes maybe up to an hour
149:19 - depending on the queue of
149:20 - submissions from different participants
149:23 - you will receive
149:25 - a grade over email
149:27 - let's just refresh the page
149:30 - and it seems like
149:32 - there was an issue here the issue was
149:34 - that count rotations binary was not
149:36 - defined
149:38 - so it's possible that
149:40 - this happened
149:41 - contradictions binary did not get
149:43 - defined because there are a bunch of
149:45 - question marks here
149:46 - so we may need to then fix the issue and
149:49 - then come back
149:52 - and make a submission once again
149:54 - okay
149:54 - so i have received failed grade i will
149:56 - go back and i will fix the issue and
149:58 - then come back okay now it's very
150:00 - important for you that's why to have
150:02 - good asset good set of test cases for
150:04 - you to test your function
150:10 - so that
150:11 - when you submit it or when you get an
150:13 - error you can maybe look at your
150:17 - functions performance on the test cases
150:19 - and fix anything that needs to be fixed
150:21 - and add new test cases if you need to
150:24 - now one other way you can submit
150:27 - is by simply running the code by joven
150:29 - dot submit assignment equals python dsa
150:32 - hyphen assignment 1 the code is
150:33 - mentioned here
150:34 - you can see here that the submission was
150:36 - made and you can verify your submission
150:38 - on this page
150:40 - ok
150:41 - so
150:43 - that's assignment1
150:47 - so what should you do next
150:49 - review the lecture video if you need to
150:52 - and execute the jupyter notebook
150:54 - you may need to keep you may want to
150:55 - keep the jupyter notebook running side
150:57 - by side as you're working on the
150:58 - assignment then complete the assignment
151:00 - and even attempt the optional questions
151:02 - if you scroll down here on the
151:04 - assignment notebook
151:05 - you will find that there are some
151:07 - optional questions for you
151:11 - here's one bonus question use the
151:13 - generic binary search algorithm so
151:15 - inside the python dsa
151:17 - module in jovian there is a function
151:19 - called binary search you can use the
151:21 - generic binary search example
151:25 - then here's an optional bonus question
151:26 - two handle repeating numbers we did say
151:28 - that you can assume that
151:32 - there are no
151:33 - repeating numbers in the list but here's
151:36 - one list with repeating numbers can you
151:37 - modify your solution to handle the
151:39 - special case
151:40 - and then here's an optional bonus
151:42 - question three
151:44 - about searching in a rotated list so
151:46 - you're given a rotated list now instead
151:48 - of finding the number of times it was
151:49 - rotated you you're trying to find the
151:51 - position of a certain number for
151:52 - instance the position of six
151:54 - can you apply binary search and modify
151:56 - your previous solution slightly
151:59 - to search within the rotated list and
152:02 - find the position of a given number
152:05 - now here's a hint
152:07 - you can simply
152:09 - identify two sorted sub-arrays within
152:11 - the given array
152:13 - and perform a binary search on each
152:14 - sub-array
152:17 - using so to identify the two sorted
152:20 - sub-arrays you can use the count
152:21 - rotations binary function so that's one
152:23 - potential solution another way is to
152:25 - modify the counter rotations binary
152:29 - function to solve the problem directly
152:31 - so it's a very interesting problem to
152:32 - solve
152:33 - and if you found the assignment easy
152:35 - then you should definitely solve these
152:36 - bonus questions and if you can solve
152:38 - this question
152:40 - by yourself without taking additional
152:43 - help
152:44 - then you can solve pretty much any
152:47 - problem related to binary search that
152:49 - may be asked in an interview because
152:52 - most of the questions are some
152:53 - variations of something like this and
152:54 - this is pretty much the hardest problem
152:56 - you may get asked
152:59 - you can also test your solution by
153:01 - making a submission on lead code and
153:02 - this is only for the final optional
153:04 - question
153:05 - and there's a thread
153:07 - on the forum where you can discuss the
153:09 - bonus questions separately as well
153:11 - so do make use of the forum thread too
153:17 - here it is optional bonus questions
153:18 - discussion
153:20 - so that was assignment one of data
153:22 - structures and algorithms
153:25 - this is called binary search practice
153:29 - hello and welcome to data structures and
153:31 - algorithms in python this is an online
153:33 - certification course by jovian
153:37 - my name is akash and i am the ceo and
153:39 - co-founder of jovian
153:41 - you can earn a certificate of
153:42 - accomplishment for this course by
153:44 - completing four weekly assignments and
153:46 - doing a course project today we are on
153:48 - lesson two of six
153:51 - now if you open up pythondsa.com
153:54 - you will end up on this course website
153:55 - where you will be able to find all the
153:57 - information for the course you can view
153:59 - the previous lessons which is lesson one
154:01 - and uh you can also
154:03 - work on the previous assignment which is
154:05 - assignment one
154:06 - and you can also check out the course
154:08 - community forum where
154:09 - you can
154:10 - get help and have discussions
154:13 - so let's open up lesson two
154:16 - this is a lesson page here you will be
154:18 - able to see
154:20 - the video for this lesson
154:23 - you can watch live or you can watch a
154:24 - recording here and you can also see a
154:27 - version of this video lecture in hindi
154:31 - and in this lesson we'll explore the use
154:33 - cases of binary search trees and develop
154:35 - a step-by-step implementation from
154:37 - scratch solving many common interview
154:39 - questions along the way
154:41 - so
154:42 - here is the code that we are going to
154:44 - use in this lesson all the different
154:47 - notebooks containing the code are listed
154:49 - here and let's open up the first one
154:58 - so here you can see all the explanations
155:00 - and the code for this lesson this is
155:02 - binary search trees traversals and
155:04 - balancing in python
155:07 - and this is the second notebook in the
155:09 - course you can check out the first
155:10 - notebook in lesson one
155:12 - and if you're just joining us
155:14 - this is a beginner friendly course and
155:16 - you do not need a lot of background in
155:18 - programming with a little bit of
155:20 - understanding of python and a little bit
155:22 - of high school mathematics you should be
155:23 - able to follow along just fine if you do
155:26 - not know these then you can follow these
155:29 - tutorials to learn the prerequisites in
155:30 - just about an hour or two
155:34 - now the best way to learn the material
155:36 - that we are covering in this course is
155:38 - to actually run the code and experiment
155:41 - with it yourself
155:43 - so to run the code and you can see here
155:45 - if we scroll down you can see that there
155:47 - is some code here on this page as well
155:49 - now to run the code you have two options
155:51 - you can either run it using an online
155:54 - programming platform or you can run it
155:57 - on your computer locally
156:00 - so to run this code we will scroll up
156:03 - and click on the run button and then
156:05 - click run on binder
156:07 - and this is going to start executing the
156:10 - code that we were just looking at
156:12 - so once again you can go on the course
156:14 - page pythondsa.com
156:17 - open up lesson2
156:19 - and you can watch the video there and on
156:21 - lesson 2 you can open up the link to the
156:24 - code where you can read the code and the
156:26 - explanations here
156:28 - and if you want to run the code just
156:30 - click the run button and that will
156:32 - execute the code for you
156:35 - so once you click the run button on
156:37 - binder
156:38 - you should be able to
156:40 - see
156:41 - an interface like this this is the
156:42 - jupyter notebook interface the same
156:45 - explanations that we were seeing on the
156:47 - lesson page you can see here the same
156:49 - explanations are now available here
156:51 - but the difference is you can now edit
156:53 - these explanations and you can go down
156:55 - and you can actually run some of the
156:56 - code in this tutorial you can see here
156:59 - that you have a run button and when you
157:00 - click the run button that is going to
157:01 - run the code in this particular cell and
157:04 - this is a jupyter notebook made up of
157:06 - cells now we'll do a couple of things
157:08 - here the first thing we'll do is we
157:10 - click on
157:10 - kernel and click on restart and clear
157:13 - output what this will do is this will
157:15 - clear all the outputs of the code cell
157:17 - so that we can execute them ourselves
157:22 - and then i'm just going to zoom in here
157:27 - and hide the interface so that we can
157:28 - look at
157:30 - the explanations and the code
157:33 - so finally we have some running code
157:36 - and in this notebook we will focus on
157:38 - solving this specific problem and this
157:41 - is a common question
157:42 - a question of this sort can be asked in
157:44 - interviews so this is an interview
157:46 - question but along the way we will also
157:48 - learn how to build binary trees and
157:50 - binary search trees and how to apply
157:52 - them to several other questions so
157:54 - here's the question
157:56 - as a senior back-end engineer at jovin
157:58 - you are tasked with developing a fast
158:00 - in-memory data structure to manage
158:02 - profile information which is username
158:04 - name and email for 100 million users it
158:07 - should allow the following operations to
158:08 - be performed efficiently you should be
158:10 - able to insert the profile information
158:12 - for a new user find the profile
158:14 - information for a user given their
158:16 - username and then update the profile
158:18 - information of a user once again given
158:20 - their username
158:21 - and list all the users of the platform
158:23 - sorted by username
158:25 - and you can assume here that usernames
158:27 - are unique
158:28 - so this is a very realistic problem that
158:31 - you might face if you're working at a
158:32 - company where you have a lot of users
158:36 - so let's see how we solve this problem
158:40 - now here's a systematic strategy that
158:42 - we'll apply for solving problems not
158:44 - just here but throughout this course
158:46 - this first step is state the problem
158:48 - clearly and in abstract terms and then
158:50 - identify the input and output formats
158:53 - then come up with some example inputs
158:55 - and outputs to test any future
158:58 - implementations and try to cover all the
159:00 - edge cases
159:01 - and then come up with a simple correct
159:03 - solution for the problem
159:05 - it doesn't have to be efficient it just
159:06 - has to be correct and stated in plain
159:08 - english and then implement the solution
159:11 - and test it using some example inputs
159:14 - fix bugs if you face any
159:16 - and finally analyze the algorithms
159:18 - complexity and identify inefficiencies
159:21 - if any
159:23 - now once you identify inefficiencies
159:25 - then we apply the right technique and
159:27 - that's where data structures and
159:29 - algorithms comes into picture so we
159:31 - apply the right technique to overcome
159:32 - the inefficiency and then we go back to
159:35 - step three so come up with a new correct
159:37 - solution which is also efficient state
159:39 - it in plain english implement it and
159:41 - then analyze the complexity now if you
159:44 - follow this process you should be able
159:45 - to solve any programming problem or
159:47 - interview question
159:50 - so step one we state the problem clearly
159:53 - and we identify the input and output
159:54 - formats now we can reduce the problem to
159:57 - a very simple single line statement we
159:59 - need to create a data structure which
160:01 - can efficiently store 100 million
160:04 - records
160:06 - and
160:07 - we should be able to perform insertion
160:09 - search update and list operations
160:11 - all of them as efficient as possible
160:15 - now the input the key input to our data
160:18 - structure the solution that we are
160:20 - building
160:21 - is going to be user profiles
160:25 - which contains username name and email
160:27 - of a user
160:28 - now before we come up with a solution we
160:31 - need a way to represent user profiles
160:33 - and a python class would be a great way
160:35 - to represent the information for a user
160:37 - so you may have heard of the term
160:39 - object-oriented programming and that is
160:42 - what we're going to look at now
160:44 - if you're not familiar with the class
160:45 - it's very simple a class is simply a
160:47 - blueprint for creating objects and
160:49 - what's an object well everything in
160:51 - python is an object whether you're
160:52 - looking at a number a dictionary a list
160:55 - anything and you can create your own
160:57 - custom objects with custom properties
160:59 - and custom methods
161:01 - by creating your own custom classes
161:03 - so here's the simplest possible class in
161:06 - python with nothing inside it we're
161:07 - creating a class user so this is how you
161:09 - declare a class and then when putting
161:11 - nothing inside it so whenever you put
161:13 - nothing inside a function or a class or
161:15 - anything
161:16 - you can put you need to put the pass
161:18 - statement because python cannot accept
161:20 - empty blocks of code so here we're
161:23 - creating a class which does not have
161:25 - anything inside it
161:27 - and we can create an object or it's
161:29 - often called instantiation which is take
161:32 - creating an instance of a class
161:34 - instantiate an object of the class by
161:36 - calling it like a function so we say
161:38 - user1
161:40 - is user
161:42 - so this creates an object and the
161:44 - variable user1 points to that object now
161:47 - we can verify that the object is off the
161:48 - class user by simply printing it
161:51 - or by checking its type
161:53 - user1 and typeuser1 are both user
161:57 - now the object user one does not contain
161:59 - any useful information
162:01 - so let's add what's called a constructor
162:04 - method so constructor method is used to
162:06 - construct an object
162:08 - to store some attributes and properties
162:12 - so now we're defining the class user
162:13 - once again but inside it we're defining
162:15 - this function and you can see that this
162:17 - function is inside the class because
162:19 - there is some indentation here
162:21 - so we define this function underscore
162:23 - underscore init
162:24 - and it takes four arguments now the
162:26 - first argument is a special argument
162:28 - called self and we'll talk about this
162:30 - and then we have three arguments
162:32 - username name and email
162:34 - and inside in it what we're doing is
162:36 - we're
162:37 - setting self.username so we're setting a
162:40 - property on self to username we're
162:42 - setting a property on self to name and
162:44 - we're setting a property on self to
162:45 - email
162:47 - and finally we're printing user created
162:49 - so let's see let's create another user
162:52 - user2
162:53 - and you can see that user 2 is also
162:56 - an object of the class user now here's
162:58 - what happening conceptually when we do
163:00 - this
163:01 - the first thing that happens is
163:03 - when you invoke this function when you
163:05 - invoke user as a function python first
163:08 - creates an empty object of the class
163:10 - user
163:11 - and then stores it in the variable user
163:13 - too
163:15 - and then
163:16 - python invokes the init function
163:20 - and to the init function it passes user
163:22 - to the object that was just created as
163:23 - self
163:24 - and then the other arguments that were
163:26 - passed while creating the object
163:28 - as the rest of the arguments so you can
163:30 - imagine that we are basically doing
163:34 - we are basically calling user dot
163:36 - underscore underscore init
163:39 - the function with user to an empty
163:42 - object
163:43 - and these arguments john johndoe and
163:46 - jondo.com and then inside the init
163:48 - function we simply set these properties
163:50 - on user two so now we get user two dot
163:52 - username is
163:54 - john user two dot name is john doe and
163:56 - user two dot email is
163:58 - johndoejohneddo.com
164:00 - so that's basically how classes work in
164:02 - python
164:03 - and that's why you always have this
164:05 - additional
164:06 - extra argument in all class methods
164:08 - which will refer to the object that
164:11 - finally gets created
164:13 - okay
164:14 - so
164:17 - once user two is created with the values
164:20 - john john doe and john doe dot com you
164:22 - can check that user two dot name
164:26 - is john doe and user two dot email
164:29 - is john doe dot com and user two dot
164:31 - username is john
164:34 - now you can also define some custom
164:36 - methods in
164:37 - inside a class
164:38 - so obviously we had the init method but
164:41 - here we are also defining another method
164:43 - called introduce yourself now introduce
164:45 - yourself takes again two arguments the
164:48 - first argument is self which will
164:50 - refer to the actual object
164:52 - that gets created later
164:54 - and then we have a guest name and we
164:56 - basically say hi guest name i am
164:59 - such and such contact me at such and
165:01 - such so these blanks are filled in using
165:03 - the guest name self.name and self.email
165:06 - okay so that's how you define a method
165:08 - in a class so here we have
165:11 - another user we're creating jane and
165:13 - jane doe at janetddo.com
165:16 - and you can see here that when we call
165:18 - introduce yourself with david
165:21 - so user3
165:22 - which is jane becomes self and then
165:25 - david becomes guest name and that's why
165:28 - we get hi david i am jane doe contact me
165:31 - at geneto.com
165:33 - so that's a quick refresher on classes
165:36 - in python now there's a lot more to
165:37 - classes but the simplest thing you need
165:39 - to know is you how to define a class how
165:42 - to create a constructor
165:44 - which is underscore underscore init how
165:46 - to set some properties like we said the
165:48 - properties name email
165:51 - and username and finally how to define
165:53 - methods like we defined the method
165:55 - introduce yourself
165:57 - and that's all we will need today so we
165:59 - won't need much more than that
166:06 - and one final thing that we're doing
166:08 - with our class is we're defining two
166:09 - other special
166:11 - functions
166:12 - underscore underscore repr wrapper and
166:15 - underscore underscore str
166:21 - so now these two functions
166:26 - these two functions are used to create a
166:28 - string representation of the object and
166:31 - you can see here once we create an
166:32 - object user4
166:34 - now and if we try to print user four you
166:36 - can see that 4 is
166:39 - now printed like this so user 3 was not
166:41 - printed i mean user 3 was printed just
166:44 - as a user but with user 4 we have all
166:46 - this information printed here as well
166:49 - so now here's an exercise for you which
166:52 - also brings us to the first quiz of the
166:54 - day now we are going to do three quizzes
166:58 - in this video and you can answer these
167:01 - quizzes on linkedin
167:03 - so go to our linkedin profile if you see
167:06 - the posts you will see a new post here
167:09 - which will give you a question and the
167:11 - question is what is the purpose of
167:13 - defining the functions str and wrapper
167:16 - within a class and how are these two
167:18 - functions different now leave a comment
167:21 - with your answer
167:23 - and we will pick
167:25 - the right answer one right answer and
167:27 - one lucky winner will get a swag back
167:28 - from us
167:32 - so that was the input we have we now
167:33 - have a way to represent users by
167:36 - creating classes
167:38 - and then the output that we want the
167:40 - final output that we want to create for
167:42 - our problem is a data structure
167:44 - so a data structure is once again
167:47 - something that we can define using a
167:48 - class so we can define we can expect our
167:51 - final output to be a class called user
167:53 - database which has four methods insert
167:56 - find update and list all and insert
168:00 - takes a user and inserts it into the
168:01 - database find takes a username and
168:04 - returns the user
168:05 - update takes a user
168:08 - and updates the data for that user and
168:10 - finally list all returns a list of the
168:12 - users so this is what the class will
168:14 - look like and we have not implemented it
168:16 - yet
168:19 - but we now have an interface
168:21 - so now the next step is to come up with
168:23 - some example inputs and outputs so let's
168:26 - create some sample user profiles that we
168:27 - can use to test our functions once we
168:30 - implement them
168:31 - so we're going to create
168:33 - these seven user profiles you can see
168:35 - that we're creating these seven user
168:36 - profiles with a username name and an
168:39 - email and storing them in these
168:40 - variables
168:42 - using the user class that we have just
168:44 - defined earlier
168:47 - and we're also going to store the list
168:48 - of users
168:50 - in this variable called users
168:54 - and as you can see we can access
168:56 - different fields within a user profile
168:58 - using the dot notation so you can check
168:59 - biraj dot username is bharaj and biraj
169:02 - dot email is biraj example dot com and
169:05 - biraj dot name is bhiraj
169:09 - now you can also view a string
169:11 - representation of the user as we have
169:12 - seen so if we print the user you can see
169:14 - some information about the user and here
169:16 - is the full list of users that we have
169:18 - created so it's always a good idea to
169:20 - set up some input data set up some test
169:23 - inputs that you can use to test with
169:25 - your implementation later on
169:28 - and since we haven't implemented our
169:30 - data structure yet it's not possible to
169:31 - list any sample outputs
169:33 - but you can try to come up with some
169:35 - different scenarios to test any future
169:38 - implementations
169:39 - so let's let's list some scenarios for
169:41 - testing the methods of our user database
169:43 - class so the
169:45 - methods are insert find update and list
169:48 - all and for inserting you may want to
169:51 - test that you're inserting a user into
169:53 - an empty database of users so that's
169:55 - what's called an edge case and then the
169:57 - general case is to insert a user
170:01 - into the database assuming that the user
170:03 - already does not exist
170:05 - then another edge case is trying to
170:07 - insert a user with a username that
170:09 - already exists right so these are all
170:11 - the different ways in which you can use
170:12 - the insert function and there can be
170:14 - some more so here's an exercise for you
170:16 - try coming up with all the different
170:18 - scenarios in which you would like to
170:19 - test the different functions insert find
170:22 - update and list
170:26 - so that completes step two now we have
170:28 - some sample inputs and then we have
170:33 - some scenarios in which you we are going
170:35 - to finally test our function
170:37 - so the next step is to come up with a
170:39 - simple correct solution and then state
170:41 - it in plain english
170:43 - now here's a simple and easy solution to
170:45 - the problem
170:46 - we simply store the user objects in a
170:49 - list sorted by usernames
170:54 - that's simple enough and suppose we do
170:56 - that so inside our data structure we
170:58 - have a list
171:00 - which simply contains a bunch of user
171:02 - objects then the various functions can
171:04 - be implemented
171:06 - like this
171:07 - so you have the insert function the
171:08 - insert function simply requires looping
171:11 - through the list and then adding the new
171:13 - user at a position that keeps the list
171:15 - sorted
171:16 - so for instance if you have the users
171:19 - akash
171:21 - and siddhant already and then you're
171:23 - inserting the user biraj then you can
171:26 - tell that bharat should go between akash
171:28 - and hemanth in alphabetical order
171:31 - so that's how you insert a new user and
171:33 - maintain the sorted property of the list
171:36 - then to find a user we simply loop
171:38 - through the list and then find the user
171:40 - object with the username matching the
171:42 - query
171:43 - so that's you if you're looking for
171:46 - he-man for instance you start from the
171:47 - beginning you go through akash biraj and
171:49 - finally hit him and then you can
171:51 - retrieve the user object
171:53 - associated with hemanth
171:55 - and then you have update now updating is
171:58 - very simple as well it's similar to find
172:00 - so you find the user object matching the
172:02 - query and then update the details of
172:04 - that user object
172:06 - and then finally because our internal
172:07 - representation is already a list of user
172:10 - objects sorted by usernames so we can
172:12 - simply return that list when we want to
172:14 - list the users
172:19 - so that's our
172:20 - plain english description and it's
172:22 - always a good idea to describe your
172:24 - solution in plain english so
172:26 - that you can clarify any doubts you have
172:31 - and even during interviews it's a good
172:32 - idea to have a conversation with the
172:34 - interviewer before you actually
172:37 - implement the solution
172:44 - and now one
172:45 - fact that we can use is that usernames
172:48 - which are strings can be compared using
172:50 - the less than greater than or equal to
172:52 - operators so we can compare strings just
172:54 - like numbers in python
172:56 - so that will make it easy for us to
172:58 - implement these functions
173:00 - and that brings us to the implementation
173:03 - and the code for implementing these is
173:05 - also fairly straightforward so now we
173:06 - have the user database class we are
173:08 - actually implementing this class
173:10 - and here you see that we have a
173:11 - constructor and the constructor does not
173:14 - take any additional arguments apart from
173:16 - self and all we do is inside self we set
173:19 - a property.users and that property.users
173:23 - is set to an empty list
173:26 - then we come to insertion so now assume
173:29 - that we already have some users in our
173:31 - user database
173:32 - so we start out with a pointer set to
173:34 - zero
173:36 - and we go through all the valid
173:38 - positions in the users list so which is
173:40 - from 0 to n minus 1 if there are n users
173:43 - and then we find the first username
173:45 - greater than the new user's username so
173:47 - for instance if you're inserting a
173:50 - month then you go through akash and
173:52 - bhiraj and then finally you realize that
173:54 - the next value is probably siddhant so
173:57 - you want to insert
173:58 - before siddhant right so you want the
174:00 - first username that's greater than the
174:02 - new user's username
174:04 - and you check this property and as soon
174:06 - as you find the next that the next user
174:09 - is
174:11 - greater than the user that needs to be
174:13 - inserted we break out
174:16 - and then we insert that user at that
174:18 - position okay so this is the insertion
174:21 - you can it's a just four or five lines
174:23 - of code so you can work through this
174:25 - code try to read the score line by line
174:27 - and see how it works
174:30 - now similarly you have the find function
174:31 - the update function and the list
174:33 - function they're all pretty
174:34 - straightforward there's really not much
174:36 - here so this is an exercise for you
174:38 - because this is also the brute force of
174:40 - the simple implementation so this is an
174:42 - exercise for you to go through each of
174:44 - these functions and try it out and use
174:46 - the interactive nature of jupiter to
174:48 - experiment
174:51 - and add print statements inside each of
174:53 - the
174:55 - functions if you need inside each of the
174:57 - loops if you need more visibility into
174:59 - what's happening okay
175:01 - but what we will do is we will try and
175:03 - test this implementation out and the
175:06 - first thing we do is instantiating a new
175:08 - database of users
175:10 - using the user database class so here we
175:13 - say user database and that gives us a
175:15 - database of users
175:24 - and now let's insert some entries into
175:26 - this database so we can now insert for
175:29 - instance we can insert the value hemanth
175:31 - akash and siddhant
175:33 - so here we have inserted three values
175:36 - into the database and now we can
175:38 - retrieve the data for a given user given
175:41 - their username using the find method so
175:43 - now we say database dot find siddhant
175:46 - that returns a user and we can check the
175:49 - value of user and you can see that now
175:51 - we have retrieved the data for siddhant
175:53 - which is username siddhant name siddhant
175:55 - sinha and email siddhant example.com
175:59 - now let's try
176:01 - changing the information for a user so
176:04 - to change the information we can call
176:06 - database dot update and then simply pass
176:08 - in a new user object so let's say we
176:10 - want to change the information from
176:12 - sadhan cena to siddhant u
176:14 - so this is how we do it
176:16 - we call database dot update
176:21 - and now if you find the information once
176:24 - again now if you can't find call
176:25 - database dot find once again
176:28 - we get back
176:30 - a user object and this time with the
176:31 - updated information
176:33 - so we have created the database we have
176:35 - inserted some values into it and then we
176:37 - have retrieved values out of it and
176:38 - we've also updated them and finally we
176:41 - can retrieve a list of the users in
176:43 - alphabetical order
176:46 - so now if we list it out you can see
176:48 - here that we have
176:49 - the username akash we have the username
176:52 - himant and we have siddhant these are
176:54 - the three values that were inserted and
176:56 - they are all in alphabetical order of
176:58 - username
177:00 - now if we insert a new user let's say
177:02 - let we insert barrage
177:04 - we can make sure that bhiraj is inserted
177:07 - into the right position
177:10 - okay
177:11 - so that's how we use the data structure
177:13 - that we just created
177:15 - and you can use the empty cells
177:17 - here
177:19 - to try out the various scenarios when
177:21 - you run the notebook
177:23 - so just to recap
177:24 - we created a simple class inside which
177:27 - we are storing a list of users in sorted
177:30 - order of usernames
177:31 - and then insertion is pretty easy we
177:33 - simply loop through find the right
177:35 - position and insert any new values
177:37 - finding values is very easy as well we
177:39 - simply loop through and keep comparing
177:42 - and updating values is simply a matter
177:44 - of finding them and then updating that
177:46 - specific value and listing is simple
177:48 - because we can simply return
177:50 - the internal list representation that
177:52 - we're already storing in the sorted
177:54 - order of usernames
177:56 - so that's the simplest solution or one
177:58 - of the simplest solutions there can be
178:00 - even
178:01 - simpler solutions
178:02 - maybe so the next step now is to analyze
178:06 - the algorithms complexity and identify
178:09 - any inefficiencies
178:10 - so typically in an interview setting you
178:13 - may not want to implement the simplest
178:15 - solution so you you can actually skip
178:17 - step four you know when you've described
178:19 - what the simplest solution is in english
178:22 - in plain english which was step three
178:24 - you can directly jump to analyzing its
178:25 - complexity and then move on to
178:28 - optimization and implementing the
178:29 - optimized version but when you're
178:32 - practicing or when you're learning it's
178:33 - always a good idea to implement even the
178:36 - brute force solutions
178:38 - so let's analyze the complexity the
178:40 - operations insert find update involve
178:43 - iterating over a list of users and in
178:45 - the worst case they may take up to n
178:47 - iterations to return a result
178:50 - where n is the total number of users
178:53 - now the list all function
178:55 - is slightly different because it simply
178:57 - returns
178:58 - an existing list so the list all
179:01 - function does not take
179:02 - linear time it takes constant time
179:05 - now based on this information it's very
179:07 - easy to check to guess the time
179:09 - complexities of the various operations
179:11 - insert find and update have a order n
179:14 - first case time complexity which means
179:16 - they can
179:17 - take up to n iterations
179:21 - however the list function has an order
179:24 - one complexity which means irrespective
179:26 - of how many users you have in your
179:28 - database
179:29 - it returns the
179:30 - list in the same amount of time now if
179:33 - you want to display the list or if you
179:34 - want to iterate over the list that may
179:36 - take you additional effort but getting
179:38 - the list itself is a constant time
179:40 - operation
179:44 - so that was the time complexity and an
179:46 - exercise for you is to verify that the
179:48 - space complexity of each operation is
179:50 - order one
179:52 - and if you're wondering what we mean by
179:53 - complexity then you can go back and
179:55 - watch lesson one where we talk about
179:58 - analysis of all algorithms complexities
180:00 - and the big o notation
180:03 - what we're calling order of n the big o
180:05 - notation all of these explained in a lot
180:07 - more detail so you can go back to lesson
180:09 - one and check it out
180:12 - now we've created a simple solution and
180:14 - our first question might be
180:16 - to wonder if this is good enough and to
180:18 - get a sense of how long each function
180:20 - might take if there are a hundred
180:22 - million number users on the platform
180:25 - let's create a while loop let's create a
180:28 - for loop
180:30 - and let's run it for let's see how many
180:32 - this is one two three four five six
180:35 - seven eight so let's run it for 10
180:37 - million 100 million numbers so here we
180:40 - are creating a range of 100 million
180:42 - numbers
180:43 - and we're running a for loop which
180:45 - iterates over the entire range
180:47 - and we're simply performing a simple
180:48 - operation which we're not really using
180:50 - we just we're just multiplying the
180:52 - number by itself to simulate what might
180:54 - happen if we have
180:56 - a database of 100 million users and
180:59 - we're trying to access find a user now
181:01 - what is the worst case scenario here
181:04 - let's run this
181:06 - and you can already see that it is
181:07 - taking a while
181:09 - for 100 million users the loop takes
181:12 - about
181:13 - 10 seconds to complete here it took
181:15 - about 9.45
181:17 - and a 10 second delay for fetching user
181:19 - profiles will definitely lead to a sub
181:22 - optimal user experience and that may
181:24 - cause users to stop using the platform
181:26 - altogether now imagine you came to
181:27 - joven.ai and it took 10 or 15 seconds to
181:31 - load your profile and then maybe even
181:34 - longer to load the other information and
181:35 - display it
181:37 - you would not be happy with the
181:38 - experience
181:39 - and then a 10 second processing time for
181:41 - each user for each request each profile
181:44 - request will also significantly limit
181:46 - the number of users that can access the
181:48 - platform at a time because if you're
181:51 - running the backend server on one
181:53 - computer which has eight cores then
181:56 - each core will be busy for 10 seconds
181:58 - each time a user tries to access the
181:59 - platform so you can only serve about 8
182:02 - users in 10 seconds time
182:04 - now that's pretty bad
182:07 - that could significantly limit the
182:09 - number of users
182:10 - you will have a significant outage if a
182:12 - lot of users come to the platform
182:15 - or on the other hand you may have to
182:16 - increase the cloud infrastructure add
182:18 - more servers add bigger hardware more
182:20 - cores more ram
182:22 - and that could
182:24 - increase the cloud infrastructure cost
182:25 - for your company by millions of dollars
182:28 - so as a senior back-end engineer you
182:30 - must come up with a more efficient data
182:31 - structure
182:32 - and this is why choosing the right data
182:34 - structure for the requirements at hand
182:36 - is a very important skill
182:38 - now
182:39 - we can clearly see that using a sorted
182:42 - list of users may not be the best data
182:44 - structure to organize the profile
182:46 - information so let's see what better we
182:48 - can do here
182:50 - and before we do that
182:52 - let's save our work so remember that
182:55 - this notebook
182:57 - we were running it on an online platform
183:00 - called binder and binder can shut down
183:02 - at any moment because it is a free
183:04 - service
183:05 - so
183:06 - what you want to do is run pip install
183:09 - jovian
183:11 - and then import
183:13 - the jovian library
183:15 - and you can then run jovian.commit
183:19 - now when you run jovian.commit
183:21 - what this does is this captures a
183:23 - snapshot of your jupyter notebook
183:25 - whether you're running it on binder or
183:27 - you're running it on your own local
183:29 - computer
183:30 - and it saves the snapshot of this
183:32 - jupyter notebook on your jovian profile
183:35 - so here you can see now on my jovian
183:37 - profile
183:40 - i have this notebook
183:43 - and i can go back on my profile and view
183:45 - the other notebooks that i've created in
183:46 - the past so your jovian profile becomes
183:48 - a collection of all the jupyter
183:50 - notebooks that you're working on so
183:52 - always just it takes just a couple of
183:54 - lines import joven and run joven.com so
183:56 - always run your window commit inside
183:59 - your notebooks
184:00 - and if you want to resume any work that
184:02 - you were doing then all you need to do
184:04 - is click on the run button and then
184:06 - click run on binder once again and then
184:08 - you can start executing the code within
184:10 - the jupyter notebook once again right so
184:12 - remember that binder is a free service
184:14 - so it will shut down
184:16 - if
184:17 - after about 10 minutes of inactivity
184:19 - which is if your computer goes to sleep
184:20 - or you change your tab
184:22 - so keep running juvenile.com it from
184:24 - time to time so now we have
184:26 - a simple implementation and we have
184:28 - analyzed it and determined that it is
184:30 - not efficient it is inefficient
184:32 - so now we need to apply the right
184:34 - technique to overcome the inefficiency
184:36 - and we can limit
184:38 - the number of iterations required for
184:40 - common operations like find insert and
184:42 - update
184:43 - by ditching the linear structure that we
184:45 - had earlier and organizing our data in a
184:48 - more tree-like structure
184:50 - so this is a structure that we use for
184:52 - our data and we will call this a binary
184:54 - tree
184:55 - now this is called a tree because it
184:57 - vaguely
184:58 - resembles an inverted tree trunk with
185:00 - branches so you can think of this as the
185:02 - root so this has the root and then you
185:05 - can see each of these are like branches
185:08 - and then there are nodes where branches
185:10 - then split into multiple branches so
185:12 - these are called nodes and finally at
185:14 - the end you will have
185:16 - individual nodes which do not have any
185:19 - more branches and those are called
185:21 - leaves
185:22 - so these are some terms that are used
185:24 - the tree represents the entire structure
185:26 - the top node is called the root and each
185:29 - each element in the tree is called a
185:32 - node the top node is called a root and
185:34 - then the bottom most nodes which do not
185:35 - have any
185:37 - sub trees or what are called children
185:39 - which do not have any children are
185:40 - called
185:41 - leaves right so the root node has two
185:43 - children and then each node there with
185:45 - can have zero one or two children so
185:48 - it's not necessary to have exactly two
185:49 - children but
185:51 - up to two children
185:52 - is what determines a binary tree
185:57 - so that's a binary tree
186:00 - but the binary tree that we need
186:03 - will have some additional properties
186:04 - which was what will make it efficient
186:07 - for our purposes so you can see one
186:09 - thing you can observe here is that the
186:12 - root node seems also seems to be the
186:14 - central value if you sort the keys
186:17 - in increasing order so what you will
186:19 - notice is
186:21 - on the left we have
186:24 - keys which have which lie before jades
186:26 - and on the right we have keys which lie
186:28 - after jades so that's one thing
186:30 - and that is actually the second property
186:32 - listed here
186:34 - that the left subtree of any node
186:36 - consists only of nodes
186:40 - which have keys that are
186:42 - lexicographically smaller than the nodes
186:44 - key right so the key for this node is
186:46 - barrage and that is lexicographically
186:47 - smaller than jades and similarly hemant
186:50 - and akash are all smaller than jadish
186:52 - and then this property holds at every
186:54 - node so at every node if you check
186:55 - sunaks you can see that siddhant is less
186:57 - than sunaks and vishal which comes to
186:59 - the right is a more than sunaks and then
187:02 - so not siddhanta vishal all three are
187:04 - greater than jadeesh right
187:08 - so when a binary tree satisfies this
187:10 - property it is called a binary search
187:12 - tree
187:13 - so that's what we're looking at here
187:15 - this is a binary search tree so that's
187:16 - the first property but we need the
187:18 - second property is that
187:20 - our nodes will have both keys and values
187:23 - now sometimes you can create binary node
187:25 - binary trees with just keys each node
187:27 - will have a single
187:29 - number or string inside it and you can
187:31 - call it the key or value or element or
187:33 - whatever you wish but what we want is we
187:36 - want
187:37 - the keys to be user names so that we can
187:39 - compare the keys easily but along with
187:42 - each node we also want to associate a
187:44 - value which is the actual user object so
187:46 - if you're looking for hemath let's say
187:48 - we started the root node
187:50 - we see that jadeish is the root node and
187:53 - since it is a binary search tree we know
187:55 - that he meant lies to the left then we
187:57 - reach biraj
187:58 - we know that himans will lie to the
188:00 - right of biraj so we go right we reach
188:02 - him
188:03 - and then we access the values stored at
188:05 - hemanth which is the user details for
188:06 - hemath
188:08 - right so we need both keys and values in
188:10 - a binary tree and this is what is called
188:12 - a tree map
188:14 - or a map in many languages
188:18 - and then finally
188:20 - this tree that we will create this data
188:23 - structure that we will create it will be
188:24 - balanced
188:25 - so here what we're looking at is each
188:27 - node has
188:28 - two children left and right but it is
188:30 - also possible to have an unbalanced tree
188:32 - where you only have one child on each on
188:35 - on maybe one of the sides
188:37 - so we will require it to be balanced
188:39 - which means that it does not skew too
188:41 - heavily in one direction
188:44 - and we'll talk about what balancing
188:45 - means and we'll talk about how to check
188:47 - if a tree is balanced and how to keep it
188:49 - rebalanced okay so we'll go over all of
188:51 - these things step by step but these are
188:53 - some of the properties that we want our
188:55 - final data structure to have
188:59 - okay
189:00 - so one important property of a tree of a
189:03 - binary tree
189:05 - is the height of a tree in fact if you
189:08 - start counting you can say this is level
189:10 - zero where you have one node and this is
189:12 - level two or this is level one where you
189:13 - have two nodes
189:15 - the left and right
189:17 - the left and right child
189:20 - of the root node and then this is level
189:22 - three level two where you have four
189:24 - nodes the left and right child of the
189:27 - first node on level one and the left and
189:29 - right child of the second node on level
189:31 - one right so you can see that the number
189:33 - of
189:34 - nodes in each level in a balanced binary
189:37 - tree
189:39 - is double of the number of nodes of the
189:41 - previous level
189:44 - so if you have a tree of height k or
189:46 - which which means a tree which has
189:48 - exactly k levels
189:50 - then here's the list of the number of
189:51 - nodes at each level now level zero will
189:53 - have one node the root node level one
189:55 - will have two nodes its children level
189:58 - two will have four nodes their children
190:00 - so that's four nodes is two times two or
190:02 - two to the power two
190:04 - level three will have eight nodes
190:06 - two nodes for each of these four nodes
190:08 - so that's two to the power three and
190:10 - similarly if you keep going down level k
190:12 - minus 1 the final level will have 2 to
190:14 - the power of k minus 1 nodes
190:16 - so that if the total number of nodes in
190:18 - the tree is n then it follows that n
190:22 - is 1 plus 2 plus 2 square plus 2 cubed
190:25 - plus so on plus 2 to k minus 1
190:28 - okay
190:30 - so what we're trying to determine here
190:31 - is what is the relationship between the
190:33 - height of the tree and the total number
190:34 - of nodes in the tree and this is the
190:36 - relationship and we can simplify it a
190:38 - bit if we add 1 to each side you can see
190:41 - here that this side we get n plus 1 and
190:43 - this side we get 1 plus 1 which gets
190:44 - simplified as 2 or 2 to the power 1 and
190:47 - then we can add 2 to the power 1 by 2 to
190:49 - the power 1 and that gets simplified as
190:50 - 2 to the power of 2
190:52 - then we can add 2 to the power of 2 and
190:54 - 2 to the power of 2 and that gets
190:55 - simplified to 2 to the power of 3 and we
190:57 - can keep performing this reduction we
190:59 - can keep adding these together till we
191:01 - finally end with 2 to the power k minus
191:03 - 1 plus 2 to the power k minus 1 which is
191:05 - simply 2 to the power of k
191:07 - so what that gives us is that k the
191:10 - height of the tree is log of n plus 1
191:13 - which is approximately or in almost in
191:16 - every case less than log n plus 1 so
191:18 - that's a a bit of an approximation are
191:21 - doing here but it is uh the height of
191:23 - the tree is less than log n plus one
191:25 - so to store n records we require a
191:28 - balanced binary search tree of height no
191:31 - larger than log n plus one
191:33 - now this is a very useful property in
191:36 - combination with the fact that nodes are
191:37 - arranged in a way that it makes it easy
191:39 - to find a specific key simply by
191:42 - following a path down from the root the
191:44 - binary search tree property
191:46 - and we'll see soon by the end of this
191:48 - lesson
191:51 - that the insert find and update
191:53 - operations in a balanced binary search
191:54 - tree have complexity order of login so
191:57 - in our original implementation a brute
191:59 - force implementation they had order n
192:01 - and this time we've reduced the
192:02 - complexity to order login and that is
192:04 - far better
192:07 - and we will see how that happens okay
192:10 - so that's a quick introduction to binary
192:12 - search trees we have we've had enough
192:14 - theory now let's get into some
192:16 - implementation
192:19 - but before that
192:21 - we have the second question
192:28 - now binary trees are very commonly used
192:31 - as data structures
192:33 - for a variety of different in a variety
192:35 - of different languages for instance
192:37 - java c plus plus python java and c plus
192:40 - plus have this concept of a map which is
192:42 - represented using a binary tree
192:46 - and it is also used in file system so
192:48 - binary trees are also used in file
192:50 - systems to store indexes of files so
192:52 - when you browse
192:54 - your file system or when you search for
192:56 - a specific file it is a binary tree that
192:58 - is used to look up the file and find the
193:00 - location of the file
193:02 - now that's where that brings us to our
193:04 - second question of today
193:06 - now you can you can find the second
193:08 - question on our linkedin profile so once
193:10 - again go to linkedin.com slash
193:13 - school slash jovian ai
193:16 - and you will find the second question
193:17 - here
193:20 - the second question is which tree based
193:23 - data structure is used to store the
193:25 - index
193:26 - in the windows file system
193:29 - and who invented this data structure
193:32 - so
193:34 - like this question follow us and comment
193:37 - with your answer
193:41 - and you can stand the chance to win a
193:42 - swag pack right so we repeat the
193:44 - question which tree based data structure
193:46 - is used to store the index in the
193:48 - windows file system also known as ntfs
193:51 - and who invented this data structure
193:58 - okay so let's get to the implementation
194:01 - of binary trees and here's a very common
194:03 - interview question that you might get
194:05 - implement a binary tree using python and
194:07 - then show its usage with some examples
194:09 - so what we'll do as we implement binary
194:11 - trees and binary search trees is
194:14 - to also cover many common interview
194:15 - questions in fact we'll cover exactly 15
194:18 - so that's a quite a few
194:20 - the first one is to implement a binary
194:22 - tree and to begin we'll create a very
194:24 - simple binary tree so we will not have
194:26 - any of the special properties like key
194:28 - value pairs and binary search tree and
194:31 - balancing rather and we'll also use key
194:35 - numbers as keys within our nodes because
194:36 - are simpler to work with so here is an
194:39 - example binary tree so we have a root
194:41 - node and then we have a left child in
194:43 - right side
194:44 - and here's a simple class representing
194:46 - this representing a single node within
194:48 - the tree so we're calling this class
194:50 - tree node and it has a constructor
194:53 - function it simply takes a key and it
194:56 - sets self dot key to key it also has a
194:59 - couple of other properties self.left and
195:01 - self.write which are initially set to
195:03 - none so each node when it's created
195:06 - exists independently of other nodes
195:09 - and now let's create nodes representing
195:11 - each of these
195:13 - nodes
195:14 - so we have node 0 we're calling it
195:17 - we're calling tree node with the value
195:19 - three then we have node one and node two
195:22 - so there you go now we've created the
195:24 - nodes and we can verify that it is of
195:26 - the type tree node you can see here and
195:28 - if we check the key of node zero you can
195:30 - see that it has a value three
195:32 - and we can now connect the nodes by
195:34 - setting the dot left and dot right
195:35 - properties of the root node so if you go
195:38 - to node zero and set dot left to node
195:40 - one so now we've connected node zero to
195:43 - node one
195:44 - and similarly if we set node zero dot
195:46 - right to node two now we've connected
195:48 - node zero and node two
195:50 - and that's it we're done
195:51 - so now we have three nodes and then
195:53 - we've connected each of those nodes
195:55 - and we may also just want to track which
195:57 - is the root node so we can create a new
196:00 - variable called tree
196:01 - and simply point it to node zero so tree
196:04 - points to the root node of the
196:06 - tree and then the root node is connected
196:08 - to its children and the children will be
196:10 - connected to their children and so on
196:12 - so you can check here that if we check
196:14 - tree dot key
196:16 - we get three and if we check tree dot
196:18 - left dot key
196:20 - so three is the root node it has a value
196:22 - three tree dot left is this node so it
196:24 - should have the value four and tree dot
196:26 - right dot key should have the value of
196:28 - five
196:30 - okay so pretty straightforward and
196:31 - that's pretty much the answer to the
196:33 - question implement a binary tree in
196:35 - python
196:38 - now going forward we will use the term
196:40 - tree to refer the node root node
196:42 - to refer to the root node and the term
196:44 - node can be used to refer to any node in
196:47 - a tree not necessarily just the root
196:49 - okay so here's an exercise for you
196:52 - try to create this binary tree so now
196:54 - you have a root node here and then you
196:56 - have a left child and right child and
196:57 - then this left child has another left
196:59 - child but does not have a right child
197:02 - similarly here you have another right
197:04 - child and then it has a left child which
197:06 - does not have a left child but has a
197:07 - right child okay so there's a slightly
197:09 - more complicated tree structure and try
197:12 - to use these cells these empty cells
197:14 - that are given here to replicate this
197:16 - tree structure
197:18 - and then try to view the different
197:19 - levels of that tree
197:21 - manually okay
197:23 - now please do that because that's a
197:24 - great exercise in understanding how the
197:26 - structure works and how to connect the
197:27 - nodes
197:28 - but it's a bit inconvenient to create a
197:30 - tree by manually connecting all the
197:32 - nodes in fact here you may have to make
197:34 - a total of one two three four five six
197:36 - seven eight nine connections right
197:39 - so what we can do is we can write a
197:40 - helper function which can convert
197:43 - a tuple
197:44 - and the tuple will have this kind of a
197:46 - structure so a tuple is simply
197:49 - is kind of like a list except that it is
197:51 - represented with these round brackets of
197:53 - parenthesis
197:55 - so a tuple will have this kind of
197:57 - structure it will have three elements
197:59 - and then the middle element will
198:00 - represent the value or the key within
198:03 - the root node
198:05 - the first element will itself also be
198:07 - either a tuple
198:09 - if the left
198:11 - child is is an entire subtree
198:13 - or if it is a single number then it will
198:15 - be just a number
198:17 - and then the right element will
198:18 - represent the right subtree okay
198:21 - so here's an example
198:23 - here is one tree tuple now if you see
198:25 - this tree tuple it has three elements
198:27 - this is the first element
198:28 - this is the second element and then this
198:30 - is the third element so this first
198:32 - element two
198:34 - represents the root node
198:38 - and then this
198:40 - so the second element 2 represents the
198:41 - root node this first element or element
198:45 - at position 0 represents this subtree
198:48 - so you can see here that in this sub
198:50 - tree if you look at just that subtree of
198:52 - that tree
198:53 - 3 is the root in that subtree and then
198:55 - one is the left child and there is no
198:58 - right child so that's what this
198:59 - represent and then for this subtree
199:01 - where 5 is the root node and then you
199:03 - have 2 other subtrees
199:05 - that's represented here so 5 is the root
199:07 - node and then you have a subtree here
199:09 - and a subtree here
199:11 - so this is a very easy way it is a
199:14 - convenient way for us to represent a
199:15 - binary tree and what we can do is we can
199:18 - define a function parse tuple
199:20 - and this parse tuple function can take a
199:22 - tuple like this and then convert it into
199:26 - a tree like structure of linked nodes
199:28 - using the tree node data struct using
199:30 - the tree node class that we have defined
199:31 - above
199:33 - so we call the parse tuple function with
199:35 - some data for instance this tuple
199:38 - and the pass tuple first checks
199:41 - if data is
199:44 - of the type tuple and it has a length
199:46 - three
199:48 - if these two things hold true
199:50 - then first we create a node we create a
199:52 - node with data one so in this case we
199:54 - create a node with
199:56 - two as the key
199:58 - and then we set the left and the right
200:00 - subtrees of the node
200:02 - and then we're doing something very
200:04 - interesting here we are calling the pass
200:06 - tuple function once again so we call
200:07 - parse tuple
200:09 - this time
200:10 - so this is called recursion when a
200:12 - function calls itself inside it
200:15 - that's called recursion so we call parse
200:17 - tuple
200:18 - with the first element which itself is a
200:20 - tuple right so once again that it calls
200:22 - another invocation to pass tuple and for
200:25 - a moment let's assume that that returns
200:28 - the proper subtree the proper node so we
200:30 - set that node which which got created to
200:33 - node.left
200:34 - and similarly we create the right
200:36 - subtree using these values and then we
200:39 - set that node to node.right okay
200:42 - now
200:44 - you might wonder in the function we're
200:46 - calling itself so when will this stop
200:48 - can't it go on forever and that's where
200:50 - you have to track the actual function
200:52 - calls so when we call parse tuple with
200:54 - the entire
200:56 - tuple
200:57 - first it calls past tuple with this
201:00 - and when you call past tuple with this
201:02 - uh then you can see that
201:04 - three is used to create a node and then
201:06 - pass tuple is called with one
201:08 - so when past tuple is called with one
201:11 - this condition no longer holds true
201:15 - and we also check the next condition
201:17 - which is if the data if one is none when
201:20 - one is not none so this condition does
201:21 - not hold true so we fall into the else
201:23 - condition and we simply create a node
201:25 - right so we just create a node and this
201:27 - time we are not calling parse tuple once
201:30 - again right so this is called a
201:31 - terminating condition of the
201:34 - recursive function
201:35 - and similarly once we get back the
201:37 - result from one then we call patch
201:39 - triple with the value none once again
201:41 - this condition is not entered and this
201:44 - condition matches so we set node equal
201:46 - to none and then we return the node okay
201:48 - so when we reach either a leaf node
201:51 - which is either a single number or we
201:52 - reach the value none that is when we
201:55 - stop invoking the function recursively
201:57 - and then the function returns and that's
201:59 - how the entire tree gets con gets
202:01 - converted
202:02 - so this is a very powerful idea in
202:05 - programming the idea of recursion the
202:07 - idea of functions calling themselves
202:09 - and it can seem unintuitive and
202:11 - confusing at first
202:13 - so one thing you can do is you can add a
202:15 - print statement here inside this
202:16 - function
202:18 - to see how it works to see how the
202:19 - different calls are going so when you
202:21 - call past tuple with the entire tuple
202:23 - what are the internal calls that are
202:25 - made
202:26 - and and study how the result comes out
202:29 - maybe try it on pen and paper
202:31 - but it's a very important technique for
202:33 - you to learn
202:34 - you will be asked or you will find
202:36 - applications of recursions in many
202:38 - places throughout your programming or
202:40 - data science career
202:42 - so do learn it
202:43 - so let's now call parse tuple with this
202:46 - tuple as an input
202:48 - and let's see okay so that returned a
202:51 - tree and then that tree is of the type
202:53 - tree node that's great and now let's
202:56 - examine the tree to verify that it was
202:58 - constructed as expected
203:00 - so now we check tree two dot key so tree
203:03 - two dot key should be pointing to the
203:05 - root node which has the key two
203:07 - and then let's check the level one so
203:10 - that was level zero let's check level
203:11 - one so let's check three two dot left
203:13 - dot key and tree two dot right dot key
203:17 - you can see here we get the values three
203:19 - and five
203:20 - let's check the next level
203:22 - on this level we have three two dot left
203:24 - dot left and then we have three two dot
203:26 - left dot right but there's no value
203:28 - there
203:28 - so we can't really check for a key here
203:30 - then we have treated right dot left and
203:32 - tree two dot right dot right
203:35 - so you can see that tree two dot left
203:37 - dot left dot key is one but tree two dot
203:39 - left dot right is none because there is
203:41 - no child here no right child
203:44 - then we have left dot key and right dot
203:47 - key and that gives you three and a seven
203:50 - and similarly you can now
203:52 - check level four level three as well
203:57 - so here are all the levels of the tree
203:59 - so it looks like the tree was
204:00 - constructed properly and you can see the
204:02 - power of recursion at play here that the
204:05 - recursive function can now construct
204:07 - trees of any levels now you can create
204:09 - tuples within tuples within tuples and
204:11 - as long as they have the right structure
204:14 - as long as you have this
204:16 - three element structure where the left
204:18 - element represents a left subtree the
204:20 - right element represents a light right
204:22 - subtree in the middle element represents
204:23 - the current node
204:25 - you can construct a tree of any size
204:30 - so now here's an exercise for you
204:33 - we've defined a function to convert a
204:35 - tuple into a tree
204:38 - define a function now to convert a tree
204:40 - back to a tuple so if you have a binary
204:42 - tree
204:43 - convert return a tuple representing the
204:45 - same tree for instance for the tree
204:47 - created above tree 2 calling tree to
204:49 - tuple should return this original tuple
204:52 - which is used to create the tree and
204:53 - here's a hint on how to do this use
204:56 - recursion
204:57 - so do fill this out
205:01 - and see if you can figure out how to do
205:03 - this
205:04 - so now we have defined a class for a
205:07 - binary tree and we also have a way for
205:10 - creating a binary tree from a tuple so
205:12 - now let's create another helper function
205:14 - to display all the keys of the tree in a
205:17 - tree like structure for easier
205:18 - visualization so here we'll just use
205:20 - we'll call this function display keys
205:23 - and we'll not get into the code for this
205:25 - because it's once again it's a pretty
205:27 - straightforward but there are a few
205:28 - conditions we need to handle
205:30 - but here's what it will give us
205:32 - when we call display keys on a tree
205:35 - so then we'll then we'll get this kind
205:37 - of a representation of a tree and you
205:39 - can see that this is not exactly the
205:40 - same representation as this you will
205:42 - have to take this representation and
205:43 - then mentally rotate it by 90 degrees in
205:46 - the clockwise direction to get a
205:47 - representation like this but you can see
205:50 - roughly that the root node is 2 and then
205:52 - it has a left child 3 and it has a right
205:54 - child 5.
205:56 - then 3 again it has a left child 1 and
205:58 - there is no right child
206:00 - now 5 has a left child 3 and 3 has no
206:03 - left child and 3 has the right child 4
206:05 - and so on so the exact same structure
206:07 - has been replicated here for us to view
206:09 - visually now this is a very useful thing
206:11 - we're spending all this time here
206:13 - or talking about how to create trees and
206:15 - how to
206:17 - visualize trees because
206:19 - the easier you make it for yourself to
206:21 - create trees the more likely you are to
206:23 - test the easier it is for you to test
206:25 - different scenarios out so always spend
206:28 - a little bit of time coming up with good
206:30 - string representations for any data
206:32 - structure you create something that
206:33 - helps you visualize them and an easy way
206:35 - to create these data structures okay
206:39 - so now we have a way to visualize the
206:41 - tree as well
206:43 - that's great
206:44 - now here's an exercise for you try to
206:46 - create some more trees and visualize
206:48 - them using display keys and you can use
206:50 - this tool excalidraw.com and that's
206:53 - where how that's how these diagrams were
206:54 - created
206:55 - as a digital whiteboard so you can
206:57 - create some trees you can create trees
206:59 - like this and then try to come up with
207:01 - tuples for those trees try to create
207:03 - those trees using the
207:05 - parse tuple function and finally try to
207:07 - display them okay so experiment with it
207:10 - and see explore what are all the
207:11 - different tree structures that you can
207:13 - create
207:16 - now the next
207:17 - one of the frequently asked questions in
207:20 - interviews is to traverse a binary tree
207:22 - binary tree traversals are very common
207:25 - so you may face one of these three
207:26 - questions write a function to perform
207:28 - the in order traversal of a binary tree
207:30 - or write a function to perform the
207:32 - pre-order traversal of a binary tree or
207:34 - write a function to perform the
207:36 - post-order traversal of a binary tree
207:38 - what do you mean by a traversal a
207:39 - traversal refers to the process of
207:41 - visiting each node of a tree exactly
207:44 - once
207:45 - now what do you mean by visiting by
207:47 - visiting it could mean any operation but
207:50 - generally it refers to
207:52 - either printing the key or the value at
207:54 - the node or adding the nodes key
207:56 - to a list
207:58 - and then there are three ways to
207:59 - traverse a binary tree
208:01 - and return a list of visited keys
208:04 - so the first one is called in-order
208:06 - traversal
208:07 - and the in-order traversal now traversal
208:09 - is defined recursively because binary
208:12 - trees have this recursive structure so
208:14 - you will see that almost all the
208:15 - functions that we write will have some
208:17 - sort of a recursive structure
208:20 - so in order traversal
208:23 - involves first traversing the left
208:24 - subtree
208:26 - recursively in order then traversing the
208:28 - current node and then traversing the
208:30 - right subtree recursively in order
208:33 - so what does that mean well we start out
208:35 - with this tree and we we're traversing
208:38 - it in doing an inorder traversal so we
208:41 - try we look at the root node and then we
208:43 - realize that there it has a left child
208:46 - so it has a left sub tree so we do not
208:48 - visit it yet which means we do not print
208:50 - it or we do not add it to our list yet
208:52 - rather we follow the
208:54 - we follow the path on the left side and
208:56 - then we come across three
208:57 - and then we realize that okay three also
209:00 - has a left child so we don't visit it
209:01 - yet so then we go down to one
209:04 - we go down to one and now it does not
209:07 - have a left child or a right child so we
209:09 - can visit one
209:11 - then we go to three
209:12 - and now we
209:13 - so we've visited the left subtree of
209:16 - three so now we can visit three
209:18 - and then the next step is to visit the
209:20 - right subtree of 3 but of course 3 does
209:22 - not have a right child so there is no
209:24 - right subtree to visit so we can move
209:26 - back up to 2. so now we have visited the
209:29 - left subtree of 2 so now we can visit 2
209:31 - so we we print 1 three two
209:34 - and now once we've visited two we can
209:37 - now visit the right subtree of two
209:39 - so to visit the right subtree we go to
209:41 - five once again we realize that five has
209:44 - a left subtree so we go to three now
209:46 - three doesn't have a left subtree so we
209:48 - can visit three then we visit four
209:50 - then now since we visited the left sub
209:52 - tree of five we can now visit five
209:55 - and similarly we then visit six seven
209:57 - and eight okay so that's the in order
209:59 - traversal of the tree
210:02 - and then there is another traversal
210:03 - called pre-order traversal which is
210:05 - slightly different where you traverse
210:06 - the current node first so here we start
210:08 - out at 2 and we say that okay we're
210:10 - going to visit 2 first so we visit 2 or
210:12 - print it or add it to a list then we
210:14 - traverse the left subtree and then we
210:16 - traverse the right subtree so we go we
210:18 - visit three and one and then we come to
210:20 - the right side we visit five and three
210:23 - so you can compare these two diagrams
210:25 - and see how in order and pre-order
210:26 - traversal are different now these are
210:28 - very important for you for you to
210:30 - understand because
210:31 - they are great examples of
210:34 - dif different
210:36 - functions which have very similar
210:38 - implementations but there are just one
210:39 - or two things you will need to change uh
210:42 - and these are recursive as well so do
210:45 - understand the subtle difference between
210:46 - them and second they are very commonly
210:48 - asked in interviews you will most likely
210:51 - face some coding assignment or an
210:53 - interview where you will be asked to
210:55 - perform a traversal of a binary tree
210:59 - and then finally there's another
211:02 - order called another
211:04 - traversal called the post order
211:05 - traversal and i'll let you guess how it
211:07 - works you can also look it up
211:09 - and here's an implementation of in-order
211:11 - traversal now it may seem a little
211:13 - complicated but it's actually pretty
211:14 - straightforward so let's look at it here
211:16 - what we do is
211:18 - given a node
211:19 - we first traverse the nodes left subtree
211:23 - then we create so that should return a
211:25 - list a list of all the keys
211:28 - and then we create a list with just the
211:30 - nodes key so we get the list of keys
211:32 - from the left subtree in with the
211:34 - inorder traversal then we get add to it
211:38 - the current nodes key and then we call
211:40 - traverse in order
211:42 - with the right subtree and that
211:44 - recursively keeps adding these keys each
211:46 - one and the end condition so the
211:48 - terminating condition for the recursion
211:50 - is when we hit none so when we hit a
211:52 - node which does not exist so that means
211:54 - we come there from a parent which does
211:56 - not have a left or right child
211:58 - then we return the empty array
212:00 - okay
212:02 - so let's try it out with this tree so
212:03 - this is the tree we have and we just saw
212:05 - its traversal
212:09 - now if it travels the tree in order we
212:11 - get the values one three two three four
212:13 - five six seven eight and we can verify
212:16 - here we have one three two three four
212:19 - five six seven eight so that was the
212:21 - in-order traversal of a tree
212:24 - now the exercise for you is to print the
212:27 - pre-order and post order traversal of
212:29 - the binary tree and you can test your
212:31 - implementations by making submissions to
212:33 - these problems on
212:34 - leadcode.com okay
212:37 - so that was our discussion about
212:39 - traversals
212:41 - another thing that you may get asked
212:43 - commonly is
212:46 - writing functions to calculate the
212:47 - height or the depth of a binary tree and
212:49 - then writing a function to count the
212:50 - number of nodes in a binary tree
212:53 - once again these can be expressed
212:55 - recursively as well now the height of a
212:57 - tree
212:58 - given a node
212:59 - is simply
213:01 - 1 plus
213:02 - maximum of the height of the right
213:04 - subtree of the left subtree
213:08 - the height of retreat is defined it is
213:09 - defined as the longest path from a root
213:11 - node to a leaf so you can see that the
213:13 - longest path from root node of the to
213:15 - the leaf
213:16 - is of length four so two five three and
213:19 - four
213:20 - and the way to do get the longest length
213:22 - of the longest path is by checking the
213:24 - max of the left height right height and
213:26 - then adding one to it
213:28 - and of course the terminating condition
213:30 - here also is if you hit a node that does
213:32 - not exist you return zero
213:36 - so that's how you get the height of a
213:37 - tree
213:39 - and you can check that the height of a
213:40 - three is four then here's another
213:42 - function to count the number of nodes in
213:44 - a tree once again really simple all you
213:46 - do is this time instead of checking the
213:48 - maximum we simply get the size of the
213:50 - left subtree get the size of the right
213:52 - subtree add them and add one to it
213:56 - so here you can see that there are nine
213:58 - elements in the street three six and
214:00 - nine
214:01 - so we get tree size of tree as nine
214:04 - now here are a few more questions
214:05 - relating to the path lengths in a binary
214:07 - tree so you can just check
214:09 - there's a concept of maximum depth and
214:11 - minimum depth and then there's also the
214:12 - concept of a diameter so you can try out
214:15 - both of these
214:18 - now as a final step
214:20 - what we can do is we can compile all the
214:22 - functions we've written all the methods
214:25 - as methods within the tree node class
214:26 - itself and this technique is called
214:28 - encapsulation where we are encapsulating
214:30 - the data as well as the functionality
214:32 - related with the data of the data
214:34 - structure within the same class and this
214:36 - is real as really good programming
214:37 - practice so as you
214:40 - write more code try to think about how
214:42 - you can create these classes with not
214:45 - just the information inside them but
214:46 - also with the relevant methods inside
214:48 - them
214:49 - okay so we have now added the methods
214:51 - height size traverse and order display
214:54 - keys to tuple and we've also added these
214:56 - methods str and wrapper and remember
214:59 - quiz 1 or you can go on linkedin and
215:01 - post an answer to what these functions
215:02 - do
215:04 - and finally parse tuple as well
215:06 - so all of these functions are now added
215:09 - within the class and you can try it out
215:10 - here so for instance here we have a tree
215:13 - tuple and we can call tree node dot pass
215:15 - tuple
215:16 - to convert this tree tuple
215:19 - into a tree
215:20 - so you can see that now we are also
215:22 - representing the binary tree itself
215:24 - using this tuple like representation but
215:26 - we can also display it in this
215:27 - hierarchical structure using display
215:29 - keys
215:30 - then we can check the height using tree
215:32 - dot height we can check the size using
215:34 - tree dot size and we can traverse the
215:36 - tree in order using traverse in order
215:38 - and we can
215:40 - convert the tree to a tuple
215:43 - using 3.2 tuple
215:45 - so do create some more trees and try out
215:48 - the operations that we've just defined
215:49 - and try or you can also try adding more
215:51 - operations
215:52 - to the tree node class
215:54 - and before continuing we can just save
215:57 - our work so i'm just going to import
215:58 - jovane and run juventus commit
216:06 - so that concludes our discussion on
216:08 - binary trees
216:10 - next let's talk about binary search
216:12 - trees
216:13 - now a binary search tree
216:16 - or a bst is a binary tree that satisfies
216:20 - these two conditions
216:22 - the left subtree of any node
216:24 - should only contain nodes with keys less
216:28 - than the current nodes key
216:30 - and then the right subtree of any node
216:32 - should only contain nodes with keys
216:34 - greater than
216:35 - the current nodes key
216:37 - and we can see that this is let's just
216:40 - copy this over
216:48 - so we can see that this node this tree
216:49 - here is actually a binary search tree
216:51 - and you can verify that these two
216:52 - properties hold for each of these nodes
216:56 - and it should follow from these two
216:58 - conditions that every soft tree of a
217:00 - binary search tree must also be a binary
217:02 - search tree so i can let you verify that
217:05 - that if you pick up any subtree inside
217:07 - so you pick up any node and you see the
217:08 - tree under that node you will see that
217:10 - it is a binary search tree
217:14 - so here are some questions that are
217:16 - often asked
217:17 - relating to binary trees and binary
217:19 - search trees and we've lumped them
217:20 - together because we'll answer them with
217:21 - a single function
217:23 - so here's a function that you might be
217:25 - expected to write so write a function to
217:27 - check if a binary tree is a binary
217:29 - search tree which means
217:31 - ensure that these two conditions hold
217:34 - and second write a function to find the
217:36 - maximum key in a binary tree so this
217:38 - could be a generic question finding the
217:40 - maximum key
217:45 - and here's another question that you
217:46 - might face write a function to find the
217:47 - minimum key in a binary tree
217:50 - so what we will do is we'll answer we'll
217:51 - answer all of these questions together
217:54 - with a single function called is bst so
217:57 - isbst takes a node
217:59 - and then is bst returns three things so
218:02 - if you look at the return value it
218:04 - returns whether the node
218:06 - and the tree
218:07 - under that node
218:09 - is a bst
218:10 - so here so we this is going to be the
218:12 - value
218:13 - determining it's going to be either true
218:15 - or false telling us whether the tree
218:17 - under that node
218:19 - with that node as root is that a bst
218:22 - it also returns the minimum key from
218:24 - that entire tree and it also returns the
218:26 - maximum key from that entire tree now
218:29 - why are these two useful we'll see in
218:31 - just a moment
218:32 - so the way we calculate is bst node
218:35 - is by actually looking at
218:38 - the left subtree and the right subtree
218:40 - recursively so we call is bst on the
218:43 - left subtree of the node
218:45 - and we call isbst on the right subtree
218:47 - of the node
218:48 - so we get back three values which is is
218:51 - the left subtree a binary search tree is
218:53 - the right subtree binary search tree
218:56 - is the minimum key in the left subtree
218:58 - the minimum key in the right subtree and
218:59 - then the maximum key in the left subtree
219:01 - and the maximum key in the right subtree
219:04 - so now what we can do is we can say is
219:06 - is bst node so is the entire tree of
219:09 - binary search tree well if the left sub
219:12 - tree is a binary search tree and the
219:13 - right subtree is a binary search tree
219:15 - and then we verify these two properties
219:18 - which is the maximum key
219:20 - in the left subtree is either none which
219:23 - means that there is no left subtree
219:26 - or the current nodes key is greater than
219:28 - the maximum key
219:30 - and
219:31 - the minimum key in the right subtree
219:34 - the smallest key in the right subtree is
219:35 - either none which means that there is no
219:37 - right subtree or the minimum key in the
219:39 - right subtree is greater than
219:41 - the current nodes key so that this was
219:44 - condition one and condition two and that
219:46 - tells us whether
219:49 - this entire tree is now a binary search
219:52 - tree
219:53 - and then finally we can also calculate
219:55 - the minimum key and maximum key simply
219:57 - by computing the minimum of the left
219:59 - minimum node.key and right minimum
220:02 - and the maximum can be calculated by
220:04 - checking the maximum of the left maximum
220:06 - node dot key and right maximum okay
220:09 - so what we return from the sbst function
220:11 - is whether the
220:13 - node
220:14 - and the tree represented
220:16 - rooted at that node is a binary search
220:19 - tree and then the minimum and maximum
220:20 - key out of it
220:22 - so if we look at this tree right here
220:25 - let's verify whether this is a bst and
220:28 - well before we check we can probably
220:30 - tell that it's not because you can see
220:32 - that 3 appears as a left sub child of 2
220:35 - but 3 the key is greater than 2 and
220:37 - that's a problem so this is a violation
220:39 - of the property
220:40 - elsewhere this property is satisfied you
220:42 - can check any other node here and you
220:44 - will find that the left subtree is
220:45 - always
220:47 - smaller than the right than the node and
220:49 - the right subtree is larger than the
220:50 - node
220:52 - so let's check is bst tree one
220:54 - it's not
220:56 - so it's false
220:57 - now on the other hand
220:59 - this tree is a bst this is the tree that
221:02 - we've been looking at all this while
221:04 - so once again
221:05 - we can create this using tree node.parse
221:08 - tuple
221:09 - and note that the keys can
221:11 - the way we've implemented tree node keys
221:14 - can not only be numbers but they can
221:16 - also be strings so we don't need to
221:18 - change anything here and that creates
221:20 - tree two
221:22 - and we can even display tree two so if
221:23 - we do tree two dot
221:26 - display keys
221:30 - you can see that it has this structure
221:31 - where jadeesh is at the center
221:33 - and then on the left you have biraj on
221:35 - the right you have sunaks biraj and
221:37 - sanaksh then you have akash siddhant and
221:40 - vishal
221:43 - and this
221:44 - is a bst so you get back true here and
221:47 - the smallest value here is akash and the
221:49 - highest value is vishal as you can
221:51 - verify in alphabetical order
221:54 - so that's pretty handy now we have a way
221:56 - to check if a binary tree is a binary
221:59 - search tree and this is again a very
222:01 - common interview question that you might
222:02 - face
222:05 - next remember that we need to store not
222:07 - just keys but also user objects within
222:10 - each key
222:11 - with each key within our bst so what we
222:13 - do is we will define a new class called
222:15 - bst node to represent the nodes of our
222:18 - binary search tree
222:19 - and bst node will not only have the key
222:22 - but in the constructor it can also
222:24 - accept a value and this is optional
222:27 - so we will set the key and we set the
222:29 - value we will also set the left and
222:31 - right apart from this we also set
222:33 - another property called parent and the
222:35 - parent will point to the parent node so
222:36 - for instance if this node
222:38 - is a left sub tree of this route then
222:40 - the parent of barrage will point to
222:42 - jadeish and this will be useful for
222:44 - upward traversal now if you're given a
222:46 - pointer to a node and you have to go
222:47 - back and find the root of the tree
222:50 - the parent will be helpful there
222:53 - so this is our bst node
222:56 - and let's try to recreate this bst right
222:58 - here
222:59 - with usernames as keys and user objects
223:01 - as values so first we create level 0. so
223:04 - level 0 we create bst node now the key
223:07 - is jaadesh or username which will be
223:09 - just the string jadeesh and then the
223:11 - value will be the jadeish user object
223:15 - so we've created that and we can check
223:17 - its key and value you can see that
223:18 - jadish is the key and then the user
223:20 - object is the value
223:23 - let's create
223:24 - let's create level one
223:27 - now level one is
223:29 - we set tree dot left
223:31 - to bst node barrage dot username and
223:33 - biraj now one other thing that we should
223:35 - do here is once we set it we should set
223:38 - tree dot left dot parent
223:41 - to tree
223:42 - and similarly we said tree dot write
223:44 - it's not tree dot write is sunak so we
223:47 - said bst node with sonar username as the
223:49 - key and sonax is the value and then we
223:52 - can set tree.write.parent as tree
223:57 - and now can you can view these values so
223:58 - now you can see that we have inserted
224:00 - barrage
224:01 - and the username barrage we've inserted
224:03 - sonaax and the user
224:06 - sonar shear as keys and values
224:08 - respectively
224:09 - now the exercise for you two is then try
224:12 - to add the next level of keys and values
224:14 - and then verify that they were inserted
224:15 - properly but you can see now that we
224:18 - now have a way to represent the data
224:23 - the both both the usernames and the user
224:25 - objects in a binary search tree so we're
224:27 - getting pretty close to the data
224:28 - structure that we want to create
224:30 - once again we can display the keys of
224:32 - the tree by calling the display keys
224:34 - function
224:36 - now this is also rather nice is a good
224:37 - thing about python that because python
224:41 - functions
224:42 - are dynamic because you do not need to
224:44 - specify the types of the objects while
224:46 - defining the function the same display
224:48 - keys function can be used both with tree
224:50 - node and bst node classes
224:53 - so all it requires is that the object of
224:56 - your class should have a property dot
224:58 - key for it to be able to display the
225:00 - keys in this visual
225:02 - setting
225:03 - and the same is true with most of the
225:05 - other functions that we've defined in
225:06 - fact any function we've defined for tree
225:08 - node will also work for bst node
225:13 - okay so moving right along
225:16 - now we have a way to construct a bst but
225:19 - it it's a bit inconvenient to insert
225:23 - values manually because what we're doing
225:24 - so far is we are manually checking
225:27 - whether we should insert a value in the
225:28 - left or the right rather there should be
225:30 - a way to do it automatically we should
225:31 - be able to call a function insert
225:33 - and here's this is a common question as
225:35 - well write a function to insert a new
225:37 - node into a binary search stream
225:39 - so we'll use the
225:41 - bst property
225:43 - to perform insertion efficiently
225:46 - once again let's grab a copy of this
225:47 - tree here so that we can think about it
225:50 - easily
225:57 - okay so now we have this tree and let's
225:58 - say we want to insert a new user with
226:01 - the username tanya into this tree so
226:04 - first we start at the root and then we
226:06 - compare the key to be inserted with the
226:08 - current node's t key so the current node
226:10 - is the root so we compare tanya with
226:11 - jades and we see that tanya is greater
226:14 - than jades because t comes after j
226:17 - so obviously tanya should not be
226:19 - inserted into the left sub tree rather
226:21 - than should be inserted into the right
226:22 - subtree so if the key is smaller we
226:25 - recursively insert it into the right
226:27 - left subtree and if the key is larger we
226:28 - recursively insert it into the right
226:30 - subtree so then we encounter sunak tanya
226:33 - is also greater than sonax t is greater
226:35 - than s t comes after s so once again we
226:38 - call recursively called insert on this
226:40 - subtree that subtree rooted at vishal
226:43 - this time we notice that tanya is
226:45 - smaller than vishal so t is less than v
226:47 - so then
226:49 - we need to recursively insert in the
226:51 - left subtree but there is no left
226:52 - subtree here and this is the point at
226:54 - which we can create a new node and
226:56 - attach it as the left child of vishal so
226:59 - you can see that the node tanya will get
227:00 - added here
227:02 - at this position
227:03 - in the tree
227:05 - so here is a recursive implementation of
227:08 - insert
227:09 - exactly what we just discussed
227:12 - first we check if the key is less than
227:14 - the current nodes key and if that is the
227:17 - case then we insert it into the left
227:19 - subtree then we check if the key is
227:21 - greater than the current nodes key and
227:22 - if that is the case we insert it into
227:24 - the right subtree
227:26 - and the ending condition is that if the
227:28 - node is none
227:29 - which means
227:31 - if we've hit a position where we do not
227:33 - have a left subtree and we need to go
227:35 - left or we do not have a right subtrain
227:36 - we need to go right then we create a new
227:39 - node so we create new node node equal to
227:41 - bst node and then we return the node
227:43 - so we return the node and this is an
227:47 - interesting thing that we're doing here
227:48 - we're returning
227:49 - the root node back from insert so when
227:52 - we called insert with node.left
227:54 - we get back the pointer to the left
227:56 - subtree so we can set it back to
227:58 - node.left
228:00 - and we can also set the parent of the
228:02 - left subtree to node okay so this is
228:04 - just updating the parent
228:06 - so
228:06 - just study this function carefully
228:09 - see how it works it does exactly what we
228:11 - just talked about
228:13 - and it finally returns a pointer to the
228:17 - to the tree once again
228:19 - so let's use this to recreate the tree
228:21 - that we had here
228:23 - now to create the first node we can call
228:25 - the insert function with none so
228:27 - initially we don't have a tree to begin
228:28 - with so we just called insert with none
228:31 - and remember that insert after
228:33 - performing an insertion returns
228:36 - the pointer to the tree
228:39 - so we call insert with none
228:41 - and we want to insert the value
228:43 - jaadesh.username and we want to insert
228:45 - the we want to insert the key short
228:47 - username with the value jadesh so that
228:49 - gives us a tree
228:51 - and now the tree has one element you can
228:53 - see tree
228:54 - dot key and tree dot value
229:00 - and now the remaining nodes can just be
229:02 - inserted into tree so now we call insert
229:04 - with tree
229:05 - and call it with barrage dot user name
229:07 - and biraj then we call it with sonar
229:09 - username and sunaks
229:11 - akashad username and akash and this way
229:13 - so we are adding barrage when we are
229:15 - adding sonax then we are adding akash
229:18 - siddhant vishal and see that we are not
229:20 - specifying exactly where these nodes
229:22 - need to be inserted but you can see that
229:25 - once these nodes are inserted then they
229:27 - are inserted in the right places so
229:28 - jadeesh you can see that the binary
229:30 - search tree property is
229:32 - preserved here
229:33 - and also we've exactly replicated the
229:35 - tree structure that we had here so the
229:38 - left subchild of jadeesh is
229:41 - biraj and the right child is sonak for
229:43 - biraj the left child is akash and the
229:44 - right child is hemanth and so on
229:48 - now note however that the order of
229:50 - insertion of nodes can change the
229:51 - structure of the resulting tree so for
229:54 - instance if we insert
229:57 - all the nodes in the increasing order of
229:59 - username so if your for example here we
230:02 - are inserting akash biraj
230:03 - siddhants vishal so this is the
230:05 - lexicographic increasing order and we
230:07 - try to display that tree
230:09 - this is what we end up with so we end up
230:11 - with an unbalanced or a very skewed tree
230:14 - and you can see why it was created as a
230:16 - skewed or unbalanced tree well let's
230:18 - look at it so we started with akash so
230:20 - we have a single node and then when we
230:22 - try to insert bharaj we realized that we
230:23 - need to go right so we insert barrage
230:25 - here then we try to insert hamad then we
230:28 - realize that we need to go
230:30 - right from akash and right from biraj
230:32 - and go to himant
230:33 - and then we keep going this way so how
230:35 - you set up the root node and how you set
230:37 - up each subtree and the order in which
230:39 - you insert the nodes is very important
230:41 - and that can create a huge skew within
230:43 - the tree
230:44 - now skewed or unbalanced trees are
230:46 - problematic because the
230:48 - height of sub such trees is no longer
230:51 - logarithmic compared to the number of
230:52 - nodes in the tree right so
230:55 - earlier we had deduced that in a
230:57 - balanced tree if containing n nodes the
230:59 - height is
231:01 - log n or log n plus one
231:04 - and that makes the operations like
231:05 - insert update and find very efficient
231:08 - but here where you have a very skewed
231:10 - tree the height can actually match the
231:11 - number of nodes for instance this tree
231:13 - has seven nodes and it has a height
231:14 - seven
231:17 - and in these q trees
231:20 - once again you may get back the fact
231:22 - that insertion finding and update
231:25 - can be order n because you may have to
231:28 - traverse the entire height of the tree
231:29 - which is equal to the number of nodes of
231:31 - the tree
231:33 - and that may once again defeat the
231:35 - purpose of using a binary search tree in
231:37 - the first place
231:38 - so maintaining the balance of a binary
231:40 - search tree is very important and we'll
231:42 - see how to do that
231:45 - so we've seen how to insert a node now
231:48 - the next thing is to find the value
231:50 - associated with a given key in a binary
231:52 - search tree so once again we can follow
231:54 - a recursive strategy here
231:56 - similar to insertion so we check
231:59 - we start from the top let's say we want
232:00 - to find the key heyman we start from the
232:02 - top and we compare it with the root node
232:05 - now
232:06 - here if it matches the root node we can
232:08 - simply return this node
232:10 - if it does not then we check whether we
232:11 - need to go left or right since hemanth
232:13 - comes before jadeish we need to go left
232:15 - then we encounter bharaj and here we
232:17 - realize that we need to go right and
232:19 - finally we encounter haiman and we
232:20 - return
232:21 - another option is that we have a value
232:24 - let's say tanya which does not exist
232:25 - here so if we try to search that we may
232:27 - go in this kind of a direction and we
232:29 - end up at an empty place so in that case
232:31 - we simply return none
232:34 - so you either find a node and return it
232:36 - or you return none
232:37 - so you can see here
232:39 - that if we called find tree
232:42 - with hemanth we get back the details for
232:44 - human
232:46 - and very interestingly because it's a
232:48 - balanced tree you we only had to take
232:50 - two steps
232:51 - and not go through the entire tree and
232:53 - in the worst case you can check that any
232:55 - path from the
232:57 - root to any leaf in a balanced tree
233:00 - will only be two steps long and that's
233:02 - what makes it so convenient
233:04 - now on the other hand if we try to find
233:08 - the key tanya
233:15 - you can see that it's not formed
233:18 - try creating larger
233:20 - bsts and try finding some more nodes
233:22 - it's important to experiment with these
233:24 - operations once they're defined because
233:26 - now it's simply a matter of calling the
233:27 - function we've written the code for it
233:29 - so experiment with it try creating
233:31 - larger trees with multiple levels and
233:34 - dozens or maybe hundreds of nodes
233:36 - try generating some fake data putting it
233:38 - into the trees and see how trees build
233:40 - up
233:42 - and that will give you a feel for how
233:44 - binary search trees work
233:47 - next let's talk about updating a value
233:48 - in a bst
233:54 - now updating a value is fairly simple we
233:56 - already have a way of finding a node so
233:58 - if you want to update a node let's say
234:00 - we want to update the node hema the key
234:02 - heimat
234:04 - and here we want to update it we want to
234:06 - update it to this value which is the new
234:08 - value of the user heman and we're
234:10 - changing the name and we're changing the
234:12 - email here so we first find the node and
234:15 - if the node is not none
234:17 - then we simply change the value at that
234:19 - node it's as simple as that
234:22 - and we what we're also seeing is we're
234:23 - reusing the find function here and this
234:25 - is a good practice to always incorporate
234:28 - into your programs into your functions
234:30 - whenever you find yourself copy pasting
234:32 - some code and maybe changing one or two
234:34 - things here and there think about
234:36 - whether you can extract that piece of
234:38 - code into a function and then reuse that
234:40 - function so always try to make your code
234:42 - more and more generic the less code you
234:45 - write the less there are the chances for
234:48 - errors the easier it is to understand
234:50 - and the smaller your functions become so
234:52 - write small reusable generic functions
234:54 - whenever you can and this is a
234:56 - principle called the dry principle or
234:59 - the dry principle which stands for don't
235:01 - repeat yourself
235:03 - whenever you're writing programs
235:06 - so in update we are not repeating
235:08 - ourselves by using the find function to
235:10 - find the right node and simply updating
235:12 - it
235:13 - by setting its value
235:16 - so let's update hemanth here to the new
235:18 - value and you can see that now we have
235:20 - the updated data here so we have payment
235:22 - j and human j at example.com
235:27 - now the value of the node
235:29 - was successfully updated and you can in
235:32 - it and you can easily check that the
235:33 - time complexity of update is same as
235:35 - that of find
235:40 - now finally we have the last
235:43 - operation that was required and this was
235:45 - to write a function to retrieve all the
235:47 - key value pairs stored in a binary
235:49 - search tree in the sorted order of keys
235:56 - is a question that you might face uh
235:57 - once again
235:59 - and this is simply the in order
236:01 - traversal it's a different way of
236:03 - stating the inorder traversal now
236:05 - what you will have to figure out or a
236:08 - reason about is why the inorder
236:10 - traversal of a binary search tree
236:12 - produces a sorted array of our sorted
236:15 - list of keys
236:17 - think about it
236:21 - so here's the list all function all we
236:23 - do here is we call list all on node.left
236:26 - and then we call listall on node.write
236:28 - and in between them then these give us
236:30 - two arrays so we assume that
236:32 - listall.node.left gives us the
236:35 - list of key value pairs from the left
236:37 - subtree in sorted order similarly here
236:39 - we get the list of key value pairs from
236:41 - the right subtree in sorted order and
236:43 - between them we simply insert this key
236:45 - value pair from the current node and
236:48 - recursively
236:50 - it automatically fills out the entire
236:51 - array and this is the end condition
236:54 - where we encounter an empty node we
236:55 - simply return the empty array
236:58 - you can see now when we pass in this
237:00 - tree we get back the list of users key
237:03 - value pairs
237:05 - arranged by the sorted order of keys
237:10 - now here's an exercise for you
237:12 - determine the time complexity and state
237:14 - compliance space complexity of the list
237:17 - all function
237:18 - now you can do this for a balanced tree
237:20 - or an unbalanced tree and here's a hint
237:23 - it will not make a difference
237:26 - but think about it
237:29 - so once again let's save our work and
237:31 - now we've talked about
237:36 - binary trees and operations on binary
237:38 - trees
237:40 - now the next thing is to look at
237:43 - balanced binary trees and this is once
237:45 - again a very common question that gets
237:47 - asked write a function to determine if a
237:49 - binary tree is balanced
237:52 - and here's a recursive strategy to do
237:54 - this
237:56 - in fact this is really the definition of
237:58 - balanced binary trees the left sub tree
238:01 - should be balanced the right subtree
238:03 - should be balanced
238:05 - and the difference between the heights
238:06 - of the left and right subtree should not
238:08 - be more than one okay so this is an
238:10 - important thing now when we're looking
238:12 - for balance we're not always looking for
238:13 - perfect balance because it may not
238:15 - always be possible to create a tree with
238:17 - perfect balance because to have a
238:18 - perfectly balanced tree where
238:21 - for every node the left subtree and the
238:23 - right sort you have the exact same
238:24 - height
238:25 - you will have to fill out all the nodes
238:27 - at all the levels
238:30 - and that can only have
238:32 - that can only happen for certain numbers
238:34 - for example you can have one node which
238:36 - satisfied this property or you can have
238:37 - a tree with three nodes which satisfy
238:39 - this property or you can have a tree
238:41 - with seven nodes which satisfies this
238:43 - property but you may not be able to get
238:45 - a tree with six nodes to satisfy that
238:47 - property for instance if you remove
238:48 - vishal here you will see that
238:51 - the left subtree and right sub tree of
238:53 - this node sonar will not be of equal
238:55 - height that's why for balancing we relax
238:57 - the criteria slightly we simply need to
238:59 - ensure that the difference between the
239:01 - heights of the left and the right
239:02 - subtrees is not more than one
239:07 - so here's the code for is balanced
239:10 - once again pretty straightforward but we
239:12 - will return two things here we will this
239:14 - is balance will not only return whether
239:16 - the tree node is balanced it will also
239:18 - return the height of the
239:20 - tree which is rooted at that node
239:23 - so the way we implement it is first
239:26 - calling is balanced on node.left and
239:28 - then calling is balanced on node.right
239:31 - and by the way this is exactly how we
239:33 - implement recursive functions as well
239:35 - sometimes we write the recursive
239:37 - functions
239:39 - signature
239:40 - then we immediately write the return
239:42 - value
239:42 - and then we assume that a recursive call
239:45 - is going to return these values so a
239:47 - recursive call is balanced node.left is
239:49 - going to return
239:51 - whether the left subtree was balanced
239:53 - and the height of the left sub tree and
239:55 - then we assume that is balanced for
239:58 - node.write is going to recall
240:00 - is going to return whether the right
240:01 - subtree is balanced and the height of
240:03 - the right subtree because that's what we
240:04 - return here
240:06 - then the entire tree is balanced if the
240:09 - left sub tree is balanced and the right
240:10 - subtree is balanced and the absolute
240:12 - value of the differences in their height
240:14 - is less than one which means the height
240:16 - l minus height r is either minus one
240:18 - zero or one
240:20 - and finally we calculate the height of
240:21 - the tree itself which is simply one plus
240:23 - the maximum of the height of the left
240:25 - subtree and the right subtree and we
240:27 - return it
240:28 - so that's how you implement a recursive
240:29 - function or think recursively
240:31 - and there's one last thing which is the
240:33 - end condition and the end condition
240:35 - although it's often the last thing you
240:37 - think about it's the first thing that
240:38 - you have to put in the end condition is
240:40 - to check whether a node is none
240:42 - because as we call node.left you may not
240:45 - have a left subtree so you may call is
240:47 - balanced with none and if the node is
240:48 - none we simply return true
240:51 - because an empty tree is
240:53 - balanced by default because there's no
240:56 - imbalance there
240:57 - and its height is zero
241:00 - so that's our is balanced function it's
241:02 - just
241:02 - four or five lines of code
241:05 - but if you are not able to reason about
241:07 - recursion easily you may get stuck with
241:09 - this and
241:10 - you may spend an entire 45 minutes
241:12 - trying to write this function and debug
241:14 - it so always try to think in recursive
241:17 - terms and that's why always it always
241:18 - helps to write down what you want to do
241:21 - in plain english so that you can
241:22 - determine what should be the inputs and
241:24 - outputs to your function
241:26 - maybe also have some test cases ready
241:28 - and then start implementing your
241:29 - function and it becomes really easy
241:33 - so this tree for instance is balanced
241:35 - here
241:36 - you can check is balanced
241:38 - you get back true
241:40 - but this tree here you're looking at
241:42 - this is not balanced so this was tree
241:44 - two and if you check is balanced here
241:47 - you get back false
241:49 - so here you also get the height of the
241:51 - tree which is three and here you get the
241:52 - height of the tree which is seven
241:55 - now here's another tree
242:00 - is this tree is this tree shown here
242:02 - balanced why or why not now create this
242:05 - tree and check if it's balanced using
242:07 - the is balanced function
242:14 - so there's another concept called
242:15 - complete binary trees which is slightly
242:17 - similar to balanced binary trees but
242:20 - it's a slightly stricter criteria so you
242:22 - can check out this problem here
242:25 - and you simply need to modify the is
242:27 - balance the code for is balanced
242:28 - slightly to get the code for complete
242:31 - binary so do check out this problem on
242:33 - leadcode.com
242:36 - all right so we've looked at binary
242:38 - search trees and we've looked at
242:39 - balanced binary trees now let's bring
242:41 - them both together
242:42 - into balanced binary search trees
242:45 - and here's one question that you will
242:47 - face
242:48 - at some point write a function to create
242:51 - a balanced binary search tree
242:53 - from a sorted list of key value pairs
242:57 - so you have a sorted list of key value
242:58 - pairs so the keys for example could be
243:01 - usernames the values could be the user
243:03 - objects and they are sorted by key and
243:05 - you have a list
243:06 - and you have to create a balanced binary
243:08 - search tree from it
243:11 - and here's the basic logic which is
243:13 - somewhat similar to
243:15 - binary search which is something that
243:16 - we've covered in lesson one do check it
243:18 - out
243:21 - what we can do is we look at the middle
243:23 - element
243:24 - for instance if you have a list of 15
243:28 - elements then the element at position 7
243:30 - counting from 0
243:33 - the element at position 7 is the middle
243:34 - element
243:35 - now we can take the middle element and
243:37 - then create a new
243:39 - binary search tree with the middle
243:40 - element as the root node
243:42 - okay so you take you make the middle
243:44 - element the root node
243:46 - and then
243:47 - you take the left half of the list
243:50 - and use that to create a balanced bst
243:52 - and make it the left
243:54 - child
243:55 - of the middle element
243:57 - the root node and then you take the
243:59 - right half
244:00 - which both of the house will have seven
244:02 - elements each so if you take the right
244:03 - half and you create a balanced bst out
244:05 - of it and then make it the right child
244:08 - of the middle element
244:12 - so that's the idea here
244:13 - and
244:15 - how do you make a balance bst for the
244:16 - left or right child
244:18 - recursion right
244:20 - so once again here's a recursive
244:22 - solution
244:24 - make balance bst takes data which is a
244:26 - list of key value pairs it takes a low
244:28 - and high and it also takes a parent and
244:31 - we look at those
244:32 - now
244:33 - low is set to zero by default and high
244:35 - by default is set to the last index in
244:37 - the data
244:38 - so we use that to get the middle index
244:41 - so for instance if low is 0 and high is
244:43 - 14 the middle index is 7
244:46 - then we get back the key and the value
244:48 - from the middle index so we calculate we
244:50 - find data made and that gives us the key
244:52 - and the value for exa since the username
244:54 - and the user object then we create the
244:56 - root node so we create the root node
244:58 - using bst node
245:00 - and then we call make balanced bst
245:04 - on data but this time from low to mid
245:06 - minus one so from the indices zero to
245:08 - six
245:10 - and make that the left child of the road
245:12 - and we called make balance bst
245:15 - on the right node
245:17 - so on the right half so from mid plus 1
245:19 - so which is index 8 to 14
245:22 - and we make this the right subtree and
245:23 - then we return the root
245:25 - and that's it that's pretty much it the
245:27 - only thing that we might need here is
245:28 - the terminating condition when low
245:30 - becomes less than high which means that
245:32 - we have no more elements to create trees
245:34 - out of we simply return none so the
245:36 - left or right subtree for those for the
245:38 - parents of those nodes get set to none
245:42 - so that's your makes balance bst
245:44 - function we also have this other thing
245:46 - called parent going around
245:48 - and this i will let you figure out what
245:49 - the parent does here but this is the
245:51 - basic idea
245:55 - so here is a list of key value pairs you
245:57 - have
245:58 - a key value pair sorted in increasing in
246:01 - the increasing or lexicographic order of
246:03 - keys
246:05 - and we're calling make balance bst with
246:07 - data
246:08 - and that gives us a tree and let's view
246:10 - the tree here
246:11 - so there you go now we have created the
246:13 - tree perfectly as we wanted it jadeish
246:15 - is at the center and we have viraj sunak
246:18 - on each side and then the appropriate
246:20 - nodes on each side as the children of
246:23 - those nodes
246:25 - now recall that the same list of users
246:26 - when inserted one by one resulted in a
246:28 - skewed tree here we are getting the list
246:30 - of users username and user from data and
246:33 - inserting them and you can see
246:38 - calling display keys on tree three
246:43 - returns a skewed tree okay so whenever
246:46 - you have a sorted array and you want to
246:48 - create a balanced bst the way to do it
246:51 - is
246:51 - to start from the middle out
246:59 - now finally one other question you may
247:01 - be asked is to
247:03 - balance an unbalanced binary search tree
247:07 - and this is
247:09 - pretty simple at this point and this is
247:10 - kind of a trick question because
247:12 - if you were given this question directly
247:14 - you may not be able to think about what
247:15 - to do how do you balance an unbalanced
247:18 - binary search tree
247:19 - but now that we have we have a way to
247:23 - create a balanced binary search tree
247:25 - from a sorted array
247:28 - of key value pairs
247:30 - and we have a way
247:32 - to get
247:33 - a sorted array of key value pairs
247:35 - so now it simply becomes calling the
247:38 - sorted array so calling list all on the
247:39 - node which is also the in-order
247:41 - traversal so doing an in-order traversal
247:43 - of the binary search tree which gives us
247:45 - a sorted area of key value pairs and
247:47 - then passing that into the make balanced
247:49 - bst function okay
247:51 - so that's the trick here it's a two part
247:53 - question and once again we see the
247:54 - benefit of reusing our functions here
247:57 - now we this now balancing and unbalanced
248:00 - bst now becomes a single line of code
248:03 - that's very nice
248:04 - so we create a tree here
248:07 - with the value none and now we insert
248:09 - into it the values one by one and you
248:11 - can see that that creates a skewed tree
248:14 - because we are inserting
248:16 - the values
248:17 - in increasing order
248:19 - electrical graphic order so we keep
248:21 - adding right children and we never add a
248:23 - right left child
248:24 - but then we call the balance bst
248:26 - function which internally takes this
248:29 - gets in order traversal so the inorder
248:31 - traversal lists all the keys and key
248:33 - value pairs in sorted order
248:37 - and then we call the
248:40 - make balance bst function which starts
248:41 - from the middle and then creates a
248:43 - bandwidth binary search tree out of it
248:46 - so there you see
248:47 - this is how you balance a binary search
248:49 - tree
248:51 - and what we can do now to maintain the
248:53 - balance as we grow our data structure is
248:55 - a simple thing that we can do is to ins
248:57 - to of insert
248:59 - to balance the tree after every
249:01 - insertion
249:05 - and that brings us to the complexities
249:06 - of the various operations in a balanced
249:08 - bst
249:10 - so if we are doing an ins if you're
249:12 - doing an insertion that takes order
249:13 - login because now if a tree is balanced
249:16 - its height is order login so for
249:18 - insertion you may have to traverse a
249:19 - path from the root down to a leaf and
249:22 - that path can be of length
249:25 - at maximum equal to the height which is
249:26 - order login but if we are also doing a
249:29 - balancing with every insertion then we
249:31 - also have an order n term added here and
249:33 - order n plus order log n because
249:35 - log n becomes much smaller than n as n
249:38 - grows so order n plus order login is
249:40 - the same as order n
249:42 - so that makes insertion order n
249:45 - finding a node becomes order login
249:48 - updating a node becomes order login and
249:50 - you can verify that listing getting a
249:51 - list of all the nodes is order n
249:54 - so what's the real improvement between
249:56 - order n and order login so let's think
249:58 - about it
250:00 - if you're looking at a 100 million
250:02 - records
250:03 - then
250:04 - log to the base 2 of 100 million is
250:06 - about 26 or 27
250:08 - so it only takes 26 operations to find
250:11 - or update a node within a balanced bst
250:14 - as opposed to 100 million operations so
250:16 - you can see here a 26 or
250:19 - a loop of size of length 26 and we're
250:22 - doing some operation inside it only
250:24 - takes about 19.1 microseconds that is
250:27 - one microsecond is
250:29 - 10 to the power minus 6 seconds on the
250:31 - other hand order n
250:34 - involves looping through the entire list
250:36 - so looking through 100 million numbers
250:38 - rather than 26
250:40 - and that obviously takes far far longer
250:43 - and we saw that it took about 10 seconds
250:45 - right about 9.98 seconds so
250:49 - to find and update
250:51 - finding and updating a node in a
250:53 - balanced binary search tree is 300 000
250:56 - times faster than our original solution
250:58 - and all we have changed here is the data
251:00 - structure
251:02 - and that's the importance of data
251:03 - structures because now
251:06 - each user will be able to view their
251:09 - profile in just 19.1 microseconds at
251:11 - least that part of the request will take
251:12 - only this long
251:14 - so the user experience will be better
251:16 - and your cpu will be busy for a shorter
251:18 - time so you will be able to serve not
251:21 - eight
251:22 - but hundreds of thousands of users
251:25 - every second
251:28 - and finally your
251:30 - hardware cost will also be far lower
251:32 - because now your cpu is busy for a
251:34 - lesser time so you do not need to use a
251:38 - very large machine or you do not need to
251:40 - use too many machines to support
251:41 - hundreds of millions of users
251:44 - and that is the benefit of choosing the
251:45 - right data structure
251:47 - now there's one tip here how do you
251:49 - speed up insertions
251:52 - so what we may do is we may choose to
251:54 - perform the balancing periodically
251:56 - instead of at every insertion for
251:57 - example we can balance for every 100th
252:00 - insertion or every thousandth insertion
252:02 - or every 100 000 insertion whatever you
252:05 - know that and that's where we have to
252:06 - balance how often do we need to insert
252:08 - things versus how often do we need to
252:10 - restore the balance
252:12 - another idea is to do the balancing
252:14 - maybe periodically at the end of every
252:16 - hour
252:18 - so
252:19 - for a second or two there may be a
252:21 - slight dip in the performance because
252:23 - you may be performing the balancing but
252:25 - even that there's a way to do it so you
252:27 - can take a copy of the tree and then
252:29 - balance it and then simply replace the
252:31 - pointer
252:32 - to the original tree so there are many
252:34 - other tricks that you can apply
252:35 - and in fact there's also an algorithmic
252:37 - trick which brings
252:40 - insertion and balancing together into an
252:42 - order login operation which we look at
252:45 - right at the very end so stay till the
252:47 - end
252:49 - but before we do that
252:51 - let's come back and answer our original
252:53 - problem statement so remember now as a
252:54 - senior backend engineer you are tasked
252:56 - with developing a fast in-memory data
252:58 - structure to manage profile information
253:00 - username name and email for 100 million
253:02 - users and it should allow insertion find
253:05 - update and listing the users by
253:07 - username
253:08 - all as efficiently as possible
253:11 - and to answer this question instead of
253:12 - creating a user database class we we can
253:15 - create a generic class called tree map
253:17 - because we have been making things more
253:19 - and more generic as we have gone along
253:21 - so let's define a function called tree
253:23 - map
253:24 - which
253:25 - internally stores
253:31 - a binary search tree a balanced binary
253:33 - search tree inside it
253:34 - so when we initialize the tree map we
253:36 - set self dot root to none which means we
253:38 - have not created a tree so far
253:41 - and then instead of defining functions
253:43 - insert
253:44 - update and delete we are going to use
253:46 - some special functions
253:48 - in python classes so we are going to use
253:49 - the function set item
253:53 - we're going to use the function set item
253:55 - here and set item
253:57 - is just like insert except it is a
253:59 - combination of both insert and update so
254:01 - to set item we will pass a key and a
254:04 - value and of course self will refer to
254:06 - the tree map object itself
254:09 - so the first thing we do is we get the
254:12 - root which which is basically the binary
254:14 - search tree that we are storing
254:15 - internally here so we get the binary
254:17 - search tree and then we find we look
254:20 - for the key inside the binary search
254:22 - tree so if the key is found so if we
254:24 - find the node
254:26 - in our tree
254:29 - then we come into this else position and
254:30 - then we simply update its value and if
254:32 - we do not find the node so which is what
254:34 - happens initially because initially our
254:36 - self.root is none so when you call find
254:38 - with none and pass a key you get back
254:41 - none
254:42 - so then we first set
254:44 - self.root
254:46 - by inserting the key
254:48 - into the tree okay
254:51 - so if a key exists within our
254:54 - binary search tree
254:56 - then we update it
254:58 - and if the key does not exist within a
255:00 - binary search tree
255:02 - then we insert it into our binary search
255:04 - stream okay so we've combined insert and
255:06 - update into the single operation called
255:08 - set item
255:10 - and similarly we define another
255:11 - operation called get item this is the
255:13 - find operation
255:14 - all we do here is we find the node
255:16 - inside self.root using the find function
255:18 - we had defined earlier
255:20 - and if the node is
255:22 - present if it is found then we return
255:24 - the value of the node otherwise we
255:26 - return none
255:27 - so given a key we retrieve the value
255:31 - and then we have we defined one last
255:32 - function called iter and this is the
255:34 - replacement for
255:36 - our list all function so what we do is
255:38 - we simply say we call listall on
255:40 - self.root so that gives us a list of key
255:42 - value pairs
255:44 - and then
255:45 - we have the special syntax we say x for
255:47 - x in
255:49 - this list
255:50 - and we put
255:52 - these round brackets around it so what
255:54 - this round brackets around it does is
255:56 - that this creates a generator out of it
255:58 - so now this is no longer list but this
256:00 - is a generator and a generator is
256:02 - something that you can use within a for
256:05 - loop so
256:07 - the iter function will allow our class
256:09 - to be used directly within a for loop
256:11 - and we'll see the example in just a
256:13 - second and finally we have another
256:15 - function called underscore underscore
256:16 - len
256:17 - so remember there are double underscores
256:19 - here so there's double underscore set
256:21 - item double underscore double underscore
256:22 - get item double underscore similarly
256:24 - double underscore uh len double
256:26 - underscore here we simply return the
256:29 - size of the self.root so here we simply
256:31 - return the size of the binary tree and
256:33 - then we have this function called
256:34 - display this is going to simply display
256:35 - the keys
256:37 - okay so now we've defined the stream app
256:39 - structure and it has all of these funny
256:41 - looking methods like we know in it but
256:43 - what about all of these but we'll see
256:45 - what these do in just a moment and we
256:47 - know what the what the functionality is
256:49 - but you may be wondering why we've
256:50 - defined them like this so the reason is
256:53 - these are special
256:56 - methods
256:57 - that are treated especially in python
257:00 - so here's how you can use them
257:02 - let's first get a list of users that
257:04 - we'll later insert into a tree
257:07 - let's get a tree map so we instantiate
257:09 - the tree map function
257:10 - the tree mac class and that gives us a
257:12 - new tree map inside it there is no
257:14 - binary tree you can check
257:17 - if you check tree map dot root you will
257:19 - see that it is none there is no value
257:21 - here
257:26 - and if we try to display it you can see
257:28 - that this tree map is empty
257:31 - then to insert instead of calling
257:33 - treemap.insert or instead of calling
257:35 - premap dot underscore underscore set
257:37 - item we can use this
257:39 - indexing notation so we open these
257:42 - square brackets and we put in the key
257:44 - that we want to insert so if we want to
257:46 - against the key ins against the key
257:48 - akash which is the string if you want to
257:50 - insert the value akash then we simply
257:52 - say tree of akash
257:55 - is akash
257:57 - and similarly tree of a certain key with
257:59 - the indexing notation set to this right
258:02 - so this is
258:03 - going to first look for the key as we
258:05 - have defined in set item if it finds the
258:07 - key then it is going to update the value
258:09 - for the key if it does not find the key
258:11 - then it is going to insert that key
258:13 - value pair as a new node into our tree
258:16 - so let's check it out now
258:21 - and let's see here if we now check tree
258:23 - map
258:24 - dot root you will see that now it is a
258:26 - bst node and if you try to display it
258:29 - you can see that now it has a structure
258:32 - jadeish
258:33 - and akash
258:34 - also note that this is a balanced tree
258:36 - now if you go back here to set item you
258:38 - will notice that whenever we insert
258:41 - right after this we also balance the
258:42 - tree and now you can change the logic
258:45 - here so that we do the balancing not
258:47 - after every insertion but maybe after
258:48 - every 100 insertions so you may need to
258:51 - track somewhere what is the current
258:52 - number of what is the current insertion
258:54 - counter and when it gets 200 only then
258:56 - do the balancing and then set the
258:58 - counter back to zero so that's an
258:59 - exercise for you perform the insertion
259:01 - or perform the balancing it only at
259:03 - certain intervals
259:09 - and here's a way to retrieve an element
259:11 - so the retrieving element is also now
259:13 - really simple you just call tree map
259:15 - with jadesh as
259:17 - the index and that gives you the value
259:20 - if it is found and if it is not found it
259:21 - simply returns none
259:23 - now because we have defined the function
259:25 - underscore underscore len underscore
259:27 - underscore
259:28 - so you can see here that has the value 3
259:31 - because that
259:32 - now we can use it with the len function
259:34 - which is used for lists and dictionaries
259:37 - and let's add a few more things
259:39 - and let's set the values and let's see
259:41 - here
259:43 - so you can see all this
259:44 - works exactly as expected
259:47 - now
259:48 - we are able to set values we are able to
259:49 - update values we are able to display the
259:51 - tree
259:52 - it is remaining balanced and remember i
259:55 - mentioned that you can use this in a for
259:56 - loop so you can now put the tree map
259:58 - directly into a for loop and what this
260:00 - will do is because we have defined the
260:02 - underscore underscore iter function and
260:04 - the iter function returns a generator
260:07 - so now
260:08 - you can use this in a for loop and you
260:10 - get back the key value pairs from the
260:12 - list all
260:14 - function that was used inside editor you
260:16 - can print the keys in the values
260:18 - and in fact if you want to convert it to
260:19 - a list all you need to do is pass it
260:21 - into the list and once again because
260:23 - this is a generator because this is an
260:26 - iterable this is now an iterable class
260:29 - and you have defined that the way to
260:30 - iterate over this class is to get
260:32 - elements out of the key value pair list
260:35 - so when you call list you get back this
260:37 - list of key value pairs
260:39 - okay so now we've made it a very python
260:41 - friendly class you know instantiating it
260:44 - is very easy we simply create a new tree
260:46 - map adding values is very easy we simply
260:48 - use the indexing notation removing
260:50 - elements is very easy well not removing
260:52 - a finding elements is very easy we
260:54 - simply use the indexing notation
260:56 - updating elements is the same as
260:57 - inserting
260:59 - we can also check the size of the tree
261:01 - quite easily using the len function and
261:02 - then we can also use
261:04 - iterate over the keys iterate over all
261:06 - the users in a for loop quite easily
261:11 - and we can also update values as you see
261:12 - here values have been updated
261:16 - now
261:18 - the the purpose of doing this
261:21 - is to make it easier for other people to
261:23 - use this data structure now as a senior
261:26 - backend engineer you may have designed
261:27 - this data structure and you may have
261:29 - implemented binary search trees inside
261:31 - it
261:32 - but it's not important for other people
261:34 - on the team or other people using your
261:36 - data structure to know what the internal
261:38 - implementation is what's important for
261:41 - them is to be able to use it easily so
261:43 - that's why always think carefully about
261:44 - the interface or the api of your
261:47 - functions or of your modules or of your
261:49 - classes
261:50 - try to make them as python friendly as
261:52 - possible this was something that will be
261:54 - appreciate that will be appreciated in
261:56 - interviews and by co-workers
261:59 - so make them python friendly so that
262:02 - when people want to use something you
262:04 - have created it is extremely intuitive
262:06 - you know and they do not need to really
262:08 - understand the underlying details
262:10 - for instance i could be using this class
262:12 - and i could have no idea that it is a
262:14 - binary search tree all i know is how to
262:15 - insert and how to get a value out of it
262:17 - and i know that it is super efficient
262:19 - because you have designed it
262:21 - and i don't don't need to worry about
262:22 - the internal details
262:25 - so encapsulation and good apis are very
262:28 - important
262:29 - skill to have to cultivate so do that as
262:31 - you work on programming problems
262:34 - now once again let's save our work
262:35 - before committing
262:37 - now i did tell you that
262:39 - there is a way to create self balancing
262:42 - binary
262:44 - trees and a self-balancing mandatory
262:47 - remains balanced after every insertion
262:49 - or deletion and in fact several decades
262:52 - of research has gone into creating
262:53 - self-balancing binary trees and not just
262:55 - binary trees but other trees as well
262:57 - which are not binary in nature and many
262:59 - approaches have been devised for
263:00 - instance red black trees avl trees and b
263:03 - trees so here's an example
263:06 - this is an avl tree so here whenever a
263:08 - node goes out of balance
263:11 - we rotate the tree and you can see
263:12 - visually what we're doing here now
263:14 - whenever you see that there is an
263:16 - imbalance in the tree
263:18 - we rotate it and how do you do this we
263:20 - do this by tracking the balance factor
263:22 - which is the difference between the
263:23 - height of the left subtree
263:26 - and the right subtree
263:28 - for each node and then rotating
263:30 - unbalanced subtrees along the path of
263:32 - insertion or deletion to balance them so
263:35 - you can see the balance factor is zero
263:36 - right now the balance factor becomes one
263:38 - and the balance factor becomes two then
263:40 - we rotate it to set the balance factor
263:42 - back and then the balance factor here
263:44 - becomes -2 so here we do a right
263:46 - rotation
263:47 - here the balance factor
263:50 - becomes minus 2 here and minus 1 here so
263:52 - here we do two rotations so there are
263:54 - four cases in total
263:57 - there's the left right case the right
263:59 - left case the left left case in the
264:00 - right right case all four cases were
264:02 - demonstrated here as well
264:03 - and then you may need to do this
264:05 - rotation not just once but you may need
264:08 - to do this multiple times along the path
264:10 - of insertion so when you insert a node
264:12 - and that node creates an imbalance then
264:14 - you need to work backwards so you need
264:16 - to keep going from parent to parent
264:19 - and keep rotating nodes whenever you
264:20 - need to rebalance them based on the
264:23 - updated balance factor of each node
264:25 - so it
264:27 - seems a little complicated but it's
264:29 - actually not it's just that there are
264:31 - multiple cases to handle
264:33 - so you will need to write a couple of
264:35 - helper functions you'll need to write a
264:36 - function
264:37 - left rotate which rotates node left
264:40 - while still preserving the binary search
264:42 - tree property you will need to write a
264:43 - function right rotate which rotates the
264:45 - function
264:46 - which rotates it to the right while
264:49 - preserving the bst property and then in
264:51 - the insertion you will also need to
264:54 - perform the rotation at the right places
264:56 - and you will need to track the balance
264:58 - factor inside each node so there are few
264:59 - things to work out here
265:01 - and don't worry you will normally not be
265:03 - asked to implement an avl tree within
265:05 - within an interview or within a coding
265:07 - assessment so you do not really need to
265:09 - learn the implementation but it's
265:11 - nevertheless a very interesting data
265:13 - structure to study and here are a couple
265:15 - of resources you can check out so you
265:17 - can check out this
265:18 - youtube video which explains it very
265:20 - wonderfully and you can check out this
265:22 - implementation on geeksforgeeks.org and
265:24 - the important thing for us to take away
265:26 - here and which is something that you
265:28 - may be asked if not the implementation
265:29 - but just the complexity the important
265:32 - thing is that
265:34 - each rotation takes constant time and at
265:37 - most log n rotations may be required
265:38 - because if you are starting with a
265:40 - balanced tree and you are inserting a
265:41 - new node
265:43 - then you may traverse a path of height
265:46 - at most of length at most log n so you
265:48 - may need to perform at most login
265:50 - rotations maybe twice of that
265:52 - so what that means is in order login
265:55 - time you will be able to insert and
265:57 - maintain the balanced property of a
265:58 - binary tree right so you do not need to
266:00 - recreate the entire tree again
266:03 - and that makes your tree very efficient
266:04 - because now when you're working with 100
266:07 - million records
266:08 - inserting will also take 20 steps
266:11 - and finding will also take 20 steps and
266:13 - updating would also take 20 steps and
266:15 - all of these will work in microseconds
266:18 - so that makes your data structure very
266:20 - efficient
266:23 - and with that we conclude our discussion
266:25 - of binary search trees
266:27 - so here's a quick summary we we looked
266:29 - at
266:31 - this problem of creating a data
266:33 - structure which allows efficient storage
266:36 - retrieval and updation
266:38 - also efficient
266:40 - iteration in a sorted order we first
266:43 - started out with a list of sorted list
266:46 - of
266:47 - values sorted by the keys and we
266:49 - realized that that was probably not the
266:51 - right idea because
266:52 - we are working with really large number
266:53 - of records then we created this binary
266:55 - tree structure so we looked at binary
266:57 - trees we looked at how to create them we
267:00 - looked at easy ways to visualize them
267:02 - easy ways to create them from tuples we
267:04 - looked at how to calculate their heights
267:06 - their sizes how to traverse them in in
267:08 - order pre-order post order we then
267:11 - looked at binary search trees which have
267:13 - this property
267:15 - that the left subtree
267:16 - has keys that are smaller than the
267:19 - root nodes keys and the rights of trees
267:21 - keys are larger than the root nodes keys
267:22 - and that property holds at every sub
267:25 - tree
267:26 - and that makes it really easy to find to
267:28 - locate a specific element or find the
267:30 - position to insert an element so we
267:32 - created binary search trees we created
267:34 - the operations insert update find
267:38 - and list all in a binary search tree we
267:40 - also
267:42 - determined ways to check if a binary
267:45 - tree is a binary search tree or not then
267:47 - we talked about balancing and we saw how
267:50 - to create balanced binary search trees
267:53 - and binary search trees form the basis
267:55 - of many modern programming languages
267:57 - language features for instance
268:00 - maps in c plus plus and java are binary
268:02 - search trees and data storage systems
268:04 - like file system indexes or relational
268:06 - databases also use something called b
268:08 - trees which is an extension of binary
268:10 - search trees
268:14 - so it's very important to know about
268:16 - binary searches even if you may not ever
268:18 - need to implement them
268:23 - you may be asked about them and in many
268:25 - cases you may need to pick a binary
268:27 - search tree as a data structure for a
268:28 - problem like we did in this case
268:31 - now you may wonder if dictionaries in
268:33 - python are also binary search trees well
268:35 - they're not
268:36 - dictionaries and python are not binary
268:38 - search trees so we'll soon release an
268:40 - assignment that you can find on the
268:42 - lesson page and you will work on hash
268:44 - tables in the assignment
268:48 - and here are some
268:49 - more problems that you can try out so
268:51 - you can try to implement rotations and
268:53 - self-balancing insertion you can try to
268:55 - implement the deletion of a node in a
268:57 - binary search tree that's slightly more
268:59 - complicated because
269:00 - what you do if you have to delete a node
269:02 - that has both left and right subtree
269:06 - you can try deletion with balancing if
269:08 - you really are up for a challenge
269:10 - here a couple more finding the lowest
269:12 - common ancestor of two nodes in a tree
269:15 - so the common node which
269:17 - is a common parent of both nodes
269:20 - here you can use the parent property
269:22 - finding the next node in lexicographic
269:24 - order so given a node how do you find
269:26 - the next node
269:27 - what's its complexity or given a number
269:30 - k how do you find the kth node in a
269:31 - binary search tree so to do this you
269:33 - will have to employ some clever tricks
269:36 - and then there are a couple more
269:37 - resources here you can open up these and
269:39 - find more questions the important thing
269:41 - to take away is that almost all of these
269:43 - will involve some form of recursion so
269:46 - you will either work with
269:48 - the left sub tree or the right sub tree
269:50 - or both
269:51 - and some of them may also require you to
269:53 - store additional information within the
269:55 - node for instance for
269:57 - for this one
269:59 - the given the number k find the kth node
270:01 - this may require you to store the size
270:04 - of each
270:05 - balanced binary search tree
270:07 - in each node
270:10 - so what to do next
270:11 - you should review the lecture video and
270:13 - execute the jupyter notebook experiment
270:15 - with the code yourself
270:17 - then complete the assignment hopefully
270:21 - the next lesson
270:22 - is called divide and conquer and sorting
270:24 - algorithms
270:25 - this is data structures and algorithms
270:27 - in python
270:28 - and i will see you next time
270:31 - thank you and goodbye
270:33 - let's look at assignment 2 of data
270:35 - structures and algorithms in python the
270:37 - topic of the assignment is hash tables
270:39 - and python
270:40 - dictionaries let's get started
270:43 - the first thing we'll do is go to the
270:45 - course website pythondsa.com
270:49 - and on the course website you can find
270:52 - all the lessons
270:53 - and previous assignments
270:55 - we are looking at assignment two so you
270:57 - may want to open that up and assignment
270:59 - two is based on or inspired from some of
271:02 - the topics discussed in assign lesson
271:04 - two so you may also want to watch lesson
271:05 - two and complete the notebook before you
271:07 - work on assignment two let's open it up
271:11 - now in this assignment you will apply
271:13 - some of the concepts learned in the
271:15 - first two lessons to implement a hash
271:17 - table from scratch in python that's very
271:19 - interesting
271:20 - you will
271:21 - and hash tables are very important data
271:23 - structure they're present in pretty much
271:24 - every programming language and are a
271:26 - common topic
271:28 - discussed and asked in coding interviews
271:31 - so we'll see how to implement them from
271:32 - scratch
271:34 - and one of the central problems in hash
271:35 - tables is called collisions so we'll see
271:37 - how to handle
271:39 - hashing collisions using linear probing
271:42 - and we will also replicate the
271:44 - functionality of python dictionary so
271:45 - python dictionaries are actually
271:47 - implemented using
271:48 - hash tables
271:50 - so we see how to replicate
271:53 - the way python dictionaries are created
271:56 - and used and modified and the way we
271:59 - access keys and
272:01 - iterate over keys and set values and
272:04 - change values and so on so we'll pretty
272:06 - much re-implement the python dictionary
272:09 - now we have an assignment starter
272:10 - notebook here so we can click on view
272:13 - notebook to open up the notebook
272:16 - once again this is a jupyter notebook
272:19 - and as you work through the notebook you
272:21 - will find
272:22 - question marks in certain places to
272:24 - complete the assignment you have to
272:25 - replace all the question marks with
272:27 - appropriate values expressions or
272:29 - statements to ensure that your notebook
272:31 - runs properly end to end okay so make
272:33 - sure that you run all the code cells do
272:36 - not change any variable names and in
272:38 - some cases you may need to add code
272:39 - cells or new statements and since you'll
272:42 - be using a temporary online service for
272:44 - code execution keep saving your work by
272:46 - running jovian.commit at regular
272:47 - intervals
272:49 - there are some optional questions they
272:51 - are not considered for evaluation but
272:53 - they are for your learning okay so let's
272:54 - run the code now the
272:57 - recommended way to run the code is using
273:00 - free online resources binder
273:02 - specifically but you can also run it on
273:04 - your computer locally so we're going to
273:06 - click run and click run on binder
273:09 - once again this may take
273:11 - a few minutes sometimes depending on
273:13 - the current traffic on the platform
273:16 - there we have it now we have the jupyter
273:18 - notebook running
273:19 - the first thing i like to do is click
273:21 - kernel and restart and clear output so
273:23 - that we can execute all the code cells
273:25 - and see their outputs from scratch
273:27 - i'm also going to hide the header and
273:29 - the toolbar and zoom in here a little
273:31 - bit
273:32 - so we can see things a little better
273:35 - the first thing we will do is set a
273:38 - project name import the jovian library
273:40 - and run jovian.commit this will allow
273:43 - you to save a snapshot of your work to
273:45 - your trovian profile so now you have a
273:48 - copy of the assignment starter notebook
273:51 - any modifications that you make every
273:53 - time you run joven.com it will get saved
273:54 - to your personal copy and it is this
273:56 - personal copy that you will submit at
273:58 - the very end
274:00 - so let's talk about
274:01 - the problem statement
274:03 - in this assignment you will recreate
274:04 - python dictionaries from scratch using a
274:07 - data structure called hash tables
274:10 - and dictionaries in python are used to
274:12 - store key value pairs so keys are store
274:14 - used to store and retain values
274:17 - and here's an example here's a
274:18 - dictionary for storing and retrieving
274:20 - phone numbers using people's names so we
274:23 - have a dictionary called phone numbers
274:24 - and the way you create a dictionary is
274:25 - using this special character the brace
274:28 - or the curly bracket as it's called
274:30 - and then in a dictionary you have these
274:32 - key value pairs so this is one key value
274:34 - pair where you have a key
274:37 - the key in this case is a string akash
274:40 - and here you have a colon
274:43 - and then here you have a value the value
274:45 - in this case is a phone number
274:47 - so that's how you create a key value
274:49 - pair
274:49 - and comma separated key value pairs is
274:52 - what you need to create a dictionary you
274:54 - can see once the dictionary is created
274:56 - it is displayed in the exact same way
274:58 - and then you can access a person's phone
275:01 - number using their name so if we have
275:03 - the variable phone numbers and we use
275:05 - the indexing notation so this is the
275:07 - square bracket and we pass in a key here
275:10 - we get back their name
275:12 - and you may wonder what happens if the
275:14 - key is not present the great thing about
275:16 - jupiter is you can insert a new cell
275:18 - like you can just click
275:19 - insert cell below or you can use the
275:21 - keyboard shortcut b as i just did
275:24 - and check maybe
275:26 - let's check the key vishal
275:29 - okay and you get back a key error
275:31 - and you may also wonder what happens if
275:34 - is it case sensitive does that matter
275:36 - you can check it very easily
275:39 - so a lot of the questions that you might
275:40 - get a lot of the questions that you may
275:42 - want to even ask on the forum or look up
275:44 - online can be resolved simply by
275:46 - creating a new cell and typing out some
275:48 - code right what happens if
275:51 - questions
275:52 - can all be answered by writing some code
275:55 - so now let's add some new phone numbers
275:57 - so this is how you create an initial set
275:59 - of phone numbers this is how you access
276:01 - a phone number and this is how you add
276:03 - new values so adding new values is like
276:05 - accessing them but instead of accessing
276:08 - it you put an equal to and then you
276:09 - actually set the value here
276:11 - so we can add a new value here the phone
276:14 - number for vishal and we can also update
276:16 - an existing value in a dictionary simply
276:18 - by accessing that value and putting an
276:21 - equal to
276:22 - and putting in new value there
276:24 - you can see now that the dictionary is
276:25 - updated to contain the new phone number
276:28 - 7878 and not the original phone number
276:31 - 948948
276:33 - you can also view all the names and
276:34 - phone numbers stored in the phone number
276:37 - dictionary using a loop so you can say
276:39 - for for name and phone numbers so when
276:42 - you put a dictionary into a for loop you
276:44 - get back a key within each loop
276:46 - you can see here that
276:48 - the name and the phone number here is
276:50 - displayed for you
276:52 - using the print statement
276:54 - so those are some things that you can do
276:56 - within a dictionary
276:57 - and dictionaries in python are
276:59 - implemented using a data structure
277:00 - called a hash table and a hash table
277:02 - uses a list
277:04 - or an array to store key value pairs
277:07 - and
277:07 - uses a hashing function to determine the
277:10 - index for storing or retrieving the data
277:12 - associated with a given key
277:15 - so here's what it looks like here you
277:17 - have
277:18 - the key john smith
277:20 - and you have a function called hash and
277:22 - the function hash takes any key and it
277:25 - returns an index within the list
277:28 - so why do we use a hashing function well
277:30 - one approach as we've discussed in
277:32 - lesson two
277:34 - is we can store our key value pairs in a
277:37 - list and we can simply search through
277:39 - the list each time we want to look up
277:40 - the value for a key but that is
277:42 - inefficient because that requires
277:44 - looking through potentially all the keys
277:46 - before we get to the key that we want or
277:48 - maybe half of the keys so that makes it
277:51 - an order n operation
277:53 - if n is the size of the list
277:57 - that's pretty inefficient we want
277:58 - something faster and a hash function
278:01 - actually operates in constant time so
278:04 - hash simply takes the key
278:06 - and it converts the key into a number so
278:09 - in that sense it gives you the index of
278:12 - the specific key value pair
278:15 - in constant time rather than ordering
278:17 - and that is what makes hash table so
278:18 - efficient right so hash function
278:22 - does not require looping through the
278:24 - list it simply takes a key gives you the
278:25 - index and you can simply then get
278:28 - the key value pair or the value from
278:30 - that index
278:31 - now your objective in this assignment is
278:34 - to implement a hash table class which
278:36 - supports these operations an insert
278:38 - operation a way to insert a new key
278:40 - value pair a find operation to find the
278:43 - value associated with a given key an
278:45 - update operation to update the value
278:47 - associated with the given key and then
278:49 - list operation to list all the keys
278:51 - stored in the hash table
278:54 - and here's where we are going to use
278:56 - python classes
278:58 - and there's a
278:59 - brief introduction to python classes in
279:02 - lesson two
279:03 - of this course so do check out lesson2
279:05 - if you want a refreshing on python
279:07 - classes
279:08 - you have the class hash table
279:11 - and inside the class hash table you have
279:13 - a bunch of
279:15 - methods now the insert method apart from
279:18 - taking the self argument and remember
279:20 - that the self argument is
279:22 - refers to the object of the
279:25 - class that will be created so this is
279:27 - equivalent to this
279:30 - variable in java or c plus
279:34 - but these are the actual arguments of
279:36 - the method
279:37 - the actual arguments are key and value
279:39 - so the
279:41 - insert function or the insert method
279:43 - will take key and value
279:45 - then the find method will take a key
279:47 - the update method will take a key and
279:49 - value once again so the find method
279:50 - takes a key and your job is to return
279:52 - the value the insert method takes a key
279:54 - and value and you insert the key value
279:56 - pair into the hash table
279:58 - then you have the list all method which
280:01 - is used to list all the keys from the
280:03 - table
280:04 - so before we begin our implementation
280:06 - let's just save and commit our work so
280:08 - we're running joven.comit here
280:10 - let's just run that once again
280:13 - there we go the notebook has now been
280:15 - committed
280:16 - so what you can do is
280:18 - you can come back to this particular
280:20 - page and you can find this from your
280:22 - profile and then you can click run to
280:24 - continue your work
280:25 - based on the modifications that you've
280:27 - already made
280:28 - okay so we build a hash table class step
280:31 - by step
280:32 - and the first step is to create a python
280:34 - list which will hold all the key value
280:36 - pairs now remember that a hash table
280:38 - internally uses a list to store the key
280:39 - value pairs
280:40 - and we will create a list of a fixed
280:43 - size so we'll set this variable max hash
280:45 - table size of size 4096
280:48 - initially
280:49 - and we're going to create a python list
280:52 - of this size how do you create a python
280:53 - list of the size and we want all the
280:55 - values to be set to none
280:57 - so this is the way to do it you can of
281:00 - course you can start typing
281:02 - none and that would take a long time
281:05 - or you can use a simple
281:07 - technique just put in none times 4096
281:10 - and that's one of the great things about
281:12 - python it is such an expressive language
281:14 - that creating a list of 4000 elements
281:16 - simply requires this single
281:19 - expression here
281:21 - you can check that here you can even
281:23 - check the length of
281:24 - the data list
281:26 - now if the list was created successfully
281:28 - here are some test cases
281:30 - here is one check that the length of the
281:32 - list is 4096 here's another check and
281:35 - we're simply picking a random value from
281:37 - the list 99 and just checking if that is
281:40 - equal to none but if you really want to
281:42 - have a
281:43 - sure shot test here what you should be
281:45 - doing is you should be checking for
281:48 - item in data list
281:51 - item equals none
281:53 - okay and here's a trick you can do you
281:55 - can
281:56 - write a word called assert and what
281:59 - assert does is if this comparison
282:03 - is true then it does nothing it lets
282:05 - your code proceed as usual but if at any
282:09 - point this comparison becomes false
282:12 - then it throws an error so let's see
282:14 - here you can see here there was no error
282:15 - so that means it worked fine but if this
282:17 - comparison was wrong so let's say if
282:19 - item
282:21 - if we had here
282:22 - we wanted the items to be equal to
282:26 - seven if you put it and and the telus
282:29 - does not contain the item seven at a
282:31 - certain position then you will get an
282:33 - assertion error here okay
282:36 - this is how you can create your own test
282:38 - cases by putting in assert
282:40 - but the idea here is that whatever you
282:42 - try to do make sure that you're adding
282:45 - some more test cases and not just
282:46 - depending on the test cases that are
282:48 - given here
282:49 - these are simply to guide you in the
282:51 - right direction
282:52 - okay so next up we have a list now we
282:55 - need a way to store or insert key value
282:57 - pairs into a list
283:00 - that's where the hashing function comes
283:01 - into picture the hashing function is
283:03 - used to convert strings and other
283:05 - non-numeric data types into numbers
283:07 - which can then be used as list indices
283:10 - for example if a hashing function
283:12 - converts the string akash into the
283:14 - number 4 then the key value pair akash
283:17 - and the phone number seven eight seven
283:19 - eight seven eight seven eight
283:21 - seven eight will be stored at the
283:23 - position four within the data list and
283:25 - here's a simple algorithm for hashing
283:27 - which can convert strings into numeric
283:29 - list indices and
283:31 - a hashing algorithm does not have a
283:32 - single definition
283:34 - you can come up with a hashing algorithm
283:36 - and in fact coming up with a good
283:38 - hashing algorithm is
283:41 - an area of research in itself now of
283:43 - course python dictionaries use hashing
283:46 - that is inbuilt into python and that's a
283:48 - fairly optimized
283:49 - hashing algorithm that's
283:51 - probably the result of several years of
283:53 - research
283:55 - but here's one very simple technique we
283:57 - iterate over the string character by
283:59 - character and then we convert each
284:00 - character into a number using python's
284:02 - built-in ord function
284:04 - and you can see here that if you call
284:06 - ord
284:08 - on the character x
284:10 - you get back a number
284:11 - it already gives you a way of converting
284:13 - characters into numbers but not
284:16 - entire strings that's why we need to
284:17 - iterate over the string character by
284:18 - character then we simply add the numbers
284:21 - for each character to obtain the hash
284:23 - for the entire string it's a very simple
284:25 - technique we just keep
284:26 - if you have the number hello we take the
284:29 - odd for hello the odd for e the odd for
284:32 - l the odd for l and the odd for o and
284:34 - add them together
284:36 - and since we want that number the final
284:38 - result to be an index
284:40 - or a position within the list
284:42 - so we take the remainder of the result
284:44 - with the size of the data list right so
284:46 - it's possible that once you add the
284:48 - numbers together you may end up with a
284:49 - pretty big number but if you take the
284:51 - remainder
284:52 - with
284:53 - 4096
284:55 - or the max hash
284:57 - table size
284:58 - variable
285:00 - you get back
285:02 - a number that is smaller than 4096 so
285:04 - you can use just that remain as the
285:06 - index
285:08 - so let's first define a function called
285:10 - get index
285:11 - all it does is it takes the data list
285:13 - and it takes a string
285:15 - and it returns it applies this hashing
285:18 - algorithm to return an index
285:21 - for that string for that key
285:23 - so for a character in a string we need
285:26 - to convert the character to a number so
285:28 - we convert the character from the string
285:30 - into a number
285:32 - by calling od
285:34 - on a character
285:36 - great then we update the result by
285:38 - adding the number so we say result plus
285:42 - equals a number
285:43 - pretty straightforward
285:45 - and that
285:46 - repeats for all the characters in the
285:48 - string and then we get back the final
285:50 - result now that result may be longer
285:53 - than the actual size of the list
285:56 - and this is where we then we may then
285:57 - want to check the size of the list okay
286:00 - now remember there's one no i could also
286:02 - have probably written max
286:04 - hash table size here
286:07 - but that would be wrong
286:08 - isn't it because we are passing in a
286:11 - data list here we are passing in a data
286:13 - list and
286:15 - although we have so far created a data
286:17 - list of size 4096
286:20 - your function should ideally be you
286:22 - looking at the size of the data list
286:24 - that you have here and not any global
286:27 - variables
286:28 - so keep that in mind and the right thing
286:30 - you should check here is lend data list
286:33 - and what this will allow is now this
286:34 - will allow your function to work with
286:36 - data lists of different sizes and not
286:39 - just the standard size 4096 that we have
286:42 - defined above okay very important thing
286:45 - always make sure that your functions
286:48 - use the arguments
286:50 - that are passed into them that they are
286:52 - generic that they can work with any
286:55 - input and not just a particular input
286:57 - that have been
286:58 - that has been defined earlier okay
287:03 - so
287:04 - there you go now you have
287:06 - this is a function get index that has
287:07 - been defined
287:09 - and here are some tests now if you pass
287:10 - in the data list and you pass in the
287:12 - empty string because there are no
287:14 - characters the result is likely to be
287:16 - zero it's great
287:18 - here's another one
287:19 - the result here is 585 here's another
287:22 - one result here is 941 great now
287:26 - this is where you should be testing your
287:28 - function with some custom test cases i'm
287:31 - going to create a new
287:32 - data list 2 and this is going to have
287:34 - the size none times 48 so this is only
287:37 - going to have the size 48
287:39 - and i should be testing get index
287:42 - with this data list as well
287:45 - so let's say
287:46 - we're looking at
287:48 - the key akash
287:50 - now we know that
287:52 - let's see
287:53 - we can actually test this out here what
287:54 - happens if you add ord of a
287:58 - plus or d of a
288:01 - plus k
288:02 - a
288:03 - s
288:04 - and h
288:06 - that number is 585 but since the
288:08 - size of the list is 48
288:10 - what we should be getting back as the
288:12 - result is 48 divided by 585
288:16 - so we should be getting oh sorry
288:19 - 585 and its remainder with 48.
288:22 - we should be getting back the number
288:23 - nine
288:24 - this should be equal to nine
288:27 - okay
288:28 - so let's check that if this is equal to
288:30 - nine
288:32 - and indeed this is equal to nine
288:35 - on the other hand if we had
288:38 - max
288:41 - hash table size
288:43 - you will see here that
288:45 - since we are not taking into
288:46 - consideration the actual size of the
288:48 - list that was passed into the function
288:52 - we are getting back the value 585
288:54 - because we are taking the remainder with
288:56 - 4096 okay so remember to take the result
289:00 - remainder with the size of the data list
289:02 - that was passed in
289:04 - so this is one of the several gotchas in
289:06 - this assignment and they're there for a
289:08 - reason because
289:10 - this is something that you need to keep
289:12 - in mind
289:14 - a function which only uses its arguments
289:16 - and does not
289:17 - depend on any external global variables
289:21 - or
289:22 - constants and things like that
289:25 - is called a pure function
289:27 - of course a plot function also does not
289:29 - modify any external global variables so
289:31 - it simply takes some arguments and
289:33 - returns a result
289:35 - irrespective of
289:36 - anything else
289:38 - outside
289:39 - so now we can
289:41 - to insert a key value pair into a hash
289:43 - table we can simply get a hash of the
289:45 - key so here we have a key value pair and
289:47 - we simply get a hash of the key by
289:49 - calling get index for data list and key
289:51 - and we get back the index 585 and then
289:54 - inside the data list at the given index
289:56 - we can simply set the key value pair as
289:58 - the
289:59 - element stored at that index
290:02 - and the same operation can be expressed
290:04 - in a single line of code so here we're
290:06 - calling get index
290:09 - for data list and he month
290:11 - and that's going to give us an index
290:13 - and we're going to then invoke
290:15 - a set
290:17 - at that particular index within data
290:19 - list
290:20 - the the element
290:22 - hemanth comma hemans phone number
290:26 - now to retrieve or find the element
290:28 - associated with a pair
290:29 - we can simply get a hash of
290:33 - the element the value associated with
290:34 - the key we can simply get a hash of the
290:36 - key and look up that index within the
290:38 - data list so here we have the kiakash
290:41 - and we have the data list and we call
290:43 - get index
290:45 - so we get the index of the kiakash
290:49 - and that gives us the index here
290:51 - and we can then call datalist
290:54 - and pass in the position idx and that
290:57 - should give us a key value pair remember
290:59 - that we stored a key value pair at the
291:00 - given index so we should get back that
291:02 - value here
291:04 - so now we know how to store a value you
291:06 - get its hash for the key and you store
291:08 - the key value pair how to retrieve a
291:10 - value so you get a hash for the key and
291:13 - then you retrieve the
291:14 - key value pair and from there you can
291:16 - get the value
291:18 - you can also list the keys to list the
291:20 - keys here is some special code we are
291:23 - using
291:24 - so let's see this is called list
291:25 - comprehension and let's take a quick
291:27 - look at list comprehension
291:29 - so list compression works like this
291:31 - if you create a list y from a list x
291:34 - uh let's say let's call this list one
291:38 - and list two
291:39 - go to variable names always help so if
291:42 - you have a
291:43 - list one and you write this x for x in
291:47 - list one
291:49 - what does that do
291:52 - that for x in list one
291:54 - patches
291:55 - elements one by one from the list
291:58 - and then here you can specify what to do
291:59 - with the numbers that were fetched so
292:00 - right now i'm not doing anything i'm
292:02 - simply returning that number and then
292:03 - i'm putting the entire thing into a list
292:06 - what this does is this creates a new
292:08 - list so you can see this is a copy of
292:10 - the original list what i could do is i
292:12 - could write x times two for x in list
292:15 - one
292:16 - and now i would end up with a list which
292:18 - in which each element is the double of
292:20 - that particular element
292:23 - i could also do x times x if i wanted
292:27 - i could also call a function on it
292:30 - let's see what function we can call here
292:32 - let's maybe put in some numbers here 1.3
292:36 - 2.4
292:38 - 3.2
292:40 - so we could put maybe the function math
292:42 - dot round
292:44 - x
292:45 - oh sorry math dot seal
292:48 - this is going to give us the ceiling the
292:50 - 1.3 becomes 2 2.4 becomes 3 so you can
292:53 - do any operation with each element of
292:55 - the list and once you put that in a
292:57 - bracket and you have this 4 here
293:00 - that's going to apply that same
293:01 - operation to the entire
293:03 - list and this is called list
293:05 - comprehension in python it's a very
293:07 - powerful way to express complex
293:09 - operations on lists and dictionaries
293:12 - and there's one final thing in list
293:14 - operations which is the if condition so
293:17 - for x in list 1 can be followed by an if
293:20 - condition and the if condition can once
293:22 - again apply on x
293:23 - so if
293:25 - x is greater than
293:28 - 3 let's say we put this condition
293:30 - then what happens is we choose only
293:33 - those numbers from list one which
293:35 - satisfy this condition x greater than
293:37 - three so that means we would skip one
293:39 - point three we would skip two point four
293:41 - we would get three point two we would
293:42 - get six we would get seven and we would
293:44 - apply math.cl to them and that's how we
293:47 - get back 467
293:48 - so that's list comprehension in a
293:50 - nutshell
293:51 - so to get a list of keys all we can do
293:54 - is for key value pairs in data list
293:57 - if the key value pair is not none
294:00 - remember that we have a lot of non
294:01 - values and it's a huge list
294:03 - if the key value pair is not none then
294:05 - we simply return kv0 so remember if you
294:08 - have a key value pair
294:10 - if you have like a key value pair that's
294:13 - akash and a phone
294:14 - number and you can also put because
294:17 - these are tuples
294:19 - you can also put a
294:20 - round bracket here if you want but even
294:22 - without it it's the same thing
294:24 - that's a key value pair
294:26 - kv 0
294:28 - is going to give you the key and kv 1 is
294:30 - going to give you the value
294:33 - so we simply get the key for those key
294:35 - value pairs in data list where the
294:37 - element at that position of the key
294:38 - value pair is not none
294:40 - and that should not be called pairs that
294:42 - should probably be called keys
294:44 - you can see that the keys are akash and
294:46 - hemath
294:48 - so that's how we can now use the get
294:50 - index function
294:52 - and the next step for you is to complete
294:54 - the hash table implementation
294:56 - here
294:57 - by following the instructions given in
294:59 - the comments
295:00 - so now you have this basic hash table
295:03 - class and in this class you have a
295:05 - constructor
295:06 - now the constructor takes
295:09 - the object self or this and the self is
295:12 - going to point to the actual object or
295:14 - the actual hash table that gets created
295:16 - using the class
295:17 - and then it takes a maximum size
295:19 - now what are we doing here we want to
295:21 - make our hash table configurable we
295:23 - don't
295:24 - always want to have 4096
295:27 - elements
295:28 - in our internal list
295:30 - we may need a hash table that can store
295:32 - more values or we may need a hash table
295:33 - that can only store fewer values so we
295:36 - are going to set a
295:37 - a default value for it which is the max
295:39 - hash table size so if you do not provide
295:41 - this argument by default it will create
295:43 - a list of size 4096
295:46 - but
295:47 - we also want the option to specify a
295:49 - maximum size now you need to create a
295:51 - list of size max size with all the
295:53 - values set to none
295:55 - now you may be tempted to do this
295:57 - but that would be wrong remember that
296:00 - always use the arguments to a function
296:03 - try not to depend on an external value
296:05 - or external constant so this would be
296:07 - wrong
296:08 - you may also be tempted to do this data
296:11 - list set dot data list equals data list
296:13 - that we've already created this would
296:15 - also be wrong
296:17 - not just because you're not using the
296:18 - max size but also because
296:21 - now you are tying this class
296:23 - implementation to a global variable
296:25 - and that global variable
296:28 - is a list which can be modified so if
296:30 - you all the objects of this class any
296:32 - number of hash tables that you create
296:34 - using this class
296:35 - we'll all use the same data list and
296:37 - that's not what you want each hash table
296:39 - that you create maybe you have a hash
296:40 - table for phone numbers you have a hash
296:42 - table for addresses you have a hash
296:43 - table for something else each of them
296:45 - should have their own internal data list
296:49 - and this is not going to create a copy
296:51 - of that original this is simply going to
296:52 - point to the original list so what you
296:54 - want to do is you want to do
296:58 - none
296:59 - and you want to multiply it with max
297:01 - size
297:02 - there you go this is the correct way to
297:05 - do this
297:06 - now we're looking at insert here now to
297:09 - insert
297:10 - we did see that to get the index all you
297:12 - need to do is you need to pass the key
297:14 - and remember here you need to pass not
297:16 - data list but self.datalist right
297:19 - because now we want to use the
297:21 - data list that is stored inside this
297:23 - specific object of the class we do not
297:25 - want to use the global data list and
297:27 - this is something that is
297:29 - an mistake that we often make initially
297:31 - i've still make this mistake where i
297:33 - have certain global variables defined
297:36 - and i'm using those global variables
297:37 - inside my class
297:39 - avoid doing that anything that you want
297:41 - to put inside a class object you need to
297:43 - put inside self like we've done here and
297:45 - then to access it you need to use self
297:47 - dot to access that specific
297:50 - property or
297:53 - element or even method
297:56 - so now we have self.datalist and we pass
297:59 - in the key and the data list into get
298:01 - index
298:03 - and that gives us the index
298:05 - now the get index function was defined
298:07 - earlier we've seen it already
298:09 - now we want to store the index inside
298:12 - the list so we call
298:14 - self.datalist idx and we want to store
298:17 - the key value pair there so we can
298:18 - simply put in key comma value here
298:21 - if you wish you can also put in the
298:23 - brackets but they are not necessary
298:25 - and that's going to insert the key value
298:27 - pair now how do we
298:29 - find the value associated with the given
298:31 - p key
298:32 - first
298:34 - we get the index for the key so we call
298:36 - get index
298:37 - on self.datalist and key
298:40 - then we retrieve the data stored at the
298:42 - index so this would be
298:45 - simply
298:47 - self dot data list
298:50 - of idx
298:51 - and then if the key value pair is not
298:53 - none
298:54 - if the key value pair is none well
298:56 - there's nothing in that index we can
298:57 - return none another option would be to
299:00 - also maybe raise an index error
299:04 - and with a message
299:07 - etc etc but
299:09 - return on is good enough for now
299:11 - then if not
299:13 - from the key value pair we get back the
299:14 - key and the value and then we return the
299:16 - value
299:18 - keep those in mind if you simply return
299:20 - this you would get an error you would
299:21 - get an exception that may go unexplained
299:24 - so whenever you are destructuring or
299:26 - you're trying to get two values out of a
299:28 - tuple make sure that the tuple is not
299:30 - none especially in this case because
299:31 - we're starting with a list of nones
299:34 - in a place where we're supposed to be
299:36 - storing key value pairs
299:39 - so that's fine
299:40 - now update is
299:42 - going to be
299:43 - pretty much identical to insert i don't
299:46 - see any difference here so we can simply
299:48 - say
299:49 - get index for self dot
299:54 - data list and key
299:57 - and then now we simply store the key
299:58 - value pair inside it so we can simply
300:00 - store oops the key comma value
300:03 - inside self.datalist idx
300:06 - then for list all
300:07 - again straightforward
300:09 - self dot
300:10 - fkb is not none so get all the
300:13 - key value pairs that are not empty and
300:15 - then we simply get
300:17 - kb 0 is going to give us the key from kv
300:21 - so that there it is
300:23 - here you can see already that we are
300:24 - creating a basic hash table
300:26 - of max size one zero two four
300:28 - so the first thing that we can verify is
300:30 - that the length of the basic of the data
300:32 - list is one zero two four
300:34 - there you go
300:36 - then you insert some values here so we
300:39 - insert
300:41 - the value akash we insert the key value
300:44 - pairs so we insert the value 9999 for
300:47 - akash so this is one key value pair we
300:49 - are inserting hemanth and 8088 and what
300:52 - this will do is when you call basic
300:54 - table dot insert
300:56 - it will call this insert function
300:59 - and self will now point to the basic
301:02 - table that we have just created because
301:04 - we're calling insert on that specific
301:05 - basic table so self will point to the
301:07 - basic table
301:09 - so self.datalist will become basic
301:11 - table.datalist and then the remaining
301:14 - arguments are cached in 9999 will get
301:16 - passed in as the key and the value
301:19 - so this code will execute we will get
301:21 - the index
301:23 - within self.datalist for the kiakash and
301:26 - then within self.datalist or basic
301:29 - table.datalist in this case add the
301:31 - given index that we just computed we
301:33 - will store the key value pair which is
301:35 - akash and the phone number
301:37 - and that's how it'll work
301:39 - so we're inserting some values and then
301:41 - we're finding a value
301:42 - so when once we insert the two values
301:44 - and then we find a value that should
301:46 - give us the
301:47 - value 888 you may want to then maybe
301:50 - modify this test case to also include
301:52 - the test for the other value that we
301:53 - inserted so feel free to modify the test
301:56 - cases
301:57 - or add new test cases
301:59 - so that we're checking not just one
302:00 - value but both the values
302:03 - next let's see how we if we can update a
302:04 - value so we call basic table dot update
302:06 - and we said seven seven seven seven
302:09 - now suppose you're not implemented
302:10 - update here that's for a moment
302:14 - return
302:15 - suppose you've not implemented update
302:16 - here
302:17 - then
302:19 - if you called update
302:21 - you would get false here because the
302:22 - value did not get updated and you can
302:24 - check that by
302:26 - simply checking
302:29 - basic table dot find akash you can see
302:31 - that it still has a value 9999
302:34 - that's how test cases are helpful
302:36 - let's remove the return
302:40 - okay so now the value seems to have been
302:41 - updated just fine
302:43 - then let's get a list of all the keys
302:46 - and the list of keys should match true
302:48 - once again if we did not have this kv is
302:51 - not none then we would get back not just
302:53 - this key value pair but we would get
302:54 - back all the nuns and we don't want that
302:58 - so these were some test cases but you
303:01 - need to now create more test cases
303:03 - and test them out to make sure that your
303:05 - implementation is correct
303:07 - now once you've done that
303:09 - you would want to run jobin.comit
303:11 - now the next step and this is something
303:13 - that you may have thought about while
303:15 - working through the assignment is that
303:17 - how do you ensure that
303:20 - different keys
303:21 - do not point to the same index because
303:23 - we are doing all these things where
303:25 - we are
303:26 - converting each character into a number
303:28 - and then adding up the characters now
303:30 - obviously if you have
303:32 - words which have the same characters but
303:34 - in different orders now obviously there
303:35 - are different keys
303:37 - but
303:38 - they do not have they have the same hash
303:41 - listen
303:42 - and silent
303:43 - have exactly the same
303:45 - keys
303:47 - exactly the same hash so for instance
303:49 - instance you can check get index
303:52 - listen
303:53 - and get index
303:55 - silent
303:57 - okay we also need a data list let's put
303:59 - in a data list here
304:01 - both of them have the hash 655
304:04 - that means if you insert a value
304:07 - at with the key listen and then you
304:09 - insert a value with the key silent
304:11 - the data at this position will get
304:13 - overwritten so when you try basic table
304:15 - dot find listen you will get the value
304:18 - associated with silent and that's bad
304:21 - and this is called collisions
304:24 - this is called a collision because here
304:26 - the
304:27 - two keys are colliding in some sense
304:30 - because they're leading to the same hash
304:32 - and any hash table that you implement is
304:34 - ultimately going to have collisions
304:36 - because the number of strings or the
304:38 - number of keys is possibly infinite but
304:40 - you have a
304:42 - limited number of positions or indices
304:44 - in your table
304:46 - so our hash table implementation is
304:48 - incomplete because there can be data
304:49 - loss and it does not handle collisions
304:51 - and there are multiple techniques to
304:53 - handle collisions and we the technique
304:55 - we will use in this
304:57 - assignment is called linear probing and
304:59 - here's how it works
305:01 - while inserting a new key value pair if
305:03 - the target index for a key is occupied
305:06 - by another key then we simply try the
305:08 - next index and if the next index is also
305:10 - occupied by another key we try the next
305:12 - and then if we try the next and then we
305:14 - try the next till we find the closest
305:15 - empty location
305:17 - and then while finding a key value pair
305:19 - we apply the same strategy but it's
305:21 - searching for an empty location this
305:23 - time we search for a location which
305:24 - contains the key value pair with the
305:26 - matching key
305:28 - we get the hash of the key that we want
305:30 - to find and then we check if that
305:33 - position is occupied by another key not
305:35 - the same key
305:36 - then we try the next index and then we
305:38 - try the next index and then we try the
305:40 - next index till we find a position which
305:42 - is occupied by a key value pair for the
305:44 - same key
305:46 - and if we find an empty position that
305:47 - means
305:49 - the key does not exist because if it did
305:51 - exist then it should have been somewhere
305:52 - in that
305:54 - string of searches that we just come
305:56 - that we just did
305:58 - now by updating the key value pair again
306:00 - we apply the same strategy but instead
306:02 - of searching for an empty location we
306:04 - look for a location which contains a key
306:06 - value pair with the matching key and
306:08 - update its value
306:10 - so that's how you handle collisions in a
306:12 - hash table
306:14 - and to handle collisions we will define
306:16 - a function called getvalidindex which
306:18 - first gets the hash using get index
306:22 - and then start searching the data list
306:23 - and returns the first index which is
306:25 - either empty
306:27 - or contains a key value pair matching
306:28 - the given key so we are now
306:31 - addressing two
306:33 - requirements in one shot with the get
306:36 - valid index function
306:37 - for insertion we are looking for an
306:39 - empty position
306:40 - for
306:42 - find an update we are looking for a
306:44 - position which is occupied by a by the
306:46 - given k value by the given key value
306:48 - pair
306:48 - okay or the given key specifically so
306:52 - here's the get valid index function
306:54 - and
306:55 - i will let you work through this
306:57 - so you will start with the index
306:59 - returned by get index
307:01 - then
307:02 - while true
307:03 - because we don't know how long we may
307:04 - need to iterate get the key value paired
307:06 - stored at the index
307:08 - this is where you may have to
307:11 - it's simply a question of putting the
307:13 - index into data list getting the key
307:14 - value pair now if the key value pair is
307:17 - none which means that there is nothing
307:18 - at that index it is empty
307:20 - that's great we are done we can simply
307:22 - return the index
307:23 - on the other hand if it does have values
307:26 - so then we get the key and value out of
307:28 - it if the key
307:29 - matches
307:30 - the key that we want to store
307:33 - great then we can return the index once
307:35 - again
307:36 - if neither of these hold true we move
307:38 - the index to the next position
307:40 - but as we move
307:41 - to the next position it's possible that
307:43 - we may run out of indices so the index
307:45 - may become equal to the length of the
307:46 - data list so then we wrap around and go
307:49 - back to the zeroth position so this is
307:51 - an important part where we go around so
307:53 - now our list is in some sense circular
307:55 - where we can keep looping around it so
307:57 - that if we have something that needs to
307:59 - be stored at the last position
308:02 - but the last position is occupied then
308:03 - we move back to the zeroth position and
308:06 - so on
308:07 - and then you can check if get valid
308:10 - index was defined correctly and if it
308:12 - was then these cells should output true
308:15 - once again these are just some sample
308:17 - test cases so you should include some
308:18 - more of your own test cases here
308:21 - and finally once you're done just save
308:22 - your work
308:24 - now the next step is to incorporate
308:27 - linear probing into your hash table so
308:29 - here's a new class called probing hash
308:31 - table
308:32 - here you need to use not get index but
308:34 - get valid index
308:35 - it has pretty similar code so i'll let
308:37 - you work this out
308:39 - be
308:41 - aware not to simply copy paste code and
308:44 - you will run into issues if you copy
308:46 - paste code
308:47 - so always make sure that you are
308:50 - writing the code yourself and carefully
308:52 - writing each word or each variable in
308:55 - each method and each argument of the
308:56 - code
308:58 - then there are some test cases here for
309:00 - you to test the probing hash table
309:02 - once again you can try it out with some
309:05 - examples and
309:06 - see if it works fine
309:08 - specifically here we are taking the same
309:10 - example listen and silent
309:12 - both of which in basic hash table would
309:14 - have the same key but in probing hash
309:16 - table would have different
309:18 - will have the same position but in
309:20 - probing hash table will have
309:23 - different positions
309:25 - and that's it you at this point you're
309:27 - done with the assignment so you can make
309:29 - a submission
309:30 - if you have run jobian.commit
309:34 - you can take this link
309:35 - and make a submission on the assignment
309:37 - page
309:38 - or the other option for you is to simply
309:40 - run jobin dot submit python dsa
309:42 - assignment 2 and once you make a
309:44 - submission it will be evaluated
309:46 - automatically so let's click through
309:48 - here
309:49 - so it will be evaluated automatically
309:51 - and if you scroll down here you will see
309:54 - that you will get a grade and not just
309:56 - grade but you will also get comments for
309:58 - each question so if you see here there
310:01 - are question numbers here
310:03 - you can see that there's question five
310:05 - question four and so on so it seems like
310:07 - we since we implemented the get index
310:09 - function since we implemented the data
310:12 - list correctly question 1 was a pass
310:14 - let's see what question 1 was
310:16 - very quickly
310:18 - question 1 create a python list of size
310:19 - max table hash size question 2 was a
310:22 - pass so question 2 was the get index
310:25 - function
310:26 - question 3 was a pass so question 3 was
310:30 - complete the hash table implementation
310:33 - question 4 was a field get valid index
310:35 - we've not defined it yet and question 5
310:36 - led to an exception obviously because we
310:38 - have some code which will not execute
310:41 - because we have some blanks that need to
310:42 - be filled in
310:44 - so keep that
310:45 - use this as feedback you will know
310:47 - exactly what to fix and if you are stuck
310:51 - at any point
310:53 - you know what to do
310:54 - you can go to the forum
310:56 - so let's see the forum here
310:58 - so this is the forum
311:00 - sub category for assignment two you can
311:03 - create a new topic here if you want to
311:04 - have a longer discussion or you can
311:06 - simply go to the main topic assignment
311:08 - to hash tables and python dictionaries
311:11 - and you can ask a question here there
311:13 - are already a lot of discussions going
311:15 - on here
311:16 - so it's possible that your question may
311:18 - already have been answered
311:20 - and after this there are also some
311:21 - optional questions now here the optional
311:23 - question is for you to implement a
311:25 - python friendly interface for the hash
311:26 - table so instead of defining functions
311:28 - insert update and find you will define
311:31 - the functions get item
311:33 - set item
311:34 - and instead of list all you will define
311:36 - the function eter
311:38 - and also instead of using the hash
311:40 - function
311:42 - instead of using the custom hash
311:44 - function that we have defined
311:45 - you will define you will use a function
311:47 - that's inbuilt into python called hash
311:50 - and it takes any string or any object
311:52 - and it returns a number for it
311:55 - now since hash does not accept a list so
311:58 - you will have to take the remainder
312:01 - manually so in this case for example
312:03 - we've taken the remainder and gotten
312:04 - back the number three five six nine
312:07 - so you define a hash table here and once
312:09 - you have done that you will be able to
312:11 - use it just like a python dictionary you
312:13 - will be able to use it exactly like this
312:16 - you create a hash table and then to
312:17 - insert a value you use the indexing
312:20 - notation and insert the value to
312:22 - retrieve a value you use the indexing
312:23 - notation to get the value back and here
312:25 - you can compare it to the number to
312:27 - update a value you simply use the
312:29 - induction notation again
312:31 - and to get a list of values you simply
312:33 - call the list function or you can also
312:35 - use it within a for loop
312:36 - and we've also defined a
312:39 - function called wrapper and str what
312:42 - that will do is that will let python
312:44 - print a representation like this when
312:46 - you simply run a cell which just
312:48 - contains the name of this variable
312:50 - that's one
312:52 - and then there are a bunch of
312:53 - improvements that you can try to hash
312:55 - tables this is a great exercise if you
312:57 - want to improve your python programming
312:58 - skills and also understand how hash
313:01 - tables work if you can complete these
313:03 - four exercises there's pretty much no
313:06 - question related to hash tables that you
313:07 - cannot answer you will know everything
313:10 - about them and each of these exercises
313:12 - may take another
313:14 - 30 minutes to 45 minutes but it's
313:16 - completely worth the time maybe spend
313:19 - set aside a few hours on the weekend to
313:22 - work on these optional exercises now
313:24 - here's one how to track the size of the
313:26 - hash table instead of having to look
313:28 - through the entire table to get the
313:29 - number of key value pairs
313:31 - can you
313:33 - store the length somewhere so that you
313:35 - can
313:36 - track it in
313:37 - size order one here's one to implement
313:39 - deletion so to implement deletion you
313:41 - have a topic called technique called
313:43 - tombstones that are used
313:45 - so you can use this tombstone technique
313:47 - and implement it just a little more code
313:49 - can you implement dynamic resizing so
313:51 - instead of starting out with a hash
313:53 - table of a given size or requiring the
313:55 - user to specify a size
313:57 - can you or maybe start with a hash table
313:59 - of let's say 128 elements and then
314:02 - double it as soon as you reach 128
314:04 - elements or maybe even before to avoid
314:06 - collisions you may want to double it as
314:08 - soon as you reach 64 elements
314:10 - like 50 of the capacity
314:13 - so dynamic resizing is the technique
314:15 - that allows you to automatically grow
314:16 - and shrink the data list internally and
314:19 - then here's another technique for
314:22 - collision resolution this is called
314:23 - separate chaining so instead of going to
314:26 - the next index what you do is you
314:27 - maintain a linked list
314:29 - at each position
314:30 - and for all the key for all the keys you
314:33 - still use that position but you look
314:34 - through the linked list while looking
314:36 - for a key or you add a new element to
314:38 - the linked list
314:39 - for that position
314:41 - if you're adding a new key there
314:44 - so here's separate chaining explained in
314:46 - a youtube video
314:47 - you can look through that and try to
314:49 - explain it on your own
314:51 - and one final thing here is also the
314:53 - complexity analysis and here's where you
314:55 - talk about
314:56 - average case time complexity because on
314:59 - average if you have a good hashing
315:00 - function and you've implemented some
315:02 - improvements like dynamic resizing
315:05 - then the average time complexity for
315:07 - insert update find and delete
315:10 - are order one and list of course is
315:12 - still order n on the other hand the
315:14 - worst case time complexity because there
315:16 - can be collisions are still order in
315:19 - so here's something for you to ponder
315:21 - upon what is average case complexity and
315:24 - how does it differ from worst case
315:25 - complexity this is also something that
315:27 - is discussed in lesson three of the
315:29 - course where we talk about quicksort
315:32 - and you see why insert find and update
315:34 - have an average case complexity of order
315:36 - one and a worst case complexity of order
315:38 - n
315:38 - if not it is something that you can look
315:40 - up online
315:42 - try to see if you can search a tutorial
315:43 - and learn
315:45 - why this happens
315:46 - then how is the complexity of hash
315:48 - tables different from that of binary
315:50 - search trees we've discussed binary
315:52 - search trees in a lot of detail in
315:55 - lesson two
315:56 - so now the question becomes when should
315:58 - you prefer using hash tables and when
315:59 - should you prefer using binary search
316:01 - trees or vice versa so
316:04 - all these very interesting questions and
316:05 - you may get asked some of these
316:07 - questions and interviews as well
316:09 - it will help you especially to ponder
316:11 - upon some of these questions even if you
316:13 - do not end up
316:15 - solving all of these optional questions
316:17 - do look at the complexity analysis and
316:19 - think about it
316:22 - and there's a forum thread where you can
316:23 - discuss your
316:24 - thoughts so what you do next
316:27 - review the lecture video review the
316:30 - assignment walkthrough video and execute
316:32 - the jupyter notebook
316:35 - complete the assignment and attempt the
316:37 - optional questions as well
316:40 - and do participate in forum discussions
316:42 - so this was a walkthrough of assignment
316:44 - 2 of data structures and algorithms in
316:47 - python hello and welcome to data
316:48 - structures and algorithms in python this
316:51 - is an online certification course
316:53 - conducted by jovian and today we're on
316:55 - lesson three
316:57 - my name is akash i'm the ceo of jovian
317:00 - and i'm your instructor for the course
317:03 - if you follow along with this course and
317:05 - complete four weekly assignments and a
317:07 - course project
317:09 - you can earn a certificate of
317:11 - accomplishment for this course
317:16 - so let's get started
317:18 - the first thing we do is visit the
317:20 - course website
317:23 - pythondsa.com
317:26 - so when you visit pythondsa.com
317:28 - this will bring you to the course
317:30 - website here you can find all the
317:31 - information and material for the course
317:35 - you can check out lessons 1 and 2 and
317:37 - assignments 1 and 2
317:39 - both of which are still open for
317:41 - submission
317:42 - and let's open up lesson 3.
317:49 - so the topic today is sorting algorithms
317:51 - and divide and conquer
317:53 - and you can watch a video recording of
317:55 - the lesson here
317:56 - you can also catch a version in hindi
317:59 - now the code
318:01 - used for the lesson
318:02 - is provided here so let's open up this
318:05 - link sorting and divide and conquer this
318:08 - is where all the code is present
318:13 - so here we have it
318:14 - now we are looking at
318:16 - the tutorial and the code for this
318:18 - lesson if you scroll down you can see
318:20 - that there is some code here
318:26 - now to execute this code you have two
318:28 - options you can either execute this code
318:32 - online using free online resources which
318:34 - is what we recommend or you can download
318:37 - it and run it on your computer locally
318:41 - and the instructions for both of these
318:42 - are given here
318:44 - we are going to use the first one
318:46 - which is to click the run button at the
318:48 - top of this page and select run on
318:50 - binder
318:51 - so let us scroll up here and let us
318:53 - click the run button and then click run
318:55 - on binder
319:00 - now once you do this it will open up an
319:02 - interface like this
319:07 - and what you're looking at here is a
319:08 - jupiter notebook so a jupiter notebook
319:10 - is an interactive programming
319:12 - environment where you can write code
319:14 - look at the results and you can also
319:16 - write explanations
319:19 - and we've provided you with a
319:20 - cloud-based jupyter notebook setup so
319:22 - you don't have to install anything all
319:24 - the code that you execute here will be
319:26 - running on our cloud
319:28 - but you can also download it and run it
319:30 - on your own computer by following the
319:31 - instructions
319:33 - so the first thing we'll do is click on
319:35 - the kernel menu and click restart and
319:37 - clear output
319:38 - to remove any of the outputs from
319:40 - previous executions of the code
319:43 - so that we can execute the code and see
319:45 - the outputs fresh for ourselves
319:52 - now i'm also going to
319:54 - zoom in a little bit here
319:56 - so we can look at the code
320:00 - and let's get started
320:03 - so this is a coding focus and practical
320:05 - course
320:08 - and we're talking about different data
320:09 - structures and algorithms the topic
320:11 - today is sorting algorithms and divide
320:13 - and conquer algorithms in python
320:15 - so in every lecture we focus on a
320:18 - specific problem
320:19 - so in this notebook in this tutorial we
320:21 - will focus on this problem which you're
320:23 - looking at here
320:25 - so let's read the question
320:27 - you're working on a new feature on
320:28 - jovian called top notebooks of the week
320:31 - write a function to sort a list of
320:32 - notebooks in decreasing order of likes
320:35 - keep in mind that up to millions of
320:37 - notebooks can be created every week so
320:39 - your function needs to be as efficient
320:41 - as possible
320:42 - that is the key point here
320:45 - now this is a classical problem in
320:48 - computing
320:49 - the problem of sorting a list of objects
320:51 - and it comes up over and over in
320:52 - computer science and software
320:54 - development
320:55 - and it's important to understand common
320:57 - approaches for sorting
320:59 - how they work what the trade-offs are
321:01 - between them
321:02 - and how to use them
321:04 - so before we solve this problem we solve
321:06 - a simplified version of the problem it's
321:08 - quite simple to state write a program to
321:11 - sort a list of numbers
321:13 - and sorting usually refers to sorting in
321:16 - ascending order unless specified
321:18 - otherwise
321:19 - so that's a question
321:21 - for today write a program to sort a list
321:22 - of numbers and we'll expand upon it to
321:24 - answer this original question as well
321:27 - now this is the method that we've been
321:29 - following throughout the course and we
321:30 - will continue to follow a systematic
321:32 - strategy for solving programming
321:34 - problems step one state the problem
321:36 - clearly identify the input and output
321:39 - formats
321:40 - step two come up with some example
321:42 - inputs and outputs and try to cover all
321:44 - the edge cases and step three come up
321:47 - with a correct solution for the problem
321:48 - stated in plain english
321:50 - step four implement the solution and
321:52 - test it using example inputs so this is
321:55 - very important that you implement the
321:57 - simple solution so you just need a
321:58 - correct solution first not the efficient
322:01 - one and then you implement it and test
322:03 - it then you analyze its complexity
322:05 - identify inefficiencies and then you
322:07 - apply the right techniques to overcome
322:09 - the inefficiency and that is where the
322:11 - knowledge of the right data structures
322:12 - and algorithms comes into picture and
322:14 - once you apply the new technique then
322:16 - you once again state the
322:17 - solution implement it and analyze its
322:20 - complexity and repeat if necessary so
322:22 - this is the strategy we'll follow here
322:24 - today as well
322:25 - so step one state the problem clearly
322:28 - and identify input and output formats
322:30 - now the problem is stated clearly enough
322:32 - for us we need to write a function to
322:33 - sort a list of numbers in ascending or
322:36 - increasing order now here's the input
322:39 - the input is a single argument called
322:41 - nums
322:42 - and that is a list of numbers so for
322:45 - instance here's a list of numbers you
322:46 - can see that they're not in any specific
322:48 - order
322:49 - and then the output is the sorted
322:51 - version of the input so here is the same
322:54 - list of numbers in sorted order
322:56 - and based on these two we can now write
322:58 - a signature of our function so a
323:00 - function will be called sort or
323:02 - something else but it will accept just
323:04 - one input and right now we've not
323:06 - written any code here so we just put in
323:08 - pass
323:10 - now i'm running this code here using the
323:13 - shift plus enter shortcut but you can
323:15 - also use the run button on the toolbar
323:17 - so either run or shift plus enter
323:20 - and the great thing about jupyter
323:22 - notebooks is that you can add more code
323:24 - cells anywhere and test
323:27 - anything that you want for instance if
323:29 - you want to insert a code cell below
323:30 - just click the insert cell below menu
323:33 - option or click outside a cell on the
323:35 - left
323:36 - and press the b button
323:39 - and now you can write some code here
323:41 - and run it
323:44 - so please feel free to experiment with
323:46 - this notebook
323:48 - as you go along
323:50 - so step two come up with some example
323:52 - inputs and outputs now this is very
323:54 - important you need to think about all
323:55 - the different scenarios in which you may
323:57 - want to test out your function before
323:59 - you put it into production so that you
324:00 - catch errors early on and thinking about
324:03 - scenarios will help you identify what
324:05 - are the special cases you need to handle
324:07 - in code and it's easier to do it right
324:09 - now than while writing your code because
324:11 - that may lead to bugs
324:13 - so here are some scenarios that i was
324:15 - able to come up with and there may be
324:16 - more so you can continue and increase
324:19 - this list so the first one is some list
324:21 - of numbers in random order for some
324:25 - numbers in any random order and you can
324:27 - try
324:28 - slightly smaller lists and larger lists
324:30 - and so on
324:32 - second is a list that's already sorted
324:33 - we need to ensure that an already sorted
324:36 - list does not become unsorted
324:38 - a third is a list that's sorted in
324:40 - descending order we may want to check
324:42 - that
324:43 - see if
324:44 - we need to handle that case separately
324:46 - somehow
324:47 - then a list containing repeating
324:49 - elements this is something you may not
324:51 - have thought of but the question never
324:52 - said that the number should be unique so
324:54 - there could be repeating elements here
324:57 - an empty list
324:58 - interesting input the output is also an
325:00 - empty list or a list containing just one
325:03 - element or a list containing one element
325:06 - repeated many many times
325:08 - or even a really long list this is
325:10 - something that we may want to test
325:12 - because we want our algorithm to be
325:13 - efficient at the very end so a long list
325:16 - may help us just evaluate the efficiency
325:18 - empirically so these are the scenarios
325:20 - and what we now need to do is create
325:22 - some test cases for these scenarios so
325:24 - test cases
325:26 - involve creating an input and an output
325:28 - for instance here is an input
325:31 - num0
325:34 - and this could be
325:36 - the list 431 and here's the expected
325:39 - output
325:40 - so let me call it output 0
325:42 - and this would be 134
325:44 - now this is a good way to put create a
325:47 - test case and you can use it later for
325:49 - testing but we will put our tests into
325:51 - this particular structure we'll create a
325:54 - dictionary and creating a dictionary
325:56 - like this will help us automate the
325:58 - testing of all our test cases with a
326:00 - single helper function
326:02 - so what we're gonna do is for each test
326:04 - case create a dictionary and
326:07 - then
326:10 - it'll have two keys first key is called
326:13 - input and the second key is called
326:14 - output
326:16 - and in the inputs for each of the
326:18 - arguments that go into the function and
326:20 - remember there's just one argument here
326:21 - we will have one key so we will have the
326:23 - key nums and the key numbers will have
326:25 - the input value for the test case and
326:28 - the output will simply contain the
326:29 - output returned by the function
326:32 - so that's how we'll set up our test
326:33 - cases
326:35 - so does our test 0 a list of numbers in
326:37 - random order
326:42 - then we have test one this is also
326:44 - another list of numbers in random order
326:45 - you can see here no specific order
326:48 - now we have a list that's already sorted
326:50 - and of the output obviously is the same
326:53 - now for the random ordered list the
326:55 - output is the same numbers in sorted
326:57 - order
326:59 - now we have a list that's sorted in
327:01 - descending order
327:03 - and the output is the same list in
327:05 - increasing order
327:07 - then we have a list containing repeating
327:09 - elements
327:11 - you can see that the numbers 1
327:13 - 2 6 and 7 and even minus 12 repeat here
327:17 - here we have the empty list
327:19 - here we have a list containing just one
327:21 - element and here we have a list
327:22 - containing one element repeated many
327:24 - many times
327:26 - and then the final test case which was
327:28 - to create a really long list
327:30 - that's where we can start with a sorted
327:32 - list
327:33 - created using the range function and
327:35 - then shuffle it to create
327:37 - the input
327:38 - otherwise you may spend a lot of time
327:40 - just creating a list and then writing
327:42 - the sorted version of it that's too much
327:43 - work
327:44 - so always use a computer always use
327:46 - helper functions whenever you can even
327:48 - to create test cases
327:50 - so we'll use the range function now the
327:52 - range function
327:53 - takes either a single number or two
327:55 - numbers so you can have something like
327:57 - this range 2 to 10
327:58 - or just range 10
328:00 - and if you just look at it this way it
328:03 - just prints range 0 to 10. now if you
328:05 - actually want to see what's in it there
328:07 - are a couple of ways you can do list
328:09 - range 10 and that gets converted into a
328:11 - list
328:13 - or you can use it in a for loop
328:15 - so you can put for x in range 10
328:18 - print x so you can see that it contains
328:21 - the numbers zero to nine
328:23 - and that's important that the range does
328:25 - not include the end element of the range
328:28 - okay so just keep that in mind
328:30 - now what's the difference between a
328:32 - range in a list
328:35 - a list contains all the 10 numbers
328:38 - together at once but a range internally
328:40 - simply maintains a counter so when you
328:42 - use a range in a for loop it simply
328:44 - starts the counter from 0 and increments
328:47 - it up to the starts the counter from the
328:49 - starting value so if it's two to ten
328:50 - then it starts a counter from two and
328:52 - increases it up to the end value minus
328:55 - one so it does not use as much space as
328:57 - a list
328:58 - it simply uses a one single variable
329:01 - internally and that's why it's more
329:02 - efficient
329:04 - in any case right now we need lists so
329:06 - what we'll do is we will create
329:09 - a list of ten thousand numbers so zero
329:12 - to nine nine thousand nine hundred and
329:14 - ninety nine that is our in list and then
329:16 - our out list is also going to be 0 to
329:19 - 999 that's our outlist both of them are
329:22 - sorted now what we do is we shuffle the
329:24 - inner list so we import the random
329:26 - module from python and then we call
329:28 - random.shuffle
329:31 - and we call random dot shuffle on in
329:33 - list and that
329:35 - shuffles the
329:36 - the first list the n list
329:38 - so now we have that as the input
329:41 - nums and then the out list the sorted
329:43 - list is the output
329:45 - now once again we can even check
329:48 - that in list is actually shuffled maybe
329:49 - by looking at the first 10 elements you
329:52 - can see here that these are all shuffled
329:53 - numbers on the other hand if you check
329:55 - the out list
329:57 - you can see that these are all
330:00 - in order
330:03 - so those are our test cases and it's
330:04 - very important to create good test cases
330:06 - even in interviews
330:08 - before you start coding or before you
330:10 - even suggest a solution you should try
330:13 - and list out your test cases either
330:15 - verbally to an interviewer in a coding
330:17 - assessment you may create a block of
330:19 - comments at the top and start listing
330:20 - some test cases at the top or you can
330:23 - create proper test case dictionaries
330:25 - like this
330:26 - it takes a few minutes but it's totally
330:28 - worth it because you can then test your
330:30 - algorithms very easily
330:32 - and finally we'll take all our test
330:33 - cases test 0 to test 8 and put them into
330:36 - a single list called tests
330:39 - great so we've made some good progress
330:41 - so far
330:43 - next let's come up with a simple correct
330:45 - solution and stated in plain english
330:48 - and coming up with the correct solution
330:50 - is pretty straightforward
330:52 - we have a list of numbers
330:54 - so we iterate over the list
330:58 - let's grab a list of numbers so that we
331:00 - have something to look at
331:05 - here you go
331:10 - so we have a list of numbers so we
331:12 - iterate over the list of numbers
331:13 - starting from the left so we start from
331:14 - the very left
331:16 - and then we compare each number with the
331:18 - number that follows it so we compare 99
331:20 - with 10.
331:22 - and if 99 is greater than 10
331:25 - then we can say for sure that 99 should
331:28 - appear after 10 in the final sorted
331:31 - array and the sorted array
331:33 - by default it means the increasing order
331:35 - of numbers right so that's what we're
331:37 - solving first
331:38 - so
331:39 - what we can do is we can simply swap 99
331:41 - and 10 because we know that 10 should
331:43 - appear before 99 and 99 should appear
331:46 - after 10.
331:48 - now once we continue the swap we move to
331:49 - the next position
331:51 - and then we compare 99 with the next
331:53 - element nine
331:54 - that turns out to be
331:56 - higher as well
332:00 - so we swap it and then we keep going so
332:02 - we iterate over the list and for each
332:05 - element compare the number with the
332:06 - number that follows it and if the number
332:08 - is greater than the one that follows it
332:10 - swap the two elements
332:11 - now you do that once
332:13 - and that alone is probably not enough to
332:16 - compile the entire list because the
332:18 - entire sorted list because 99 in this
332:20 - way will end up at the end
332:22 - if you follow
332:24 - the process but the rest of the list is
332:27 - still not sorted
332:29 - so we repeat these steps one two three
332:31 - so once again we start from the left and
332:33 - then we start comparing ten with nine
332:35 - and then ten with eight and so on
332:38 - and keep swapping elements as we go
332:40 - forward
332:43 - now
332:45 - i have a claim here that you may you
332:47 - will need to repeat the steps one two
332:48 - three at most n minus one times to
332:51 - ensure that the array is sorted
332:53 - can you guess why and here's a hint
332:55 - after one iteration of the process the
332:58 - largest number in the list will reach
333:00 - the very end
333:01 - so that means that each time you're
333:04 - putting one of the largest numbers at
333:06 - the very end
333:07 - so you need around n steps so here's an
333:10 - animation showing the same thing here we
333:12 - compare six and five and then we switch
333:14 - them
333:16 - then we compare six and three
333:18 - and we switch them
333:22 - then we compare six and one
333:25 - and we switch them
333:29 - now we compare six and eight
333:32 - and we don't switch them because they're
333:34 - in order next we compare eight and seven
333:36 - and we switch them
333:39 - next we compare eight and two and we
333:42 - switch them
333:45 - and finally we can compare eight and
333:47 - four and we switch them
333:50 - and in this way the largest number eight
333:52 - has reached the very end so now we can
333:54 - froze freeze its position
333:56 - and we can start again from the
333:57 - beginning and you can see that this time
333:59 - the next number seven will end up here
334:02 - and then the next time the number six
334:03 - will end up here and then next time the
334:04 - number five will end up here and so on
334:07 - so in
334:08 - n
334:09 - repetitions of this process of
334:11 - comparison left to right
334:13 - we will have sorted the array
334:15 - and this approach is called bubble sort
334:18 - because it causes the smaller elements
334:20 - to bubble to the top or to the beginning
334:22 - you can see that the numbers 1 3 slowly
334:24 - bubble up to the top and it causes the
334:26 - larger numbers like 8 and 7 to sink to
334:29 - the bottom
334:30 - and you can watch this entire animation
334:32 - to get a full sense of how bubble sort
334:34 - works what will also really help is if
334:37 - you can take an example on paper and
334:39 - work it out on your own step by step
334:42 - especially with sorting algorithms this
334:44 - really helps
334:46 - okay so now we've come up with a correct
334:48 - solution
334:50 - let's implement it and let's test it
334:52 - using an example
334:54 - now the implementation itself is also
334:56 - pretty straightforward
334:58 - so we have the bubble sort function here
335:00 - def bubble sort it takes a list of
335:02 - numbers
335:04 - now
335:05 - we may not want to modify the list of
335:07 - numbers in place because then our test
335:09 - cases will not be reusable
335:12 - so just to avoid modifying our test
335:14 - inputs
335:16 - we are going to create a copy of the
335:18 - list to avoid changing it and the way to
335:20 - create a copy simply call the list
335:21 - function
335:23 - with the list as input so now we are set
335:25 - replacing nums with a copy of nums
335:29 - now depending on your particular use
335:32 - case this may not be necessary so this
335:34 - is something that you can actually check
335:35 - while you're in a coding assessment or
335:38 - in an interviewer or talking to an
335:40 - interviewer just check with them do do
335:42 - they want an edit to be sorted in place
335:45 - or do they want a new array to be
335:46 - created if they want if they're okay
335:48 - with sorting it in place then you
335:49 - probably don't need this but you may
335:51 - still just want to keep it in because
335:53 - otherwise you may end up modifying some
335:55 - of your test cases unintentionally
335:58 - and that may lead to problems
336:00 - it's always good to create a copy of the
336:02 - input
336:03 - rather than modifying it in place
336:05 - okay so then let's come to steps one two
336:08 - and three
336:09 - and then we'll see step four which is
336:11 - the outermost step really so we iterate
336:14 - over the array so we go from
336:16 - we take i
336:18 - and we check the range
336:20 - len
336:20 - nums minus 1 so the number of elements
336:23 - in the array is n
336:25 - and n can be obtained using len nums
336:27 - then we want to go from indices 0
336:30 - to n minus 2
336:32 - so the total number of indices is 0 to n
336:34 - minus 1 but if you go to the n minus 1
336:37 - or the last element there is no
336:39 - further element to compare it with okay
336:41 - so keep that in mind that you only want
336:44 - to run this iteration till your pointer
336:46 - comes to this point not till the last
336:48 - element and that is why
336:49 - we check if we put i in the range 0 to
336:53 - len nums minus 1.
336:55 - so the highest value that it can take is
336:57 - len nums minus 2.
337:01 - next we compare nums i with nums i plus
337:04 - 1. so we compare the number with the
337:05 - element that comes after it
337:07 - and if it is greater so that means these
337:10 - two are out of order
337:12 - so then we simply swap them so we set
337:15 - nums i
337:16 - comma nums i plus 1 equal to num i plus
337:19 - 1 comma num psi now this is a very
337:22 - interesting way of sorting in c or c
337:24 - plus plus or java you would have to
337:25 - write three or four steps to swap
337:27 - numbers but in python it's really simple
337:29 - first you say x y is let's say we're
337:32 - saying x comma y are two comma three so
337:34 - you can see they have the values two and
337:36 - three and then we simply write x y
337:38 - equals y x so what happens is the value
337:40 - of y gets placed into x and the value of
337:42 - x gets placed into y it's a single step
337:45 - for swapping two numbers there you go
337:49 - so we swap the two elements
337:51 - exactly what we're showing here swapping
337:54 - the two elements
337:56 - next
337:58 - we repeat this so now we're doing this
338:00 - from left
338:01 - to the
338:02 - penultimate element
338:04 - and in this way we have pushed the
338:06 - largest element to the end
338:08 - now we need to repeat this process n
338:10 - minus one times so that each time we are
338:12 - pushing one of the largest elements to
338:14 - the very end and in n minus one
338:17 - repetitions of these three steps we will
338:20 - end up with a sorted list
338:22 - and finally we return the sorted list
338:24 - and that's it
338:26 - so let's test it out with an example
338:30 - and by the way if some of this doesn't
338:32 - make sense so a simple way
338:34 - to debug it
338:37 - is to
338:38 - add print statements here so you can add
338:40 - a print statement and maybe just print
338:43 - this value so we've used underscore here
338:46 - because we don't actually use this value
338:48 - but let's say we wanted to use this
338:50 - value then we can print that this is
338:52 - iteration
338:54 - j
338:55 - and then inside it you can print that
338:57 - the value of i is i
339:00 - and you can also print the value of nums
339:02 - i and you can also print the value of
339:03 - nums
339:05 - i plus 1
339:07 - and at the very top you can also print
339:08 - nums now if you add all of these print
339:10 - statements
339:12 - and then execute your algorithm now you
339:15 - will be able to see exactly what is
339:17 - happening inside each iteration
339:19 - so that's a great way to debug your code
339:21 - if you're facing any issues and also
339:23 - understand what the code does
339:25 - but in any case we won't need these
339:29 - so i'm just going to comment these
339:35 - so let's test it out so we get from test
339:38 - 0 we get the
339:41 - nums
339:42 - as input and then we get the output
339:45 - and we can print the input and the
339:46 - expected output and then finally
339:48 - calculate the result by passing num0
339:50 - into bubble sort
339:52 - and then
339:53 - printing the actual output and finally
339:55 - whether the two match
339:59 - so you can see here now
340:01 - that the input was this unsorted list
340:04 - and then the expected output was the
340:05 - sorted version and that's what we got so
340:08 - in fact there was a perfect match
340:12 - and that's it so we've implemented our
340:14 - first sorting algorithm it was pretty
340:16 - straightforward a few lines of code
340:18 - as an exercise you can try to implement
340:20 - it once again from your memory
340:23 - just write it in plain english first and
340:25 - then try to implement it it's a good
340:27 - coding practice
340:31 - and we can also evaluate all the test
340:33 - cases that we have remember we created
340:35 - about nine test cases
340:37 - and to help you evaluate the test cases
340:40 - we've given you a helper function called
340:42 - evaluate test cases which is part of the
340:44 - jovian library so we installed the jobin
340:46 - library here pip install jovian and then
340:49 - from joven.python dsa so python dsa is
340:52 - the name of the course and that's also
340:53 - the module where we have helper
340:55 - functions for this course
340:56 - import evaluate test cases
340:58 - and evaluate test cases simply goes over
341:00 - the list of test cases that you have and
341:03 - it pulls out the inputs and passes them
341:05 - as arguments to the function provided
341:07 - here which is bubble sort and then gets
341:09 - the outputs and compares the outputs and
341:12 - also prints the information with like
341:14 - what was the input what was the expected
341:16 - output and the actual output and whether
341:17 - they match
341:18 - so
341:19 - let's check it out
341:21 - so you can see here this was test case 0
341:24 - and that work which we just tested out
341:27 - here's a larger list
341:29 - including some negative numbers this
341:30 - worked as well you can see the test
341:32 - result is passed
341:34 - then you have another list here
341:37 - this seems to work fine too this is
341:39 - already sorted
341:41 - here you have one which is sorted in
341:42 - decreasing order that works here you
341:45 - have one with repeating numbers that
341:46 - works too
341:48 - the empty list works the
341:50 - single element works
341:54 - and this works too this is the same
341:55 - element repeated over and over and
341:57 - finally here is our final test case this
341:59 - had 10 000 elements remember so you can
342:02 - see that this was the expected output
342:03 - and this was the actual output so we
342:05 - have successfully sorted 10 000 elements
342:08 - and that's really the power of
342:09 - programming that
342:11 - without having to look at any of the
342:13 - numbers we've just written four or five
342:14 - lines of code and we've sorted 10 000
342:17 - elements
342:18 - so all our test cases passed
342:20 - although do look here that it took about
342:24 - 15 seconds
342:26 - for the sorting of 10 000 elements
342:30 - now maybe that's not maybe that's not
342:31 - that bad but we we are looking at
342:34 - probably millions of notebooks every
342:36 - week at jovin so
342:38 - we want there to be a faster sorting
342:41 - algorithm
342:47 - okay so
342:49 - to before we improve the algorithm we
342:50 - need to understand the algorithms
342:52 - complexity
342:54 - and identify any inefficiencies now the
342:56 - core operation in bubble sort if you
342:58 - look at the code here once again
343:01 - is this operation of comparison so we're
343:03 - comparing a number with the next number
343:05 - and swapping now comparison almost
343:08 - always happens and swapping doesn't
343:10 - happen nearly as often
343:12 - so if you want to find the time
343:14 - complexity
343:15 - and we want an upper bound or the worst
343:17 - case time complexity we can assume that
343:20 - roughly every comparison also leads to a
343:23 - swap
343:24 - in the worst case so if we just count
343:26 - the number of comparisons
343:28 - as a function of the input size the size
343:31 - of the list that was given as an input
343:34 - that should give us an idea of the time
343:35 - complexity
343:36 - okay
343:43 - so here we can see that there are two
343:44 - loops and the length of each loop is n
343:47 - minus 1 and inside the
343:49 - inner loop there is a comparison so the
343:50 - total number of comparisons is n minus 1
343:53 - times n minus 1 which is n minus 1
343:55 - square or n square minus 2 n plus 1.
343:58 - now expressing this in the big o
344:00 - notation which is to get a rough idea of
344:03 - how the number of comparisons or the
344:06 - number of operations in the algorithm
344:08 - grows with time
344:09 - we can ignore the lower order terms like
344:11 - 2 n plus 1
344:14 - so we can now conclude that the time
344:15 - complexity of bubble sort
344:21 - is
344:22 - order of n square and this is also known
344:24 - as quadratic complexity
344:29 - so we can now verify that bubble sort
344:31 - requires order one
344:33 - additional space
344:35 - that this is an exercise for you but
344:37 - here's a quick hint you can see that we
344:39 - are not allocating any new lists we did
344:42 - create a copy of the list but we didn't
344:43 - have to
344:44 - so let's not count that but apart from
344:46 - that there is no additional space that
344:48 - was required here we're not allocating
344:50 - any new variables we are creating this
344:52 - range but remember i mentioned that a
344:54 - range simple simply contains a single
344:56 - variable inside it
344:58 - which it
344:59 - keeps incrementing for a for loop so we
345:02 - have these two ranges so maybe we have
345:03 - two variables assigned
345:05 - so it's
345:07 - constant irrespective of the size of the
345:08 - input and that's how bubble sort
345:10 - requires order one additional space
345:13 - now you may be asked about space
345:14 - complexity and this is where it's a
345:16 - slightly tricky thing because sometimes
345:19 - strictly speaking space complexity
345:22 - also includes the size of the input
345:25 - because to store n numbers or
345:29 - n elements you need
345:31 - n spaces in memory so the space
345:33 - complexity of bubble sort in that sense
345:35 - is order n
345:37 - and this is something you can check with
345:38 - the interviewer if they're asking you
345:40 - what is the space complexity and you can
345:42 - ask them if they just want to know what
345:43 - is the additional space required so the
345:45 - overall space complexity is order n
345:47 - because we need to store the actual
345:50 - input list somewhere
345:52 - but on the other hand the amount of
345:53 - additional space required is order one
345:55 - which is a constant factor
345:57 - independent of the size of the list
346:00 - so that's
346:02 - that's how bubble sort works
346:05 - now analyzing this order n square
346:07 - complexity
346:08 - and keeping in mind that
346:10 - a list of 10 000 numbers takes about 12
346:13 - seconds
346:14 - so if n is 10 000 and n square is
346:17 - multiplied by some constant is about 12
346:20 - seconds then
346:22 - if you had a list that was
346:25 - of hundred thousand elements so that
346:27 - would be 10 n whole square or 100 times
346:29 - the same amount of time
346:31 - that it would take to sort it so that
346:33 - means it would take about 20 minutes to
346:35 - sort 100 000 numbers
346:37 - which is i would say is a bit
346:39 - inefficient now
346:40 - and a list of a million numbers would
346:42 - take close to two days to be sorted in
346:44 - python now if you do it in c plus plus
346:46 - maybe it might be uh four or five times
346:48 - faster
346:49 - but again the moment you go from a
346:51 - million to ten million well that will
346:53 - actually end up taking a year or so
346:57 - and that's bad and that is why n square
346:59 - or quadratic complexity is
347:03 - something that we would like to do away
347:05 - with because it grows very fast as soon
347:08 - as you hit maybe
347:10 - a ten thousand or a hundred thousand
347:12 - elements then it starts taking longer
347:14 - than a few seconds or a few minutes or a
347:15 - few days and at that point you can no
347:17 - longer use that particular algorithm
347:22 - so we need to optimize bubble sort
347:25 - and the inefficiency in bubble sort
347:27 - comes from the fact that we are shifting
347:29 - elements by at most one position at a
347:31 - time so each time we go through the list
347:34 - we
347:35 - capture some information about the list
347:38 - but we are simply moving one element
347:40 - from left to right so to speak
347:42 - and each time we're just moving it one
347:44 - at a time by doing swaps
347:46 - rather it would be nice to just place
347:48 - elements
347:49 - directly
347:51 - maybe a few positions ahead
347:53 - and that's where we will look at some
347:55 - optimized algorithms
347:57 - now another common algorithm that is
348:00 - used is called insertion sort
348:02 - and this is here is the code for
348:04 - insertion sort so you can look through
348:06 - the code for insertion sort here
348:10 - and here is
348:11 - an example you can see how it works
348:13 - and we will not look into insertion sort
348:15 - in a lot of detail but roughly this is
348:18 - how you arrange cards in your hand which
348:20 - is by
348:21 - starting to move cards around so that
348:25 - at the
348:26 - maybe on the left edge you have
348:28 - sorted cards on the right edge you have
348:30 - the unsorted cards and you keep moving
348:32 - the new cards into sorted positions
348:35 - that's how it works so here's an
348:38 - exercise for you go through this
348:39 - function
348:41 - read the source code and then describe
348:43 - the algorithm in plain english now
348:44 - reading source code is an essential
348:46 - skill for software development this is
348:47 - something that you'll have to do in your
348:49 - work whether you're doing software
348:51 - development or data science maybe
348:52 - because there are no comments in the
348:54 - code there is no documentation or the
348:56 - person who has written the code is not
348:58 - available or has left the company or
349:00 - this is some open source library so in
349:03 - all these cases you will have to read
349:04 - and understand code so read it and then
349:06 - describe insertion sort the algorithm in
349:09 - plain english then look it up online and
349:10 - see if it matches what you've written
349:13 - and then second is to also determine the
349:16 - time and space complexity of insertion
349:18 - sort
349:18 - and see if it is any better than bubble
349:20 - sort
349:22 - and explain why or why not so these are
349:24 - a couple of exercises for you
349:27 - so that's bubble sort and insertion
349:29 - sword
349:30 - now before we continue
349:33 - i just want to recall you that this is a
349:35 - jupiter notebook running on an online
349:37 - platform hub.binder.joven.ml
349:40 - and since this is free it will shut down
349:42 - after some time so you want to capture
349:44 - snapshot of your work
349:47 - at regular intervals and that's where
349:48 - you can use the jovian library
349:50 - so you install the joven library using
349:52 - pip install jovian import jovian and
349:55 - then run jovian.commit now when you run
349:57 - jovi.com it captures a snapshot of this
350:00 - jupyter notebook and puts it on your
350:02 - jovian profile so now this will be your
350:05 - profile when you run juvenile commit
350:07 - and you will be able to resume your work
350:09 - by clicking the run button on this page
350:11 - anytime and this notebook will go to
350:13 - your profile so you can just click on
350:14 - your jovian profile or just click home
350:17 - here
350:18 - and if you check either the overview or
350:20 - the notebooks tab you should be able to
350:22 - find your
350:23 - notebook here
350:26 - like here you go okay coming back now
350:29 - we're at step 6 where we want to apply
350:31 - the right technique to overcome the
350:33 - inefficiency in the algorithm
350:36 - now to perform sorting more efficiently
350:38 - we will apply a strategy called divide
350:40 - and conquer and divide and conquer is a
350:43 - very common strategy
350:45 - used across the board for many different
350:47 - kinds of algorithms and it has this
350:50 - general steps that is applied in
350:52 - different different ways across
350:54 - different problems
350:55 - so step one is to divide the inputs into
350:58 - two roughly equal parts okay they don't
351:00 - have to be exactly equal but two roughly
351:02 - equal parts
351:03 - and the idea here is that
351:05 - those two
351:06 - parts can themselves be used as inputs
351:09 - as sub problems
351:11 - so then we use recursion so we
351:13 - recursively solve the problem
351:15 - individually for each of the two parts
351:19 - so here you have a problem you have
351:20 - created two sub problems out of it and
351:22 - then you call recursion so the recursive
351:24 - solution itself will use divide and
351:26 - conquer and then keep going and so on uh
351:28 - but once it gives you the solution
351:31 - combine the results to solve the problem
351:33 - for the init for the original inputs
351:36 - okay so you have now results of the sub
351:38 - problems and you combine them you get
351:39 - back the final result
351:42 - and then
351:43 - the only last thing you need to know is
351:45 - because you're going to
351:46 - keep calling this keep doing this
351:48 - division recursively so if you have an
351:50 - input of size 100 you will
351:52 - call the same function on inputs of size
351:55 - 50 and 50 then you will call the same
351:57 - function for each of those 50 you will
351:59 - call the same function on inputs of size
352:00 - 25 and 25 so each half and as you keep
352:03 - going you will eventually end up with
352:05 - small or indivisible inputs
352:07 - and that is where you can solve the
352:09 - problem directly and include terminating
352:12 - conditions so that's where the recursion
352:13 - stops
352:14 - okay so you include terminating
352:16 - conditions for small or indivisible
352:18 - inputs
352:20 - so that's divide and conquer you take
352:22 - the problem divided into two sub
352:23 - problems recursively solve the sub
352:25 - problems get the solutions of the sub
352:27 - problems and then combine them so you
352:29 - can also call it divide conquer combine
352:31 - in some sense
352:34 - and
352:35 - merge sort is the algorithm that is the
352:38 - classic application of divide and
352:40 - conquer to the sorting problem
352:42 - so let's take a look at merge sort
352:44 - by looking at an example visually so
352:46 - here we have a list
352:48 - that needs to be sorted in increasing
352:50 - order
352:52 - so remember
352:53 - step one
352:54 - divide the problem into two sub problems
352:57 - so here we have half the list a little
352:59 - more than half here we have another half
353:01 - so we have split it into four elements
353:02 - and three elements
353:04 - then
353:05 - we take we call recursively we call the
353:07 - same sorting problem
353:09 - the same algorithm on these two so we
353:11 - split 38 and 27 into one half and 43 and
353:15 - three into another here 982 becomes one
353:17 - half and 10 becomes the other
353:20 - again we can split 38 in 27
353:23 - we can split 43 and 3 980 to 10. so now
353:26 - we've ended up with single elements so
353:30 - with recursion we've ended up at this
353:31 - terminating condition we can no longer
353:33 - split the list so now we start combining
353:36 - the problems now if you're looking to
353:38 - sort a list with just one element 38
353:41 - well that list is already sorted so you
353:43 - can return that
353:44 - and 27 is already sorted the single
353:47 - element so you return that now we have
353:48 - these two sub lists and we need to
353:50 - combine them each has one element so we
353:52 - can simply compare these two elements
353:54 - and we can tell that 27 comes first and
353:56 - 38 comes
353:58 - second so that's how you combine these
354:00 - two results to get 2738 then similarly
354:03 - with 43 3 you combine them to get 343
354:06 - and you get 982 and 10.
354:09 - next you can combine these two results
354:11 - so this is where now the combination is
354:13 - important okay we need to look through
354:15 - and we can probably tell that 3 should
354:17 - come first
354:18 - and then 27 and then 38 and then 43 so
354:22 - we've combined them here
354:23 - and similarly here we've combined 9 10
354:25 - and 82 and then we take the final
354:28 - results these two final lists and then
354:30 - we combine them back to get the fully
354:32 - sorted list okay and we'll talk about
354:34 - this combination or what is called the
354:36 - merge operation in a lot more detail
354:40 - soon but this is roughly the idea here
354:42 - you keep splitting it into half and then
354:43 - you combine the halves
354:46 - so let's now state it in plain english
354:50 - so first the terminating condition if
354:52 - the input list is empty or contains just
354:55 - one element then it is already sorted
354:57 - return it
354:58 - if it is not divide the list of numbers
355:01 - into two roughly equal parts
355:03 - then
355:04 - sort each part recursively using the
355:06 - merge sort
355:08 - algorithm and
355:11 - by the power of recursion you will get
355:12 - back two sorted lists
355:15 - then merge the two sorted lists to get a
355:18 - single sorted list and this is the key
355:20 - operation here and this is why it's
355:21 - called a merge sort because we are
355:23 - always merging sorted list and making
355:25 - bigger and bigger sorted lists out of
355:27 - them
355:29 - and the merge operation is something
355:30 - that you may be asked to write in an
355:32 - interview or a coding challenge apart
355:34 - from the whole merge sort operation
355:35 - itself
355:37 - so this is something that you can try to
355:39 - explain yourself so try to think about
355:42 - how the merge operation might work and
355:43 - explain it in your own words
355:46 - here is some space for you
355:48 - but let's jump into the implementation
355:50 - of merge sort then
355:55 - now we will implement merge sort
355:57 - assuming that we already have a helper
355:59 - function called merge
356:02 - and this is a very useful trick
356:05 - where your program may need some
356:07 - complicated
356:08 - piece of logic or some logic which you
356:09 - have not figured out yet so all you do
356:12 - is assume that you already have the
356:13 - function
356:14 - and write
356:15 - uh use it first and then implement it
356:18 - later so here's a merge sort algorithm
356:23 - so now we have the merge sort algorithm
356:25 - and we have numbers here given as an
356:28 - input to merge sort now here's the
356:29 - terminating condition if the length of
356:31 - numbers is less than equal to one which
356:33 - means if the list is empty or has just
356:35 - one element return the numbers
356:38 - then
356:39 - if not then get the midpoint so return
356:42 - length of numbers divided by two and
356:45 - remember using the double slash here
356:47 - because
356:48 - a single slash would return a decimal
356:50 - and we cannot use a decimal as an index
356:53 - or a position in the list so that's why
356:54 - we're using the double slash here
356:56 - so we take the length of numbers divided
356:58 - by 2. so if the size of the list is 10
357:00 - so we get back
357:02 - five here
357:04 - then we split the list into two halves
357:05 - and here's some interesting syntax for
357:07 - you and let's look into what the syntax
357:09 - actually means so let's say you have a
357:11 - list
357:17 - so this is the list we have and let's
357:19 - say mid
357:21 - has the value
357:22 - well we can check it here one two three
357:24 - four five six so
357:26 - six elements by two mid has a value
357:28 - three
357:30 - now let's check
357:31 - x
357:32 - of mid what does that give us
357:35 - well that gives us one three five well
357:37 - actually
357:38 - x
357:39 - of colon mid means x of zero to mid
357:42 - and x of zero to mid means all the
357:44 - elements from position zero
357:47 - till before the position mid so that's
357:49 - very important once again it's like a
357:51 - range so you get the
357:54 - indices at position zero one and two not
357:56 - at position three okay so that gives us
357:58 - these three elements
358:00 - then let's check the other thing x
358:03 - of mid colon
358:05 - now what this gives you is this gives
358:08 - you
358:09 - the elements starting from the position
358:11 - mid
358:12 - all the way to the end so you can also
358:14 - write here minus 1 or we can also write
358:16 - here len of
358:18 - x minus 1
358:20 - but or we can just skip it and python
358:22 - will automatically interpret that you
358:23 - want all the elements starting from mid
358:25 - to the end
358:26 - that is twelve five and one so positions
358:28 - three four and five
358:30 - and hence to split the
358:32 - list all we need is
358:35 - to invoke this
358:37 - one three five and twelve 1251
358:40 - we get back two parts of the list
358:43 - so this is a nice thing about jupiter
358:44 - whenever you don't understand a line of
358:46 - code just create a cell above or below
358:48 - and try out a simple example so now we
358:51 - have
358:52 - the the left half
358:53 - num
358:54 - zero to mid and then the right half so
358:56 - numbs mid colon now here's where the
358:58 - magic happens we call the function
359:01 - recursively so we call the merge sort
359:02 - function itself
359:04 - so because we call merge sort on left
359:06 - and that gives us back a list a sorted
359:09 - list for the left half called left
359:10 - sorted and then we call merge sort
359:12 - function right and that will give us
359:14 - back a sorted list called write sorted
359:17 - and then we combine the results of the
359:19 - two halves by calling the merge
359:20 - operation so we now we are now saying
359:22 - that we want to merge left sorted and
359:24 - right sorted
359:26 - to get back the final sorted numbers and
359:28 - then we return the sorted numbers
359:31 - so that's merge sort
359:32 - so
359:34 - yeah it's almost seems like magic but
359:36 - it's pretty small pretty straightforward
359:39 - only about four or five lines of code if
359:41 - you combine some of these lines
359:44 - so then let's come to the merge
359:46 - operation
359:47 - because that seems to be the meat here
359:49 - right this is the only missing piece
359:51 - so to merge two sorted arrays
359:54 - what we can do is we can repeatedly
359:56 - compare the two least elements of each
359:58 - array and copy over the smaller one into
360:00 - a new array so here's what that process
360:02 - might look like let's say you have these
360:04 - two parts one four seven and zero two
360:05 - three and we want to get this sorted
360:08 - list and notice that these are both
360:10 - already sorted because these are the
360:12 - results of the recursive calls to merge
360:13 - sort so we keep a pointer on the left
360:16 - on each one so here we have the pointer
360:18 - at one here we have the pointer at zero
360:20 - we compare the two
360:22 - we take the smaller one and put it in
360:24 - the list how do we know we can put it
360:26 - because if this is smaller than this
360:29 - all these numbers are also greater than
360:31 - 0 and then since 1 is greater than 0 and
360:33 - all these numbers are greater than 0 are
360:35 - greater than 1 so that follows that all
360:37 - the other numbers to the right of 1 and
360:40 - to the right of 0 are greater than 0 and
360:42 - hence 0 should come in the first
360:44 - position
360:45 - so we put it there and advance the
360:47 - pointer now you can see here now we can
360:49 - compare one and two and this time one is
360:50 - smaller
360:52 - and you know that all the numbers here
360:53 - are greater than two so they're also
360:55 - greater than one and then all the
360:57 - numbers here are also greater than one
360:59 - hence we know that one is now the next
361:01 - largest number so we can now put in one
361:02 - and advance the pointer
361:04 - and keep going this time now you compare
361:06 - two and four so now you can put in two
361:08 - and advance the pointer now you put in
361:10 - three and then advance the pointer and
361:12 - at some point you will exhaust one of
361:14 - the lists and when you exhaust one of
361:16 - the list then you can stop comparing and
361:18 - you can simply copy over the remaining
361:19 - elements so we can now copy over four
361:21 - and seven and we've exhausted this list
361:23 - and we get back the sorted merged array
361:25 - zero one two three four seven so it's
361:27 - really simple it involves each step
361:29 - involves one comparison
361:31 - and incrementing one
361:32 - pointer so you're either incrementing
361:34 - this pointer or you're incrementing this
361:36 - pointer
361:37 - okay so let's now define the merge
361:40 - operation and you can see the benefit
361:41 - now of assuming that the function
361:43 - already existed now we do not have to
361:45 - worry about the actual
361:48 - sorting and recursion etc we simply have
361:50 - to worry about merging two sorted arrays
361:57 - so first we will create a list to store
361:59 - the results and we have nums 1 and num2
362:02 - the two left and right list that we are
362:03 - going to combine then we are going to
362:05 - set up two indices or two numbers for
362:07 - iteration the two pointers on the two
362:09 - lists
362:10 - and we set up each of them at position
362:12 - zero
362:14 - so each of them are currently at
362:16 - position zero here
362:17 - and we loop over the two lists so we say
362:19 - while i less than len of nums one and
362:22 - while j less than len of nums 2. so
362:25 - if you have four elements in the left
362:28 - list then i can go from zero to three
362:30 - all four positions and if you have five
362:32 - elements in the right list j can grow
362:34 - from zero to five zero to four all five
362:36 - positions
362:38 - then
362:40 - we check and and we remember we want to
362:42 - make sure that both of these indices are
362:44 - valid if any of those have reached the
362:46 - end then you want to skip and we can
362:48 - simply copy over the remaining list
362:50 - right so as you see here as soon as we
362:52 - reach this point there's no more
362:53 - comparisons to be made so we can exit
362:55 - the loop
362:57 - so now we check
362:58 - which one is smaller so if we if norm's
363:00 - one i so the left list current element
363:03 - is smaller than nums to j
363:05 - then we append to the merged list num1i
363:09 - as we did here and we increment i so
363:12 - this is exactly what we've done here so
363:14 - we put in
363:16 - well let's say here so we put in 1 here
363:19 - and we increment the left pointer
363:22 - on the other hand if that's not true
363:24 - we append the element from the right so
363:26 - nums 2j and we increment the right
363:29 - pointer so in each case in each while
363:31 - loop we are incrementing one of the
363:32 - pointers
363:34 - and then
363:36 - when the while loop ends one of the
363:38 - lists would have been exhausted that's
363:39 - when the while loop ends so we can get
363:41 - the remaining parts of both the lists so
363:43 - we can get numbs1 i colon will get the
363:45 - remaining elements from the first list
363:47 - the left list nouns 2 j colon will get
363:49 - the remaining elements from the right
363:50 - list but remember since one of them is
363:53 - exhausted so one of these two is going
363:55 - to be empty
363:56 - right now we we can check which one is
363:58 - empty and simply add the
364:00 - remaining one but here's a simpler
364:02 - solution we just add both of them to the
364:05 - merged array
364:06 - so we append both the lists at the end
364:09 - and this automatically takes care of the
364:11 - empty case if the left side becomes
364:13 - empty then this adds nothing to the
364:14 - merged array and this adds the remaining
364:16 - numbers from the right side if the right
364:18 - side becomes empty then this adds the
364:19 - remaining numbers from the left and left
364:21 - side and this adds nothing so that's a
364:23 - small trick
364:25 - so that's the merge operation again not
364:27 - very difficult
364:30 - if you have any questions is take this
364:32 - out into specific
364:34 - cells and try it out with examples and
364:37 - you should see it working
364:39 - let's try out the merge operation now so
364:40 - here we have two sorted lists you can
364:42 - see here
364:48 - and there you go you can see that this
364:50 - is now arranged
364:52 - all these numbers are now arranged in a
364:53 - sorted order
364:56 - so now we have the merge operation and
364:58 - we have the merge sort operation so we
364:59 - can now test out the merge sort function
365:02 - so we get the first set of inputs and
365:04 - outputs
365:06 - from test 0
365:10 - and you can see here
365:12 - that this is the input and this is the
365:14 - expected output and this was the actual
365:16 - output as well
365:20 - now let's test all the cases using the
365:22 - evaluate test cases function from jovian
365:24 - so here we're simply going to call
365:26 - evaluate test cases on the entire list
365:29 - of test cases and you can see all the
365:31 - test cases seem to be passing
365:36 - now if one of these test cases had
365:38 - failed what you should go do is you
365:40 - should go back and add some print
365:42 - statements inside your merge function or
365:43 - add some print statements inside your
365:45 - merge sort function the right places to
365:47 - add the print statements is right after
365:49 - the function definition
365:50 - right after
365:51 - in the body of the function it can be
365:53 - the first statement and then inside each
365:55 - loop so inside each loop whatever are
365:56 - the changing parameters you should print
365:58 - them inside the loop and then finally
366:00 - you can also print the return value of
366:01 - the function so in this way you can
366:03 - build a full picture of what the
366:06 - what your function is doing and that
366:08 - makes it much easier to solve issues
366:11 - so test cases and print functions make
366:14 - it easy to fix errors in code and don't
366:16 - worry if there are there are always
366:18 - errors in code
366:19 - what's important is you should be able
366:21 - to find a way to fix them easily and
366:23 - without
366:24 - test cases or without printing you may
366:26 - get stuck
366:27 - and you may just keep staring at the
366:29 - code and trying to figure out what
366:31 - exactly went wrong so please do that
366:35 - now one last thing i want you to notice
366:37 - is here the execution took only about 50
366:39 - milliseconds
366:42 - on the other hand remember bubble sort
366:44 - took about 15 seconds
366:48 - to sort ten thousand numbers so that's
366:51 - mer sword is much much faster right a
366:53 - millisecond is point zero zero zero one
366:55 - ten to the power minus three seconds so
366:57 - in a second you can probably sort
367:00 - two hundred of two hundred list of size
367:02 - ten 10000
367:04 - and that's what makes merge sort so much
367:05 - more powerful and because it is so much
367:07 - more efficient and as we analyze the
367:08 - complexity you will learn
367:11 - that merge sort is in fact more
367:14 - efficient in terms of the
367:16 - bigger notation as well so let's analyze
367:18 - the algorithms complexity and identify
367:22 - if there are any inefficiencies
367:24 - now analyzing recursive algorithms can
367:27 - get tricky and that's where it helps to
367:29 - track and follow the chain of recursive
367:31 - calls so what we'll do is we will add
367:32 - some print statements to our merge sort
367:34 - function
367:35 - and our merge function so we'll simply
367:37 - see what the merge sort function was
367:39 - invoked with
367:40 - okay so we'll add a print statement
367:42 - inside merge and we'll add a print
367:43 - statement inside merge sort both of them
367:45 - and we are also tracking something
367:47 - called a depth to
367:49 - track the chain or the depth of each
367:51 - recursive call
367:52 - and you'll see what i mean in just a
367:54 - second
367:55 - okay so this is what it looks like we
367:57 - called merge sort on this big list
368:00 - of elements unsorted and that merge sort
368:03 - internally led to two calls of merge
368:04 - sort so you can see this one here and
368:06 - this one here so you have two calls to
368:08 - merge sort one with the left half of the
368:10 - list and one with the right half of the
368:12 - list and they're unequal
368:15 - and these two merge sorts finally
368:19 - returned
368:20 - merged lists and we finally called a
368:22 - merge operation on the two of them you
368:23 - can see that this is the merge operation
368:25 - the final merge operation called here
368:29 - on the two merge sort lists and this
368:32 - merge operation is working with these
368:33 - two sorted lists okay
368:35 - so we can see that each merge sort
368:37 - invokes the
368:39 - itself invokes merge sort twice but this
368:41 - time with an area of half the size you
368:42 - can see merge sort was invoked with
368:44 - arrays of or lists of half the size
368:48 - and it also invokes the merge function
368:50 - once to merge the two resulting arrays
368:52 - the two sorted arrays
368:54 - now the two calls to merge or if you
368:56 - observe closely they themselves make two
368:58 - more calls to merge sort
369:00 - and one more call to merge
369:02 - and then those internal calls make two
369:04 - more calls to merge sort and one more
369:06 - call to merge and so on
369:08 - till we end up with single elements at
369:10 - which point merge sort simply returns
369:12 - that single element
369:17 - so
369:19 - the merge sort algorithm ultimately
369:21 - points down to a series of merge
369:23 - operations you can see here that each
369:24 - merge sort all it's doing is calling
369:26 - merge sort internally and then calling a
369:28 - merge operation so ultimately what we
369:30 - are doing is we are first merging 5 and
369:33 - -12
369:34 - and then we are merging 2 and 6
369:37 - and then we're merging minus 12 5 and 2
369:39 - comma 6
369:40 - and then we're merging 123 and we're
369:42 - merging
369:44 - 7 minus 12 and then we're merging
369:48 - 7 minus 12 7 and finally we're merging
369:51 - 123-1277 and then finally we are merging
369:54 - the big list right so it's ultimately
369:55 - just a whole bunch of merge operations
369:58 - and if you look inside the
370:00 - merge operation this is where a
370:02 - comparison is happening and this is
370:04 - where this append step is happening so
370:07 - we are comparing and appending so those
370:10 - are the two key operations here and with
370:12 - every comparison there is append so if
370:13 - we simply count the comparisons once
370:15 - again
370:16 - that's happening
370:18 - that should be enough to get the time
370:20 - complexity
370:21 - and what is the number of comparisons
370:22 - that's happening
370:23 - well that's straightforward too if you
370:26 - have two lists nums one and nums two
370:28 - each and the total length of the two
370:30 - list is n
370:31 - so because the size the number of
370:33 - iterations is equal to
370:36 - in the in the worst case it would be
370:37 - equal to the lengths of the two lists
370:40 - combined so you may have to first maybe
370:42 - increment i by one then increment j by
370:44 - one then once again increment i by one
370:46 - and j by one so the total number of
370:49 - iterations here is len of numbers 1 plus
370:51 - len of norms 2
370:53 - right but remember the merge was called
370:55 - if merge sort was called with a list of
370:57 - size n then merge was called with a list
371:00 - of size n by two and n by two roughly so
371:02 - the total list the total length of nums
371:05 - one plus nums two is actually the
371:07 - overall length n
371:09 - so that's the real trick here that merge
371:12 - the merge operation is an order n
371:14 - operation where n is the number of
371:16 - elements the total number of elements
371:17 - okay so
371:19 - this merge operation
371:22 - takes four plus five nine comparisons
371:25 - and this merge operation
371:27 - takes five comparisons and this merge
371:29 - operation takes three comparisons and so
371:31 - on
371:33 - now this way now if we visualize a
371:35 - problem now as a tree where we're
371:37 - calling merge sort with nl with n
371:39 - elements and that ends up calling merge
371:40 - sort with n by two elements and that
371:42 - ends up calling merge sort with n by
371:43 - four elements all the way down and then
371:45 - we start merging so here when we get to
371:49 - individual elements we are calling
371:51 - merge with literally single elements and
371:53 - as we come up here we are calling
371:56 - merge at this point we are calling merge
371:59 - with elements of size n by eight and n
372:01 - by eight
372:02 - but we are calling merge
372:03 - eight times
372:05 - so
372:06 - now each of these sub problems makes a
372:08 - call to merge
372:09 - and each of these sub problems has the
372:11 - list size n by eight
372:13 - so you have eight calls to merge of size
372:15 - n by eight so the total number of
372:17 - comparisons done is n
372:20 - and at every stage you can check this at
372:22 - the top level
372:23 - uh you are calling merge with n total
372:25 - elements so the total number of
372:27 - comparisons is n
372:28 - at the second level you're calling merge
372:30 - here once with n by two elements and
372:32 - you're calling merge here once with n by
372:34 - two elements so the total number of
372:35 - comparisons is two times n by two that's
372:37 - n
372:38 - and here you're calling merge with n by
372:40 - four elements four times so that's n
372:48 - so if the height of the tree is h
372:50 - then the total number of comparisons is
372:52 - n times h right so
372:55 - on each level you'd require n
372:57 - comparisons for the merge and you call
372:59 - merges at every level for each of these
373:01 - sub problems so the height of the tree
373:03 - is so the total number of comparisons is
373:05 - n times h
373:09 - now how do we get the height of the tree
373:12 - if the height of the tree is h and you
373:14 - can see here that as we go down
373:16 - this is level zero and it has
373:19 - one element this is level one and it has
373:21 - two elements this is level two and it
373:23 - has
373:24 - four sub problems and this is level
373:26 - three and it has eight sub problems so
373:28 - level k has two to the power k sub
373:30 - problems so if you keep going down this
373:32 - is level h minus one
373:34 - so level h minus one should have two to
373:36 - the h minus one sub problems but
373:39 - remember at the last level we simply we
373:41 - simply have sub problems or merge merge
373:44 - calls with single elements so that means
373:46 - we have a total of
373:48 - n elements here or n leaf nodes here
373:52 - so it follows that 2 to the power of h
373:54 - minus 1 is n
373:56 - okay so i'll i'll let you think about
373:59 - that in reason with that now this is
374:00 - something that you may have to work out
374:02 - on pen and paper to get correctly that
374:06 - if the height of the tree is h then 2 to
374:08 - the power h minus 1 is equal to n
374:10 - because at the bottom most layer you
374:12 - have n leaves in the tree
374:15 - so it follows that h is log n plus one
374:19 - so since we said that there are n times
374:21 - h comparisons and h is log n plus one
374:24 - so it follows that the complexity of
374:25 - merge sort is n log n
374:31 - and that's a big improvement from n
374:32 - square it may not seem like much but it
374:35 - is so n square for ten thousand is ten
374:37 - thousand times ten thousand
374:39 - but n log n for ten thousand is ten
374:42 - thousand times
374:45 - 12 or 13
374:47 - log to the base two
374:49 - so that's about
374:51 - a few hundred times faster
374:53 - now even for an array of a million
374:55 - elements it will only take a few seconds
374:57 - to be sorted and you can verify this by
374:59 - actually creating a list of a million
375:01 - elements okay so the complexity of merge
375:03 - sort is n log n and you get it by
375:05 - drawing this sub problem tree and
375:07 - realizing that there are you get a sub
375:09 - problem tree of height log n or log n
375:12 - plus one and at each step you perform a
375:15 - merge operation
375:18 - or multiple merge operations totaling to
375:20 - n comparisons so so n times log n is the
375:22 - complexity of merge sort
375:25 - now here's also
375:27 - discussion about space complexity and
375:29 - this is something that i believe is an
375:31 - exercise for you so do read through this
375:33 - and see if you can reason why the space
375:36 - complexity of merge sort is
375:39 - order n
375:40 - okay so time complexity is order n log n
375:43 - and the space complexity is order n
375:46 - but here's a hint why it's order n you
375:48 - can see that inside the merge operation
375:50 - we are creating a new list and then we
375:52 - are copying over elements from each of
375:54 - the two lists into the new lists
375:57 - so we are allocating a new list inside
375:59 - merge
376:01 - and now it's so now that's no longer
376:03 - constant that list will have the same
376:05 - size as the size of the problem itself
376:08 - and hence roughly that's why the space
376:10 - complexity is order n
376:12 - okay
376:14 - so with that we conclude our discussion
376:16 - of merge sort it's a divide and conquer
376:18 - algorithm you split the list into half
376:20 - recursively sort both of them then merge
376:22 - the two sorted lists and the initial
376:25 - condition is one or zero elements
376:27 - now there are several extensions and
376:29 - variations
376:31 - of merge sort
376:32 - called the k way merge sort where we
376:34 - split not into two parts but into k
376:36 - parts then we have the counting
376:38 - inversions problem
376:39 - where
376:41 - we modify merge sort a little bit to
376:43 - also find some other info information
376:45 - about the list
376:46 - and finally we have
376:48 - hybrid algorithms which combine merge
376:50 - sort and insertion sort so what they do
376:52 - is for smaller lists they use insertion
376:54 - sort because that's more efficient and
376:56 - then for bigger lists they use merge
376:58 - sort so
376:59 - as they're splitting the list when you
377:01 - get to a small
377:02 - enough problem let's say 10 or less
377:04 - elements they use insertion sort
377:08 - and that brings us
377:10 - to our next question
377:14 - where we
377:15 - make one level of optimization and then
377:17 - we stop
377:19 - but here we will go one step further
377:20 - what we do is we will apply
377:22 - an another technique to overcome the
377:24 - inefficiency in merge sort now
377:27 - the time complexity is pretty good you
377:29 - can actually sort millions or even tens
377:31 - of millions of elements with merge sort
377:33 - quite reliably
377:35 - but it's a space complexity that
377:37 - causes a problem now because merge sort
377:39 - requires allocating additional space and
377:42 - that is additional space is as large as
377:44 - the input itself
377:45 - that makes it somewhat slow in practice
377:47 - because memory allocation is more
377:49 - expensive than
377:51 - computations so doing a comparison is
377:53 - very easy you just tell the cpu to
377:55 - compare two things in the memory or
377:57 - swapping them is also easy because
377:59 - you're still working with memory that
378:01 - you already have but when you have to
378:02 - allocate new memory you often have to
378:04 - then request the operating system
378:07 - uh to allocate the new memory and then
378:08 - you have to get its address and do a
378:10 - whole bunch of operations so it's
378:12 - let's say an order of magnitude more
378:16 - expensive than simply doing some
378:17 - computations so you should try and avoid
378:19 - memory allocations as far as possible
378:21 - now one or two variables is fine but if
378:23 - you're dealing with a million elements
378:25 - so you're probably going to need maybe a
378:27 - few mb of additional space and that is
378:30 - what may slow down
378:33 - your
378:34 - algorithm a little bit it would still be
378:36 - n log n but the constant factor now the
378:39 - cost of each operation will be higher
378:41 - because it involves an allocation
378:44 - now to overcome the inefficiencies the
378:46 - space efficiency of merge sort we will
378:48 - study another divide and conquer based
378:50 - algorithm
378:52 - sorting algorithm and this is called
378:53 - quick sort
378:54 - and quick sort
378:58 - the array in place which means it does
379:00 - not create a copy of the array
379:02 - internally for sorting inside each
379:04 - operation inside each combination
379:05 - operation so let's see how it works it's
379:07 - a pretty interesting a pretty smart
379:08 - trick
379:10 - so here's how it works if the list is
379:12 - empty or has just one element return it
379:14 - it's already sorted straight forward
379:17 - then pick a random element if not
379:19 - pick a random element from the list
379:22 - now this element is called a pivot now
379:26 - there are many strategies for picking a
379:27 - pivot one is to pick a random element
379:29 - one is to maybe pick the first element
379:31 - the last element
379:33 - what we'll do is we will pick the last
379:34 - element but you can
379:37 - easily
379:38 - augment our implementation to pick a
379:40 - random element
379:43 - and then
379:44 - reorder the list and this is the key
379:46 - operation here reorder the list so that
379:48 - all the elements with values less than
379:49 - or equal to the pivot come before the
379:52 - pivot element while all the elements
379:55 - with values greater than the pivot come
379:57 - after the pivot element
379:59 - and this element is called partitioning
380:01 - you're partitioning the array around the
380:03 - pivot
380:04 - so here's an example
380:06 - you
380:07 - let's say we take three as the pivot
380:09 - element the final element now what we
380:10 - want to do is we want to reorder the
380:12 - elements and the way we reorder is by
380:14 - doing swapping and comparison in
380:16 - whatever way we can and that's what we
380:18 - will really focus on the partitioning
380:20 - algorithm
380:23 - and you reorder it in such a way that
380:25 - all the numbers to the left of the pivot
380:27 - are smaller than it and all the numbers
380:30 - to the right of the pivot are larger
380:31 - than it
380:33 - now here's the key observation here once
380:35 - you do that
380:37 - you can tell that
380:39 - all these
380:41 - all these numbers can now be sorted
380:42 - independently and none of the numbers
380:44 - from here will move to the right of
380:46 - pivot and similarly all these numbers
380:48 - can also be sorted independently and
380:50 - none of the numbers here will move to
380:51 - the left of the pivot so the pivot is in
380:53 - the correct position in the final sorted
380:55 - array so it's now in its correct final
380:57 - position
380:58 - and you can simply call quick sort on
381:01 - this half or less than half this portion
381:03 - of the array and this portion of the
381:05 - array
381:06 - and there's no real combination required
381:08 - anymore right so because we're doing it
381:10 - all in place we simply call quick sort
381:12 - on each
381:13 - side of the array
381:15 - and once this gets sorted and this gets
381:17 - sorted recursively
381:19 - then you will have end up with the
381:20 - entire sorted list right and that's what
381:22 - that's how we then continue doing the
381:24 - process recursively now on the left half
381:26 - you once again pick a pivot and then you
381:28 - arrange the elements around the pivot on
381:29 - the right half you once again pick a
381:31 - pivot and arrange the elements around
381:32 - the pivot
381:33 - and so on and so on okay
381:36 - so as i said the key observation here is
381:38 - that after the partition the pivot
381:39 - element is at its right place in the
381:41 - sorted array the two parts of the array
381:43 - can be sorted independently in place
381:45 - now maybe once again take pen and paper
381:48 - and try to work it out yourself again
381:51 - all of this makes a lot more sense when
381:53 - you
381:54 - actually put it down and solve a real
381:56 - problem as a real
381:58 - example so here's an implementation of
382:01 - quick sort and
382:03 - once again we will assume that we
382:04 - already have a helper function called
382:06 - partition which can pick a pivot
382:08 - partition the array and return the
382:10 - position of the pivot element
382:12 - for the next quick sort step okay
382:14 - so this entire process going from here
382:16 - to here this is where we'll assume that
382:18 - we have a function and write the quick
382:20 - sort algorithm and then implement the
382:22 - partition function
382:24 - so here's what quick sort might look
382:25 - like now quicksort takes a bunch of
382:28 - numbers
382:29 - and apart from the numbers it also takes
382:31 - a start index and an end index now why
382:33 - are we doing this
382:35 - remember we want to avoid creating
382:36 - copies of the list that's the whole pro
382:38 - that's the whole thinking here the line
382:40 - of thinking so
382:43 - we will call quick sort not with a sub
382:45 - list which is
382:47 - which is a copy of a portion but we will
382:49 - call quick sort simply by changing the
382:52 - by passing the same original list but by
382:55 - changing the start and end index okay
382:59 - now there is some code here if end is
383:01 - none then we are sent setting end to the
383:04 - length of the list minus one
383:06 - and here's one more thing that we're
383:08 - doing so
383:10 - the final invocation to quicksort that
383:12 - we'll make will be something like this
383:13 - we may call quicksort
383:16 - let's say there are a few numbers here
383:23 - so we may call quick sort
383:25 - on a list something like this and in
383:27 - this case automatically start will have
383:29 - the value 0 and end will have the value
383:30 - none
383:31 - now remember the quick sort is going to
383:33 - sort the array in place but we also said
383:35 - that we don't want to modify our test
383:37 - cases so here's one assumption we are
383:40 - making that if end is none which means
383:42 - if quicksort is called just with the
383:44 - just with the list then we'll create a
383:46 - copy of the list right so we'll just
383:47 - create one copy at the very beginning
383:49 - right when the list is passed for the
383:52 - first time and then we will not create
383:54 - any more copies and you can even skip
383:55 - this line entirely
383:58 - but the only trouble is that we'll start
383:59 - changing our test case input so that's
384:01 - why let's keep it and let's keep a copy
384:04 - but this is only done at the very top
384:07 - level right so only when we start we
384:09 - create a copy so that we're not
384:10 - modifying the input list but never again
384:14 - so that's what we're doing here creating
384:16 - a copy if uh quick sort what was called
384:18 - with the list and setting end to len
384:20 - nums minus 1 which is the final valid
384:23 - index in the list anyway putting this
384:25 - aside this is the real
384:27 - condition here
384:29 - so if start is less than end which means
384:32 - let's say here you have start and here
384:34 - you have end now if start is less than
384:36 - end that means you have two or more
384:38 - elements right if start and end are
384:40 - equal that means you have just one
384:41 - element
384:42 - and if start is greater than n that
384:44 - means you have zero elements really so
384:47 - if start is less than n that means if
384:49 - you have at least two elements
384:50 - then we call the partition function
384:53 - we call the partition function on nums
384:55 - and we say that we want to partition the
384:57 - region start to end so let's say this is
384:59 - the region start to end
385:01 - we want to partition it
385:03 - so we want to pick a pivot and then
385:06 - partition it in such a way that
385:08 - elements to the left of the pivot are
385:10 - smaller than it and elements to the
385:11 - right of the pivot are larger than it
385:13 - for example if you want 4 to be the
385:15 - partition element 4 to be the pivot
385:17 - element then we will partition the array
385:19 - as 3 comma 4 comma 5 comma 23
385:24 - so that 3 is smaller than 4 and 523 are
385:26 - bigger than 4 and we will return the
385:28 - position of the pivot element
385:30 - okay
385:31 - so now you partition the array and
385:33 - return the position of the pivot element
385:36 - so this is the position we get back and
385:38 - then we can call quick sort on this
385:39 - region and on this region
385:41 - so we can now call quick sort on start
385:45 - to pivot minus one and we can call quick
385:47 - sort on pivot plus one
385:49 - to end okay so now we are passing
385:52 - actually explicitly passing in values
385:54 - for start and end so this will not kick
385:57 - in the next time so no more copies of
385:58 - the list will be created so all the
386:00 - recursive calls will keep modifying in
386:02 - place so all the even the partition call
386:05 - will modify in place and we'll see how
386:06 - partition works in just a moment so
386:08 - partition gets the
386:10 - slice of the original list
386:13 - and it returns the position of the pivot
386:15 - element then we call quick sort on the
386:17 - left slice which is before the partition
386:20 - the element smaller than the partition
386:21 - and then we call quick sort on the right
386:23 - slice which
386:24 - is elements that come after the
386:27 - partition
386:29 - okay now here is how the partition
386:31 - operation works
386:34 - it's pretty straightforward too not that
386:36 - difficult
386:38 - so
386:38 - what we'll do is we will pick the final
386:40 - element as the pivot element but if you
386:42 - don't want to pick the final element you
386:44 - want to pick a randomized element well
386:45 - just pick a random position and move
386:48 - that element to the final position and
386:50 - that's as good as picking the final
386:52 - element now so
386:55 - random pivot simply involves picking an
386:56 - element moving it to the final position
386:58 - but assuming the pivot is in the final
387:00 - position
387:01 - we then keep two pointers left and right
387:04 - now remember we want to
387:06 - create we want to push all the numbers
387:09 - smaller than the pivot to the left
387:12 - and we want to push all the numbers
387:14 - larger than the pivot to the right
387:16 - okay and what we'll do ultimately is we
387:18 - will arrange them in such a way that
387:20 - some of these are smaller than the pivot
387:22 - and some of these are larger than the
387:23 - pivot and then we'll move the pivot
387:24 - between them
387:26 - so we'll see how to do that so you have
387:28 - the left pointer and the right pointer
387:30 - now here's what we do inside partition
387:34 - while these two pointers are far away
387:37 - from each other
387:38 - first we check if the element at the
387:41 - left pointer is smaller than the pivot
387:43 - well if the element at the left pointer
387:45 - is smaller than the pivot which it is
387:46 - you simply advance the left pointer
387:48 - forward so this goes to 5
387:52 - and then we
387:54 - go back to the next loop
387:56 - now this time once again we check if the
387:58 - element that the left pointer points to
388:00 - is smaller than the pivot
388:02 - 5 is not smaller than 3 5 is greater
388:04 - than 3. so if that is the case then we
388:06 - check
388:08 - if the right pointer
388:10 - is greater than the pivot
388:12 - now if the right pointer is greater than
388:13 - the pivot that means this number is in
388:15 - its right position
388:17 - it's greater than the pivot so we move
388:19 - the right pointer back
388:21 - one space
388:22 - okay
388:23 - so that's the operation we just did now
388:25 - once again we check is the left pointer
388:27 - smaller than the pivot no it's not
388:30 - is the right pointer greater than a
388:32 - pivot no it's not so that means these
388:35 - two numbers are out of place right we
388:37 - ideally would want this to be smaller
388:39 - than the pivot and this to be larger
388:40 - than the pivot so we swap these two
388:42 - elements so now zero comes here and phi
388:44 - comes here
388:45 - now once again we can check is 0
388:48 - the left pointer smaller than the pivot
388:50 - yes so move the left pointer forward
388:52 - then we is the left pointer smaller than
388:54 - the pivot no 6 is now greater than 3 so
388:57 - we check is the right pointer larger
388:59 - than the pivot
389:00 - yes so we move the right pointer forward
389:02 - because five is still in its correct
389:04 - position it's you know on the on the
389:05 - right edge and
389:07 - everything is greater than three so now
389:09 - once again we end up in this position
389:10 - that the left element is smaller than
389:12 - the is larger than the pivot
389:14 - so we check the right element the right
389:16 - element is smaller than the pivot
389:18 - we want it to be larger so we
389:21 - swap these two because these two are
389:23 - once again out of order and now you can
389:25 - see that one zero two are all smaller
389:27 - than the pivot and six five eleven are
389:30 - all larger than the pivot so we do one
389:32 - final check is two
389:35 - smaller than the pivot yes so we advance
389:37 - the left pointer
389:38 - and now both of the pointers are at the
389:40 - same position so now we can tell at this
389:43 - point that
389:46 - here
389:47 - or from this point position onwards all
389:50 - of these numbers are larger than the
389:52 - pivot so we simply simply swap this
389:54 - element with the pivot so there you go
389:57 - so you end up with one zero two three
389:59 - five eleven and six
390:01 - okay so that's the partition operation
390:03 - so again to understand it yourself
390:06 - do it on pen and paper write out write
390:08 - down write out this array
390:11 - create the pivot
390:12 - create the left pointer right pointer
390:14 - and keep creating copies of the array
390:16 - for each step of the loop okay and
390:18 - that's how you understand these things
390:19 - it's not that difficult it's just
390:22 - it involves two pointers so it's a
390:24 - little tricky
390:26 - now this is the code for partition
390:28 - and i will let you follow this code
390:31 - we'll go over this briefly but at by
390:33 - this point since we are halfway into the
390:36 - course now you should be able to read
390:38 - the code and then there are also
390:40 - comments here and understand what we
390:42 - have just discussed in plain english
390:44 - understand that in terms of code okay so
390:47 - one exercise for you is to explain this
390:50 - visual approach in plain english
390:52 - step by step and then the second
390:54 - exercise for you is to read the code
390:57 - and understand it
390:58 - or maybe even try to write it from
391:00 - memory so just take the english
391:02 - description and try to write the
391:03 - partition function from your memory not
391:05 - memorize the code itself but
391:08 - convert the english
391:09 - text into code
391:11 - okay
391:12 - so once again here you know we have the
391:14 - nums the numbers that need to be
391:16 - partitioned the start and the end
391:18 - and if end is none we simply set end to
391:21 - the last index which is len nums minus
391:22 - one
391:23 - then we initialize the start and end
391:25 - pointers so we initialize the left and
391:27 - right pointers
391:29 - remember we want to use the end element
391:31 - so this is the end element so we want to
391:33 - use the end element as the pivot so the
391:35 - left point
391:36 - the left pointer is start and the right
391:38 - pointer is n minus 1
391:39 - that's what we that's what we've set
391:41 - here and then white while the right
391:43 - pointer is greater than the left pointer
391:45 - we increment the left pointer if the
391:47 - number at the left pointer is less or
391:50 - equal to the pivot we decrement
391:52 - otherwise
391:53 - we decrement the right pointer if the
391:55 - number
391:56 - on the right pointer is greater than the
391:58 - pivot otherwise the two of them are out
392:00 - of place and they can be swapped so we
392:02 - swap them here
392:04 - and finally we place the pivot
392:06 - in place between the two parts and
392:08 - that's it
392:09 - that's exactly what's happening here
392:11 - so let's see here let's see this
392:13 - partition we are taking this list and we
392:15 - are calling partition on it
392:17 - and 3 is the number that was used as a
392:20 - pivot so now 3 ends up here in between
392:22 - so you have 1 0 2
392:24 - and 5 11 6.
392:26 - and the partition function returns the
392:28 - position of the pivot so now you can see
392:30 - how it is used in quick sort
392:33 - the partition function returns the
392:34 - position of the pivot and then we call
392:35 - quick sort on the left partition
392:39 - before the pivot and on the right
392:40 - partition after the pivot
392:46 - so now we can test out quick sort okay
392:49 - and here's another exercise for you add
392:51 - print statements inside the partition
392:53 - function so there are already some print
392:55 - statements you can simply uncomment them
392:57 - uncomment the print statements to
392:59 - display the list the left pointer and
393:00 - the right pointer and the beginning at
393:02 - end of every loop to study how
393:04 - partitioning works and similarly you can
393:06 - also add print statements inside the
393:08 - quick sort function to study how the
393:10 - recursive calls are going on
393:12 - so study what we've done in merge and
393:14 - merge sort and add the same print
393:16 - statements in quick and quick sort
393:18 - and look at these recursive calls
393:21 - now what you want is to have a
393:23 - completely clear and perfect idea of
393:25 - what your code is doing you don't want
393:27 - to be lost about it and that's why
393:29 - adding print statements and looking at
393:31 - small examples and making sure that it's
393:33 - working perfectly really helps
393:36 - so let's look at quicksort in action so
393:38 - here's an input
393:40 - and here's the expected output and
393:42 - here's the actual output and they match
393:44 - great
393:45 - and we can now evaluate all the test
393:47 - cases using the evaluate test cases
393:49 - functions for function from jovian
393:52 - so
393:53 - we import from juvenile python dsa
393:55 - evaluate test cases
393:58 - and call evaluate test cases here
394:01 - and you can see that it passes
394:04 - all the test cases
394:06 - and not only that you will also notice
394:08 - that it is marginally faster than merge
394:10 - sort for sorted lists
394:13 - sometimes you may not
394:15 - see that but yeah you can see here that
394:17 - it's
394:18 - you will see that in most cases
394:19 - quicksort is marginally faster than
394:21 - merge sort for larger list and that's
394:23 - because it is not allocating
394:25 - new space okay so now coming to the time
394:28 - complexity for
394:29 - quick sort
394:31 - now assuming that we are able to have a
394:33 - good partition each time so each time we
394:36 - are dividing the list into roughly equal
394:38 - halves
394:39 - roughly equal parts
394:41 - like you start with a list of size n and
394:43 - you partition it
394:45 - into n by two and n by two so this is
394:47 - what the sub problem tree looks like so
394:49 - you call quick sort with two lists of n
394:50 - by two n by two then you call quick sort
394:52 - with four lists of size n by two n by
394:54 - four n by four and so on
394:56 - now what is the activity that we're
394:57 - doing inside quick sort in each quick
394:59 - sort the core operation is partition
395:01 - right and that's what puts one element
395:03 - the pivot element into its right place
395:05 - and then the
395:06 - element smaller than it to the left of
395:08 - it the elements larger than it to the
395:09 - right of it
395:11 - so the partition is where
395:14 - the actual work the comparison and
395:16 - swapping happens and how many
395:17 - comparisons do we perform in the
395:19 - partition
395:21 - i would say that the number of
395:22 - comparisons is equal to the size of the
395:24 - actual list and you can see that here
395:27 - you can see that we are going on
395:28 - comparing
395:29 - numbers like this we are comparing each
395:31 - number to the pivot so each number gets
395:33 - compared to the pivot exactly once
395:35 - roughly
395:37 - and that means
395:38 - that there are a total of
395:41 - n comparisons if n is the size of the
395:43 - list
395:44 - okay
395:47 - so we have n comparison and partition so
395:49 - partition performs n operations or
395:51 - partition is an order n function
395:54 - and what is the height of the tree once
395:55 - again the height of the tree is log n
395:57 - because
395:58 - to go from n to one
396:02 - it takes log n steps you keep going n by
396:04 - two n by four and by eight and so on n
396:06 - by two to the power log n becomes n by n
396:09 - one
396:13 - and so the time complexity of quick sort
396:16 - is n login
396:17 - if you're able to partition the array
396:19 - into roughly equal parts
396:21 - and that is what happens on average if
396:22 - you're picking random pivots each time
396:25 - then you do end up with roughly equal
396:27 - parts maybe it's 75 35 75 25
396:31 - but that's still more or less in the
396:33 - same range
396:35 - so the quick sort complexity is about n
396:38 - log in
396:39 - and this is called the average case
396:40 - complexity on the other hand if you have
396:43 - a really bad partition and a really bad
396:45 - partition is maybe you picked the
396:47 - smallest element as the pivot now if you
396:49 - pick the smallest element as the pivot
396:51 - then all the elements will go to the
396:53 - right of the pivot and you will end up
396:55 - calling quick sort
396:57 - on a problem of size n minus one and
396:59 - then maybe once again if you pick the
397:02 - smallest element as pivot
397:03 - all the elements will go to the right of
397:05 - the pivot once again and you will end up
397:07 - calling quicksort with a problem size of
397:08 - n minus two now this is an unbalanced t
397:11 - or a skewed tree and what happens in a
397:13 - skewed tree is that the height this time
397:15 - is the same as n you can see n n minus
397:18 - one n minus two n minus three so going
397:19 - up to one
397:20 - the height of three is n
397:22 - but the amount of work involved in
397:24 - partitioning is the same because you
397:25 - have to run through the entire list to
397:28 - partition the list right so
397:30 - that in this case the time complexity is
397:36 - roughly n times n minus 1 by 2.
397:40 - so the time complexity is about
397:42 - order n square
397:45 - and that's bad because that's as bad as
397:47 - bubble sort
397:50 - but despite the quadratic worst case
397:52 - time complexity quicksort is still
397:54 - preferred in many situations now it
397:57 - really depends on
397:58 - what kind of algorithm you need to use
398:00 - and what kind of memory constraints you
398:02 - have because
398:04 - quicksort's complexity is closer to end
398:06 - login in practice especially with a good
398:08 - strategy for picking a pivot and a good
398:11 - strategy is picking a random pivot but
398:12 - there's another one called picking
398:14 - median of medians you can check that out
398:15 - as well
398:17 - so that's n log n is the average time
398:20 - complexity of quick sort and then
398:22 - n square is the worst case time
398:23 - complexity of quick sort
398:25 - now here's an exercise for you verify
398:28 - that quicksort requires order one
398:29 - additional space which means that it
398:31 - does not really need to copy the array
398:33 - we did create a copy
398:35 - because we did not want to affect our
398:37 - test cases but we could have removed
398:39 - that line and quick sort would work just
398:41 - fine so because you do not need to
398:43 - create a copy of the list or the array
398:46 - it requires order one additional space
398:49 - but because space complexity also
398:51 - includes
398:52 - often the size of the space required to
398:54 - store the input so you can say that
398:56 - quicksort has the space complexity of
398:58 - order n okay so if you get the question
399:01 - about space complexity you may want to
399:03 - ask are you talking about the additional
399:05 - space or do you also want to include the
399:07 - input in the space complexity
399:11 - so that's quick sort
399:15 - and those are the two sorting algorithms
399:17 - we've looked at so we've looked at
399:19 - we've looked at bubble sort and we've
399:21 - looked at insertion sort and then we
399:22 - optimized it
399:24 - using
399:25 - divide and conquer and
399:27 - got to merge sort which is order n log n
399:30 - but it also has a space complexity of or
399:33 - the additional space requirement of
399:34 - order n which can be avoided using quick
399:36 - sort
399:39 - which uses order one additional space
399:42 - but can have order n square
399:45 - complexity in the worst case time
399:47 - complexity
399:49 - but with the right choice of a pivot it
399:50 - is closer to n log n
399:53 - so that's sorting and you can see that
399:55 - python is such an expressive language
399:57 - that all these sorting algorithms which
400:00 - are often quite confusing to implement
400:02 - in c plus or java are actually pretty
400:04 - straight forward to implement in python
400:06 - all you need to do is follow the method
400:08 - which is to state it first in plain
400:11 - english have some test cases ready to
400:13 - test your function and then write your
400:16 - code carefully
400:17 - checking each line for errors and create
400:20 - small functions wherever you need to so
400:22 - try not to have too much logic in one
400:24 - function a good rule of thumb is about
400:26 - seven to eight lines of code per
400:28 - function no bigger than that
400:30 - and that's not just for toy problems but
400:32 - that's also even as a software developer
400:34 - something that you can
400:35 - try to
400:37 - follow just have seven eight lines of
400:38 - code in any function if you have more
400:40 - than that try to split it into two
400:42 - functions
400:43 - okay and and this way it's very
400:46 - difficult for you to go wrong
400:49 - so now let's return to our original
400:51 - problem statement and let's read it once
400:52 - again you're working on a new feature on
400:54 - jovian called top notebook of the week
400:56 - or top notebooks of the week and write a
400:59 - function to sort a list of notebooks in
401:01 - decreasing order of likes now keep in
401:03 - mind that up to millions of notebooks
401:04 - can be created every week you want to
401:06 - build this for scale so your function
401:08 - needs to be as efficient as possible
401:11 - so first we need to sort objects this
401:13 - time and not just numbers
401:15 - and second we also want to sort them in
401:17 - the decreasing order of likes for each
401:19 - notebook okay
401:21 - so all we need to do
401:23 - is to use our merge sorter quick sort
401:26 - techniques that we've already
401:28 - discussed
401:30 - is to define a com custom comparison
401:32 - function to compare two notebooks okay
401:34 - but before we do that we let's create a
401:37 - class that can capture some basic
401:38 - information about notebooks so here we
401:40 - have the class
401:41 - so we're still following the method so
401:42 - to speak right the step one was to come
401:44 - up with the input and the output format
401:46 - so here is the input format our input
401:49 - format would be using this class so we
401:51 - create creating a class notebook which
401:53 - is titled username and likes
401:57 - so you create the class and that gets
401:59 - stored as properties titles username and
402:01 - likes and then we also have a string
402:02 - representation here then
402:05 - create some test cases so now we are
402:06 - creating some test cases here so we are
402:09 - creating some test cases in nb0 to nb9
402:13 - and let's put them all into a list and
402:15 - you can see here that
402:17 - we now have a list of notebooks
402:20 - nb 0 to nb9
402:22 - and you can see that because we have a
402:24 - string representation we can see that
402:25 - the first notebook is this our caution
402:27 - slash pytorch basics and it has 373
402:29 - likes
402:30 - and the second one is this and it has
402:32 - 532 likes and these are clearly out of
402:34 - order in terms of likes
402:36 - next we will define a custom comparison
402:38 - function for comparing the two notebooks
402:41 - what it will do is it will return the
402:43 - strings lesser equal or greater to
402:47 - establish the output order between the
402:49 - two objects okay so it should return
402:52 - lesser
402:53 - when
402:53 - nb1
402:55 - should come at a position or a index
402:58 - lesser than the position of nb2
403:00 - in a sorted
403:02 - list
403:04 - okay so in in in case of our problem
403:07 - what that means is we want to sort
403:09 - things in the decreasing order of likes
403:11 - so the first notebook should have the
403:12 - highest number of likes and then maybe
403:14 - the second notebook should have the
403:15 - second highest number of likes and the
403:16 - third notebook will have a lower number
403:18 - of likes and so on so if you have two
403:20 - notebooks nb1 and nb2 and if nb1.likes
403:23 - is greater than nb2.likes so then nb1
403:27 - should come at a lesser index okay so we
403:29 - will return lesser because it should
403:31 - come at a
403:32 - lower position
403:35 - in the sorted list so we return lesser
403:37 - because we want a decreasing order
403:40 - and if nb1 dot likes is equal to nv two
403:42 - dot likes then we return equal and if nb
403:44 - one dot likes is
403:46 - less than nb two dot likes so that means
403:48 - this is not uh is nb two is the more
403:51 - like notebook and bit one is the less
403:53 - like notebook
403:55 - then nv1 should actually come at a
403:57 - greater position so we will return
403:59 - greater okay
404:00 - so this is
404:02 - this comparison function should
404:04 - return whether the first input to it
404:07 - should come up should show up at a
404:09 - lesser position in the sorted list
404:11 - compared to the
404:12 - second input
404:14 - now in
404:15 - languages like c plus plus and java
404:17 - normally the convention is to return a
404:18 - negative number zero or positive number
404:21 - but i find that python allows you to
404:24 - return strings strings are first-class
404:26 - citizens in python and it's a lot
404:28 - clearer when you are debugging things
404:30 - when you face issues to look at actual
404:32 - strings and it's also easier to write
404:34 - write code
404:36 - so i prefer using strings but you can
404:38 - also use
404:40 - you can also use
404:41 - numbers like negative zero or positive
404:44 - that's totally up to you
404:46 - so now here is an implementation of
404:47 - merge sort which accepts a custom
404:49 - comparison function so let's see the
404:51 - merge sort function
404:52 - so the merge sort function uses
404:56 - it takes a list of objects this time not
404:58 - a list of numbers
404:59 - and it also takes a compare function
405:01 - which by default we also provide a
405:03 - default comparison so that we can still
405:05 - use it with numbers now with numbers
405:08 - and default assumption is if you want
405:10 - sorting you want sorting in increasing
405:12 - order so this is what the default
405:14 - sorting looks like for numbers so that's
405:16 - pretty straightforward but
405:18 - you can also pass a custom comparison
405:20 - function so here we have the terminating
405:22 - condition if the length is less than 2
405:24 - then we simply return the list then we
405:26 - get the mid index and then we call merge
405:29 - sort
405:30 - on the left half with the custom
405:31 - comparison function we call merge sort
405:33 - on the right half with the custom
405:35 - comparison function and we call merge
405:37 - with the custom comparison function
405:40 - now what happens inside merge inside
405:42 - merge earlier you know once again we
405:44 - have these two halves left and right and
405:46 - then we have a custom comparison
405:47 - function so we create pointers for the
405:50 - two of them and then we also create the
405:51 - final result list which is merged
405:54 - and then we iterate over the left list
405:56 - and the right list
405:58 - so while we are going through these
406:00 - we compare
406:01 - the left element and the right element
406:03 - so now we're calling compare now we're
406:04 - not doing the greater than less than
406:06 - comparison calling compare and if the
406:08 - result if the element on the left is
406:10 - lesser or equal to the element on the
406:13 - right then we append it to the result
406:17 - array and we increment the left counter
406:19 - otherwise
406:21 - so lesser or equal means that the
406:23 - element on the left the first element on
406:26 - the left
406:27 - should show up at a lower position in
406:29 - the sorted final sorted list so that's
406:30 - why we append it first otherwise we
406:33 - append the right child to the right
406:34 - element
406:35 - and we increment the right pointer and
406:37 - finally we attach any remaining elements
406:39 - here so this is something that you can
406:40 - review something we've covered in a lot
406:42 - of detail so now let's see let's call
406:45 - merge sort on our notebooks and let's
406:47 - check if the notebooks are sorted by
406:49 - likes and indeed they are you can see
406:51 - that at position 0 you have the notebook
406:53 - with the highest number of likes and
406:55 - then you have the next one and the next
406:56 - one and so on
406:58 - now since we have written a generic
407:00 - merge sort function that works with any
407:03 - compare function we can now very quickly
407:04 - use it to sort the notebooks by title as
407:06 - well or if we had maybe the number of
407:08 - views per notebook or the number of
407:10 - versions in each notebook or the number
407:12 - of
407:13 - comments on each notebook we could do
407:14 - that sorting as well so we could even
407:16 - use a hybrid of those
407:18 - so here the example we're taking is
407:20 - comparing by titles so here we have nb1
407:23 - and nb2
407:24 - and simple comparison strings can also
407:26 - be compared using the comparison
407:27 - operators so if nb1 dot title is less
407:30 - than nb2.title then we return lesser
407:33 - otherwise we return equal or greater
407:36 - and with this we should be able to sort
407:39 - them in the
407:40 - ascending order of titles you can see a
407:42 - n c i c i f e l i l o
407:46 - p y p y okay p y t
407:48 - h p y t h p y t o by torch okay so this
407:53 - is an order sorted in the order of
407:54 - titles
407:56 - an exercise for you is to sort in the
407:57 - order of username slash title which
407:59 - means you first compare the username and
408:01 - if the usernames are equal
408:03 - then compare the titles so you can
408:05 - compare you can
408:07 - probably write another comparison
408:08 - function compare username and titles
408:11 - and use that to do that two-level
408:13 - comparison and use that for sorting
408:16 - okay now another exercise for you going
408:19 - forward is to implement and test the
408:22 - generic versions of
408:24 - bubble sort insertion sort and quick
408:26 - sort
408:28 - using these empty cells that are given
408:30 - here right so at this point in the
408:32 - course you should start writing code you
408:33 - should be writing maybe solving one
408:36 - problem every day
408:38 - to really practice the concepts and
408:40 - internalize them
408:43 - and while you're doing that you can also
408:45 - any problem that you work on any
408:46 - notebook that you create you can save it
408:50 - to joven.commit and i'll show you also
408:52 - how to create new notebooks so one way
408:54 - to create new notebooks is to go to
408:56 - jovian joven.ei click the new button and
408:59 - click blank notebook
409:01 - and you can give it a title let's say
409:03 - you are doing quick sort
409:06 - generic
409:08 - and you can set up privacy and create a
409:10 - notebook
409:11 - and that creates a notebook for you and
409:13 - then you can click the run button and
409:14 - run it so that's one way to do it
409:17 - another way you can do it
409:19 - is we've given you a problem solving
409:21 - template so if you come back to the
409:22 - lesson page you will find a problem
409:24 - solving template here
409:26 - now you can click on the problem solving
409:28 - template and click duplicate to create a
409:30 - copy of this notebook in your profile
409:33 - so let's do that
409:37 - and now this is on your profile so you
409:39 - can now click run and then run it on
409:40 - binder or you can even run it locally on
409:43 - your computer
409:45 - and make some changes to it and come
409:47 - back and run jovian.commit
409:49 - and you will end up with a
409:52 - link that you can share so now you can
409:54 - now go on twitter and you can just share
409:56 - this link so
409:58 - write out a tweet
410:00 - and tag us and also use the hashtag 60
410:03 - days of python
410:09 - okay and maybe say this is your quick
410:10 - sort
410:12 - algorithm
410:14 - for generic objects
410:18 - and tweet it out
410:20 - and we will retweet your tweet so we
410:23 - want to support everybody who's taking
410:24 - part in this course on the course page
410:26 - you will find a link to the course
410:28 - community forum which is where you can
410:30 - go and ask questions where if you have
410:31 - questions about any of these and you can
410:33 - even discuss some of the ideas that are
410:35 - discussed here some of the exercises
410:36 - that are shared so you can go into
410:40 - lesson three for instance and create a
410:42 - new topic maybe you want to talk about
410:44 - the generic implementation of quick sort
410:46 - so maybe you can create a new topic and
410:48 - post a query there if you're not able to
410:50 - make it work post your notebook there
410:51 - and ask a question have a discussion
410:56 - and
410:57 - if you are helping other people out if
410:59 - you are answering other people's
411:00 - questions and you've written some really
411:02 - great posts there are links to some more
411:04 - problems that have been shared here so
411:06 - you can check out these links
411:08 - on each of these links you can try out
411:10 - problems you can make submissions you
411:12 - can solve these
411:14 - problems some of these are interview
411:15 - questions as well
411:17 - you can check if your results are
411:18 - correct
411:20 - and you can use the solving problem
411:22 - solving template as a starting point as
411:24 - we've just shared
411:28 - so there is a starter notebook with each
411:30 - assignment and in the assignment all you
411:33 - need to do is run the notebook so you
411:35 - can run it on binder for instance
411:37 - and then there is a question mark in a
411:39 - bunch of places you will find like
411:41 - question marks here in the text and you
411:43 - will find question marks
411:45 - here in the code
411:47 - so you simply need to put in your code
411:49 - your answers into the question marks so
411:52 - replace that with your code you can see
411:53 - here there are some question marks here
411:55 - so you replace that and step by step
411:58 - there are instructions to guide you
411:59 - there is
412:01 - there are comments to guide you so step
412:03 - by step you can solve it and then
412:04 - finally you can also make a submission
412:06 - so right at the very end when you run
412:08 - the code you will also be able to submit
412:10 - directly
412:11 - and when you make a submission then the
412:13 - assignment will get automated will get
412:16 - evaluated in an automated fashion
412:18 - instantly and you will get a pass or a
412:19 - fail grade now if you get a pass grade
412:21 - that's great but if you get a fail grade
412:23 - then you will also get some comments
412:25 - about what went wrong in your solution
412:29 - so you can use those comments to fix the
412:31 - issues
412:32 - so it's a great way to get quick
412:33 - feedback and keep fixing your issues uh
412:37 - especially watch out for edge cases so
412:39 - that's assignment one and then
412:41 - assignment two is called hash tables and
412:42 - python dictionaries a very interesting
412:44 - assignment where you are going to
412:46 - implement
412:48 - hash tables which power python
412:49 - dictionaries from scratch in python and
412:51 - you will also replicate the interface of
412:54 - python dictionaries so do check it out a
412:56 - very interesting assignment
412:58 - again very similar format
413:02 - you will find question marks in certain
413:03 - places you need to replace them with
413:05 - appropriate values expressions or
413:07 - statements
413:09 - and
413:10 - in this way by working through each of
413:12 - these step by step
413:14 - you can see here by working through each
413:16 - of these you will
413:17 - implement hash functions and hash tables
413:20 - which again are very commonly asked in
413:22 - interviews as well so this is an
413:24 - important assignment for from an
413:26 - interview preparation or coding
413:27 - assessment preparation as well
413:30 - and it also teaches you a lot of really
413:32 - good practices in python programming
413:35 - in particular
413:36 - so do check out assignment 2 as well and
413:38 - we will send you an email as soon as
413:40 - assignment 3 is ready but you can check
413:41 - back in a couple of days and you should
413:42 - see it on the same page
413:44 - pythondsa.com
413:48 - so what you do next review the lecture
413:50 - video and execute the jupyter notebook
413:53 - use the interactive nature of jupiter to
413:55 - experiment with the code
413:58 - complete the assignment and attempt the
414:00 - optional questions as well so each
414:01 - assignment has some required questions
414:03 - and you can make a submission as soon as
414:04 - you're done with the required questions
414:06 - but there are some optional questions
414:07 - which are slightly harder but i highly
414:10 - recommend doing that because
414:12 - they will improve your understanding
414:14 - give you more practice help you
414:15 - internalize the concepts better
414:17 - and then participate in forum
414:19 - discussions
414:21 - and join or start a study group so this
414:24 - is a great way to learn get together
414:25 - with some friends maybe watch the
414:27 - lecture together over a zoom call pause
414:29 - the video
414:31 - have discussions wherever you have
414:32 - doubts discussion is a great way to
414:34 - solve the specific doubts that you may
414:36 - have
414:38 - and it will also help you to articulate
414:40 - your understanding better because you
414:43 - when you explain to others you also
414:45 - answer a lot of your own questions so
414:47 - please do that
414:50 - this is data structures and algorithms
414:52 - in python
414:54 - thank you and good day or good night
414:57 - hello and welcome to data structures and
414:59 - algorithms in python this is a live
415:02 - online certification course being
415:04 - organized by
415:07 - jovian
415:09 - today we are on lesson four recursion
415:12 - memoization and dynamic programming
415:15 - my name is akash and i am your
415:17 - instructor
415:18 - you can find me on twitter
415:20 - on at akashness
415:23 - if you follow along with this course and
415:25 - complete the weekly assignments
415:28 - you can also earn a certificate of
415:30 - accomplishment
415:31 - which you can add to your linkedin
415:33 - profile and you will find hosted on your
415:36 - jovian profile as well
415:39 - so let's get started
415:41 - now to the data structures and
415:43 - algorithms course this is
415:45 - pythondsa.com is the course website and
415:47 - on the course website you will be able
415:49 - to find
415:50 - all the information about the course
415:53 - so you can view the previous lessons
415:55 - lessons one two and three and you can
415:56 - also view the previous assignments
415:58 - assignments one and two
416:00 - today we're on lesson four so let's open
416:02 - up lesson four the topic is recursion
416:05 - and dynamic programming
416:07 - now you can find a recording of the
416:10 - lesson here and you can also watch a
416:12 - version in hindi if you would prefer
416:14 - that
416:15 - in this lecture we will cover recursion
416:17 - memoization and dynamic programming by
416:19 - looking at two common problems in
416:21 - dynamic programming the longest common
416:23 - subsequence problem and then knapsack
416:25 - problem
416:28 - and we'll do this by coding these
416:30 - problems live using the problem solving
416:32 - template that we have
416:34 - been using
416:36 - one in one way or another since lesson
416:37 - one so let's open up the problem solving
416:40 - template
416:43 - this is a template that you can use to
416:45 - solve any coding problem and we will
416:47 - illustrate this by solving two problems
416:49 - using this template today
416:51 - so
416:53 - the first thing we need to do is to run
416:55 - this
416:56 - template you can see that there is some
416:58 - explanation and then there is some code
417:00 - here as well now to run this code you
417:01 - have two options you can run it using
417:03 - free online resources or you can run it
417:05 - on your computer
417:07 - the simplest way to run it is click the
417:09 - run button here and select run on binder
417:15 - and with just one click this will
417:19 - set up a machine on the cloud for you
417:22 - start
417:23 - a jupyter notebook server
417:26 - and you will be able to then
417:31 - execute the code and modify the notebook
417:33 - and save a version of it to your own
417:35 - profile so that you can continue working
417:37 - on it
417:39 - so there we have it now we have a
417:41 - running jupiter hub server
417:46 - i'm just going to zoom in here a bit so
417:47 - that you can see things clearly
417:50 - okay so this is the problem solving
417:52 - template and i said we're working on two
417:53 - problems so i have some problem
417:55 - statements listed out here
417:57 - you can see the first problem longest
417:59 - common subsequence is listed here
418:03 - and this is a part
418:04 - of the
418:06 - lesson notebook lesson page as well so
418:08 - you will find link to this problem
418:10 - statement on the lesson page too
418:12 - so let's first
418:14 - modify the title of this notebook
418:15 - problem solving template let's change
418:17 - this title
418:18 - to
418:21 - dynamic programming
418:24 - longest
418:25 - common
418:27 - subsequence
418:29 - let's get rid of this
418:31 - i don't think we need this
418:34 - then i'm going to keep the section on
418:36 - how to run your code so that
418:39 - if
418:40 - i share this notebook with somebody else
418:42 - they have a way to run it
418:45 - and then before we start
418:47 - the assignment or the
418:50 - problem
418:51 - let's just save this to our own profile
418:53 - so i'm just going to give it a name
418:57 - longest
418:59 - common
419:00 - subsequence
419:02 - this is an appropriate name for it so
419:04 - i'm going to give it this a project name
419:06 - install the jovian python library
419:11 - and just run jovian.commit now what this
419:13 - will do is we started out with a
419:15 - template and now we are editing the
419:16 - template by running joven.com we've
419:19 - saved a copy of the template to our own
419:21 - profile you can see this is the link
419:23 - where you will be able to access this
419:25 - notebook and you can run it and continue
419:27 - your work
419:28 - if this jupyter notebook shuts down if
419:30 - you want to continue tomorrow for
419:32 - instance
419:34 - okay so now let's look at the problem
419:36 - statement
419:37 - now i'll just copy over the problem
419:39 - statement here as well so that we can
419:41 - see it directly within the notebook
419:48 - there we have it
419:51 - now you can paste the problem statement
419:53 - and if you are getting this problem
419:54 - statement from some other source then
419:56 - it's always a good idea to include the
419:57 - link to the original source as well
420:04 - okay now we have a problem statement in
420:07 - front of us
420:09 - so the question is write a function to
420:11 - find the length of the longest common
420:13 - subsequence
420:14 - so that's a new term we'll unpack that
420:16 - between two sequences
420:19 - now let's first learn what we mean by a
420:21 - sequence now a sequence is a group of
420:23 - items with a deterministic ordering for
420:26 - instance a list
420:27 - a tuple a range or even a string these
420:30 - are some common sequence types in python
420:32 - so here i have the string serendipitous
420:34 - this is a group of items and this also
420:37 - contains an order you can see that e
420:39 - comes after s and r comes after e and so
420:41 - on so this is a sequence a list would
420:44 - also be a sequence so that would be a
420:45 - list of numbers
420:47 - so that's a sequence then we're looking
420:49 - at subsequence what is the subsequence
420:51 - now a subsequence is a sequence that is
420:53 - obtained by
420:55 - deleting or removing zero or more
420:57 - elements from another sequence for
420:59 - instance if you look at serendipitous
421:02 - and if we remove the characters s
421:05 - r e n
421:07 - i
421:10 - i o u s then you will be left with e d p
421:13 - t so e d p t is a subsequence of
421:15 - serendipitous now two things to note
421:17 - here edpt does not have to occur
421:20 - continuously
421:21 - so these elements can occur anywhere
421:23 - within the sequence but the order should
421:26 - be the same so e d p t occur in this
421:28 - particular order here and e d p t should
421:31 - occur in the same order here so d should
421:33 - occur after e
421:34 - and p should occur after d and t should
421:37 - occur after p
421:38 - so those are the two requirements for
421:40 - edpt to be a subsequence of
421:42 - serendipitous and visually speaking what
421:45 - we can see is if you take a
421:47 - sequence and then you draw boxes around
421:49 - some of these
421:50 - characters or some of these elements of
421:52 - the sequence and if you just take the
421:54 - elements in the boxes then in the same
421:56 - order then you end up with a subsequence
421:59 - so now we understand what a sequence is
422:01 - and what are subsequences
422:03 - and once again if this is this question
422:05 - is asked in an interview and you're not
422:07 - sure what you mean by a longest common
422:09 - subsequence and or even what a sequence
422:11 - is then you should ask the interviewer
422:14 - what do you mean by a subsequence or
422:15 - what do you mean by a sequence and
422:16 - they'll be more than happy to tell you
422:18 - it's very important to communicate
422:21 - whatever you're thinking whatever
422:22 - questions you have
422:23 - contrary to what
422:25 - you might think asking questions is
422:26 - actually a good thing the more questions
422:28 - you ask the more it is appreciated
422:32 - okay so now we've talked about a
422:33 - sequence
422:34 - and a subsequence now what's a common
422:36 - subsequence so look at these two strings
422:39 - serendipitous and precipitation now if
422:43 - we pick just these elements that are in
422:45 - the boxes r e i p i t o
422:50 - now you can see that
422:51 - rei pito is a subsequence of
422:53 - serendipitous
422:55 - and
422:56 - r-e-i-p-i-t-o is also a subsequence of
422:59 - precipitation
423:01 - so a sub-sequence
423:03 - which is common which is a subsequence
423:05 - of both sequences
423:07 - is called a common subsequence so rei
423:09 - p-i-t-o is a common subsequence between
423:12 - serendipitous and precipitation
423:15 - now you can have many common
423:16 - subsequences for instance we could just
423:18 - look at re and re here and re would be a
423:22 - common subsequence too
423:24 - or you could just look at
423:28 - i t and i t and that would be a common
423:30 - subsequence as well or we've not picked
423:33 - n here but you could also pick r e n and
423:35 - r e n and that would also be a common
423:38 - subsequence between the two
423:41 - now the longest common subsequence as
423:43 - the name suggests is the subsequence
423:46 - which between the the common subsequence
423:48 - between the two sequences which has the
423:51 - maximum possible length
423:53 - and you can verify this you can try
423:54 - different subsequences and see that rei
423:56 - p i t o is the longest common
423:58 - subsequence between these two strings
424:01 - these two sequences
424:04 - and its length is seven
424:07 - one two three four five six seven
424:10 - so you have to write a function to find
424:12 - the length of the longest common
424:14 - subsequence between two sequences
424:16 - so that's a question
424:18 - and
424:19 - this is a visual example that tells you
424:22 - the answer okay
424:24 - so now that we have the question we've
424:26 - understood the question
424:28 - we can start applying the method that we
424:30 - have been learning throughout so this is
424:31 - the systematic strategy that we will
424:33 - apply and nothing about this method has
424:35 - changed since the first lesson even
424:37 - though we've covered a whole variety of
424:39 - topics like binary search and binary
424:41 - search trees and then sorting algorithms
424:43 - and divide and conquer
424:45 - this method has remained the same the
424:47 - first step is to state the problem
424:49 - clearly and identify the input and
424:51 - output formats
424:53 - then the second step is to come up with
424:55 - some example inputs and outputs and
424:57 - these will be used to
424:59 - test our solutions so we should try and
425:02 - cover all the edge cases and that will
425:04 - help us write code that is correct
425:06 - anticipating all the errors that we
425:09 - might face
425:11 - then we come up with a correct solution
425:13 - to the problem as stated in plain
425:14 - english
425:16 - very important for you to state the
425:19 - problem in plain english before you
425:20 - start coding so that you communicate
425:22 - your ideas and you also make it clear
425:24 - once you express yourself
425:26 - then you implement the solution and test
425:28 - it using example inputs
425:30 - and you fix bugs if you find any of them
425:32 - and you will be able to find bugs if you
425:34 - have written good test cases
425:36 - then you analyze the algorithms
425:38 - complexity and identify inefficiencies
425:40 - if you have any
425:42 - and most likely the first solution that
425:43 - you come up with it doesn't have to be
425:45 - optimal it just has to be correct so
425:47 - there will be some inefficiency but it's
425:49 - important to go through that process of
425:50 - first finding a brute force solution and
425:52 - then
425:53 - finding the inefficiency
425:55 - and then apply the right technique to
425:57 - overcome the inefficiency and repeat
425:58 - steps to three to six so you identify
426:01 - what's the right technique and in this
426:03 - case we will learn a couple of
426:04 - techniques called memoization and
426:05 - dynamic programming and then we go back
426:07 - and state the correct solution again
426:09 - then we implement the solution and test
426:11 - it and then we analyze it again and if
426:13 - there's further scope for improvement we
426:15 - do that otherwise we say that we've
426:16 - arrived at a
426:18 - optimal or good enough optimal enough
426:20 - solution
426:21 - okay
426:23 - i hope by this point
426:25 - this you've started to memorize this
426:26 - process and that's why we keep repeating
426:28 - it over and over that it should become
426:30 - second nature every time you see a
426:31 - problem
426:32 - so the first thing is to state the
426:34 - problem clearly and to identify the
426:36 - input and output formats now the problem
426:39 - is already stated clearly enough but
426:42 - let's just state it slightly more
426:44 - clearly so let's say
426:47 - we are given and just write it in your
426:49 - own words that's more important whatever
426:52 - is clear to you so we are given two
426:53 - sequences
426:55 - and we need to find
426:58 - the length of the
427:01 - longest common
427:04 - subsequence between them
427:07 - simple enough
427:08 - then we have two inputs now we decide
427:10 - the input and output formats
427:14 - we have sequence one
427:17 - a sequence
427:19 - example
427:23 - serendipitous
427:26 - sequence two
427:28 - another sequence
427:30 - example
427:34 - precipitation
427:44 - great
427:45 - and this these are the only two inputs
427:47 - that we require and the output would be
427:50 - the
427:52 - length of the
427:54 - longest common subsequence let's just
427:56 - abbreviate that as lcs
428:05 - which in this case
428:07 - is seven
428:12 - and we know what that subsequence looks
428:13 - like we've just seen it above
428:17 - so now based on this we can now create
428:19 - and you can see the problem is now
428:21 - created
428:22 - and before i talk about the next thing
428:24 - you if you double click on a text cell
428:25 - you can start editing it and here we are
428:27 - using a language called markdown so you
428:29 - can see this creates a block code this
428:31 - creates a bold font and
428:34 - this creates a
428:36 - code like font so let's see here no and
428:39 - the way to go back into the display mode
428:41 - is to press shift plus enter
428:43 - so now you can see here that now we have
428:45 - the problem we have the block code and
428:46 - then we have all the styling so markdown
428:48 - is a really useful and easy to learn
428:51 - language for formatting your text
428:53 - especially in jupyter notebook so do
428:55 - learn it
428:56 - but now based on this
428:58 - we can now create a signature of our
428:59 - function
429:01 - so our function len lcs
429:04 - will accept a sequence sequence 1
429:06 - and sequence two
429:08 - and it will return something okay so
429:10 - that's the basic signature of our
429:11 - function
429:12 - and even though it's not doing much just
429:14 - establishing what the arguments are is
429:17 - the first step towards solving a problem
429:20 - and let's just save our work from time
429:22 - to time it's very important to keep
429:23 - saving your work on jovian because this
429:26 - is running on
429:27 - a free online service so this will shut
429:29 - down after some
429:31 - minutes of inactivity so just run
429:33 - jovian.commit and that will save the
429:35 - notebook to your profile and you can
429:36 - rerun it
429:37 - okay so now the next step is to come up
429:39 - with some example inputs and outputs and
429:42 - here we need to try and cover all the
429:43 - edge cases
429:45 - so
429:46 - i have written out a few test cases here
429:49 - already
429:51 - now the most common case is a general
429:52 - case of a string like we had
429:55 - serendipitous and precipitation that's a
429:57 - common case there is one of them
430:00 - both of them have some common elements
430:02 - and there's a subsequence common
430:04 - subsequence of length 7
430:06 - but we may also want to test out another
430:08 - type of data and this is one of the nice
430:11 - things about python where you can write
430:12 - functions that operate not just on a
430:14 - particular class and its subclasses but
430:18 - on any kind of data as long as it
430:20 - satisfies certain criteria for instance
430:22 - strings and lists both allow indexing
430:24 - into them and picking out the ith
430:26 - element or the nth element from the
430:29 - sequence so they're both sequences so
430:31 - our function should be able to work with
430:32 - both strings and with lists
430:35 - then
430:37 - here is another case where we have two
430:39 - sequences and they have no common
430:41 - subsequence a function should not throw
430:43 - an error here it should gracefully
430:45 - return the number 0 because the empty
430:48 - sequence is a subsequence of every other
430:50 - sequence does that make sense
430:52 - think about it so in that case if you if
430:55 - there's no common subsequence then the
430:57 - empty sequence is the common subsequence
430:59 - so the answer is zero and here's one
431:01 - other extreme case where one is a
431:03 - subsequence of the other
431:05 - here's another case where one sequence
431:07 - is empty there's another case where both
431:09 - sequences are empty all of these are
431:11 - important otherwise you might miss out
431:13 - certain special cases and you will face
431:16 - an error when you code your solution
431:19 - finally you can also have this case
431:21 - where you have multiple subsequences
431:22 - with the same length for instance if you
431:24 - have a b c d e f and b a d c f e an a c
431:28 - e
431:29 - a c e is one long subsequence of length
431:32 - three and that's the longest you can
431:33 - verify and bdf is another subsequence
431:36 - which is common to the two and also has
431:38 - the same length
431:40 - those are some test cases now let's copy
431:42 - over these test cases here
431:44 - in an interview or a coding assessment
431:46 - what you might want to do is just write
431:48 - these as comments if you have just a
431:50 - single coding screen and try to list at
431:52 - least four or five if but
431:54 - go as far as you can because this will
431:56 - also help you streamline your own
431:58 - solution
431:59 - and it's always something that is
432:00 - appreciated
432:02 - by interviewers
432:04 - let's do that let's get
432:10 - let's copy over these test cases here
432:12 - and you can think of more so
432:16 - if you have some more ideas of things
432:17 - you should test
432:19 - come up with them there's no right
432:20 - number of tests
432:23 - whatever it takes for you to feel
432:24 - confident
432:27 - is what you need to do
432:30 - okay
432:31 - so now what we've done is we've taken
432:33 - these test cases and converted them into
432:34 - dictionaries so you can see here we have
432:36 - this first sequence sequence one and
432:38 - remember that's why we've written out
432:41 - that's why we've written out here the
432:43 - names of the inputs and the signature of
432:45 - the function now we can create test
432:46 - cases
432:48 - as dictionary so that we can test them
432:50 - all easily all at once so we have the
432:53 - sequence one and sequence two in the
432:55 - input
432:56 - sub dictionary inside the main test case
432:58 - dictionary and then we have the output
433:00 - which is the output of the function
433:01 - which should be seven and this you can
433:03 - verify so this is a general case then we
433:06 - have another case in this case we have
433:09 - two sequences these are both
433:11 - lists
433:13 - of numbers and in this case the output
433:15 - that we expect is 5
433:17 - and we have another general case longest
433:19 - and stone in this case you can verify
433:20 - that o n e is the common subsequence
433:23 - it has the output three then here we
433:25 - have two sequences which do not have any
433:28 - common elements all these
433:30 - come from the left half of the keyboard
433:32 - all these come from the right half of
433:33 - the keyboard so that was a quick way to
433:34 - generate these two sequences
433:39 - then here we have
433:41 - dense and condensed and you can see that
433:43 - dense is actually a piece inside
433:46 - condensed so this is a special case
433:48 - where dense is a continuous
433:50 - sub string of the string
433:53 - but it even if we had d e s e
433:56 - that would still be a subsequence
433:57 - because d e s e occur in this order so
434:00 - that's one example and in this case the
434:03 - sequence one is itself the longest
434:05 - common subsequence and it has length
434:07 - five
434:07 - then we have this case where one of the
434:10 - sequences is empty
434:12 - and you can see in that case the output
434:13 - should be zero and both sequences are
434:16 - empty and here is the case where you can
434:18 - have multiple longest common
434:20 - subsequences and even in this case
434:22 - your function should be able to figure
434:24 - out the answer correctly
434:26 - so let's take this
434:28 - and let us copy over these test cases
434:30 - here so we have t 0
434:33 - to
434:33 - p 7 so that's 8 test cases
434:40 - and
434:40 - you can add more test cases here
434:43 - please feel free
434:46 - coming up with good test cases is a
434:47 - skill that you should develop
434:49 - and what we'll do is we'll also put all
434:51 - these test cases
434:54 - into
434:55 - this function called lcs or longest
434:57 - common subsequent tests
435:01 - so that we have all of them easily
435:02 - available for testing at once
435:06 - okay
435:08 - okay
435:09 - now next step is to come up with a
435:11 - correct solution for the problem now
435:12 - we've seen the problem we have
435:14 - identified some scenarios
435:17 - now we need to come up with a simple
435:18 - correct solution stated in plain english
435:20 - it doesn't have to be efficient
435:23 - it just has to be correct
435:25 - so here's one idea
435:29 - here's one idea here you can see we have
435:31 - a couple of
435:33 - sequences
435:34 - let's create two counters idx1 and idx2
435:38 - both starting at 0. so idx 1 will be a
435:41 - pointer which will
435:43 - start tracking
435:46 - elements on in the first sequence and
435:48 - idx 2 will be a pointer which will start
435:50 - tracking elements in the second sequence
435:53 - and what we'll do is we will write a
435:55 - recursive
435:57 - function so we'll write a recursive
435:59 - function
436:00 - which will compute the lcs of sequence
436:03 - one
436:05 - from idx to the idx1 to the end and
436:07 - sequence 2 from idx 2 to the end
436:10 - so what does that mean
436:12 - let's say idx 1 has the value 3
436:15 - and idx 2 has the value
436:18 - 1.
436:19 - so you can see 0 one two three so
436:23 - sequence one idx one onwards is logy
436:27 - and sequence two idx uh idx2 onwards is
436:30 - lch m e m y
436:33 - so we are looking at this portion of the
436:36 - problem and this portion of the problem
436:38 - and our recursive function when invoked
436:40 - with idx 1 and idx2
436:43 - should return
436:46 - the length of the longest common
436:47 - subsequence between these two portions
436:50 - so l o g y and l c h e m y now why are
436:53 - we doing this we need this longest
436:55 - common subsequence for the entire string
436:58 - don't we
436:59 - now
437:00 - here's the logic why why we're writing
437:02 - this recursive function which which can
437:05 - theoretically compute this subsequence
437:07 - for from any position onwards
437:10 - so here's how we do this
437:13 - if
437:14 - sequence 1 of idx1 so if idx1 was
437:17 - pointing to l and idx2 was pointing to
437:21 - l here as well if sequence 1 of idx 1
437:24 - and sequence 2 of idx2 are equal
437:27 - then this character l
437:29 - belongs to the lcs of
437:31 - this portion
437:33 - and this portion
437:34 - okay why
437:36 - think about it it makes sense because
437:39 - these
437:41 - these elements are equal so if you pick
437:43 - the longest common subsequence of this
437:45 - and you pick the longest common
437:46 - subsequence of the remaining
437:49 - then you can always add l to bo to that
437:52 - subsequence and that will make the
437:53 - subsequence longer right and that way it
437:56 - follows that l will always occur in the
437:58 - longest common subsequence between l o g
438:00 - y and l c h e m y
438:03 - okay
438:05 - so we know now that this will occur l
438:08 - will occur in the longest common
438:09 - subsequence further
438:10 - the length of this
438:13 - longest the length of this longest
438:15 - common subsequence will be
438:16 - the length of the longest common
438:18 - subsequence between ogy and ch emy
438:22 - plus one
438:24 - okay and now you can see why a recursion
438:27 - is required because what we can now do
438:29 - is we can say that if
438:30 - sequence one of idx 1 and sequence 2 of
438:32 - idx 2 are equal
438:34 - then we simply call the recursive
438:36 - function on sequence 1 of idx 1 plus 1.
438:39 - so ogy and sequence 2 of idx 2 plus 1 ch
438:43 - emy
438:44 - and
438:45 - assume that recursion will give us the
438:47 - solution there
438:48 - and simply add 1 to it because this is
438:51 - equal okay so that's one case if
438:53 - sequence 1 of idx 1 and sequence 1 of
438:55 - idx 2 are equal great
438:58 - but if they're not equal right so for
439:00 - ins in this case for instance you can
439:03 - see that
439:04 - if i dx1 and idx 2 are both 0 so idx 1
439:07 - points to a and idx 2 points to b so if
439:11 - they are not equal
439:12 - then one of the two things should hold
439:16 - either
439:17 - a does not occur in the longest common
439:19 - sub sequence
439:21 - between the two strings or b does not
439:23 - occur in the longest common subsequence
439:25 - between the two strings now we don't
439:26 - know which one but that's the
439:29 - power of recursion that we can just try
439:30 - both so we can simply ignore a and we
439:33 - can get the longest common subsequence
439:35 - between b s e and t and b est
439:38 - and check its length and then we or we
439:40 - can simply ignore b and we can get the
439:42 - longest common subsequence between absc
439:45 - and est and check the length now
439:48 - whichever is longer in length that
439:50 - becomes the solution for the two strings
439:53 - okay
439:55 - so this is what it looks like
439:57 - we start out with analogy and alchemy
440:00 - we compare a and a
440:02 - these two are equal so we know that the
440:04 - longest common subsequence is one
440:07 - the length is one plus
440:09 - lcs of analogy and alchemy okay now we
440:13 - compare n and l and now we see that they
440:15 - are not equal
440:17 - so either n does not come in the longest
440:20 - common subsequence or l does not come in
440:22 - the longest common subsequence so we try
440:25 - both we remove n here you see a l o g y
440:28 - and we remove l here we see c h e m
440:33 - now once again a and l are unequal so
440:37 - either a does not occur in the lcs of
440:39 - these two strings or l does not occur in
440:41 - the lcs of these two strings so if a
440:44 - doesn't occur in the lcs we can remove a
440:46 - and try again if l does not occur in the
440:49 - lcs we can remove l and try again
440:52 - and here once again we get a match
440:55 - so in this case we know that l occurs in
440:57 - the longest common subsequence of these
440:59 - two elements
441:01 - so now we can get the lcs of ogy and ch
441:04 - emy okay and then you know as these
441:06 - recursive calls complete
441:08 - you can see that this entire tree pans
441:10 - out you can see that each time you
441:12 - either get one
441:13 - child or you get two children and if you
441:15 - go all the way down and then you
441:17 - go back up and simply count the number
441:19 - of matches for each path you will kee
441:21 - and you take keep taking the maximum so
441:23 - here you get back an answer let's say
441:25 - you get back an answer of size two here
441:27 - you get back an answer of size one
441:29 - so the answer for this is simply the
441:31 - maximum of two and one which is two and
441:33 - then the answer for this is simply the
441:35 - maximum of two and
441:37 - let's say this is three then three and
441:39 - the answer for this is simply one plus
441:41 - three four okay so this is the way that
441:44 - we will build up the solution
441:46 - so we've now looked at the recursive
441:48 - solution expressed
441:50 - in text and we've looked at the
441:52 - recursive solution expressed as a tree
441:55 - now it's possible that it still may not
441:57 - make sense to you how exactly this is
441:59 - working and that is where you should
442:00 - start trying to
442:02 - create this tree yourself so pick up a
442:04 - pen and paper and then start drawing on
442:07 - pen and paper take an example and try to
442:09 - read each step here and try to work it
442:12 - out like a computer okay and just
442:15 - thinking about it that way will help you
442:17 - understand
442:18 - this algorithm
442:20 - now one last thing is that if either of
442:23 - the
442:24 - sequence one from idx onwards or
442:26 - sequence two from idx onwards is empty
442:27 - which means the index has reached the
442:29 - end point
442:30 - in after doing some recursion then their
442:33 - lcs is empty so the length is zero okay
442:36 - so that is the
442:38 - recursive solution here i will just copy
442:40 - over this recursive solution too
442:43 - along with the entire tree
442:51 - now obviously in an interview you do not
442:53 - need to write all of this
442:55 - in
442:56 - in a lot of detail or you do not need to
442:59 - so it helps to show a diagram sometimes
443:01 - but you don't really need to do all of
443:03 - this all you need to do is express
443:05 - yourself clearly that we will create two
443:07 - counters
443:08 - and
443:09 - the condition to check is whether these
443:12 - two elements at those counter positions
443:14 - are equal what do we do if they are
443:16 - equal what do we do if they are in equal
443:18 - and why are we using recursion here so
443:20 - we are using recursion we can because we
443:22 - can use reuse some of the sub problems
443:24 - to compute the final problem
443:26 - okay
443:27 - and
443:28 - understanding recursion is really
443:29 - important for solving data structures
443:31 - and algorithms problems because it's
443:32 - like a superpower pretty much
443:35 - pretty much every problem that you see
443:38 - one way or another can
443:41 - does boil down to recursion in one way
443:44 - okay so now let's
443:46 - save our work once again and now we're
443:48 - ready to implement the solution so we
443:49 - have the recursive solution in front of
443:51 - us and if you remember the four steps
443:53 - let's go let's go ahead and implement it
443:55 - so we see
443:57 - let's just call it lcs recursive
444:02 - and this will accept a sequence one
444:04 - and a sequence two
444:06 - and let's also initialize
444:10 - idx1 and idx2 because we will be calling
444:12 - this function recursively so we'll
444:13 - simply
444:15 - use these two counters idx 1 and idx 2
444:19 - and set them to 0.
444:21 - now the first thing we need is if idx 1
444:25 - is equal to the length of sequence 1
444:27 - or idx2
444:29 - is equal to the length of sequence 2.
444:32 - then we return zero
444:34 - again this is a common thing
444:36 - that happens that the base case or the
444:38 - end scenario is something when you're
444:40 - describing the algorithm you will
444:42 - describe at the very end as you're
444:43 - drawing the tree you will notice what
444:44 - the end case and scenario is but when
444:47 - you're coding the algorithm the end
444:48 - scenario or the base case comes at the
444:51 - very top because otherwise we'll try and
444:53 - access idx 1
444:54 - from sequence 1 and that will throw an
444:57 - error so that's why you need to handle
444:58 - the base case at the very beginning
445:01 - okay
445:02 - next moving ahead
445:04 - if sequence one
445:06 - of idx one
445:09 - equals
445:13 - sequence 2
445:15 - of idx2
445:18 - great we found a match
445:20 - we simply return 1 plus
445:23 - now we can call
445:24 - lcs recursive
445:27 - on sequence
445:29 - one sequence two
445:31 - and we increment idx
445:33 - one by one
445:36 - and we also increment idx two by one
445:39 - both of these need to be incremented
445:43 - because
445:45 - we are going to use this element this
445:47 - common element
445:48 - as an element in the subsequence okay
445:51 - so there's just one recursive call here
445:53 - that was nice
445:54 - otherwise
445:56 - we have to either ignore the first
445:58 - element of or the current element from
446:01 - sequence 1 or the current element from
446:03 - sequence 2.
446:04 - so we have two options so we have option
446:06 - one
446:07 - which is
446:08 - we ignore the current element of
446:09 - sequence one so this becomes lcs
446:12 - recursive sequence one
446:14 - sequence two
446:17 - idx one plus one
446:21 - and idx2
446:23 - and then we have option two
446:25 - this is
446:28 - lcs recursive
446:31 - once again with sequence one
446:33 - and sequence two
446:34 - and this time we increment
446:37 - idx2
446:40 - okay so make sure you understand this
446:42 - piece because this is really the key
446:44 - here
446:46 - and then the length of the longest
446:47 - common subsequence is simply the maximum
446:49 - of option one
446:50 - and option two okay
446:53 - and that's it
446:54 - what may
446:55 - have seemed like a fairly tricky problem
446:57 - once you start thinking about it
446:59 - recursively okay
447:00 - what happens if we simply compare the
447:02 - first two and they're equal and they're
447:04 - unequal okay now we need to solve the
447:06 - problem for the remaining um either we
447:09 - add one or we take or we ignore one of
447:11 - the elements right once you get that
447:13 - thought the recursive thought then the
447:16 - solution and the code simply presents
447:19 - itself to you it's just about
447:21 - seven lines of code
447:23 - okay
447:24 - that's our lcs recursive solution
447:26 - now let's test it out let's look at a
447:29 - test case t0
447:32 - okay so here we have serendipitous and
447:34 - precipitation as the inputs let's call
447:36 - lcs
447:41 - let's keep that around so that we can
447:42 - view it later
447:45 - let's cost call lcs recursive
447:49 - on
447:51 - t0
447:52 - but of course we need to fetch from t0
447:54 - the input
447:56 - and
447:57 - get sequence 1 out of the input
448:06 - and similarly we need to get the input
448:08 - and get sequence 2 out of the input
448:12 - you can see it it
448:14 - takes
448:14 - it returns the value 7
448:16 - which is equal to the output by the way
448:19 - so if we simply put in here t0
448:25 - output
448:27 - and i'm also going to put in this
448:29 - special command called percentage
448:30 - percentage time this is going to tell us
448:32 - how long the cell takes to execute
448:35 - yeah so now you can see here that we get
448:38 - back true and the cell takes 495 seconds
448:41 - or half a second to execute
448:48 - and that's it so now we have tested this
448:50 - test case one small thing i can tell you
448:52 - how to
448:53 - improve this slightly is because
448:56 - in t 0 of input is a dictionary and
448:59 - because the names of the elements of the
449:01 - dictionary are sequence 1 and sequence 2
449:03 - which also match the argument names of
449:05 - lcs recursive you can see here we have
449:07 - sequence 1 and sequence 2. what you can
449:09 - do is you can simply say star star t0
449:12 - input
449:13 - and python will automatically grab each
449:16 - key so sequence one will be passed as
449:17 - the argument sequence one and sequence
449:19 - two will be passed as the argument
449:21 - sequence two
449:22 - that's this is a small trick here that
449:24 - helps us speed up
449:26 - the reduce the amount of code we need to
449:28 - write
449:29 - okay now we've tested one test case but
449:32 - that's not enough we should be testing
449:34 - all the test cases
449:35 - so to test all the cases we can write a
449:38 - for loop for
449:40 - t in tests etc
449:45 - but we can do something else too
449:48 - we can use the evaluate
449:50 - test cases function from jovian so from
449:53 - jovian.python dsa the module
449:55 - we will import evaluate test cases
449:58 - it's a helper function that we've
450:00 - created for you but it's really simple
450:01 - to write you can just use a for loop as
450:03 - well
450:04 - and we call evaluate
450:07 - test cases
450:09 - on the function that we want to test
450:10 - which is lcs recursive
450:13 - and the test that we have which is lcs
450:15 - tests
450:16 - and when we do this it is going to try
450:19 - out each test case you can see it strike
450:20 - test k0 that was a pass it tried test
450:23 - case 1 and it's also printing out the
450:25 - input the expected output in the actual
450:27 - output
450:28 - the test case 1 was
450:31 - lists
450:32 - and
450:33 - lists work too because all we have used
450:35 - here is indexing and length and these
450:37 - are both things that are available in
450:39 - both strings and lists and this is
450:41 - something that's very nice about python
450:43 - the dynamic nature of the functions
450:46 - uh once again this worked perfectly fine
450:48 - then here we have another one longest in
450:50 - stone the expected output was three and
450:52 - the actual output was three as well here
450:54 - we have ads f e w ad and another string
450:58 - they have nothing in common so the
450:59 - expected and actual output are both zero
451:02 - here's one where one is the
451:05 - is already a subsequence of another so
451:07 - the smaller one becomes the longest
451:09 - common subsequence and then we have an
451:11 - empty string and then we have two empty
451:12 - strings and finally we have multiple
451:15 - longest common subsequences we still get
451:17 - back the right output now if any of
451:19 - these failed you would know exactly what
451:21 - went wrong for instance if you had an
451:23 - issue in
451:24 - this case where the two of these were
451:26 - empty then that would tell you that
451:28 - you've probably not handled that empty
451:30 - case properly and that is why having
451:31 - great test cases is very important
451:34 - okay and we can see the timings for
451:36 - these as well each of these took about
451:39 - well
451:39 - 480 milliseconds was the highest now
451:42 - that's still a bit high i would say 480
451:44 - milliseconds because we are just looking
451:46 - at sequences serendipitous and
451:48 - precipitation which are of very short
451:51 - length if you're looking at a really
451:53 - long sequence for instance this
451:54 - technique is used for dna sequencing and
451:57 - we were looking at two dna strands or
452:00 - two in two dna strings and trying to get
452:03 - the common subsequence out of them and
452:04 - these can go into thousands or sometimes
452:06 - millions of
452:08 - elements
452:09 - that would make it rather slow
452:12 - okay so we do want to improve this
452:15 - algorithm further
452:17 - so let's do that
452:19 - and before that we can just commit our
452:21 - work once again
452:23 - but the first thing before we improve
452:24 - the algorithm is to analyze its
452:25 - complexity how long does it really take
452:28 - okay and identify any inefficiencies
452:30 - now to analyze the complexity
452:34 - let's look at an example and let's
452:36 - consider the worst case now when does
452:38 - the worst case occur here we've seen
452:40 - that if two
452:42 - elements match then we simply have one
452:44 - sub problem or one recursive call but if
452:47 - the two elements or two elements of the
452:49 - sequences don't match then we have two
452:51 - recursive calls
452:53 - so if you have two completely distinct
452:55 - sequences
452:57 - where none of the sequences none of the
452:58 - elements match
453:00 - then each time we will end up with two
453:01 - sub problems so that becomes the worst
453:03 - case so the worst case occurs each time
453:05 - we have two sub problems where the
453:07 - sequences have no common elements and
453:08 - here's an example this is a sequence of
453:10 - length six
453:12 - here's a sequence of length eight
453:15 - and this is what the tree will look like
453:16 - so now we have no longer put the actual
453:18 - sequences we've simply put what is the
453:20 - length of the string that we started
453:22 - with so here we start out with strings
453:24 - of length six and eight and then we say
453:25 - that we either ignore the first
453:27 - character of the first string or the
453:29 - first sequence or we ignore the first
453:31 - element of the second sequence and that
453:33 - gives us two sub problems and this time
453:35 - this
453:36 - the sequences have length five and eight
453:38 - in this case and six and seven in this
453:39 - case okay so we either reduce one from
453:42 - the left or we reduce one from the right
453:45 - and once again here we either reduce one
453:46 - from the left or we reduce one from the
453:48 - right so this way we create a tree and
453:50 - you can also see that a lot of common
453:52 - trees get created and that really is
453:54 - what is the inefficiency and we'll talk
453:56 - about that
453:57 - but what will happen here is five seven
453:59 - will then call four seven five six and
454:01 - five seven here will once again call
454:03 - four seven and five six
454:05 - and four seven and four seven will get
454:06 - repeated here and five six and five six
454:08 - will get repeated three times here so
454:10 - there's a lot of repeated calls that are
454:12 - going to occur and you can even see this
454:14 - here at the top you can see that alogy
454:17 - the problem was
454:18 - called repeatedly
454:20 - so that's really a source of
454:21 - inefficiency but
454:24 - now the question becomes
454:26 - that we know that all the leaf nodes
454:27 - will end at zero zero that's when the
454:29 - entire tree ends
454:32 - so can you count the number of leaf
454:33 - nodes
454:34 - okay can you count the num if you keep
454:36 - expanding this tree completely expand
454:38 - each of these don't skip any of them can
454:40 - you count the number of leaf nodes now
454:42 - if you count the number of leaf nodes we
454:43 - know that in a binary tree
454:47 - the number of leaf nodes if the number
454:48 - of leap nodes is
454:50 - l um then the height of the tree is
454:54 - if the number of leaf nodes is n then
454:55 - height of three is log n
454:57 - and based on that we can actually
454:59 - determine the actual size of the tree as
455:00 - well
455:02 - so we know
455:04 - that
455:05 - to count the number of unique paths from
455:07 - root to leaf will give us the number of
455:08 - leaves right so each time
455:11 - we have two choices we either reduce
455:13 - from the left or we reduce from the
455:14 - right so to get to 0 0 we would have to
455:17 - reduce all the elements from the left
455:19 - and we would have to reduce all the
455:20 - elements from the right that means if
455:22 - you have
455:23 - strings or
455:25 - if you have strings of length or
455:26 - sequences of length m and n then you
455:29 - would have to make m plus n choices
455:32 - in total
455:34 - and you so each time you have m you have
455:36 - to make m plus n choices and each time
455:38 - you have to choose whether you want to
455:39 - reduce from the left or from the right
455:41 - you have two choices and you have to
455:42 - make those two choices m plus n times
455:45 - that's the right way to put it really
455:47 - so that means each time you com you do
455:49 - two choices so you have two multiplied
455:51 - by two multiplied by two multiplied by
455:52 - two
455:53 - and you keep multiplying that and you
455:55 - will end up with two to the power of m
455:58 - plus n leaf nodes okay
456:00 - so here is an exercise for you draw this
456:03 - tree on a piece of paper
456:06 - mark out
456:07 - how
456:08 - the number of leaf nodes how the length
456:10 - of each part is m plus n figure that out
456:13 - and based on that can you conclude that
456:15 - it takes 2 to the power of m plus n
456:18 - leaves
456:20 - to complete this tree and if 2 to the
456:22 - power m of m plus n is the number of
456:24 - leaves then the total number of elements
456:26 - is in the tree simply double of that
456:29 - once again this is something that is
456:30 - very easy to verify you can check it
456:33 - here for instance if you just consider
456:34 - these two levels
456:36 - the
456:37 - if you have two leaves then the total
456:39 - number of elements in the tree is two
456:40 - plus one three actually it's double
456:42 - minus one so two into two four minus one
456:45 - three
456:45 - if you have three levels you can see
456:47 - here that if you have four leaves then
456:49 - the total number of elements in the tree
456:51 - is four into two eight minus one seven
456:53 - and you can see that here
456:55 - so it follows essentially that we have
456:57 - an exponential number of sub problems we
457:00 - have we are calling the
457:02 - recursive function an exponential number
457:03 - of times and inside the recursive
457:06 - function we are doing
457:08 - inside the recursive function we are
457:09 - doing a constant time work so you can
457:11 - see here that there's no there's no
457:14 - special work that we're doing all we're
457:15 - doing is some comparison and we're doing
457:17 - an addition both of them are constant
457:19 - time so we make 2 to the power of m plus
457:21 - n recursive calls inside each we do
457:23 - constant work so the time complexity is
457:26 - order of 2 to the power of m plus n okay
457:29 - that's a rough explanation we've not
457:31 - gone into a lot of depth because we've
457:32 - covered this over and over in three
457:34 - lessons but the exercise for you to is
457:37 - to verify how exactly it is 2 to the
457:39 - power of m plus n okay
457:42 - so that's our
457:44 - recursive solution
457:46 - and we know we now know that the time
457:47 - complexity is 2 to the power of m plus n
457:50 - let's just copy that over here
458:04 - and the inefficiency as we said in this
458:06 - algorithm is that we are calling the
458:07 - same problem
458:09 - we're calling the exact same problem the
458:12 - lcs recursive function is called with
458:14 - idx equal idx 1 equal to 5 and idx 2
458:16 - equal to 7 and at x 1 equal to 5 and at
458:19 - x 2 equal to 7 the same time twice so
458:22 - each of these sub problems will be
458:23 - called twice and then each of the sub
458:25 - problems within them will be called
458:26 - twice and of course some of these sub
458:28 - problems will once again get shared so
458:30 - there's a lot of repetition now there's
458:32 - a simple solution here which is simply
458:34 - to
458:35 - remember some of these results okay and
458:38 - this technique is called memoization
458:41 - and you may also just call it
458:42 - memorization because you're just
458:43 - remembering some of these things but
458:45 - memoization is a technical term for it
458:48 - and we remember these solutions in our
458:51 - dictionary called memo so what we are
458:53 - going to do is we are going to follow
458:54 - the same recursive strategy but this
458:56 - time we are going to maintain a
458:57 - dictionary
459:00 - called memo and we're going to track
459:02 - intermediate results within the
459:03 - dictionary and if we find an
459:05 - intermediate result already exists in
459:07 - the dictionary then we will not compute
459:09 - it again okay so let's see
459:12 - so now we write lcs memoized or let's
459:14 - just say lcs memo for short it takes a
459:17 - sequence one and it takes a sequence two
459:20 - and this time
459:21 - we
459:22 - create this dictionary called memo
459:24 - and then we write a function inside it
459:26 - so we will write a helper function a
459:28 - recursive helper function inside the lcs
459:30 - memo function so that it has access to
459:32 - sequence 1 and sequence 2 and we will
459:34 - simply started out with idx 1
459:37 - as 0
459:38 - and idx 2 as 0 as well right x1 will
459:42 - track the position in sequence one idx2
459:44 - will track the position in sequence two
459:47 - now the first thing we do is create
459:50 - using the two indices create a key so we
459:52 - are going to create the key idx one
459:54 - comma idx2
459:56 - and if the key is
459:58 - present in the memo so this is the way
460:00 - to check if a key exists in a dictionary
460:02 - then we simply return memo of key
460:05 - simple the problem is solved we don't
460:07 - have to solve this problem because it's
460:09 - already it's already something that
460:10 - we've solved if it isn't then we need to
460:13 - solve the problem and save it in the
460:15 - memo
460:16 - now here we know that we can now write
460:18 - our same three recursive cases now if
460:20 - the base case if idx 1
460:23 - is equal to the length of sequence 1
460:27 - or idx 2 is equal to the length of
460:30 - sequence 2
460:32 - then we simply set
460:35 - memo of
460:36 - key as
460:41 - 0 because by this point we have reached
460:43 - the end of the strings there's nothing
460:45 - left for us to compare
460:48 - lf idx sequence 1
460:52 - of idx 1
460:54 - equals
460:57 - sequence 2
460:59 - of idx 2. so in this case
461:02 - this is the case where the current
461:04 - characters are equal so this is if we go
461:06 - go up here and look at the tree once
461:08 - again
461:09 - this is a case like this where the
461:11 - current characters that we are pointing
461:12 - at are equal so in that case we simply
461:15 - return
461:16 - we simply get the result as one plus
461:19 - the result for the remaining
461:22 - with the first character removed
461:26 - so in this case we simply set memo of
461:28 - key
461:30 - to
461:32 - 1 plus
461:34 - we call the recursive function again
461:36 - recurs
461:37 - idx one plus one and idx two plus one
461:41 - great
461:42 - else so this is the case where the two
461:44 - elements are not equal so and this is
461:46 - where we have two options i'm not going
461:48 - to write the two options separately
461:49 - let's just do a max directly here
461:51 - max
461:53 - and we say
461:55 - recurs with idx 1 plus 1
461:59 - comma
462:00 - idx2 and recurse with
462:03 - idx 1 comma idx 2
462:07 - plus 1
462:09 - okay
462:10 - and finally from the recurse function we
462:11 - return memo of key so we have whichever
462:14 - case it is we have computed the result
462:16 - and saved it in the memo
462:18 - so this time
462:22 - these computations will not get repeated
462:24 - again and again
462:27 - and let us now return
462:30 - recurs of zero comma zero
462:32 - because zero comma zero is the entire
462:35 - string
462:37 - and that's it
462:40 - and this is the common strategy that you
462:41 - should apply
462:44 - whenever you come up with a recursive
462:45 - solution and you see the inefficiency
462:48 - coming because of the same problem being
462:50 - called again and again and again
462:52 - this is where you need to apply this
462:53 - technique called memoization right and
462:55 - in this technique you will then be able
462:58 - to
463:01 - simply store intermediate results so
463:02 - it's really simple you just create a
463:04 - dictionary and then you add one or two
463:06 - lines of code here and you make sure to
463:08 - save the result in that dictionary
463:10 - whenever you compute a result the next
463:12 - time you don't have to compute it okay
463:15 - and we can test it out we can test it
463:16 - out with all the test cases
463:20 - evaluate the test cases
463:22 - so lcs
463:24 - memo and lcs tests
463:29 - and you can see that all the test cases
463:31 - pass
463:32 - now not only do all the test cases pass
463:34 - you can see that the
463:36 - time taken is now lower
463:44 - okay so
463:46 - that's nice the time taken is now lower
463:48 - now we went from 450 milliseconds if we
463:51 - just go up here you can see that it took
463:54 - 480 milliseconds
463:57 - for the
463:58 - for finding the longest common
463:59 - subsequence between
464:02 - precipitation and serendipitous but in
464:05 - this case it only took about 0.234
464:09 - which is 0.2 milliseconds so it is 2 000
464:11 - times faster even for strings of length
464:14 - 7 or 8
464:15 - and that's a huge boost
464:17 - let's analyze the complexity here
464:21 - let's uh look at the complexity now a
464:24 - quick and easy way to find the
464:26 - complexity of the solution
464:29 - is to see where the computation how many
464:31 - times the computation can occur now this
464:32 - is where the bulk of the computation is
464:34 - occurring in a recursive call
464:38 - and this computation is avoided
464:40 - if we already have
464:43 - something in the memo okay
464:45 - so that means that the only number of
464:48 - computations that we need to do
464:50 - is equal to the maximum number of
464:52 - elements that can end up in the memo now
464:55 - what are the keys in the memo look like
464:56 - the keys in the memo look like idx 1 and
464:58 - idx 2
465:00 - great and what values can these take idx
465:03 - 1 can take
465:05 - 0 to
465:07 - m values if m is the length of sequence
465:09 - 1 let's say and idx2 can take
465:12 - 0 to n values if n is a sequence a
465:15 - length of sequence 2. so in total the
465:18 - possible number of keys is
465:20 - m times n
465:23 - the possible number of keys is m times n
465:25 - the possible number of things that you
465:27 - need to store in the memo is m times n
465:29 - and for each of them you do constant
465:31 - work and then the next time you try to
465:33 - access this you do not need to do the
465:34 - work you do not need to call any
465:36 - recursion you can simply access the
465:38 - memoization right
465:41 - so what that tells us is the complexity
465:43 - of this case and in any memoization case
465:46 - in general
465:47 - is
465:48 - equal to the number of keys which in
465:49 - this case is m times n so the time
465:52 - complexity here is order of m times n so
465:55 - we've gone from 2 to the power of m plus
465:58 - n
465:59 - which if you if m plus n was equal to 30
466:01 - would be 1 billion
466:04 - to
466:06 - m time order of m times n so let's say
466:08 - both strings were 15 and 15 so that
466:10 - would just be 225 operations so we've
466:13 - gone from 1 billion operations to
466:17 - 225 operations simply by storing
466:19 - intermediate results and it's a very
466:21 - powerful technique
466:22 - that we apply all the time so now you
466:24 - can see here that the first time five
466:26 - seven is computed
466:28 - the next time phi 7 does not need to be
466:30 - computed again and that's why this tree
466:32 - here is actually marked out so this is
466:34 - the tree for memoization this the first
466:37 - time 4 7 is computed it never needs to
466:39 - be computed again so this entire tree of
466:40 - computation gets eliminated and
466:42 - similarly this entire tree of
466:43 - computation gets eliminated we are
466:45 - eliminating
466:47 - from
466:48 - 1 billion computations almost
466:51 - all except 225 computations so we are
466:53 - left with practically nothing and that
466:55 - speeds up your algorithm by a huge huge
466:57 - factor
466:59 - so that's memoization
467:01 - and
467:02 - as i said it's really easy to compute
467:04 - the
467:06 - time complexity of memorization just
467:08 - simply count the number of keys
467:10 - and then just track how much work do you
467:13 - need to compute each key
467:15 - assuming that you already have the
467:17 - recursive solutions for the remaining
467:18 - okay so how much work do you need to
467:20 - compute each key using some other
467:23 - existing solutions now in this case that
467:25 - was constant because all we needed to do
467:26 - was
467:27 - compare and add
467:33 - okay and i'll let you write here a
467:36 - simple optimized so a
467:39 - plain english explanation of
467:41 - memorization it's worth a it's a good
467:43 - exercise to try out but what we will
467:45 - also look at is another technique called
467:47 - dynamic programming now the downside
467:49 - with memoization is that it requires
467:52 - recursive calls
467:53 - and while it's not a problem for small
467:56 - cases when you have really large
467:58 - problems
468:00 - recursion has an overhead and the
468:01 - overhead for recursion
468:03 - if you see this way is that for this
468:05 - function execution to complete you need
468:07 - this function execution to complete and
468:09 - this to complete and for this to
468:10 - complete you need this to complete and
468:12 - this to complete right so the idea here
468:14 - is that for
468:15 - each new recursive call
468:19 - takes more space in the memory and it
468:21 - also takes longer because now we have to
468:22 - allocate some memory and then set up
468:24 - that function stack
468:26 - the function stack for the execution of
468:29 - that function
468:30 - so if you have a large tree
468:32 - then you're creating hundreds thousands
468:34 - or possibly millions of open functions
468:36 - all of which have their own memory and
468:38 - that can eat up a lot of memory and
468:40 - sometimes that can also take up
468:42 - a take longer time
468:44 - so the solution to replace recursion
468:47 - is iteration
468:49 - and how do we do that we do that using a
468:51 - technique called dynamic programming
468:53 - so we'll do almost the same thing there
468:55 - are a few changes here
468:58 - instead of using a dictionary to track
469:01 - intermediate results we will create a
469:02 - matrix because we know that
469:06 - sequence one uh the idx one can go from
469:08 - zero to n uh where or zero to n one
469:11 - let's say where n one is the length of
469:13 - sequence one and sequence idx2 can go
469:15 - from 0 to n2 where see
469:17 - n2 is the length of sequence 2 and what
469:20 - we can do is we can use a for loop or a
469:22 - couple of for loops to fill out all
469:24 - these sub problems
469:25 - without having to
469:27 - require a recursion okay and this is how
469:29 - we'll do it
469:31 - so let's say these are the two strings
469:33 - that we're working with this is string
469:34 - one t a c g t and this is string two and
469:37 - these this is what
469:38 - dna sequences look like
469:40 - so what we'll do is we will create a
469:42 - table of size n plus one plus one
469:45 - and
469:46 - n one plus one and n two plus one so you
469:48 - can see that
469:49 - there are
469:50 - n one plus one rows so if if this is of
469:52 - length n one these are n one rows and
469:54 - then there's an additional row
469:56 - and similarly there is there are n2 plus
469:58 - one rows here so if this is of length n2
470:01 - there are there are n2 plus one columns
470:04 - so you can see these are n2 columns and
470:06 - there is an additional column here
470:09 - and
470:10 - table of inj so let's say table of uh if
470:13 - i and j are 0 so i is a pointer for
470:17 - the first sequence and j is a pointer
470:18 - for the second sequence so i
470:20 - selects a row and j selects the column
470:23 - so table of i and j represents the
470:25 - longest common subsequence
470:27 - of
470:28 - sequence 1 up to i
470:31 - which means sequence 1
470:36 - so here if let's say i was 1 and j was
470:39 - 1.
470:42 - so this represents the longest
470:44 - subsequence of sequence 1 up to i
470:46 - so
470:47 - all the positions before 1 which means
470:51 - only the 0th position just t
470:53 - and sequence two up to j which means all
470:55 - the positions up to the first position
470:58 - of up to up to one so which means only
471:00 - the zeroth position
471:01 - so which means a okay so table one and
471:03 - uh table i j represents the longest
471:05 - common subsequence of
471:08 - these two of just a and t which is zero
471:11 - on the other hand if we skip ahead a
471:12 - little bit
471:14 - if we skip ahead to let's say this
471:15 - position you can count here i goes zero
471:18 - one two three four five six
471:21 - so this is 6 here
471:23 - and here we have
471:26 - 0 1
471:27 - 0 1 2 3
471:29 - so this is so this is table of 6 comma 3
471:33 - the table of 6 comma 3
471:35 - takes the first
471:37 - six elements
471:39 - which is ta gtca
471:42 - and the first three elements aga of
471:45 - sequence 2
471:47 - and it stores the result of the longest
471:49 - common subsequence between these two
471:52 - okay
471:53 - so i'll just let you look at the table
471:54 - and maybe even draw the table on a piece
471:57 - of paper and verify that the length
471:58 - three is right you can see here a g a
472:01 - a g a occurs here so a g a is a
472:03 - subsequence of t a g t c a so the
472:05 - longest common subsequence between them
472:07 - is three
472:10 - now
472:11 - what we'll do is we will now compare the
472:14 - next elements
472:16 - of
472:17 - we will now compare sequence 1 of i in
472:19 - sequence 2 of j so let's say we are
472:21 - looking at
472:25 - let's pick an example let's say sequence
472:27 - let's say i has the value
472:30 - i has the value 0 1 2 3 4 i has another
472:32 - value 0 1 2 i has the value 2 and let's
472:36 - say j has the value
472:38 - 1 so 0 1 so if we compare sequence 1 of
472:41 - i
472:42 - so which is g
472:44 - and sequence 2 of a
472:46 - sequence 2 of j which is also g and if
472:49 - they're equal so if they're equal
472:52 - then
472:53 - table of i plus 1 on j plus 1 which is
472:56 - this value
472:57 - right so remember i is 2 and j is 1
473:01 - so table 1 of
473:03 - i plus 1 so table 1 of 3 is 0 1 2 3
473:07 - and table and table 1 of i plus 1 j plus
473:10 - 1 is table 1 of
473:14 - three
473:15 - and
473:16 - a table a table of i plus one and j plus
473:19 - one
473:21 - i being two and j being one
473:24 - is table one of
473:26 - three and 2 and table 1 of 3 and 2 is
473:30 - the value 2.
473:32 - so this value is obtained by adding 1
473:36 - to table 1 of i comma j so because these
473:39 - two elements are equal
473:42 - we we can then
473:44 - say that if we take the longest common
473:45 - subsequence of t a
473:47 - and a
473:48 - and add one to it that will give us the
473:50 - longest common subsequence of
473:53 - tag and a g so the exact same logic as
473:55 - recursion
473:57 - we have simply
473:59 - now reversed it so we now now looking at
474:01 - the last element so that we can keep
474:03 - filling out the last value using some
474:05 - previous values okay so this is one case
474:07 - similarly here's one other case where a
474:09 - and a are equal
474:10 - so the longest common subsequence
474:12 - between t a g t c a and the longest
474:14 - common subsequence between a g a
474:17 - is one plus the longest common
474:18 - subsequence between t a g t c
474:21 - and a g
474:23 - okay one plus this value
474:26 - so that's one case the other case is if
474:28 - they're not equal so let's look at
474:30 - this value for example over here
474:33 - so we have ta gt on this side and then
474:35 - we have
474:37 - okay let's let's look at this one uh we
474:39 - have ta gt on this side and we have a g
474:41 - ac on this side
474:43 - now t
474:44 - is the element here and c is the element
474:46 - here
474:48 - they are not equal
474:49 - so that means
474:51 - the longest common subsequence between
474:53 - these two either does not contain t
474:55 - or it does not contain c it cannot
474:57 - contain both obviously because
475:00 - one of the strings has to end
475:04 - so if it does not contain t then it is
475:06 - this result and if it does not contain t
475:09 - or if it does not contain c then it is
475:11 - this result so we simply take the
475:12 - maximum of these two maximum of these
475:14 - two to get the result for this if these
475:16 - two elements are not equal
475:18 - and that is how you fill out the table
475:20 - you start from the top the first row is
475:21 - zeros because we are we have empty
475:23 - strings and the first column is also
475:25 - zeros because we have empty strings to
475:26 - fill out an element you compare if the
475:28 - two elements are equal and if they are
475:31 - equal we simply add one to the
475:33 - diagonally left
475:35 - top left element if they're unequal then
475:38 - we take the maximum of the element above
475:41 - it and the element to the left of it and
475:42 - that way we fill out the entire table
475:44 - okay so that's the dynamic programming
475:46 - solution and i know this can seem a
475:49 - little bit complicated honestly i still
475:52 - get
475:53 - confused with dynamic programming a lot
475:55 - of times and that's why i like to just
475:56 - draw tables and
475:58 - write things out carefully
476:02 - okay
476:03 - and and especially you have to be
476:04 - specially careful with indices because
476:07 - here we are saying that if sequence i
476:08 - one i and sequence to j are equal then
476:10 - table one of i plus one and j plus one
476:13 - is one plus table i j so b just watch
476:15 - the indices carefully here but let's
476:17 - implement the solution
476:21 - let's implement the dynamic programming
476:23 - solution
476:24 - so let's say
476:26 - lcs
476:27 - dynamic programming so we'll just say dp
476:29 - here
476:31 - and we have sequence one
476:33 - and we have sequence two
476:37 - and the first thing we need is we need a
476:39 - table of results
476:41 - now this table
476:43 - for it let's just grab n1 and n2 so
476:45 - length of sequence one
476:48 - and
476:50 - length of sequence two
476:54 - and now we need to create a table with
476:56 - all zeros how do you create a table with
476:59 - all zeros the way to do it a way to
477:00 - create a list of zeros is this
477:03 - zero for underscore in let's say n1
477:06 - let's give n1 and n to some values
477:12 - now if you want to create a list of
477:13 - zeros of length and one use you simply
477:15 - say
477:17 - zero for underscore or zero for x you're
477:19 - simply ignoring whatever value you're
477:21 - getting from a range
477:22 - arrange n one and that's going to give
477:24 - you a list of zeros but we don't want a
477:26 - list of
477:27 - n one zeros we want
477:30 - these one these want to be rows so we
477:31 - want each of these to itself be a list
477:33 - of zeros of length n2
477:36 - so zero for
477:38 - x in
477:39 - range n2
477:42 - and now we have you can see that we have
477:44 - five rows one two three four five then
477:46 - we have seven columns
477:48 - one two three four five six seven
477:51 - so this is the table that we want to
477:53 - create initially okay now this is a
477:55 - table that we've created this is going
477:56 - to be this exact same table
477:59 - and we're just simply going to start
478:01 - each string from position 1 this time
478:02 - not from position 0 because we want to
478:05 - have this additional row where we don't
478:07 - consider either of these that just makes
478:08 - computations a little easier
478:12 - now we say for idx one in len
478:16 - at x1 and range n1
478:19 - so that's that's going to iterate over
478:20 - the rows and then for idx true
478:24 - in range n2
478:27 - and that's going to iterate over the
478:28 - columns
478:30 - and first we compare
478:33 - if sequence one of idx 1
478:38 - is equal to
478:41 - sequence 2
478:44 - of idx2
478:45 - if they're equal
478:47 - then we can fill out table of i plus 1
478:53 - and j plus 1
478:56 - as 1 plus
478:57 - table of i j
479:02 - okay and we can see this
479:04 - we can see this here suppose the first
479:06 - elements were equal so suppose this was
479:09 - suppose idx 1 was 0 and idx 2 was also 0
479:11 - suppose they were equal
479:13 - then this value should be 1 so this
479:15 - value should be 1 plus the diagonally
479:16 - top element and that holds true anywhere
479:19 - within the list so wherever you have two
479:21 - elements equal like g and g are equal
479:23 - here so this value is one plus this
479:25 - value
479:29 - else
479:30 - we have table
479:33 - i plus 1
479:39 - and j plus 1
479:44 - is max of
479:46 - table
479:49 - i comma j plus one so you stay in the
479:52 - same row
479:56 - or you you go to the previous row or you
479:58 - go to the previous column which is table
479:59 - of
480:01 - i plus 1
480:03 - comma j and this is the previous column
480:05 - okay so
480:07 - this is this case where g and a are not
480:09 - equal so if g and a are not equal then
480:11 - we take the maximum of these two values
480:14 - and that's it that is going to fill up
480:16 - the table for us and then we simply say
480:18 - return
480:19 - table we simply want the bottom right
480:21 - element
480:22 - we can simply say return table minus one
480:25 - minus one so this is going to get that
480:26 - last row last column and that's our
480:28 - dynamic programming solution
480:31 - let's do evaluate test cases here
480:46 - okay turns on there's no i okay let's
480:48 - just call this i
480:50 - and j
480:55 - turns out idx 1 is not defined
480:58 - let's just make these i and j
480:59 - now that we're doing this coding live
481:01 - you can see that even after a decade of
481:04 - coding i still make all of these
481:08 - issues says the list a list index is out
481:11 - of range it seems like i plus 1 and j
481:14 - plus 1.
481:15 - ah that's because remember we need an
481:17 - additional row and an additional column
481:20 - to track the case where either of the
481:22 - strings is empty so we need to get range
481:25 - n two plus one here
481:28 - and we need to get range n one plus one
481:29 - here okay that's why it helps to have
481:32 - test cases so that you can fix all of
481:33 - these issues now you have test k0 it
481:36 - passes and test case 1 2 3 all of them
481:39 - pass you can see that all test cases
481:40 - have passed and you can also verify that
481:43 - the amount of time it took is now lower
481:46 - than the amount of time it took for
481:47 - memoization
481:49 - okay
481:50 - and
481:51 - so that's the dynamic programming
481:53 - approach you simply create a table and
481:54 - you fill out the table
481:56 - sometimes just
481:58 - working with indices within the table
482:00 - can get confusing so it helps to work
482:03 - with it on paper
482:04 - and make it clear to yourself and then
482:06 - write it in english that's why we've
482:08 - written it in plain english here
482:11 - and now an exercise for you is to verify
482:13 - that the complexity of this dynamic
482:14 - programming approach is order of n1
482:17 - times n2 so which is the same as
482:19 - memoization
482:21 - and it's actually more straightforward
482:22 - to see here because you have two for
482:25 - loops
482:26 - and then each of these for loops
482:29 - you're simply doing a comparison and an
482:31 - addition
482:32 - and there's not even any recursion to
482:34 - very
482:35 - very
482:36 - there's not even any recursion for you
482:37 - to worry about
482:39 - so you just do a comparison and you do
482:41 - an addition or you take a maximum pretty
482:43 - straightforward
482:45 - so order of n1 times n2 and it does not
482:47 - even
482:49 - invoke an another function so it does
482:52 - not take up too much memory it does not
482:54 - take up too much time it's very very
482:56 - efficient
482:57 - and this is how you solve pretty much
482:59 - every dynamic dynamic programming
483:01 - problem
483:02 - you write a recursive solution you come
483:04 - up with the brute force solution and
483:06 - keep in mind that recursion is
483:09 - almost always
483:11 - the way to go about creating a brute
483:13 - force solution so you come up with a
483:14 - recursive solution
483:17 - and then you identify you draw the
483:18 - recursion tree
483:20 - and if you see that the same sub problem
483:21 - is being called again and again
483:24 - that is a point where you can introduce
483:25 - memoization so you introduce memoization
483:27 - and sometimes you can just write the
483:29 - memoized solution and that's enough
483:31 - because it's easy to reason about you
483:32 - just put in a memo and you're done with
483:34 - it um even the interviewer or
483:37 - the coding assessment will accept that
483:39 - solution
483:40 - but in some cases you will be asked to
483:42 - then remove the recursion and write it
483:44 - as a in an iterative fashion and that is
483:47 - when then you have to start drawing a
483:48 - table and think about what are the rows
483:51 - and columns in that table need to
483:52 - represent so here
483:54 - the i j element of the table represented
483:57 - the first the first i elements of
484:00 - sequence one and the first rj elements
484:02 - of sequence two what is the longest
484:04 - subsequence between them and we used
484:06 - that to build the next row and the next
484:08 - next column
484:10 - and we then filled out the entire table
484:12 - and we simply used the last value
484:14 - now
484:15 - again this is not very straightforward
484:17 - uh how to come up with this and the way
484:19 - you do that is by solving problems so if
484:21 - you solve five to ten dynamic
484:23 - programming problems you will get some
484:26 - intuition about how to build the tables
484:28 - and it's always very helpful to solve it
484:30 - on pen and paper first especially with
484:32 - dynamic programming so that it's clear
484:34 - to you
484:36 - what each element of the table
484:38 - represents otherwise you may make a lot
484:40 - of off by one errors like missing the
484:41 - plus one here or missing the plus one
484:44 - here
484:45 - and get confused just like i did pretty
484:47 - much
484:50 - and that's the time the time complexity
484:52 - is pretty straightforward in most cases
484:53 - it is simply the size of the table but
484:55 - sometimes you may have to do more than
484:57 - constant work here so keep that in mind
485:00 - see what it is that you're doing inside
485:01 - your loop now inside of inside your loop
485:03 - if you have to go back and check the
485:05 - entire length of the string so that will
485:07 - introduce another factor into the
485:09 - equation so keep that in mind but in
485:11 - most cases counting the iteration should
485:12 - be good enough to give you an idea of
485:14 - the time complexity
485:19 - okay so that's the first problem and let
485:22 - us just
485:23 - commit this
485:26 - and now it's saved
485:28 - to my profile
485:29 - if i just open this up here
485:32 - you can see that now i have this
485:35 - notebook called longest common
485:36 - subsequences and i can share it online
485:39 - whenever you work on a notebook it's
485:40 - always a good idea to make it public put
485:42 - it up on jovian all you need to do is
485:44 - run jobin.com and share it online just
485:46 - press the
485:47 - share button and then you can share it
485:48 - on twitter linkedin facebook or wherever
485:50 - you like
485:53 - so that's the first problem that we
485:54 - looked at
485:56 - now let's come back to lesson four
485:58 - and uh by the way the problems that
485:59 - we're talking about all the
486:01 - problem statements the graphs the images
486:04 - you can see them in the second link here
486:06 - but we will once again open up the
486:08 - problem solving template
486:10 - and now we'll use it for the second
486:12 - problem let me run this once again
486:18 - and we're going to look at the second
486:19 - problem which is the knapsack problem
486:23 - so let's read the knapsack problem it's
486:25 - also called the zero one knapsack
486:26 - problem here's there are many variations
486:28 - of this problem but here's one way to
486:30 - state it
486:31 - that you might come across
486:33 - or something similar you are in charge
486:35 - of selecting a football or a soccer team
486:38 - from a large pool of players
486:41 - and each player has a cost
486:43 - and a rating so
486:45 - there's a selection going on you have to
486:47 - come up with a team for this year
486:49 - and you have a large pool of players
486:51 - each player has a cost and each player
486:52 - has a rating
486:54 - now you have a limited budget
486:56 - so you need to build a team within the
486:57 - budget so what is the highest total
487:00 - rating of a team
487:01 - that you can create
487:03 - which fits within your budget okay so
487:05 - this is the question here you have to
487:06 - maximize the total rating
487:08 - but fit it fit the total cost within
487:11 - your budget so we have two variables
487:12 - here rating and variables rating needs
487:14 - to be maximized cost needs to be
487:17 - simply optimized to the extent that it
487:19 - fits in the budget and just a
487:21 - simplifying assumption here is that you
487:23 - can assume that there is no minimum or
487:25 - maximum team size
487:27 - this is simplification and later you can
487:29 - introduce a criteria there as well that
487:32 - you want to build a team of exactly 10
487:33 - people and see if you can also solve
487:35 - that problem in a way
487:38 - so that's the knapsack problem let's
487:39 - copy it over
487:44 - and
487:45 - here's a jupiter notebook a fresh
487:47 - problem solving template
487:50 - let's simply
487:51 - change the title here
487:57 - it is also called the zero one knapsack
487:59 - problem because each item can either be
488:02 - chosen
488:04 - or not chosen
488:08 - and let's give it a project name here
488:10 - too
488:22 - let's commit it
488:23 - and let's paste the problem statement
488:25 - here
488:30 - okay
488:32 - so that's the problem statement and this
488:34 - is a specific or a special form
488:38 - of
488:39 - a more general problem statement and we
488:41 - look at the general problem statement in
488:42 - a second
488:43 - we'll when we try to state the problem
488:45 - clearly but here's once again the
488:46 - systematic strategy will apply we will
488:48 - state the problem clearly identify the
488:50 - input and output formats come up with
488:52 - some example inputs and outputs and try
488:54 - to cover all the edge cases
488:56 - then we will come up with a correct
488:58 - solution for the problem and state the
488:59 - solution in plain english it just has to
489:01 - be simple correct solution not too
489:03 - complex
489:05 - then we apply the right technique to
489:07 - overcome the inefficiency and then we
489:09 - so we analyze the algorithm and identify
489:11 - any inefficiencies after implementing
489:14 - the solution and finally we apply the
489:16 - right technique to overcome the
489:17 - inefficiency and then repeat the process
489:19 - of stating the solution implementing it
489:21 - and analyzing it
489:24 - so to state the problem clearly
489:26 - what we can do is we can abstract out
489:28 - the problem in more general terms and
489:30 - that is what is stated here
489:35 - and let's just grab that and we'll take
489:36 - a look
489:44 - so here we have we are given n elements
489:47 - and each of which has a weight and a
489:49 - profit
489:50 - so you have n elements and here's the
489:52 - profit of each element and here's the
489:54 - weight you can of each element so you
489:56 - need to determine the maximum profit
489:58 - that can be obtained by selecting a
490:00 - subset of the elements weighing no more
490:02 - than a given weight w
490:04 - so
490:05 - you have a capacity a maximum capacity
490:07 - let's say the maximum capacity is 15
490:10 - and you have to select certain elements
490:12 - so that you fill out
490:15 - the total weight is no more than the
490:16 - capacity and the total profit is
490:19 - maximized
490:20 - that's and this is why it's called the
490:21 - knapsack problem it's assuming here you
490:23 - have a bag or a knapsack with a capacity
490:25 - of 15 kilograms and these are the
490:27 - weights of the items and these are the
490:29 - profits
490:30 - now in this case you can see in this
490:32 - example the optimal selection is
490:35 - these four elements which have the
490:37 - weights five
490:38 - three two and five so that you fill up
490:40 - the total capacity of 16 or 15
490:43 - and
490:44 - the of the solution on the maximum
490:46 - profit that you can obtain is 7 plus 4
490:48 - 11 plus 5 16 plus 3 19. now you can try
490:52 - other combinations and verify that this
490:54 - is actually the best solution
490:57 - do give it a shot
491:01 - so what are the inputs here so we have
491:03 - it's pretty clear we have an input
491:07 - weights
491:08 - so these are the weights of
491:10 - the this is a list of
491:14 - numbers
491:15 - containing weights
491:18 - and then you have profits
491:22 - a list of numbers
491:24 - containing profits
491:26 - and this should have the same length as
491:28 - weights
491:30 - and then finally you have a capacity
491:36 - the maximum
491:38 - weight allowed
491:41 - and there you go
491:43 - and now we have outputs so now
491:46 - the output would simply be the max
491:49 - profit
491:51 - so this is the
491:55 - maximum profit
491:58 - that can be obtained
492:03 - by selecting elements
492:10 - of total weight
492:12 - no more than w or no more than capacity
492:16 - okay
492:18 - great so that gives us
492:20 - a
492:22 - pretty good starting point now we can
492:24 - write a function signature here so we
492:26 - write max let's say def max profit
492:31 - and we can give it weights and we can
492:34 - give it
492:36 - profits and we can give it a capacity
492:41 - and we pass
492:45 - so now we have defined the problem we
492:47 - have stated we have identified input and
492:49 - output formats now we need to come up
492:50 - with some example inputs and test cases
492:53 - once again we have listed out a few test
492:54 - cases here so we will have a few generic
492:57 - test cases
492:59 - where you have just a random set of
493:01 - weights and profits and you identify the
493:05 - knapsack the optimal solution then
493:07 - here's one option where all of the
493:09 - elements can be included
493:10 - you can take everything here's another
493:13 - option where none of the elements can be
493:14 - included
493:16 - you have to think about all these
493:17 - scenarios
493:18 - here's one where only one of the
493:20 - elements can be included then you may
493:22 - also think about areas where
493:24 - you do not use the complete capacity
493:29 - okay you do not use the complete
493:31 - capacity
493:33 - because the optimal solution is actually
493:35 - taking a lower capacity so there may be
493:36 - a way to fill out to capacity but that
493:39 - may have a lower profit
493:41 - than another option which takes less
493:43 - than the complete capacity but has a
493:45 - higher profit so think about some cases
493:47 - here
493:48 - think about some good test cases here
493:50 - and
493:52 - i will just copy over these for now
493:56 - and then what we'll do is we will
493:57 - express these test cases once again as
494:00 - dictionaries so you have test 0 test 1
494:03 - s2 all of these expressed are
494:04 - dictionaries and these are covering all
494:06 - the test cases that are mentioned here
494:08 - you can see here are some weights and
494:09 - some profits and the capacity is 165 and
494:12 - then the optimal solution is 309 now we
494:15 - are simply asking here for the optimal
494:17 - solution the maximum
494:19 - profit that can be obtained but an
494:21 - extension of this problem is to identify
494:23 - which are the elements that should be
494:25 - chosen
494:26 - and it's a simple extension it's a good
494:28 - exercise for you to try out and you can
494:30 - discuss it in the forums
494:32 - we have test zero test one test two
494:35 - test three and four and five so we have
494:37 - a total of six six test cases let's copy
494:40 - over these test cases here
494:45 - and let's put them here into a single
494:48 - string and that gives us the test cases
494:50 - okay
494:51 - now
494:52 - coming up with the solution
494:56 - so once again the first step is to try
494:58 - and come up with a recursive solution
495:00 - and a recursive solution is again quite
495:02 - straightforward we'll write a recursive
495:04 - function
495:05 - max profit
495:07 - that given an index so this time we have
495:09 - just one sequence so given an index
495:10 - within the sequence so let's say our
495:12 - index idx
495:14 - it computes
495:16 - the maximum profit that can be obtained
495:19 - using the elements from idx onwards so
495:22 - 31547 using all of these elements idx
495:25 - onwards
495:29 - the maximum profit that can be obtained
495:31 - right and
495:33 - using a given capacity
495:35 - so it will take an index
495:38 - so it will take an index and a capacity
495:42 - so if let's say the idx is one so it
495:45 - will then look at just these elements
495:47 - and if the capacity is 10 so it will try
495:49 - to fill the capacity of 10
495:53 - and that's a recursive function and why
495:55 - are we creating a recursive function
495:56 - like this
495:57 - there's a simple reason now suppose idx
495:59 - has the value 1 and the capacity is 10
496:02 - or let's say the capacity is 3
496:04 - then the weight of this element is
496:06 - greater than the capacity so that means
496:08 - it cannot show up
496:11 - it cannot be selected because it cannot
496:13 - fit inside the bag the knapsack that we
496:15 - have so then
496:17 - the solution for
496:19 - this sub problem with idx equal to 1 and
496:22 - capacity equal to 3
496:25 - is same as the solution for this sub
496:28 - problem with this element removed
496:29 - because you cannot include this element
496:31 - within the knapsack right so if you
496:33 - remove this element and simply consider
496:36 - these elements
496:38 - the remaining elements which essentially
496:39 - means idx plus one
496:41 - so max profit of idx plus one
496:44 - profit uh of weights idx 1 profits idx 1
496:48 - and capacity
496:50 - is the answer for max profit of weights
496:53 - idx profits idx and capacity because the
496:56 - current weight 5 is greater than the
496:57 - capacity 3 which is which the recursive
497:00 - function has been invoked with so that's
497:02 - one option but the more general case is
497:04 - that you have enough capacity so let's
497:06 - say you have a capacity of 10 recursion
497:08 - was called with a capacity of 10 and you
497:10 - are at idx 1 so then you have two
497:13 - choices
497:14 - either you include this element in your
497:18 - knapsack or you do not include this
497:20 - element in your option because you don't
497:22 - know whether the optimal solution will
497:24 - have this element or not so you try both
497:27 - so there are two possibilities we either
497:29 - pick weights idx this element or we
497:31 - don't
497:33 - and what we can do is we can simply
497:34 - compute the result in both cases and
497:36 - pick the maximum
497:38 - so if we don't pick weights idx
497:41 - then once again
497:42 - if we don't pick this element so the
497:43 - capacity remains the same let's say the
497:45 - capacity was 10 so we simply try out to
497:47 - fill out the capacity of 10 using the
497:49 - remaining elements so we simply call max
497:51 - profit with weights idx plus 1
497:54 - profits idx plus 1 onwards and the
497:56 - remaining capacity which is 10
497:58 - but if we do pick the element
498:00 - if we pick the element and we had a
498:02 - capacity of 10
498:03 - then the optimal then the
498:06 - solution the best solution in this case
498:08 - will have a profit 3 more than the
498:11 - solution for this case
498:13 - and since we also used of some capacity
498:15 - so we need to
498:17 - add 3 in the profit and we need to
498:19 - subtract 5 from the capacity right
498:21 - so if we pick weights idx then the
498:24 - maximum profit for this case is profits
498:27 - of idx plus
498:29 - max profit of weights idx plus 1 onwards
498:32 - profits idx plus on onwards but because
498:34 - we've used up some capacity we reduce
498:36 - the capacity in the recursive call okay
498:38 - and that is why a recursive call takes
498:40 - both an index and a capacity
498:43 - okay i hope that makes sense
498:46 - so here's a recursive tree that tells
498:48 - you the same thing we started the first
498:50 - index and we we have the capacity and if
498:53 - we don't pick the first element then we
498:56 - sim the answer is simply
498:58 - the
499:01 - to the best solution for second index
499:04 - onwards with the same capacity if we do
499:06 - pick the first element then the answer
499:07 - is the second solution onwards
499:10 - with the reduced capacity with the
499:13 - profit added okay
499:15 - and then we simply take the maximum of
499:16 - these two cases so we call these two
499:18 - recursive calls and then we simply take
499:20 - the maximum of these two cases to get
499:22 - back
499:25 - the final result or the final best
499:27 - answer
499:28 - and the final end case is that if we've
499:30 - reached the end if weights idx onwards
499:32 - is empty if the index that we're
499:34 - tracking has reached the very end then
499:36 - irrespective of what the capacity is the
499:38 - maximum profit is in that case is zero
499:44 - so let's try and implement this now
499:47 - let's copy this over
499:51 - as the explanation
500:06 - and let's try and implement the solution
500:08 - let's say let's call it max profit
500:11 - recursive
500:15 - and this is going to take a set of
500:17 - weights it is going to take a set of
500:19 - profits and it is going to take a
500:21 - capacity and is also going to take an
500:24 - index which the index will start out at
500:26 - zero
500:28 - so now if the index is we start with the
500:31 - base case so if i dx
500:34 - equals the length of weights
500:37 - in this case there's nothing left to do
500:38 - we simply return 0 because we don't have
500:40 - any more elements
500:42 - then we check
500:46 - if the weights idx
500:49 - is so the current element is greater in
500:51 - weight than the capacity
500:53 - then it's a pretty straightforward
500:54 - solution we simply return
500:58 - max profit
501:02 - recursive
501:04 - of
501:06 - weights
501:07 - profits
501:09 - capacity plus one
501:11 - sorry capacity and idx 1.
501:14 - so we simply ignore this element because
501:16 - we cannot fit it in the capacity that we
501:18 - have
501:19 - else we have two options
501:21 - we have option one option one is even
501:24 - though it can fit within the bag
501:26 - we don't take it we every because the
501:28 - optimal solution may still not have it
501:30 - just because it fits does not mean we
501:32 - should take it so we look at the option
501:34 - one which is once again the same as this
501:36 - where we ignore this element and then we
501:38 - have we look at option two
501:40 - in option 2 we actually put this element
501:42 - into the bag so since we are putting
501:45 - this element into the bag then we get we
501:47 - get profit from it so we get profits of
501:49 - idx
501:50 - and then we call max
501:52 - profits recursive
501:54 - and this time we call it with weights
501:57 - and profits
502:00 - and now the capacity has reduced a
502:02 - little bit
502:04 - because we have taken this element so
502:05 - now we can now we need to fill the
502:07 - remaining
502:08 - we fill the need to fill the bag with
502:10 - the remaining elements from idx plus one
502:12 - onwards with a limited capacity of
502:15 - capacity minus weights of idx
502:18 - and then finally we just put in idx 1 so
502:21 - that we can start calculating the
502:23 - solution from the next element onwards
502:26 - so that's max profit recursive
502:31 - again not very difficult it is just
502:33 - about
502:35 - six seven lines of code
502:37 - and let's try it out here's test zero
502:41 - let's try max profit recursive
502:46 - with test zero
502:49 - input
502:52 - and we need to get weights capacity and
502:54 - profit all of these out of it the simple
502:56 - way to do that is simply to put in star
502:58 - star and we'll get back all of these
503:00 - will get passed in
503:03 - capacity will get passed as a capacity
503:05 - parameter in weights will get passed
503:06 - against the weights parameter and
503:08 - profits as the profits parameter
503:11 - okay so we've encountered an error and
503:14 - that's completely fine
503:16 - completely fine to encounter an error
503:20 - i see so what we've done here is uh we
503:22 - have not really taken the maximum of
503:24 - these two we've just defined the two
503:26 - options so we do need to take max of
503:28 - option one
503:29 - and option two okay once again this is
503:32 - why helping test having test cases helps
503:35 - and you can see that now we call max
503:37 - profit
503:38 - and we can also add a timer here so max
503:40 - profit it takes 210 micro seconds but it
503:43 - result it returns a result 309
503:47 - great we get back the result 309 here
503:49 - which is what we expected
503:52 - so our function is working correctly we
503:54 - can even evaluate it on all the test
503:56 - cases so
503:58 - from joven dot python dsa
504:01 - we import
504:03 - evaluate
504:05 - test cases
504:11 - and then we simply call evaluate test
504:14 - cases
504:18 - on all the inputs so we pass in
504:21 - max profit
504:23 - recursive
504:25 - and then we pass in all the test cases
504:27 - as tests
504:29 - now you can see that we have these test
504:30 - cases and each test case seems to be
504:33 - passing just fine all six x test cases
504:36 - have passed and these are the times they
504:38 - took
504:40 - so that's your recursive solution pretty
504:42 - straightforward once you reason it out
504:44 - once you
504:47 - maybe just
504:48 - look at an example draw a tree of
504:50 - recursion yourself work it out on paper
504:52 - the code is in fact in most cases fairly
504:55 - simple
504:57 - and this is what the recursion tree
504:58 - looks like each time we make a choice to
505:00 - either include the element or not
505:02 - include the element and now you can
505:04 - reason the complexity very easily
505:05 - because now we have n elements for each
505:07 - one we keep making this choice so that
505:09 - means we end up with 2 to the power n
505:11 - leaves
505:13 - and from there it follows that
505:15 - the complexity of the recursive
505:17 - algorithm is order of 2 to the power n
505:18 - right so it could be 2 times or c times
505:20 - 2 to the power n but
505:23 - and in the bigger notation it's order of
505:26 - 2 to the power of n so it is exponential
505:28 - and complexity and why is it exponential
505:30 - complexity once again there are it's a
505:32 - possibility here that we may be
505:34 - computing a lot of things repeatedly
505:37 - because we are creating so many of these
505:38 - sub problems
505:41 - so it's possible that we may be creating
505:43 - we may be
505:44 - recomputing a lot of data here so now
505:47 - the
505:49 - task for you or the an exercise for you
505:51 - is to write the memoized version of this
505:54 - so what is it that you need to memoize
505:56 - now the trick here is to look at what is
505:59 - changing within the recursive calls so
506:01 - now in max profit recursive
506:03 - you can see that weights and profits
506:05 - remains the same but it's the capacity
506:08 - and the idx that change so you can take
506:10 - the capacity comma the index the idx as
506:14 - the key in your memoization dictionary
506:17 - and each time you compute so each time
506:19 - let's say you compute this or you
506:21 - compute this or you compute this
506:24 - store the result in the dictionary
506:26 - before returning it and then at the
506:28 - beginning of the recursive function
506:30 - check within the dictionary
506:32 - if this value is already present okay so
506:35 - remember what we did for longest common
506:37 - subsequence we defined a recursive
506:39 - function internally we defined a memo a
506:42 - dictionary internally
506:44 - and the recursive function kept either
506:46 - checking the dictionary or filling the
506:48 - dictionary if it could not find a value
506:50 - and that could eliminate a lot of the
506:52 - repeated work
506:54 - in your problem okay so that's the
506:56 - challenge for you to try out implement
506:58 - the memoize solution
507:02 - and what we'll do is we will go ahead
507:04 - and we will
507:07 - implement the dynamic programming
507:09 - solution so let's just commit our work
507:11 - once again and we've analyzed the
507:13 - algorithms complexity in recursion it's
507:16 - order 2 to the power of n
507:19 - in memoization now that's an exercise
507:22 - for you what do you think the complexity
507:24 - will be
507:24 - well let's apply dynamic programming so
507:26 - let's look at a dynamic programming
507:28 - solution
507:29 - now once again for dynamic programming
507:31 - you have to create a table you always
507:33 - almost always have to create a table for
507:35 - dynamic programming and in this case
507:40 - we can see that there are n elements so
507:42 - there are n rows within the table
507:44 - because we have n elements to choose
507:45 - from
507:46 - and we we have a number of columns going
507:48 - from zero to capacity plus one going
507:51 - from zero to capacity and that's why
507:52 - there are total of capacity plus one
507:54 - columns
507:55 - and in fact what we can do is we can
507:57 - also include another column at the top
507:59 - here another row at the top here
508:02 - which we have not which is not shown
508:03 - here
508:06 - but what n represents
508:08 - n is the number of elements so what n
508:10 - represents or or what the a particular
508:13 - element in the table represents so table
508:15 - of i comma c what it represents is
508:19 - the maximum profit that can be obtained
508:21 - using the first i elements if the
508:23 - maximum capacity is c
508:26 - so if your maximum capacity is c
508:29 - let's say your maximum capacity is three
508:31 - what is the maximum profit that you can
508:33 - obtain using the first
508:36 - two elements so um here let's say we are
508:38 - at this position so using the first two
508:40 - elements
508:43 - of the list
508:48 - within this capacity okay so the first
508:51 - two elements have weights one and two
508:53 - and the capacity is three
508:55 - so you can
508:57 - you can actually pick uh sorry the first
508:59 - two elements are weights two and three
509:01 - and the capacity is three so you either
509:02 - pick this element or pick this element
509:04 - now if you pick this element the profit
509:05 - is one and if if you pick this element
509:08 - the profit is two so the solution is to
509:10 - pick this element and you get
509:12 - uh
509:13 - you fill the capacity three and you get
509:15 - a profit of two you cannot pick both
509:16 - because your capacity is three okay so
509:18 - that's the logic here
509:21 - a very simple visual representation now
509:23 - remember that there will also be a zero
509:25 - throw here which we have not shown
509:27 - but this is something that should be
509:29 - here another zeroth row so the zeroth
509:31 - row represents that you've not picked
509:33 - any of the elements and if you don't
509:34 - pick any of the elements it is simply
509:35 - going to contain all zeros and that's
509:37 - why it's not shown here the first row
509:40 - assumes that you have picked you can
509:42 - pick only the first element so you can
509:44 - you you can't pick the first element
509:46 - till a capacity of two and then from a
509:48 - capacity of two onwards you pick the
509:50 - first element and that has a maximum
509:51 - capacity
509:53 - of one
509:55 - the maximum profit of one the second row
509:58 - or the row number two
510:00 - with row with index two represents the
510:02 - fact that you can pick both of these
510:04 - elements
510:06 - and if you can pick both of these
510:07 - elements once again at capacity 0 none
510:09 - of them can be picked at capacity 1 none
510:12 - of them can be picked at capacity 2 this
510:15 - element can be picked which has a weight
510:17 - 2 and it gives you a maximum profit of
510:20 - one at capacity three
510:22 - this element can also be picked so now
510:24 - you have a choice to pick between the
510:25 - two of these so you might as well better
510:27 - pick this one
510:29 - because this is going to give you higher
510:31 - profit and then finally when the
510:32 - capacity becomes 5 you can pick both of
510:34 - these elements
510:36 - and you can pick both of these elements
510:37 - and that is going to give you a profit
510:38 - of 2 plus 1 3 and so on so you keep
510:41 - filling out this table for each
510:45 - step here or for each
510:46 - set of first i elements you fill out the
510:49 - capacity table and then you use the
510:51 - information to fill out the next row and
510:53 - the next column and so on
510:55 - okay and finally your what we need is
510:58 - using all the elements
511:02 - and using the maximum capacity that we
511:04 - have what is the maximum profit that we
511:05 - can obtain so the last element of the
511:07 - table will give you the result okay
511:10 - so what does the logic look like we will
511:12 - fill the table row by row and column by
511:15 - column now if table of i comma c
511:19 - table of i comma c
511:21 - let's say this is a certain position
511:22 - here table of i comma c
511:24 - can be filled using some values in the
511:27 - row above it okay now if you look at the
511:29 - table of i comma c you you look at
511:34 - look at this element for example
511:36 - yeah let's look at this element here
511:38 - so in here c has the value 3
511:41 - and then i has the value 0 which is a
511:44 - row that is not shown 1 2 3 4. so i has
511:48 - the value 4
511:50 - and c has the value 3.
511:54 - so if
511:58 - yeah so if weights of i
512:00 - is greater than c
512:03 - so zero one two three four uh if though
512:05 - if this if this weight so this weight
512:08 - the weight of this element is greater
512:10 - than the capacity so the weight of this
512:12 - element is 4 it is greater than the
512:13 - capacity
512:14 - then
512:16 - this element cannot show up
512:18 - in this maximum profit
512:21 - why because its weight is greater than
512:23 - the capacity so obviously it cannot show
512:25 - up in the maximum profit now if it
512:26 - cannot show up in the maximum profit
512:28 - then the then this cell can be filled
512:30 - using the value above it because in any
512:33 - case you cannot put in this element so
512:35 - you might as well get the result by
512:36 - using the first three elements and in
512:38 - that case the
512:40 - value of this cell is obtained from the
512:42 - value of the cell above it
512:44 - that's one case now on the other hand
512:46 - let's come here you come to this case
512:49 - into this cell in
512:51 - to fill this cell because you have a
512:52 - capacity of 4
512:54 - you have the option of either choosing
512:56 - this element or of not choosing this
512:58 - element
512:59 - now if you do choose this element let's
513:00 - say you choose this element with a
513:02 - capacity of 4
513:05 - with a capacity of 4 you get back a
513:06 - profit of 9
513:08 - and now you have no more capacity left
513:10 - to create more to fill more elements
513:13 - on the other hand if you do not choose
513:15 - this element
513:17 - then that's the same as this value
513:19 - because if you do not choose this
513:20 - element then you have to fill the
513:21 - capacity of 4 using the value of
513:24 - using the first three elements
513:26 - and that simply gives you
513:28 - the same highest profit as the previous
513:30 - cell right so you just consider these
513:31 - two cases whether we choose the element
513:34 - or we do not choose the element now if
513:37 - if you do not choose the element the
513:38 - value comes from above if you choose the
513:40 - element then the value comes from
513:42 - where let's see
513:44 - if you choose the element the profit of
513:47 - 9 comes and you fill out the capacity 4
513:49 - so you have no remaining capacity but on
513:51 - the other hand if the capacity was 6 and
513:53 - you choose the element
513:55 - then you have chosen the element and
513:58 - you've used up the capacity 4 so you can
514:01 - still use the previous three elements to
514:03 - fill the remaining capacity which is
514:05 - six minus four so which is your capacity
514:07 - of two so you can go back to the
514:09 - previous row and check the capacity two
514:13 - and see how much was the maximum profit
514:15 - that you can obtain with capacity 2
514:18 - and it turns out that with capacity 2
514:20 - using the first 3 elements you can
514:21 - obtain a maximum profit of 1. so the
514:23 - maximum profit here when you choose the
514:25 - element is 9 plus 1 n
514:29 - similarly here a maximum profit that can
514:31 - be obtained if you choose the element is
514:33 - 9
514:36 - plus 7 minus plus from the previous row
514:39 - you pick the element with a capacity 7
514:41 - minus 4 which is 3 so 9 plus 5 14
514:44 - okay so that's the logic here
514:48 - sometimes you choose the element
514:49 - sometimes you don't choose the element
514:51 - and in fact the solute the result of
514:52 - this cell is simply the maximum of
514:55 - either not choosing the elements the
514:56 - maximum of this cell or choosing the
514:58 - element and subtracting the weight which
515:01 - is
515:02 - six minus four two
515:04 - so
515:05 - maximum of this and that okay
515:07 - so let's implement this same dynamic
515:09 - programming solution
515:12 - once again do work this out on paper it
515:15 - really helps to work it out in paper but
515:17 - let's say
515:19 - we have
515:21 - max profit
515:24 - dp the dynamic programming solution we
515:26 - have weights we have profits and we have
515:29 - a capacity
515:32 - and then let's say n is len weights
515:36 - so we need to create a
515:38 - table
515:41 - so this is our table
515:42 - our table contains
515:45 - n rows so we have len n and then in for
515:48 - each of the rows
515:50 - we contain we have
515:52 - capacity plus one
515:54 - oh we contain n plus one rows remember
515:57 - we also want to consider the case where
515:58 - we don't consider where we don't take
516:00 - any of the elements
516:07 - and it is filled with zeros and the
516:09 - number of columns is capacity plus one
516:13 - to check the values from zero to
516:14 - capacity so that's our table right now
516:17 - you can check what this capacity looks
516:19 - like let's say n has n capacity
516:24 - i have the values here n in this case is
516:27 - 5 and capacity is 10.
516:34 - we don't need a len here
516:38 - you don't need a len here as well
516:41 - it's all perfectly natural
516:44 - to make these mistakes
516:46 - this should be range not len
516:50 - this should be a range and
516:53 - this should be arranged too
516:57 - yeah now you can see that we have
516:59 - created n rows
517:01 - or n plus one rows so one for each of
517:03 - these and then one more row above
517:04 - containing all which will contain all
517:06 - zeros this is in the case where we don't
517:08 - pick any of the elements and then we've
517:10 - created 11 columns so this is for
517:12 - capacity zero so again the first column
517:14 - will also contain all zeros and this is
517:17 - something that you will often see in
517:18 - dynamic programming you will have an
517:20 - additional row at the beginning or at
517:21 - the end containing all zeros and that is
517:24 - simply to
517:26 - make your calculations or computations
517:28 - easier but what that will lead to is off
517:30 - by one error so you need to be very
517:32 - careful while doing this
517:35 - and now we'll fill out this value using
517:37 - either this value
517:39 - or by subtracting the weight of the
517:40 - element that's here
517:42 - and getting a value from the previous
517:44 - row
517:45 - so now we start iterating so when now we
517:47 - say for
517:50 - i in
517:51 - range
517:53 - n
517:54 - and for j in range c
518:00 - let's just say for c in range capacity
518:02 - it should be capacity
518:05 - table of i comma c
518:11 - and it's actually going to be i plus 1
518:12 - and c plus 1 because we have these
518:14 - additional rows and columns
518:16 - table of i plus 1 comma c plus 1 is
518:20 - there are two cases here if
518:24 - weights of i
518:26 - is greater than c the current capacity
518:31 - then we can simply
518:33 - look at the previous row so which is
518:35 - this case
518:36 - let's say
518:38 - the weight 3 is greater than the current
518:40 - capacity 2.
518:43 - so then we simply
518:44 - copy over the value from the previous
518:46 - row
518:48 - the same column so we just say table of
518:52 - i
518:53 - comma c plus one we see
518:57 - so our capacity should go from the value
518:59 - of 1 because we don't want to affect the
519:01 - first column so the capacity goes from
519:03 - the value of 1 to a value of 10.
519:06 - so capacity c goes from the range of 1
519:08 - to capacity
519:10 - and if the weights i is greater than the
519:12 - capacity then we cannot fill the table
519:14 - on the other hand
519:16 - if it is
519:18 - if it fits within the capacity then we
519:20 - have two options
519:21 - the table of i plus one comma c has two
519:23 - options
519:24 - so one is we
519:26 - don't use the current element we don't
519:28 - use the current element and that gives
519:30 - us stable ic once again the other option
519:32 - is we use the current element so we get
519:33 - profit from the current element so
519:35 - profits i
519:36 - but we do not get profits
519:38 - but
519:39 - that reduces the capacity so we then
519:41 - have to pick
519:43 - table of
519:46 - i
519:47 - but now we have to pick c minus
519:49 - weight
519:51 - weights of i
519:52 - okay
519:54 - and that should fill out the entire
519:56 - table pretty much
519:57 - that's a nice thing about dynamic
519:59 - programming you simply just have to
520:01 - write this one solution or this one
520:03 - recurrence and be careful about it and
520:06 - everything else is taken care of by this
520:08 - loop here
520:10 - now we simply return table of
520:13 - minus one
520:15 - and minus one
520:16 - and let's see if that works
520:19 - it's likely that there are some issues
520:20 - here but let's see we have test cases
520:28 - max profit dp
520:30 - with the tests that we have
520:33 - great so we are seeing an issue already
520:35 - i see here that
520:41 - this should be range
520:42 - and this should be range
520:50 - okay one thing that we haven't done here
520:52 - is
520:59 - well it seems like our solution is
521:01 - always zero
521:06 - ah this should be capacity plus one so
521:08 - that we this takes all the values from
521:10 - zero to capacity right so c the iterator
521:12 - should take the values from one two
521:14 - three four all the way up to the maximum
521:15 - capacity and the range does not end so
521:19 - the range does not include the end value
521:20 - so you need to put capacity plus one
521:22 - here
521:24 - okay now with that out of the way
521:27 - you see once again these off by one
521:29 - errors are always going to bug you with
521:30 - dynamic programming
521:32 - i've probably solved
521:35 - 50 or 100 problems in dynamic
521:36 - programming but i still make these
521:37 - errors
521:39 - but with that out of the way you can see
521:40 - now that each of the test cases seems to
521:43 - pass
521:45 - now there may be other cases which you
521:46 - have not accounted for but overall we've
521:49 - covered all the test cases here and
521:52 - we've ended up with now a dynamic
521:53 - programming solution
521:55 - and i'll let you figure out the
521:56 - complexity here but once again it's
521:58 - pretty straightforward
522:00 - because we are filling up this table and
522:02 - filling up this table simply requires
522:04 - this constant amount of work which is a
522:06 - comparison and then potentially
522:08 - another comparison and an
522:10 - addition and a subtraction so like four
522:12 - or five operations
522:15 - so you have this n times and uh you have
522:17 - this n times
522:19 - capacit n times capacity
522:22 - where n is the length of weights and
522:23 - capacitor or w is a total capacity so n
522:26 - times w is the
522:29 - number of iterations and that really
522:30 - also is the
522:32 - complexity the time complexity of the
522:35 - algorithm
522:37 - so that's the knapsack problem
522:39 - and now what you can do is try and
522:41 - figure out not just what is the maximum
522:43 - value but also figure out what are the
522:47 - actual elements that were chosen now you
522:49 - can do this for the knapsack problem and
522:51 - you can do this for the longest
522:52 - subsequence problem figure out the
522:54 - actual longest subsequence and it should
522:56 - be possible to do that with just a small
522:58 - modification now use the forum
523:01 - if you have any questions
523:03 - about the contents of this lecture go
523:05 - back to
523:07 - the lesson page and open up the course
523:09 - community forum here
523:12 - you can see here that
523:13 - this is the lesson for recursion and
523:15 - dynamic programming lesson you can post
523:17 - your question here and you can also
523:19 - discuss ideas on how to figure out what
523:22 - the longest common subsequence is and
523:24 - what the best selection for the knapsack
523:26 - problem is so what do you do next well
523:28 - you can review the lecture video and
523:30 - execute the jupyter notebook the next
523:32 - step is also to complete the assignment
523:35 - now
523:36 - we have released assignments one and two
523:38 - so far
523:39 - if you go back on the lesson page
523:41 - you will find lessons you will find
523:43 - assignments one and two and you can work
523:45 - on them there is sufficient time
523:48 - and also work on optional questions and
523:50 - do participate in forum discussions and
523:53 - or if possible join or start a study
523:55 - group too
523:56 - that's a great way to stay motivated
523:59 - this was lesson 4 of data structures and
524:00 - algorithms in python
524:02 - thanks and talk to you soon
524:05 - hello and welcome to data structures and
524:07 - algorithms in python this is an online
524:09 - certification course being conducted by
524:11 - jovian
524:12 - today we are on lesson five graph
524:15 - algorithms like bfs dfs and shortest
524:18 - paths
524:20 - my name is akash and i am your
524:21 - instructor
524:22 - you can find me on twitter on akashens
524:27 - if you follow along with this course and
524:29 - complete all the assignments and build a
524:30 - course project you can earn a verified
524:32 - certificate of accomplishment for this
524:34 - course
524:38 - so with that let's get started the first
524:40 - thing we'll do is go to the course
524:42 - website pythondsa.com
524:46 - now you can point your browser to
524:47 - pythondsa.com to open up the course page
524:51 - and on the course page you can enroll
524:52 - for the course and you can view all the
524:54 - previous lessons and assignments
524:57 - so do check it out and do check out the
525:00 - course project as well but for now we'll
525:03 - open up lesson 5 graph algorithms
525:07 - now on this page you can watch a video
525:10 - for the lesson later the same video that
525:12 - you're watching right now
525:14 - and you can also catch a hindi version
525:15 - if you wish
525:17 - and here is the code that we are going
525:19 - to use today the
525:21 - first notebook under the heading
525:23 - notebooks
525:25 - so let's open it up
525:28 - and this is a jupiter notebook hosted on
525:30 - jovian
525:31 - you should be familiar with it by now
525:33 - but
525:33 - here you can see that there are some
525:35 - explanations and then there are some
525:36 - code cells where we can write some code
525:38 - you can see that there's some code here
525:42 - now to actually execute and edit this
525:44 - code we will need to run this notebook
525:47 - you can find the instructions to run the
525:49 - notebook right here but the simplest way
525:52 - to do it is to click run
525:54 - and select run on
525:56 - binder now this will take a second or
525:59 - two but this will take your jupiter
526:00 - notebook and create a new machine in the
526:03 - cloud and send your jupyter notebook to
526:05 - that machine for execution this is a
526:08 - free service
526:12 - that you can access via jovian
526:16 - you can also run this notebook on your
526:18 - own computer directly if you wish so for
526:21 - that you can check the run locally
526:22 - option here
526:26 - okay
526:26 - so our jupyter notebook server is now
526:29 - ready so we can now start editing and
526:32 - writing some code
526:35 - let's just go full screen here
526:39 - okay so the topic today is graph
526:41 - algorithms bfs dfs and shortest paths
526:44 - using python
526:46 - now before we talk about graph
526:47 - algorithms let's just
526:49 - try to understand intuitively what
526:51 - graphs are now here's an example of a
526:53 - graph in the real world
526:55 - so this is the railway map of india you
526:58 - can see here all the train stations that
527:00 - you have in india
527:02 - they're represented using these black
527:05 - dots
527:06 - points they're also labeled so each
527:08 - train station points to a city or a
527:10 - village
527:11 - so all these are also labeled
527:13 - and then you can see connections between
527:16 - these stations so these are as you might
527:18 - guess railway lines and you see that
527:20 - there are
527:21 - three or four colors involved so these
527:23 - colors could represent different types
527:25 - of railway lines like different gauge
527:27 - meter gauge broad gauge etc or these
527:30 - could represent different zones
527:34 - so there's some information contained in
527:36 - the connections as well now another
527:37 - important thing is that each railway
527:40 - line between two cities will also have a
527:42 - certain length
527:45 - so that's what a graph is roughly and
527:49 - the kind of questions that you may want
527:50 - to ask here is for example
527:53 - is there a path from new delhi
527:56 - to
527:57 - hyderabad
527:59 - so
528:00 - given this information first of all the
528:01 - question is how do you even represent
528:03 - all this information how because you
528:04 - have so many railway lines connections
528:06 - between different cities so many
528:07 - hundreds of cities how do you even
528:09 - represent this so that you can start
528:11 - writing algorithms to answer these
528:13 - questions right so if you're building a
528:15 - search
528:16 - a trained search website
528:18 - then you would have to answer given new
528:20 - delhi and hyderabad is there is there a
528:22 - way to get from new delhi to hyderabad
528:24 - okay that's the first question that you
528:25 - might ask now if there is a way then the
528:28 - next question might be that what is the
528:31 - path
528:32 - with the shortest number of stops
528:35 - so
528:36 - do you go this way for the shortest
528:38 - number of stops or do you go this way or
528:39 - do you go this way another question
528:41 - could be what is the path with the
528:43 - shortest distance right so sometimes
528:46 - if you measure the distance and if you
528:48 - measure the number of stations the
528:49 - number of stops they may be different
528:51 - along different paths and one may be
528:53 - greater than the other
528:56 - in in certain cases
529:00 - so those are the kind of questions that
529:01 - we want to ask and answer today
529:04 - or another question could be what are
529:06 - all the stations reachable from new
529:08 - delhi within one stop or two stops or
529:10 - three stops or ten stops
529:12 - so those are the kind of questions we'll
529:13 - try and answer and for that we need a
529:16 - way to represent graphs
529:19 - in a more abstract fashion because this
529:22 - same question can be asked in a
529:23 - different context for instance here we
529:25 - are looking at flight routes
529:26 - international flight routes now once
529:28 - again you can ask the exact same thing
529:30 - here is there a way to get from
529:33 - new delhi to
529:35 - vancouver
529:36 - now if there is then how many stops will
529:38 - that require
529:40 - what is the minimum number of stops we
529:42 - can take to get from new delhi to
529:43 - vancouver or what is the minimum time it
529:47 - might take maybe if you you're okay with
529:48 - taking multiple stops but you want to
529:50 - minimize the
529:52 - the the time taken or the distance
529:54 - traveled because you're concerned with
529:56 - the miles or for some reason
529:59 - another thing you could ask is what is
530:01 - the minimum cost if there is a cost
530:03 - along each route okay
530:07 - now here's one more example from a very
530:09 - different domain this is hyperlinks or
530:11 - the internet essentially so you can see
530:14 - here here you have a whole bunch of
530:16 - websites
530:17 - and you have links on websites now links
530:20 - on websites point to other websites and
530:22 - in this case it is a one-way connection
530:25 - you can see that from this particular
530:27 - course website we have a link to ibm but
530:31 - from ibm you may not have a link to this
530:32 - course website now that's an interesting
530:34 - thing that's a slight variation here and
530:36 - this is called a directed graph because
530:38 - each
530:40 - connection here
530:42 - is
530:43 - has a particular direction
530:45 - now this is again interesting to ask
530:48 - is there a way to navigate from
530:51 - cs.umass.edu
530:53 - to ithaca weather
530:55 - if there is what is the shortest way
530:57 - what do what does that path look like so
531:00 - those are the kind of questions that we
531:01 - want to answer today
531:03 - and to do that we will need a more
531:05 - abstract representation of graphs and we
531:07 - start with the simplest possible
531:09 - representation where you have certain
531:12 - points or what we will call nodes or
531:14 - vertices so these are two terms that are
531:17 - used for these points so nodes or
531:19 - vertices
531:20 - a graph has certain nodes or vertices
531:23 - and just to make things easy
531:26 - these could be cities or these could be
531:28 - web pages or these could be something
531:29 - else but just to make things easy what
531:31 - we'll do is we will number the nodes so
531:33 - in our graph if we have
531:36 - 10 nodes then we will number the nodes
531:38 - from 0 to 9. okay this is and they can
531:41 - be numbered completely arbitrarily
531:43 - there's no reason to name number the 0
531:45 - number this one what's more important is
531:47 - that we should use up all the
531:52 - all the numbers from 0 to n minus 1 if
531:54 - we're dealing with n nodes
531:56 - now why do we do that we'll see in a
531:57 - moment when we try to represent graphs
531:59 - using certain data structures like
532:01 - adjacence adjacency list etc but we want
532:04 - to number our nodes from 0 to n minus 1
532:06 - and this number is arbitrary this 1
532:09 - doesn't represent anything in the sense
532:11 - that 1 being greater than 0 or so on
532:13 - okay
532:14 - so these nodes have labels
532:15 - and then
532:16 - you have edges between nodes so an edge
532:19 - is simply a pair
532:21 - an edge is simply something
532:23 - like
532:24 - 1 comma 2. so a pair 1 comma 2 tells you
532:27 - that there is an edge between the node
532:29 - one and node two okay now
532:32 - as we move forward we will also store
532:34 - some information within an edge and we
532:36 - will call that weight of an edge and we
532:38 - will also later look at directed edges
532:41 - and those will get us directed graphs
532:42 - but let's start with this
532:44 - and let's see how we can now represent
532:46 - with this basic structure how we can
532:48 - represent
532:49 - a graph so we can represent a graph
532:51 - using two
532:52 - variables so one is called a number of
532:55 - nodes and the number of nodes is in this
532:57 - case
532:59 - 5
533:00 - and then we can represent
533:02 - the edges using a list of pairs
533:11 - so in this case the pairs are
533:15 - zero comma one
533:20 - in this case the pairs are zero comma
533:22 - one that's an edge then zero comma four
533:24 - that's an edge too
533:26 - then we have
533:30 - 1 comma 2 so 1 is connected to 2 and the
533:33 - edge in this case is bi-directional so
533:35 - when we are saying 0 comma 1 we're
533:36 - saying it automatically says that 1 and
533:39 - 0 are also connected
533:40 - right
533:42 - so 1 comma 2 and then we have 2 comma 3
533:44 - and which order we write these in
533:45 - doesn't matter we could have just
533:47 - written 3 comma 2 here as well
533:50 - or we also have 1 comma 3
533:53 - and then we have one comma four
533:56 - great
533:59 - and then finally
534:02 - we have
534:05 - three comma four okay so this is how we
534:08 - represent this data structure which what
534:10 - we've drawn here is now represented in
534:12 - code using these two variables and we
534:15 - can check here
534:17 - if we simply print the number of nodes
534:20 - and the length of edges
534:22 - we can verify if this
534:24 - is roughly correct so you see we have
534:26 - five nodes and we have one two three
534:28 - four five six seven edges okay seems
534:30 - right to me we could there may be a
534:32 - mistake here but roughly
534:34 - uh we have set things up correctly okay
534:38 - now the question becomes
534:40 - is this question is this representation
534:42 - good enough now this representation is
534:44 - good enough if you want to convey the
534:46 - structure of a graph to someone i could
534:47 - give you these two variables and then
534:50 - without showing you this image and you
534:52 - could use this information to draw the
534:54 - graph on a piece of paper so this
534:56 - representation is complete it provides
534:58 - all the information about the graph but
535:00 - it may not be efficient for example if
535:02 - you want to find out which nodes
535:05 - the node 1 is connected to we would have
535:08 - to iterate over the entire list of edges
535:10 - we would have to go through this one and
535:12 - then check if either of these is one and
535:13 - check if either of these is one and so
535:15 - on
535:16 - so that makes it very tricky to
535:19 - access any information efficiently
535:22 - rather it'll be much nicer to just look
535:24 - at a list of nodes that one is connected
535:26 - to in some way and go from there now if
535:28 - you want to find the shortest path we
535:30 - would first have to find all the nodes
535:31 - that one is connected to and then for
535:33 - each of those we would have to find
535:35 - their neighbors and then for each of
535:36 - those we would find have to find their
535:38 - neighbors and so on so it would get
535:39 - pretty
535:41 - tedious to go through the list so many
535:43 - times
535:44 - that's why and by the way
535:46 - by a neighbor we represent we mean two
535:50 - nodes that are connected by an edge so
535:52 - zero and one are neighbors but zero and
535:54 - two are not neighbors okay so that's a
535:56 - very simple nomenclature that we can use
535:58 - and
536:01 - what we can say is if we track the path
536:03 - we say 0 1 2 and then if there is an
536:06 - edge between both of them we say that 0
536:07 - 1 2 is a path
536:09 - so 0 1 2 in this case is a path
536:12 - but 3
536:13 - zero one is not a path because there is
536:15 - no path but there's no edge between
536:17 - three and zero okay and we'll see what
536:20 - what we mean by paths and neighbors and
536:22 - so on in some time
536:25 - but
536:26 - to
536:27 - work with graphs more efficiently we
536:30 - will represent them using what's called
536:32 - an adjacency list now
536:35 - the name it explains what it contains
536:38 - so the adjacency list contains a list
536:42 - for each node
536:44 - and it contains a list of all the nodes
536:46 - that are adjacent to that node now again
536:48 - adjacency is the same as an adjacent is
536:50 - same as neighbor so if for each node so
536:53 - for example for the node 0 we we
536:54 - maintain a list and that list contains
536:57 - the numbers one and four indicating that
536:59 - zero is adjacent to or zero is a
537:02 - neighbor of or zero is connected via a
537:04 - direct edge to one and four so that's
537:07 - why you have one and four here and then
537:10 - one is connected to zero two three and
537:12 - four you can see that one is connected
537:14 - to zero two three and four
537:17 - similarly two is connected to one and
537:19 - three three is connected to one two four
537:22 - and four is connected to 0 1 3. now this
537:25 - is more convenient for sure one because
537:28 - since this is an uh this is a list
537:31 - if you want to find
537:33 - let's say which nodes 2 is connected to
537:35 - we can directly access the index 2
537:37 - within the list
537:38 - and this is why we number the vertices
537:40 - or the number of the nodes from 0 to n
537:42 - minus 1 so that we can access them
537:44 - directly
537:46 - in an adjacency list right so we
537:48 - directly access the number stored next
537:50 - to 2 and so we have one and three here
537:53 - so that's what makes it convenient and
537:55 - one important thing to notice here is
537:56 - that edges each edge goes twice so the
537:59 - edge zero one shows up in the list for
538:02 - zero so you can see here in the list for
538:04 - zero we have one
538:07 - and similarly in the list for one we
538:08 - have zero
538:10 - so each edge shows up in two adjacency
538:12 - list
538:15 - of each of the nodes
538:16 - that it connects okay
538:19 - so now
538:20 - the obvious next question might be to
538:22 - create a class to represent a graph as
538:24 - an adjacency list in python okay
538:27 - this is again a question that you might
538:29 - get asked a step or this might be part
538:31 - of another question that you may get
538:32 - asked where you're asked to perform a
538:34 - breadth first search or depth first
538:36 - search or find the shortest path but the
538:37 - first step you will have to do is define
538:39 - a class for a graph
538:42 - to maintain the information about the
538:43 - graph as the adjacency list okay so here
538:46 - we're creating a class graph and the
538:48 - first thing we'll need inside the graph
538:50 - is
538:51 - a constructor function
538:54 - so we need to put something inside the
538:55 - constructor function and we know that
538:57 - the first argument to any graph any
538:59 - class method in python is self which
539:02 - represents the object that will get
539:04 - created ultimately when we
539:07 - create an object of the class
539:09 - but apart from this what information do
539:11 - you need to create a graph
539:14 - now it's
539:15 - pretty straightforward we can simply
539:17 - work with this information because these
539:18 - two variables together
539:20 - specify the graph completely
539:22 - so let's simply accept num nodes and a
539:26 - list of edges
539:27 - as the information
539:29 - the first thing we can do is simply
539:30 - store num nodes in self.num nodes so
539:33 - that once we create a graph we can
539:34 - access the number of nodes very easily
539:36 - then we need to create the adjacency
539:38 - list
539:39 - so we need to create the adjacency list
539:41 - we'll call it
539:42 - self.data and
539:45 - initially we will create a list
539:47 - containing empty lists because
539:50 - and then we will fill out the empty list
539:52 - step by step so what we need is
539:55 - something like this in this case because
539:56 - there are
539:58 - five
540:00 - because there are five nodes
540:02 - so this is what we need to create
540:04 - the five empty lists now in general
540:08 - the way to create
540:10 - repeated elements is this you can
540:13 - say
540:17 - if you want to create a repeated element
540:19 - like this 0 times
540:21 - you type 0 times 10 and that gives you
540:23 - this list
540:24 - 0 0 or containing all zeros
540:26 - on the other hand if you create empty
540:28 - list times 10 and let's call this l1
540:31 - and let's see what l1 is
540:34 - it looks like you've gotten an empty
540:35 - list you've got in a list containing 10
540:37 - empty lists but let's just go into the
540:40 - first element so the first element is
540:42 - this first empty list and inside the
540:44 - first element let us add the value one
540:48 - okay and then let's look at the let's
540:50 - look at the list l1 once again
540:53 - and you see what happens
540:55 - this one gets inserted into all of these
540:57 - lists now what's the problem here now
541:00 - the problem here is that when we do this
541:02 - when we create a list containing an
541:04 - empty list or containing any object then
541:07 - the same object gets replicated 10 times
541:10 - but python does not create copies
541:12 - now when you're working with numbers
541:14 - it's fine because when you're working
541:16 - with let's say the number zero
541:18 - that's fine because
541:22 - there's no internal structure inside
541:23 - zero right so there's nothing you can
541:25 - change inside the zero it's a fixed
541:26 - value fixed immutable value
541:29 - so what so you can you can't really say
541:31 - l one of zero and change its value
541:34 - internally what you can do is you can
541:35 - set l one of zero to another value let's
541:38 - say you can set l1 of zero to one
541:40 - so instead of getting all zeros you get
541:42 - all ones but you cannot take this take
541:45 - the zero and change something inside it
541:47 - on the other hand when you have an empty
541:49 - list here
541:51 - so this is the same list that is showing
541:53 - up in 10 different showing up 10
541:55 - different times each of the each of the
541:57 - elements in the list
541:58 - outer list is simply a pointer to this
542:00 - same empty list so what we can do is we
542:02 - can go inside this empty list and append
542:05 - something to it so since this is the
542:07 - same object that we are seeing over and
542:08 - over
542:10 - the one gets appended to the first list
542:12 - and because the rest of them are the
542:13 - same object we get back all once inside
542:16 - here okay so this is a com the reason
542:18 - we're spending time here is because
542:19 - there's a common
542:22 - common bug that you may unintentionally
542:25 - execute whenever you want to create an
542:27 - list of empty lists do not use this
542:30 - method so what's the method you should
542:32 - use then
542:34 - so here's one method you can use let's
542:36 - say you want to create a list
542:38 - of empty list of size 10
542:40 - so you may be familiar with this
542:42 - object this
542:45 - this object called range this function
542:47 - called range what this does
542:48 - is if you view it as a list you can see
542:51 - that it contains all the elements from 0
542:53 - to 9. okay now if you view the range
542:55 - itself it simply shows you 0 to 10 but
542:58 - when you convert it into a list you can
542:59 - see that internally it contains the
543:01 - value zero to nine
543:03 - okay so you can take this range
543:05 - and you can do something like this put
543:07 - this range or put anything which is
543:10 - iterable inside these brackets
543:12 - the list brackets and then say for x in
543:15 - range
543:16 - and simply put x
543:18 - so what did that do that did practically
543:21 - nothing we simply took x from the range
543:23 - of 0 to 10
543:25 - and returned x itself so we created a
543:28 - new list
543:29 - like this but suppose we multiplied it
543:31 - by two here x by two so for each element
543:34 - in the range we are multiplying it by
543:35 - two so we get back a new list which is
543:38 - zero two four six eight so this is each
543:40 - element is the double of the elements
543:42 - that we have in the range
543:44 - now what we need is we need
543:47 - just empty lists right so we can simply
543:49 - put an empty list here and we can ignore
543:51 - this value x that we get here so now we
543:53 - get back a whole bunch of empty lists so
543:55 - let's call this l2
543:57 - and what we are now doing is for each
543:59 - element in the range we are creating a
544:00 - new empty list so this is important so
544:02 - now when you do
544:04 - l2 0
544:07 - dot append 1
544:09 - and then check l2
544:14 - you can see that one was only inserted
544:16 - inside the first list
544:18 - so keep keep out watch out for this
544:20 - this is something that you will
544:22 - probably go wrong with at some point
544:24 - i've gone wrong many times
544:26 - and one last change we can make here is
544:29 - whenever you're not using a variable in
544:30 - python it's always a good idea to just
544:32 - call it underscore you can still call it
544:34 - x but your sometimes
544:37 - somebody reading your code may not
544:38 - understand
544:40 - why you have declared a variable and not
544:41 - used it and assume that maybe you've
544:43 - made a mistake so just to make things
544:45 - very clear it's always a good idea to
544:46 - make something underscore it's also a
544:48 - variable name a valid name and mark
544:51 - something is underscore if it is not
544:52 - being used
544:54 - okay
544:56 - so with that whole discussion about
544:58 - lists we now know how to create a list
545:00 - of empty lists
545:02 - so here you have a list of empty lists
545:05 - or underscore in
545:06 - range num nodes so now we have created a
545:09 - list of empty lists then
545:12 - for each edge
545:14 - in edges
545:16 - we need to do something so we need to
545:18 - insert it
545:20 - into the right lists
545:23 - okay
545:24 - now what does for edge and edges look
545:26 - like so let's see for edge in edges
545:30 - print
545:32 - edge okay each edge is a pair we already
545:36 - know that and when you have pairs or
545:38 - tuples here
545:39 - you can get them get the values out so
545:42 - let's say let's call them n1 and n2 node
545:45 - 1 and node 2. you can get the values n 1
545:47 - and n 2 out like this so now we can say
545:49 - print n 1 and print n 2.
545:59 - you can see that we are able to get
546:00 - values n1 and 2 out directly within the
546:02 - for loop so let's call this n1 and n2
546:05 - and now this is a much more pythonic way
546:07 - of writing code so one of the things
546:09 - that we are also learning is how to
546:11 - write code which is more pythonic or
546:13 - which is idiomatic in python and this is
546:15 - again something that will
546:17 - impress people when you use it in an
546:19 - interview or a coding challenge
546:22 - so for n1 and n2 in edges
546:24 - what we need to do is
546:28 - first we get self data of n1 so this
546:30 - gives us the adjacency list for n1 the
546:33 - first node
546:34 - and here we append the value n2
546:37 - and similarly we do the same for n2
546:41 - and we append n1 to it and that's it now
546:44 - we've set up the graph
546:46 - let's create a graph g1
546:49 - let's call this graph 1 maybe
546:51 - and
546:52 - we simply invoke the graph function
546:55 - and then we give it a number of nodes
546:56 - and the edges right so remember self
546:59 - will be passed in by python
547:00 - automatically as the object that is
547:02 - getting created
547:04 - so the graph one object essentially so
547:06 - now the number of nodes is five and we
547:08 - have a list of edges
547:11 - and let's see what graph1.data looks
547:14 - like
547:15 - so there you go you can see that zero is
547:17 - connected to one and four
547:20 - and one is connected to zero two three
547:22 - four and so on now while this is okay it
547:25 - would be nicer to print it
547:27 - like this
547:28 - so maybe let's see if we can print it
547:30 - like this
547:33 - and the way to do that
547:35 - is to define a wrapper function so we
547:37 - define a function called underscore
547:38 - underscore repr
547:41 - and it contains
547:42 - it simply takes self as the input
547:46 - and what we are going to do is
547:49 - we are going to
547:52 - go over
547:54 - we're going to call
547:57 - enumerate
547:58 - on self.data now what does that give us
548:01 - let's just check what enumerate on
548:02 - self.data give us gives us
548:06 - well maybe before we do that let's see
548:08 - what enumerate on a list gives us
548:13 - enumerate on a list
548:15 - gives us this object but let's just get
548:18 - the value out of it in a for loop
548:19 - because you can use an enumerate in a
548:21 - for loop and just print x
548:24 - so what enumerate gives us is
548:26 - it gives us the values from the list but
548:29 - apart from those values it also gives us
548:31 - indices okay so you can get an index
548:34 - i
548:35 - and a value v out of enumerate so then
548:38 - you can see that you can print both i
548:39 - and v here
548:42 - and you will get back the same
548:44 - output
548:46 - so what we can say is we can do
548:48 - enumerate self.data now because
548:49 - self.data contains these elements so
548:51 - what we'll get back is we'll get back
548:53 - pairs
548:57 - let's see here
549:06 - we'll get back pairs 0 comma 1 4 1 comma
549:09 - 0 2 3 4 2 comma 2 1 3 now this is
549:12 - starting to look a lot like what we want
549:14 - okay so we'll just take enumerate self
549:17 - data and these we'll take these pairs so
549:19 - the pairs will be
549:21 - a node so node n
549:23 - and its
549:24 - neighbors
549:27 - the so we have the node n so the node n
549:29 - will first be 0 and its neighbors will
549:31 - be 1 and 4 node n will be 1 and its
549:34 - neighbor will be 1 and 2 and so on
549:36 - and then
549:41 - so for n comma neighbors in enumerate
549:42 - what we'll do is we simply create a
549:44 - simple string
549:46 - and here we are using string formatting
549:51 - we are simply creating this string
549:56 - where
549:57 - we put this
549:58 - here we place a placeholder where we put
550:00 - n and then here we put a placeholder
550:02 - where we put neighbors
550:04 - again let's just see what that looks
550:05 - like
550:06 - and this is the best thing about jupiter
550:08 - while you're writing code you can test
550:09 - your code right then and there simply by
550:11 - creating putting data into a new into a
550:14 - new cell so let's see graph1.data
550:18 - so you can see here that now we have now
550:20 - we have converted that enumerated list
550:22 - into a list of strings so we have a
550:24 - string here this is the string 0
550:26 - pointing to one comma four this is a
550:28 - string one
550:29 - point this one pointing to zero two
550:31 - three four and so on but this is still a
550:33 - list of strings what we need to return
550:35 - from the wrapper function
550:37 - is a single string
550:39 - so the way to join them together
550:41 - whenever you have a list of strings and
550:42 - you want to join them together all you
550:44 - need to do is
550:45 - you say what you want to join them with
550:47 - so we want to join them with a new line
550:49 - and then call the join function on that
550:51 - string
550:55 - and return that right so that is our
550:57 - wrapper function and we'll see its users
550:59 - in just a moment and similarly we have
551:00 - another function called str
551:02 - now wrapper is used when we simply type
551:05 - graph one
551:07 - so when we type graph one this is the
551:09 - output of the default wrapper function
551:11 - now this will get replaced by the
551:13 - wrapper function that we are defining
551:14 - but when we do str of graph one or when
551:17 - we do print of graph one or when we
551:19 - insert graph1 into string that is when
551:21 - the str function is used
551:23 - now we will simply use the wrapper
551:25 - representation so let's just put self
551:28 - dot underscore underscore rdpr
551:32 - and that's it
551:34 - okay so let's see now let's put let's
551:36 - type graph one here and you can see that
551:39 - now we have this representation printed
551:41 - using this wrapper function that we've
551:43 - defined
551:44 - so we have zero one four one zero two
551:46 - three four two connected to one three
551:48 - three connected to one two four and four
551:50 - connected to zero one and three
551:58 - okay so now we have a graph data
552:01 - structure that we've implemented using a
552:03 - class so the adjacency list and we have
552:05 - a nice way to print it out
552:07 - and this is just good programming
552:09 - practice now you don't have to do this
552:11 - in a coding competition or you don't
552:12 - have to do this it's good if you do it
552:14 - in an interview if let's say you're able
552:16 - to type this out quickly but when you
552:17 - are working
552:19 - when you are working on your own
552:20 - problems or on your own code or on a
552:22 - project always make sure that any
552:24 - classes you define have a good string
552:26 - representation so that when you type the
552:29 - name of a variable you understand what
552:31 - it represents and you don't have to
552:33 - spend time thinking about it make it
552:34 - clear to yourself okay
552:36 - so that's the adjacency list and we'll
552:38 - see how that is useful in just a few
552:41 - moments
552:44 - but here are a couple of questions for
552:46 - you try writing a function to add an
552:48 - edge to a graph that is represented as
552:51 - an adjacency list okay so here we've
552:53 - specified all the edges right in the
552:54 - beginning but can you write a function
552:57 - add edge which takes
552:58 - a couple of nodes and it inserts an edge
553:02 - between those two nodes and here's a
553:04 - hint this code might be useful
553:07 - so do try that out
553:08 - now here's another one can you write a
553:10 - function to remove an edge from a graph
553:12 - which is represented as an adjacency
553:14 - list
553:15 - here you may have to use the list remove
553:17 - functions to remove a particular element
553:19 - from a list but these are two good
553:20 - exercises to
553:22 - complete here okay
553:25 - now before we continue let's just save
553:27 - our work
553:28 - and
553:29 - we know that this notebook is running on
553:31 - binder which is a free service
553:33 - so we'll just save our work by running
553:35 - jovian.commit and what that will do is
553:37 - that will capture a snapshot of this
553:39 - notebook all the changes that you've
553:40 - made and put this on your jovian profile
553:44 - now this will go on your jovian profile
553:45 - from where you can continue running it
553:49 - continue executing it from where you
553:50 - have left off okay
553:53 - now another common representation for
553:56 - graphs is called the adjacency matrix
553:58 - which is slightly different from
553:59 - adjacency lists in this case for example
554:02 - the same graph here is represented using
554:04 - this matrix so what we do is we create a
554:07 - matrix of size n by n if n is the number
554:10 - of
554:11 - if n is the number of nodes in the graph
554:14 - and then for each node
554:17 - for instance since we have
554:18 - zero and since we have a edge between
554:21 - one and two
554:22 - so
554:23 - if you take the first row row number one
554:26 - and column number two you put a one
554:28 - there
554:30 - otherwise if there's no edge for example
554:32 - there's no edge between zero and two you
554:34 - take the zero throw and column number
554:36 - two
554:38 - the you put a zero there okay so you put
554:40 - a one wherever there is an edge between
554:42 - the two nodes and you put a zero
554:43 - wherever there isn't you can see that
554:45 - there is this reflection reflexive
554:47 - property here because
554:49 - one two is one and two one is also one
554:51 - because these are undirected edges now
554:53 - of course if this is a directed graph
554:55 - this would be different
554:57 - okay
554:58 - so an exercise for you once again is to
555:00 - represent a graph as an adjacency matrix
555:03 - in python
555:04 - shouldn't be too hard all you have to do
555:06 - is instead of so in adjacency list we
555:08 - initialized a list of empty lists here
555:12 - you may want to initialize a list of
555:15 - zeros a list containing lists of zeros
555:18 - okay and then you may simply just want
555:20 - to fill in the zero once in the right
555:22 - places now adjacency matrices have their
555:25 - own benefits sometimes they are
555:28 - more useful for example
555:30 - when you want to immediately check if
555:32 - there is an edge between two vertices or
555:35 - two nodes you can quickly look up look
555:37 - it up in the adjacency matrix but in the
555:39 - adjacency list you will have to get the
555:41 - list for one of them and then search
555:43 - through that list
555:44 - which is fine for most cases but in some
555:47 - cases you may just want an adjacency
555:48 - matrix as well
555:51 - so that's one other way you can
555:53 - represent a graph
555:54 - and that's an exercise for you
555:57 - okay
555:58 - so now we know we've represented graphs
556:00 - and
556:01 - now we can start looking at some graph
556:03 - algorithms and probably the most common
556:06 - graph algorithm something that you will
556:08 - ultimately get asked in one interview or
556:11 - the other if you're interviewing with a
556:13 - bunch of companies is breadth first
556:15 - search
556:17 - and breadth first search well this is
556:19 - what it looks like so suppose you have
556:21 - this
556:22 - this is a real world graph that we're
556:23 - looking at so these are cities in
556:25 - germany
556:26 - and you can see that there are roads
556:29 - between these cities and we have lengths
556:31 - of each road now we can ignore the lens
556:33 - for now
556:34 - what's important is that these cities
556:36 - are connected to each other but not all
556:38 - cities are connected to all of them all
556:40 - of the others
556:42 - so starting from frankfurt you may want
556:45 - to find out
556:47 - which are the cities that are
556:49 - that you can reach from frankfurt
556:51 - without stopping so
556:53 - which are the cities that are one edge
556:55 - away from frankfurt and if you look at
556:57 - it this way it turns out that mannheim
556:59 - castle and
557:01 - wurzburg
557:03 - are the three cities that are one edge
557:05 - away from frankfurt right so if you
557:07 - start drawing this tree of sorts
557:09 - so
557:10 - you will find that mannheim wurzburg and
557:12 - castle are one edge away okay then you
557:15 - might ask which are the cities which are
557:17 - two edges away from frankfurt
557:20 - so now the cities that are manheim is
557:23 - connected to
557:25 - karlsruhe and wurzburg is connected to
557:28 - these two cities and then castle is
557:30 - connected to this city okay
557:32 - so here you have these other cities and
557:34 - then you might ask which are the cities
557:36 - that are three steps away from the from
557:38 - frankfurt and that would be the
557:39 - remaining two cities
557:42 - augsburg and stuttgart okay
557:45 - now i'll let you think about this but
557:47 - what you will find in this way
557:50 - as you go step by step by step like
557:52 - first you're finding all the cities that
557:54 - are one step away so all the nodes that
557:56 - are one step away from a source node
557:58 - then you're finding all the nodes that
557:59 - are two steps away from a source node
558:01 - what this will give you is ultimately
558:04 - you will end up
558:06 - for each node you will find out
558:09 - how far away it is from the source
558:12 - and that will be the length of the
558:13 - shortest path between the two okay and
558:15 - you can verify that i'll let you think
558:17 - about it for instance if you see
558:19 - you can go to
558:21 - castle by going this way from wurzburg
558:24 - to nurenberg to mission to castle
558:28 - but that would not be the shortest path
558:30 - but binary search the this is called
558:31 - breadth first search brett first search
558:33 - will always discover the shortest path
558:35 - because we're first finding all the
558:36 - nodes at distance one and then we're
558:38 - finding all the nodes at distance two
558:40 - and then we're finding all the nodes at
558:41 - distance three and if a node at distance
558:44 - three has a shorter path then it would
558:46 - have been already found
558:48 - when we are finding nodes of length one
558:50 - or two or distance one or two okay
558:53 - so that's brett first search
558:56 - so here's one problem that you might
558:58 - face in an interview
559:00 - implement breadth first search
559:02 - given a source node in a graph
559:05 - using python
559:07 - and here is some pseudo code this is so
559:09 - it's always a good idea to write or
559:11 - explain your approach in plain english
559:14 - before you implement it so that you do
559:16 - not make mistakes while coding
559:19 - so here for here is the pseudo code so
559:21 - if you have to write a function bfs
559:23 - which takes a graph and a root or a
559:25 - source node
559:27 - so first we say create a queue so we're
559:30 - creating and this is taken by from
559:31 - wikipedia
559:33 - so first we create a queue and what's a
559:36 - queue
559:37 - well a queue is a very simple data
559:38 - structure a queue is simply a list
559:41 - and it follows a first in first out
559:45 - of policy
559:47 - so when you have a list and you want to
559:48 - add something into a queue it's also
559:50 - called enqueue the enqueue operation so
559:52 - when you want to add something into a
559:54 - queue you add it at the end okay so you
559:56 - have a list and then you simply keep
559:57 - adding things at the end you just append
559:59 - things at the end of a list
560:01 - but when you want to access something
560:03 - from a queue you do not access any value
560:05 - directly no
560:06 - you always access
560:08 - the first available value okay you
560:11 - access the first available value in this
560:13 - case
560:14 - what what is called the value in front
560:17 - and when you access a value it gets
560:19 - removed
560:20 - okay so it's so in this way you can see
560:22 - that it implements the
560:23 - the first gen first out policy like if
560:26 - first we enqueue one and then we enqueue
560:28 - three and then we on q4 and then we want
560:31 - to dq and when we want to dq we simply
560:33 - get the first value that was inserted
560:35 - which is 1. then maybe we enqueue a few
560:37 - more numbers 5 2 7 then we dq and then
560:40 - we get back the first value that we had
560:43 - inserted which is not yet dequeued so
560:45 - then we get back
560:46 - four or whatever was the was the second
560:48 - value inserted initially right so that's
560:50 - a queue
560:51 - and we let's see how a queue is useful
560:53 - so we create a queue
560:55 - and then we
560:57 - mark the label
560:59 - we mark
561:01 - root
561:02 - we label the root node as discovered
561:04 - okay so we need
561:05 - to somehow
561:07 - track which nodes have been discovered
561:09 - or visited
561:11 - and first what we'll do is we will mark
561:13 - the root node so let's say we're
561:14 - starting from the node three we will
561:16 - mark three as discovered so three is now
561:18 - discovered
561:19 - and as soon as we mark something as
561:21 - discovered we will enqueue it
561:23 - okay
561:24 - then while the queue is not empty which
561:27 - is why we have not
561:29 - accessed all the elements in the queue
561:30 - or well we have not
561:32 - dequeued all the elements from the queue
561:34 - we dequeue an element so we dequeue the
561:36 - first element which has not yet been
561:38 - removed from the queue
561:41 - and if we are looking for a particular
561:43 - goal node then we can simply end there
561:45 - like we found that node but we are not
561:47 - looking for a goal node so let's remove
561:49 - this code
561:54 - yeah so we get we get the first element
561:57 - or the first node from the queue which
561:59 - is not yet dequeued and then so for
562:02 - example initially we just have three in
562:03 - the queue so then we get back three we
562:06 - get three back from the queue then we
562:08 - check all the edges for three so we
562:10 - check that three is connected to one and
562:12 - three is connected to two and three is
562:13 - connected to four so we see all the
562:14 - edges for three
562:17 - and if
562:19 - the other end of the edge
562:21 - we check for each node let's say
562:24 - the other end of this edge is 2 we check
562:26 - if 2 is not yet discovered or not yet
562:29 - visited
562:30 - then we enqueued 2 into the queue
562:33 - similarly we check for 1 and if one is
562:36 - not yet already discovered we enqueue
562:38 - one into the list similarly for four we
562:40 - enqueue four into the list okay so we
562:43 - have dequeued three so three is no
562:45 - longer in the queue
562:46 - or
562:47 - we've moved forward are we no longer
562:49 - going to get q a three out of the cube
562:52 - but now we've enqueued two one and four
562:54 - and two one and four we now understand
562:56 - they are at distance one
562:58 - so when we pick the next element of the
562:59 - queue we dequeue the next element the
563:01 - first in first and first out we get back
563:03 - 2
563:04 - and then
563:06 - we mark 2 as visited great now we
563:08 - visited 2.
563:13 - oh no we we mark
563:15 - as soon as we are adding something to a
563:16 - queue we also mark them as visited
563:18 - because we've identified that 2 1 and 4
563:21 - are all at distance 1 from 3 and we've
563:23 - added them to a queue so we mark them as
563:25 - visited
563:26 - now
563:27 - when we get 2 out of the queue in the
563:29 - next iteration we check
563:32 - if there are any nodes which 2 is
563:34 - connected to those are not yet visited
563:36 - so 2 is connected to 1 but 1 is already
563:39 - visited so there's no need to enqueue it
563:41 - again and then 2 is connected to 3 but 3
563:44 - is already visited so there's no need to
563:45 - encue it again
563:48 - and so we just move forward then we go
563:50 - to 1 and when we go to 1 we realize that
563:54 - 0 is
563:55 - not yet visited so we enqueue 0
563:58 - 4 is visited so we don't enqueue four
564:01 - okay and that's how we proceed so now
564:04 - what you should do is you should draw
564:05 - this on a piece of paper and work it out
564:08 - just write on a piece of paper what
564:10 - would be the first element that gets
564:12 - inserted and what will be the elements
564:14 - that we will insert into the queue etc
564:16 - etc
564:18 - but
564:19 - this is the algorithm here
564:21 - exactly what we what we just discovered
564:24 - so we dequeue in a vertex for all the
564:26 - edges that start from the vertex v or
564:29 - the node v
564:32 - if the other end of the edge is not
564:34 - labeled as discovered
564:36 - then mark it as discovered and enqueue
564:38 - it into the queue
564:40 - let's implement this let's see if we can
564:41 - implement this live
564:43 - so we are implementing bfs where we will
564:45 - get a graph and a source node
564:48 - the first thing we need to set up is a
564:49 - queue
564:51 - so the queue is empty then we set up
564:53 - discovered
564:56 - and discovered will be false initially
565:00 - and it will have the length
565:02 - so we want to mark it false for all the
565:05 - elements okay and remember now we can
565:07 - use this notation here because false is
565:08 - an immutable value so it doesn't matter
565:11 - so so we don't really need to use the
565:12 - range or the list comprehension notation
565:14 - here
565:17 - then
565:19 - here let's come here so we mark the
565:21 - label root as discovered
565:26 - so discovered of
565:29 - source
565:30 - let's just call it root so that we don't
565:32 - get confused with the terminology
565:35 - so we mark discovered of root as true
565:39 - great
565:40 - then we insert
565:41 - or we enqueue the root so we we
565:45 - type q dot append now enqueue simply
565:47 - means adding something to the end and
565:49 - you know how to do that in a list you
565:50 - simply call q dot append
565:52 - so q dot append root
565:55 - great
565:57 - now
565:59 - python list by default do not support a
566:01 - dq operation so what we will do is we
566:04 - will set up an index which will track
566:08 - the first
566:09 - available element in the queue okay so
566:11 - whenever we dequeue an element we will
566:13 - increase the index so that we move
566:15 - forward
566:17 - so here we have the index idx equal to
566:20 - zero so now while there are elements in
566:23 - the queue which means while the next
566:25 - available index is less than the length
566:27 - of the queue
566:30 - first we will get the current we will dq
566:33 - so dequeuing simply means
566:35 - getting the getting the first in element
566:38 - the element that was most recently
566:40 - inserted and has not been dequeued so we
566:42 - get current
566:44 - is
566:45 - q of idx and then we can also
566:48 - increase idx so as soon as we dequeue
566:51 - something we update the index so you can
566:53 - imagine that the index starts out here
566:54 - and when we dequeue this or delete this
566:56 - then we get that value out and then we
566:59 - update the index to the next position
567:00 - okay so now we have the current
567:04 - this is the dq operation
567:08 - then what do we have next
567:10 - now we want to check all the edges
567:13 - of current right so we are going to say
567:16 - for
567:18 - so remember we have the adjacency list
567:20 - representation so we will get
567:22 - for node in self.data
567:26 - current so self.datacurrent contains a
567:29 - list of all the nodes that are connected
567:30 - with the current node
567:32 - so for node in self.datacurrent
567:35 - if
567:37 - not
567:39 - discovered
567:41 - node so if you have not yet discovered
567:43 - the node
567:44 - then
567:45 - we first mark it at this as discovered
567:52 - and then we add it to the queue so we do
567:54 - q dot append
567:56 - node
567:58 - okay
568:00 - so what you end up with this way is
568:01 - first you have the source that got added
568:04 - to queue
568:05 - and then we inserted all the
568:08 - inserted all the nodes which were at a
568:10 - distance one from source and then we
568:12 - insert then if you follow the trajectory
568:14 - you'll see that we we will insert all
568:16 - the nodes that are at a distance to from
568:18 - q and so on right so ultimately when we
568:20 - end up with this entire process
568:24 - we will have the q and the queue will
568:25 - contain
568:27 - the list of nodes as they would be
568:29 - visited
568:30 - in a binary in a breadth first search
568:33 - okay so we can simply return the queue
568:35 - here
568:37 - so let's try it out so we have graph one
568:41 - and let's call bfs
568:45 - and graph1 is this graph so let's grab
568:46 - this image as well
568:50 - so let's simply copy the code for the
568:52 - image and come down here
568:55 - let's come down here
568:57 - and put the image here
569:00 - okay let's call bfs on graph one
569:03 - starting at the node three
569:07 - okay of course this should be called
569:09 - graph.data
569:11 - so because graph is the graph that we're
569:13 - working with so we need to check graph
569:15 - or data here
569:19 - okay so we start out with the note 3 and
569:21 - you can see that three first causes one
569:24 - two and four to get inserted and then
569:27 - one causes two to get inserted okay
569:29 - now that's bfs for you it's pretty much
569:32 - done at this point but what would also
569:34 - be helpful is maybe to keep track of
569:37 - what is the distance of each node right
569:40 - so we can also track
569:42 - we can also keep track of a distance so
569:44 - let's say we have a distance which we
569:46 - initially set to none
569:49 - or yeah which we initially set to none
569:55 - and we will track a distance for from
569:57 - each for each node so we have the
569:59 - distance here
570:02 - and initially we are going to set the
570:04 - distance for
570:07 - the root to zero of course because the
570:10 - root is at zero distance from itself
570:12 - and the distance here means the number
570:14 - of edges right
570:16 - then when something is discovered
570:18 - so when we are discovering a node and
570:21 - that node was not already previously
570:22 - discovered that means that the distance
570:25 - for that node
570:27 - is one more
570:30 - than the distance for the current node
570:32 - which caused it to be discovered right
570:34 - so the distance for
570:36 - so for example if you're starting with
570:38 - three the distance for one is one more
570:40 - than three which caused one to be
570:42 - discovered and the distance for zero is
570:44 - going to be 1 more than 1 which caused 0
570:47 - to be discovered
570:49 - so that's the distance
570:50 - great we've now also tracked the
570:52 - distance one other thing that would be
570:54 - nice to have is
570:56 - what is called the parent
570:58 - if you see if you go back here you can
571:00 - see that
571:01 - it would be nice to know
571:04 - what led to carl's room being discovered
571:06 - was it mannheim wurzburg or castle so
571:08 - that we can work our way backwards and
571:10 - find a path
571:12 - from frankfurt to carl's room okay
571:15 - so for that what we can do is we can
571:17 - keep track of a dictionary of a
571:21 - list called parent once again we will
571:23 - have no parents uh by default so
571:26 - parent none
571:28 - and whenever
571:30 - we find a node and that node was not
571:32 - already discovered
571:34 - then we can set the parent of that node
571:37 - to the current node which caused it to
571:38 - be discovered okay and now we can return
571:41 - from the queue the distance
571:43 - and the parent
571:47 - so let's see if that works
571:49 - okay so it seems like now we have
571:52 - these are this is the this is the order
571:54 - in which the nodes are being visited you
571:56 - can see that 3
571:58 - is the first node to be visited
572:04 - and
572:06 - 3 has and if you want to check the
572:07 - distance of 3 you can see that the
572:09 - distance of three is zero so this is
572:13 - distance is given in the order of the
572:15 - nodes in the order of the original
572:17 - numbering of the node so you can see
572:18 - that three is at a distance zero from
572:19 - itself obviously then you have one two
572:22 - and four now if you want to check the
572:24 - distance of one just check the index
572:26 - number one here so
572:28 - one is at a distance one if you want to
572:30 - check the distance of two now that is at
572:32 - a distance of
572:33 - one as well you can check here and then
572:35 - you want to check the distance of four 4
572:37 - is also at a distance of 1 right so all
572:39 - of these 1 2 and 4 are at a distance of
572:41 - 1 from the root node 3
572:43 - and also you can see here that the
572:44 - parent of 1
572:47 - remember these are 0 1 2 3 4. these are
572:48 - the indices of the nodes so the parent
572:51 - of one is three and the parent of two is
572:53 - three as well and the parent of four is
572:54 - three three itself does not have a
572:56 - parent that's why this is none and
572:58 - finally the last node we visit is zero
573:01 - and it is at a distance two you can see
573:03 - it is the this distance here is indeed
573:05 - the highest
573:07 - and
573:08 - the parent for
573:10 - zero is one right so because one was the
573:12 - first node that caused zero to be
573:14 - visited it could have been four two but
573:16 - in this case just how we implemented it
573:18 - one was the first node which caused it
573:20 - to be visited so
573:21 - one is the parent of zero so if you now
573:23 - want to find the path from three to zero
573:26 - you can look at the parent of zero that
573:28 - would be one
573:29 - and then you can look at the parent of
573:30 - one
573:31 - that would be three
573:33 - and we are done so we can work backwards
573:35 - from the target we can keep checking the
573:37 - parent after parent of the target and
573:39 - that will give us the entire path so now
573:41 - we have the path we have the distance
573:44 - and we have the order in which these
573:46 - nodes will be visited so you may get
573:49 - asked bret first search in all these
573:50 - different variations but roughly this is
573:52 - what the code looks like and you can see
573:54 - here that the code is not too long now
573:57 - we have created all these additional
573:58 - additional lists but you don't really
574:00 - need them so the code is about 15 lines
574:03 - of code 10 to 15 12 to 15 lines of code
574:05 - not more than that
574:08 - so that's bfs again if you're working on
574:10 - a bfs problem it always helps to first
574:13 - state it in simple words
574:15 - and work it out with an example and then
574:17 - start coding so that you do not make
574:19 - mistakes while coding
574:25 - now
574:27 - one question that you can
574:29 - work on is to check if all the nodes in
574:32 - a graph are connected this may not
574:33 - always be the case so for example here
574:36 - you can see that all the nodes in the
574:37 - graph are connected but sometimes you
574:39 - may have a situation where some nodes
574:40 - are not connected for instance if these
574:43 - edges 1 1 2 and 3 2 weren't present then
574:46 - 2 would not be connected to 0 and maybe
574:48 - 2 is connected to 5 and 6 etc so here is
574:50 - one graph where not all the nodes are
574:53 - connected to each other you can see that
574:55 - there are nine nodes but there are only
574:57 - eight edges and
574:59 - if you look carefully you will see that
575:01 - 0 1 2 3 0 1
575:04 - 2 3 are connected
575:06 - but there is no connection from these
575:07 - nodes to 4 so 4 5 6 are then connected
575:10 - separately and then seven eight are
575:12 - connected to each other but not to one
575:13 - another right so can you use breadth
575:16 - first search
575:17 - to determine if all the nodes in a graph
575:19 - are connected
575:21 - i would reckon yes
575:22 - look at this q
575:24 - now this queue gives you
575:26 - all the nodes
575:28 - that starting from the source node are
575:31 - connected to the source node by zero one
575:33 - two three or so many steps
575:35 - if something is not connected it will
575:37 - not show up in the queue so you can
575:38 - simply check the length of the queue and
575:41 - see if that is less than the total
575:42 - number of nodes
575:43 - and then use that to
575:47 - determine if all the nodes are connected
575:49 - or not
575:50 - now another related question that you
575:51 - may get asked is to find the number of
575:54 - connected components in the graph now
575:56 - what's a connected component if you take
575:58 - a set of nodes that's connected that's
576:00 - one component and if you remove that
576:03 - then you look at the next set of nodes
576:04 - that's connected that's two components
576:06 - if you remove that then you take the
576:07 - next set of nodes that connected
576:10 - that are connected
576:12 - that and that gives you the
576:14 - third connected component and so on so
576:16 - in this case for example you have this
576:18 - is one connected component you can check
576:20 - by drawing the graph and then this would
576:22 - be one connected component and then
576:24 - these would form one connected component
576:26 - so zero one two three would be one
576:28 - connected component four five six would
576:29 - be another and seven eight would be
576:31 - another
576:32 - can you find the number of connected
576:34 - components or even can you list all the
576:36 - connected components of a graph using
576:38 - bfs
576:39 - yes you can
576:41 - again a very simple way to do it is just
576:44 - pick the first node perform bfs from the
576:46 - first node that gives you the connected
576:48 - component that contains the first node
576:50 - then find the first index which is the
576:52 - first node which is not yet visited
576:54 - start bfs from that node now that will
576:56 - give you the connected component for the
576:58 - second node and then find and then keep
577:00 - doing keep repeating this till all the
577:02 - nodes have been visited
577:04 - okay
577:05 - that's another question that you might
577:07 - get find the number of connected
577:08 - components or find a list all the
577:10 - connected components in a graph the bfs
577:13 - is a very versatile algorithm that can
577:15 - be applied to solve
577:17 - pretty much
577:18 - most graph problems that you may get
577:20 - asked in an interview
577:22 - so do do work on a few bfs problems
577:26 - and get some practice with it
577:29 - now another way to work through a graph
577:31 - to
577:32 - look through a graph is what is called
577:34 - dfs and this is the way in which you
577:36 - would normally explore a maze where you
577:38 - start out in one direction and then keep
577:40 - going so for example we started out here
577:42 - and then we kept going till we hit an
577:44 - end right so you can see here that we
577:46 - kept going until we hit an end and then
577:48 - we turned back and then we tried the
577:49 - next path and then we turned back and
577:51 - tried the next path and so on so we go
577:53 - like this then we turn back we try 5 go
577:55 - like this turn back we try 8 then we
577:57 - turn back try 9
577:58 - 10. that's another way to go about it
578:02 - and
578:03 - it's some cases in some cases bfs makes
578:05 - more sense in some cases dfs makes more
578:07 - sense and
578:09 - you can in most cases both of them work
578:12 - just fine for most problems so you can
578:14 - implement either one when you are faced
578:16 - with a graph problem
578:18 - so let's implement
578:20 - dfs or depth first search okay now here
578:23 - is a depth first search it's pretty
578:25 - straightforward you have you pick a node
578:27 - and then you pursue the the node and the
578:29 - next node then the next node and so on
578:33 - among the edges you pick one node and
578:35 - then once once you've exhausted the path
578:37 - along one edge you come back and try the
578:38 - next edge and then you come back and try
578:40 - the next edge so there are two ways to
578:42 - write it there is a way to write it
578:44 - recursively and then there is a way to
578:46 - write it without recursion
578:47 - and i'll leave it as an exercise for you
578:49 - to write it recursively but what we'll
578:51 - do is we will write it without recursion
578:54 - and you write without recursion we will
578:56 - use
578:58 - something called a stack we will use a
579:00 - stack and a stack is another data
579:02 - structure very simple list like data
579:04 - structure but it's
579:06 - just like a queue but it's different
579:09 - instead of being first in first out
579:11 - which is what we do in a queue in a
579:13 - stack we perform
579:15 - last in first out
579:17 - so here's how it works you start with an
579:19 - empty stack
579:21 - so you can think of it like this
579:22 - container or a cookie jar and you start
579:24 - putting in things into that jar you put
579:27 - in one and you put in two and you put in
579:28 - three so now when you have to remove an
579:31 - element from the stack or you want to
579:32 - access an element from the stack the
579:33 - only element that you can access is
579:36 - the element that was inserted most
579:38 - recently
579:40 - so last in
579:41 - first out that's a stack
579:43 - how is that going to be useful
579:45 - it's pretty straightforward if you think
579:48 - about it
579:49 - because this node when you start from
579:51 - this as the source you will add all
579:53 - these three into the let's say you add
579:55 - these three into the stack
579:57 - now if you add these three uh let's add
579:59 - them in this order so you start with
580:00 - this node then you add this this and
580:02 - this so you add these three into the
580:03 - stack
580:04 - then the last in value was two okay so
580:08 - then what you do is you
580:09 - extract two out and then you insert
580:12 - everything that two is connected to into
580:13 - the stack so you insert three into the
580:15 - stack
580:17 - and then you the last in value was three
580:18 - so you insert you take out three and
580:20 - then you insert four into the stack then
580:22 - the last in value was four then you take
580:24 - out four and you have nothing left to
580:25 - insert so now this entire path has been
580:28 - exhausted so then you end up with this
580:31 - five now when you end up with five you
580:32 - can insert its name neighbors eight and
580:35 - six into the stack
580:37 - and once six gets inserted into the
580:39 - stack uh then you take out six and you
580:42 - put seven into the stack and so on right
580:44 - so you can see how depth first search is
580:46 - working using a stack and roughly this
580:48 - is what the procedure the
580:50 - process looks like you start a stack
580:53 - it's empty
580:54 - push push the
580:56 - current
580:58 - source let's say the root node which you
581:00 - are starting with put the root into the
581:02 - stack now while the stack is not empty
581:04 - pop the stack so get the last 10 value
581:07 - from the stack and that gets removed as
581:09 - soon as we call pop
581:13 - then if that node is not already
581:16 - discovered
581:17 - then we mark it as discovered and then
581:19 - for all the edges from v to w
581:23 - so for all of its neighbors
581:25 - we simply push them into the stack right
581:27 - so that's it that's all we are doing all
581:30 - of its neighbors which are not already
581:33 - visited we can simply push push them
581:35 - into the stack okay
581:37 - so let's do that let's implement dfs
581:41 - and once again we will keep this picture
581:43 - in mind so let me just grab this picture
581:45 - here as well
581:52 - this is one of the nice things about
581:54 - jupiter that you can take these images
581:56 - and
581:57 - simply include them within your jupyter
581:59 - notebook while coding so that you don't
582:01 - make any mistakes so let's say we're
582:02 - writing define dfs
582:05 - and once again let's assume that we are
582:07 - going to start from 3
582:11 - and this picture is graph one
582:15 - so let's say we are starting from three
582:16 - so define dfs graph and we have a
582:20 - root node that we want to start with
582:23 - and the first thing we want to do is we
582:24 - want to create a stack and you can use a
582:26 - list as a stack
582:28 - adding
582:30 - you can simply add things to the end and
582:31 - then pop them from the end
582:34 - so
582:35 - we create the stack and then we find
582:36 - discovered we mark discovered as false
582:40 - for every node
582:43 - len graft or data
582:46 - then we say stack dot
582:49 - insert so stack dot append so we simply
582:52 - add the number three to the end or the
582:54 - root number to the end so stack dot
582:56 - append root and then we don't mark it as
582:59 - discovered yet now this is the
583:00 - interesting thing in dfs because
583:03 - remember when you start out with three
583:06 - you want you don't want to mark four one
583:08 - and two all of them as discovered you
583:10 - want to put them into the stack but only
583:12 - when they come out you want to mark it
583:13 - as discovered because you want to
583:15 - discover four and then you want to
583:16 - discover zero before you discover one so
583:19 - that's why we put these into the stack
583:20 - but we don't really
583:23 - mark them as discovered just yet so
583:25 - that's why we are not marking
583:26 - the root as discovered then while
583:29 - lens stack is greater than zero
583:35 - we get the current value so the current
583:37 - value would be stack dot pop
583:41 - so interestingly python lists two
583:43 - support a pop operation so if you have a
583:44 - list
583:49 - and then you do l1 dot pop
583:52 - you can see that
583:57 - the value v that you get from l one dot
583:59 - pop is the value two and l one now has
584:01 - the value five comma six okay so you can
584:03 - use a dictionary or you can use a python
584:05 - list like a stack in fact we can even
584:07 - try append here to see the entire
584:09 - process let's say we are appending three
584:11 - and then we are popping three
584:13 - so we get back three and five six two
584:15 - remains
584:18 - so we pop the current node and then we
584:21 - mark it as discovered
584:23 - so we mark it as discovered here
584:26 - discovered of current is true
584:28 - and
584:29 - we may also just want to store that this
584:32 - is the result that we have so we may
584:34 - also just want to create a result list
584:37 - where every time we pop something we are
584:38 - also going to add it to the result list
584:40 - so let's say result
584:44 - dot append current
584:47 - and then we are finally going to return
584:49 - the result
584:51 - okay but here's the main logic
584:53 - so for
584:56 - all the nodes in
584:58 - graph dot data current
585:03 - we are simply going to push those nodes
585:04 - into the stack so
585:07 - we are simply going to say
585:09 - stack dot append
585:12 - node okay so what we do is we start with
585:14 - three and we then pop three
585:17 - and add it to the result and then we
585:20 - put one two and four into the stack we
585:22 - don't mark them as
585:24 - discovered yet
585:26 - then we pop one
585:29 - and then we put
585:30 - all of these zero two three four into
585:32 - the stack
585:34 - we don't mark them as discovered yet we
585:36 - mark one is discovered now
585:38 - then we pop zero because sorry then we
585:40 - pop four not one because we insert one
585:42 - to four so four is the last inserted
585:44 - value so then we pop for four we mark it
585:46 - as discovered and then we insert zero
585:49 - one and three now you can see that there
585:51 - is some repetition here we're also
585:52 - inserting three once again so just to
585:54 - avoid that what we can do is we can say
585:56 - if
585:58 - not
585:59 - discovered node
586:03 - only then add it to the stack right
586:04 - there's no point in adding something to
586:06 - a stack if it is not all if it is
586:08 - already discovered so now with that in
586:10 - mind let's see we start with three and
586:12 - then we insert one
586:14 - two
586:15 - and four great four is the last value
586:17 - inserted so three is discovered now four
586:19 - is the last value inserted so we pop
586:21 - four
586:23 - and then we insert 0 1 but we don't
586:25 - insert 3 because it's visited
586:27 - so now 1 is the last value inserted then
586:30 - we pop 1
586:31 - and we try to insert some of these other
586:33 - values it seems like everything is
586:34 - already inserted so nothing will get
586:36 - inserted
586:37 - then the only thing that remains is zero
586:39 - so we pop zero
586:41 - then we pop once we have popped zero we
586:43 - are going to pop four so the order in
586:46 - which we expect to see things is three
586:49 - four
586:50 - one
586:53 - zero two i believe
586:56 - let's see
587:00 - dfs
587:03 - graph one
587:04 - starting at the node three
587:07 - okay so it looks like we have
587:09 - zero one so it looks like we made a
587:11 - mistake because we got some repeated
587:13 - values here
587:15 - and that's because we may want to just
587:17 - check
587:19 - if not
587:20 - discovered current
587:24 - we may want to just add this check and
587:26 - put everything inside this check
587:28 - so that
587:29 - any older values that have been inserted
587:31 - into the stack which are already visited
587:33 - later
587:34 - sometime through another value in the
587:36 - stack that gets ignored so we end up
587:39 - with three one three four one two zero
587:41 - right so it goes like this first we go
587:44 - from
587:45 - three to four to one
587:48 - to 2 and then we go from 3 to 4 to 0.
587:52 - so that's how it goes
587:55 - now
587:56 - a challenge for you is to also implement
587:59 - distance now in this case the distance
588:01 - will not really make sense because this
588:02 - is not the shortest distance anymore so
588:04 - when you want to get shortest distance
588:06 - from one node to another then you want
588:08 - to use bfs not dfs because if you track
588:11 - distance here you may end up going by
588:13 - dfs three to four to one to two
588:17 - and that is going to give you a distance
588:18 - of
588:20 - or a distance of three to getting to two
588:22 - although the shorter distance is one so
588:24 - maybe distance doesn't make sense here
588:25 - but what you may want to put in is the
588:27 - parent you may want to track the parent
588:29 - for each node
588:30 - should be simple enough to do whenever
588:32 - you are
588:34 - popping something you may just want to
588:36 - track its parent
588:38 - okay
588:41 - that's an exercise for you
588:43 - another exercise that you can try is to
588:46 - write a function to detect a cycle in a
588:48 - graph now when you're performing dfs
588:50 - let's say you are going about performing
588:52 - dfs starting at one
588:55 - and you do this and then you end up here
588:58 - back at one right because you go to from
589:00 - one to two two to zero and when you
589:03 - notice that zero points to one which is
589:05 - already visited that gives you an
589:07 - indication that there is a cycle in the
589:09 - graph a cycle is simply a path which
589:11 - leads from a node to itself so 1 2 0 1
589:14 - is a path and a path is something a path
589:17 - is a sequence of edges so 1 2 is an edge
589:19 - 2 0 is an edge and 0 1 is the edge so
589:21 - this is a path but 1 2 and 2 4 is not an
589:24 - edge so 1 to 4 is not a valid path right
589:27 - so cycle is simply a path that leads
589:30 - a node leads from a node to itself so
589:33 - the challenge for you is to write a
589:34 - function to detect a cycle in a graph
589:37 - another challenge for you is to
589:41 - detect maybe the number of cycles in a
589:42 - graph
589:45 - okay so that's another thing that you
589:46 - can try out
589:48 - but we will move on to another problem
589:50 - now we will talk about
589:53 - weighted graphs and get closer to that
589:55 - example of
589:57 - the railway map that we looked at
589:58 - initially so here you have nodes so you
590:01 - have nodes numbered from 0 to
590:04 - 8 so you have a total of 9 nodes
590:07 - and you have edges too now these edges
590:10 - also have weights and this could be
590:12 - distances for example the railway line
590:15 - or
590:16 - this could represent
590:18 - any other information which is of value
590:20 - to you right so you decide what edge
590:22 - weights are what they mean
590:24 - in the abstract representation we simply
590:25 - call them weights so this is a weighted
590:27 - graph and here is an example of how we
590:29 - can convey the information about a
590:31 - weighted graph i can give you the number
590:33 - of nodes and then i can give you a list
590:34 - of edges so the first two elements of
590:36 - each edge tell you which nodes are
590:38 - connected like the nodes 0 and 1 are
590:40 - connected here
590:42 - and then the last element of the list or
590:44 - the third element of the list tells you
590:47 - if it is weighted if there is a weight
590:50 - associated with the edge
590:52 - okay
590:53 - so you have 0 1 3 and then you have 0 3
590:55 - 2 so 0 is connected to
590:57 - 3 and it has a weight 2 and so on and
591:00 - you can verify that there are 10 edges
591:02 - here and these are the 10 edges with the
591:04 - 10 weights
591:05 - so that's one variation that we see in
591:08 - graphs
591:09 - here is another variation this is called
591:12 - a directed graph in this case
591:15 - edges have a certain direction so this
591:17 - corresponds to the example of hyperlinks
591:19 - where we have pages web pages on the
591:20 - internet and one page can link to the
591:22 - other but the other page may not
591:24 - necessarily link back they may in which
591:26 - case you may have a bidirectional edge
591:28 - but in most cases there you would have a
591:30 - single unidirectional edge so you have 0
591:32 - 1 1 2 and 2 3.
591:35 - now directed graphs can be represented
591:38 - just the same way as undirected graphs
591:40 - all we need to do is we need to provide
591:42 - some information that this is a directed
591:43 - graph right so you can simply say uh
591:46 - directed equals true
591:49 - and that will simply and once you
591:50 - provide all these all this information
591:52 - that can then specify to the person who
591:54 - is going through this data that this is
591:56 - a directed graph right uh so here's how
591:58 - it's exactly the same as a normal
592:01 - undirected graph but
592:02 - when we create the adjacency list
592:04 - we can
592:06 - have a graph we can have a node from 0
592:09 - to 1 but we should not put 0 into the
592:12 - adjacency list for one because there's
592:14 - no way from uh to there's no direct h
592:16 - from one to zero there's only a direct
592:18 - edge from zero to one so keep that in
592:20 - mind and similarly in the adjacency list
592:22 - now you will not set both the values
592:24 - zero one and one zero two one you will
592:26 - only set one of them corresponding to
592:28 - the one direction unless of course there
592:30 - is a bi-directional edge
592:32 - and what we can do is we can even
592:34 - combine directed graphs and weighted
592:36 - graphs
592:37 - so here's the here's what we'll do we
592:40 - will define a class which can represent
592:42 - weighted and directed graphs in python
592:44 - so we'll use it to represent undirected
592:46 - graphs directed graphs and weighted
592:48 - graphs all of these
592:50 - and we will take some information in the
592:52 - constructor to capture this
592:55 - detail
592:56 - so let's say let's create a class graph
592:59 - once again we will create a constructor
593:02 - now this has the self which is the
593:04 - object that gets created always the
593:06 - first
593:07 - argument to any
593:09 - method in a class in python
593:12 - then we take the num nodes
593:15 - then we take the edges
593:16 - and then we take a couple more arguments
593:18 - we take a argument directed which has a
593:21 - default value false and we take the
593:23 - argument weighted which has a default
593:25 - value false okay
593:27 - and we're going to store the information
593:28 - self dot directed let's store self dot
593:31 - num nodes
593:33 - as num nodes
593:35 - self dot directed as directed
593:39 - self dot
593:41 - weighted is
593:43 - weighted
593:46 - okay so now we come to the edges
593:49 - so for edge
593:51 - in edges
593:54 - what do we do now an edge can either
593:56 - have two values or three values if it is
593:59 - weighted if it is unweighted then it
594:01 - will have two values if it is weighted
594:02 - then it will have three values
594:05 - so we need an if condition here if
594:08 - self dot
594:09 - weighted
594:10 - then
594:13 - include weights
594:15 - else
594:18 - work without weights
594:20 - okay now we may want to also because we
594:23 - need to create an adjacency list so we
594:25 - will create self.data just as we have
594:27 - been doing so far
594:29 - and in self.data
594:31 - we will
594:33 - create a list of empty lists as we have
594:35 - done
594:37 - for underscore in
594:40 - range
594:42 - num edges
594:44 - now what we'll do along with self.data
594:47 - we will also create something called
594:48 - self.weight
594:50 - and self.weight will store
594:53 - for each corresponding value in the
594:54 - adjacency list it will store the weight
594:56 - of the edge between the two elements so
594:58 - for
594:59 - under and you will see how it works in
595:01 - just a moment
595:03 - num edges
595:05 - okay so we have self.data and self.wait
595:07 - and this will make it easier
595:10 - another way you can do it is instead of
595:12 - storing single values you can store
595:14 - tuples inside self.data which will
595:16 - correspond to the node and which will
595:18 - also contain the weight right so that
595:20 - both these are both ways to do it i'm
595:22 - just doing it this way
595:24 - but you can do it the other way as well
595:26 - where you can store tuples directly
595:27 - inside self.data
595:31 - suppose
595:32 - it is weighted
595:34 - then first we get the values out of the
595:37 - edge so node 1 node 2
595:40 - and weight
595:41 - from the edge remember the edge is a
595:43 - tuple
595:44 - if and then
595:47 - first we set self.data
595:50 - node1
595:51 - and append to it
595:53 - node2
595:55 - and then we also set self.wait node1
595:59 - so at the exact same location where we
596:01 - have node 2 at the exact same index
596:04 - we store the
596:05 - weight
596:06 - between the of the edge between node 1
596:08 - and node 2 which is weight okay
596:11 - so now we've stored one direction which
596:13 - is node one to node two
596:15 - we may also need to store the second
596:17 - direction so if not directed so if if
596:20 - the graph is not directed only then we
596:22 - need to store the second direction so we
596:23 - just say self.data node two dot append
596:27 - node one
596:28 - and then self dot data
596:31 - node two dot append
596:34 - wait
596:36 - okay
596:37 - and that's the case when it is weighted
596:39 - if it is not weighted well
596:41 - the code is actually simpler
596:44 - so we simply get node 1 and node 2 from
596:46 - the edge
596:48 - and we say self.data node 1.
596:56 - dot append
596:58 - node 2
596:59 - and then if not directed so there's no
597:01 - wait here so we simply check if the
597:03 - graph is not directed self.data
597:06 - node2
597:08 - dot append
597:10 - node one
597:11 - okay
597:13 - so there's a bit of code here but the
597:15 - code is again fairly straightforward
597:17 - it's just a couple of things that we
597:19 - have to take care of whether it's
597:20 - weighted or not whether it's directed or
597:21 - not but now that we've done this we have
597:23 - a fairly generic representation for a
597:26 - graph right so now we can take this
597:27 - graph
597:28 - and
597:29 - remember graph one
597:30 - the graph one had this information
597:33 - so similarly we can we can create this
597:35 - graph we can use this graph class to
597:37 - represent graph one but we can also use
597:38 - it to represent one of these which is a
597:41 - directed graph a graph with weights or a
597:43 - graph with directed edges or a graph
597:45 - with both a graph with both weights and
597:47 - directed edges which we'll see in just a
597:49 - moment
597:50 - now one thing that we'll also do here is
597:52 - create a nice representation so let's
597:55 - just create a representation here
597:59 - now i'm not going to get into the code
598:00 - of this but roughly what we want is we
598:02 - want while showing the graph if there is
598:04 - a weight we also want to show the weight
598:06 - we'll show the weight alongside the
598:08 - other node
598:14 - so let's see we create a result the
598:16 - result will be
598:19 - this
598:19 - the empty string and then we'll return
598:21 - that result
598:26 - then we are going to say for i comma
598:30 - nodes comma weights
598:32 - in
598:33 - enumerate
598:37 - self.data and self.weight
598:40 - so now this is an exercise for you to
598:42 - figure out what exactly this is doing
598:44 - and you can apply the exact same
598:45 - technique take create a new
598:49 - create a new cell and put this data into
598:51 - a cell put the zip into a cell
598:54 - and then see what that represents if if
598:56 - you're not able to if it doesn't show
598:57 - something then try converting it into a
598:59 - list or using it in a for loop and then
599:01 - put enumerate around it and see what
599:03 - that represents so that you understand
599:04 - what i nodes and weights represent
599:06 - but i am simply going to write it here
599:09 - so that you see the final result
599:26 - okay
599:27 - so let's take
599:29 - nom nodes one once again
599:33 - and edges one it was called num nodes
599:35 - and edges so this was the initial data
599:37 - that we were working with let's create
599:39 - graph one
599:51 - and of course we want to do this only if
599:53 - it is weighted so if
599:55 - self dot weighted
600:00 - if it is not weighted then we have a
600:02 - different case where
600:04 - for i common nodes in
600:07 - enumerate
600:09 - self.data
600:11 - result
600:14 - plus equals
600:26 - okay let's see so graph one we are going
600:28 - to use
600:29 - the graph
600:31 - and we're going to pass num nodes edges
600:33 - and by default weighted and directed are
600:34 - both false so we don't need to specify
600:36 - them and let's see graph one
600:42 - this should be
600:44 - num nodes
600:48 - so you can see with live coding we
600:49 - always make mistakes and it's almost
600:51 - always bound to happen that's where
600:53 - jupyter notebooks are very helpful and
600:54 - it's always helpful to just test your
600:56 - function
600:57 - while you're writing it
600:59 - okay so now we've created graph one and
601:01 - graph one you can see is an undirected
601:02 - graph you can see that zero points to
601:04 - one and one points to zero
601:08 - then let's look at graph two so we're
601:10 - going to grab this
601:12 - data
601:13 - this contains
601:15 - let's call this num nodes two and edges
601:16 - two
601:17 - this is a graph with weights
601:21 - so now let's create a graph too
601:24 - graph and here we pass in num
601:30 - nodes to
601:31 - edges too
601:34 - and weighted equals true
601:36 - and let's say graph two
601:41 - okay there's a small change here
601:47 - yeah so now you can see for graph 2 this
601:49 - was the graph we were looking at here
601:51 - this graph let's grab this image as well
602:02 - yeah this is the graph that we were
602:03 - looking at and you can see that zero is
602:05 - connected to one and three
602:08 - and so zero is connected to one three
602:10 - and eight one three and eight and there
602:12 - are also weights associated so zero one
602:14 - has the weight three
602:15 - 0 3 has the weight 2 and 0 8 has the
602:17 - weight 4
602:19 - and so on
602:26 - there seems to be something off here
602:27 - because 0 1 only seems to be connected
602:29 - to 0. i think we may have made a mistake
602:32 - somewhere in the code
602:44 - okay so we may just have to debug this
602:46 - code it seems like we may have made a
602:47 - made a small mistake somewhere because
602:50 - zero one uh one seems to be connected
602:52 - only to zero but one should also be
602:54 - connected to seven
602:55 - i don't see why that did not show up
602:57 - here
603:04 - this is the curse of life coding and
603:05 - that's why i have created
603:09 - a working
603:10 - i have some working code here i'm simply
603:12 - going to grab the working code right now
603:19 - and we'll just replace that
603:21 - but see if you can detect the bug in the
603:24 - code okay we don't the version i have
603:27 - does not require you to specify weighted
603:29 - so we can simply skip weighted here it
603:31 - detects automatically if the graph is
603:33 - weighted still something wrong here
603:35 - let's just quickly verify what's going
603:37 - wrong
603:39 - so we are going through the list of
603:40 - edges here
603:49 - and we are appending
603:52 - maybe let's just print
603:54 - graph two dot
603:58 - graph2.data
604:00 - maybe the issue is in the representation
604:02 - and not in the
604:03 - code graph two dot
604:06 - edges
604:12 - ah there seems to be some issue in the
604:13 - weight here
604:15 - so we may not have inserted the weights
604:16 - correctly
604:23 - ic so this should be called weight
604:29 - this should be called weight
604:39 - and so should this be called wait
604:47 - oh there was a syntax error here
605:29 - okay
605:30 - i think we fixed it finally let's see
605:33 - this should be called weight
605:48 - so we have an edge here we have too many
605:51 - values to unpack ah we simply
605:53 - pass
605:54 - weighted equals true finally
605:58 - and we need to make this a list
606:06 - it's finally done
606:08 - some
606:10 - good hardcore live debugging but we have
606:12 - this finally and again you get to see
606:15 - that when you're coding you will you
606:17 - will make issues you just need to
606:19 - but if you have a clear idea of how
606:20 - you've written the code it's easier to
606:22 - narrow down the issues by looking at the
606:24 - errors
606:25 - but let's see this graph here so we have
606:27 - zero connected to one three and eight
606:30 - and that's you can see that here one
606:31 - three and eight are zero connected to
606:33 - one three eight with the weights three
606:35 - two and four
606:36 - then we have three connected to zero
606:38 - two and four
606:40 - so we have three connected to zero two
606:42 - and four and we have six connected to
606:44 - five and eight you can see six connected
606:45 - to five with the value eight
606:47 - so great we have now represented our
606:49 - graph properly and this is why a
606:51 - representation is really useful because
606:53 - now we can check if our implementation
606:54 - is correct before we go on and implement
606:56 - any graph algorithms we can check if our
606:59 - representation is correct let's try one
607:01 - more let us also try this directed graph
607:04 - so we're going to grab this code
607:06 - and put it here let's call this
607:09 - num nodes three
607:11 - edges three and directed three
607:16 - let me grab this
607:18 - graph code here as well
607:24 - we are working with
607:26 - this graph
607:28 - and
607:29 - let's create graph three
607:31 - so for graph three we have
607:33 - graph and we pass in num
607:36 - nodes three
607:39 - we pass in edges three and you can
607:41 - verify that the edges are set up
607:43 - correctly and we just specify directed
607:45 - equals true so we don't really need this
607:47 - at this point we can just say directed
607:49 - true and weighted by default is
607:50 - automatically false so we have graph 3
607:53 - here
607:54 - you can see that 0 is connected to 1
607:57 - and 1 is connected to 2 but not to 0 so
608:00 - now we haven't inserted the opposite
608:01 - edge and then 2 is connected to 3 and 4
608:04 - then 3 is connected to 0 and 4 is
608:06 - connected to 2. great so we've
608:08 - implemented we've now set up another
608:10 - graph
608:11 - and now here similarly you can check
608:13 - that if you have a weighted directed
608:15 - graph the code is still going to work
608:17 - fine
608:18 - that's an exercise for you
608:20 - and at this point let us just save our
608:22 - notebook using joven.com
608:26 - so the next question that we are going
608:28 - to look at is called the shortest path
608:31 - question
608:33 - and this is really what we started out
608:35 - with
608:36 - let's say you have a bunch of nodes and
608:38 - this is we have taken a directed graph
608:40 - here but
608:42 - you need not have a directed graph you
608:43 - can do this with an undirected graph too
608:45 - and that will be an exercise for you but
608:47 - you do need weights here now whenever
608:49 - you're talking about shortest paths in
608:51 - terms of weights
608:53 - that is when this algorithm makes sense
608:55 - now if you do not have weights in the
608:57 - graph then the shortest path can be
608:58 - found simply by performing breadth first
609:00 - search okay so whenever you're asked to
609:02 - find the shortest path the first
609:04 - question you should be answer asking is
609:06 - is there a weight involved or are there
609:08 - no weights now if there are way no
609:10 - weights involved then we're simply
609:11 - concerned with the length of the path
609:13 - the number of nodes in each path and in
609:15 - that case you can simply perform a
609:16 - breadth first
609:17 - a breadth first search
609:20 - but if you have weights whether it's
609:21 - directed or undirected then breadth
609:23 - first search alone may not be enough
609:25 - right because
609:27 - it may turn out that certain parts
609:30 - for instance you go from zero to three
609:33 - so you you go if you go via zero two
609:35 - four and three the length of the path is
609:37 - two plus three five plus four nine but
609:39 - if you sorry the
609:41 - yeah the total size the total size of
609:44 - the length of the path is two plus three
609:45 - five plus four nine but the number of
609:47 - nodes is four zero two three four
609:50 - on the other hand
609:52 - if you go via 0 1 3 in this case the
609:55 - number of nodes is smaller so there's
609:56 - just one in between so 0 1 3 there's
609:58 - just three nodes total but the length of
610:00 - the path is 14 which is far higher right
610:02 - so this could represent that you go to a
610:04 - far off place
610:06 - of via a train and then take a train to
610:08 - something that was actually closer even
610:10 - though there were more stops in a
610:12 - different route
610:16 - okay this is what we're going to
610:17 - implement now we're going to implement
610:19 - an algorithm to
610:21 - identify the shortest path from a given
610:24 - node to a given target okay so now this
610:27 - time we're going to focus
610:28 - our
610:30 - search between
610:31 - a node and a target so what is the
610:33 - shortest path
610:34 - in terms of the total weight of the path
610:37 - not in terms of the number of nodes in
610:38 - the path keep in mind what is the
610:40 - shortest path in terms of the total
610:42 - weight
610:43 - that we
610:45 - can find from
610:48 - a starting node to an end node
610:50 - and roughly the strategy goes like this
610:52 - and the strategy is called the distraus
610:54 - algorithm roughly the strategy goes like
610:56 - this you have the source node and the
610:58 - source node is at a distance 0 from
611:00 - itself so there's nothing there really
611:03 - but
611:06 - the first thing that we know the first
611:07 - and the only thing that we know is
611:10 - that
611:12 - for one of the siblings for one of the
611:14 - neighbors of the source node
611:17 - the direct edge will be the shortest
611:18 - path so
611:21 - for example we have one
611:23 - and we have two
611:25 - now you have directed
611:28 - you have direct edges from
611:30 - you have direct edges from
611:32 - zero to two and you have a direct edge
611:34 - from zero to 1.
611:38 - 0 to 2 has the weight 2 and 0 to 1 has
611:41 - the weight 4.
611:43 - now in this case suppose we had an edge
611:46 - from 2 to 1 and that edge had the weight
611:48 - one
611:50 - then you could go from zero to two with
611:52 - a weight two and then go from zero two
611:54 - to one by a weight one and the total
611:56 - weight you would incur to get to one
611:58 - would simply be three and that would be
612:00 - smaller than the
612:03 - shorter smaller than the direct edge
612:05 - right so even if we are looking at
612:06 - direct
612:08 - connections of the root we can't say
612:10 - that the direct edge is the shortest
612:11 - path
612:12 - except for one of the nodes right so if
612:15 - we just look at the node
612:17 - where the
612:18 - edge weight is the smallest so you start
612:21 - at the root and you look at the edge
612:23 - with the smallest weight
612:26 - then we can say for sure
612:28 - that
612:29 - the shortest path from the root to the
612:32 - next node to the node to
612:35 - is the direct edge why because this
612:37 - direct edge is smaller than or smaller
612:40 - than equal to any other direct edge so
612:42 - any other path that comes to two
612:44 - indirectly
612:46 - will contain an another direct edge and
612:49 - then some other edges right so it will
612:50 - have a length greater than or equal to
612:52 - this direct edge right so that's the key
612:54 - inside here that at every point you
612:57 - maintain a group of visited nodes so in
612:59 - this case initially just two zero is
613:00 - visited and then you find the first node
613:03 - which is
613:05 - at the closest distance from any node
613:07 - within the visited group okay so for
613:10 - example if we start out at zero and then
613:13 - we look at 1
613:14 - and we look at 2
613:15 - we see the smallest edges 2
613:17 - so we
613:19 - add 2 into our visited group because we
613:22 - we know that this is the shortest path
613:23 - from 0 to 2 and at this point now
613:27 - we take all of the siblings or all of
613:29 - the neighbors of two and update their
613:31 - weights now because we know that zero to
613:34 - two is a direct shortest path so we can
613:36 - update the distance for four that four
613:38 - could be at a potential distance of
613:42 - two plus three five or there could be a
613:44 - shorter path so we've not yet added it
613:46 - we'll just update four and similarly if
613:48 - there was a edge to one we can update
613:51 - the distance of one and we can say that
613:52 - the distance of one is
613:54 - either 4 which was a direct edge or it
613:57 - can be 2 plus 1 if there was a direct
613:59 - edge from 1 so now we will get to know
614:01 - that
614:02 - 1 is at a distance of 3 which is smaller
614:05 - right in this case it's not but suppose
614:07 - there was a direct edge from 2 to 1 of
614:08 - weight 1 we would get to know that
614:11 - 1 is at a distance 3 so each time you
614:14 - add a new node as you mark a node as
614:16 - visited you you update the weights of or
614:19 - update the distances of all its
614:21 - neighbors and then you simply
614:23 - find the next node with the smallest
614:25 - distance right so you will find that the
614:27 - next node with the smallest distance in
614:29 - this case is four
614:30 - and then you update the numbers of four
614:32 - there's only one neighbor the next node
614:33 - with the smallest distance is three you
614:35 - update the weights of three and so on so
614:38 - that was shortest path in a directed
614:40 - graph but here let's see a shortest path
614:41 - in an undirected graph where we have
614:43 - more such cases
614:48 - let's just watch this
614:50 - from the beginning let's wait for the
614:51 - animation to start again
614:55 - so we start at zero
614:56 - then we check two okay we mark two as
614:58 - updated then we check nine then we mark
615:01 - three as updated then we update the
615:02 - distance of 14
615:04 - but now we can see here that we have
615:06 - another path to go to 2 or we go to 3
615:08 - that's why we
615:10 - track that
615:11 - and finally we get 2 we mark 2 as
615:13 - visited now we are considering 3 and
615:16 - using 3 we are updating the weights of
615:18 - all the other
615:19 - graph all the other nodes and then we
615:21 - are marking 3 as visited then we are
615:23 - using 3 to mark 6 as visited and so on
615:26 - right so at each point you have a group
615:28 - of visited nodes and you have distances
615:31 - for all the nodes that are connected
615:33 - with the visited nodes
615:35 - and then you pick the first unvisited
615:37 - node with the smallest distance okay now
615:40 - let's read the algorithm
615:43 - you first mark all nodes as unvisited
615:45 - and then you create a set of all the
615:48 - unvisited nodes and you call it the
615:49 - universal set so a set of all the
615:51 - unvisited nodes is called the universe
615:54 - call it the unvisited set
615:56 - assign to every node a tentative
615:58 - distance value
615:59 - now set it to zero for the initial node
616:01 - because the initial node is at a
616:03 - distance 0 and set it to infinity for
616:05 - all the other nodes
616:07 - so we now set the distance to infinity
616:09 - because we've not yet visited the nodes
616:11 - we don't know their distance
616:14 - then you set the initial node as the
616:15 - current node so there is a always a
616:17 - current node that we're looking at in
616:19 - this case we'll start with the initial
616:20 - node
616:21 - now for the current node consider all of
616:24 - its unvisited neighbors
616:26 - and then calculate their tentative
616:28 - distances through the current node right
616:30 - so you have the current node and the
616:31 - current node is connected to a lot of
616:33 - unvisited nodes
616:39 - and if we look at each unvisited node we
616:41 - know the distance up to the current node
616:43 - because the current node is visited and
616:45 - using that we can calculate distances
616:48 - for the unvisited nodes
616:50 - now if the unvisited nodes have
616:52 - distances set to infinity then we know
616:55 - that the distance from the current node
616:57 - distance y for going wire the current
616:59 - node is going to small is going to be
617:01 - smaller than the distance infinity that
617:03 - has been set but on the other hand if
617:05 - the
617:06 - if a distance has already been set for
617:08 - an unvisited node through some other
617:10 - node then we can simply compare whether
617:13 - it is better to go through the current
617:15 - node or whether it is better to retain
617:16 - the retain the distance that was
617:18 - obtained by some other node
617:20 - and just maintain that right so in this
617:21 - way we simply update the distances of
617:24 - all the unvisited nodes that are
617:27 - neighbors of the current node okay so
617:29 - for example if the current node is a and
617:32 - it is marked with a distance of six
617:34 - and then there is an edge connecting it
617:36 - with a neighbor
617:38 - b and then that edge has the weight or
617:40 - the length two
617:41 - then the distance to go to b through a
617:44 - from the source will be six plus two
617:47 - eight right so from the source to a is
617:49 - six a to b is two so the distance if you
617:51 - want to go to b through a will be six
617:53 - plus two eight
617:54 - on the other hand if b was already
617:57 - previously marked with a distance right
617:58 - so it was not visited but it was just
618:00 - marked with a distance
618:01 - greater than eight
618:03 - then we know that we have found a
618:04 - shorter path via a so we update its
618:07 - distance to 8.
618:08 - on the other hand if we have a value
618:10 - let's say the value of for visiting b by
618:12 - an another node d was seven so we keep
618:15 - the distance as seven right so we're
618:17 - simply updating the distance we are not
618:19 - yet marking
618:21 - these new we are not yet marking b as
618:23 - visited
618:25 - now when we are done updating all the
618:28 - distances for the current node
618:31 - then we mark the current node as visited
618:35 - and of course we remove it from the
618:36 - unvisited set right so we mark the
618:38 - current node as visited
618:39 - then
618:40 - a visited node will never be checked
618:42 - again because once you have visited a
618:44 - node you have found the shortest paths
618:45 - to it and you have used it to update the
618:48 - distances of all its neighbors you never
618:49 - need to visit it again
618:52 - so then
618:55 - find the first unvisited node
619:00 - find the first unvisited node that is
619:02 - marked with the smallest distance right
619:04 - so now we have a bunch of visited nodes
619:06 - and then we have a bunch of unvisited
619:07 - nodes many of those unvisited nodes have
619:09 - been marked with a distance so you
619:11 - simply get the first unvisited node with
619:14 - the smallest distance
619:15 - and make it the current node and then
619:17 - repeat the process okay
619:20 - so you start out with zero you see that
619:22 - you can mark two as you can mark the
619:24 - distances of four one and two so one
619:26 - gets the distance four and two gets the
619:28 - distance two
619:29 - now
619:30 - then you mark zero as visited
619:32 - now you see that the
619:34 - node with the least the unvisited node
619:36 - with the least distance is two
619:39 - so you get two and then you mark the
619:42 - mark the edges from two so you mark the
619:44 - distance for 4 as 2 plus 3 5 and suppose
619:48 - 2 had an edge to 1 then you would mark
619:50 - the distance for 1 as 2 plus 1 if 1 was
619:53 - the weight of the edge let's say you
619:54 - would mark the distance for 1 as the
619:56 - minimum of 4 and 2 plus 1 so which will
619:58 - be 3
620:00 - so you can mark the distance for a 1s3
620:05 - and that's it and then you
620:06 - remove 2 from the unvisited set next you
620:09 - find the
620:10 - next unvisited node the which has the
620:14 - lowest distance so if this edge existed
620:17 - that would be one but if since this says
620:19 - if this h does not exist that would be
620:21 - four so you get four and then you mark
620:23 - the
620:24 - distances for the neighbors of four and
620:26 - so on okay
620:31 - so what we'll do is we will
620:32 - create this
620:36 - we create this graph here
620:38 - which contains
620:43 - okay there should be a graph here that
620:45 - we can look at
620:47 - yeah so we'll create this graph here
620:49 - which contains uh
620:51 - 0 to 6 which contains 6 nodes 0 to 5.
620:57 - this is the graph we are creating
621:08 - let's just put it here this graph
621:11 - yeah so this is a graph that we'll work
621:13 - with
621:14 - and
621:15 - let's start writing our shortest path
621:16 - algorithm
621:18 - so def shortest path
621:23 - and we have a graph
621:25 - and that's it we have a we have a start
621:27 - node
621:29 - so let's call it source and then we have
621:31 - a target node that node that we want to
621:33 - get to so we want to go from zero to
621:35 - five
621:36 - and as soon as we have the as soon as we
621:38 - mark the target node as visited our
621:40 - algorithm is done right so first we
621:45 - mark everything as unvisited by setting
621:48 - visited false
621:52 - times lan graph.data so here we have
621:55 - marked visited then we have distance so
621:57 - we take we take the distance as infinity
622:00 - so here's a way to create infinity in
622:03 - python you just say float in
622:07 - and once again we set all distances to
622:09 - infinity
622:15 - then we are going to maintain a queue
622:17 - so because we have this first in first
622:19 - out kind of structure so we're going to
622:20 - maintain a queue
622:23 - the first thing we'll do is
622:25 - we will
622:27 - mark
622:29 - the distance
622:32 - for
622:35 - the source node
622:36 - as zero
622:39 - then we can insert the source node into
622:42 - q so q dot insert
622:44 - or q dot append
622:46 - source and then we'll set an index to
622:49 - keep track of
622:51 - what is the next element that we need to
622:53 - dequeue so the first element is what we
622:54 - need to dequeue so while index is less
622:57 - than
622:59 - zero
623:01 - and
623:03 - not visited
623:05 - target so while index is less than the
623:07 - length of the queue
623:08 - and the target is not visited
623:11 - so what do we need to do we need to get
623:12 - the current element from the queue so we
623:14 - simply get
623:16 - q of idx
623:18 - and then we increment increment idx by 1
623:21 - so we increment idx by 1 here
623:24 - then we need to take all the neighbors
623:27 - of
623:29 - queue
623:30 - all the neighbor we also need to finally
623:32 - mark it as visited so let's just put in
623:34 - visited current equals true here
623:37 - but in between what we need to do is we
623:38 - need to update the distances
623:43 - of all the neighbors
623:49 - and then we also need to
623:51 - find the next
623:53 - node with the
623:55 - find the first
623:57 - unvisited node
624:02 - with the smallest
624:04 - distance okay
624:06 - so to update the distance of all the
624:08 - neighbors we have written a function
624:10 - called update distance
624:12 - so we'll call this function update
624:14 - distance
624:15 - or update distances
624:18 - where we will pass in the graph and we
624:20 - will pass in the current node and we
624:22 - will pass in the distance matrix or the
624:25 - distance array
624:27 - and we pass it in this way
624:29 - and what update distances does let's
624:32 - look let's look at it here and again
624:33 - it's always a good idea to extract out
624:35 - specific pieces of logic into separate
624:37 - functions
624:38 - so here you we're calling update
624:40 - distances where we have a current node
624:42 - and then we have the graph and then we
624:43 - have the distance so we get the
624:45 - neighbors of the current node using
624:47 - graph dot data
624:49 - draft or data current will give us the
624:50 - neighbors of the current nodes
624:52 - then we get the weights of of the
624:54 - neighbors of the edges connecting the
624:56 - current node to its neighbors so we get
624:58 - the weights as well
624:59 - now we go through each list of neighbors
625:02 - so for i common node in enumerate
625:04 - neighbors
625:08 - and then we check
625:10 - we get the weight so we now we have the
625:12 - node and we have the weight so we have
625:14 - for each edge
625:17 - the node that
625:19 - it is connected to
625:22 - and the weight of the edge
625:24 - and then we check the distance for the
625:26 - node if the distance for the node
625:29 - let's say hasn't already been said then
625:31 - it is infinity so in that case distance
625:34 - to the current node from the source plus
625:36 - the weight of the edge from the current
625:38 - node to the
625:39 - next node will be less than the distance
625:42 - so if the distance flow of current plus
625:43 - weight is less than the distance we
625:45 - simply update the distance of the node
625:47 - on the other hand if the distance of the
625:49 - node has already been set via some other
625:51 - node and that is less than the distance
625:54 - via the current node then we do not
625:55 - update the distance
625:57 - okay so that's all we are doing here
625:59 - and we can ignore this for now we'll
626:01 - come back to it but this is performing
626:03 - exactly that update distances function
626:05 - that we talked about
626:06 - then next we want to find the next
626:08 - unvisited node so here we have a
626:10 - function called pick next node which has
626:12 - a list of distances and it has visited
626:14 - so
626:15 - we want to track the minimum distance so
626:17 - we first set a variable called minimum
626:19 - distance
626:20 - to the value infinity and then we set a
626:23 - variable min node so this is the node
626:25 - with the minimum distance to the value
626:26 - none
626:27 - then we iterate over
626:29 - the
626:30 - all the lists all the nodes in the
626:33 - that we have in the graph so from 0 to n
626:35 - minus 1 and we check that if the node is
626:38 - not visited
626:39 - and the distance of the node is less
626:41 - than the minimum distance we've obtained
626:43 - so far
626:44 - then we set that node to the minimum
626:46 - node and we set the minimum distance to
626:47 - that value
626:49 - okay so we track the minimum distance
626:50 - the running minimum distance by going
626:53 - over all the nodes in the
626:55 - graph and we keep track of which node
626:58 - has the minimum which unvisited node has
627:00 - the minimum distance so finally what
627:03 - pick next node gives us is the first
627:05 - next unvisited node
627:08 - okay so here we can get next node
627:13 - is
627:14 - pick next node
627:17 - and we give it the distance and we give
627:19 - it visited
627:25 - okay
627:27 - so now
627:28 - if there was a next node it's possible
627:30 - that there is no next node because we've
627:32 - probably already visited everything that
627:34 - we can visit
627:35 - so if there is a next node
627:38 - then we enqueue it so we say q dot
627:40 - append
627:42 - next node
627:48 - and that's it
627:50 - that's pretty much it so that is our
627:52 - shortest path algorithm
627:56 - we
627:57 - create a visited list we create a
627:59 - distance list we create a queue where we
628:01 - will add things so this this will be all
628:02 - the
628:04 - all the nodes that we have visited will
628:05 - go through it or go through this one by
628:08 - one
628:08 - and the q in order will give us
628:11 - a list of all the nodes in their order
628:14 - of distance from
628:16 - the source node
628:17 - now what we need to return here
628:19 - is we simply need to return distance of
628:22 - the target and since that was what was
628:24 - asked here
628:30 - let's also mark current as visited
628:32 - through here soon enough so that we
628:35 - don't end up
628:36 - visiting current again and again
628:42 - all right so let's run the shortest path
628:43 - algorithm then
628:45 - here we have a graph
628:47 - this is the same graph that we see here
628:58 - now we can create a graph graph 7
629:02 - and this is
629:04 - weighted and directed so we will pass in
629:06 - graph we will pass num nodes
629:08 - seven
629:09 - we will pass edges seven
629:12 - and then we will
629:14 - pass weighted equals true and directed
629:16 - equals true
629:18 - and this is graph seven
629:25 - okay this seems like it was it worked
629:27 - out right zero is connected to one and
629:29 - two with the weights four and two
629:31 - respectively
629:32 - and 5 is connected to nothing
629:36 - 4 is connected 3 is connected to 5 4 is
629:38 - connected to 3 okay this looks fine
629:41 - so now we can say
629:44 - shortest path
629:47 - in the graph
629:48 - from let's say from 0
629:51 - to 5
629:55 - in graph 7
629:56 - and it says that the length of the
629:58 - shortest path is 20. so you have 2 3
630:00 - four eleven so two plus three five
630:03 - five plus four nine nine plus eleven
630:04 - twenty so that seems to be right
630:06 - what would also be nice to get is just
630:09 - to see
630:10 - what that path is and for this we can
630:12 - introduce something called a parent
630:15 - so here we can simply have another thing
630:17 - called a parent
630:18 - which is set to none for each element
630:23 - so visited
630:25 - let's call this parent
630:27 - and let's set it to none by default and
630:30 - all we need to do is whenever we are
630:32 - enqueuing a node we need to track why it
630:35 - got enqueued right so if an if a node is
630:38 - getting enqueued then it is probably
630:39 - getting enqueued so sorry not whenever
630:41 - we are enqueuing whenever we are
630:43 - updating the distance of a node we need
630:45 - to track why
630:46 - why its distance got updated so inside
630:49 - update distances whenever we update the
630:51 - distance of a node
630:53 - we also set the node the parent of the
630:56 - node to that current node
630:58 - from which the distance got updated
631:00 - right and that's all we need to do when
631:02 - we update the distance of a node we need
631:04 - to track why did we update this distance
631:07 - by which node we did we come to update
631:09 - this distance so this way we have now
631:11 - tracked the parent
631:13 - and let's return not just the distance
631:15 - of the target but let's also return the
631:17 - queue
631:18 - and let's return
631:21 - let's just return the parent for now
631:23 - i think this should be
631:24 - fine
631:26 - okay so now you have the parent for each
631:28 - one so if you look at the fifth element
631:30 - 0 1 2 3 4 5 you can see that the parent
631:33 - of 5 is 3
631:34 - so it seemed like we arrived at 5 from 3
631:37 - and then if you look at the parent of 3
631:39 - so zero one two three the parent of
631:40 - three was four it seemed like we arrived
631:42 - at three from four then you look at the
631:44 - parent of two it seems like we arrived
631:46 - at
631:47 - from at four from two then you look at
631:49 - the parent of
631:51 - two and it looks like we arrived there
631:53 - from 0
631:54 - and 0 was our source so the path
631:57 - is if simply going reverse 0 2 4 3 5
632:01 - okay and that's how you get the shortest
632:03 - path and not just the shortest path
632:04 - distance now notice that 0 itself does
632:07 - not have a parent because that was the
632:08 - source
632:10 - now you can repeat this with another
632:12 - graph let's say we take this other graph
632:15 - that we had
632:18 - this was
632:21 - graph two so let's grab this image here
632:34 - so let's get graph two and let's say
632:36 - shortest path
632:39 - graph two
632:42 - and let's get the shortest path maybe
632:44 - from
632:46 - zero to seven so it seems like there are
632:48 - two parts one goes by one and one goes
632:50 - by a six
632:51 - two three
632:52 - three two and seven so let's get the
632:54 - shortest path from zero to seven
632:59 - okay so we started out with zero and we
633:02 - end up at 7 so 0 1 2 3 4 5 6 7. it seems
633:07 - like the parent for 7 was 1
633:10 - and then the parent for 1 was 0.
633:12 - so it's clear that it picked the path 0
633:14 - 1 7 and the total length of the path was
633:17 - seven
633:18 - sounds good
633:20 - we can try another one we can try
633:24 - two and eight so there are a couple of
633:26 - ways to go from two to eight
633:28 - one is to go wire three
633:30 - so you can go to six to other three ways
633:33 - actually but six two uh six z uh you can
633:36 - go at three zero and eight or you can go
633:38 - at three four and eight let's see which
633:40 - one it picks
633:43 - okay so now zero one two three four five
633:46 - six seven eight so the parent for eight
633:48 - is five
633:50 - oh sorry zero one two three four five
633:53 - six seven eight so the parent for eight
633:55 - is four so we came to eight wire four
633:57 - and then the parent for four zero one
633:59 - two three four apparent four four is
634:01 - three so we came to four wire three
634:04 - and then the parent for three zero one
634:05 - two three the parent for three is two so
634:08 - we came to three y six wire two so two
634:10 - three four is the path and the length
634:12 - should be
634:13 - eight plus one nine plus six fifteen
634:16 - great it seems like we've figured out
634:17 - the shortest path once again and this
634:18 - time this was an undirected graph okay
634:21 - so as long as you have weights you can
634:22 - apply this algorithm and this algorithm
634:24 - is called the dystra's algorithm
634:29 - and that's it so that's all we're going
634:30 - to cover today
634:32 - now one thing that we have not looked at
634:34 - very closely is the running time
634:35 - complexities so let's do a quick
634:38 - look at that let's do a quick look at
634:40 - let's say bfs
634:43 - and see if we can identify and get or
634:44 - guess the running time complexity and
634:46 - the full proof is left to you as an
634:48 - exercise but roughly it looks like this
634:51 - this is the main
634:53 - this is the main loop here so where we
634:55 - are going through the queue
634:58 - so the number of times this may happen
634:59 - is n
635:01 - which is the number of n which is the
635:02 - number of
635:04 - nodes
635:05 - and the number of times this might
635:06 - happen now inside each for each node
635:09 - inside bfs remember that we check a full
635:11 - list of nodes inside each node for bfs
635:14 - so the number of times this may happen
635:16 - is equal to the number of
635:18 - for each node we may perform an
635:20 - additional number of steps equal to the
635:22 - number of nodes it is connected to right
635:25 - so if we have n nodes
635:27 - so we have n while loops and then if we
635:29 - have a total of m edges and let's say
635:31 - those m edges are split across if i
635:33 - count the number of edges for each node
635:35 - the number of edges is e1 e2 e3 e4 and
635:37 - so on and then we so the num the num the
635:40 - size of this loop for the node
635:42 - n1 is e1 the size of this loop for the
635:45 - node n2 is e2 the size of this loop for
635:47 - node n3 is e3 so if you add up the list
635:50 - of all the edges e1 plus e2 plus e3 plus
635:53 - e4 so the total number of iterations
635:55 - inside this for loop turns out to be
636:01 - you can see here
636:03 - the total number of iterations inside
636:05 - the for loop will turn out to be the
636:07 - total the sum of all the
636:09 - adjacency lists okay and this total sum
636:12 - of all the adjacency list is equal to
636:14 - twice the number of edges you can see
636:16 - here the number of edges is one two
636:17 - three four five six seven and you can
636:19 - verify that the number of elements of
636:21 - all the adjacency lists put together is
636:25 - 14 because each edge is represented
636:27 - twice right so we end up if we have
636:30 - n
636:32 - so if you have n
636:34 - f n vertices and
636:37 - m edges we end up with n plus two m
636:41 - operations right so each of the n
636:44 - operations to start the while loop and
636:45 - then each of the two m operations
636:48 - those are to iterate over each adjacency
636:51 - list right and now when we are talking
636:53 - about
636:54 - complexities we can ignore the m if m is
636:58 - the number of edges we can ignore the
636:59 - factor 2 associated with it so what we
637:02 - end up with with is order of n plus m
637:08 - so order of n plus m is the complexity
637:11 - of
637:12 - breadth first search
637:14 - and now by this by this point
637:16 - you should be able to just work it out
637:18 - by looking at the code so do try it out
637:19 - and if you if it's not clear do ask on
637:22 - the forum but order of n plus m is the
637:25 - complexity of brett first search and you
637:27 - will find a similar complexity for depth
637:30 - first search as well
637:32 - order of n plus m
637:36 - for the shortest path algorithm however
637:38 - the complexity will be different
637:42 - because in the shortest path algorithm
637:44 - let's see it here
637:49 - in the shortest path algorithm what we
637:51 - do is
637:52 - we go over all the vertices so that's we
637:56 - insert each vertex or each node into the
637:59 - queue once and then we take it out once
638:00 - so this contributes a factor n
638:02 - then when we are saying update distances
638:04 - then it also contributes the factor m
638:08 - but when we are picking the next node we
638:10 - may we visit all the vertices once again
638:13 - right so
638:14 - here we are performing n operations
638:17 - inside when we are picking the next node
638:19 - so that gives us
638:22 - order of
638:23 - n square
638:24 - plus nm
638:27 - n square plus m
638:30 - yeah something like that so order of n
638:32 - square plus m or n plus m into n so
638:35 - that's you those are some complexities
638:37 - that you will see reported for shortest
638:38 - path
638:40 - and a way to improve this a way to
638:42 - improve the picking of the next node is
638:44 - to use what is called a min heap so that
638:46 - you don't have to look through the
638:47 - entire list of nodes each time
638:50 - to pick the next node but you can simply
638:52 - pick the next node in a very short time
638:55 - so there's a data structure called a min
638:57 - heap that you can look at the min heap
638:59 - allows
639:01 - is used to keep track of a bunch of
639:03 - numbers and easily track the minimum so
639:06 - you can keep a bunch of numbers around
639:07 - in a binary tree like this and the root
639:09 - will always be the minimum and the
639:11 - numbers on the left and right will
639:13 - always be larger than the root and then
639:15 - the same will be true for each subtree
639:17 - as well
639:19 - an insertion into this heap is of order
639:21 - login and deletion into this heap is of
639:24 - order login as well and then the min max
639:26 - in this case
639:28 - fetching the min or the maximum value is
639:30 - of order one so instead of mainta
639:32 - instead of looping through the entire
639:33 - list of nodes each time what you can do
639:35 - is you can simply insert nodes into this
639:38 - min heap and delete nodes from the min
639:39 - heap when they become visited and
639:42 - getting the next node is as simple as
639:44 - fetching the minimum value
639:46 - okay so
639:48 - check this out this is not something
639:50 - that will generally get asked this is a
639:52 - more advanced concept in fact even the
639:54 - distraught shortest path algorithm it's
639:56 - very unlikely that you will get asked
639:58 - but do review it and do try as an
640:00 - exercise if you want to go further try
640:02 - implementing and improving the distress
640:04 - algorithm
640:05 - using a binary heap
640:07 - so that will take the complexity for
640:09 - from m plus n times n to m plus n times
640:13 - log n
640:14 - okay and that may be better so do check
640:17 - that out that's obviously going to be
640:18 - better for larger graphs
640:21 - so do try to implement it in fact inside
640:24 - python there is a built-in heap called
640:26 - the heap queue data structure
640:28 - and that will that will optimize the
640:33 - pick next node
640:36 - operation
640:38 - in the distress algorithm
640:41 - so that concludes our discussion of
640:43 - graphs here there's a lot more in graphs
640:45 - graph theory is an entire course in
640:47 - itself but since this
640:49 - course is particularly concentrated on
640:51 - data structures and algorithms from the
640:52 - perspective of coding interviews and
640:54 - coding assessments this is as far as we
640:57 - need to go so what you should do is you
640:59 - should practice more graph problems
641:01 - related to breadth first search and
641:02 - depth first search that is really
641:04 - something
641:05 - that you need to become very familiar
641:07 - with breadth first and depth first
641:08 - search and shortest path may be in
641:10 - sometimes
641:12 - some some really hard interviews you may
641:14 - get asked the shortest path as well so
641:16 - do familiarize yourself with that but
641:18 - apart from that you don't really need a
641:19 - lot more
641:21 - but there are other algorithms you can
641:23 - look at minimum spanning trees you can
641:25 - look at topological sorting you can look
641:28 - at connected components that's another
641:31 - path you can look at detection of cycles
641:35 - and there's something called disjoint
641:36 - sets so there's a huge huge number of
641:38 - topics that we can cover in graphs but
641:40 - we'll stop our discussion here so what
641:42 - do you do next review the lecture video
641:44 - and execute the jupiter notebook
641:47 - complete the assignment and attempt the
641:48 - optional questions and finally
641:50 - participate in forum discussions very
641:52 - important if you're stuck at any point
641:54 - just go on the forum ask a question
641:56 - you can also share your code as long as
641:58 - it's not working to get help
642:00 - and you can also join or start a study
642:02 - group to learn together with friends
642:06 - and you can also find us on twitter at
642:07 - chopin ml and akash in s
642:10 - and the next lesson is data structures
642:12 - and algorithms
642:15 - in in data structures and algorithms is
642:17 - python interview tips tricks and
642:19 - practical advice
642:20 - thank you
642:21 - hello and welcome to data structures and
642:23 - algorithms in python
642:26 - this is an online certification course
642:28 - being conducted by jovian
642:30 - today we're on lesson six python
642:32 - interview tips tricks and practical
642:34 - advice
642:35 - this is the final lesson of this course
642:38 - so i hope you're excited
642:41 - my name is akash and
642:43 - i'm your instructor
642:45 - you can find me on at akashenist
642:50 - if you've been following along with this
642:51 - course
642:53 - and you have been working on the
642:55 - assignments
642:56 - and if you complete a course project as
642:58 - well then you can earn a certificate of
643:00 - accomplishment for the course
643:02 - which you can find on your jovian
643:04 - profile and also add to linkedin or
643:06 - download as pdf
643:09 - so let's get started first thing we'll
643:11 - do is go to the course website
643:14 - pythondsa.com
643:17 - so this is the course website
643:19 - pythondsa.com this is where you'll find
643:21 - all the information about the course
643:24 - you can watch all the previous lessons
643:26 - lessons one through five and you can
643:28 - also check out the previous assignments
643:30 - assignment one two three and you have
643:32 - the course project as well
643:35 - let's open up lesson six
643:40 - now on lesson six you will be able to
643:42 - find a video recording
643:44 - of the video you're watching right now
643:48 - and here is the code that we will look
643:50 - at today
643:51 - so today we will do something different
643:53 - we will
643:54 - simulate the experience of being in an
643:56 - interview
643:58 - so while we have given you a problem
644:00 - solving template and we recommend that
644:02 - you follow this template for any project
644:04 - or any notebook that you work on any
644:06 - coding problem that you work on
644:08 - and here on the problem solving template
644:11 - we also have a method something that
644:13 - we have been applying throughout this
644:15 - course
644:16 - to different kinds of problems different
644:18 - kinds of data structures and algorithms
644:20 - but in an interview obviously you will
644:22 - not have this template
644:24 - so we'll see how to apply this method
644:27 - during an interview
644:29 - and before we do that let's revise the
644:31 - method so that we can recall it from
644:32 - memory when we are working on the
644:34 - interview problem
644:35 - so here is the systematic strategy that
644:37 - we have been applying so far for solving
644:39 - problems and do check out the previous
644:41 - lessons if you haven't seen them for
644:43 - examples of how to apply it in detail
644:47 - so the step one is to
644:50 - state the problem clearly in your own
644:52 - words
644:53 - and identify the input in output format
644:56 - and then the second step is to come up
644:58 - with some example inputs and outputs and
645:00 - try to cover all the edge cases that you
645:02 - can think of you want to think of all
645:04 - the possible scenarios and that will
645:06 - help you
645:07 - write your code properly then step three
645:10 - is to come up with a correct solution
645:12 - for the problem and state that solution
645:14 - in plain english
645:16 - and then step 4 is to implement the
645:18 - solution and test it using some example
645:20 - input this is important
645:22 - while you're practicing but initially
645:24 - when you come up with a correct solution
645:26 - it will be a simple solution what is
645:27 - often called a brute force solution and
645:30 - in an interview setting you may not have
645:32 - the time to implement it from scratch so
645:34 - you may skip if the brute force solution
645:36 - is too straightforward
645:39 - then step five is to analyze the
645:41 - algorithm's complexity and identify any
645:43 - inefficiencies in the algorithm
645:45 - so what you can do in an interview is
645:47 - come up with the correct solution and
645:48 - describe it to the interviewer and then
645:51 - analyze its complexity directly and
645:53 - start identifying inefficiencies and
645:55 - then move on to apply the right
645:58 - technique to overcome the inefficiency
646:00 - so this is where you need to identify
646:02 - what
646:03 - which one of the techniques that you've
646:04 - learnt in this course do you need to
646:06 - apply
646:07 - is this a binary search problem is this
646:09 - a divide and conquer problem is this
646:11 - related to binary search trees is this
646:15 - something that you can solve in a
646:16 - similar way you'd solve sorting is it
646:19 - important to look at the worst case or
646:20 - average case complexity
646:22 - is this a graph problem or is this a
646:26 - recursion or
646:29 - is this a dynamic programming or a
646:30 - memoization problem so all of these
646:32 - things are something that you have to
646:33 - think about and as you practice more and
646:35 - for more problems so for each of the
646:37 - lessons if you try and practice about
646:39 - five to ten problems then you will start
646:41 - to recognize these patterns and when
646:43 - you're on step six when you're trying to
646:45 - come up with the right technique to
646:46 - overcome the inefficiency the ideas will
646:49 - automatically come to you so practice is
646:51 - very important to succeed in step six
646:55 - and once we have determined how to
646:57 - overcome the inefficiency through the
646:58 - right data structural algorithm then we
647:01 - state that solution implement it analyze
647:03 - the complexity right so this is how
647:05 - your
647:06 - a coding assessment or an interview
647:08 - should proceed for you
647:10 - and let's see let's pick up a coding
647:12 - problem and let's go from there
647:14 - so here we have a coding problem python
647:16 - sub array with the given sum and we read
647:18 - the problem but before that you can see
647:21 - that here this
647:22 - notebook is fairly empty
647:25 - and we what we're trying to do is we're
647:27 - trying to simulate the situation where
647:28 - you are on a call with somebody and they
647:30 - are interviewing you and typically they
647:32 - would be using some platform like
647:35 - a collab edit or maybe a platform where
647:37 - you can also run the code
647:38 - or a platform where
647:42 - the question is somewhere let's say on
647:44 - the right it's already printed it's from
647:45 - a pre-selected database on on the right
647:47 - on the left and on the right you can
647:49 - type your code and you can experiment
647:52 - with it now we're not using any third
647:54 - platform here what we'll do is we'll
647:55 - simply simulate that in our jupyter
647:57 - notebook
648:01 - okay so now we have this notebook
648:02 - running we've clicked the run button on
648:05 - the jobin notebook and here we are
648:08 - now the question is
648:10 - and this is a question that was asked
648:11 - during a coding interview for amazon of
648:13 - course a lot of other companies may ask
648:15 - similar questions too
648:17 - you are given an array of numbers and
648:19 - these numbers are all non-negative
648:23 - you need to find a continuous sub array
648:25 - of the list which adds up to a given sum
648:28 - this is how interviewer might state the
648:30 - problem to you
648:32 - and then they may also tell you an
648:34 - example sometimes they don't and if they
648:36 - don't it's always a good idea to ask for
648:38 - example now
648:40 - you might sometimes feel that maybe if
648:42 - you ask too many questions the
648:44 - interviewer might think that that you
648:45 - don't know this or you're dumb in some
648:47 - way but that's not true it's actually
648:49 - the opposite the more questions you ask
648:51 - the better the interview
648:53 - the better the interviewer is able to
648:55 - convey what they want right now they're
648:57 - busy they're doing five interviews a day
648:59 - and they have their entire day's work
649:01 - sometimes they may just fail to state
649:03 - the question in its entirety and if you
649:05 - don't ask for clarifications you may
649:07 - assume the wrong thing and go ahead and
649:10 - implement something that's completely
649:11 - wrong and
649:13 - that completely deals your interview and
649:14 - trust me it happens more often than you
649:16 - might think
649:19 - okay
649:20 - so
649:22 - we here is one example so let's say if
649:24 - the interviewer did not provide an
649:25 - example you can ask them can you please
649:27 - give me an example for this problem and
649:30 - then they come back to you and they say
649:31 - suppose we have this array one seven
649:34 - four two one three eleven and five these
649:36 - are these are all numbers and they're
649:38 - all non-negative some of these could be
649:40 - 0 as well but suppose we have this array
649:43 - and i give you the number 10 that i want
649:45 - you to find the large
649:47 - i want you to find a continuous sub
649:49 - array of the list which adds up to the
649:51 - given sum which is 10.
649:54 - so
649:55 - then they might also tell you that in
649:57 - this case the solution is this sub array
649:59 - starting from position 4
650:01 - starting from the number 4 and going all
650:03 - the way up to 3 and you can check that
650:05 - there are no other ways to create 10
650:06 - like if we took 1 7 that would be 8 and
650:08 - 1 7 4 would be 12. on the other hand 7 4
650:12 - 2
650:12 - would be 12 again but 4 2 1 3 turns out
650:16 - to be 10 and once again on the right you
650:18 - will not be able to create the total of
650:19 - 10.
650:21 - so this sub-array is what you have to
650:23 - return now what does it mean to return a
650:25 - sub-array to return a sub-array means to
650:27 - return the indices which is the
650:30 - index of the starting term or and the
650:33 - index of the ending term and sometimes
650:35 - we know in python when we're working
650:36 - with ranges typically the end index is
650:39 - outside of the actual data so you could
650:42 - return the index of 4 in the index of 11
650:44 - so that we so the index of 4 is 0 one
650:47 - two so two is the index of four three
650:49 - four five six index of eleven six so if
650:52 - you return two and six and then i try to
650:54 - access
650:57 - the two to six two colon six range of
651:00 - the list then you will get get this list
651:01 - four two one three in fact that's
651:04 - something that we can very quickly
651:05 - verify here
651:07 - let's say l1 so you have one
651:09 - seven
651:10 - four two one three
651:13 - now if i say that the start index is the
651:15 - start index i
651:17 - and the end index j are 2 and 6
651:19 - respectively
651:20 - and you can see l 1 of 2 to 6
651:24 - is 4 2 1 3 right so although j is
651:27 - outside so that doesn't get included
651:29 - when we put it as a range
651:31 - and then we put in 4 2 1 3
651:33 - and you can also verify that the sum
651:36 - is 10.
651:39 - all right so that's the problem now i've
651:41 - explained it to you in a lot more detail
651:43 - than an interviewer would
651:45 - but this is the process that you have to
651:47 - apply in your own mind what and
651:48 - sometimes what you can also do is you
651:50 - can repeat the problem back to the
651:51 - interviewer that's a great idea you you
651:53 - they've stated the problem to you
651:55 - they've maybe given you an example now
651:56 - you state the problem yourself in simple
651:58 - words remember that was step one so in
652:01 - the same way that i just have you can
652:02 - state the problem and then you have to
652:05 - figure out what are the inputs and the
652:06 - outputs so the input you have an array
652:09 - or array is also a list in python so
652:11 - let's say arr
652:12 - zero let's create let's make this the
652:14 - first an example first input and that
652:16 - would be one seven four two one three
652:21 - and then the target so your target sum
652:23 - is ten
652:25 - that's the input here and then the
652:27 - output that we want to want is
652:31 - so this is the
652:32 - output 0 that would be
652:36 - 2 comma 6 as we've just verified
652:40 - so this is the input and output format
652:43 - always makes sense to just create some
652:45 - variables for that before you start
652:46 - coding
652:49 - the next step is to think of what are
652:51 - all the cases that a function
652:54 - should be able to handle but actually
652:56 - before we do that we should also write a
652:58 - function signature because we know what
652:59 - the input looks like we know what the
653:01 - output is going to look like and we know
653:02 - what so we know what the function should
653:04 - look like so we can just say def
653:08 - and let's call this sub array sum
653:12 - and it's going to take an array it's
653:14 - going to take a target and there's going
653:16 - to be some
653:17 - logic inside it okay all right so that
653:19 - was step one sorry i forgot about the
653:21 - function signature but it always helps
653:23 - to just write the function signature
653:24 - because if you've misunderstood the
653:26 - problem still the interviewer can
653:27 - immediately correct you and tell you hey
653:29 - but you haven't taken a certain input or
653:31 - you've assumed an input which i have not
653:33 - provided okay all right so now we have
653:35 - the function signature now step two
653:37 - remember step two was come up with an
653:40 - exhaustive list of test cases to test
653:42 - the problem so you can do this in
653:44 - comments
653:45 - you can just create some comments and
653:46 - you can say i'm thinking about the
653:48 - problem and i'm just trying to think
653:50 - what are all the cases we need to handle
653:53 - and this is a great quality this is not
653:55 - something people do often but they
653:56 - should because this indicates that you
653:58 - are doing what is called test driven
654:00 - development which means you are thinking
654:01 - about all the ways in which your code
654:04 - code might be used and accounting for
654:07 - those before writing the code so kind of
654:10 - working backwards and it's a very useful
654:11 - way to avoid errors so now the first one
654:14 - could be a generic
654:17 - array
654:18 - where the
654:21 - sub array
654:22 - is in the center somewhere in the center
654:24 - right so which is what we have already
654:26 - seen here
654:27 - now
654:28 - the sub eric would be in the center or
654:29 - the sub array
654:31 - would be
654:33 - at the start
654:36 - or the sub array
654:40 - could be at the
654:42 - end
654:44 - or it's possible that the sub array
654:48 - there is no such sub array so there's no
654:50 - sub array which adds up to 10.
654:59 - you may also have the situation where
655:02 - you have a few zeros so you have
655:07 - a few
655:09 - zeros in the list that's one option
655:11 - here's one thing that can happen this
655:14 - could be that
655:16 - there are multiple sub arrays with the
655:18 - same sum
655:24 - now this is where you might want to just
655:26 - clarify with the interviewer hey what
655:27 - happens if we get two sub arrays which
655:30 - add up to the same
655:31 - number the target
655:33 - and the interviewer might say find the
655:35 - shortest one or find the first one or
655:37 - find any one but it's always good to
655:39 - clarify that
655:41 - one option could be that
655:45 - or you could also ask them what is what
655:47 - happens if there is no sub array that
655:48 - adds up to 10 and then they may tell you
655:50 - you can return none none or you can
655:52 - return -1 or whatever it is
655:54 - or assume that there is always a
655:56 - sub-array so that will help you write
655:57 - your code
655:58 - and then you can obviously you may have
656:00 - to work with the empty array you may
656:02 - also have to work with the sub-array is
656:04 - a single element
656:12 - and whenever we say arrayed we also mean
656:14 - list in python they're
656:16 - practically speaking the same thing for
656:18 - our purposes
656:22 - okay we've listed quite a few test cases
656:24 - and
656:26 - in that process we've come across a few
656:28 - more questions which we've clarified so
656:30 - now we're ready to start solving the
656:31 - problem
656:32 - now at this point what you may want to
656:35 - do
656:36 - is maybe just ask for a couple of
656:39 - minutes and keep a pen and paper close
656:41 - to you i'm going to use this tool
656:45 - instead
656:47 - so i'm going to use this tool instead so
656:49 - keep a pen and paper close to you so
656:51 - that you can work on this problem
656:53 - now let's come up with the simplest
656:55 - possible solution right so we have about
656:57 - two three minutes to come up with the
656:59 - solution
657:00 - and often the simplest solution is
657:03 - pretty obvious so in this case one
657:05 - simple solution could be if i could
657:07 - simply try every sub array
657:10 - then
657:11 - i will find at least one if
657:13 - that adds up to 10 if there is one so
657:16 - all i need to do now each subarray is
657:17 - defined by a start index that is where
657:20 - the first element of the array is and
657:22 - then and n index the end index is just
657:25 - next the next index the first index
657:27 - which is not in the array right so
657:29 - that's how we define the sub array
657:30 - remember so all we need to do is try all
657:32 - such values so all such values i i comma
657:35 - j where i goes from 0 to n minus 1 and
657:38 - where j goes from
657:40 - remember you could start out with the
657:42 - empty sub array so which means j also
657:44 - has the value i
657:45 - so here we are saying
657:47 - i and j both have the value 2 so l1 of 2
657:50 - to 2 becomes the empty array so j grows
657:52 - from i
657:53 - to
657:56 - all the way beyond the last element
657:58 - which means if the last elements index
658:00 - is n minus 1 so j can go
658:02 - all the way up to n all right so i goes
658:04 - from 0 to n minus 1 and j goes from i to
658:08 - n and each time we start at an i and we
658:11 - check e j so we check j equals 0 and j
658:14 - equals 1 equals 2 j equals 3 4 5 and so
658:17 - on then we move i again and then we
658:20 - start over again and then we say we
658:22 - start with j equal to 0 j equal to 1 j
658:24 - equal to 2 3 4
658:26 - okay and and we keep doing this to we
658:28 - find an array and we have exhaust this
658:30 - way we'll test all the sub-arrays so the
658:32 - problem is solved
658:34 - so that's the brute force solution and
658:36 - what you should do first of all is
658:37 - explain that brute force solution it may
658:39 - seem that this is an obvious solution
658:42 - what's the point of explaining it but to
658:44 - mention it because at this point the
658:46 - interviewer knows nothing about you so
658:47 - they don't know if you can even
658:50 - come up with a solution to the problem
658:52 - right they're trying to assess can you
658:54 - think about problems and they're trying
658:55 - to assess can you write code now
658:59 - if you don't tell them the brute force
659:00 - solution then they don't even know if
659:02 - you figured out the brute force solution
659:03 - so do tell them the brute force solution
659:06 - and generally you do not have to
659:08 - code it you can do the analysis in your
659:11 - memory
659:12 - in your mind and
659:15 - you can sort of write the code in your
659:16 - mind picture the code and based on that
659:18 - come up with the
659:19 - complexity analysis and directly say
659:21 - that the brute force algorithm will have
659:23 - such and such complexity
659:25 - okay now
659:27 - we will just write the code right now
659:29 - just to
659:30 - be very clear about it in case you have
659:32 - not you are not yet clear on how to
659:34 - write the code but in an interview this
659:36 - is the part which you can skip in the
659:38 - interest of time
659:39 - so f
659:44 - sub array
659:45 - i think it was called
659:47 - sub array sum
659:51 - sub array sum and let's call this server
659:52 - sm1 the first approach that we're taking
659:56 - here we have array1 and that's it we
659:59 - have array and then we have our target
660:01 - and we're saying remember that start i
660:04 - from
660:06 - i goes from
660:08 - 0 to n minus 1
660:11 - that was the first thing so for i in
660:13 - range
660:14 - 0 to
660:15 - n minus 1 and what's n well n is simply
660:19 - the length of the array length of the
660:21 - array
660:22 - then
660:24 - j goes from
660:28 - i to n
660:31 - oops so i made a small error here this
660:34 - should say 0 to n because even in a
660:36 - range the last value is not taken so j
660:39 - goes from 0 to i to n so for j in the
660:41 - range
660:42 - i 2 this should be n plus 1 then because
660:45 - we want j to go
660:47 - all the way up to n
660:51 - and now
660:52 - we simply check if
660:54 - the sum
660:55 - of array
660:57 - i to j and then we've seen this array i
660:59 - to j is going to give us all the indices
661:01 - starting at i but ending just before j
661:04 - so if the sum of array i to j
661:09 - equals target
661:12 - then we found the answer return i comma
661:14 - j
661:16 - that's it so
661:17 - check if
661:19 - sub array sum
661:21 - equals target
661:25 - and if not let's just return none none
661:27 - maybe this is what we agreed but let's
661:29 - return none
661:30 - and
661:32 - that's it so that's your
661:35 - that's your code
661:37 - it's about one two three four five lines
661:39 - of code maybe six
661:42 - but that's a brute force solution
661:45 - if it's really short it doesn't hurt to
661:47 - write it because it then it's going to
661:48 - sit there and at least as a reference
661:50 - you have it but
661:52 - it's something you can discuss with the
661:54 - interviewer should i i mean
661:56 - if you if you are clear about the brute
661:57 - force solution and you can tell its
661:58 - complexity then you don't have to write
662:02 - one other tip is whenever you're coding
662:05 - it's always helpful to simply add a
662:08 - small comment above
662:11 - so that even if the interviewer is not
662:12 - able to follow your code
662:15 - they can just follow your comments and
662:17 - they can tell if your general strategy
662:19 - is correct right once again reading code
662:21 - is hard and especially when
662:24 - you
662:25 - are not familiar with the coding best
662:28 - practices in the industry the code that
662:30 - you write is
662:31 - sometimes difficult to read so while you
662:33 - learn how to write good code in the
662:35 - meantime it always helps to just mention
662:37 - comments makes it makes their job easier
662:39 - makes them easier it makes it easier for
662:40 - them to evaluate you otherwise you may
662:42 - spend five to ten minutes talking about
662:45 - something in your code which either they
662:47 - misunderstood or you made a typo etc
662:50 - okay
662:52 - so we have here the sub array sum one
662:54 - we've implemented the brute force
662:56 - solution
662:57 - maybe let's also check out some
663:00 - cases in
663:02 - and see if this root 4 solution works
663:04 - correctly
663:05 - so in an interview if you have the
663:08 - ability to run the code you can just run
663:10 - a few
663:11 - samples so let's say i simply take array
663:13 - 0
663:14 - and target 0
663:17 - and you get the value 2 6
663:19 - and remember output
663:21 - 0 also has the value 2 6.
663:24 - so
663:25 - great it seems like our
663:29 - our technique work
663:31 - let's test a few more cases just to be
663:33 - sure sub-array at the end subway at the
663:35 - start let's see if we can fix that so
663:38 - here is array 0.
663:41 - now if i take this remember 4 to 1 3
663:44 - oops i think i didn't complete it let me
663:46 - also put in 11 comma 5 here
663:50 - yeah so remember 4 to 1 3 is the
663:52 - solution now if we simply take 4 to 1 3
663:55 - 11 5
663:56 - and call sub array sum
664:03 - and put in
664:05 - this number here and put in once again
664:08 - the target zero was 10
664:10 - oh this should be subway some one okay
664:12 - yeah so now you can see four two one
664:14 - three is zero one two three which is the
664:16 - range zero to four so it seems to have
664:18 - worked correctly let's do the same thing
664:20 - now list this time let's
664:22 - put this at the end so one seven
664:25 - four two one three eleven five
664:28 - this works fine two two six
664:31 - let's try another one let's try maybe
664:34 - 17 and that probably cannot be found oh
664:37 - it can
664:38 - one two
664:39 - let's see one zero one two three four
664:42 - five probably the sum of all of these
664:44 - four let's do six plus four ten
664:49 - okay
664:50 - now maybe there's a problem here because
664:51 - it seems like 17 is not the right sum so
664:55 - you have 1 plus 7 8
664:58 - and 8 plus 4 12
665:00 - 12 plus two fourteen
665:03 - fourteen plus four eighteen
665:05 - okay so this seems like a mistake then
665:10 - and we can even check this out
665:18 - so we have l1
665:20 - that's that
665:22 - let's call that l2
665:24 - and 2 oh it says one to six i think i
665:27 - misread it so we are ignoring the 0th
665:30 - element so this does add up to 17 okay
665:32 - so 17 does show up
665:34 - let's try 18 which takes up the entire
665:37 - array works fine
665:39 - let's try maybe 4 which should just take
665:41 - the single number so that works fine too
665:45 - let's try 19 that should be none none
665:48 - okay
665:49 - we've tested this extensively and
665:51 - overall our solution seems correct this
665:53 - is the process whenever you write any
665:55 - code you should also test it out and it
665:57 - also gives
665:59 - more confidence to the interviewer
666:01 - but if you do not have the option to
666:04 - test it out if you do if you are not
666:06 - able to run the code right now
666:08 - then simply walk them through an example
666:10 - yourself like look at this example and
666:12 - then walk them through the exam
666:14 - okay so now we have the brute force
666:16 - solution the next step is to analyze the
666:18 - brute force solution now let's analyze
666:20 - it so you have here one for loop
666:23 - and we know that counting for loops
666:24 - helps us count the number of operations
666:26 - then we have another for loop so one for
666:28 - loop can go from zero to n so this may
666:30 - run n times then we have another for
666:32 - loop which goes from i to n plus one
666:34 - let's approximate here and say that it
666:36 - can
666:38 - run at most n minus 1 times or n times
666:41 - so
666:42 - n
666:43 - and inside each of these up at most n
666:45 - and then inside the second for loop you
666:47 - have the sum so this is very important
666:49 - now always carefully observe the
666:51 - operation inside your for loop so you
666:53 - have a sum which can be on an array of i
666:56 - to j now remember i can be 0 and j can
666:58 - have the value n that means in the the
667:01 - largest area that you can work with will
667:03 - have approximately the size
667:06 - n as well right so you have
667:09 - n and inside each of those you do n
667:11 - other loops and inside each loop you do
667:13 - work
667:14 - you do n additions right up at most n
667:17 - addition so that roughly gives you that
667:19 - this is going to be n times n times n so
667:22 - this is going to be an order n cube
667:24 - solution
667:25 - so
667:26 - if you are able to arrive at the order n
667:29 - cube solution
667:31 - at the order n cube complexity without
667:34 - implementing the solution great you have
667:37 - learned it but if you're not able to
667:39 - arrive
667:40 - um at the order n cube solu at the order
667:42 - and cube complexity for the brute force
667:44 - solution
667:46 - then you probably need a little more
667:47 - practice because this should become
667:49 - second nature to you just looking at a
667:51 - problem identifying the simplest
667:53 - solution and then finding the complexity
667:55 - of the simplest solution
667:58 - all right so now we have implemented it
668:00 - tested it and we've identified the
668:02 - complexity remember the next step
668:05 - find the inefficiency and
668:08 - overcome that inefficiency by applying
668:10 - the right technique
668:12 - so
668:13 - let's find the inefficiency then
668:18 - here we have
668:21 - let's say we are at this position so
668:23 - let's say you are looking at
668:27 - seven four two let's say
668:30 - i has the value
668:32 - 1 so
668:33 - you start out with i equal to 1 and j
668:35 - equal to 1 in the inner loop then what
668:37 - we do is we increment j by 1 and then we
668:40 - calculate the sum and this sum is 7.
668:43 - then what we do is we increment j by one
668:45 - more and we calculate this loop and this
668:48 - sum and this sum is seven plus four
668:49 - eleven
668:50 - then we increment this window once again
668:52 - and then we
668:53 - calculate this sum and that is seven
668:55 - plus four plus two so seven plus four
668:57 - eleven plus two
669:01 - 13 and then we move this and then we
669:03 - check it again so we are doing this over
669:05 - and over and over many many times right
669:07 - each time we are doing 7 plus 4 plus 2
669:09 - plus 1 and 7 plus 4 4 plus 2 plus 1 plus
669:12 - 3 that seems like a lot of additional
669:14 - work maybe we can just avoid that what
669:16 - we can do is we can when we start out
669:18 - with a j we can keep a running sum and
669:20 - each time simply before incrementing j
669:23 - add this
669:25 - upcoming element which is the jth
669:27 - element into that running sum right and
669:30 - that way we don't have to do that entire
669:32 - sum inside each of the inner loops
669:35 - so that's one optimization and this is
669:37 - how you should explain it that's one
669:38 - optimization that i have come up with
669:40 - the second optimization that we can come
669:42 - up with is that the moment the sum the
669:44 - running sum that we're calculating the
669:46 - moment the sum becomes greater than the
669:48 - target value
669:50 - we can skip all of these right so we
669:52 - know that 7 plus 4 is greater than 10
669:56 - and we know that the array only contains
669:58 - non negative number so what that means
670:01 - is 7 plus 4 plus any of these numbers is
670:03 - always going to be greater than 10 right
670:05 - you can obviously you can see this the
670:07 - number is not going to decrease if we
670:09 - keep adding positive numbers
670:12 - and so as soon as the running sum
670:15 - crosses
670:16 - this value we can break out of the inner
670:18 - loop we do not need to continue and look
670:20 - for higher values of g
670:23 - two optimizations
670:26 - helps to just write them down
670:29 - maintain a running sum
670:31 - so that you don't forget it and
670:33 - find it and second optimization is
670:37 - when some
670:39 - exceeds target
670:42 - break inner loop
670:49 - okay
670:50 - so
670:51 - now we have applied an optimization
670:54 - simply by just looking at the data in a
670:55 - lot of cases it's very straightforward
670:57 - you don't even have to apply any special
670:59 - technique
671:00 - and in this case we found these couple
671:02 - of optimizations so let's apply them
671:04 - so what we'll do is we'll define
671:07 - def subarray
671:10 - sum2
671:14 - and here once again we have the array
671:16 - and we have target
671:19 - and this time we get the length of the
671:20 - array
671:23 - now once again i goes from the same
671:25 - value so i goes from
671:28 - 0 to n minus 1.
671:31 - nothing changes
671:32 - here so for i
671:36 - in range
671:38 - 0 to n minus 1.
671:40 - now here is where we want to start a
671:42 - running sum so s equals 0 this is our
671:44 - running sum
671:47 - then for
671:48 - j
671:50 - in range
671:51 - remember we start out with i
671:53 - and we'll go all the way oh this i
671:56 - keep making these mistakes all the time
671:58 - and by the way these are called off by
672:00 - one errors here what we did was i wanted
672:03 - to go to at the address n minus 1 but
672:06 - because ranges
672:08 - do not include the final value i put in
672:10 - what i put in n minus 1 was wrong i
672:12 - should be putting in n and i make these
672:14 - mistakes all the time even after many
672:15 - years of coding so always watch out for
672:17 - off by one errors
672:19 - anyway so j can j can take the range of
672:22 - zero of i to
672:24 - n so here we should put in n plus one
672:28 - and now
672:29 - first we want to check
672:31 - if the running sum
672:34 - is equal to
672:35 - the target right so so assume that we've
672:37 - been calculating the running sum step by
672:39 - step
672:40 - and we'll write and and at this current
672:42 - point the sum has become equal to target
672:44 - now if the sum has become equal to
672:46 - target then we simply return i comma j
672:49 - because
672:50 - this sum
672:51 - includes the sum from
672:53 - index i all the way up to just before j
672:56 - so initially the j also has the value i
672:59 - so the sum is 0 which makes sense
673:05 - but if that is not the case
673:07 - we check if it is greater than the
673:08 - target
673:09 - so is it possible that our sum has
673:11 - already exceeded the target in that case
673:13 - we don't need to continue this inner
673:15 - loop we can break out of this inner loop
673:17 - and the way to do that is by simply
673:18 - typing break
673:21 - and then
673:24 - if neither of these held true if neither
673:26 - of these was true so which is that the
673:28 - sum was not equal to the target it was
673:30 - not greater that means it is still less
673:32 - than the target
673:34 - so that means we need to then add
673:37 - array of j
673:38 - into the sum so we can say sum plus
673:41 - equal to
673:42 - oops sum plus equals area of j which is
673:44 - the same as sum equal to sum plus array
673:46 - of j
673:48 - in any case array of sum plus equal to
673:50 - array of j
673:52 - so we have added the jth element now
673:54 - remember
673:56 - if this is the pointer j we added the
673:59 - jth element and then we we will set j to
674:01 - j plus one that will happen
674:03 - automatically when we come into the next
674:05 - iteration
674:06 - and the next iteration will once again
674:07 - check if the sum is equal to the target
674:09 - if it is equal we return i comma j
674:11 - otherwise we check if it is greater than
674:13 - the target if it is so we break if it is
674:15 - still less we increment we
674:18 - move j once again so we add one and then
674:20 - we move j once again and then we check
674:22 - again right so that's our running sum
674:26 - looks good now once again
674:29 - if we were if it was found it would have
674:30 - been returned somewhere here
674:33 - since it seems like it was probably not
674:35 - found so
674:37 - if we come to the very end so here we
674:40 - return none none okay
674:42 - and once again let's test it out so
674:44 - let's try subway sum two
674:46 - it gives you two six subway sum two of
674:49 - none
674:50 - okay seems like there is an issue here
674:54 - yes
674:55 - so this is why you need test cases so it
674:57 - seems
674:58 - that
675:00 - array j took up an invalid value
675:08 - so why is that well that was because j
675:10 - can go to the point of n so the maximum
675:13 - value j can take is n
675:14 - so which means that you have already
675:16 - arrived at
675:18 - this position
675:20 - so now you can no longer increase the
675:22 - sum further right so if you've arrived
675:24 - at this position but you've still not
675:25 - reached the total of 10 then that means
675:27 - you may need to increase it further but
675:29 - you can't increase further so there's no
675:31 - number here to add so what we should do
675:32 - is we should here add a check if j less
675:35 - than n
675:37 - since j can go all the way up to n
675:42 - and that's it so we had a small bug and
675:45 - we fixed it
675:48 - now again this is something that you
675:50 - should work out for yourself on pen and
675:52 - paper so even while doing the
675:54 - optimization you can ask for a couple of
675:56 - minutes
675:57 - play around with it on pen and paper
675:59 - write a few examples
676:02 - relax you can even take up to four five
676:03 - minutes and if you
676:06 - if you're not getting any ideas you can
676:07 - simply talk to the interviewer you can
676:09 - speak out loud explain your thought
676:11 - process and in a lot of cases they will
676:13 - give you a hint because they want to see
676:15 - you succeeding
676:18 - okay
676:20 - so now this is the second implementation
676:23 - let's see okay this time it worked
676:26 - none none four two one three let's put
676:28 - in 10 here this should give you the
676:30 - value two comma six
676:32 - let's put in
676:34 - this so that's zero comma three
676:37 - let's test this out two so that's zero
676:39 - comma four
676:43 - yeah 0 comma 4. so it seems like it's
676:45 - working just fine
676:51 - yeah so seems like this is working
676:53 - pretty well so now we have the second
676:56 - optimized solution so let's look at the
676:58 - optimized solution and analyze it
677:01 - so we have one loop and then we have a
677:03 - second loop these two are the same but
677:05 - inside the second loop we are simply
677:07 - doing a constant operation we are just
677:09 - doing some comparisons and one addition
677:11 - not up to n additions so the complexity
677:14 - goes from
677:15 - order of n cube to order of n square by
677:18 - maintaining a running sum
677:20 - great
677:21 - now
677:24 - this at this point when you've described
677:26 - the solution to the interviewer and
677:27 - maybe also coded it
677:29 - you might ask them is this good enough
677:31 - and
677:32 - they can see that you've ex you've
677:34 - thought about it you've found the
677:36 - solution and you have tested it and it
677:38 - tests well and at this point they may
677:40 - just say i'm happy with the solution
677:42 - this is good enough or they may say can
677:44 - you do better now when they say can you
677:46 - do better most of the time it suggests
677:48 - that there is a better solution
677:50 - so let's see let's think about it a
677:52 - little more and let's see if there is a
677:54 - better solution
677:55 - now you can to can you do better
677:58 - we apply the exact same technique we
678:00 - have analyzed the complexity and now we
678:02 - need to look for inefficiency okay now
678:04 - we have removed the inefficiency on this
678:07 - side which is as we move j
678:10 - that is when
678:12 - we reuse the previous sum to compute the
678:14 - next sum so we've removed the
678:15 - inefficiency on this side
678:17 - and we've also added
678:18 - this also added this condition so that j
678:22 - only goes up to a certain point now of
678:24 - course in the worst case j may always go
678:26 - up all the way to the end but at least
678:27 - in a lot of cases j will not j will not
678:30 - not go beyond a point where the sum
678:32 - becomes larger than the target
678:34 - so these are good optimizations but what
678:36 - about i what about the left
678:40 - window now look at this here when you
678:42 - have seven
678:44 - four or let's start out all the way at
678:46 - one
678:47 - so we have one
678:48 - that's so first we started with the
678:50 - empty
678:52 - empty sub array that has the sum zero
678:54 - then we increment j so now the sum
678:55 - becomes one then we increment j now the
678:58 - sum becomes
678:59 - eight then we increment j once again and
679:02 - now the sum becomes 12.
679:04 - okay the sum has become 12 now that's a
679:06 - problem so what do we do what we are
679:09 - saying is we will take i and set it to
679:12 - the next value and then we will bring j
679:14 - back to zero or back to the value i so
679:16 - that we start with the empty sub array
679:18 - once again so now when we do seven and
679:21 - when we so that's that just has a value
679:23 - seven and when we do this we have to add
679:25 - up seven plus four
679:27 - now here's something that we could have
679:29 - done instead
679:31 - now as soon as the value became larger
679:33 - than the target value we could have
679:35 - simply moved
679:37 - this here
679:40 - does that make sense
679:42 - let's think about it so
679:46 - till this point
679:47 - this total was less than 10.
679:50 - as soon as we added this number on the
679:52 - right this total became more than 10.
679:55 - now we know that this product became
679:56 - more than 10 that means that
680:00 - if we slide this
680:02 - window if we slide the left window
680:04 - forward one step then the total may
680:06 - become less than 10 right it may still
680:08 - become stay larger in this case it stays
680:10 - larger or it may become less than 10.
680:14 - so if the total now becomes less than 10
680:16 - then we can once again move this
680:19 - but the total has not become less than
680:21 - 10 so we will move this instead
680:24 - so now the total again is less than 10
680:26 - so we can once again move this
680:29 - and now the total is still less than 10
680:31 - so we move this now the total is still
680:32 - less than 10 we move this and we
680:34 - encounter 10 here but suppose we had not
680:36 - encountered 10 suppose this number was 4
680:38 - instead then what we would have to do is
680:41 - move this right
680:43 - and now now the number becomes less than
680:45 - 10
680:46 - so we always go
680:48 - we always try to maintain a window of
680:50 - size less than 10. the moment the window
680:53 - becomes greater than 10
680:55 - we keep trying to reduce its size
680:57 - further
680:58 - to less than 10 right or exactly 10 as
681:01 - well it's possible that the size may
681:02 - become exactly 10 and then the problem
681:04 - is solved but we keep trying to reduce
681:06 - its size to a value till it becomes less
681:08 - than 10.
681:09 - so
681:10 - to revise the algorithm we start out
681:12 - with both i and j at zero
681:16 - then we increment j while the running
681:19 - now we have a single running loop and a
681:20 - single loop essentially
681:22 - so we increment j while
681:25 - the
681:25 - sum is less than 10.
681:28 - the moment it becomes greater than 10 we
681:30 - start incrementing i
681:32 - the moment the sum becomes less than 10
681:34 - or less than target we start
681:36 - incrementing j
681:38 - and if we encounter the point where the
681:39 - sum equals 10 we have found the answer
681:42 - so that's the algorithm so let's write
681:44 - it
681:46 - sub array sum three
681:49 - now this is the array target
681:53 - now we have
681:55 - we have i we have j and we have sum all
681:57 - of them let's call it s because sum is a
681:59 - reserved word in python
682:01 - an existing function so all of these
682:03 - have the value 0
682:05 - then we say while i is less than
682:10 - len array
682:13 - let's call that n so let's create n
682:16 - equal to len a r r
682:21 - i is less than n
682:22 - and j is
682:24 - less than n plus 1 remember because j
682:28 - can take the value n as well it is the
682:30 - exclusive end index
682:33 - now at this point you want to
682:36 - check first so if the sum s the current
682:39 - sum running sum
682:40 - is equal to the target
682:43 - then we simply return i comma j
682:46 - l if
682:48 - some is le less than the target
682:51 - then we
682:53 - simply increment j
682:56 - okay so now we can move the window
682:58 - forward so we we are incrementing j if
683:00 - the sum is less than the target
683:03 - so we increment j but before we
683:05 - increment j we should add the jth
683:06 - element to maintain the running sum
683:09 - so here we say s plus equals
683:16 - j
683:18 - or array of j
683:20 - and remember j can take the value n as
683:22 - well
683:23 - so that's where we do this
683:26 - only if
683:27 - j is less than n
683:29 - if there is indeed an element for us to
683:31 - add
683:32 - this is an error we faced last time and
683:34 - you will discover this when you write
683:35 - the test anyway
683:37 - and then we say l if s is greater than
683:39 - target and we can also just say else
683:41 - here but just for clarity let's say alif
683:43 - in this case
683:45 - what we want to do is we want to move i
683:47 - forward so suppose we end up in a
683:49 - situation like this and we want to move
683:51 - this forward for that we need to
683:53 - subtract s array of i first so we s we
683:56 - say s minus equals which is equal to s
683:59 - minus
684:00 - which is the same as s equals s minus
684:04 - array of i
684:06 - and then we increment i
684:09 - so we move the left window forward as
684:10 - well
684:13 - so we then repeat this so we first move
684:15 - j to a point then we
684:17 - as soon as we cross the target we start
684:18 - increasing i and then we keep doing that
684:20 - till we match the target
684:22 - and then finally we return none comma
684:24 - none if we have not found it
684:27 - so that's r sub array sum three
684:30 - this is seems like the most optimized
684:32 - solution and let's test it out
684:35 - so here we have sub array sum three
684:42 - and let's test sub-array sum three here
684:44 - as well
684:45 - seems like it worked let's see
684:48 - so if you put in ten here you get two
684:50 - comma six
684:52 - let's say this is four two one three
684:55 - zero comma four
685:01 - let's put in 12 here that doesn't show
685:03 - up
685:05 - let's put in 17 here zero comma five
685:09 - thirteen one comma five
685:15 - let's try 19 that's three comma six
685:17 - let's see one plus three
685:19 - plus 7 plus 9 yeah that has the value
685:21 - 19. let's throw in a zero there and see
685:24 - if it works with zeros
685:26 - that's three comma seven works fine
685:29 - and let's see if it doesn't work out
685:31 - yeah
685:32 - okay
685:33 - great so this solution is correct too
685:36 - again if you don't have
685:38 - the option to run the code you can
685:39 - simply pick one example and walk through
685:42 - the working of the example
685:45 - now we have sub array sum
685:47 - three
685:48 - and once again we are ready to analyze
685:50 - the complexity and in this case the
685:51 - complexity would be this somewhat tricky
685:54 - is a little bit unusual because there is
685:56 - a while loop with two variables
685:58 - but remember that in each while loop
686:00 - either we exit which is the best case so
686:02 - we can ignore that or we either
686:05 - increment j
686:07 - or we increment i right so we increment
686:10 - j or we increment i
686:14 - and
686:17 - if we increment
686:19 - uh so
686:20 - j can go from the value 0 to n and i can
686:23 - go from the values 0 to n minus 1. so
686:25 - the total number of increments can we
686:27 - and we can do is the
686:29 - sum of the number of possible values of
686:30 - i and the number of possible values of j
686:32 - right remember this is not a product
686:34 - this time because this you do not have a
686:36 - nested loop so for each value of i
686:38 - you're not doing this rather
686:40 - you are incrementing each one
686:42 - and i only one of them each time
686:45 - so the sum of total number of values i
686:47 - can take is n the total number of values
686:49 - j can take is n plus one so the total
686:52 - becomes
686:54 - this number of iterations becomes two n
686:56 - plus one
686:57 - now of course
686:58 - there's the you can verify that a
687:00 - constant amount of work is being done
687:01 - here
687:03 - so
687:04 - we finally end up with the conclusion
687:06 - that this is an order n algorithm
687:09 - so this is finally an order n algorithm
687:12 - this is a good example of a problem
687:14 - where the step-by-step
687:16 - solution coming up with a simple
687:18 - solution and then thinking about the
687:22 - inefficiency in the problem and then
687:24 - applying
687:25 - in this case just common sense to solve
687:28 - the inefficiency step by step
687:31 - leads to the perfect solution and a very
687:34 - good solution in fact so you start out
687:36 - with the order n cube solution the order
687:38 - n cube is going to be pretty slow when
687:40 - you start hitting let's say even a
687:42 - thousand
687:44 - even a thousand elements if you have ten
687:46 - thousand elements it will take forever
687:47 - it will take maybe an hour or so if you
687:49 - have
687:50 - a million elements it will take
687:53 - hundreds of years on the other hand
687:56 - order n can work fine all the way up to
687:59 - a billion elements right so there's a
688:01 - huge difference between
688:02 - the
688:03 - sub array sum one two and three
688:06 - so where some three can work instantly
688:08 - for a billion elements so where is some
688:10 - one will take
688:12 - forever even for
688:14 - a hundred thousand elements
688:17 - and sub-array two is in between and you
688:19 - can do the math
688:24 - and this technique where
688:26 - you can almost certainly tell
688:28 - what the next strat what the next step
688:30 - is so this was not
688:32 - really
688:33 - related to any of the algorithms or data
688:36 - structures that we have talked about
688:37 - this is what is called a greedy approach
688:39 - where you know some optimal strategy
688:41 - about the problem in this case you know
688:43 - that we can calculate the sums by
688:45 - maintaining a running sum so we just do
688:47 - that and then you also know that as soon
688:49 - as it becomes greater than a target we
688:51 - need to break out and then you know the
688:53 - next thing that when it becomes greater
688:54 - than target rather you can simply up
688:56 - update i
688:57 - so this is what what is called a greedy
688:59 - approach where you
689:01 - somehow know that just doing this will
689:03 - fix it right there's no real technique
689:05 - to be applied and
689:07 - these problems are somewhat tricky but
689:09 - you get the hang of these problems as
689:10 - well if you search for greedy problems
689:12 - online you get the hang of these by
689:14 - solving a few practice exercises
689:18 - so that's our first
689:20 - interview problem
689:24 - and we've solved it in about 45 minutes
689:26 - and this is approximately how long you
689:28 - will have for an interview a typical 45
689:31 - minute to one hour interview we'll have
689:32 - about
689:33 - a couple of minutes of introduction
689:35 - maybe a few minutes just you talking
689:37 - about a project and the interviewer
689:39 - asking you questions but then the next
689:41 - 30 to 40 minutes will be dedicated
689:44 - towards solving a problem
689:49 - and this is what roughly the process
689:50 - will look like
689:53 - let's do one more example let's pick
689:55 - another interview question
689:57 - and let's see if we can solve this one
689:59 - so this is slightly different
690:01 - so this gives us one more variation to
690:04 - study
690:16 - by the way to run these you simply click
690:18 - the run button and select run on binder
690:27 - okay so this is an interview question
690:29 - that was asked during a coding interview
690:31 - at google
690:33 - and the question is given two strings a
690:35 - and b
690:36 - find the minimum number of steps
690:38 - required to convert a
690:40 - into b so what you can do is you can
690:43 - perform operations and each operation is
690:45 - counted as one step
690:47 - and the operations you can perform on a
690:49 - word are these you can either insert a
690:52 - character into the word
690:54 - or you can delete a character from the
690:56 - word so
690:57 - for instance here
690:59 - you can see that
691:00 - we are trying to convert intention into
691:02 - execution so either you can insert a
691:04 - character for example you could insert c
691:06 - here or you can delete a character for
691:08 - example you can delete i here or you can
691:11 - replace a character
691:13 - that is you can take n and replace it
691:15 - with e you can take t and replace it
691:17 - with x and e does not need to be
691:19 - replaced
691:20 - and here we've inserted c and then here
691:22 - we substituted n for u right so we have
691:24 - taken the word intention and by
691:26 - performing a few changes character by
691:28 - character by either inserting deleting
691:30 - or replacing a character we have
691:32 - converted it into the
691:34 - string execution
691:38 - so the number of steps required here is
691:41 - one two three four five now here's a
691:44 - challenge for you try and work this out
691:46 - on paper and prove that this is the best
691:48 - solution so because we need to find the
691:50 - minimum number of steps required to
691:52 - convert a to b
691:55 - okay
691:56 - so that's the problem
691:58 - and
691:58 - this is a moderately hard problem
692:02 - and variations of this show up as well
692:05 - so let's start applying the method now
692:08 - when you hear the problem
692:10 - a solution may not strike you up front
692:12 - that's perfectly all right don't panic
692:14 - sometimes when you're not able to
692:16 - immediately come up with a solution or
692:17 - identify how to solve this problem you
692:20 - enter a sort of panic and then you are
692:21 - unable to think don't do that remember
692:23 - have faith in the method and we will
692:26 - apply the method and come up with a
692:27 - solution step by step
692:31 - so the first thing
692:32 - is to state the problem in your own
692:34 - words
692:35 - so given two strings
692:38 - we need to perform operations a series
692:40 - of operations on the first string the
692:42 - operations could be deletion of a
692:44 - character
692:45 - substitution of a character with another
692:47 - character or insertion of a character
692:50 - and through these operations we need to
692:52 - convert it into a second string okay we
692:54 - have understood the problem if the
692:57 - interviewer had not given an example
692:58 - either you can state the example or you
693:00 - can just ask for an example
693:02 - whatever makes works for you
693:05 - so we've stated the problem now what are
693:07 - the inputs to the problem so the inputs
693:09 - are two strings so the inputs are
693:11 - strings like intention and execution so
693:14 - let's see
693:15 - maybe
693:16 - let's call them str1
693:18 - this is intention
693:22 - str2
693:24 - this is
693:25 - execution
693:26 - now one thing you have to be careful
693:28 - about here is you do not want to
693:30 - capitalize
693:31 - because sometimes what might happen is
693:33 - this i may match up with an i here in
693:36 - the in the proper solution but
693:38 - python obviously treats small and
693:40 - capital letters differently python
693:41 - doesn't know what's that the i which is
693:44 - lowercase and the i which is uppercase
693:46 - is the same so you will not be able to
693:48 - compare them so just to keep things
693:50 - simple either make everything uppercase
693:52 - or make everything lowercase
693:54 - but yeah this is what the input looks
693:56 - like
693:58 - and the output is going to be a single
694:00 - number
694:00 - so the output is simply going to be the
694:03 - edit distance so let's just call it
694:05 - output one and it is going to be the
694:07 - number five
694:10 - and here is something that you can
694:11 - verify so that's the input that's the
694:13 - output
694:14 - and function signature
694:17 - so
694:18 - of course this term edit distance is how
694:20 - this problem is described but
694:22 - here there is no
694:24 - edit there's no concept of edit distance
694:26 - that's mentioned so you can give a
694:27 - function name that makes sense
694:29 - for this problem
694:31 - so find the minimum number of steps
694:32 - required to convert a to b okay
694:35 - so
694:37 - let's just call it min steps
694:39 - for now
694:41 - so the function definition would be min
694:43 - steps and this would take an str1 and
694:45 - this would take an str2
694:48 - and it would return
694:50 - an output for now we'll just put in pass
694:52 - here
694:54 - all right so now we have already
694:57 - clarified the problem if you had any
694:59 - questions this is this would have been a
695:00 - good time to ask the interviewer and
695:02 - make sure that you have a clear
695:03 - understanding now you have stated the
695:04 - input output and function signature
695:09 - the problem has been communicated back
695:10 - and forth properly the first step is
695:13 - done
695:13 - the next step is to list out some test
695:15 - cases right once again a very good
695:17 - quality listing out some test cases so
695:19 - you can say that now i'm just going to
695:21 - list out a few cases that i want my
695:23 - function to cover
695:25 - so that
695:26 - they will help me it will help me while
695:28 - writing the code
695:29 - now one is
695:31 - the general case
695:33 - which is
695:35 - listed above
695:36 - so this would be
695:38 - intention execution and we can take a
695:39 - few more examples like this
695:41 - now one example could be where
695:45 - no change is required
695:47 - so you are given the same strings one
695:50 - case could be that
695:52 - all the
695:54 - characters
695:58 - need to be changed
696:01 - so these are the two extreme cases one
696:03 - is no change is required and second is
696:04 - all characters need to be changed maybe
696:06 - added remove deleted
696:08 - lots of such things then you can
696:11 - check
696:13 - both strings of equal length so in this
696:15 - case they are in fact of equal length
696:17 - unequal length you can check both
696:18 - strings of unequal length
696:20 - one of the strings
696:24 - is empty
696:26 - your function should be able to handle
696:28 - that too
696:30 - then you may check things like it will
696:33 - if something only requires deletion
696:35 - if something only requires
696:37 - addition or if something only requires
696:41 - swapping
696:42 - right such things
696:47 - i guess this is pretty good at this
696:48 - point so now we can probably move
696:50 - forward so we have stated some test
696:51 - cases now you don't need to create all
696:53 - the test cases right now in an interview
696:55 - it can
696:56 - take a little take a bit of time so
696:58 - let's just move ahead and the next step
697:00 - is to come up with the simplest solution
697:02 - to the problem
697:04 - which is also called the brute force
697:05 - solution so now we have a lot more
697:07 - information about the problem in this
697:08 - mean time probably it has sunk into you
697:10 - and you may have been able to think of a
697:12 - brute force solution but if not don't
697:14 - worry there is a simple trick i'll tell
697:16 - you which you can apply whenever you are
697:18 - stuck and you can't think of a brute
697:20 - force solution so we're looking at
697:21 - you're looking at it in tension
697:23 - execution what am i going to do am i
697:24 - going to start from the left and right
697:26 - how do i check which one is
697:29 - how do i know if this is going supposed
697:31 - to be inserted or executed or
697:34 - replaced or substituted
697:36 - or deleted
697:38 - so the simple trick is whenever you're
697:41 - in doubt
697:44 - think about recursion see if there is a
697:46 - way to solve this problem recursively
697:49 - and what do you mean by solving a
697:50 - problem recursively can you reduce the
697:53 - overall problem
697:55 - to
697:57 - a combination of one or more
698:00 - sub problems so if you take a portion of
698:02 - the input
698:04 - and can you solve the same problem on
698:06 - the portion of the input and then use
698:07 - that to solve the overall problem okay
698:09 - so let's see let's see if there is a
698:11 - recursive solution possible here
698:14 - so here i have the same thing
698:16 - intention and execution now with
698:18 - recursive solutions normally you either
698:20 - start by looking at the first character
698:22 - or the last character
698:24 - so let's look at the first character
698:26 - character of each string right so we
698:27 - given these two strings and we need to
698:29 - find
698:30 - the number of operations to change this
698:32 - string into this string let's look at
698:34 - the first character
698:39 - now suppose the first characters were in
698:41 - fact equal suppose this was not
698:43 - intention but it this was n tension and
698:46 - this was execution so now we compare the
698:49 - first characters and we know that the
698:50 - first characters are equal okay so
698:53 - if the first characters are equal then
698:55 - obviously neither of them needs to be
698:57 - deleted or
699:00 - removed or obviously this character does
699:02 - not need to be deleted or removed or
699:03 - switched it's already matching so what
699:06 - we can do is we can just ignore the
699:08 - first characters
699:10 - and we can simply look at the remaining
699:12 - string
699:14 - so intention and execution because the
699:16 - first characters are already equal let's
699:18 - write that down so that we don't forget
699:20 - it
699:22 - and this is the
699:24 - recursive solution
699:26 - now this is where you can take a moment
699:27 - to work this out on pen and paper and
699:29 - that's perfectly all right what helps us
699:31 - to just talk keep talking about what
699:33 - you're doing but for recursion now first
699:36 - thing we know is if the
699:38 - first character is equal
699:43 - then ignore from both
699:45 - so just ignore the character first
699:46 - character of both strings and simply
699:48 - recursively solve the problem for the
699:51 - sub list or the sub string without the
699:54 - first characters in each of the strings
699:56 - right so you exclude e and exclude e
699:58 - from this and solve the problem for
699:59 - these two
700:00 - perfect
700:01 - now suppose the first character isn't
700:03 - equal so that's another case now right
700:05 - so that is the case where you have
700:06 - intention and execution
700:10 - so if the sub if the first character is
700:11 - not equal then
700:13 - either the first character has to be
700:15 - deleted
700:16 - or the first character has to be swapped
700:18 - so you may you may have to swap i with e
700:21 - or the first character or maybe
700:23 - something needs to be added before the
700:24 - first character okay now let's see one
700:27 - by one
700:30 - so if
700:33 - the
700:34 - first character is not equal
700:38 - either it has to be deleted
700:44 - or swapped
700:47 - or a character inserted before it
700:53 - there are only three possibilities right
700:55 - of course it's possible that we may do
700:57 - some other things insert characters
700:59 - after after it and so on but
701:01 - at that position
701:03 - after applying an operation either the
701:05 - first character will get deleted
701:07 - or the first character will get swapped
701:09 - and will be changed to e or the first
701:11 - character will now change to something
701:13 - else and the first original first
701:14 - character will become the second
701:15 - character
701:18 - now let's look at each case the first
701:20 - cases it has if it is deleted now the
701:22 - power of the beauty of recursion is that
701:24 - we don't need to guess which solution it
701:26 - is we can try all three recursively and
701:28 - then simply pick the best one so suppose
701:31 - we choose to delete the first character
701:33 - so suppose we say that we are deleting
701:35 - the first character
701:37 - now what that means is we've performed
701:39 - one operation
701:40 - and we've deleted the first character so
701:42 - now what we are left with is this
701:46 - so now
701:47 - what we end up is
701:49 - the second the string has remained the
701:51 - same only the first string has changed
701:52 - where we have lost the first character
701:54 - now what we end up with is with a sub
701:56 - problem where we need to find the
701:57 - minimum number of steps to change n
701:59 - tension nte and tion into execution okay
702:04 - so in this case if it has to be deleted
702:06 - then
702:09 - recursively find
702:13 - then recursively solve
702:16 - after ignoring
702:17 - first character of str1 okay
702:22 - that's one possibility
702:27 - and the you get the recursive solution
702:29 - and you simply add one to it that tells
702:31 - you the solution if you
702:34 - delete the first character the next
702:35 - option is that we change the first
702:37 - character i to e
702:38 - now if we change the first character i
702:40 - to e
702:41 - so one operation has been performed and
702:43 - then now these two have become equal now
702:45 - that these two have become equal we can
702:48 - move this forward
702:49 - and we can move this forward
702:51 - so now we can simply recursively solve
702:53 - the problem for n tension and execution
702:55 - find the minimum edit distance between
702:57 - the two and simply add one to it to get
703:00 - the number of steps required to change
703:03 - intention to
703:05 - execution
703:07 - by
703:08 - swapping the first character right from
703:11 - i to e
703:12 - so in this case
703:14 - you recursively solve
703:17 - after ignoring
703:20 - the first
703:22 - character of each
703:23 - right so it is one plus
703:26 - in both cases it is one plus the
703:28 - recursive solution after ignoring the
703:30 - first character of each
703:33 - because the one operation is something
703:34 - that has been performed
703:35 - okay now the final case
703:39 - the final case is you have intention and
703:42 - execution now we decide that
703:45 - we are going to shift the string forward
703:47 - and we are going to include we are going
703:50 - to introduce an e here so we are going
703:51 - to introduce e
703:53 - here
703:55 - so now what happens is the e is matching
703:58 - the e
703:59 - now i has gone on to the first position
704:01 - i has gone on to the next position here
704:03 - so effectively what has happened is that
704:05 - we need to recursively solve the problem
704:07 - for the original string in tension
704:10 - and the second string with the first
704:12 - character removed because we have
704:14 - inserted something before the first
704:15 - character in the first string so that is
704:16 - going to match with the first character
704:18 - of the second string and hence we simply
704:20 - need to recursively solve the problem
704:22 - for these two
704:23 - in this case what we are doing is the
704:26 - solution is one plus
704:28 - recursively
704:31 - solve after
704:32 - ignoring the first character
704:36 - of
704:36 - str2
704:38 - okay sounds good looks like we've done
704:41 - that now what's the end solution going
704:44 - to look like the end case remember in
704:46 - recursion this is all well and good but
704:48 - at some point we are going to hit some
704:50 - kind of an end so let's see let's see if
704:52 - we can define such an end scenario so
704:54 - maybe let's say we have been performing
704:56 - recursion and then we ended up at a
704:58 - situation like this
705:00 - where
705:02 - there is nothing left in the second
705:04 - string but you still have some
705:05 - characters left in the first string
705:06 - right so you are at this position now
705:09 - and here this is gone there's nothing
705:11 - left
705:11 - in the second string
705:14 - so in this case
705:16 - to change recursive to change tion into
705:19 - the empty string all we need to do is
705:21 - delete all four
705:23 - so
705:24 - if you have a few character if you if
705:26 - the second string becomes empty then you
705:28 - simply find the number of remaining
705:30 - characters in the first string and
705:31 - delete them so that is the number of
705:32 - operations or
705:34 - the other possibility is that
705:37 - the second string
705:38 - still has some characters but you've run
705:40 - out of characters on the first string
705:42 - if you run out of characters on the
705:43 - first string but the second string still
705:45 - has some characters
705:47 - then in that case what you need to do
705:49 - obviously is you have the empty string
705:51 - and you need to
705:53 - take this
705:56 - convert this empty string into t i o n
705:58 - that is a recursive problem we are
705:59 - solving so you that you can do by adding
706:01 - t i o n
706:03 - great so you add t i o n and that is
706:06 - again going to be
706:08 - four steps which is the number of
706:09 - characters remaining in the second
706:11 - string okay so these are the two end
706:13 - cases now of course if both of them are
706:15 - empty then
706:17 - the answer is zero but if either of them
706:19 - is empty the answer is the number of
706:20 - remaining elements in the other one
706:23 - let's write the solution now we figured
706:26 - out the solution it took some time but
706:27 - again this is not a very straightforward
706:29 - problem so
706:30 - there are a few cases to figure out
706:33 - and while you are doing this while you
706:34 - are identifying each
706:36 - case
706:37 - either you can say it out loud to the
706:39 - instructor or you can write it as a
706:41 - comment
706:43 - whatever you feel more convenient with
706:44 - because
706:46 - the interviewer cannot see the work that
706:48 - you're doing on paper so it's very
706:50 - important for you to be able to convey
706:51 - it and that is why all this while in
706:53 - this course we have been saying that you
706:55 - need to express the solution in simple
706:57 - words because you need to tell the other
706:59 - person that you know the solution
707:03 - and they should be able to understand
707:04 - what you're saying without looking at
707:06 - your work without looking at the images
707:08 - that you've drawn
707:10 - and a great way to do it is either by
707:12 - writing or by speaking
707:16 - let's define it then def
707:18 - what's it called min steps
707:23 - and min steps is it takes str1 and str2
707:28 - great now
707:30 - we are doing recursion and in recursion
707:32 - what we're tracking is the
707:35 - which character we are currently at so
707:37 - we could be at
707:39 - the zeroth character or the first
707:40 - character or the second character in
707:42 - string one
707:43 - and we could be at the zeroth character
707:44 - second first character second character
707:46 - in string two right so
707:48 - the the starting point of this window
707:50 - determines the sub string that we are
707:53 - solving the problem for so ideally
707:55 - we when we want to solve this problem
707:57 - for
707:58 - these two sub strings
708:00 - we can simply pass those sub strings but
708:02 - creating sub sub list or sub strings as
708:05 - a cost because you have to copy those
708:08 - characters out and then allocate some
708:09 - memory and put them into a new place so
708:11 - an easier way is to simply keep a
708:13 - pointer so we will keep two pointers i1
708:15 - and i2
708:18 - and these will signify
708:20 - that we should be skipping while
708:23 - computing min steps we should be
708:24 - skipping the first i1 characters or we
708:27 - should be starting from the i want index
708:29 - and we should be starting from the i
708:30 - tooth index for str2 okay
708:33 - so
708:34 - in your window if the i1 index if the
708:37 - starting
708:38 - if the starting index
708:40 - is equal to the length of string one so
708:42 - this is the end case and remember the
708:44 - end case while coding is always written
708:47 - first so if this is equal to length of
708:48 - str1 then we have known we have seen
708:51 - here that
708:52 - we need to perform these many additions
708:56 - so we simply return in this case
708:58 - str
708:59 - len of str2
709:02 - minus
709:05 - i2 right and you can verify that this is
709:07 - the amount number of additions required
709:10 - alif on the other hand i2 is equal to
709:12 - len of str
709:14 - 2
709:15 - so which means that
709:17 - you have exhausted the second string but
709:19 - the first string still has some values
709:20 - left so in this case you need to remove
709:22 - the delete the return remaining values
709:24 - in the first string so you just type len
709:26 - of str1
709:28 - minus i1
709:30 - right so these we have now solved the
709:33 - trivial cases
709:34 - now let's see lf
709:37 - str1 of i1
709:40 - and str2 of i2 which means the first
709:44 - characters of each sub string that we
709:46 - are working with right remember we are
709:47 - just using arrays as a we're just using
709:49 - indices as a optimization what we really
709:52 - want to work with the substring so the
709:54 - first character of each substring str1
709:56 - of i1 and str2 of i2 is equal
709:59 - now the first character is equal e and i
710:01 - are equal then we simply ignore both and
710:03 - solve the problem for the remaining
710:05 - string so we simply say return
710:08 - main steps
710:10 - and
710:12 - we pass an str1 we pass in str2 and then
710:15 - we simply pass in i1 plus 1 here and we
710:18 - pass in i 2 plus 1 here so what this is
710:20 - saying is that now we want to
710:21 - recursively solve the problem
710:24 - or a substring starting at i plus i 1
710:27 - plus 1 so we have ignored the first
710:28 - string of the current substring and
710:30 - similarly we have ignored the first
710:32 - character of the current substring or of
710:34 - the second string okay so we ignore the
710:36 - first characters and that's it and there
710:38 - are no steps required here no operations
710:40 - required here right now because the
710:42 - first characters are equal
710:44 - now finally this is the final case else
710:47 - here
710:49 - we want to return one so we have to
710:51 - perform one operation either it is an
710:52 - insertion deletion or swap
710:56 - and
710:57 - what we can do is we can recursively
710:59 - check the
711:00 - cost or the number of minimum steps
711:02 - required for each case of insertion
711:04 - deletion and
711:06 - swapping
711:07 - and simply pick the minimum one and if
711:09 - to do it we add one then we get the
711:11 - total minimum number of steps we need to
711:13 - perform for the
711:14 - entire list right so
711:16 - again recursion is very useful because
711:18 - you can simply assume that you have the
711:19 - function which solves the problem
711:22 - and you simply need to take the result
711:23 - of the sub problem and combine them so
711:25 - we take the minimum off the first option
711:27 - is if the first
711:29 - character of str1 has to be deleted
711:33 - so which is let's say we choose to
711:35 - delete i if we choose to delete i then
711:38 - that means we have to solve the problem
711:39 - for these two
711:40 - so we say 1 plus recursively solve the
711:43 - problem after ignoring the first
711:44 - character of str1
711:47 - so we solve min steps
711:49 - for str1 str2 now since we have deleted
711:52 - the first character of str1 we can skip
711:55 - ahead into the next
711:57 - because we are solving the problem now
711:58 - for the from starting from the next
712:00 - index
712:01 - and i2 remains the same right so
712:03 - remember here we have not affected i2 so
712:04 - we need to solve this problem
712:06 - recursively
712:08 - so this was the case of deletion
712:15 - next we have the option where
712:18 - you have swapped the first character so
712:21 - we have taken e and we have converted
712:22 - the it in we have taken i converted it
712:24 - into an e if we did that so then we can
712:28 - say that okay now these two characters
712:30 - are matching so now we can simply
712:31 - recursively solve the problem
712:33 - or the next character onwards after
712:35 - ignoring the current character
712:37 - so this becomes str1 plus str2 plus i1
712:41 - plus
712:43 - plus 1 plus i2 plus 1
712:46 - great so this is
712:49 - swap or replace
712:53 - and you might notice that this is this
712:56 - turns out to be the same recursive call
712:58 - as this except that we will add one to
713:00 - it because we have done the swap
713:04 - and finally if you are adding so if
713:06 - you're ad inserting
713:08 - so finally if you're inserting here
713:10 - something so if you are inserting e here
713:12 - let's say
713:16 - so in this case
713:18 - what we'll do is now we'll recursively
713:20 - solve the problem for intention
713:25 - and
713:26 - execution without the e in front so we
713:28 - skip the first character of the second
713:30 - string
713:32 - so we have main steps str1
713:34 - str2
713:36 - i1
713:37 - and i2 plus 1.
713:39 - so this is rather nice and symmetric
713:45 - and that's it so this should be it let's
713:48 - run this
713:49 - okay there is a syntax error here that's
713:51 - perfectly fine
713:56 - there needs to be a comma here that's
713:59 - fine too
714:01 - i make a lot of syntax errors all the
714:03 - time and of course off by one errors i'm
714:05 - sure there are a few
714:07 - but yeah this is
714:09 - the
714:10 - minimum number of steps and this is a
714:12 - recursive function not too bad
714:14 - two four six around eight lines of code
714:18 - and let's test out some of the test
714:19 - cases here
714:22 - i'm just going to copy the test cases
714:24 - out here below
714:26 - and let's try as a general case which is
714:28 - intention and exception
714:31 - so let's see main steps
714:37 - intention
714:39 - and exception
714:42 - it says 5 4
714:46 - okay why does it say 4
714:53 - maybe let's test
714:56 - let's test a more simpler case first
714:58 - which is one of the strings being empty
715:00 - let's say we have intention and
715:03 - one of the strings is empty so we will
715:05 - need to delete
715:06 - uh let's just say int and one of the
715:08 - strings is empty
715:09 - this looks fine we will need to delete
715:11 - all three of these
715:13 - and that in some way tests out this case
715:15 - where
715:16 - or sorry tests out the second case where
715:19 - the second string is empty
715:21 - now we can
715:23 - test this case
715:25 - in this case also
715:26 - the
715:28 - in this case also the solution is three
715:31 - great looks fine
715:32 - let's test this case where str1 i1 and
715:35 - str2 i2 are equal
715:37 - so if you have
715:38 - integer and let's say you have india
715:46 - so i n i n would be the same
715:48 - so these would get skipped and here is
715:50 - where the recursion would kick in so t
715:53 - would have to be changed to d and then
715:55 - you would have to add i and e okay that
715:57 - looks fine too
715:59 - and let's check in tension and exception
716:00 - once again i don't know what's
716:02 - wrong here
716:08 - let's see
716:24 - so
716:25 - is it possible to do it with four i
716:27 - don't know it's maybe possible to do it
716:29 - with just four changes
716:32 - if you change i
716:33 - you delete i and then you delete n
716:37 - and then you delete t
716:46 - delete i substitute these
716:48 - two i don't think it is possible with
716:51 - just four changes
716:54 - so there's probably an issue
716:56 - [Music]
717:00 - i don't know what's wrong here it's
717:01 - possible i may have made a mistake here
717:05 - let me try another
717:08 - saturday and sunday
717:12 - okay
717:13 - so
717:14 - saturday
717:16 - satur needs to be changed to sunday s u
717:18 - n
717:20 - now s is the same so a t u r needs to be
717:23 - changed to
717:25 - u n so u remains the same
717:27 - now if we can what we can do is we can
717:30 - probably delete a delete t
717:33 - and take replace r with n so this seems
717:36 - to be fine
717:44 - all right so we'll probably unless i'm
717:46 - not seeing this so you have in
717:49 - tension and you have
717:52 - exception
717:55 - unless i'm not seeing something it seems
717:57 - like we may have made a mistake
717:59 - one one thing we could do is we can
718:00 - simply print out the strings that we are
718:02 - checking
718:03 - so let's see str1 is
718:06 - i1 onwards and str
718:08 - 2 is i2 onwards
718:24 - we are first checking intention and
718:26 - exception then we check
718:29 - let's also print the
718:31 - result here
718:41 - okay so at this point i would probably
718:43 - look through the loop here and see if
718:45 - the see if it is correct coming properly
718:47 - so you have intention and exception
718:48 - first we delete i then we delete n then
718:51 - we delete n then we delete t then we
718:53 - delete okay then we compare e and e so
718:55 - then we come back to n and exception
718:59 - and so on i think we'll have this might
719:00 - take some time to fix
719:03 - we'll come back to intention and
719:04 - exception but supposing we've solved the
719:12 - yeah supposing we've written the
719:14 - recursive solution correctly and i do
719:15 - have the recursive solution here
719:17 - so let me just
719:19 - grab that and put that in here
719:22 - let's see what's different
719:36 - okay probably the answer is 4 because
719:38 - i'm still getting 4 but supposing we
719:40 - have the recursive solution here so we
719:41 - have min edit distance
719:43 - this is the recursive solution
719:46 - and now
719:47 - what you need to do is you need to find
719:49 - out the complexity of the recursive
719:51 - solution now to find the complexity of
719:53 - the recursive solution what we can do is
719:56 - simply look at the recursive calls in
719:58 - the worst case
719:59 - so how you start out is you start out
720:02 - with a string of length n1 let's say and
720:04 - a string of length n2
720:06 - we have one string of length n1 and one
720:08 - string of length n2
720:13 - then
720:14 - you call either you call this min edit
720:17 - distance with i1 plus 1 and i 2 plus 1
720:20 - so str1 and str2 you call them with i 1
720:23 - plus 1 and i 2 plus 1 so that's one
720:25 - possibility
720:29 - or
720:31 - you call three recursive calls now one
720:33 - recursive call is the good case where
720:35 - these two match up so we want to look at
720:36 - the worst case where these two things
720:38 - don't match up so in that case you make
720:40 - three recursive calls right so you make
720:42 - three recursive calls and in each
720:44 - recursive call
720:46 - you are then going to reduce the problem
720:48 - size by one so you're either going to
720:49 - decrease i2 or you're
720:52 - either going to decrease the size of the
720:54 - first string or you're going to decrease
720:56 - the size of the second string or you're
720:58 - going to decrease the sizes of
721:00 - both strings right so
721:02 - just to keep things simple let's assume
721:04 - that in all three we are decreasing the
721:06 - size of either one of the strings by one
721:08 - so we are decreasing the total problem
721:09 - size which is n1 plus n2
721:12 - by one right so the number of levels of
721:14 - recursion is going to be the total
721:17 - number of total length of each of the
721:18 - two strings so let's maybe just draw
721:20 - that graph here as well
721:25 - so let's take
721:26 - this so here you have
721:28 - n1 comma n two so let's assume these are
721:31 - the lengths of the two strings
721:44 - now
721:45 - n1 plus n2 what happens to it
721:54 - is that this
721:57 - n1 plus n2 calls three recursive
721:59 - functions
722:01 - so there are three recursive functions
722:02 - so let's just draw those three recursive
722:04 - functions
722:13 - so we have those three recursive
722:15 - functions here let's take this two
722:22 - and then those in those three recursive
722:24 - functions
722:26 - what we have is
722:35 - either you reduce either you reduce the
722:37 - size of the first string
722:38 - or you reduce the size of the second
722:40 - string or you reduce the size of both
722:42 - strings
722:44 - so either you end up with
722:47 - n1 minus 1 and n2
722:51 - and let's reduce the size of that
723:00 - or we end up with
723:03 - n1
723:06 - and n2 minus 1
723:10 - or we end up with
723:12 - n1 minus 1
723:14 - and n2 minus 1
723:16 - okay so these are the three recursive
723:18 - calls that we're doing and then each of
723:19 - these will once again make three more
723:21 - recursive calls
723:28 - and so on
723:29 - now what is the depth overall depth of
723:31 - this recursive call
723:33 - now because we can see that each time
723:36 - the size of the problem reduces by 1 so
723:38 - if the size of problem is n1 by plus n2
723:40 - in this case it reduces by 1 in this
723:41 - case it reduces by 1 and in this case it
723:44 - reduces by 2 but for simplification
723:46 - let's say it reduces by 1 here so the
723:48 - total size of the problem the total
723:49 - number of levels in this tree is going
723:51 - to be
723:54 - n1 plus n2
723:57 - so you have three problems in the first
724:00 - layer the second layer will have three
724:01 - square problems the third layer will
724:02 - have three cube problems three times
724:04 - three times three and similarly you can
724:07 - go ahead and you will find that at the
724:09 - last layer you will have three to the
724:10 - power n plus n two minus one layers
724:13 - right and if you then add together all
724:15 - the layers what you end up with is that
724:17 - total
724:18 - total number of
724:19 - sub problems is 3 to the power n 1 plus
724:22 - n 2 right so you have a total of 3 to
724:24 - the power n 1 plus n 2 sub problems that
724:26 - you end up creating
724:30 - and because of that
724:36 - you have the complexity 3 to the power
724:38 - of n1 plus n2 in this case
724:42 - so that's
724:43 - that's the complexity so here we have a
724:44 - recursive solution and then we have the
724:47 - complexity of the recursive solution
724:48 - which is exponential 3 3 to the power of
724:51 - n1 plus n2 now at this point it will
724:54 - make sense to add memoization so
724:56 - whenever you see recursive solutions and
724:57 - you see repeated problems for example
724:59 - here itself you can see a repeated
725:01 - problem
725:03 - and then you can see that this problem
725:04 - will get repeated inside this problem
725:06 - and inside this problem too so there are
725:07 - a lot of repetitions and all we need to
725:09 - do is remove some of those repetitions
725:11 - and to remove those repetitions we can
725:13 - use memoization
725:15 - so what happens in the memoize solution
725:17 - it is exactly the same as the recursive
725:18 - solution but before doing any
725:20 - computation we check a memo we check a
725:23 - dictionary if we already have the
725:25 - solution for the changing variables
725:27 - which is i1 and i2
725:33 - and if we have those
725:37 - if we have those solutions
725:39 - what we need to do is
725:41 - just return them directly if we do not
725:43 - have those solutions we need to compute
725:44 - the solutions put them in the memo and
725:47 - then
725:48 - return the value from the memo
725:50 - so let's write the memoize version so we
725:52 - have min
725:54 - edit distance
725:57 - with str1 and str2
726:01 - and this we are calling memo
726:16 - okay this we are calling memo so now we
726:19 - have
726:23 - a memo
726:24 - the memo is going to be a dictionary
726:27 - and the dictionary is empty
726:30 - and then we define a function recurs
726:33 - so instead in memoization normally you
726:34 - have to write a recursive helper
726:36 - function now you can either write this
726:37 - outside or inside
726:41 - i like writing this inside
726:43 - because
726:45 - well it will have access to str2 and
726:47 - they do not need to be passed in so here
726:49 - we have i1 and i2
726:51 - and first thing we do is we create a key
726:53 - so the key is i1 comma i2
726:55 - now if key in memo which means if we
726:57 - have already computed the solution then
726:59 - we simply return
727:00 - memo of key
727:02 - if not then we have all the other cases
727:04 - so now we have alif
727:07 - now we can check if i1
727:10 - equals len of str1
727:17 - in that case
727:18 - don't return set the memo of key
727:21 - to
727:23 - len of str2
727:25 - minus i2
727:29 - lf
727:30 - i2 equals len of str2
727:39 - then we return
727:42 - memo of key is
727:44 - len of str1
727:47 - minus i1
727:51 - lf
727:52 - okay in this case then we check if the
727:54 - first elements are equal so we have the
727:56 - exact same logic you can see the same
727:57 - cases coming up here so if you have str1
727:59 - of i1 equals str2 of i2
728:05 - in this case we have memo of e equals we
728:09 - simply ignore the first character so we
728:10 - increment i1 and i2 so exactly what we
728:13 - have done here so we simply call recurse
728:15 - this time with i 1 plus 1
728:17 - and i 2 plus 1 right so we always call
728:19 - the recursive function but inside the
728:21 - recursive function if it has already
728:23 - been computed it will return from the
728:25 - memo
728:27 - and finally if we have
728:29 - and this is the final case which is
728:31 - where they are not equal so here memo of
728:33 - key becomes
728:37 - 1 plus
728:39 - min of
728:43 - let's see here
728:45 - so we have recurse so the insertion
728:47 - cases
728:49 - we will ignore the first element sorry
728:52 - the deletion cases we will ignore the
728:53 - first element of the current range from
728:56 - the first string so we recall recurs
728:58 - with i 1 plus 1 and i 2
729:00 - otherwise we call recurse with i 1
729:03 - plus 1 and i 1 plus i 2 plus 1 this is
729:06 - the case where we swap the first element
729:08 - of the first string so
729:10 - we can just recursively check
729:13 - after ignoring the first element of each
729:15 - and then we have recurse with
729:17 - i1
729:19 - comma i2 plus 1
729:22 - i2 plus 1
729:24 - and there we go and that's it so now we
729:26 - have stored it in the memo and then we
729:28 - simply return memo of e at the very end
729:32 - and finally we call
729:35 - recurse
729:36 - 0 0 and that is our solution
729:40 - and there is a syntax error you can fix
729:42 - these syntaxes they're easy to fix
729:45 - and i've just realized that the solution
729:48 - in this case might actually be 4 because
729:50 - what we can do is
729:52 - we can change
729:54 - n to p
729:55 - so that's one step we can replace i n t
729:59 - with e x c so we replace i and t with
730:02 - exe that's three changes we don't change
730:05 - e and we replace n with p the solution
730:08 - is four so our solution was correct
730:11 - there was no issue there
730:14 - in fact this is not the best solution
730:17 - this is a sub optimal solution
730:20 - so this output should be four
730:22 - and that's okay this is something that
730:24 - happens all the time where
730:26 - you miss something
730:28 - and
730:29 - you just assume that you just say that
730:31 - you're going to come back to it at the
730:33 - end and then you move forward assuming
730:34 - that that code was right and then you
730:36 - realize that either you were correct or
730:38 - what your mistake was
730:43 - it's probably going to happen in one of
730:45 - five interviews anyway
730:47 - okay so now we've written a memoi
730:49 - solution
730:50 - great and we can start checking the
730:52 - memoi solution now so minimum edit
730:54 - distance memo
730:55 - let's call main edit distance memo and
730:58 - we get back the value 4 looks fine let's
731:01 - try saturday
731:03 - and sunday as we have
731:14 - so that's three so what you will do is
731:16 - you will leave a as it is change a t u r
731:20 - to u n by
731:21 - removing a t and changing r to n
731:24 - that seems fine let's test out some
731:27 - cases like this okay this is three six
731:30 - eight characters so that seems right we
731:33 - simply delete all the characters
731:35 - let's check out this
731:38 - here also eight characters we have to
731:40 - add eight characters let's say we have
731:42 - abc and
731:44 - xyz so this should be three if it is x y
731:48 - z
731:49 - k
731:50 - then maybe that will be four
731:52 - what if it's x y z a in this case also
731:54 - it's four
731:57 - so this seems to be working fine
732:00 - we have now taken the recursive solution
732:02 - identified the inefficiency calculated
732:04 - the complexity which was exponential
732:06 - identified the inefficiency and the
732:09 - which was repeated sub problems and then
732:11 - fixed the inefficiency by calling min
732:14 - edit dist by using memoization
732:17 - and now how do you compute the
732:21 - time complexity of memoization well the
732:24 - argument is if you only need to compute
732:27 - the solution for a key once and the
732:29 - computation apart from the recursive
732:31 - calls simply involves some comparison
732:33 - and a fixed number of comparison and an
732:35 - addition so the time required to compute
732:38 - assuming you have the recursive
732:40 - solutions is constant so that means if
732:42 - you simply count the number of
732:44 - memoizations that can possibly occur
732:46 - that gives you an upper bound on the
732:48 - total num number of operations it will
732:50 - be some multiple of that some constant
732:51 - multiple
732:54 - so i1 can take the value 0 to n 1 where
732:57 - n 1 is the straight length of string 1
732:59 - and i 2 can take the value 0 to n 2
733:01 - where n 2 is the length of string 2. so
733:04 - memo
733:05 - the keys in memo can be i 1 comma i 2 so
733:07 - you have n while n 1 values for i1 and 2
733:09 - values for i2 so that makes it n1 times
733:12 - n2
733:13 - that's the number of keys and that
733:15 - because there's a constant amount of
733:17 - time additional time required to compute
733:19 - the solution for a key that is also the
733:21 - complexity so the complexity is order n1
733:24 - plus n2 so we've gone from 3 to the
733:26 - power of n1 plus n2 which grows very
733:28 - quickly even for
733:30 - 3 to the power of
733:33 - 3 to the power of
733:36 - 10 is pretty high we can check it out
733:38 - here 3 to the power of 10 is something
733:40 - like 59 000 3 to the power of 100 so if
733:43 - you have n one plus and 2 then that's e
733:45 - to the 47 that's going to be a lot of
733:47 - operations on the other hand
733:49 - if or in with memoization it is only
733:51 - going to take let's say 100 is split as
733:54 - two strings of length 50 and 50.
733:58 - only going to take 2500 operation so
734:00 - where it was taking 10 to the 47
734:02 - operations now it takes only 2 500
734:07 - operations which is pretty small so you
734:08 - can still work with lists of size up to
734:11 - 10 000 or 100 000 very easily using the
734:14 - memoi solution
734:18 - so that covers this problem and keep
734:20 - talking through your solution even as
734:22 - you're stuck even as you're confused
734:24 - just as i was
734:26 - it's helpful to just keep spend maybe
734:28 - two or three minutes trying to solve the
734:30 - issue and if you're not able to solve
734:32 - the issue just say that this is
734:33 - something i'll fix later and then move
734:34 - on assuming that you've
734:36 - fixed it and then keep talking and keep
734:38 - continue keep working on the solution
734:40 - and at some point later it's possible
734:43 - that the solution might like you
734:49 - now at this point
734:51 - you may be asked sometimes to
734:54 - implement a dynamic programming or an
734:56 - iterative solution like the
734:58 - when you talk to the interviewer and
734:59 - you're telling them that this is how i'm
735:01 - thinking i'm doing i'll do a recursive
735:03 - solution first and i can see that maybe
735:05 - there are going to be some sub problems
735:06 - there then i'm going to then apply
735:09 - dynamic programming
735:13 - so you can just check with them and in
735:14 - most cases they will accept a
735:16 - memoization solution because the dynamic
735:18 - programming solutions can take a little
735:19 - bit of time to solve to
735:21 - implement and they're always off by off
735:23 - by one errors and it's also difficult to
735:25 - explain the solution so you can most
735:27 - most cases get away with memoization but
735:30 - if they do ask you to do it with
735:32 - iteratively with dynamic programming
735:33 - then you'll have to go ahead and
735:34 - implement the dynamic programming
735:36 - solution so once again take a couple of
735:38 - minutes now and work it out on a piece
735:42 - of paper and then go back to them now
735:44 - for dynamic programming remember you
735:45 - have to create a table essentially
735:48 - so what the table will look like
735:50 - in this case
735:52 - is let's see if we can simulate a table
735:57 - what the table will look like is
736:01 - let's create a new sheet
736:06 - and in this sheet let us put the two
736:09 - words which is
736:11 - intention
736:34 - okay and let's put the word exception as
736:36 - well
736:54 - move this down too and let's
736:56 - also put in
736:58 - the indices
737:00 - ultimately this is what a dynamic
737:02 - programming looks like programming
737:03 - problem looks like
737:07 - you are ultimately going to create a
737:09 - table here
737:16 - and how we'll start filling the table is
737:18 - the ijth element so let's say this
737:20 - element
737:23 - int int e e x c e
737:26 - so this element represents
737:28 - the edit distance or the number of
737:30 - operations required to convert i n t e
737:32 - into e x c e
737:35 - and how do you check what the solution
737:37 - is now you know that e
737:39 - and e
737:41 - are equal so the final elements are
737:43 - equal so what that means is we look at
737:46 - this value then this value should tell
737:48 - us what is the minimum edit distance
737:50 - between exc and exc now since we can
737:52 - simply add e to each string and get this
737:54 - solution that means this solution is
737:56 - equal this value should is equal to this
737:58 - value all right so
738:00 - in the case where the corresponding
738:02 - elements are equal we simply copy over
738:05 - the value diagonally left top left value
738:07 - onto the current cell
738:09 - the other option is
738:11 - if they are not equal so let's say if we
738:13 - are here where here you have n and here
738:15 - you have p now there are three
738:16 - possibilities you you want to find
738:20 - the
738:21 - minimum edit distance between i and t e
738:23 - n and e x c e p
738:28 - now
738:29 - n is not equal to p
738:30 - and this is the original string so
738:32 - either we delete n now if we delete n
738:35 - then we need to find
738:37 - the solution for i n t e and e x c e p
738:40 - so if we delete n then this value will
738:43 - become one plus this value that's one
738:45 - possibility
738:47 - or another possibility is that we swap n
738:50 - so we swap n for p
738:52 - so now you get this becomes p and this
738:54 - becomes p so this value will becomes
738:56 - will become 1 plus this value because
738:58 - now we can ignore the p and simply get
739:00 - this previous solution for e x c e and i
739:02 - and t e so this value becomes one plus
739:04 - this value
739:06 - or the final option is that you can
739:08 - insert something
739:10 - just before n so if you insert something
739:12 - just before n
739:18 - which is going to be p so if you insert
739:20 - p just before n
739:26 - so you insert p just after n naught
739:28 - before if you insert p just after n then
739:30 - you have p after it already so you can
739:33 - just look at this value
739:35 - and
739:36 - this value is going to be one more than
739:38 - this value in the case that you insert
739:40 - something insert p after n right so
739:42 - there are three ways to come to this
739:43 - value either by
739:45 - deleting n
739:46 - or by inserting p
739:48 - or by
739:51 - changing n to p and what you can do is
739:53 - you can take the minimum of three values
739:54 - three or these three values and add one
739:56 - to obtain this value so that's the logic
739:59 - roughly speaking and you start from the
740:01 - left so you see okay e and i they are
740:03 - unequal so you need one operation to
740:05 - change them and there's nothing else
740:07 - to consider so that's done then e and n
740:10 - they are unequal now
740:13 - you need
740:15 - what you can do is
740:17 - you can either delete n
740:21 - if you delete n then you simply need to
740:23 - check e and i
740:26 - and you know that the solution for e and
740:27 - i is one so this would be two
740:29 - another another option is that you could
740:32 - possibly insert something but if you
740:34 - insert something the length of i n is
740:36 - going to increase so that's going to
740:37 - cause a problem so you can't insert
740:39 - anything another option is you change n
740:41 - with e but if you change n with e
740:44 - then you will no longer be able to
740:49 - if you change n with e
740:52 - then you will no longer be able to use
740:54 - this solution
740:55 - right because now you will have to match
740:57 - i
740:58 - with the empty list
741:00 - so that's going to be one as well so
741:02 - overall you end up with two and this is
741:03 - how you start filling the list so you
741:04 - start filling up from left to right
741:07 - and left to right and keep going top to
741:09 - bottom and as you fill out this list
741:10 - finally you will fill out this final
741:12 - value exception and intention and that
741:14 - will be your solution so that's the
741:16 - dynamic programming solution and you can
741:17 - see that it's getting tricky to convey
741:19 - the entire solution because there are so
741:21 - many cases involved here so typically
741:22 - you will not find dynamic programming
741:24 - solutions to requested in interviews and
741:27 - it will help you to just stick to the
741:29 - memoization solutions
741:32 - all right so with that
741:35 - we have covered
741:37 - two common interview questions and you
741:39 - can keep going so the idea here
741:42 - is to just apply the method
741:44 - remember the remember the method the
741:46 - problem solving template that we've
741:48 - covered state the problem
741:50 - identify input and output formats write
741:52 - a function signature come up with some
741:54 - example inputs and outputs or at least
741:56 - the scenarios come up with the correct
741:58 - solution stated in plain english
742:00 - implement the solution test it using
742:02 - example inputs and fix bugs if you face
742:04 - any then analyze the algorithms
742:06 - complexity and identify inefficiencies
742:08 - and finally apply the right technique to
742:10 - overcome the inefficiency and you repeat
742:12 - the process
742:13 - going back and stating the solution
742:14 - implementing analyzing and
742:16 - repeating now you in some cases you do
742:19 - not need to implement the root force
742:21 - solution if you don't have the time but
742:23 - when you're working with recursive
742:24 - solutions it always helps to implement
742:26 - brute force first before you do
742:28 - memoization or dynamic programming
742:31 - and some tips
742:32 - ask questions
742:34 - as many questions as you can as many as
742:36 - you need to clarify the problem show an
742:38 - example
742:39 - follow the method don't panic
742:42 - if you get stuck at a certain point
742:46 - give it a couple of minutes sometimes
742:48 - you can even ask the interviewer and
742:50 - they may be able to tell you that
742:53 - maybe what your error is or
742:55 - maybe you're not stuck at all what
742:56 - you're
742:57 - simply assuming something incorrectly
743:00 - but beyond a few minutes what you want
743:02 - to say is that
743:03 - let i'll fix this later assuming this is
743:05 - correct let's move on and then talk
743:07 - about complexity and optimization and
743:10 - such and such
743:13 - very important is to state the brute
743:15 - force solution to the interviewer and if
743:17 - you are unable to figure out a more
743:19 - optimal solution
743:20 - then the best thing you can do is to
743:22 - offer to implement the brute force
743:24 - solution so that you can at least
743:25 - demonstrate that you are able to write
743:27 - code and it's all right in a lot of
743:28 - cases you will not be able to
743:30 - figure out the optimal solution and in
743:32 - some cases there may not be an optimal
743:34 - way so there are some there are certain
743:35 - problems where there is just one way and
743:38 - that is the hard way or the brute force
743:40 - way and this is typically
743:42 - very true with a
743:44 - family of problems called backtracking
743:45 - something we've not really covered
743:47 - in a lot of detail
743:49 - but it is also another form of recursion
743:54 - so
743:55 - what do you do next so the next step for
743:57 - you ish is to review this lecture video
744:00 - and solve these problems yourself
744:03 - or take more problems ideally what you
744:04 - want to do is you want to take all the
744:06 - five
744:07 - different techniques that we've covered
744:09 - and let's quickly review what those five
744:10 - techniques were
744:15 - the first one was binary search so we
744:17 - looked at linear search and binary
744:18 - search which is a form of divide and
744:20 - conquer
744:21 - and along with that we also understood
744:22 - the complexity and big o notation and
744:24 - then you had some homework on linked
744:25 - lists and python classes but binary
744:28 - search is something that comes up often
744:30 - and the hint to detect binary search is
744:34 - simply to look for order whenever you
744:35 - see something being something being
744:37 - mentioned mentioned as sorted now that
744:39 - is an indication for you that this may
744:41 - be binary search sometimes what you may
744:43 - have to do is you may have to
744:46 - get things into a sorted form maybe by
744:48 - taking
744:50 - replacing elements by
744:52 - sum of values till that element or so on
744:54 - and once you get things into a sorted
744:56 - form maybe then you can do binary search
744:59 - that's one way to go about it and once
745:01 - again just do five to ten problems on
745:03 - binary search and you will be able to
745:05 - identify pretty much any binary search
745:07 - question in an interview
745:10 - then the next topic that we looked at
745:12 - was binary search trees traversals
745:14 - and
745:15 - here is something
745:18 - that is generally asked very directly so
745:21 - you will be given a question like binary
745:23 - search tree do something with the binary
745:24 - search tree and you can answer that
745:26 - question directly we've covered a lot of
745:28 - different things here so do check out
745:30 - lesson two for all the different things
745:31 - you can do with binary search trees
745:33 - traversals balancing
745:35 - and most of these are recursive
745:36 - solutions so it's also a good exercise
745:38 - on recursion and we've also looked at
745:40 - balanced binary trees and how can we
745:41 - optimize them further
745:43 - then you had an assignment on hash
745:44 - tables so hashing is a again a common
745:47 - question that is often asked so we built
745:49 - hash tables from scratch in python and
745:51 - we also handled collisions using a
745:53 - technique called linear probing and so
745:55 - this is something you can check out in
745:57 - assignment two so you may get asked just
745:59 - to implement a hash table in python or
746:01 - implement
746:03 - collision
746:05 - resolution in a hash table in which case
746:07 - you can use linear probing
746:09 - then you have the sorting algorithms
746:11 - where we looked at bubble sort and
746:13 - insertion sort merge sort using divide
746:15 - and conquer and quick sort where we had
746:18 - a quadratic worst case complexity but
746:22 - a logarithmic average complexity and
746:24 - that's a good thing because merge sort
746:26 - although it is logarithmic in the
746:29 - worst case it still takes up a lot of
746:31 - space and space allocation is slow and
746:34 - you may also not have the memory
746:37 - that's why we sometimes use prefer quick
746:38 - sort over merge sort when we are
746:40 - constrained for space
746:42 - then
746:43 - assignment 3 is pretty interesting where
746:45 - you will implement
746:46 - an optimal algorithm for polynomial
746:48 - multiplication using divide and conquer
746:51 - so do check out assignment 3 as well
746:53 - then we looked at dynamic programming we
746:55 - looked at recursion memoization
746:57 - subsequence and abstract problems and
746:59 - then we finally also didn't cover
747:01 - backtracking and pruning but we there
747:03 - are some questions there in the lesson
747:05 - notebook which you can try out which use
747:07 - backtracking and pruning as well then we
747:10 - looked at graph algorithms the last time
747:12 - which was
747:13 - graphs and adjacency list and adjacency
747:16 - matrices we looked at the depth first
747:18 - and breadth first search and how to
747:19 - implement them and we also looked at
747:21 - shortest paths and directed and weighted
747:23 - graphs
747:25 - this is a very important topic breadth
747:26 - first in depth first search you will get
747:28 - many questions related to these so do
747:30 - solve maybe five questions on each of
747:32 - these topics
747:34 - and you should be good with most graph
747:35 - problems asked in interviews now this
747:38 - project for you the course project if
747:39 - you haven't seen it already
747:41 - is to pick a coding problem so you can
747:43 - pick a coding problem from an online
747:44 - source like lead code hacker rank geeks
747:46 - for geeks etc and then use the problem
747:48 - solving template that we've shared with
747:50 - you
747:52 - this problem solving template as a
747:54 - starting point so just give it a name
747:55 - and then write the problem statement and
747:58 - implement the solution step by step to
748:00 - use the problem solving template to
748:02 - solve the problem using the method
748:03 - you've learned in the course then
748:05 - document your solution add explanations
748:07 - wherever required perform the complexity
748:09 - analysis
748:10 - all of this you should add in the
748:11 - jupyter notebook and then publish your
748:13 - notebook to your jovian profile
748:16 - and finally you can submit the link to
748:17 - your jovian notebook
748:19 - here
748:20 - do submit the link to your jovi notebook
748:22 - here
748:23 - and you can check out
748:26 - the discussion where
748:27 - you can
748:29 - change
748:30 - where you can post what you what you're
748:32 - working on so do post your notebook as
748:35 - well and finally today we have looked at
748:37 - a couple of real interview questions
748:39 - from amazon and google and how to go
748:41 - about solving them
748:44 - and we also
748:47 - addressed a few issues that we faced
748:48 - along the way
748:50 - so that was a helpful exercise
748:56 - and that's it so now you can review the
748:57 - lecture video execute the jupyter
748:59 - notebooks complete the assignments and
749:01 - attempt the optional questions so that
749:03 - the topics that we've covered they get
749:04 - consolidated and you do not ever have to
749:07 - look at this lecture again right
749:09 - practice is what really reinforces and
749:12 - consolidates your learning
749:14 - complete the assignments and attend the
749:15 - optional questions to practice and
749:17 - participate in forum discussions also
749:19 - very useful when you participate in
749:21 - forum discussions why by answering
749:23 - questions a lot of your own doubts get
749:25 - cleared so do participate in forum
749:27 - discussions and then join or start a
749:29 - study group if possible getting together
749:31 - with a group of four or five people is
749:33 - great it really helps you
749:36 - focus
749:37 - and uh
749:39 - improve your understanding by discussion
749:43 - so that's data structures and algorithms
749:45 - in python
749:46 - with that thank you very much for
749:48 - joining us on this journey as we learn
749:49 - data structures and algorithms in python
749:52 - a very useful topic to improve your
749:54 - coding skills and also something that
749:56 - you will almost certainly encounter in
749:59 - one of your interviews no matter which
750:01 - company you're applying to so i hope
750:03 - this is helpful to you do let us know on
750:05 - the forum how
750:08 - this course helped you if it did
750:10 - you can let us know in the youtube
750:11 - comments as well if you have questions
750:13 - if something was not clear do post that
750:15 - too when we make sure to come up with
750:18 - clearer explanations and clearer
750:20 - examples the next time
750:22 - if you have any feedback for us do post
750:24 - it in the comments or send us an email
750:26 - at support jovian.ai
750:32 - with that i will take leave and i will
750:34 - see you in the forums this is not the
750:36 - end of our journey with you so do stay
750:39 - active on joven there's a lot of great
750:40 - activity happening do check out the
750:42 - forums the newsletter and
750:44 - stay tuned for our next course thank you
750:47 - and goodbye

Cleaned transcript:

this is a beginnerfriendly introduction to common data structures and algorithms in python this course is taught by akash ns the cofounder and ceo of jovian data structures and algorithms in python is a practical beginner friendly and coding focused online course that will help you improve your programming skills solve coding challenges and ace technical interviews you can also earn a verified certificate of accomplishment by completing this course learn more and register at pythondsa.com this course runs over six weeks with two hour video lectures every week with live interactive coding using the python programming language you will get a chance to practice and improve your coding skills with weekly programming assignments consisting of real interview questions and you will also build a course project that you can showcase on your resume or linkedin profile this is a beginnerfriendly course and some basic programming knowledge will help you follow along with the course don't worry if you're new to programming you can learn it as you work on this course with a little extra effort you will also get to access the course community forum where you can ask questions participate in discussions and share what you're working on during the course this course is created by jovian a platform for learning data science and machine learning with a global community of tens of thousands of learners from over 150 countries i'm your instructor akash cofounder and ceo of jovian and i'm really excited to kick off this course with you register now and invite your friends to join the course at pythondsa.com hello and welcome to data structures and algorithms in python this is an online certification course brought to you by jovian and today we are at lesson one binary search linked lists and complexity analysis my name is akash i am the ceo and cofounder of jovian and i will be your instructor you can find me on twitter at rcacheness this course runs over six weeks and over the six weeks if you enroll with for the course work on four programming assignments and build a course project you can earn a certificate of accomplishment along the process you will also learn about common data structures and algorithms in python and how to use these skills to ace coding interviews and technical assessments so let's get started then to begin we need to go to the course website pythondsa.com so if you open up pythondsa.com in your browser that will bring you to this page this is the course page and you can watch an introductory video about the course here you can enroll for the course for free you will need to sign in into jovian you can use your google github or email to sign in into jovian and once you're enrolled into the course you can also invite your friends to join the course the course is still open for enrollments so please invite your friends and colleagues this course is a beginner friendly introduction to common data structures and algorithms in python and this course will help you prepare for coding interviews we have coding focused handson video tutorials every week so you can either follow along with this video you can pause and run the code as we speak and you can practice coding on the cloud or you can watch the video right now and you can practice later in this course we will solve questions from real programming interviews and you can earn a verified certificate of accomplishment so let's go to lesson one binary search linked lists and complexity on the lesson one page you can see a recording of the lesson once it is completed and you will also be able to see a hindi version here and all the code used in this lesson is linked below so the first set of code that we will look at today is called linear and binary search so let's open it up so this is the first tutorial that we will work through in this lesson and you will be able to work through with it as well and this is part one and there are a total of 12 notebooks or 12 tutorials we will go through now this course assumes very little background in programming and mathematics but you still do need to know a little bit for instance you do need to know basic programming with python things like variables data types loops and functions and don't worry if you don't know them already you can click through and follow these links each of these is a separate tutorial the tutorial will take you about half an hour or so each of these and you can learn the basic programming with python in just a couple of hours you will also need to know some high school mathematics and if you want to brush up things like polynomials vectors matrices and probabilities you can click through and read these but no prior knowledge of data structures or algorithms is required you do not need to have an extensive coding background and we will cover any additional mathematical and theoretical concepts as we we need as we go along so how to run the code what you will see here is that some explanations and then you will also see some code so you can see here that there is some code written here and there is some func so the library is imported and a function from the library is used here now to run this code you have two options you can either run this code using free online resources which is what we recommend or you can run it on your computer locally and you can read these instructions i am going to use free online resources provided by jovin so we just scroll up here at the top of this page and click run and then click run on binder so this will take a second or two and what we're doing here essentially is setting up a machine for you on the cloud using a software called binder it's an open source software and now what you were looking at here this was actually not a blog post this is actually something called a jupiter notebook a jupiter notebook is something that can not only contain explanations but can also contain code and you can look at the code and its outputs right here in an interactive fashion so if i scroll down here you can see that we have all the same content that we were looking at except this time we can actually run this code so we can click the run button here and the run button will run the code and here we click the second run button that is going to run the second line of code now we will be using jupyter notebooks extensively throughout this course because jupyter notebooks are a great way to do interactive programming you can change the code for example instead of the math mat dot square root you can use mat dot seal and you can change the value here so jupyter notebooks are great for experimenting with code now just a couple of tips that you want to do as soon as you run a jupyter notebook you can click on kernel and click restart and clear output what this will do is this will remove all the preexecuted outputs from your code so you can now see that the output of the function is gone and you can see that the numbers here go away so now you can execute the code line by line yourself and see the output discover the output and then one other thing you can do if you want to hide the ui a little bit is to toggle the header and also toggle the toolbar now you might need the toolbar for the run button but there's a tip here instead of pressing the run button you can use shift plus enter so if you press shift plus enter that will execute a cell and that's a pretty handy shortcut so once again you go on the lesson page on the lesson page you will find a link to the notebook called linear and binary search on the linear and binary search you can read the explanations but you can't run them to run the code you need to click run and then select run on binder and clicking run on binder will set up a cloud machine for you and all the code that you see here will get executed on the cloud so you do not need to set up anything on your computer you do not need to download anything we've done all that for you so let's get started then this course takes a coding focused approach towards learning and in each notebook or each tutorial we will focus on solving one problem and then learn the techniques algorithms and data structures to device an efficient solution for that specific problem we will then generalize the technique and apply it to other problems so in this specific tutorial we will focus on solving this problem and here's the problem we're solving and this is a typical problem that you will come across in a coding challenge or a coding interview so here's how the problem goes alice has some cards with numbers written on them and then she arranges the cards in decreasing order and lays them out face down in a sequence on a table so this is what it looks like these are cards each of these cards has a number below it and the numbers are in decreasing order she challenges bob to pick out the card containing a given number for example she could say bob i want you to pick out the number 7 by turning over as few cards as possible so this is a puzzle that's given to us and we're not told how many cards alice has so you need to write a function to help bob locate the card so alice can put down any number of cards and the target number that bob has to pick out could be anything so we have to tell bob not us not the solution for a specific problem but a general strategy that he can use to turn over as few cards as possible so for instance look at these seven cards and maybe put some imaginary imaginary numbers before them below them and try to figure out a strategy try to start thinking about the problem and this may seem like a simple problem especially if you're familiar with the concept of binary search but the strategy and technique that we're learning here will be widely applicable and we will soon use it to solve harder problems now before while you think about the problem and before we start solving it i just want to talk about why you should learn data structures and algorithms and whether you're pursuing a career in software development or data science it's almost certain that you will be asked programming problems like reversing a linked list or balancing a binary tree in a technical interview or coding assessment now it's well known that you never face these problems in your job as a software developer so it's okay to wonder why such problems are asked in interviews and they're asked because they demonstrate the following traits and these are very important traits for a programmer number one is that you can think about a problem systematically and then solve it systematically step by step too and the number two is that you can envision the different inputs and outputs in edge cases for your problem because programs when you put them out in the wild as part of software can encounter any kind of inputs and as you have thousands or millions of users you will encounter any and every possible input and often this has many security implications it can take down the server it can take down your application or you can have a loss of data or loss of property you can communicate your ideas clearly to coworkers that's a very important part of problem solving and most importantly you can convert your thoughts and ideas into working code and the code should also be readable to other people so it's not really the knowledge of specific data structures or algorithms that's tested in an interview but it is your approach towards the problem so you may fail to solve the problem but you may still clear the interview or vice versa you may solve the problem and still not clear the interview so in this course we will focus on the skills to both solve the problem and to clear interviews successfully so that's why you need to learn data structures and algorithms so coming back to the problem at hand now you've read the problem and you may have been thinking about it and maybe you have some ideas on how to solve it and your first instinct might be to just start writing the code for it but that is not the optimal strategy and you may actually end up spending a longer time to solve the problem due to coding errors or you may not be able to solve the problem at all so what we are going to cover here is a systematic strategy that you should apply in interviews or in coding problems on encoding assessments or in general whenever you are faced with a problem like this so here's the strategy that we will apply step one state the problem clearly identify the input and output formats step two come up with some example inputs and outputs and try to cover all the edge cases step three come up with a correct solution for the problem it can be as simple as possible and state it in plain english step four and this is a step that is optional sometimes implement the solution and test it using example inputs and then fix any bugs in your in your first solution in step five analyze the algorithms complexity and identify any inefficiencies and finally step six apply the right technique to overcome the inefficiency and then go back to step three which is come up with a new correct solution which is also efficient then implement the solution and analyze the algorithms complexity so this is the technique that we will apply over and over for the course of six weeks to many different problems and applying the right technique is where the knowledge of common data structures and algorithms comes in handy so this is the method we'll be using so let's jump into the solution step one state the problem clearly now you will often encounter detailed word problems in coding challenges and interviews they will go on for paragraphs and paragraphs for instance here we are talking about alice having a deck of cards and then shuffling them putting them out on a table talking to bob etc etc etc the first step is to state the problem clearly and precisely in abstract terms because computers don't understand people computers don't understand cards computers understand numbers so for in this case we can represent the sequence of cards as a list of numbers so a list is a basic data structure in python and the turning over of a specific card is equivalent to the accessing of the value of the number at a certain position in the list for instance if we think of this set of cards being represented by this list you can see here that this list is sorted in decreasing order then turning over a certain card is equivalent to accessing that specific element from the list so turning over card number two or as we say in computer science card number one because this is card number zero and this is one thing that you might want to get into your head as well that whenever you're counting always start counting from zero otherwise you may run into many off by one errors so this is position zero and this is position one so if you turn over the card at position one it is as good as accessing an element from a given list which in this case will turn out to be 11. so these are the positions in the list starting from 0. and now what we have to figure out is how many elements do we need to access so we need to access the minimum number of elements to get to a particular element right so the problem can now be stated as follows we need to write a program to find the position of a given number in a list arranged in decreasing order we also need to minimize the number of times we access the elements from a list so we're finding the position of the given number 7 and the position in this case is 3 and we want to minimize the number of times we access elements from the list so if we go in this direction for example we would need to access 13 11 12 and finally we discover 7 we come from this end we may discover 7 6 5 4 and finally we may discover 7. so definitely coming from the left is better than coming from the right but is that the best that's what we're solving now once we've defined the problem and what you should do is you should try to write down the problem in your own words and primarily this is for you to make it clear to yourself uh either speak it out loud to the interviewer or write it down in your own words as short as make it as short as as long as possible so that you clearly understand what's in it and then come up with the inputs and the outputs so there are two inputs here there's the input cards which is a list of numbers sorted in decreasing order and then the second input is a query which is a number whose position in the array is to be determined and there is one output which is position and the position is simply the position of query in the list of cards for example seven is at position three counting from zero of course and as soon as you've written the input and output out you can now write what is called the signature of our function which is a structure of our function without any actual code inside it so now we can call it def locate card with cards and query and the single statement inside it called pass because a function in python cannot have an empty body you need to put in at least one statement so you always put in the pass statement first because it doesn't do anything there you go so now we have framed our problem in abstract terms and now we have a function signature to work with now a couple of tips here this is something that interviewers specifically will look for but also encoding assessments because your code is also shared with the company so you may want to name your functions properly and think carefully about the signature for example here you should not call your function f1 or func one or f or something like that it's better to call it locate card because that's what it is doing and the similar thing is true for variable names as well use descriptive variable names one because it's good for coding practice and second because as you work on the problem you may lose track of what a variable represents for example if you call this a and you call this b now 20 minutes down the line talking about the problem writing different lines of code you may forget what a and b represent so please call them what they represent even if it can get a little long and finally if you're unable to come up with a function signature if you're unable to come up with a simple description then discuss the problem with the interviewer if you're unsure how to frame it in abstract terms so keep that in mind and this is really the first and most important step which is stating the clarifying the problem statement and stating it clearly do not start coding before you have done this otherwise you may get halfway into the code and realize that you have not understood the problem at all so step two now we will come up with some examples take some example inputs and outputs and our goal will be to cover all the edge cases so before we start implementing a function we want to have some examples so that once we implement it the first thing we want to know is is it correct and in general the answer is no because coding especially when you get getting started is hard because you have to think about many different scenarios so and especially especially interviews or coding assessments are also stressful situations so you may not be able to focus and think about all the different things that you need to keep in mind so simplest way to reduce the risk of going wrong is to use a test cases so here's one test case that we came up with you know we what we've done is we've taken the information that we've listed above in the inputs and outputs and we've written it in as code so now we have a variable called cards which is a list of cards a list of numbers then we have a query which has the value 7 and then we have the output which has the value three so the expected output from the function is three and once you have a test case you can test your function at any point anything you want to test you can simply pass the input for example cards and query into the locate card function and get back the result and you can see here right now because there's nothing inside the function the result you get back is none but later you'll start getting back a proper result from your function and what you can then do is you can compare the result with the output of the test case so in this case when we compare them obviously the output is 3 the result is none we get back false now one thing we will do in this course to make testing easier because we will be testing our algorithms again and again as we keep improving them is that we will represent our test cases as dictionaries so here for example this this test case will be represented or every test case will be represented as a dictionary containing two keys input and output and the input will contain one key for each argument to the function so if your function arguments are called cards and query in the function signature and that's why we wrote down a function signature first so that we don't get confused here so if your function arguments are called cards and query then we can take one one key called cards and put the value of cards there one key called query put the value of query there and then in in the output we simply contain we simply put the output that we expect from the function and now you can test this function like this so how you might want to test it first is maybe by actually passing values like this so you have test input cards and then test input query but there's a trick here whenever you have a dictionary so here we have a dictionary with two keys and we want to pass these two keys as two arguments to a function so we want to pass cards as the cards argument to the function locate card and query as a query argument to locate cards what you can do is you can simply put the dictionary itself and just write star star now if you write star star what python does is it takes the keys from this dictionary and the values are then used as arguments for parameters with these names so there we are now calling locate card on test input and we can compare it with test output and you can see that we get back false so that's one test case for us but is that enough is that enough for you to now start writing code probably not because out in the wild your function should be able to handle any number or any set of valid inputs that we pass into it and here are some possible variations that we might encounter and it really helps to list them in fact while i was writing these variations i realized that there are many cases that i had not thought of so even after coding for 12 15 years almost i still find it really useful to list out all the scenarios that we can find our input in so the simplest scenario is that the query occurs somewhere in the middle on the list of cards this is what you imagine when you read the question this is what is called the general case but then there are some special scenarios as well what if the query is the first element in cards and what if the query is the last element in cards what if the list cards contains just one element which is the query itself or and this is something that i had not thought of what if the list cards does not even contain the number query what if alice is bluffing so what should be bob's strategy then to figure out that the number does not exist what if the list of cards is empty and what if the list contains repeating numbers this is again another interesting thing that may not come to mind because we said a list of numbers and we did not specify that the numbers are unique so the list can contain repeating numbers and finally what if the number the query itself occurs more in more than one position in cards so those are eight cases that i could think of and just see if you can think of any more variations and it's likely that when you first heard the problem you did not think of all these cases because you often tend to just focus on one generic case it's hard to hold too many cases in mind and that's why it helps to list them down actually write them down in a coding interview or in a coding assessment or an interview you may want to put this in comments if you have a page coding page you can just create a comments and list out all the test cases and some of these especially things like the empty array or query not occurring in cards are called edge cases because they represent rare or extreme examples and while edge cases may not occur very frequently your program should be able to handle edge cases otherwise they may fail in unexpected ways or somebody with the with male intentions can use the edge cases to hack your software so let's create some more test cases for the variations that we've listed and we'll store all our test cases in a list for easier testing so here we are creating a list called tests and this time we will create all our test cases in the format that we discussed which is a dictionary format and we will keep appending them to our list now if you do not understand lists and dictionaries and appending then you can go back and review some of the basic material on python which is linked at the top of this notebook so first we take the one test case that we already have we put that and we take maybe one more example of the query occurring somewhere in the middle so here you can see this is the cards list and then the query one occurs somewhere in the middle although it's closer to one end then here's one case where the query is the first element four and the output obviously the output expected is zero here's one case where the query is the last element minus 127 and this is another thing the numbers could be negative as well something you may want to keep in mind here's another one the weather card contains where cards contains just one element the query itself now the problem does not state what to do if the list cards does not contain the number query and you may often face these questions where it may not be clear what to do in a certain situation or if a certain situation can occur and when you have questions like this this is a process you should follow step one read the problem statement carefully or ask the interviewer to repeat the question so read the problem statement carefully and you me you will often find hints and sometimes these hints are just single number single words somewhere often you will also find some examples provided with the problem you will also find if you scroll down to the bottom you will find some conditions you will find limits on what the numbers can be whether they can be integers or can be decimals whether they can be negative or positive so it's important to read the problem carefully before you start coding and look through the examples and then ask the interviewer or maybe post a question on the platform for a clarification often it happens that interviewers because they take so many interviews they may forget to specify a certain detail and or they might expect you to ask the question because you should not be coding with an insufficient requirement so to clarify the specifications of the problem is very important so if you have any doubt ask the interviewer even if you are somewhat sure about it but just want to verify it's a good idea to ask then finally if you are done with all of these and you still do not have a solution then you just make a reasonable assumption state it and move forward so we will assume that our function will return 1 in case cards does not contain query so if cards does not contain query then we return we expect the function to return 1 now here's one other case where the card's array is empty and obviously then it does not contain the query as well and finally there's one last case which is the number itself can repeat in cards numbers can repeat in cards and then the query itself can repeat in cards so here the query does not repeat three does not repeat but the numbers on the in the cards that i do repeat and the last case is when the query itself repeats so you can see here in cards the query occurs many times once again it is not specified what to do here and sometimes it may be okay sometimes the problem statement may just say that return any one position but more likely than not what you will want to do is you may want to make it more deterministic and that will also make it easy for you to test the function so what we can say we can impose this additional restriction that we will expect our function to return the first occurrence of query and that will make it easier for us to test so that when we when we're testing our problem we we know that if we're getting a failure it's not because of multiple possible answers but it's because of some issue in our code right so you want to get good feedback from failures and that's why you want your tests to be deterministic so here is the final test and now we can see the full list of test cases so now we can see the list of test cases here so you have about eight or ten test cases here you may not need to create this many test cases in an interview or a coding assessment depending on how much time you have but you should create at least a few at least cover the three or four edge cases a good number to aim for would be five and this will not only help you in the coding interview help you solve the problem this will also be appreciated by the interviewer because it shows that you're thinking about the problem so definitely take a minute or two now we've spent 10 15 minutes talking about this but once you start applying this technique over and over you will see that you will start creating test cases in seconds so as soon as you read the problem and you state the problem find the find the input format find the output format write a function signature and write the test and then you will start working on tests the ideas will automatically start coming to you and within maybe two or three minutes you will be done with both all to both of these steps so great we now have a fairly exhaustive set of test cases and creating test cases beforehand allows you to identify different variations and edge cases and sometimes it may happen that you may have no clue how to work on the problem you may feel completely confused but if you simply start writing multiple test cases and start looking at them like literally list just staring at the test cases the question and the answer the solution will reveal itself to you so don't underestimate the power of writing things down and don't stress it don't stress out if you can't come up with an exhaustive list of test cases because this takes time it's a skill that you cultivate with time so what you can do is you can list out maybe the test cases that come to your mind right now and put them in a single place and keep coming back whenever a new test case comes to mind while coding or while discussing or while analyzing you can just come back to the same place and write down the test case the important thing is that you have a single place where you're listing all test cases so we've written our test cases now and now we can come up with a correct solution and how do you come up with the correct solution not by writing code but by first stating it in plain english so your first goal and by correct we do not mean the best or the most efficient solution first we want to solve the problem we want to figure out where the particular number lies in the list and not to minimize because that's solving two problems at once and sometimes that can get tricky so first aim for correctness then aim for efficiency and the simplest or the most obvious solution which almost always exists and is almost always very easy to see involves checking all the possible answers and this is also called the brute force solution so in this problem coming up with the brute force solution is quite easy bob can simply turn over the cards in order one by one till he finds the card with the given number on it so this is what this is how it might work if we want to implement it in code and this is where writing it in your own words becomes important so we create a variable called position inside a function with the value 0 then we check that the number at the index position in the card list equals query or not now if it does since we're starting from the beginning if it does then position is the answer and we can return it from our function but if it doesn't then we simply increment the value of position by one and then we repeat the steps so we go back to step two and then we check whether the number at the index position on in cards equals query and once again if it does we return position if not we increment the position once again and repeat and we repeat that till we reach the last position and if the number was not found we return 1 so it's a simple fourfivestep description doesn't take very long you can either say it out loud to the interviewer they will also appreciate it that they will know you know you may know that you know the brute force solution and you may not say it because it seems too simple or obvious but the interview does the interviewer doesn't know that so it's important to state the brute force solution you may say that i the brute force solution is fairly straightforward and it goes like this steps one two three four just take 30 seconds but at the very least it informs the interviewer that you're able to think of some solution and it happens very often i've seen it in interviews where 30 40 minutes have passed out of 45 minutes and not a single solution has been proposed so far even though many lines of code have been written so it's important to state your solution and if you state your solution the interviewer will also help you and correct you as you go forward right so it is a collaborative experience it is a discussion so use that and if you are in a coding assessment you may just want to write out a few comments and what we've implemented here is congratulations is just our first algorithm and an algorithm is simply a list of statements a list of steps that can be converted into code and executed by a computer on different sets of inputs so this particular algorithm is called linear search because it involves searching through a list in a linear fashion element by element so now we're ready to implement the solution and just a quick tip as i've already said always try to express the algorithm in your own words and it can be as brief or as detailed as you like and don't underestimate the power of writing writing can be a great tool for thinking it's likely that you will find that some part of the solution is difficult for you to express and that simply suggests that you are probably unable to think about that part clearly so the most more clearly you are able to express your thoughts the easier it will be for you to turn it into code and you will not have to come up with a strategy while you're writing the code so you can focus on coding and focus on avoiding errors and that brings us to the next step implement the solution and then test it using the example input so now you can see how everything comes together we've already know what the function signature looks like what the inputs look like we already have some test cases and through the test cases we've also identified what are the different edge cases we need to handle and we've already written out a description a rough description of what the algorithm looks like and in fact what you can do is you can simply write out comments within your function as the english description then you simply need to fill out code for those comments so for instance here are the five steps that we have just written down create a variable position with the value zero set up a loop check if the element is matches the query if yes the answer is found if not increment the position and then go back and then check if you've reached the end of the array if we have then we return 1 so then the code now is pretty straightforward we create the position variable 0 we set while true so while true kicks off a loop and we just want to first set up a loop and then we can break out of it when we need to then we check if the element at the value position matches the query if it does we return the position if it doesn't so if it doesn't then this we come to this part if it does then we say the function exits and none of this code gets executed but if it doesn't then we increment the position and then we check if we have reached the end now if you have the hdn obviously we don't want to continue so we can simply return minus one and exit the loop and exit the function itself but if it if we have not reached the end then we go back to the top of the loop and now position starts out with value one so we check value zero one two three so on up to the end of the array simple enough great so now we have our first function and let's test our function with the first test case so here's our test case once again and we can simply call locate card with the test input and the test the cards in the query and this is the result we get and you can already see that the result matches the output and that's why when we compare them we get the value true so yeah the results match the output and because this is something that you should be doing very often in this course we have put together a small function for you within the jovian python library so the jovian platform also offers a python helper library that is that contains some utility functions so we've put together a small function for you called evaluate test case and you can write it on your own as well but you can use this library version so let's install the library we will install the jovian library using pip install jovian minus minus upgrade and then from jovian.python dsa so joven is the name of the library and then inside the joven library since we have many courses the python dsa course the utilities for this course are present inside the python dsa module from that module we import the function evaluate test case and finally we can call evaluate test case and then we can give it the function that we want to test so you know test the locate card function and the test case the test case needs to be defined in this format so all it is going to do is it is going to pick out the input pass it into the function get the output compare that output with the expected output and also print some information for you to see so here's what it does it prints out the input it prints out the expected output it prints out the actual output it prints the execution time and this is something that will become important later and it tells you whether the test has passed or not so it's nice to have this you know because so we don't have to look through the output and input and compare them especially when you are in a situation where you need to think fast it's helpful to create a small function that can just print pass or fail for a test case so now while it may seem like we have a working solution because our test case has passed we can't be sure about it until we test the function with all the test cases so for doing that we can use the evaluate test cases function so just as you have evaluated test case you have evaluate test cases also part of the jovian library and you can call evaluate test cases with the same function locate card and this time pass it a list of test cases each of the test cases is a dictionary again you don't have to use this function you can simply put things into a loop so you can always just do for test in tests and then simply call evaluate test with locate card and test or you can even just directly call locate card with the test inputs and the test out and compare the output with the test output right so you can do this as well and you can simply print that so here's a simple way to do this what we are doing here but what we'll do is we'll use the evaluate test cases function because it prints out a lot of useful information for us so now you can see that it prints out case case by case now test k0 we have input expected output actual output the case has test cases passed that's what we saw it in fact it's the same test we just did test case one passes as well test case two passes test is three four five six okay all of them are fine okay test case six seems to have caused an error so here is the error it says list index out of range so that's okay it's perfectly all right for your functions to encounter an error so the first thing the most important thing is not to panic in fact it's a good thing that we know exactly where the function is failing if you look back here you can see what the issue is and then we'll see how to fix the error but one one good strategy to approach this is to keep in mind that there will always be bugs in your code and approach writing code not with the assumption that your code will be correct but go with the default assumption that your code will be wrong that there will be issues what that lets you do is one you do not feel demotivated or you do not panic when you see an error and second you then tend to be a little more careful while actually writing the code so the way you should be writing code is every time you write a line of code you should be asking yourself how can this line of code go wrong or in this particular case how can card's position equals equals query in an if statement go wrong and throw an error and let's look at it one easy way to check this is to add what is called a logging or what is called printing the information inside a function so we'll just rewrite our function in in our locate card function we will put in cards and we will written query the exact same function that we have we'll set the position but before we create the value we'll simply print the cards in the query so just for our information just so that we can see what the function is working through we can get some visibility into the function we print out cards and query and then while true so this is the same loop at the beginning of the loop we will print out the position that we are tracking okay so let's do that we've simply added some print statements and this print statement will give us an insight into the inner working of the function now if you do not put in a print statement then you will have to work it out yourself by reading the code and executing it in your head it's always easier to just print all the all the information and then print it nicely just say cards and query you know we could also have done this without saying cards here but then that would make it a little harder to read then that would be more cognitive overload apart from already dealing with the stress of solving an error right so just add nice pretty print statements to make it very obvious what we are printing so let's see now let us get the test case out so let's get from test 6 get the input get the cards get the query as well and pass it into locate card and now we see that initially the cards array is empty and the query is seven and the position is zero and then we encounter an error we encounter the error list index out of range on the line cards position equals equals query and now at this point it should be fairly obvious what the issue is the issue obviously is that we have an empty list an empty list has no elements but we're trying to access the position 0 which is in normal human conversation the first element of a list but there is no first element to access and that is why we get the error list index out of range so this is very important whenever you get an error do not try to start looking at the code first just try to understand the error first and if you're unable to understand the error just add some print statements there are tools like debuggers that people use but i personally in 15 years haven't used a debugger i maybe used it a couple of times but i don't know how to use it print statements are really simple you just put them in chuck them into the function wherever you need them as many print statements as you need with nice clear messages make it very obvious and that will almost certainly solve the issue for you so the cards area is empty we cannot access position zero so what's the solution here the solution obviously is that before we access anything from a list we need to make sure that we can access that list and this is the way to do it so now we've rewritten our function slightly we once again start out with position 0 but this time instead of putting in a while true instead of assuming that we can access the zeroth element of the list we say that the position should be less than the length of cards now if you have a cards list of n elements the indices go from zero to n minus one or in the case of zero elements there are no indices to access so the position has to be less than the length of cards for you to be able to access it and in this case the length of the cards will be zero so zero is not less than zero so the while loop will not run at all and we will directly return 1 but if the card does have elements then we can check the element at the value position compare it to the query and return the position if it does not if it does not match the query we can increment the position so that was a fairly straightforward fix easy save so let's test the failing case again great so looks like the failing case is now passing because we have output minus one and the expected output matches the actual output of the function minus one because the query does not exist in the array which is empty of course now this is not enough it is every time you make a change to the code you want to go back and test all the test cases because what have what may happen is while fixing one error you may introduce another error and that is where having a good set of test cases is very important so let's run evaluate test cases once again you can see here this time that all the test cases are passing and it's just nice to it just makes you feel good as well makes you feel motivated as well to see that a bunch of test cases are passing now in a real coding assessment or a real interview you can probably skip the step of implementing and testing the brute force solution in the interest of time because it may take about five to ten minutes to implement the solution and then if you have errors in the solution it may take some more time to fix those errors so it's generally quite easy to figure out the complexity which we'll talk about in a second of the brute force solution from the plain english description and that is why you should first state it in plain english which only takes around 20 seconds or so and the computer doesn't throw errors at you for speaking so you can just state the plain english description and move on talk about the complexity and start optimizing it but while you're practicing always always implement the brute force solution too and there's an important reason why you should know how to implement the brute force solution because in case you're not able to figure out the optimal solution to the problem you can still go back and implement the brute force solution and in a lot of cases that's okay sometimes interviewers ask hard questions just to push your boundaries a little bit but if you're unable to figure out the optimal solution then they will allow you to implement a brute force solution so that is why you should state it and that is why you should know how to implement it okay so we are done with so we're done now with the implementation of our brute force or simplest solution and now we need to analyze it and this is where we'll now learn about what is called the complexity of an algorithm what does it mean now recall the statement from the original question alice challenges bob to pick out the card containing the given number by turning over as few cards as possible but right now what we're doing is we can say we're simply turning over cards one by one and before we talk about what does it mean to minimize the number of times we turn over cards or the number of times we access elements we need a way to measure it and let's think about it you know it's it's as simple as just thinking about it since we access the list element once in every iteration so here's the code our code is pretty straightforward and this is where we are accessing an element from the list so since we access the element since we access the element once in every iteration for a list of size n we access the elements from the list up to n times because we may have to access this element and then this element and this element and so on so bob may need to overturn up to n cards in the worst case to find the required card now let's introduce an additional condition that suppose bob is only allowed to overturn one card per minute so that means it may take him 30 minutes to find the required card in the worst case if 30 cards are laid out on the table now is this really the best he can do or is there a way for bob to arrive at the answer by turning over just five cards and save 25 minutes instead of turning over all 30 and this field of study and by the way bob in this case is represented of what our computer does and a computer takes some amount of finite time to perform each instruction so each array access actually takes some time although it's so fast that we do not see it especially for small inputs but this is something that will become increasingly important as we go week over week where we see that we will start to see the limits of how long it takes computers to solve certain problems so the field of study concerned with finding the amount of time or the amount of space or the amount of other resources required to complete the execution of a program is called the analysis of algorithms and the process of figuring out the best algorithm to solve a problem is called algorithm design and that is what we are doing here we are actually doing the analysis of algorithms right now and algorithm design next so there are a couple of terms we need to understand and then we will go back to writing code first thing is complexity and the second thing is the big o notation and both of these are terms that you will hear very frequently in when you're talking about data structures and algorithms when you're talking about coding interviews assessments so these are terms that you need to understand and they're fairly simple terms although the term itself is complexity but all it means is that the complexity of an algorithm is simply a measure some some measure of the amount of time or space required by an algorithm to process an input of a given size example if you have a list of size n then the complexity is the amount of time required or the amount of space required on the ram to process an input of that size now unless otherwise stated the term complexity always refers to worst case complexity so it's possible that the bob turns over the first card and that is the answer but we always talk about what is the longest or the highest possible time or space that may be taken by the program to process an input right so we need to design our programs keeping the worst case in mind now in case of a linear search which is what we've implemented just now the time complexity of the algorithm is some constant c times n assuming n is the size of the list n is the number of cards right so now this constant c obviously depends on the number of operations that we perform in each iteration so in each loop for example we have four to five statements and then the time taken to execute a statement on your specific hardware now if you have a two gigahertz computer that may be twice as fast as a one gigahertz computer if you're running it on a phone it may be different so the c captures all of these things so information about the number of specific operations that we perform in each iteration and information about the actual hardware that you're running on so cn is the time complexity and n is the size of the input so in some sense what we understand from this is that the time complexity is proportional to the size of the input and that's the important part here the constant you know it doesn't change as you change the input the constant doesn't really change now similarly the space complexity now since we are already given an array the additional space that our linear search requires is simply a single constant when we are calling it c prime or c dash and it is independent of n so no matter how many uh no matter how large a list is given to you and the list is already present in memory we just need to allocate one new variable called position and that variable is used to iterate through the array and it occupies a constant space in the computer memory because we keep go on updating the variable right so the space complexity is c or constant it is independent of n now what we do normally is to represent the worst case complexity we often use the big o notation and in the big o notation what we do is we drop any fixed constants and we lower the powers of the and we drop any fixed constants and we drop any lower powers of variables so the idea here is to capture just the trend just the trend of the relationship between the size of the input and the complexity of the algorithm for example if the time complexity of an algorithm is some constant times n cube plus some constant times n square plus some constant time n plus some constant where n is the size of the input in the big o notation we simply say that it is order of n cube which is that you know in the long run in the if you just study the trend it the trend will be some something which looks a little bit like the n cube function and it may be offset by a constant or such so putting it this way the time complexity of linear search is order n because we just drop the constant c and the space complexity is order one so we again drop the constant c prime and we'll see why it's okay to drop the constant sometimes you may find that okay we're not exactly doing n iterations but we're doing n minus one iteration so we drop the minus one sometimes you'll find that we are just doing n by two iterations and that's simply half of n so we drop the half and you might wonder that okay that that might take twice or three times the amount of time how why are we dropping that constant because that's probably an important thing to keep in mind but we'll see we'll see soon as we implement our efficient solution to the problem so before we move forward before we optimize the algorithm we are just going to save our work because this notebook as i mentioned to you is running on an online platform we've set up everything for you you've not had to install anything but because thousands of people are using this using this platform this will shut down this will not keep running forever and what you need to do is you need to save your work from time to time and here is how you can save your work and then pick it up everything happens on the jovian platform there's no need to download anything although you could download it if you want but you there's no need to download anything so all you need to do is use the jobin library once again we've got another helpful function for you so you say import jovian and then run jovian.commit so you run joven.commit and then give it a project name the project name by which you want to identify this specific notebook and then there are some other arguments it's not too important so you can even skip this and that should be perfectly fine so now when you run jobin dot commit we will capture a snapshot of your notebook from this online platform or wherever it is running even if you're running it on your own computer we will capture a snapshot of your notebook from your computer wherever it's running and we will upload it and give you a link where you can access it so let's open up this link here so now you will be able to see this page called python binary search and it will be on your profile and you can see you can scroll down and see that it contains all the explanations and it contains all the code so this is a readonly version of the jupyter notebook so the readonly version of the jupyter notebook obviously does not require us to keep servers running so that you can run this code and when when you need to run it you know your work is saved to whatever extent you have executed things and now when you need to run it you simply click run and then click run on binder once again okay so and that is how you resume your work so what this will do is this will set up a new machine for you and on the new machine it will post the jupyter notebook and it will start up the machine for you open up the jupyter notebook and you will be able to start running the code and not just you now you can make your notebooks public or you can keep them private you have multiple viewership options so you're public and private not just you but anybody else so you can take this link and tweet it out if there's an interesting problem that you worked on you want to tweet it out you can just share this link online and anybody will be able to read through your solution and they can run it as well right in fact the notebook that i have shared with you is hosted on my profile so jovin is not just a platform for you to learn it's also a platform for you to build a repository of projects now if you go back to your profile you click on your profile or click on the jovian logo and you can see here that you will find a notebooks tab and in the notebooks tab you will find all the notebooks that you have worked on in the past okay so anything that you have committed using juventus comment you will be able to resume working on it so that's uh that's how you save your work and keep saving your work from time to time all you need to do is run jobian.comit you do not even need to put in this project argument this is just something if you want to actually give your project a name otherwise the name will be picked automatically so just keep running jovian.com from time to time especially if you're leaving your computer for half an hour or so then and your computer get goes to sleep then this server will shut down and you may lose your work coming back to our problem we've just implemented linear search and we understood that it has the complexity of order n which is and that's why it's called linear it runs in a linear time is another expression that is used it is also called linear because we are going through the array step by step now the next step is to apply the right technique to overcome this efficiency now of course we've not learned any techniques yet but we can probably figure it out if you think about it and maybe this is something that occurred to you right at the beginning and the idea that occurred to you is something that we will now implement so at the moment we are simply going over the cards one by one and not even utilizing the fact that they are sorted and that's why our approach is pretty poor we're basically checking everything so it's not a great solution but it would be great if somehow this would be the this would be the best case if somehow bob realized somehow bob could guess the card at the first attempt that would be perfect then that would be an order one that would be a constant time solution but with all the cards turned over it's simply impossible to guess the right card now the next best idea is to maybe pick a random card so maybe let's say bob picks this card and this card turns out to be a nine now bob can use the fact that the cards are in sorted order so if this card turns out to be nine that means all of these cards have numbers greater than nine and the target card is seven so the target card cannot lie in this region so the target card has to lie in this region and just by picking a random card rather than picking the first card bob has eliminated four out of seven cards to be checked right so with one check bob has eliminated a total of five cards one two three four five and of course if this number turns out to be seven perfect great guess but even if it doesn't we've still eliminated quite a few if this number turns out to be less than seven we've still eliminated three cards so that's the basic idea here that we pick something not from the edges but somewhere in the middle now what is the best place to pick something in the middle now obviously when we are picking a card we do not know whether it is going to be less than or greater than the number that we want especially when everything is close so we it's best to just pick the middle card so that whichever case turns it turns out to be we're still left with ads at most three cards to process right so if you pick this card and it doesn't turn out to be seven you either need to look at these three or you need to look at these three so that is the strategy we'll follow and this technique is called binary search and why do it just once just keep repeating it so each time you pick the middle card and you can eliminate half of the array and this is what the strategy looks like so here we have the array and in the array we want to figure out the number six so the slightly different problem but still decreasing order we want to figure out the number six so we access the middle element okay we compare it with six now it is not six okay it was a bad guess no problem but we know that four is less than six so that means that six lies to the left of four so we've suddenly eliminated half of the array we've done one access and eliminated half of it and now we're left with three numbers we pick the middle number we get seven seven is greater than six that means the number lies on the right now we are left with just one card we overturned that last card or we checked that last number okay it is equal to six great if it is not well nothing more left to check all the numbers here are greater than 6 are less than 6 and all the numbers before this are greater than 6. so if this number isn't 6 then there's no 6. and just like that for an array of seven elements we have done just three checks and arrived at the answer and that was the worst case right it mean it will never take you can verify that it will never take more than three checks if six comes at this position we guess it immediately if six comes at this position or this position we guess it in two checks and then if six comes at any of the other positions we will guess it in three checks so that's pretty good and now the idea if you if you read this part it says apply the right technique to overcome the inefficiency and then repeat the steps three to six so now we're going to go back to step three which was come up with a correct solution for the problem and stated in plain english and we have come up with a solution already we just need to state it so here is how this technique called binary search is applied to the problem it's called binary because well we take a left and right decision so first we find the middle element of the list if it matches the query number then we return the middle position as the answer and if it is less than the queried number then we search the first half of the list and if it's greater than the query number then we search the second half of the list so the exact thing that we saw here we apply it here and finally if no more elements remain we simply return 1 so let's just save our work now let's from this point on we'll keep saving our work from time to time using jovian.commit so now we've come up with the algorithm and you can again it's important to write it in your own words whether you want to write a short description a paragraph or a step by step guide but write it in your own words and you'll do this in the assignment so let's implement the solution now and test it using the example inputs so here's the implementation so what we'll do is we will look at once again let's go back to this visual representation and we will keep a track of our search space so current initially our search space is the entire array so that means we have an array of seven numbers so our search space goes from position zero to position six and slowly we'll keep reducing our search space over time so to keep track of the search space we will create two variables low and high low will have the value 0 which is it will point to the first position in the array and high will have the value pointing to the last position last valid position in the array which is which is len cards minus one so while low and then the while loop becomes very simple because as long as we have at least one element in our search space we can go ahead now to have at least one element in a search space the low value which is the starting index should be less than or equal to the end value right so while low is less than equal to high because if the starting index is higher than the end index basically we've exhausted and we've covered the entire list and there's nothing more that we can search for so we should exit at this point okay so now once we have uh once this condition is satisfied and it is initially let's say you have seven cards lower zero cards is uh len cards minus one is six then you find the middle position and you can get the middle position by doing low plus i divided by two and now let's start applying that strategy here where we say that every time we write a line of code we should think about how it can go wrong now if you write it like this low plus high divided by two and think about how it can go wrong okay low plus high may not be divisible by 2. if low plus is not divisible by 2 you may end up with a decimal number now if you do end up with a decimal number in fact the division operator in python always retains a floating point number then you cannot use it as an array index because we want to use this as a position within the array so that's why we need the double slash which is the which is the integer division which simply returns the quotient so we get the middle position and then we get the number at the middle position so we also get cards made so we access that element from the array now this is where we it makes it easy for us to count the number of times we access because here is one axis happening inside the list and there are no other accesses then we get the mid number and remember last time we faced an error and we had to add print statements you might as well just add print statements right away so here's what you can do we can just print the value of low the value of high the value of mid and the value of mid number what this will do is this will help you check whether the number is working as expect whether the function is working as expected or not so now here comes the actual check and the meat of the problem if the middle number matches the query then we return the middle number great we found it well done now if the middle number is less than the query now remember the elements are in sorted array and we are looking for the number query now the middle number is less than the query so that means the query probably lies to the left of it because the query because the elements are in a decreasing order right so if the query lies to the left of it so then we need to search we decrease the search space from the beginning to the position just before the middle number right so what we can do is we can simply set high to mid minus one on the other hand if mid number is greater than query so that means because of the decreasing order of the array the query lies to the right now we need to move the starting of the search space to beyond the middle number so we simply said low to mid plus one and that's it and you can see that we've written a we've used if lf lf loop here so lf stands for elsif in python and here the last condition could might as well just have been else because there are only three possibilities either they're equal or mid number is less or it's greater but sometimes it's nice to list out all possibilities just to make it super clear and it makes it easy for you while debugging fixing issues as well okay so that's our binary search based algorithm and finally when we exit out of the loop if you have not returned the middle number if you have not exited the function yet then we return 1 that the number was not found so let's test it out using our test cases and we have our handy evaluate test cases function here but you can also test it manually if you want by passing individual test cases but i'll just do this from now on so great so now we have test case 0 this is the input and this is the query and it passed here we have test case 1 this is the input and this is the query and it passed and now because we have these print statements we can clearly look into our test cases and actually tell if the if this is tested correctly or not because now you can see here that we started out with low 0 high 7 and a mid mid value of three so zero one two three we we found the number seven the query is one so we need to check this half of the array and that's exactly what we did we moved low to four and high remained seven then mid number became three so that means once again we need to check this half of the array and then we check this number and then we found the output so now you can see exactly how the algorithm works and this is in general what you want as a programmer you want to have a full understanding of the code that you've written you don't want your code to work incidentally you don't want it to you don't want to be in a position where you are just fixing things trying out different things and somehow at once the code works you want to be in complete control you want to know that these this is exactly what the code is doing and if it is failing why it is failing so we go to test case two three four five six uh looks good looks like we may have solved everything ah probably not so test case eight seems to have failed so test case eight is this number this list and this list contains repeating numbers and not just repeating numbers but the query itself occurs multiple times and now if we look here and maybe let's go go down and evaluate just a test case separately so here we are now using the singular version of the evaluate function so if you look here you can see you have eight eight six six a bunch of sixes then three two two zero the query is six so we start out with a low of zero higher fourteen total of fifteen elements that gives you a middle position of seven and the mid number at that position so let's count one zero one two three four five six seven okay and the mid number at that position is six great uh six is also the query so that's why our function returns seven but remember that we had decided that our function should return the first position of the number within the array so a function is failing that condition and why is that happening because unlike linear search where we start from the left and so we'll always bump into the first position because of the decreasing order of elements so we'll hit we'll encounter this six before we encounter this six binary search does not access elements in an order it access elements sort of randomly there's still a strategy but it goes left and right and it also depends on the values of specific elements whether this element is accessed before this element can depend on the value of let's say this element right so as such it's kind of a pseudo random kind of order and so we need an additional condition condition to keep track of it right so how do we fix it so the way to fix it is actually quite simple when we find that the middle position in a particular range is equal to the query we simply need to check whether it is the first occurrence of the query in the list or not that is whether the number come that comes before it is it equal to query or not if the number that comes before the middle element is also equal to query then obviously the middle element is not the first occurrence so that simply means that we can go back and because it can occur multiple times before that simply means that we can go we can now search the left half on the other hand if the middle element if the number before the middle element is not equal to query and obviously because it is a sorted list it will be greater than query then all the numbers here are going to be greater than the query and you know the the and and so this must be the first or the only position okay so make sure you understand that this must be the first or the only position where the query occurs so once again to make it easier what we will do is because there is some logic involved here what we'll do is we'll define a helper function called test location and this is a very helpful thing that you can do every time you find that okay you have to you have to cover these special cases and your function may start to get slightly longer and slightly more complicated what you may want to do is create a helper function and a good rule of thumb is not to have functions that are more than 10 lines of code or so i try to keep my functions below seven lines of code because seven eight lines is approximately the amount of information that you can hold in your head at once so if a function is about seven eight lines you can probably take a quick glance and tell what it's doing identify issues but anywhere beyond that it's very hard and if you're writing functions that are going into hundreds of lines please stop doing that please start breaking your code into small functions there's a there's a code by i forget who it is by but he's a creator of i think it's eric meyer he created the rx library for reactive programming and he said that great programmers write baby code which is really small bits of code that anybody can understand with a single look so you should be writing as many functions as many small pieces of code small pieces of logic as possible so let's see our test location function its purpose is to take the query and then take just a specific position so forget about binary search for now just take a specific position and tell if that position is the answer and how do we do that we first get the mid number from the cards so we get a mid number from cards so we then we print out mid and we print out mid number and then we compare the mid number with the query so this is the special case that we need to handle this is where we had the error now what we need to check is if the element before the mid number is also equal to query so if the element before the mid number is also equal to query then we need to go left so just to make it super clear what we'll do is instead of setting high low etc we'll simply say that we need to go left so we'll return the the actual string left but one thing to keep in mind here because once again whenever you're accessing an array you need to make sure that the index is valid so we simply check that mid minus one should be greater than or equal to zero that we made is not this position and which can happen as your search space decreases for example if this is your search space your mid will actually be this position so if it is equal to if the number before the mid number is equal to query then we return left otherwise we return found once again making it very obvious that we have found the number so we return found else the other case is if the mid number is less than query that means that the query lies on the left because of the decreasing order of the list so once again we need to search on the left else it returns right so a test location simply tells us whether we found the solution or we need to look on the left or we need to look on the right now in sometimes you will see programs especially in c plus plus java return something like minus 1 0 and 1 and then use that to represent whether you should go left and right but python is a high level language and strings are a first class things are first class feature of the language so just use strings because they are really descriptive they make your code readable somebody else reading your code will be able to understand now if you're looking at minus one plus one etc that is going to be difficult for people to understand so now we can now simplify a locate card function once again we have our low high len cards minus one uh zero and len cart minus one the while loop is the same and we print low and high as well so we are planting row and high inside the locate card function and then we are printing mid and mid number inside the test location function wherever is the right place to print something you print it then we get the mid position and now we simply call test location so we are testing if mid is the answer and if it is not the answer should we go left or should we go right now that makes it really simple because now we get this result and we check this result and if it says found then we return mid that's the answer if it says left then we return mid minus one and then we simply move high to mid minus one and if it returns right then we simply set low to mid plus one so we are simply changing the start position of the search space to after the middle element and here we are changing the end position of the search space to before the middle element right so this makes it extremely obvious and it's really hard to go wrong when you write code like this especially so when you have and binary search problems are specially tricky because they always have certain these special cases that you need to handle and if you start handling them within this if loop so now you have a while loop inside which you have an if loop inside which you have another another if statement and it can get pretty tricky and difficult to debug so let's evaluate that test case and looks like that test case has passed this time perfectly you can go through the logs here to verify it let's evaluate the test case all the test cases as well we should do this every time we change the function and that is why it's helpful to have a function where you can every time you make a change you can just run the test and on a coding platform like elite code or hacker rank you will be given some test cases although those test cases will not be visible to you so you can submit your solution but you may not get an actual result you may not get to know what the test case was or where your answer was wrong and that's where you may want to create your own test cases if you're getting a lot of errors and in fact once you've written out the algorithm you may realize that okay maybe you need to add more test cases what if the number lies in the first half of the array what if the number lies in the second half of the rate so this was not an important factor when we were not thinking about binary search but now that we are thinking in this direction of splitting the array into half we may want to add some test cases where the number lies exactly in the middle in the left in the right and the simplest way to do that is now go back to the tests array so you can open you can create a new cell here by pressing the character b so if you click outside and press the character b you can create a new cell and then you can simply do tests dot append and then write your test case so here is the final code for the algorithm without without the print statements so we have test location and then we have locate card and try creating a few more test cases to test your algorithm more extensively and once again at every step we are going to save our work by running jobin.commit so now we are down to analyzing the algorithms complexity and identifying inefficiencies if there are any now you may have just read online you can actually look it up say just search for complexity of binary search and you will read and you will find an answer but and and you may even just say that in interviews but it's always nice to just come up with that answer from first principles it's always nice especially in an interview if you can talk through it if you can talk through why it is order why it is whatever it is and we'll see what that is so now let's once again try to count the number of iterations in the algorithm because we need to minimize the number of times we access elements from the array and to do that we know that in each iteration we are accessing the element just once and then we are comparing it so we're doing a bunch of other operations but in each iteration we're accessing one element so we need to count just the number of iterations the number of times the while loop was executed now if we start out with an array of n elements then each time each time the size of the array reduces to half for the next iteration now that's roughly true because when you come when you check the middle element and then you decide whether to go left or right it's actually probably n by 2 minus 1 if n is if n is even and if n is odd it is the floor of n by two but again with algorithms with complexities we are generally interested in studying the trend so we can ignore that small part in the calculation so let's say uh the important part is that even if it's okay to overestimate a little bit but try not to underestimate so after the first iteration we may be left with the search space of size n by two it may be slightly less than that but it's okay to overestimate so we have n so we after n we have after the first iteration we we are left with the search space of n by two then we split it into half again so next time we may be left with a search space of n by four which is n divided by 2 square and then we may be left by we may be left with n by 8 and it's possible that at any of these iterations we may just exit because we may have found the right number but what we always try to analyze is the worst case complexity of an algorithm what is the longest possible amount of time or the largest amount of space it can take so right now we are talking about time because we are counting iterations and each iteration takes some time so n by 8 after iteration 3 that's 2 to the power 3 and i think then you can start to see the trend here that after the kth iteration you will end up with n divided by 2 to the power k elements now when does the iteration stop so the final iteration is on an array of length 1 and that is when we access that last element and check whether after all this checking the last element is equal to the index or not so we can do n divided by 2 to the power k and if we set that to 1 we can rearrange the terms and we get back n equals 2 to the power k so after the kth iteration if you want to be left with one element then that means n divided by 2 to the k should be equal to 1 or n should be 2 to the k or in other words k should be equal to log log n remember logarithms and here obviously log refers to log to the base 2 but what i will argue is that you can change the base of the logarithm and that will simply add a constant so that will simply if you're taking the natural log then that will simply add a constant here and remember when we talk about time complexity we ignore constants so we can just generally say that our algorithm binary search has the time complexity of order of log n that means as the input grows the amount of time taken by binary search is proportional to the logarithm of the number of elements in the list passed to it or the amount of time taken is logarithm to the size of the initial search space and you can verify this you can verify that the space complex you can you can check this out by simply writing it out as well you can take some examples let's say you take a card list of size 10 and then work through it the worst case and count how many iterations you have and compare if that is close to login or not and then as an exercise you can verify that the space complexity of binary search is order one can you you can try posting in the youtube comments or in the youtube live chat how the space complexity of binary search is order one i'll let that steam so let's now compare linear search with binary search how are the two different and what we'll do is we will create a large test case because you start to see the benefits of the difference between the order n algorithm and the order login algorithm only when you have larger test cases because small test cases everything runs instantly so it's not really that much of a hassle so here we have a locate card linear and this is the linear version of the algorithm where we simply go through each of the cards one by one and then we have a really large test case here so we have the input and then we have the cards which goes in the range okay let's see so that's one two three so that's thousand another three that's million so we have 10 million elements here so we have 10 million elements and we are looking and so we are actually creating a range here so we are using a function in python so we are creating a list of numbers going down from 10 million all the way to one so a decreasing list going from 10 million to one and this is how you create it and you can check it out and in this list we are looking for the number two which occurs at the very end so we are sort of creating this is as we will see if you want to really analyze it this is going to be a worst case scenario both for linear search and for binary search approximately worst case so the query is two and then the output is this is the output that we expect obviously because 0 to nine nine nine nine nine nine nine is are the array indices and the last element is one so the element just before is two so this is the expected output great so now we have this large test let us call evaluate test case and let us pass a check the linear search pass in the last test and because this is a huge list we may want to turn off the display of the output we may not not want to actually see the input being displayed so we can simply turn off the display by passing display equals false and we can just get back the result from the evaluate test case function so the result will give the output the actual output of the function whether the test passed and the running time of the algorithm so it takes a second so it looks like the test did pass our algorithm is correct so that's great and it took one two two four point two nine one milliseconds or about 1.2 seconds to answer it and you can probably tell why because it because this is the result so it probably took nine nine nine nine nine nine eight iterations so it had to go through all the elements to get to the very end on the other hand when we talk about binary search so now we are passing in the binary search version once again turning display to false and we are displaying the output okay so this time the result is the same the test did pass but the execution time is 0.019 milliseconds so that's 55 000 times faster than the linear search version and in fact you can tell how many elements we actually had to access so if we just check log of so log of this number is about seven and maybe you know if you're checking log two we can maybe check something like this so not more than twenty elements had to be accessed so where we linear search needed to access about 10 million elements binary search was able to get to the answer with just about 20 checks so that's a lot of time saved and you can increase the size of the array by a factor of 10 and increase this by a factor of 10 as well and then you will see far bigger difference where for a 10 times larger array linear search would run for 10 times longer whereas binary search would only require three additional operations so the linear search would go from 10 million operations to 100 million operations binary search would go from 20 operations to 23 and that is the real difference between the complexities order n and order login and as the size of as the size of the arrays grows bigger another way to look at it is that if you just divide the complexities binary search runs n by login times faster than linear search for some fixed constant because there's always some constraints involved and as the size of the input grows larger the difference only gets bigger the difference in performance and that is what algorithm analysis of algorithms and optimization of algorithms is all about it's about overcoming the limitations of computers by devising clever techniques to solve problems and it's something that you can actually apply in real life as well in a lot of cases there are a lot of things that you may see a brute force solution to but if you just apply your mind you may find a more optimal solution a more easy way or a more lazy way to do it with less work so think about that and here is a graph showing how the comp how you can compare common functions how the how the running times of common functions vary so we will look at all kinds of functions we look at constant time functions order one for example accessing an element from an array is order one so even if you have an element of 10 a list of 10 million elements you can access the last element in constant time on the other hand we've looked at binary search which has which is order log n and we've also looked at linear search which is order n now in the future we will look at other techniques which have complexities of n square n cube n to the power n are far far higher and somewhere in between there is a very nice special type of complexity called n log n which is rather nice so we'll talk about that as well n login in fact a lot of questions in coding assessments and coding interviews tend to be taking algorithms which would be which would have n square complexity in in a brute force approach and optimizing them either to order n or to order n log n so we'll we'll discuss all of this so don't worry if this doesn't make sense just yet but i hope you see now why we ignore constants and lower order terms while expressing the complexity of the bigo notation so we've covered binary search but we've seen it in the context of a problem and now we can step away one more step and abstract it out further and identify the general strategy behind binary search and this general strategy is actually applicable to a wide variety of problems and this is what you want to keep doing as a programmer you need to abstract away peel away the layers of specific problem specific details and find the general technique find the general strategy and then encode that using your functions and programs so here's the general strategy come up with a condition to determine whether the answer lies before after or at a given position so we are assuming here that we have some kind of a range and we have to identify a position within a range or maybe an element within that range but we can access elements using the position so come up with a condition that that first tells you whether given a position the answer lies at or before or after that position once you have that condition first retrieve the midpoint and the middle element of the list now if the middle element or the midpoint is the answer then return the middle position that is the answer you're done if the answer lies before it repeat the search so repeat the process with the first half of the list or the first half of the search space and if the answer lies after it repeat the search with the second half of the search space so here is the generic algorithm for binary search implemented in python and you can see a classic detailed documentation here so while so here you have the binary search is going to take a search space low and high so low is going to be zero and high is going to be well we will pass in maybe the final we will pass it may be the final position the final index of the array but writing it this way rather than passing passing an array also allows you to use binary search for problems that are not based on arrays sometimes these could just be numbers for example if i ask you to find a number between 1 million and 10 million that is a perfect square then you can use binary search to do that then it takes a condition so what it does is it starts a loop so while low less than equals high we get the midpoint so low plus high divided by 2 that gives us a midpoint then remember earlier we had this condition test location so our condition simply is supposed to take the middle position and identify if the middle position is the answer or we need to go left or right so the condition should return either found left or right so if the condition returns found we return the midpoint as the answer if the condition returns left we return the high we we move to the left side so which is we take the end of the search space and set it to before the midpoint so we set high equal to mid minus one and if the condition returns right which is the else case here we set low to mid plus one so we take the start point of the search space and move it after the element then we return minus one so that's your binary generic binary search algorithm and if you start using this what will happen is now this is a tested piece of code and in fact we can see it here now now we can rewrite locate card and locate card can be we are passing in cards and we are passing in the query and we need to write a condition and here we're using a very interesting feature of python we are writing a function inside a function so this is called function closure and it's a very handy feature so now we can simply write condition inside locate card and what that does is binary search is going to pass the middle value the middle position but condition can also access cards and query so which is because it lies inside locate so what we do inside condition is okay we check them we get the middle element cards made if cards made is equal to query then here we have that check we check whether it is the first occurrence of query or can query occur before it if query occurs before it we return left else we return found and then these are the original conditions that we already had so you can verify this by going back and checking but the important part here is now the while loop has gone away now we can simply call binary search with zero len cards minus one so the start index the end index and the condition and we can evaluate the test cases and you can see that the test cases are correct and now you can use this binary search function because we have not tested it with one problem you can use this exact same function to solve other problems too in some sense it is a tested piece of logic so here's what we'll do we'll take a quick question and we will implement it now we've spent what one and a half hour talking about a particular problem but let's spend maybe two minutes talking about a new problem and solving it so now here's a slightly related question given an array of integers sorted in increasing order find the starting and ending position of a given number so once again you have a sorted array this time they are increasing the only difference is now apart from the fact that they are sorted in increasing order the other difference is that we are looking for both the start index and the end index so we're looking for both the start index and the end index of a particular number because the number can repeat like we saw one example and there's a very simple way to solve this a simple strategy is do binary search once to find the first position and that's what this function does i'll let you read through it the only changes here are this variable this has changed this order because now the now the elements are in increasing order and then the second change and there's no other change here so that there's just one change here and then there is another function called last position here instead of checking the left we are checking the right so instead of checking mid minus 1 we are checking mid plus 1 and if mid plus 1 equals the target we go to the right and of course we have the same change here in this code because instead of decreasing we have increasing order right so now we write two position now we write two functions first position last position and then first and last position is simply getting the first position once so that's one binary search and getting the last position once that's two binary searches and that's not bad now the complexity is still order login two times login or two times some constant times login when you express it in the big o notation is still login so that's okay and that was quick we were able to reuse most of the code that we have written and that's the benef benefit of making generic functions like binary search and in fact we can test a solution by making a submission here so let's go to leadcode.com let us here what i've done is i have already copied over the binary search function the first position function and the last position function so by the way lead code is a great platform for practicing so you can go to leadcode.com sign up with any account and you will find a lot of problems especially on the in the problems tab and here you can see that this is exactly the problem that we have been solving just now so we just post the code here binary search first position last position first and last position and lead code requires you to write this class called solution this is something that they give you beforehand and inside the solution you need to define a function called search range where we are simply calling our first and last position here i'll let you see and we simply we can test this code with a test case so you can pass a test case here and test it out great or we can simply submit it and here you can see that the problem was submitted successfully and it tells you things like how much runtime it used what was the memory it used and your solution was accepted right so check out leadcode.com go to the problem section and you can see all the different problems that they have you can also explore and you have different problems that come up every day it's a great place to practice so that's binary search for you but i just want to revisit the method once again so this is the systematic strategy that we've applied for solving the problem we state the problem clearly and we identify the input and the output formats this this shows that you've understood the problem you know what the solution will look like then come up with some example inputs and outputs and try to cover all the edge cases so this shows that you are envisioning what are the different inputs that can come in before you write code then you come up with the correct solution not necessarily the most efficient one and state it in plain english now when you try to state it you will have to clarify it and that will help you clarify your own thoughts and then you can analyze the algorithms complexity and you can implement the solution and test it using example inputs so this is the basic solution now in interviews and in coding assessments maybe you know where there is a time limit you may not want to implement the brute force brute force solution because then you may get stuck in fixing issues with brute force and you can directly jump ahead to step five but while you're practicing always implement brute force then step five analyze the algorithms complexity and most of the time it is simply a matter of counting the number of iterations how many times a while loop or maybe a loop within a loop is getting executed and identify inefficiencies and if it is a brute force solution it's generally quite easy to see the inefficiency for example in this case the inefficiency was that we know that the array is sorted that anything we do will be better than going line by line right we could pick a random element and that would help us eliminate a good chunk of the array so that is the inefficiency and then apply the right technique and we are learning the techniques so we've learned binary search today and then we are going to learn a lot more techniques that are asked in interviews so apply the right technique to overcome the inefficiency and repeat steps three to six which is go back and come up with the correct solution with the optimized technique implement the solution and test it using some example inputs and then analyze that algorithm's complexity and identify any inefficiencies so what we've done for you is we have created a template so you can see this python problem solving template and how you can use this template is to simply run it so you run the code you run this template and then when you run the template inside it you will see this question mark in a bunch of places so you can give it a nice project name and you can commit it to your profile one way you can save a copy over this template to your profile is by clicking the duplicate button now if you click the duplicate button you can copy it in your profile and you don't have to look for it you can just find it on your jovian profile but anyway once you have it copied you can click the run button and then click run on binder and run run the template then you go down once you run it and you can copy over a problem statement you can copy over a link to the problem so that when you need to make a submission you can go back and refer and then here the method is summarized for you and here we have created sections for you so you can simply start filling out this method step one step two step three step four step five so whenever you're faced with a difficult problem just use this template and i guarantee it one if you work through this course you will be able to solve a majority of the problems that you come across and specifically even if you are able to follow maybe about 30 to 40 percent of this course you will easily be able to solve most questions that are asked in interviews because questions asked in interviews are fairly simple in terms of the data structures or algorithms they test but the intention there is more to test your approach look at the quality of your code and see how clearly you're expressing yourself right and this is what this is exactly what this method teaches you to do now to encourage you to do this to encourage you to try it out and you can take problems from places like lead code uh code chef code forces there are a few links listed here you can see practice problems there are a bunch of links listed here so that was today's lesson for the next lesson common data structures in python so this is data structures and algorithms in python an online certification course brought to you by jovian thank you hello and welcome to data structures and algorithms in python this is an online certification course being offered by jovian today we're looking at assignment one binary search practice so let's get started first thing we'll do is go to the course website pythondsa.com on the course website you can enroll for the course and view all the previous lectures and assignments for assignment 1 you may want to review the video and notebook for lesson 1. let's open up assignment one it's called binary search practice now in this assignment you will apply and practice the concepts that we covered in the first lesson so you will understand and solve a system solve a problem systematically implement linear search and analyze it and optimize the solution using binary search and ask questions and help others on the forum let's open up the starter notebook for the assignment which contains that problem statement and other information now this is a notebook you're looking at hosted on jovian you can see some description here and if you scroll down below you can also see some code and you will need to execute this notebook modify the code with within it and record a new version which you can then submit to see your score so let's start reading through it as you go through the notebook you will find three question marks in certain places to complete the assignment you have to replace the question marks with appropriate values expressions or statements to ensure that the notebook runs properly end to end now keep in mind that you need to run all the cells otherwise you may get errors like name error or undefined variables you should not be changing any variable names or deleting any cells or disturb any existing code you can add new code cells or new statements but do not redefine or do not change some of the existing variables you will be using a temporary online service for code execution and we'll see how to use it in a moment so keep saving your work by running jobin.com at regular intervals and then the question marks optional will not be considered for evaluation although we recommend doing them they are for your learning but you can make a submission before you have solved the optional questions now you can make a submission back on the assignment notebook page and we'll see how to do that and if you're stuck you can ask for help on the community forum it's listed here and we'll see how to do that as well now one final thing i want to mention is you can get help with errors or ask for hints you can even share your code and errors that you are getting in the code but please don't ask or share the full working answer code on the forum this is so that everybody has the opportunity to work through the problem statement on their own make mistakes learn from their own mistakes and arrive at the right solution now how do you run this code the recommended way to run this code is by clicking the run button at the top of the page and selecting run on binder but you can also run it using some other options like google collab or kagger or you can run it on your computer locally so we're going to use the recommended method run on binder now we have the notebook running in front of us the first thing i like to do is go to kernel and click restart and clear output so that we can see all the outputs of the notebook from scratch and i'm also going to toggle the header and the toolbar so that we can zoom in a bit so now the same jupyter notebook is now running online on a platform called binder and before starting the assignment let's save a snapshot of the assignment to our jovian profile so that we can access it later and continue our work i'm going to run pip install jovian this is going to install the jovian library then run import jovian to import the library and set a project name here i'm just calling it binary search assignment and run jovian.commit now you have taken a starter notebook which was hosted on my profile and then you've run it on binder where as soon as you run jovian.comit a copy of the starter notebook gets saved to your profile so what you will see here is a link to a notebook hosted on your jovian profile let's open it up here and see so now this is your personal copy of the assignment notebook any changes that you make here and run jovian.comit will get added to your profile so if you want to come back and continue your work then you do not have to go back to the original starter notebook which contains all blanks rather you can come back to your profile and you can come to your profile simply by opening jobin.ai and on your profile you can go to the notebooks tab and on the notebooks tab you will be able to find as you can see here you will be able to find the binary search assignment here there you go this is the binary search assignment that we just created and you can open it and run it on binder to continue your work so moving along this is the problem we're looking at here you are given a list of numbers obtained by rotating a sorted list an unknown number of times okay so we have two new terms here rotating a sorted list and don't worry if you don't know what that means normally if you see any new terms in a problem they will be explained somewhere within the problem itself for instance here you can see that there's a definition we define rotating a list as removing the last element of the list and adding it before the first element for instance rotating the number the list three two four one leads to removal of the last number and then placing it at the very beginning so you end up with the list one three two four this is a new operation that we are defining this is not something standard but you will find that a lot of problems will define new terms or new operations so that they it becomes easier for you to understand the problem so that's rotating a list now rotating a list once produces one three two four now if you rotate that list again the resulting list one more time then you will end up with four one three two and so on and then the other term is sorted so sorted refers to a list where the elements are arranged in increasing order in this case we have numbers and the numbers 1 3 5 7 are increased arranged in increasing order so this is a sorted list but if this was 3 2 4 1 well that's not the numbers are not arranged in increasing order so that's not a sorted list so you are given a list of numbers update obtained by rotating a sorted list an unknown number of times for instance this sorted list 0 2 3 4 5 6 9 is rotated a certain number of times and you can verify that if you rotate this three times you end up with the list five six nine zero two three four right you can see that first nine comes to the beginning then six comes comes to the beginning and then five comes to the beginning so you need to write a function and you're given just this the list you're not given the original sorted list you're given the list obtained by rotating some sorted list and unknown number of times now you need to write a function to determine the minimum number of times the original sorted list was rotated to obtain the given list your function should have the worst case complexity of order log n where n is the length of the list and you can assume that all the numbers in the list are unique okay so three parts write a function to determine the minimum number of times you need to rotate the original sorted list in this in this case it is three the function should have the worst case complexity of log n so this determines correctness and this determines efficiency and then this is some additional information to help you that you can assume all the numbers in the list are unique if this was not mentioned you would also have to handle the case where your list does not contain unique numbers now we will apply the method that we have been applying all throughout this course for solving the problems number one state the problem clearly identify the input and output formats number two come up with some example inputs and outputs and try to cover all the edge cases number three come up with a correct solution for the problem and state it in plain english number four implement the solution and test it using some example inputs and having test cases and then implementing a solution allows you to test them using the example inputs and fix any bugs that's why it's very important to have some test cases number five analyze the algorithm's complexity and identify any inefficiencies and number six apply the right technique to overcome the inefficiency and then you go back and repeat steps three to six come up with the correct solution implement the solution and test it and analyze the algorithm's complexity and you can review lesson one for a detailed explanation of this method now let's apply it step by step the first step is to state the problem clearly and identify the input and output formats now while it is stated clearly enough it always helps to express it in your own words in the way that it makes it most clear for you and this is something that you can keep returning to rather than the original problem statement because this is something that you will understand better and it's okay if your problem overlaps with the original problem statement but do try to express it in your own words so in this case what i've just done is i have double clicked here once you double click you can now edit this text cell and now we can start writing a problem so let's say given a rotated list we need to find the number of times it was rotated and okay i think what i've probably missed here is that it is a sorted list so given a sorted list that was rotated some unknown number of times we need to find the number of times it was rotated right maybe i'm just going to say given a rotated sorted list because technically the input is not a sorted list it's a rotated sorted list so given a rotated short test list that was rotated an unknown number of times we need to find the number of times it was rotated now doing this exercise helps you determine if you've understood the problem correctly and you may often find that okay there's a certain detail in the problem that you missed okay but at this point i'm happy with my description and you will see that it is matching the description to a large extent but it's something that i understand better so i'll just refer to this from this point now i'm assuming here that i know what rotation and sorted means otherwise i could also include those then here's a question the function will you will write will take one input called nums what does it represent and give an example okay so once again we double click on this and one input is nums so this is a sorted rotated list and let's give an example here let's say we take the sorted list three five six seven nine and then we rotate it a few times let's say we rotate it a couple of times so we end up with this sorted rotated list so that's our input so we've answered the question here now the first question was to express the problem in your own words this is the solution the second question was what does the input norms represent give an example it represents a sorted rotated list 79356 the third question is the function you will write will return a single output called rotations what does that represent well you have to write a function that identifies how many times the list was rotated so this is the number of times the sorted list was rotated okay and in this case the example that we have is that this sorted list was rotated twice three five six seven nine was rotated two times so you mentioned two here now you can see these back quotes that i'm using here this is next to the number one on your keyboard or below the escape key what these backwards let you do is they let you express text as code within markdown you can see that they have a gray background and they have a different font this looks a lot more like code same is here true for nums so you can use markdown and its features to your advantage to organize your descriptions and your text better okay so now based on the above we can now create a signature of our functions we have a function called counts rotations it takes the num list of numbers and it returns well right now we're just putting pass in here but we know that it's going to return a single number rotations now after each step remember to save your notebook so we are going to just run joven dot commit and now if you leave your computer you do not have to be worried that your work may be lost so you can go in here and you can open up this notebook from your joven profile and press run at any point to run this notebook now step two is to come up with some example inputs and outputs and try to cover all the edge cases and our function should be able to handle any set of valid inputs so here is some variations that you can encounter a list of size 10 rotated three times a list of size eight rotated five times so these are two generic examples and then a list that wasn't rotated at all a list that was rotated just once a list that was rotated n minus 1 times where n is the size of the list a list that was rotated n times and what do you mean by rotating the list n times well let's see an empty list and a list containing just one element and if you can think of more test cases you should definitely add more test cases here and what we'll do is we will express our test cases as dictionaries so this will help us organize the test cases and test them all at once more easily using helper functions so you can see here that we've organized one test case here and we've expressed the task as a dictionary so here we have the input to the test case that is the input key and then we have the output to the test case now because a function can take many arguments the input itself is going to be a dictionary and then for each argument in this case there's just one so we just call it nums we have the input here and this is the size of the output okay so let's create this test case and let us then if you want to fetch the actual input and output out of it so here we can fetch test input nums that's going to give us the nums we can use test input the output should be test outputs this seems to be an error and the result is count rotations num0 okay so this is the actual result obtained by passing the test case into count rotations and you can see that the result we get back is none because right now we do not have any code we it just says pass inside and the result and the output are not equal because the output is the number three but the result is none so that's okay our test case is failing right now because we have not yet implemented the function but as soon as we implement it we expect to see the test case passing now to help you avoid all of this work we have given you a function called evaluate test case so from jovian.python dsa you can just import evaluate test case and then call evaluate test case with the function you want to test and the actual test case and you can see here it prints the out input that was passed in the expected output the actual output that was obtained and the test result in this case the test result was failed and the execution time is also printed here if you just want to evaluate if a certain implementation is faster than another so now your job is to create test cases for each of the scenarios listed above so here is test zero that is same as the original test case that we had created now here is test one a size a list of size eight rotated five times i will let you create this but it will look something like this you will open up you'll replace the three question marks with let's say a list of size eight so one two three four five six seven eight and you can imagine that if this was rotated five times then one two three four five four five of these numbers will then move to the first position and you get this as the input numbers and the output well it was rotated five times so i think you can guess that the output here should be five now here is a list that wasn't rotated at all what should be the output here i'm sure you can guess that the output here should be zero so i'll let you fill this out here is a list that was rotated just once so let's try let's fill out this one so this this list rotated once would give us seven three five there you go a list that was rotated n minus one times where n is the size of the list okay i'll let you do that a list that was rotated n times where n is the size of the list okay what does that look like so you take this list and then you first put 10 in the first position and then you put 9 in the first position so 9 10 comes to the beginning and 3 5 7 8 comes after it then you move 8 to the first position then you move 7 then you move five then you move three if you if you move all of these back to the first position you end up with the same list so you've rotated it n times now what should be the output in this case there are about six numbers here so is the output 6 i don't know i'm not so sure because remember the question the original question says write a function to determine the minimum number of times the original sorted list was rotated to obtain the given list so it has to be the minimum number of times we may want to just go back and change this we need to find not the number of times it was rotated but the minimum number of times it was rotated or it needs to be rotated right so coming back here the output should be not six but zero so keep that in mind then here's an empty list i'll let you figure out what should be the nums and the output here and here is a list containing just one element once again should be pretty straightforward can you rotate a list with one element i'll let you decide and then we're taking all the tests and putting them into a single list now since i have not defined all the tests i am not going to use this definition which contains all the tests but i'm just going to pick the number of tests that i have defined so we have defined here test 0 test 1 test 3 test 5 i'm just going to put in test 0 test 1 test 3 and test 5 and that's the full set of tests that we have you definitely need to fill out all the test cases and if you can think of some other cases that you should be testing then you should include those test cases here as well okay now to evaluate your function against all the test cases together you can use the evaluate test cases helper function from jovian so there are two functions evaluate test case works with a single test case and evaluate test cases works with a list of test cases so we have a list of test cases here i have four but you should have about eight at least and a few more if you have created them so we can import from juvenile python dsa evaluate test cases and then invoke evaluate test cases with the count rotations function still it we don't have any logic in the function so all the test cases should pass and the list of test cases we've created so you can see test cases zero fails one fails two fails three fails so out of the four test cases none of them have passed no problem we have completed step two which is to create some test cases and we'll know once we've defined a function whether the function definition is correct now the next step is to come up with a correct solution for the problem and state it in plain english and there's a hint here for you already coming up with the correct solution is quite easy and it's based on this simple insight if a list of sorted numbers is rotated k times so you keep rotating it step by step moving the last number to the first position then the smallest number in the list ends up at position key and you can verify this it's very simple to do this whenever you have a doubt just create a new cell by the way you can create a new cell by clicking on the left side of a cell and clicking insert cell below or if you're in a code cell just click here near the prompt and press the b character and that adds a new cell below so let's take the list 1 3 5 7 5 6 7 and let's rotate it k times let's try with k equals 2 so if you set k equal to 2 then you're going to take two of these numbers from the very end and move them to the beginning so that means zero comes at position six comes at position zero seven comes at position one and the starting element in the sorted list now comes at position two that's interesting let's move the third element as well okay so now we've moved three elements or rotated the list three times and the smallest element ends up at position three so it seems to hold true and you can verify this now with a larger list smaller list empty list and all the test cases that you have but if a list was sorted k times sorted list was rotated k times then the smallest number in the list ends up at position k counting from zero further it is the only number in the list which is smaller than the number before it and you can see this once again the smallest number is at position 3 and all of these numbers are higher than the numbers that come before them except the number 1 which is smaller than 7. so we simply need to check for each number in the list whether it is smaller than the number that comes before it if there is a number before it then our answer is simply which is the number of rotations is simply the position of this number right so if you can find the position of the number which is smaller than the number that comes before it the position of the number is also equal to the number of times the sorted list was rotated and if we cannot find such a number then the list wasn't rotated at all and that's it you can see here in this list now applying this logic 3 is the number the smallest number and not only that 3 is the only number which is lower than the number that precedes it the predecessor which is 29 and since 3 occurs at position 4 well actually three occurs at position three zero one two three the list was rotated exactly three times now we can use the linear search algorithm as a first attempt to solve this problem in the linear search simply involves working through this list walking through this list from the left to the right so now the task for use to describe the linear search solution in your own words and please write it in your own words but here's how i'm going to write it let's say create a variable position with values zero so this is the position for tracking this is for tracking the position then look at the number at the given position and not only look at it but compare the number at the let's say the current position to the number before it now if you're starting position with the value 0 maybe we may not there's no number before it so we may not be able to compare it with something we may even just start with the value one that's all right if the number is smaller than its predecessor then return position because position is the answer we found the number that is smaller than its predecessor there's only one such number otherwise increment position and repeat till we exhaust all the numbers okay simple now you can add more steps if your description of the algorithm requires more steps that's perfectly all right but at this point we have a very clear description of the solution now we're starting with the position 1 not 0 because we also want to track the previous position now we import jovian here and commit our project once again and keep saving your work after every step so that you can continue your work so now we're talking about implementing the solution and testing it so let's implement the solution we said that we want to start with position we want to start with position one and while when should the loop be terminated well while position is less than the length of nums i guess that's fair and then what is the success criteria so we have if position greater than zero and nums of position less than numbers of position minus one okay so that's the success criteria here now you can see that there's a condition if position greater than zero here so we don't really need to start position at zero we can start position at we don't really need to start position at one we can start position at zero as well and all that will happen is this condition will get skipped and position will get incremented and this is a good practice because whenever you iterate over a list you normally just want to start with 0 just to avoid any confusion later when you're reading the code that did you intend to write 0 here a 1 etc etc so just put in position equal 0 here and simply skip the check here or simply skip this comparison if position is not valid right so whenever you're accessing an element from inside a list or inside a dictionary you always want to make sure that that index or that key is valid okay here we are making sure that the key position minus 1 is valid by checking position greater than zero in any case we now have the logic and finally we are saying that if the number at position is less than the number that comes before it then we return that and that's just going to if it's not then it's going to increment the position and it's going to check again and again and again till we run out of numbers now if you've exa exhausted the entire list then it follows that there were no rotations or there were n rotations exactly in either case the number we returned should be zero okay so keep this in mind the sum you may have the doubt should you be returning 1 here or should you be returning 0 here well the question does specify clearly that you are given a sorted rotated list and you have to find the number of times it was rotated now obviously minus 1 rotations are not possible so minus 1 would not be a valid return value from your function and this is the reason we write test cases too now let's evaluate the test case so let's call evaluate test case for a single test case on count rotations linear and let's see what the test case is this is the test case here and this is the output we call evaluate test case with count rotations linear and test and that gives us a linear search result you can see here this was the number the list of numbers this was the expected output and this was the actual output so grade our function seems to have passed the test case now we can evaluate all the test cases by calling count rotations linear on all the test cases together and give that gives us a whole list of test results test case 0 and 1 and 2 and 3 all of them have passed now if you had put n minus 1 here you would see that one of the test cases would fail which is the case where the list wasn't rotated at all or was rotated n times so that should tell you that the answer here should be zero so that's our linear search algorithm and at this point you may face issues you may feel stuck you may not be able to figure out how to write the code and that's perfectly all right that's part of learning you may face errors you may face exceptions for instance if you did not have this check here position greater than zero or maybe you what you had here was some other condition like position less than equals position plus one and that's okay then you can go to the forum and post your issue so let's open up the forum here this is the forum discussion for assignment one and you can go into the original topic here which is a longer discussion so this is where everybody is posting small issues so you can see that there's about 321 messages that have been posted you can start looking through this forum you can start reading through some of the posts you can even search if you press ctrl f and you can even search for questions here now if you want to post your own question scroll down to the very end or you can just click this button here and click reply okay and mention your question here i have a an issue should i return 1 or 0 in the case the list has not been rotated okay maybe that's and if you want if you have code that's not working or there's an error you can also include a screenshot of your code or i'll show you another trick you can actually include let's say you commit your notebook so let me come up here i've committed my notebook and if you have a particular line of code that you want to share you can actually click copy cell link and paste it here so that will give a link to the entire cell and if somebody clicks on the link then they can view that specific cell of the notebook directly let's see you can see here that it brings us directly to this specific cell there's another option you can even click on embed cell okay for embed for secret notebooks we do not allow embedding but copying the cell link should work and then click reply and your question will be posted and somebody will reply to your question just come back to the forum in a few hours or maybe the next day and you should see an answer you will also receive an email so that's the discussion topic you can also go back to the topic here the category here and create a new question you can see that if you want to start your own thread if you think your question deserves a deeper discussion where multiple people can reply you can also create a new thread by clicking new topic okay so keep this in mind and do make use of the forum what we've seen is people who are active on the forum are at least four to five times more likely to complete the course and earn the certificate of accomplishment and continue working on these topics after the course as well okay so the next step is to analyze the algorithms complexity and the way to do this if you've seen lesson one is to simply count the number of iterations the number of executions of the while loop now if you have a list of numbers of size n then you can see here that this is the key loop here while position less than the num length of numbers so then there will be n loops or n iterations and then inside each each iteration we're performing certain comparisons and returning things so all of these are in effect constant time and based on this you can probably tell that the complexity of linear search is order of n so you can just put in a big o and in the big o notation this would be order n so that's the first part of the assignment linear search now the next step is to apply the right technique to overcome the inefficiency and that's where you can now you can now read through the rest of the assignment now the idea here is this binary search is the technique we'll apply and the key question we need to answer in binary search is given the middle element can you decide if it is the answer which means if it is let's say the smallest number in the list or whether the answer lies to the left or the right of it okay so given the middle given if the middle element is smaller than its predecessor then it is the answer we already know that because there's only one number in the list that is smaller than its predecessor so you can see here for example now if the middle element was 1 which it's not but suppose the middle element was 1 and you can see that 1 is smaller than 8 then we know that 1 is the answer so the position of the middle element is the answer however if it isn't then we need a way to determine whether the answer lies to the left of the middle element or to the right of it and consider these examples so here you can see that the middle element is 3 and the answer is the position 2 so in this case the answer or the smallest element lies to the left on the other hand in this case you can see the middle element is 4 and the smallest element minus 1 lies to the right of it so now you need to apply your mind and think of a check that will help you determine if the middle element given the middle element if the answer lies to the left or the right of it right and we're looking for the smallest element remember so the logic here if you just spend a couple of minutes you will come up with this quite easily if the middle element of the list is smaller than the last last element of the list okay or the last element of the range that we are currently looking at that means that all the numbers here are in increasing order so then the answer lies to the left of it on the other hand if the middle element of the list is larger than the last element of the range that means that because we know that the list is a rotated sorted list so that means that the numbers increase up to a point and then there's a decrease and then they continue increasing that's the only way in which the final element can be smaller so that means the answer lies to the right of it so that's the logic here for binary search and now what you have to do is describe the binary search solution in your own words so here once again you have these four five lines it's very important that you do this because if you cannot express it then coding it is also going to be difficult for you so always do this exercise of expressing the solution in your own words when you're practicing when you're solving a coding challenge or something even in an interview it's also very important because the first thing you need to do is to communicate to the interviewer your thought process and how you're thinking about the problem so the first thing you need to do is describe a simple solution in your in simple words and then they may or may not ask you to code that solution and then the next thing is to identify the complexity or identify the inefficiency then the next step for you is to describe the optimal solution or the binary search solution in your own words okay now if you don't describe the solution in your own words and you start writing the code they may not be able to follow your code so even if you've written mostly correct code maybe with one or two edge cases wrong they may still have a feeling that you don't know what you're writing but if you explain the solution clearly to them they will know that now you understand the solution and they will be able to follow the code as you write it and they will be able to pick up mistakes or errors and help you with the errors one secret is that interviews are always open to helping you unless you make them really confused so keep that in mind and describe the solution in your words once you do that you can commit now the next step is to implement the solution now the implement the binary search solution as described in the previous step let's run this again so you run count rotations define the function count rotations binary now you may want to review lesson one here on how to start it out you'll see that low starts out at zero and high starts out at length nums minus 1 and i will not solve the rest of this but there is a certain condition here between low and high so in binary search we are starting with the entire list as the range then we are looking at the mid number so we're getting the first the mid position and we look at the number at the mid position then we check if the middle position is the answer so if the middle person is the answer we return the middle position then we check if the answer lies in the left half so here's a condition where you decide if the answer lies in the left half and we once if the condition holds true all we do is we change the high so which we change the end point of the range to mid minus one and then we check if the answer lies in the right half in that case we change the starting point of the range to mid plus one and the while loop repeats okay so that's the general logic of binary search and one thing you have to keep in mind is if none of the elements satisfy the criteria that you have what is the answer and this is a very important condition this is where it is very easy to go wrong it is also called the edge case or the trivial case so you should handle and think about this carefully and then once you've done that you can evaluate the test case and you can a single test case you can evaluate multiple test cases now if your test cases are failing you may want to enable this print statement inside by uncommenting it but make sure to comment it out at the end once again and the print statement will help you see what the low high and mid points were now you may want to then take a pen and paper look at an example that is failing and see if the printed numbers match what you expect to see debugging your function is a very important skill so keep that in mind and use a debugging technique like this by adding print statements and working out the same problem side by side on paper to fix your issues otherwise you may feel lost if you're not able to look into the internal workings of the function next you have to analyze the algorithms complexity and identify inefficiencies this should be straightforward enough we've already looked at the complexity of binary search but all you need to do is make sure that what you're doing within the algorithm matches the analysis that we've done earlier so the problem size reduces by half each time and then we are doing constant work in each step before solving a problem of half the size so that should roughly give you an answer and keep committing your work now finally to make a submission you have two options now one option is to take this link so your notebook has been committed here and you can come to the assignment page let's open up the assignment page binary search practice come down here and paste this link here and click submit now once you click submit the assignment will be submitted and it will go into automated evaluation so in about a couple of minutes maybe up to an hour depending on the queue of submissions from different participants you will receive a grade over email let's just refresh the page and it seems like there was an issue here the issue was that count rotations binary was not defined so it's possible that this happened contradictions binary did not get defined because there are a bunch of question marks here so we may need to then fix the issue and then come back and make a submission once again okay so i have received failed grade i will go back and i will fix the issue and then come back okay now it's very important for you that's why to have good asset good set of test cases for you to test your function so that when you submit it or when you get an error you can maybe look at your functions performance on the test cases and fix anything that needs to be fixed and add new test cases if you need to now one other way you can submit is by simply running the code by joven dot submit assignment equals python dsa hyphen assignment 1 the code is mentioned here you can see here that the submission was made and you can verify your submission on this page ok so that's assignment1 so what should you do next review the lecture video if you need to and execute the jupyter notebook you may need to keep you may want to keep the jupyter notebook running side by side as you're working on the assignment then complete the assignment and even attempt the optional questions if you scroll down here on the assignment notebook you will find that there are some optional questions for you here's one bonus question use the generic binary search algorithm so inside the python dsa module in jovian there is a function called binary search you can use the generic binary search example then here's an optional bonus question two handle repeating numbers we did say that you can assume that there are no repeating numbers in the list but here's one list with repeating numbers can you modify your solution to handle the special case and then here's an optional bonus question three about searching in a rotated list so you're given a rotated list now instead of finding the number of times it was rotated you you're trying to find the position of a certain number for instance the position of six can you apply binary search and modify your previous solution slightly to search within the rotated list and find the position of a given number now here's a hint you can simply identify two sorted subarrays within the given array and perform a binary search on each subarray using so to identify the two sorted subarrays you can use the count rotations binary function so that's one potential solution another way is to modify the counter rotations binary function to solve the problem directly so it's a very interesting problem to solve and if you found the assignment easy then you should definitely solve these bonus questions and if you can solve this question by yourself without taking additional help then you can solve pretty much any problem related to binary search that may be asked in an interview because most of the questions are some variations of something like this and this is pretty much the hardest problem you may get asked you can also test your solution by making a submission on lead code and this is only for the final optional question and there's a thread on the forum where you can discuss the bonus questions separately as well so do make use of the forum thread too here it is optional bonus questions discussion so that was assignment one of data structures and algorithms this is called binary search practice hello and welcome to data structures and algorithms in python this is an online certification course by jovian my name is akash and i am the ceo and cofounder of jovian you can earn a certificate of accomplishment for this course by completing four weekly assignments and doing a course project today we are on lesson two of six now if you open up pythondsa.com you will end up on this course website where you will be able to find all the information for the course you can view the previous lessons which is lesson one and uh you can also work on the previous assignment which is assignment one and you can also check out the course community forum where you can get help and have discussions so let's open up lesson two this is a lesson page here you will be able to see the video for this lesson you can watch live or you can watch a recording here and you can also see a version of this video lecture in hindi and in this lesson we'll explore the use cases of binary search trees and develop a stepbystep implementation from scratch solving many common interview questions along the way so here is the code that we are going to use in this lesson all the different notebooks containing the code are listed here and let's open up the first one so here you can see all the explanations and the code for this lesson this is binary search trees traversals and balancing in python and this is the second notebook in the course you can check out the first notebook in lesson one and if you're just joining us this is a beginner friendly course and you do not need a lot of background in programming with a little bit of understanding of python and a little bit of high school mathematics you should be able to follow along just fine if you do not know these then you can follow these tutorials to learn the prerequisites in just about an hour or two now the best way to learn the material that we are covering in this course is to actually run the code and experiment with it yourself so to run the code and you can see here if we scroll down you can see that there is some code here on this page as well now to run the code you have two options you can either run it using an online programming platform or you can run it on your computer locally so to run this code we will scroll up and click on the run button and then click run on binder and this is going to start executing the code that we were just looking at so once again you can go on the course page pythondsa.com open up lesson2 and you can watch the video there and on lesson 2 you can open up the link to the code where you can read the code and the explanations here and if you want to run the code just click the run button and that will execute the code for you so once you click the run button on binder you should be able to see an interface like this this is the jupyter notebook interface the same explanations that we were seeing on the lesson page you can see here the same explanations are now available here but the difference is you can now edit these explanations and you can go down and you can actually run some of the code in this tutorial you can see here that you have a run button and when you click the run button that is going to run the code in this particular cell and this is a jupyter notebook made up of cells now we'll do a couple of things here the first thing we'll do is we click on kernel and click on restart and clear output what this will do is this will clear all the outputs of the code cell so that we can execute them ourselves and then i'm just going to zoom in here and hide the interface so that we can look at the explanations and the code so finally we have some running code and in this notebook we will focus on solving this specific problem and this is a common question a question of this sort can be asked in interviews so this is an interview question but along the way we will also learn how to build binary trees and binary search trees and how to apply them to several other questions so here's the question as a senior backend engineer at jovin you are tasked with developing a fast inmemory data structure to manage profile information which is username name and email for 100 million users it should allow the following operations to be performed efficiently you should be able to insert the profile information for a new user find the profile information for a user given their username and then update the profile information of a user once again given their username and list all the users of the platform sorted by username and you can assume here that usernames are unique so this is a very realistic problem that you might face if you're working at a company where you have a lot of users so let's see how we solve this problem now here's a systematic strategy that we'll apply for solving problems not just here but throughout this course this first step is state the problem clearly and in abstract terms and then identify the input and output formats then come up with some example inputs and outputs to test any future implementations and try to cover all the edge cases and then come up with a simple correct solution for the problem it doesn't have to be efficient it just has to be correct and stated in plain english and then implement the solution and test it using some example inputs fix bugs if you face any and finally analyze the algorithms complexity and identify inefficiencies if any now once you identify inefficiencies then we apply the right technique and that's where data structures and algorithms comes into picture so we apply the right technique to overcome the inefficiency and then we go back to step three so come up with a new correct solution which is also efficient state it in plain english implement it and then analyze the complexity now if you follow this process you should be able to solve any programming problem or interview question so step one we state the problem clearly and we identify the input and output formats now we can reduce the problem to a very simple single line statement we need to create a data structure which can efficiently store 100 million records and we should be able to perform insertion search update and list operations all of them as efficient as possible now the input the key input to our data structure the solution that we are building is going to be user profiles which contains username name and email of a user now before we come up with a solution we need a way to represent user profiles and a python class would be a great way to represent the information for a user so you may have heard of the term objectoriented programming and that is what we're going to look at now if you're not familiar with the class it's very simple a class is simply a blueprint for creating objects and what's an object well everything in python is an object whether you're looking at a number a dictionary a list anything and you can create your own custom objects with custom properties and custom methods by creating your own custom classes so here's the simplest possible class in python with nothing inside it we're creating a class user so this is how you declare a class and then when putting nothing inside it so whenever you put nothing inside a function or a class or anything you can put you need to put the pass statement because python cannot accept empty blocks of code so here we're creating a class which does not have anything inside it and we can create an object or it's often called instantiation which is take creating an instance of a class instantiate an object of the class by calling it like a function so we say user1 is user so this creates an object and the variable user1 points to that object now we can verify that the object is off the class user by simply printing it or by checking its type user1 and typeuser1 are both user now the object user one does not contain any useful information so let's add what's called a constructor method so constructor method is used to construct an object to store some attributes and properties so now we're defining the class user once again but inside it we're defining this function and you can see that this function is inside the class because there is some indentation here so we define this function underscore underscore init and it takes four arguments now the first argument is a special argument called self and we'll talk about this and then we have three arguments username name and email and inside in it what we're doing is we're setting self.username so we're setting a property on self to username we're setting a property on self to name and we're setting a property on self to email and finally we're printing user created so let's see let's create another user user2 and you can see that user 2 is also an object of the class user now here's what happening conceptually when we do this the first thing that happens is when you invoke this function when you invoke user as a function python first creates an empty object of the class user and then stores it in the variable user too and then python invokes the init function and to the init function it passes user to the object that was just created as self and then the other arguments that were passed while creating the object as the rest of the arguments so you can imagine that we are basically doing we are basically calling user dot underscore underscore init the function with user to an empty object and these arguments john johndoe and jondo.com and then inside the init function we simply set these properties on user two so now we get user two dot username is john user two dot name is john doe and user two dot email is johndoejohneddo.com so that's basically how classes work in python and that's why you always have this additional extra argument in all class methods which will refer to the object that finally gets created okay so once user two is created with the values john john doe and john doe dot com you can check that user two dot name is john doe and user two dot email is john doe dot com and user two dot username is john now you can also define some custom methods in inside a class so obviously we had the init method but here we are also defining another method called introduce yourself now introduce yourself takes again two arguments the first argument is self which will refer to the actual object that gets created later and then we have a guest name and we basically say hi guest name i am such and such contact me at such and such so these blanks are filled in using the guest name self.name and self.email okay so that's how you define a method in a class so here we have another user we're creating jane and jane doe at janetddo.com and you can see here that when we call introduce yourself with david so user3 which is jane becomes self and then david becomes guest name and that's why we get hi david i am jane doe contact me at geneto.com so that's a quick refresher on classes in python now there's a lot more to classes but the simplest thing you need to know is you how to define a class how to create a constructor which is underscore underscore init how to set some properties like we said the properties name email and username and finally how to define methods like we defined the method introduce yourself and that's all we will need today so we won't need much more than that and one final thing that we're doing with our class is we're defining two other special functions underscore underscore repr wrapper and underscore underscore str so now these two functions these two functions are used to create a string representation of the object and you can see here once we create an object user4 now and if we try to print user four you can see that 4 is now printed like this so user 3 was not printed i mean user 3 was printed just as a user but with user 4 we have all this information printed here as well so now here's an exercise for you which also brings us to the first quiz of the day now we are going to do three quizzes in this video and you can answer these quizzes on linkedin so go to our linkedin profile if you see the posts you will see a new post here which will give you a question and the question is what is the purpose of defining the functions str and wrapper within a class and how are these two functions different now leave a comment with your answer and we will pick the right answer one right answer and one lucky winner will get a swag back from us so that was the input we have we now have a way to represent users by creating classes and then the output that we want the final output that we want to create for our problem is a data structure so a data structure is once again something that we can define using a class so we can define we can expect our final output to be a class called user database which has four methods insert find update and list all and insert takes a user and inserts it into the database find takes a username and returns the user update takes a user and updates the data for that user and finally list all returns a list of the users so this is what the class will look like and we have not implemented it yet but we now have an interface so now the next step is to come up with some example inputs and outputs so let's create some sample user profiles that we can use to test our functions once we implement them so we're going to create these seven user profiles you can see that we're creating these seven user profiles with a username name and an email and storing them in these variables using the user class that we have just defined earlier and we're also going to store the list of users in this variable called users and as you can see we can access different fields within a user profile using the dot notation so you can check biraj dot username is bharaj and biraj dot email is biraj example dot com and biraj dot name is bhiraj now you can also view a string representation of the user as we have seen so if we print the user you can see some information about the user and here is the full list of users that we have created so it's always a good idea to set up some input data set up some test inputs that you can use to test with your implementation later on and since we haven't implemented our data structure yet it's not possible to list any sample outputs but you can try to come up with some different scenarios to test any future implementations so let's let's list some scenarios for testing the methods of our user database class so the methods are insert find update and list all and for inserting you may want to test that you're inserting a user into an empty database of users so that's what's called an edge case and then the general case is to insert a user into the database assuming that the user already does not exist then another edge case is trying to insert a user with a username that already exists right so these are all the different ways in which you can use the insert function and there can be some more so here's an exercise for you try coming up with all the different scenarios in which you would like to test the different functions insert find update and list so that completes step two now we have some sample inputs and then we have some scenarios in which you we are going to finally test our function so the next step is to come up with a simple correct solution and then state it in plain english now here's a simple and easy solution to the problem we simply store the user objects in a list sorted by usernames that's simple enough and suppose we do that so inside our data structure we have a list which simply contains a bunch of user objects then the various functions can be implemented like this so you have the insert function the insert function simply requires looping through the list and then adding the new user at a position that keeps the list sorted so for instance if you have the users akash and siddhant already and then you're inserting the user biraj then you can tell that bharat should go between akash and hemanth in alphabetical order so that's how you insert a new user and maintain the sorted property of the list then to find a user we simply loop through the list and then find the user object with the username matching the query so that's you if you're looking for heman for instance you start from the beginning you go through akash biraj and finally hit him and then you can retrieve the user object associated with hemanth and then you have update now updating is very simple as well it's similar to find so you find the user object matching the query and then update the details of that user object and then finally because our internal representation is already a list of user objects sorted by usernames so we can simply return that list when we want to list the users so that's our plain english description and it's always a good idea to describe your solution in plain english so that you can clarify any doubts you have and even during interviews it's a good idea to have a conversation with the interviewer before you actually implement the solution and now one fact that we can use is that usernames which are strings can be compared using the less than greater than or equal to operators so we can compare strings just like numbers in python so that will make it easy for us to implement these functions and that brings us to the implementation and the code for implementing these is also fairly straightforward so now we have the user database class we are actually implementing this class and here you see that we have a constructor and the constructor does not take any additional arguments apart from self and all we do is inside self we set a property.users and that property.users is set to an empty list then we come to insertion so now assume that we already have some users in our user database so we start out with a pointer set to zero and we go through all the valid positions in the users list so which is from 0 to n minus 1 if there are n users and then we find the first username greater than the new user's username so for instance if you're inserting a month then you go through akash and bhiraj and then finally you realize that the next value is probably siddhant so you want to insert before siddhant right so you want the first username that's greater than the new user's username and you check this property and as soon as you find the next that the next user is greater than the user that needs to be inserted we break out and then we insert that user at that position okay so this is the insertion you can it's a just four or five lines of code so you can work through this code try to read the score line by line and see how it works now similarly you have the find function the update function and the list function they're all pretty straightforward there's really not much here so this is an exercise for you because this is also the brute force of the simple implementation so this is an exercise for you to go through each of these functions and try it out and use the interactive nature of jupiter to experiment and add print statements inside each of the functions if you need inside each of the loops if you need more visibility into what's happening okay but what we will do is we will try and test this implementation out and the first thing we do is instantiating a new database of users using the user database class so here we say user database and that gives us a database of users and now let's insert some entries into this database so we can now insert for instance we can insert the value hemanth akash and siddhant so here we have inserted three values into the database and now we can retrieve the data for a given user given their username using the find method so now we say database dot find siddhant that returns a user and we can check the value of user and you can see that now we have retrieved the data for siddhant which is username siddhant name siddhant sinha and email siddhant example.com now let's try changing the information for a user so to change the information we can call database dot update and then simply pass in a new user object so let's say we want to change the information from sadhan cena to siddhant u so this is how we do it we call database dot update and now if you find the information once again now if you can't find call database dot find once again we get back a user object and this time with the updated information so we have created the database we have inserted some values into it and then we have retrieved values out of it and we've also updated them and finally we can retrieve a list of the users in alphabetical order so now if we list it out you can see here that we have the username akash we have the username himant and we have siddhant these are the three values that were inserted and they are all in alphabetical order of username now if we insert a new user let's say let we insert barrage we can make sure that bhiraj is inserted into the right position okay so that's how we use the data structure that we just created and you can use the empty cells here to try out the various scenarios when you run the notebook so just to recap we created a simple class inside which we are storing a list of users in sorted order of usernames and then insertion is pretty easy we simply loop through find the right position and insert any new values finding values is very easy as well we simply loop through and keep comparing and updating values is simply a matter of finding them and then updating that specific value and listing is simple because we can simply return the internal list representation that we're already storing in the sorted order of usernames so that's the simplest solution or one of the simplest solutions there can be even simpler solutions maybe so the next step now is to analyze the algorithms complexity and identify any inefficiencies so typically in an interview setting you may not want to implement the simplest solution so you you can actually skip step four you know when you've described what the simplest solution is in english in plain english which was step three you can directly jump to analyzing its complexity and then move on to optimization and implementing the optimized version but when you're practicing or when you're learning it's always a good idea to implement even the brute force solutions so let's analyze the complexity the operations insert find update involve iterating over a list of users and in the worst case they may take up to n iterations to return a result where n is the total number of users now the list all function is slightly different because it simply returns an existing list so the list all function does not take linear time it takes constant time now based on this information it's very easy to check to guess the time complexities of the various operations insert find and update have a order n first case time complexity which means they can take up to n iterations however the list function has an order one complexity which means irrespective of how many users you have in your database it returns the list in the same amount of time now if you want to display the list or if you want to iterate over the list that may take you additional effort but getting the list itself is a constant time operation so that was the time complexity and an exercise for you is to verify that the space complexity of each operation is order one and if you're wondering what we mean by complexity then you can go back and watch lesson one where we talk about analysis of all algorithms complexities and the big o notation what we're calling order of n the big o notation all of these explained in a lot more detail so you can go back to lesson one and check it out now we've created a simple solution and our first question might be to wonder if this is good enough and to get a sense of how long each function might take if there are a hundred million number users on the platform let's create a while loop let's create a for loop and let's run it for let's see how many this is one two three four five six seven eight so let's run it for 10 million 100 million numbers so here we are creating a range of 100 million numbers and we're running a for loop which iterates over the entire range and we're simply performing a simple operation which we're not really using we just we're just multiplying the number by itself to simulate what might happen if we have a database of 100 million users and we're trying to access find a user now what is the worst case scenario here let's run this and you can already see that it is taking a while for 100 million users the loop takes about 10 seconds to complete here it took about 9.45 and a 10 second delay for fetching user profiles will definitely lead to a sub optimal user experience and that may cause users to stop using the platform altogether now imagine you came to joven.ai and it took 10 or 15 seconds to load your profile and then maybe even longer to load the other information and display it you would not be happy with the experience and then a 10 second processing time for each user for each request each profile request will also significantly limit the number of users that can access the platform at a time because if you're running the backend server on one computer which has eight cores then each core will be busy for 10 seconds each time a user tries to access the platform so you can only serve about 8 users in 10 seconds time now that's pretty bad that could significantly limit the number of users you will have a significant outage if a lot of users come to the platform or on the other hand you may have to increase the cloud infrastructure add more servers add bigger hardware more cores more ram and that could increase the cloud infrastructure cost for your company by millions of dollars so as a senior backend engineer you must come up with a more efficient data structure and this is why choosing the right data structure for the requirements at hand is a very important skill now we can clearly see that using a sorted list of users may not be the best data structure to organize the profile information so let's see what better we can do here and before we do that let's save our work so remember that this notebook we were running it on an online platform called binder and binder can shut down at any moment because it is a free service so what you want to do is run pip install jovian and then import the jovian library and you can then run jovian.commit now when you run jovian.commit what this does is this captures a snapshot of your jupyter notebook whether you're running it on binder or you're running it on your own local computer and it saves the snapshot of this jupyter notebook on your jovian profile so here you can see now on my jovian profile i have this notebook and i can go back on my profile and view the other notebooks that i've created in the past so your jovian profile becomes a collection of all the jupyter notebooks that you're working on so always just it takes just a couple of lines import joven and run joven.com so always run your window commit inside your notebooks and if you want to resume any work that you were doing then all you need to do is click on the run button and then click run on binder once again and then you can start executing the code within the jupyter notebook once again right so remember that binder is a free service so it will shut down if after about 10 minutes of inactivity which is if your computer goes to sleep or you change your tab so keep running juvenile.com it from time to time so now we have a simple implementation and we have analyzed it and determined that it is not efficient it is inefficient so now we need to apply the right technique to overcome the inefficiency and we can limit the number of iterations required for common operations like find insert and update by ditching the linear structure that we had earlier and organizing our data in a more treelike structure so this is a structure that we use for our data and we will call this a binary tree now this is called a tree because it vaguely resembles an inverted tree trunk with branches so you can think of this as the root so this has the root and then you can see each of these are like branches and then there are nodes where branches then split into multiple branches so these are called nodes and finally at the end you will have individual nodes which do not have any more branches and those are called leaves so these are some terms that are used the tree represents the entire structure the top node is called the root and each each element in the tree is called a node the top node is called a root and then the bottom most nodes which do not have any sub trees or what are called children which do not have any children are called leaves right so the root node has two children and then each node there with can have zero one or two children so it's not necessary to have exactly two children but up to two children is what determines a binary tree so that's a binary tree but the binary tree that we need will have some additional properties which was what will make it efficient for our purposes so you can see one thing you can observe here is that the root node seems also seems to be the central value if you sort the keys in increasing order so what you will notice is on the left we have keys which have which lie before jades and on the right we have keys which lie after jades so that's one thing and that is actually the second property listed here that the left subtree of any node consists only of nodes which have keys that are lexicographically smaller than the nodes key right so the key for this node is barrage and that is lexicographically smaller than jades and similarly hemant and akash are all smaller than jadish and then this property holds at every node so at every node if you check sunaks you can see that siddhant is less than sunaks and vishal which comes to the right is a more than sunaks and then so not siddhanta vishal all three are greater than jadeesh right so when a binary tree satisfies this property it is called a binary search tree so that's what we're looking at here this is a binary search tree so that's the first property but we need the second property is that our nodes will have both keys and values now sometimes you can create binary node binary trees with just keys each node will have a single number or string inside it and you can call it the key or value or element or whatever you wish but what we want is we want the keys to be user names so that we can compare the keys easily but along with each node we also want to associate a value which is the actual user object so if you're looking for hemath let's say we started the root node we see that jadeish is the root node and since it is a binary search tree we know that he meant lies to the left then we reach biraj we know that himans will lie to the right of biraj so we go right we reach him and then we access the values stored at hemanth which is the user details for hemath right so we need both keys and values in a binary tree and this is what is called a tree map or a map in many languages and then finally this tree that we will create this data structure that we will create it will be balanced so here what we're looking at is each node has two children left and right but it is also possible to have an unbalanced tree where you only have one child on each on on maybe one of the sides so we will require it to be balanced which means that it does not skew too heavily in one direction and we'll talk about what balancing means and we'll talk about how to check if a tree is balanced and how to keep it rebalanced okay so we'll go over all of these things step by step but these are some of the properties that we want our final data structure to have okay so one important property of a tree of a binary tree is the height of a tree in fact if you start counting you can say this is level zero where you have one node and this is level two or this is level one where you have two nodes the left and right the left and right child of the root node and then this is level three level two where you have four nodes the left and right child of the first node on level one and the left and right child of the second node on level one right so you can see that the number of nodes in each level in a balanced binary tree is double of the number of nodes of the previous level so if you have a tree of height k or which which means a tree which has exactly k levels then here's the list of the number of nodes at each level now level zero will have one node the root node level one will have two nodes its children level two will have four nodes their children so that's four nodes is two times two or two to the power two level three will have eight nodes two nodes for each of these four nodes so that's two to the power three and similarly if you keep going down level k minus 1 the final level will have 2 to the power of k minus 1 nodes so that if the total number of nodes in the tree is n then it follows that n is 1 plus 2 plus 2 square plus 2 cubed plus so on plus 2 to k minus 1 okay so what we're trying to determine here is what is the relationship between the height of the tree and the total number of nodes in the tree and this is the relationship and we can simplify it a bit if we add 1 to each side you can see here that this side we get n plus 1 and this side we get 1 plus 1 which gets simplified as 2 or 2 to the power 1 and then we can add 2 to the power 1 by 2 to the power 1 and that gets simplified as 2 to the power of 2 then we can add 2 to the power of 2 and 2 to the power of 2 and that gets simplified to 2 to the power of 3 and we can keep performing this reduction we can keep adding these together till we finally end with 2 to the power k minus 1 plus 2 to the power k minus 1 which is simply 2 to the power of k so what that gives us is that k the height of the tree is log of n plus 1 which is approximately or in almost in every case less than log n plus 1 so that's a a bit of an approximation are doing here but it is uh the height of the tree is less than log n plus one so to store n records we require a balanced binary search tree of height no larger than log n plus one now this is a very useful property in combination with the fact that nodes are arranged in a way that it makes it easy to find a specific key simply by following a path down from the root the binary search tree property and we'll see soon by the end of this lesson that the insert find and update operations in a balanced binary search tree have complexity order of login so in our original implementation a brute force implementation they had order n and this time we've reduced the complexity to order login and that is far better and we will see how that happens okay so that's a quick introduction to binary search trees we have we've had enough theory now let's get into some implementation but before that we have the second question now binary trees are very commonly used as data structures for a variety of different in a variety of different languages for instance java c plus plus python java and c plus plus have this concept of a map which is represented using a binary tree and it is also used in file system so binary trees are also used in file systems to store indexes of files so when you browse your file system or when you search for a specific file it is a binary tree that is used to look up the file and find the location of the file now that's where that brings us to our second question of today now you can you can find the second question on our linkedin profile so once again go to linkedin.com slash school slash jovian ai and you will find the second question here the second question is which tree based data structure is used to store the index in the windows file system and who invented this data structure so like this question follow us and comment with your answer and you can stand the chance to win a swag pack right so we repeat the question which tree based data structure is used to store the index in the windows file system also known as ntfs and who invented this data structure okay so let's get to the implementation of binary trees and here's a very common interview question that you might get implement a binary tree using python and then show its usage with some examples so what we'll do as we implement binary trees and binary search trees is to also cover many common interview questions in fact we'll cover exactly 15 so that's a quite a few the first one is to implement a binary tree and to begin we'll create a very simple binary tree so we will not have any of the special properties like key value pairs and binary search tree and balancing rather and we'll also use key numbers as keys within our nodes because are simpler to work with so here is an example binary tree so we have a root node and then we have a left child in right side and here's a simple class representing this representing a single node within the tree so we're calling this class tree node and it has a constructor function it simply takes a key and it sets self dot key to key it also has a couple of other properties self.left and self.write which are initially set to none so each node when it's created exists independently of other nodes and now let's create nodes representing each of these nodes so we have node 0 we're calling it we're calling tree node with the value three then we have node one and node two so there you go now we've created the nodes and we can verify that it is of the type tree node you can see here and if we check the key of node zero you can see that it has a value three and we can now connect the nodes by setting the dot left and dot right properties of the root node so if you go to node zero and set dot left to node one so now we've connected node zero to node one and similarly if we set node zero dot right to node two now we've connected node zero and node two and that's it we're done so now we have three nodes and then we've connected each of those nodes and we may also just want to track which is the root node so we can create a new variable called tree and simply point it to node zero so tree points to the root node of the tree and then the root node is connected to its children and the children will be connected to their children and so on so you can check here that if we check tree dot key we get three and if we check tree dot left dot key so three is the root node it has a value three tree dot left is this node so it should have the value four and tree dot right dot key should have the value of five okay so pretty straightforward and that's pretty much the answer to the question implement a binary tree in python now going forward we will use the term tree to refer the node root node to refer to the root node and the term node can be used to refer to any node in a tree not necessarily just the root okay so here's an exercise for you try to create this binary tree so now you have a root node here and then you have a left child and right child and then this left child has another left child but does not have a right child similarly here you have another right child and then it has a left child which does not have a left child but has a right child okay so there's a slightly more complicated tree structure and try to use these cells these empty cells that are given here to replicate this tree structure and then try to view the different levels of that tree manually okay now please do that because that's a great exercise in understanding how the structure works and how to connect the nodes but it's a bit inconvenient to create a tree by manually connecting all the nodes in fact here you may have to make a total of one two three four five six seven eight nine connections right so what we can do is we can write a helper function which can convert a tuple and the tuple will have this kind of a structure so a tuple is simply is kind of like a list except that it is represented with these round brackets of parenthesis so a tuple will have this kind of structure it will have three elements and then the middle element will represent the value or the key within the root node the first element will itself also be either a tuple if the left child is is an entire subtree or if it is a single number then it will be just a number and then the right element will represent the right subtree okay so here's an example here is one tree tuple now if you see this tree tuple it has three elements this is the first element this is the second element and then this is the third element so this first element two represents the root node and then this so the second element 2 represents the root node this first element or element at position 0 represents this subtree so you can see here that in this sub tree if you look at just that subtree of that tree 3 is the root in that subtree and then one is the left child and there is no right child so that's what this represent and then for this subtree where 5 is the root node and then you have 2 other subtrees that's represented here so 5 is the root node and then you have a subtree here and a subtree here so this is a very easy way it is a convenient way for us to represent a binary tree and what we can do is we can define a function parse tuple and this parse tuple function can take a tuple like this and then convert it into a tree like structure of linked nodes using the tree node data struct using the tree node class that we have defined above so we call the parse tuple function with some data for instance this tuple and the pass tuple first checks if data is of the type tuple and it has a length three if these two things hold true then first we create a node we create a node with data one so in this case we create a node with two as the key and then we set the left and the right subtrees of the node and then we're doing something very interesting here we are calling the pass tuple function once again so we call parse tuple this time so this is called recursion when a function calls itself inside it that's called recursion so we call parse tuple with the first element which itself is a tuple right so once again that it calls another invocation to pass tuple and for a moment let's assume that that returns the proper subtree the proper node so we set that node which which got created to node.left and similarly we create the right subtree using these values and then we set that node to node.right okay now you might wonder in the function we're calling itself so when will this stop can't it go on forever and that's where you have to track the actual function calls so when we call parse tuple with the entire tuple first it calls past tuple with this and when you call past tuple with this uh then you can see that three is used to create a node and then pass tuple is called with one so when past tuple is called with one this condition no longer holds true and we also check the next condition which is if the data if one is none when one is not none so this condition does not hold true so we fall into the else condition and we simply create a node right so we just create a node and this time we are not calling parse tuple once again right so this is called a terminating condition of the recursive function and similarly once we get back the result from one then we call patch triple with the value none once again this condition is not entered and this condition matches so we set node equal to none and then we return the node okay so when we reach either a leaf node which is either a single number or we reach the value none that is when we stop invoking the function recursively and then the function returns and that's how the entire tree gets con gets converted so this is a very powerful idea in programming the idea of recursion the idea of functions calling themselves and it can seem unintuitive and confusing at first so one thing you can do is you can add a print statement here inside this function to see how it works to see how the different calls are going so when you call past tuple with the entire tuple what are the internal calls that are made and and study how the result comes out maybe try it on pen and paper but it's a very important technique for you to learn you will be asked or you will find applications of recursions in many places throughout your programming or data science career so do learn it so let's now call parse tuple with this tuple as an input and let's see okay so that returned a tree and then that tree is of the type tree node that's great and now let's examine the tree to verify that it was constructed as expected so now we check tree two dot key so tree two dot key should be pointing to the root node which has the key two and then let's check the level one so that was level zero let's check level one so let's check three two dot left dot key and tree two dot right dot key you can see here we get the values three and five let's check the next level on this level we have three two dot left dot left and then we have three two dot left dot right but there's no value there so we can't really check for a key here then we have treated right dot left and tree two dot right dot right so you can see that tree two dot left dot left dot key is one but tree two dot left dot right is none because there is no child here no right child then we have left dot key and right dot key and that gives you three and a seven and similarly you can now check level four level three as well so here are all the levels of the tree so it looks like the tree was constructed properly and you can see the power of recursion at play here that the recursive function can now construct trees of any levels now you can create tuples within tuples within tuples and as long as they have the right structure as long as you have this three element structure where the left element represents a left subtree the right element represents a light right subtree in the middle element represents the current node you can construct a tree of any size so now here's an exercise for you we've defined a function to convert a tuple into a tree define a function now to convert a tree back to a tuple so if you have a binary tree convert return a tuple representing the same tree for instance for the tree created above tree 2 calling tree to tuple should return this original tuple which is used to create the tree and here's a hint on how to do this use recursion so do fill this out and see if you can figure out how to do this so now we have defined a class for a binary tree and we also have a way for creating a binary tree from a tuple so now let's create another helper function to display all the keys of the tree in a tree like structure for easier visualization so here we'll just use we'll call this function display keys and we'll not get into the code for this because it's once again it's a pretty straightforward but there are a few conditions we need to handle but here's what it will give us when we call display keys on a tree so then we'll then we'll get this kind of a representation of a tree and you can see that this is not exactly the same representation as this you will have to take this representation and then mentally rotate it by 90 degrees in the clockwise direction to get a representation like this but you can see roughly that the root node is 2 and then it has a left child 3 and it has a right child 5. then 3 again it has a left child 1 and there is no right child now 5 has a left child 3 and 3 has no left child and 3 has the right child 4 and so on so the exact same structure has been replicated here for us to view visually now this is a very useful thing we're spending all this time here or talking about how to create trees and how to visualize trees because the easier you make it for yourself to create trees the more likely you are to test the easier it is for you to test different scenarios out so always spend a little bit of time coming up with good string representations for any data structure you create something that helps you visualize them and an easy way to create these data structures okay so now we have a way to visualize the tree as well that's great now here's an exercise for you try to create some more trees and visualize them using display keys and you can use this tool excalidraw.com and that's where how that's how these diagrams were created as a digital whiteboard so you can create some trees you can create trees like this and then try to come up with tuples for those trees try to create those trees using the parse tuple function and finally try to display them okay so experiment with it and see explore what are all the different tree structures that you can create now the next one of the frequently asked questions in interviews is to traverse a binary tree binary tree traversals are very common so you may face one of these three questions write a function to perform the in order traversal of a binary tree or write a function to perform the preorder traversal of a binary tree or write a function to perform the postorder traversal of a binary tree what do you mean by a traversal a traversal refers to the process of visiting each node of a tree exactly once now what do you mean by visiting by visiting it could mean any operation but generally it refers to either printing the key or the value at the node or adding the nodes key to a list and then there are three ways to traverse a binary tree and return a list of visited keys so the first one is called inorder traversal and the inorder traversal now traversal is defined recursively because binary trees have this recursive structure so you will see that almost all the functions that we write will have some sort of a recursive structure so in order traversal involves first traversing the left subtree recursively in order then traversing the current node and then traversing the right subtree recursively in order so what does that mean well we start out with this tree and we we're traversing it in doing an inorder traversal so we try we look at the root node and then we realize that there it has a left child so it has a left sub tree so we do not visit it yet which means we do not print it or we do not add it to our list yet rather we follow the we follow the path on the left side and then we come across three and then we realize that okay three also has a left child so we don't visit it yet so then we go down to one we go down to one and now it does not have a left child or a right child so we can visit one then we go to three and now we so we've visited the left subtree of three so now we can visit three and then the next step is to visit the right subtree of 3 but of course 3 does not have a right child so there is no right subtree to visit so we can move back up to 2. so now we have visited the left subtree of 2 so now we can visit 2 so we we print 1 three two and now once we've visited two we can now visit the right subtree of two so to visit the right subtree we go to five once again we realize that five has a left subtree so we go to three now three doesn't have a left subtree so we can visit three then we visit four then now since we visited the left sub tree of five we can now visit five and similarly we then visit six seven and eight okay so that's the in order traversal of the tree and then there is another traversal called preorder traversal which is slightly different where you traverse the current node first so here we start out at 2 and we say that okay we're going to visit 2 first so we visit 2 or print it or add it to a list then we traverse the left subtree and then we traverse the right subtree so we go we visit three and one and then we come to the right side we visit five and three so you can compare these two diagrams and see how in order and preorder traversal are different now these are very important for you for you to understand because they are great examples of dif different functions which have very similar implementations but there are just one or two things you will need to change uh and these are recursive as well so do understand the subtle difference between them and second they are very commonly asked in interviews you will most likely face some coding assignment or an interview where you will be asked to perform a traversal of a binary tree and then finally there's another order called another traversal called the post order traversal and i'll let you guess how it works you can also look it up and here's an implementation of inorder traversal now it may seem a little complicated but it's actually pretty straightforward so let's look at it here what we do is given a node we first traverse the nodes left subtree then we create so that should return a list a list of all the keys and then we create a list with just the nodes key so we get the list of keys from the left subtree in with the inorder traversal then we get add to it the current nodes key and then we call traverse in order with the right subtree and that recursively keeps adding these keys each one and the end condition so the terminating condition for the recursion is when we hit none so when we hit a node which does not exist so that means we come there from a parent which does not have a left or right child then we return the empty array okay so let's try it out with this tree so this is the tree we have and we just saw its traversal now if it travels the tree in order we get the values one three two three four five six seven eight and we can verify here we have one three two three four five six seven eight so that was the inorder traversal of a tree now the exercise for you is to print the preorder and post order traversal of the binary tree and you can test your implementations by making submissions to these problems on leadcode.com okay so that was our discussion about traversals another thing that you may get asked commonly is writing functions to calculate the height or the depth of a binary tree and then writing a function to count the number of nodes in a binary tree once again these can be expressed recursively as well now the height of a tree given a node is simply 1 plus maximum of the height of the right subtree of the left subtree the height of retreat is defined it is defined as the longest path from a root node to a leaf so you can see that the longest path from root node of the to the leaf is of length four so two five three and four and the way to do get the longest length of the longest path is by checking the max of the left height right height and then adding one to it and of course the terminating condition here also is if you hit a node that does not exist you return zero so that's how you get the height of a tree and you can check that the height of a three is four then here's another function to count the number of nodes in a tree once again really simple all you do is this time instead of checking the maximum we simply get the size of the left subtree get the size of the right subtree add them and add one to it so here you can see that there are nine elements in the street three six and nine so we get tree size of tree as nine now here are a few more questions relating to the path lengths in a binary tree so you can just check there's a concept of maximum depth and minimum depth and then there's also the concept of a diameter so you can try out both of these now as a final step what we can do is we can compile all the functions we've written all the methods as methods within the tree node class itself and this technique is called encapsulation where we are encapsulating the data as well as the functionality related with the data of the data structure within the same class and this is real as really good programming practice so as you write more code try to think about how you can create these classes with not just the information inside them but also with the relevant methods inside them okay so we have now added the methods height size traverse and order display keys to tuple and we've also added these methods str and wrapper and remember quiz 1 or you can go on linkedin and post an answer to what these functions do and finally parse tuple as well so all of these functions are now added within the class and you can try it out here so for instance here we have a tree tuple and we can call tree node dot pass tuple to convert this tree tuple into a tree so you can see that now we are also representing the binary tree itself using this tuple like representation but we can also display it in this hierarchical structure using display keys then we can check the height using tree dot height we can check the size using tree dot size and we can traverse the tree in order using traverse in order and we can convert the tree to a tuple using 3.2 tuple so do create some more trees and try out the operations that we've just defined and try or you can also try adding more operations to the tree node class and before continuing we can just save our work so i'm just going to import jovane and run juventus commit so that concludes our discussion on binary trees next let's talk about binary search trees now a binary search tree or a bst is a binary tree that satisfies these two conditions the left subtree of any node should only contain nodes with keys less than the current nodes key and then the right subtree of any node should only contain nodes with keys greater than the current nodes key and we can see that this is let's just copy this over so we can see that this node this tree here is actually a binary search tree and you can verify that these two properties hold for each of these nodes and it should follow from these two conditions that every soft tree of a binary search tree must also be a binary search tree so i can let you verify that that if you pick up any subtree inside so you pick up any node and you see the tree under that node you will see that it is a binary search tree so here are some questions that are often asked relating to binary trees and binary search trees and we've lumped them together because we'll answer them with a single function so here's a function that you might be expected to write so write a function to check if a binary tree is a binary search tree which means ensure that these two conditions hold and second write a function to find the maximum key in a binary tree so this could be a generic question finding the maximum key and here's another question that you might face write a function to find the minimum key in a binary tree so what we will do is we'll answer we'll answer all of these questions together with a single function called is bst so isbst takes a node and then is bst returns three things so if you look at the return value it returns whether the node and the tree under that node is a bst so here so we this is going to be the value determining it's going to be either true or false telling us whether the tree under that node with that node as root is that a bst it also returns the minimum key from that entire tree and it also returns the maximum key from that entire tree now why are these two useful we'll see in just a moment so the way we calculate is bst node is by actually looking at the left subtree and the right subtree recursively so we call is bst on the left subtree of the node and we call isbst on the right subtree of the node so we get back three values which is is the left subtree a binary search tree is the right subtree binary search tree is the minimum key in the left subtree the minimum key in the right subtree and then the maximum key in the left subtree and the maximum key in the right subtree so now what we can do is we can say is is bst node so is the entire tree of binary search tree well if the left sub tree is a binary search tree and the right subtree is a binary search tree and then we verify these two properties which is the maximum key in the left subtree is either none which means that there is no left subtree or the current nodes key is greater than the maximum key and the minimum key in the right subtree the smallest key in the right subtree is either none which means that there is no right subtree or the minimum key in the right subtree is greater than the current nodes key so that this was condition one and condition two and that tells us whether this entire tree is now a binary search tree and then finally we can also calculate the minimum key and maximum key simply by computing the minimum of the left minimum node.key and right minimum and the maximum can be calculated by checking the maximum of the left maximum node dot key and right maximum okay so what we return from the sbst function is whether the node and the tree represented rooted at that node is a binary search tree and then the minimum and maximum key out of it so if we look at this tree right here let's verify whether this is a bst and well before we check we can probably tell that it's not because you can see that 3 appears as a left sub child of 2 but 3 the key is greater than 2 and that's a problem so this is a violation of the property elsewhere this property is satisfied you can check any other node here and you will find that the left subtree is always smaller than the right than the node and the right subtree is larger than the node so let's check is bst tree one it's not so it's false now on the other hand this tree is a bst this is the tree that we've been looking at all this while so once again we can create this using tree node.parse tuple and note that the keys can the way we've implemented tree node keys can not only be numbers but they can also be strings so we don't need to change anything here and that creates tree two and we can even display tree two so if we do tree two dot display keys you can see that it has this structure where jadeesh is at the center and then on the left you have biraj on the right you have sunaks biraj and sanaksh then you have akash siddhant and vishal and this is a bst so you get back true here and the smallest value here is akash and the highest value is vishal as you can verify in alphabetical order so that's pretty handy now we have a way to check if a binary tree is a binary search tree and this is again a very common interview question that you might face next remember that we need to store not just keys but also user objects within each key with each key within our bst so what we do is we will define a new class called bst node to represent the nodes of our binary search tree and bst node will not only have the key but in the constructor it can also accept a value and this is optional so we will set the key and we set the value we will also set the left and right apart from this we also set another property called parent and the parent will point to the parent node so for instance if this node is a left sub tree of this route then the parent of barrage will point to jadeish and this will be useful for upward traversal now if you're given a pointer to a node and you have to go back and find the root of the tree the parent will be helpful there so this is our bst node and let's try to recreate this bst right here with usernames as keys and user objects as values so first we create level 0. so level 0 we create bst node now the key is jaadesh or username which will be just the string jadeesh and then the value will be the jadeish user object so we've created that and we can check its key and value you can see that jadish is the key and then the user object is the value let's create let's create level one now level one is we set tree dot left to bst node barrage dot username and biraj now one other thing that we should do here is once we set it we should set tree dot left dot parent to tree and similarly we said tree dot write it's not tree dot write is sunak so we said bst node with sonar username as the key and sonax is the value and then we can set tree.write.parent as tree and now can you can view these values so now you can see that we have inserted barrage and the username barrage we've inserted sonaax and the user sonar shear as keys and values respectively now the exercise for you two is then try to add the next level of keys and values and then verify that they were inserted properly but you can see now that we now have a way to represent the data the both both the usernames and the user objects in a binary search tree so we're getting pretty close to the data structure that we want to create once again we can display the keys of the tree by calling the display keys function now this is also rather nice is a good thing about python that because python functions are dynamic because you do not need to specify the types of the objects while defining the function the same display keys function can be used both with tree node and bst node classes so all it requires is that the object of your class should have a property dot key for it to be able to display the keys in this visual setting and the same is true with most of the other functions that we've defined in fact any function we've defined for tree node will also work for bst node okay so moving right along now we have a way to construct a bst but it it's a bit inconvenient to insert values manually because what we're doing so far is we are manually checking whether we should insert a value in the left or the right rather there should be a way to do it automatically we should be able to call a function insert and here's this is a common question as well write a function to insert a new node into a binary search stream so we'll use the bst property to perform insertion efficiently once again let's grab a copy of this tree here so that we can think about it easily okay so now we have this tree and let's say we want to insert a new user with the username tanya into this tree so first we start at the root and then we compare the key to be inserted with the current node's t key so the current node is the root so we compare tanya with jades and we see that tanya is greater than jades because t comes after j so obviously tanya should not be inserted into the left sub tree rather than should be inserted into the right subtree so if the key is smaller we recursively insert it into the right left subtree and if the key is larger we recursively insert it into the right subtree so then we encounter sunak tanya is also greater than sonax t is greater than s t comes after s so once again we call recursively called insert on this subtree that subtree rooted at vishal this time we notice that tanya is smaller than vishal so t is less than v so then we need to recursively insert in the left subtree but there is no left subtree here and this is the point at which we can create a new node and attach it as the left child of vishal so you can see that the node tanya will get added here at this position in the tree so here is a recursive implementation of insert exactly what we just discussed first we check if the key is less than the current nodes key and if that is the case then we insert it into the left subtree then we check if the key is greater than the current nodes key and if that is the case we insert it into the right subtree and the ending condition is that if the node is none which means if we've hit a position where we do not have a left subtree and we need to go left or we do not have a right subtrain we need to go right then we create a new node so we create new node node equal to bst node and then we return the node so we return the node and this is an interesting thing that we're doing here we're returning the root node back from insert so when we called insert with node.left we get back the pointer to the left subtree so we can set it back to node.left and we can also set the parent of the left subtree to node okay so this is just updating the parent so just study this function carefully see how it works it does exactly what we just talked about and it finally returns a pointer to the to the tree once again so let's use this to recreate the tree that we had here now to create the first node we can call the insert function with none so initially we don't have a tree to begin with so we just called insert with none and remember that insert after performing an insertion returns the pointer to the tree so we call insert with none and we want to insert the value jaadesh.username and we want to insert the we want to insert the key short username with the value jadesh so that gives us a tree and now the tree has one element you can see tree dot key and tree dot value and now the remaining nodes can just be inserted into tree so now we call insert with tree and call it with barrage dot user name and biraj then we call it with sonar username and sunaks akashad username and akash and this way so we are adding barrage when we are adding sonax then we are adding akash siddhant vishal and see that we are not specifying exactly where these nodes need to be inserted but you can see that once these nodes are inserted then they are inserted in the right places so jadeesh you can see that the binary search tree property is preserved here and also we've exactly replicated the tree structure that we had here so the left subchild of jadeesh is biraj and the right child is sonak for biraj the left child is akash and the right child is hemanth and so on now note however that the order of insertion of nodes can change the structure of the resulting tree so for instance if we insert all the nodes in the increasing order of username so if your for example here we are inserting akash biraj siddhants vishal so this is the lexicographic increasing order and we try to display that tree this is what we end up with so we end up with an unbalanced or a very skewed tree and you can see why it was created as a skewed or unbalanced tree well let's look at it so we started with akash so we have a single node and then when we try to insert bharaj we realized that we need to go right so we insert barrage here then we try to insert hamad then we realize that we need to go right from akash and right from biraj and go to himant and then we keep going this way so how you set up the root node and how you set up each subtree and the order in which you insert the nodes is very important and that can create a huge skew within the tree now skewed or unbalanced trees are problematic because the height of sub such trees is no longer logarithmic compared to the number of nodes in the tree right so earlier we had deduced that in a balanced tree if containing n nodes the height is log n or log n plus one and that makes the operations like insert update and find very efficient but here where you have a very skewed tree the height can actually match the number of nodes for instance this tree has seven nodes and it has a height seven and in these q trees once again you may get back the fact that insertion finding and update can be order n because you may have to traverse the entire height of the tree which is equal to the number of nodes of the tree and that may once again defeat the purpose of using a binary search tree in the first place so maintaining the balance of a binary search tree is very important and we'll see how to do that so we've seen how to insert a node now the next thing is to find the value associated with a given key in a binary search tree so once again we can follow a recursive strategy here similar to insertion so we check we start from the top let's say we want to find the key heyman we start from the top and we compare it with the root node now here if it matches the root node we can simply return this node if it does not then we check whether we need to go left or right since hemanth comes before jadeish we need to go left then we encounter bharaj and here we realize that we need to go right and finally we encounter haiman and we return another option is that we have a value let's say tanya which does not exist here so if we try to search that we may go in this kind of a direction and we end up at an empty place so in that case we simply return none so you either find a node and return it or you return none so you can see here that if we called find tree with hemanth we get back the details for human and very interestingly because it's a balanced tree you we only had to take two steps and not go through the entire tree and in the worst case you can check that any path from the root to any leaf in a balanced tree will only be two steps long and that's what makes it so convenient now on the other hand if we try to find the key tanya you can see that it's not formed try creating larger bsts and try finding some more nodes it's important to experiment with these operations once they're defined because now it's simply a matter of calling the function we've written the code for it so experiment with it try creating larger trees with multiple levels and dozens or maybe hundreds of nodes try generating some fake data putting it into the trees and see how trees build up and that will give you a feel for how binary search trees work next let's talk about updating a value in a bst now updating a value is fairly simple we already have a way of finding a node so if you want to update a node let's say we want to update the node hema the key heimat and here we want to update it we want to update it to this value which is the new value of the user heman and we're changing the name and we're changing the email here so we first find the node and if the node is not none then we simply change the value at that node it's as simple as that and we what we're also seeing is we're reusing the find function here and this is a good practice to always incorporate into your programs into your functions whenever you find yourself copy pasting some code and maybe changing one or two things here and there think about whether you can extract that piece of code into a function and then reuse that function so always try to make your code more and more generic the less code you write the less there are the chances for errors the easier it is to understand and the smaller your functions become so write small reusable generic functions whenever you can and this is a principle called the dry principle or the dry principle which stands for don't repeat yourself whenever you're writing programs so in update we are not repeating ourselves by using the find function to find the right node and simply updating it by setting its value so let's update hemanth here to the new value and you can see that now we have the updated data here so we have payment j and human j at example.com now the value of the node was successfully updated and you can in it and you can easily check that the time complexity of update is same as that of find now finally we have the last operation that was required and this was to write a function to retrieve all the key value pairs stored in a binary search tree in the sorted order of keys is a question that you might face uh once again and this is simply the in order traversal it's a different way of stating the inorder traversal now what you will have to figure out or a reason about is why the inorder traversal of a binary search tree produces a sorted array of our sorted list of keys think about it so here's the list all function all we do here is we call list all on node.left and then we call listall on node.write and in between them then these give us two arrays so we assume that listall.node.left gives us the list of key value pairs from the left subtree in sorted order similarly here we get the list of key value pairs from the right subtree in sorted order and between them we simply insert this key value pair from the current node and recursively it automatically fills out the entire array and this is the end condition where we encounter an empty node we simply return the empty array you can see now when we pass in this tree we get back the list of users key value pairs arranged by the sorted order of keys now here's an exercise for you determine the time complexity and state compliance space complexity of the list all function now you can do this for a balanced tree or an unbalanced tree and here's a hint it will not make a difference but think about it so once again let's save our work and now we've talked about binary trees and operations on binary trees now the next thing is to look at balanced binary trees and this is once again a very common question that gets asked write a function to determine if a binary tree is balanced and here's a recursive strategy to do this in fact this is really the definition of balanced binary trees the left sub tree should be balanced the right subtree should be balanced and the difference between the heights of the left and right subtree should not be more than one okay so this is an important thing now when we're looking for balance we're not always looking for perfect balance because it may not always be possible to create a tree with perfect balance because to have a perfectly balanced tree where for every node the left subtree and the right sort you have the exact same height you will have to fill out all the nodes at all the levels and that can only have that can only happen for certain numbers for example you can have one node which satisfied this property or you can have a tree with three nodes which satisfy this property or you can have a tree with seven nodes which satisfies this property but you may not be able to get a tree with six nodes to satisfy that property for instance if you remove vishal here you will see that the left subtree and right sub tree of this node sonar will not be of equal height that's why for balancing we relax the criteria slightly we simply need to ensure that the difference between the heights of the left and the right subtrees is not more than one so here's the code for is balanced once again pretty straightforward but we will return two things here we will this is balance will not only return whether the tree node is balanced it will also return the height of the tree which is rooted at that node so the way we implement it is first calling is balanced on node.left and then calling is balanced on node.right and by the way this is exactly how we implement recursive functions as well sometimes we write the recursive functions signature then we immediately write the return value and then we assume that a recursive call is going to return these values so a recursive call is balanced node.left is going to return whether the left subtree was balanced and the height of the left sub tree and then we assume that is balanced for node.write is going to recall is going to return whether the right subtree is balanced and the height of the right subtree because that's what we return here then the entire tree is balanced if the left sub tree is balanced and the right subtree is balanced and the absolute value of the differences in their height is less than one which means the height l minus height r is either minus one zero or one and finally we calculate the height of the tree itself which is simply one plus the maximum of the height of the left subtree and the right subtree and we return it so that's how you implement a recursive function or think recursively and there's one last thing which is the end condition and the end condition although it's often the last thing you think about it's the first thing that you have to put in the end condition is to check whether a node is none because as we call node.left you may not have a left subtree so you may call is balanced with none and if the node is none we simply return true because an empty tree is balanced by default because there's no imbalance there and its height is zero so that's our is balanced function it's just four or five lines of code but if you are not able to reason about recursion easily you may get stuck with this and you may spend an entire 45 minutes trying to write this function and debug it so always try to think in recursive terms and that's why always it always helps to write down what you want to do in plain english so that you can determine what should be the inputs and outputs to your function maybe also have some test cases ready and then start implementing your function and it becomes really easy so this tree for instance is balanced here you can check is balanced you get back true but this tree here you're looking at this is not balanced so this was tree two and if you check is balanced here you get back false so here you also get the height of the tree which is three and here you get the height of the tree which is seven now here's another tree is this tree is this tree shown here balanced why or why not now create this tree and check if it's balanced using the is balanced function so there's another concept called complete binary trees which is slightly similar to balanced binary trees but it's a slightly stricter criteria so you can check out this problem here and you simply need to modify the is balance the code for is balanced slightly to get the code for complete binary so do check out this problem on leadcode.com all right so we've looked at binary search trees and we've looked at balanced binary trees now let's bring them both together into balanced binary search trees and here's one question that you will face at some point write a function to create a balanced binary search tree from a sorted list of key value pairs so you have a sorted list of key value pairs so the keys for example could be usernames the values could be the user objects and they are sorted by key and you have a list and you have to create a balanced binary search tree from it and here's the basic logic which is somewhat similar to binary search which is something that we've covered in lesson one do check it out what we can do is we look at the middle element for instance if you have a list of 15 elements then the element at position 7 counting from 0 the element at position 7 is the middle element now we can take the middle element and then create a new binary search tree with the middle element as the root node okay so you take you make the middle element the root node and then you take the left half of the list and use that to create a balanced bst and make it the left child of the middle element the root node and then you take the right half which both of the house will have seven elements each so if you take the right half and you create a balanced bst out of it and then make it the right child of the middle element so that's the idea here and how do you make a balance bst for the left or right child recursion right so once again here's a recursive solution make balance bst takes data which is a list of key value pairs it takes a low and high and it also takes a parent and we look at those now low is set to zero by default and high by default is set to the last index in the data so we use that to get the middle index so for instance if low is 0 and high is 14 the middle index is 7 then we get back the key and the value from the middle index so we calculate we find data made and that gives us the key and the value for exa since the username and the user object then we create the root node so we create the root node using bst node and then we call make balanced bst on data but this time from low to mid minus one so from the indices zero to six and make that the left child of the road and we called make balance bst on the right node so on the right half so from mid plus 1 so which is index 8 to 14 and we make this the right subtree and then we return the root and that's it that's pretty much it the only thing that we might need here is the terminating condition when low becomes less than high which means that we have no more elements to create trees out of we simply return none so the left or right subtree for those for the parents of those nodes get set to none so that's your makes balance bst function we also have this other thing called parent going around and this i will let you figure out what the parent does here but this is the basic idea so here is a list of key value pairs you have a key value pair sorted in increasing in the increasing or lexicographic order of keys and we're calling make balance bst with data and that gives us a tree and let's view the tree here so there you go now we have created the tree perfectly as we wanted it jadeish is at the center and we have viraj sunak on each side and then the appropriate nodes on each side as the children of those nodes now recall that the same list of users when inserted one by one resulted in a skewed tree here we are getting the list of users username and user from data and inserting them and you can see calling display keys on tree three returns a skewed tree okay so whenever you have a sorted array and you want to create a balanced bst the way to do it is to start from the middle out now finally one other question you may be asked is to balance an unbalanced binary search tree and this is pretty simple at this point and this is kind of a trick question because if you were given this question directly you may not be able to think about what to do how do you balance an unbalanced binary search tree but now that we have we have a way to create a balanced binary search tree from a sorted array of key value pairs and we have a way to get a sorted array of key value pairs so now it simply becomes calling the sorted array so calling list all on the node which is also the inorder traversal so doing an inorder traversal of the binary search tree which gives us a sorted area of key value pairs and then passing that into the make balanced bst function okay so that's the trick here it's a two part question and once again we see the benefit of reusing our functions here now we this now balancing and unbalanced bst now becomes a single line of code that's very nice so we create a tree here with the value none and now we insert into it the values one by one and you can see that that creates a skewed tree because we are inserting the values in increasing order electrical graphic order so we keep adding right children and we never add a right left child but then we call the balance bst function which internally takes this gets in order traversal so the inorder traversal lists all the keys and key value pairs in sorted order and then we call the make balance bst function which starts from the middle and then creates a bandwidth binary search tree out of it so there you see this is how you balance a binary search tree and what we can do now to maintain the balance as we grow our data structure is a simple thing that we can do is to ins to of insert to balance the tree after every insertion and that brings us to the complexities of the various operations in a balanced bst so if we are doing an ins if you're doing an insertion that takes order login because now if a tree is balanced its height is order login so for insertion you may have to traverse a path from the root down to a leaf and that path can be of length at maximum equal to the height which is order login but if we are also doing a balancing with every insertion then we also have an order n term added here and order n plus order log n because log n becomes much smaller than n as n grows so order n plus order login is the same as order n so that makes insertion order n finding a node becomes order login updating a node becomes order login and you can verify that listing getting a list of all the nodes is order n so what's the real improvement between order n and order login so let's think about it if you're looking at a 100 million records then log to the base 2 of 100 million is about 26 or 27 so it only takes 26 operations to find or update a node within a balanced bst as opposed to 100 million operations so you can see here a 26 or a loop of size of length 26 and we're doing some operation inside it only takes about 19.1 microseconds that is one microsecond is 10 to the power minus 6 seconds on the other hand order n involves looping through the entire list so looking through 100 million numbers rather than 26 and that obviously takes far far longer and we saw that it took about 10 seconds right about 9.98 seconds so to find and update finding and updating a node in a balanced binary search tree is 300 000 times faster than our original solution and all we have changed here is the data structure and that's the importance of data structures because now each user will be able to view their profile in just 19.1 microseconds at least that part of the request will take only this long so the user experience will be better and your cpu will be busy for a shorter time so you will be able to serve not eight but hundreds of thousands of users every second and finally your hardware cost will also be far lower because now your cpu is busy for a lesser time so you do not need to use a very large machine or you do not need to use too many machines to support hundreds of millions of users and that is the benefit of choosing the right data structure now there's one tip here how do you speed up insertions so what we may do is we may choose to perform the balancing periodically instead of at every insertion for example we can balance for every 100th insertion or every thousandth insertion or every 100 000 insertion whatever you know that and that's where we have to balance how often do we need to insert things versus how often do we need to restore the balance another idea is to do the balancing maybe periodically at the end of every hour so for a second or two there may be a slight dip in the performance because you may be performing the balancing but even that there's a way to do it so you can take a copy of the tree and then balance it and then simply replace the pointer to the original tree so there are many other tricks that you can apply and in fact there's also an algorithmic trick which brings insertion and balancing together into an order login operation which we look at right at the very end so stay till the end but before we do that let's come back and answer our original problem statement so remember now as a senior backend engineer you are tasked with developing a fast inmemory data structure to manage profile information username name and email for 100 million users and it should allow insertion find update and listing the users by username all as efficiently as possible and to answer this question instead of creating a user database class we we can create a generic class called tree map because we have been making things more and more generic as we have gone along so let's define a function called tree map which internally stores a binary search tree a balanced binary search tree inside it so when we initialize the tree map we set self dot root to none which means we have not created a tree so far and then instead of defining functions insert update and delete we are going to use some special functions in python classes so we are going to use the function set item we're going to use the function set item here and set item is just like insert except it is a combination of both insert and update so to set item we will pass a key and a value and of course self will refer to the tree map object itself so the first thing we do is we get the root which which is basically the binary search tree that we are storing internally here so we get the binary search tree and then we find we look for the key inside the binary search tree so if the key is found so if we find the node in our tree then we come into this else position and then we simply update its value and if we do not find the node so which is what happens initially because initially our self.root is none so when you call find with none and pass a key you get back none so then we first set self.root by inserting the key into the tree okay so if a key exists within our binary search tree then we update it and if the key does not exist within a binary search tree then we insert it into our binary search stream okay so we've combined insert and update into the single operation called set item and similarly we define another operation called get item this is the find operation all we do here is we find the node inside self.root using the find function we had defined earlier and if the node is present if it is found then we return the value of the node otherwise we return none so given a key we retrieve the value and then we have we defined one last function called iter and this is the replacement for our list all function so what we do is we simply say we call listall on self.root so that gives us a list of key value pairs and then we have the special syntax we say x for x in this list and we put these round brackets around it so what this round brackets around it does is that this creates a generator out of it so now this is no longer list but this is a generator and a generator is something that you can use within a for loop so the iter function will allow our class to be used directly within a for loop and we'll see the example in just a second and finally we have another function called underscore underscore len so remember there are double underscores here so there's double underscore set item double underscore double underscore get item double underscore similarly double underscore uh len double underscore here we simply return the size of the self.root so here we simply return the size of the binary tree and then we have this function called display this is going to simply display the keys okay so now we've defined the stream app structure and it has all of these funny looking methods like we know in it but what about all of these but we'll see what these do in just a moment and we know what the what the functionality is but you may be wondering why we've defined them like this so the reason is these are special methods that are treated especially in python so here's how you can use them let's first get a list of users that we'll later insert into a tree let's get a tree map so we instantiate the tree map function the tree mac class and that gives us a new tree map inside it there is no binary tree you can check if you check tree map dot root you will see that it is none there is no value here and if we try to display it you can see that this tree map is empty then to insert instead of calling treemap.insert or instead of calling premap dot underscore underscore set item we can use this indexing notation so we open these square brackets and we put in the key that we want to insert so if we want to against the key ins against the key akash which is the string if you want to insert the value akash then we simply say tree of akash is akash and similarly tree of a certain key with the indexing notation set to this right so this is going to first look for the key as we have defined in set item if it finds the key then it is going to update the value for the key if it does not find the key then it is going to insert that key value pair as a new node into our tree so let's check it out now and let's see here if we now check tree map dot root you will see that now it is a bst node and if you try to display it you can see that now it has a structure jadeish and akash also note that this is a balanced tree now if you go back here to set item you will notice that whenever we insert right after this we also balance the tree and now you can change the logic here so that we do the balancing not after every insertion but maybe after every 100 insertions so you may need to track somewhere what is the current number of what is the current insertion counter and when it gets 200 only then do the balancing and then set the counter back to zero so that's an exercise for you perform the insertion or perform the balancing it only at certain intervals and here's a way to retrieve an element so the retrieving element is also now really simple you just call tree map with jadesh as the index and that gives you the value if it is found and if it is not found it simply returns none now because we have defined the function underscore underscore len underscore underscore so you can see here that has the value 3 because that now we can use it with the len function which is used for lists and dictionaries and let's add a few more things and let's set the values and let's see here so you can see all this works exactly as expected now we are able to set values we are able to update values we are able to display the tree it is remaining balanced and remember i mentioned that you can use this in a for loop so you can now put the tree map directly into a for loop and what this will do is because we have defined the underscore underscore iter function and the iter function returns a generator so now you can use this in a for loop and you get back the key value pairs from the list all function that was used inside editor you can print the keys in the values and in fact if you want to convert it to a list all you need to do is pass it into the list and once again because this is a generator because this is an iterable this is now an iterable class and you have defined that the way to iterate over this class is to get elements out of the key value pair list so when you call list you get back this list of key value pairs okay so now we've made it a very python friendly class you know instantiating it is very easy we simply create a new tree map adding values is very easy we simply use the indexing notation removing elements is very easy well not removing a finding elements is very easy we simply use the indexing notation updating elements is the same as inserting we can also check the size of the tree quite easily using the len function and then we can also use iterate over the keys iterate over all the users in a for loop quite easily and we can also update values as you see here values have been updated now the the purpose of doing this is to make it easier for other people to use this data structure now as a senior backend engineer you may have designed this data structure and you may have implemented binary search trees inside it but it's not important for other people on the team or other people using your data structure to know what the internal implementation is what's important for them is to be able to use it easily so that's why always think carefully about the interface or the api of your functions or of your modules or of your classes try to make them as python friendly as possible this was something that will be appreciate that will be appreciated in interviews and by coworkers so make them python friendly so that when people want to use something you have created it is extremely intuitive you know and they do not need to really understand the underlying details for instance i could be using this class and i could have no idea that it is a binary search tree all i know is how to insert and how to get a value out of it and i know that it is super efficient because you have designed it and i don't don't need to worry about the internal details so encapsulation and good apis are very important skill to have to cultivate so do that as you work on programming problems now once again let's save our work before committing now i did tell you that there is a way to create self balancing binary trees and a selfbalancing mandatory remains balanced after every insertion or deletion and in fact several decades of research has gone into creating selfbalancing binary trees and not just binary trees but other trees as well which are not binary in nature and many approaches have been devised for instance red black trees avl trees and b trees so here's an example this is an avl tree so here whenever a node goes out of balance we rotate the tree and you can see visually what we're doing here now whenever you see that there is an imbalance in the tree we rotate it and how do you do this we do this by tracking the balance factor which is the difference between the height of the left subtree and the right subtree for each node and then rotating unbalanced subtrees along the path of insertion or deletion to balance them so you can see the balance factor is zero right now the balance factor becomes one and the balance factor becomes two then we rotate it to set the balance factor back and then the balance factor here becomes 2 so here we do a right rotation here the balance factor becomes minus 2 here and minus 1 here so here we do two rotations so there are four cases in total there's the left right case the right left case the left left case in the right right case all four cases were demonstrated here as well and then you may need to do this rotation not just once but you may need to do this multiple times along the path of insertion so when you insert a node and that node creates an imbalance then you need to work backwards so you need to keep going from parent to parent and keep rotating nodes whenever you need to rebalance them based on the updated balance factor of each node so it seems a little complicated but it's actually not it's just that there are multiple cases to handle so you will need to write a couple of helper functions you'll need to write a function left rotate which rotates node left while still preserving the binary search tree property you will need to write a function right rotate which rotates the function which rotates it to the right while preserving the bst property and then in the insertion you will also need to perform the rotation at the right places and you will need to track the balance factor inside each node so there are few things to work out here and don't worry you will normally not be asked to implement an avl tree within within an interview or within a coding assessment so you do not really need to learn the implementation but it's nevertheless a very interesting data structure to study and here are a couple of resources you can check out so you can check out this youtube video which explains it very wonderfully and you can check out this implementation on geeksforgeeks.org and the important thing for us to take away here and which is something that you may be asked if not the implementation but just the complexity the important thing is that each rotation takes constant time and at most log n rotations may be required because if you are starting with a balanced tree and you are inserting a new node then you may traverse a path of height at most of length at most log n so you may need to perform at most login rotations maybe twice of that so what that means is in order login time you will be able to insert and maintain the balanced property of a binary tree right so you do not need to recreate the entire tree again and that makes your tree very efficient because now when you're working with 100 million records inserting will also take 20 steps and finding will also take 20 steps and updating would also take 20 steps and all of these will work in microseconds so that makes your data structure very efficient and with that we conclude our discussion of binary search trees so here's a quick summary we we looked at this problem of creating a data structure which allows efficient storage retrieval and updation also efficient iteration in a sorted order we first started out with a list of sorted list of values sorted by the keys and we realized that that was probably not the right idea because we are working with really large number of records then we created this binary tree structure so we looked at binary trees we looked at how to create them we looked at easy ways to visualize them easy ways to create them from tuples we looked at how to calculate their heights their sizes how to traverse them in in order preorder post order we then looked at binary search trees which have this property that the left subtree has keys that are smaller than the root nodes keys and the rights of trees keys are larger than the root nodes keys and that property holds at every sub tree and that makes it really easy to find to locate a specific element or find the position to insert an element so we created binary search trees we created the operations insert update find and list all in a binary search tree we also determined ways to check if a binary tree is a binary search tree or not then we talked about balancing and we saw how to create balanced binary search trees and binary search trees form the basis of many modern programming languages language features for instance maps in c plus plus and java are binary search trees and data storage systems like file system indexes or relational databases also use something called b trees which is an extension of binary search trees so it's very important to know about binary searches even if you may not ever need to implement them you may be asked about them and in many cases you may need to pick a binary search tree as a data structure for a problem like we did in this case now you may wonder if dictionaries in python are also binary search trees well they're not dictionaries and python are not binary search trees so we'll soon release an assignment that you can find on the lesson page and you will work on hash tables in the assignment and here are some more problems that you can try out so you can try to implement rotations and selfbalancing insertion you can try to implement the deletion of a node in a binary search tree that's slightly more complicated because what you do if you have to delete a node that has both left and right subtree you can try deletion with balancing if you really are up for a challenge here a couple more finding the lowest common ancestor of two nodes in a tree so the common node which is a common parent of both nodes here you can use the parent property finding the next node in lexicographic order so given a node how do you find the next node what's its complexity or given a number k how do you find the kth node in a binary search tree so to do this you will have to employ some clever tricks and then there are a couple more resources here you can open up these and find more questions the important thing to take away is that almost all of these will involve some form of recursion so you will either work with the left sub tree or the right sub tree or both and some of them may also require you to store additional information within the node for instance for for this one the given the number k find the kth node this may require you to store the size of each balanced binary search tree in each node so what to do next you should review the lecture video and execute the jupyter notebook experiment with the code yourself then complete the assignment hopefully the next lesson is called divide and conquer and sorting algorithms this is data structures and algorithms in python and i will see you next time thank you and goodbye let's look at assignment 2 of data structures and algorithms in python the topic of the assignment is hash tables and python dictionaries let's get started the first thing we'll do is go to the course website pythondsa.com and on the course website you can find all the lessons and previous assignments we are looking at assignment two so you may want to open that up and assignment two is based on or inspired from some of the topics discussed in assign lesson two so you may also want to watch lesson two and complete the notebook before you work on assignment two let's open it up now in this assignment you will apply some of the concepts learned in the first two lessons to implement a hash table from scratch in python that's very interesting you will and hash tables are very important data structure they're present in pretty much every programming language and are a common topic discussed and asked in coding interviews so we'll see how to implement them from scratch and one of the central problems in hash tables is called collisions so we'll see how to handle hashing collisions using linear probing and we will also replicate the functionality of python dictionary so python dictionaries are actually implemented using hash tables so we see how to replicate the way python dictionaries are created and used and modified and the way we access keys and iterate over keys and set values and change values and so on so we'll pretty much reimplement the python dictionary now we have an assignment starter notebook here so we can click on view notebook to open up the notebook once again this is a jupyter notebook and as you work through the notebook you will find question marks in certain places to complete the assignment you have to replace all the question marks with appropriate values expressions or statements to ensure that your notebook runs properly end to end okay so make sure that you run all the code cells do not change any variable names and in some cases you may need to add code cells or new statements and since you'll be using a temporary online service for code execution keep saving your work by running jovian.commit at regular intervals there are some optional questions they are not considered for evaluation but they are for your learning okay so let's run the code now the recommended way to run the code is using free online resources binder specifically but you can also run it on your computer locally so we're going to click run and click run on binder once again this may take a few minutes sometimes depending on the current traffic on the platform there we have it now we have the jupyter notebook running the first thing i like to do is click kernel and restart and clear output so that we can execute all the code cells and see their outputs from scratch i'm also going to hide the header and the toolbar and zoom in here a little bit so we can see things a little better the first thing we will do is set a project name import the jovian library and run jovian.commit this will allow you to save a snapshot of your work to your trovian profile so now you have a copy of the assignment starter notebook any modifications that you make every time you run joven.com it will get saved to your personal copy and it is this personal copy that you will submit at the very end so let's talk about the problem statement in this assignment you will recreate python dictionaries from scratch using a data structure called hash tables and dictionaries in python are used to store key value pairs so keys are store used to store and retain values and here's an example here's a dictionary for storing and retrieving phone numbers using people's names so we have a dictionary called phone numbers and the way you create a dictionary is using this special character the brace or the curly bracket as it's called and then in a dictionary you have these key value pairs so this is one key value pair where you have a key the key in this case is a string akash and here you have a colon and then here you have a value the value in this case is a phone number so that's how you create a key value pair and comma separated key value pairs is what you need to create a dictionary you can see once the dictionary is created it is displayed in the exact same way and then you can access a person's phone number using their name so if we have the variable phone numbers and we use the indexing notation so this is the square bracket and we pass in a key here we get back their name and you may wonder what happens if the key is not present the great thing about jupiter is you can insert a new cell like you can just click insert cell below or you can use the keyboard shortcut b as i just did and check maybe let's check the key vishal okay and you get back a key error and you may also wonder what happens if is it case sensitive does that matter you can check it very easily so a lot of the questions that you might get a lot of the questions that you may want to even ask on the forum or look up online can be resolved simply by creating a new cell and typing out some code right what happens if questions can all be answered by writing some code so now let's add some new phone numbers so this is how you create an initial set of phone numbers this is how you access a phone number and this is how you add new values so adding new values is like accessing them but instead of accessing it you put an equal to and then you actually set the value here so we can add a new value here the phone number for vishal and we can also update an existing value in a dictionary simply by accessing that value and putting an equal to and putting in new value there you can see now that the dictionary is updated to contain the new phone number 7878 and not the original phone number 948948 you can also view all the names and phone numbers stored in the phone number dictionary using a loop so you can say for for name and phone numbers so when you put a dictionary into a for loop you get back a key within each loop you can see here that the name and the phone number here is displayed for you using the print statement so those are some things that you can do within a dictionary and dictionaries in python are implemented using a data structure called a hash table and a hash table uses a list or an array to store key value pairs and uses a hashing function to determine the index for storing or retrieving the data associated with a given key so here's what it looks like here you have the key john smith and you have a function called hash and the function hash takes any key and it returns an index within the list so why do we use a hashing function well one approach as we've discussed in lesson two is we can store our key value pairs in a list and we can simply search through the list each time we want to look up the value for a key but that is inefficient because that requires looking through potentially all the keys before we get to the key that we want or maybe half of the keys so that makes it an order n operation if n is the size of the list that's pretty inefficient we want something faster and a hash function actually operates in constant time so hash simply takes the key and it converts the key into a number so in that sense it gives you the index of the specific key value pair in constant time rather than ordering and that is what makes hash table so efficient right so hash function does not require looping through the list it simply takes a key gives you the index and you can simply then get the key value pair or the value from that index now your objective in this assignment is to implement a hash table class which supports these operations an insert operation a way to insert a new key value pair a find operation to find the value associated with a given key an update operation to update the value associated with the given key and then list operation to list all the keys stored in the hash table and here's where we are going to use python classes and there's a brief introduction to python classes in lesson two of this course so do check out lesson2 if you want a refreshing on python classes you have the class hash table and inside the class hash table you have a bunch of methods now the insert method apart from taking the self argument and remember that the self argument is refers to the object of the class that will be created so this is equivalent to this variable in java or c plus but these are the actual arguments of the method the actual arguments are key and value so the insert function or the insert method will take key and value then the find method will take a key the update method will take a key and value once again so the find method takes a key and your job is to return the value the insert method takes a key and value and you insert the key value pair into the hash table then you have the list all method which is used to list all the keys from the table so before we begin our implementation let's just save and commit our work so we're running joven.comit here let's just run that once again there we go the notebook has now been committed so what you can do is you can come back to this particular page and you can find this from your profile and then you can click run to continue your work based on the modifications that you've already made okay so we build a hash table class step by step and the first step is to create a python list which will hold all the key value pairs now remember that a hash table internally uses a list to store the key value pairs and we will create a list of a fixed size so we'll set this variable max hash table size of size 4096 initially and we're going to create a python list of this size how do you create a python list of the size and we want all the values to be set to none so this is the way to do it you can of course you can start typing none and that would take a long time or you can use a simple technique just put in none times 4096 and that's one of the great things about python it is such an expressive language that creating a list of 4000 elements simply requires this single expression here you can check that here you can even check the length of the data list now if the list was created successfully here are some test cases here is one check that the length of the list is 4096 here's another check and we're simply picking a random value from the list 99 and just checking if that is equal to none but if you really want to have a sure shot test here what you should be doing is you should be checking for item in data list item equals none okay and here's a trick you can do you can write a word called assert and what assert does is if this comparison is true then it does nothing it lets your code proceed as usual but if at any point this comparison becomes false then it throws an error so let's see here you can see here there was no error so that means it worked fine but if this comparison was wrong so let's say if item if we had here we wanted the items to be equal to seven if you put it and and the telus does not contain the item seven at a certain position then you will get an assertion error here okay this is how you can create your own test cases by putting in assert but the idea here is that whatever you try to do make sure that you're adding some more test cases and not just depending on the test cases that are given here these are simply to guide you in the right direction okay so next up we have a list now we need a way to store or insert key value pairs into a list that's where the hashing function comes into picture the hashing function is used to convert strings and other nonnumeric data types into numbers which can then be used as list indices for example if a hashing function converts the string akash into the number 4 then the key value pair akash and the phone number seven eight seven eight seven eight seven eight seven eight will be stored at the position four within the data list and here's a simple algorithm for hashing which can convert strings into numeric list indices and a hashing algorithm does not have a single definition you can come up with a hashing algorithm and in fact coming up with a good hashing algorithm is an area of research in itself now of course python dictionaries use hashing that is inbuilt into python and that's a fairly optimized hashing algorithm that's probably the result of several years of research but here's one very simple technique we iterate over the string character by character and then we convert each character into a number using python's builtin ord function and you can see here that if you call ord on the character x you get back a number it already gives you a way of converting characters into numbers but not entire strings that's why we need to iterate over the string character by character then we simply add the numbers for each character to obtain the hash for the entire string it's a very simple technique we just keep if you have the number hello we take the odd for hello the odd for e the odd for l the odd for l and the odd for o and add them together and since we want that number the final result to be an index or a position within the list so we take the remainder of the result with the size of the data list right so it's possible that once you add the numbers together you may end up with a pretty big number but if you take the remainder with 4096 or the max hash table size variable you get back a number that is smaller than 4096 so you can use just that remain as the index so let's first define a function called get index all it does is it takes the data list and it takes a string and it returns it applies this hashing algorithm to return an index for that string for that key so for a character in a string we need to convert the character to a number so we convert the character from the string into a number by calling od on a character great then we update the result by adding the number so we say result plus equals a number pretty straightforward and that repeats for all the characters in the string and then we get back the final result now that result may be longer than the actual size of the list and this is where we then we may then want to check the size of the list okay now remember there's one no i could also have probably written max hash table size here but that would be wrong isn't it because we are passing in a data list here we are passing in a data list and although we have so far created a data list of size 4096 your function should ideally be you looking at the size of the data list that you have here and not any global variables so keep that in mind and the right thing you should check here is lend data list and what this will allow is now this will allow your function to work with data lists of different sizes and not just the standard size 4096 that we have defined above okay very important thing always make sure that your functions use the arguments that are passed into them that they are generic that they can work with any input and not just a particular input that have been that has been defined earlier okay so there you go now you have this is a function get index that has been defined and here are some tests now if you pass in the data list and you pass in the empty string because there are no characters the result is likely to be zero it's great here's another one the result here is 585 here's another one result here is 941 great now this is where you should be testing your function with some custom test cases i'm going to create a new data list 2 and this is going to have the size none times 48 so this is only going to have the size 48 and i should be testing get index with this data list as well so let's say we're looking at the key akash now we know that let's see we can actually test this out here what happens if you add ord of a plus or d of a plus k a s and h that number is 585 but since the size of the list is 48 what we should be getting back as the result is 48 divided by 585 so we should be getting oh sorry 585 and its remainder with 48. we should be getting back the number nine this should be equal to nine okay so let's check that if this is equal to nine and indeed this is equal to nine on the other hand if we had max hash table size you will see here that since we are not taking into consideration the actual size of the list that was passed into the function we are getting back the value 585 because we are taking the remainder with 4096 okay so remember to take the result remainder with the size of the data list that was passed in so this is one of the several gotchas in this assignment and they're there for a reason because this is something that you need to keep in mind a function which only uses its arguments and does not depend on any external global variables or constants and things like that is called a pure function of course a plot function also does not modify any external global variables so it simply takes some arguments and returns a result irrespective of anything else outside so now we can to insert a key value pair into a hash table we can simply get a hash of the key so here we have a key value pair and we simply get a hash of the key by calling get index for data list and key and we get back the index 585 and then inside the data list at the given index we can simply set the key value pair as the element stored at that index and the same operation can be expressed in a single line of code so here we're calling get index for data list and he month and that's going to give us an index and we're going to then invoke a set at that particular index within data list the the element hemanth comma hemans phone number now to retrieve or find the element associated with a pair we can simply get a hash of the element the value associated with the key we can simply get a hash of the key and look up that index within the data list so here we have the kiakash and we have the data list and we call get index so we get the index of the kiakash and that gives us the index here and we can then call datalist and pass in the position idx and that should give us a key value pair remember that we stored a key value pair at the given index so we should get back that value here so now we know how to store a value you get its hash for the key and you store the key value pair how to retrieve a value so you get a hash for the key and then you retrieve the key value pair and from there you can get the value you can also list the keys to list the keys here is some special code we are using so let's see this is called list comprehension and let's take a quick look at list comprehension so list compression works like this if you create a list y from a list x uh let's say let's call this list one and list two go to variable names always help so if you have a list one and you write this x for x in list one what does that do that for x in list one patches elements one by one from the list and then here you can specify what to do with the numbers that were fetched so right now i'm not doing anything i'm simply returning that number and then i'm putting the entire thing into a list what this does is this creates a new list so you can see this is a copy of the original list what i could do is i could write x times two for x in list one and now i would end up with a list which in which each element is the double of that particular element i could also do x times x if i wanted i could also call a function on it let's see what function we can call here let's maybe put in some numbers here 1.3 2.4 3.2 so we could put maybe the function math dot round x oh sorry math dot seal this is going to give us the ceiling the 1.3 becomes 2 2.4 becomes 3 so you can do any operation with each element of the list and once you put that in a bracket and you have this 4 here that's going to apply that same operation to the entire list and this is called list comprehension in python it's a very powerful way to express complex operations on lists and dictionaries and there's one final thing in list operations which is the if condition so for x in list 1 can be followed by an if condition and the if condition can once again apply on x so if x is greater than 3 let's say we put this condition then what happens is we choose only those numbers from list one which satisfy this condition x greater than three so that means we would skip one point three we would skip two point four we would get three point two we would get six we would get seven and we would apply math.cl to them and that's how we get back 467 so that's list comprehension in a nutshell so to get a list of keys all we can do is for key value pairs in data list if the key value pair is not none remember that we have a lot of non values and it's a huge list if the key value pair is not none then we simply return kv0 so remember if you have a key value pair if you have like a key value pair that's akash and a phone number and you can also put because these are tuples you can also put a round bracket here if you want but even without it it's the same thing that's a key value pair kv 0 is going to give you the key and kv 1 is going to give you the value so we simply get the key for those key value pairs in data list where the element at that position of the key value pair is not none and that should not be called pairs that should probably be called keys you can see that the keys are akash and hemath so that's how we can now use the get index function and the next step for you is to complete the hash table implementation here by following the instructions given in the comments so now you have this basic hash table class and in this class you have a constructor now the constructor takes the object self or this and the self is going to point to the actual object or the actual hash table that gets created using the class and then it takes a maximum size now what are we doing here we want to make our hash table configurable we don't always want to have 4096 elements in our internal list we may need a hash table that can store more values or we may need a hash table that can only store fewer values so we are going to set a a default value for it which is the max hash table size so if you do not provide this argument by default it will create a list of size 4096 but we also want the option to specify a maximum size now you need to create a list of size max size with all the values set to none now you may be tempted to do this but that would be wrong remember that always use the arguments to a function try not to depend on an external value or external constant so this would be wrong you may also be tempted to do this data list set dot data list equals data list that we've already created this would also be wrong not just because you're not using the max size but also because now you are tying this class implementation to a global variable and that global variable is a list which can be modified so if you all the objects of this class any number of hash tables that you create using this class we'll all use the same data list and that's not what you want each hash table that you create maybe you have a hash table for phone numbers you have a hash table for addresses you have a hash table for something else each of them should have their own internal data list and this is not going to create a copy of that original this is simply going to point to the original list so what you want to do is you want to do none and you want to multiply it with max size there you go this is the correct way to do this now we're looking at insert here now to insert we did see that to get the index all you need to do is you need to pass the key and remember here you need to pass not data list but self.datalist right because now we want to use the data list that is stored inside this specific object of the class we do not want to use the global data list and this is something that is an mistake that we often make initially i've still make this mistake where i have certain global variables defined and i'm using those global variables inside my class avoid doing that anything that you want to put inside a class object you need to put inside self like we've done here and then to access it you need to use self dot to access that specific property or element or even method so now we have self.datalist and we pass in the key and the data list into get index and that gives us the index now the get index function was defined earlier we've seen it already now we want to store the index inside the list so we call self.datalist idx and we want to store the key value pair there so we can simply put in key comma value here if you wish you can also put in the brackets but they are not necessary and that's going to insert the key value pair now how do we find the value associated with the given p key first we get the index for the key so we call get index on self.datalist and key then we retrieve the data stored at the index so this would be simply self dot data list of idx and then if the key value pair is not none if the key value pair is none well there's nothing in that index we can return none another option would be to also maybe raise an index error and with a message etc etc but return on is good enough for now then if not from the key value pair we get back the key and the value and then we return the value keep those in mind if you simply return this you would get an error you would get an exception that may go unexplained so whenever you are destructuring or you're trying to get two values out of a tuple make sure that the tuple is not none especially in this case because we're starting with a list of nones in a place where we're supposed to be storing key value pairs so that's fine now update is going to be pretty much identical to insert i don't see any difference here so we can simply say get index for self dot data list and key and then now we simply store the key value pair inside it so we can simply store oops the key comma value inside self.datalist idx then for list all again straightforward self dot fkb is not none so get all the key value pairs that are not empty and then we simply get kb 0 is going to give us the key from kv so that there it is here you can see already that we are creating a basic hash table of max size one zero two four so the first thing that we can verify is that the length of the basic of the data list is one zero two four there you go then you insert some values here so we insert the value akash we insert the key value pairs so we insert the value 9999 for akash so this is one key value pair we are inserting hemanth and 8088 and what this will do is when you call basic table dot insert it will call this insert function and self will now point to the basic table that we have just created because we're calling insert on that specific basic table so self will point to the basic table so self.datalist will become basic table.datalist and then the remaining arguments are cached in 9999 will get passed in as the key and the value so this code will execute we will get the index within self.datalist for the kiakash and then within self.datalist or basic table.datalist in this case add the given index that we just computed we will store the key value pair which is akash and the phone number and that's how it'll work so we're inserting some values and then we're finding a value so when once we insert the two values and then we find a value that should give us the value 888 you may want to then maybe modify this test case to also include the test for the other value that we inserted so feel free to modify the test cases or add new test cases so that we're checking not just one value but both the values next let's see how we if we can update a value so we call basic table dot update and we said seven seven seven seven now suppose you're not implemented update here that's for a moment return suppose you've not implemented update here then if you called update you would get false here because the value did not get updated and you can check that by simply checking basic table dot find akash you can see that it still has a value 9999 that's how test cases are helpful let's remove the return okay so now the value seems to have been updated just fine then let's get a list of all the keys and the list of keys should match true once again if we did not have this kv is not none then we would get back not just this key value pair but we would get back all the nuns and we don't want that so these were some test cases but you need to now create more test cases and test them out to make sure that your implementation is correct now once you've done that you would want to run jobin.comit now the next step and this is something that you may have thought about while working through the assignment is that how do you ensure that different keys do not point to the same index because we are doing all these things where we are converting each character into a number and then adding up the characters now obviously if you have words which have the same characters but in different orders now obviously there are different keys but they do not have they have the same hash listen and silent have exactly the same keys exactly the same hash so for instance instance you can check get index listen and get index silent okay we also need a data list let's put in a data list here both of them have the hash 655 that means if you insert a value at with the key listen and then you insert a value with the key silent the data at this position will get overwritten so when you try basic table dot find listen you will get the value associated with silent and that's bad and this is called collisions this is called a collision because here the two keys are colliding in some sense because they're leading to the same hash and any hash table that you implement is ultimately going to have collisions because the number of strings or the number of keys is possibly infinite but you have a limited number of positions or indices in your table so our hash table implementation is incomplete because there can be data loss and it does not handle collisions and there are multiple techniques to handle collisions and we the technique we will use in this assignment is called linear probing and here's how it works while inserting a new key value pair if the target index for a key is occupied by another key then we simply try the next index and if the next index is also occupied by another key we try the next and then if we try the next and then we try the next till we find the closest empty location and then while finding a key value pair we apply the same strategy but it's searching for an empty location this time we search for a location which contains the key value pair with the matching key we get the hash of the key that we want to find and then we check if that position is occupied by another key not the same key then we try the next index and then we try the next index and then we try the next index till we find a position which is occupied by a key value pair for the same key and if we find an empty position that means the key does not exist because if it did exist then it should have been somewhere in that string of searches that we just come that we just did now by updating the key value pair again we apply the same strategy but instead of searching for an empty location we look for a location which contains a key value pair with the matching key and update its value so that's how you handle collisions in a hash table and to handle collisions we will define a function called getvalidindex which first gets the hash using get index and then start searching the data list and returns the first index which is either empty or contains a key value pair matching the given key so we are now addressing two requirements in one shot with the get valid index function for insertion we are looking for an empty position for find an update we are looking for a position which is occupied by a by the given k value by the given key value pair okay or the given key specifically so here's the get valid index function and i will let you work through this so you will start with the index returned by get index then while true because we don't know how long we may need to iterate get the key value paired stored at the index this is where you may have to it's simply a question of putting the index into data list getting the key value pair now if the key value pair is none which means that there is nothing at that index it is empty that's great we are done we can simply return the index on the other hand if it does have values so then we get the key and value out of it if the key matches the key that we want to store great then we can return the index once again if neither of these hold true we move the index to the next position but as we move to the next position it's possible that we may run out of indices so the index may become equal to the length of the data list so then we wrap around and go back to the zeroth position so this is an important part where we go around so now our list is in some sense circular where we can keep looping around it so that if we have something that needs to be stored at the last position but the last position is occupied then we move back to the zeroth position and so on and then you can check if get valid index was defined correctly and if it was then these cells should output true once again these are just some sample test cases so you should include some more of your own test cases here and finally once you're done just save your work now the next step is to incorporate linear probing into your hash table so here's a new class called probing hash table here you need to use not get index but get valid index it has pretty similar code so i'll let you work this out be aware not to simply copy paste code and you will run into issues if you copy paste code so always make sure that you are writing the code yourself and carefully writing each word or each variable in each method and each argument of the code then there are some test cases here for you to test the probing hash table once again you can try it out with some examples and see if it works fine specifically here we are taking the same example listen and silent both of which in basic hash table would have the same key but in probing hash table would have different will have the same position but in probing hash table will have different positions and that's it you at this point you're done with the assignment so you can make a submission if you have run jobian.commit you can take this link and make a submission on the assignment page or the other option for you is to simply run jobin dot submit python dsa assignment 2 and once you make a submission it will be evaluated automatically so let's click through here so it will be evaluated automatically and if you scroll down here you will see that you will get a grade and not just grade but you will also get comments for each question so if you see here there are question numbers here you can see that there's question five question four and so on so it seems like we since we implemented the get index function since we implemented the data list correctly question 1 was a pass let's see what question 1 was very quickly question 1 create a python list of size max table hash size question 2 was a pass so question 2 was the get index function question 3 was a pass so question 3 was complete the hash table implementation question 4 was a field get valid index we've not defined it yet and question 5 led to an exception obviously because we have some code which will not execute because we have some blanks that need to be filled in so keep that use this as feedback you will know exactly what to fix and if you are stuck at any point you know what to do you can go to the forum so let's see the forum here so this is the forum sub category for assignment two you can create a new topic here if you want to have a longer discussion or you can simply go to the main topic assignment to hash tables and python dictionaries and you can ask a question here there are already a lot of discussions going on here so it's possible that your question may already have been answered and after this there are also some optional questions now here the optional question is for you to implement a python friendly interface for the hash table so instead of defining functions insert update and find you will define the functions get item set item and instead of list all you will define the function eter and also instead of using the hash function instead of using the custom hash function that we have defined you will define you will use a function that's inbuilt into python called hash and it takes any string or any object and it returns a number for it now since hash does not accept a list so you will have to take the remainder manually so in this case for example we've taken the remainder and gotten back the number three five six nine so you define a hash table here and once you have done that you will be able to use it just like a python dictionary you will be able to use it exactly like this you create a hash table and then to insert a value you use the indexing notation and insert the value to retrieve a value you use the indexing notation to get the value back and here you can compare it to the number to update a value you simply use the induction notation again and to get a list of values you simply call the list function or you can also use it within a for loop and we've also defined a function called wrapper and str what that will do is that will let python print a representation like this when you simply run a cell which just contains the name of this variable that's one and then there are a bunch of improvements that you can try to hash tables this is a great exercise if you want to improve your python programming skills and also understand how hash tables work if you can complete these four exercises there's pretty much no question related to hash tables that you cannot answer you will know everything about them and each of these exercises may take another 30 minutes to 45 minutes but it's completely worth the time maybe spend set aside a few hours on the weekend to work on these optional exercises now here's one how to track the size of the hash table instead of having to look through the entire table to get the number of key value pairs can you store the length somewhere so that you can track it in size order one here's one to implement deletion so to implement deletion you have a topic called technique called tombstones that are used so you can use this tombstone technique and implement it just a little more code can you implement dynamic resizing so instead of starting out with a hash table of a given size or requiring the user to specify a size can you or maybe start with a hash table of let's say 128 elements and then double it as soon as you reach 128 elements or maybe even before to avoid collisions you may want to double it as soon as you reach 64 elements like 50 of the capacity so dynamic resizing is the technique that allows you to automatically grow and shrink the data list internally and then here's another technique for collision resolution this is called separate chaining so instead of going to the next index what you do is you maintain a linked list at each position and for all the key for all the keys you still use that position but you look through the linked list while looking for a key or you add a new element to the linked list for that position if you're adding a new key there so here's separate chaining explained in a youtube video you can look through that and try to explain it on your own and one final thing here is also the complexity analysis and here's where you talk about average case time complexity because on average if you have a good hashing function and you've implemented some improvements like dynamic resizing then the average time complexity for insert update find and delete are order one and list of course is still order n on the other hand the worst case time complexity because there can be collisions are still order in so here's something for you to ponder upon what is average case complexity and how does it differ from worst case complexity this is also something that is discussed in lesson three of the course where we talk about quicksort and you see why insert find and update have an average case complexity of order one and a worst case complexity of order n if not it is something that you can look up online try to see if you can search a tutorial and learn why this happens then how is the complexity of hash tables different from that of binary search trees we've discussed binary search trees in a lot of detail in lesson two so now the question becomes when should you prefer using hash tables and when should you prefer using binary search trees or vice versa so all these very interesting questions and you may get asked some of these questions and interviews as well it will help you especially to ponder upon some of these questions even if you do not end up solving all of these optional questions do look at the complexity analysis and think about it and there's a forum thread where you can discuss your thoughts so what you do next review the lecture video review the assignment walkthrough video and execute the jupyter notebook complete the assignment and attempt the optional questions as well and do participate in forum discussions so this was a walkthrough of assignment 2 of data structures and algorithms in python hello and welcome to data structures and algorithms in python this is an online certification course conducted by jovian and today we're on lesson three my name is akash i'm the ceo of jovian and i'm your instructor for the course if you follow along with this course and complete four weekly assignments and a course project you can earn a certificate of accomplishment for this course so let's get started the first thing we do is visit the course website pythondsa.com so when you visit pythondsa.com this will bring you to the course website here you can find all the information and material for the course you can check out lessons 1 and 2 and assignments 1 and 2 both of which are still open for submission and let's open up lesson 3. so the topic today is sorting algorithms and divide and conquer and you can watch a video recording of the lesson here you can also catch a version in hindi now the code used for the lesson is provided here so let's open up this link sorting and divide and conquer this is where all the code is present so here we have it now we are looking at the tutorial and the code for this lesson if you scroll down you can see that there is some code here now to execute this code you have two options you can either execute this code online using free online resources which is what we recommend or you can download it and run it on your computer locally and the instructions for both of these are given here we are going to use the first one which is to click the run button at the top of this page and select run on binder so let us scroll up here and let us click the run button and then click run on binder now once you do this it will open up an interface like this and what you're looking at here is a jupiter notebook so a jupiter notebook is an interactive programming environment where you can write code look at the results and you can also write explanations and we've provided you with a cloudbased jupyter notebook setup so you don't have to install anything all the code that you execute here will be running on our cloud but you can also download it and run it on your own computer by following the instructions so the first thing we'll do is click on the kernel menu and click restart and clear output to remove any of the outputs from previous executions of the code so that we can execute the code and see the outputs fresh for ourselves now i'm also going to zoom in a little bit here so we can look at the code and let's get started so this is a coding focus and practical course and we're talking about different data structures and algorithms the topic today is sorting algorithms and divide and conquer algorithms in python so in every lecture we focus on a specific problem so in this notebook in this tutorial we will focus on this problem which you're looking at here so let's read the question you're working on a new feature on jovian called top notebooks of the week write a function to sort a list of notebooks in decreasing order of likes keep in mind that up to millions of notebooks can be created every week so your function needs to be as efficient as possible that is the key point here now this is a classical problem in computing the problem of sorting a list of objects and it comes up over and over in computer science and software development and it's important to understand common approaches for sorting how they work what the tradeoffs are between them and how to use them so before we solve this problem we solve a simplified version of the problem it's quite simple to state write a program to sort a list of numbers and sorting usually refers to sorting in ascending order unless specified otherwise so that's a question for today write a program to sort a list of numbers and we'll expand upon it to answer this original question as well now this is the method that we've been following throughout the course and we will continue to follow a systematic strategy for solving programming problems step one state the problem clearly identify the input and output formats step two come up with some example inputs and outputs and try to cover all the edge cases and step three come up with a correct solution for the problem stated in plain english step four implement the solution and test it using example inputs so this is very important that you implement the simple solution so you just need a correct solution first not the efficient one and then you implement it and test it then you analyze its complexity identify inefficiencies and then you apply the right techniques to overcome the inefficiency and that is where the knowledge of the right data structures and algorithms comes into picture and once you apply the new technique then you once again state the solution implement it and analyze its complexity and repeat if necessary so this is the strategy we'll follow here today as well so step one state the problem clearly and identify input and output formats now the problem is stated clearly enough for us we need to write a function to sort a list of numbers in ascending or increasing order now here's the input the input is a single argument called nums and that is a list of numbers so for instance here's a list of numbers you can see that they're not in any specific order and then the output is the sorted version of the input so here is the same list of numbers in sorted order and based on these two we can now write a signature of our function so a function will be called sort or something else but it will accept just one input and right now we've not written any code here so we just put in pass now i'm running this code here using the shift plus enter shortcut but you can also use the run button on the toolbar so either run or shift plus enter and the great thing about jupyter notebooks is that you can add more code cells anywhere and test anything that you want for instance if you want to insert a code cell below just click the insert cell below menu option or click outside a cell on the left and press the b button and now you can write some code here and run it so please feel free to experiment with this notebook as you go along so step two come up with some example inputs and outputs now this is very important you need to think about all the different scenarios in which you may want to test out your function before you put it into production so that you catch errors early on and thinking about scenarios will help you identify what are the special cases you need to handle in code and it's easier to do it right now than while writing your code because that may lead to bugs so here are some scenarios that i was able to come up with and there may be more so you can continue and increase this list so the first one is some list of numbers in random order for some numbers in any random order and you can try slightly smaller lists and larger lists and so on second is a list that's already sorted we need to ensure that an already sorted list does not become unsorted a third is a list that's sorted in descending order we may want to check that see if we need to handle that case separately somehow then a list containing repeating elements this is something you may not have thought of but the question never said that the number should be unique so there could be repeating elements here an empty list interesting input the output is also an empty list or a list containing just one element or a list containing one element repeated many many times or even a really long list this is something that we may want to test because we want our algorithm to be efficient at the very end so a long list may help us just evaluate the efficiency empirically so these are the scenarios and what we now need to do is create some test cases for these scenarios so test cases involve creating an input and an output for instance here is an input num0 and this could be the list 431 and here's the expected output so let me call it output 0 and this would be 134 now this is a good way to put create a test case and you can use it later for testing but we will put our tests into this particular structure we'll create a dictionary and creating a dictionary like this will help us automate the testing of all our test cases with a single helper function so what we're gonna do is for each test case create a dictionary and then it'll have two keys first key is called input and the second key is called output and in the inputs for each of the arguments that go into the function and remember there's just one argument here we will have one key so we will have the key nums and the key numbers will have the input value for the test case and the output will simply contain the output returned by the function so that's how we'll set up our test cases so does our test 0 a list of numbers in random order then we have test one this is also another list of numbers in random order you can see here no specific order now we have a list that's already sorted and of the output obviously is the same now for the random ordered list the output is the same numbers in sorted order now we have a list that's sorted in descending order and the output is the same list in increasing order then we have a list containing repeating elements you can see that the numbers 1 2 6 and 7 and even minus 12 repeat here here we have the empty list here we have a list containing just one element and here we have a list containing one element repeated many many times and then the final test case which was to create a really long list that's where we can start with a sorted list created using the range function and then shuffle it to create the input otherwise you may spend a lot of time just creating a list and then writing the sorted version of it that's too much work so always use a computer always use helper functions whenever you can even to create test cases so we'll use the range function now the range function takes either a single number or two numbers so you can have something like this range 2 to 10 or just range 10 and if you just look at it this way it just prints range 0 to 10. now if you actually want to see what's in it there are a couple of ways you can do list range 10 and that gets converted into a list or you can use it in a for loop so you can put for x in range 10 print x so you can see that it contains the numbers zero to nine and that's important that the range does not include the end element of the range okay so just keep that in mind now what's the difference between a range in a list a list contains all the 10 numbers together at once but a range internally simply maintains a counter so when you use a range in a for loop it simply starts the counter from 0 and increments it up to the starts the counter from the starting value so if it's two to ten then it starts a counter from two and increases it up to the end value minus one so it does not use as much space as a list it simply uses a one single variable internally and that's why it's more efficient in any case right now we need lists so what we'll do is we will create a list of ten thousand numbers so zero to nine nine thousand nine hundred and ninety nine that is our in list and then our out list is also going to be 0 to 999 that's our outlist both of them are sorted now what we do is we shuffle the inner list so we import the random module from python and then we call random.shuffle and we call random dot shuffle on in list and that shuffles the the first list the n list so now we have that as the input nums and then the out list the sorted list is the output now once again we can even check that in list is actually shuffled maybe by looking at the first 10 elements you can see here that these are all shuffled numbers on the other hand if you check the out list you can see that these are all in order so those are our test cases and it's very important to create good test cases even in interviews before you start coding or before you even suggest a solution you should try and list out your test cases either verbally to an interviewer in a coding assessment you may create a block of comments at the top and start listing some test cases at the top or you can create proper test case dictionaries like this it takes a few minutes but it's totally worth it because you can then test your algorithms very easily and finally we'll take all our test cases test 0 to test 8 and put them into a single list called tests great so we've made some good progress so far next let's come up with a simple correct solution and stated in plain english and coming up with the correct solution is pretty straightforward we have a list of numbers so we iterate over the list let's grab a list of numbers so that we have something to look at here you go so we have a list of numbers so we iterate over the list of numbers starting from the left so we start from the very left and then we compare each number with the number that follows it so we compare 99 with 10. and if 99 is greater than 10 then we can say for sure that 99 should appear after 10 in the final sorted array and the sorted array by default it means the increasing order of numbers right so that's what we're solving first so what we can do is we can simply swap 99 and 10 because we know that 10 should appear before 99 and 99 should appear after 10. now once we continue the swap we move to the next position and then we compare 99 with the next element nine that turns out to be higher as well so we swap it and then we keep going so we iterate over the list and for each element compare the number with the number that follows it and if the number is greater than the one that follows it swap the two elements now you do that once and that alone is probably not enough to compile the entire list because the entire sorted list because 99 in this way will end up at the end if you follow the process but the rest of the list is still not sorted so we repeat these steps one two three so once again we start from the left and then we start comparing ten with nine and then ten with eight and so on and keep swapping elements as we go forward now i have a claim here that you may you will need to repeat the steps one two three at most n minus one times to ensure that the array is sorted can you guess why and here's a hint after one iteration of the process the largest number in the list will reach the very end so that means that each time you're putting one of the largest numbers at the very end so you need around n steps so here's an animation showing the same thing here we compare six and five and then we switch them then we compare six and three and we switch them then we compare six and one and we switch them now we compare six and eight and we don't switch them because they're in order next we compare eight and seven and we switch them next we compare eight and two and we switch them and finally we can compare eight and four and we switch them and in this way the largest number eight has reached the very end so now we can froze freeze its position and we can start again from the beginning and you can see that this time the next number seven will end up here and then the next time the number six will end up here and then next time the number five will end up here and so on so in n repetitions of this process of comparison left to right we will have sorted the array and this approach is called bubble sort because it causes the smaller elements to bubble to the top or to the beginning you can see that the numbers 1 3 slowly bubble up to the top and it causes the larger numbers like 8 and 7 to sink to the bottom and you can watch this entire animation to get a full sense of how bubble sort works what will also really help is if you can take an example on paper and work it out on your own step by step especially with sorting algorithms this really helps okay so now we've come up with a correct solution let's implement it and let's test it using an example now the implementation itself is also pretty straightforward so we have the bubble sort function here def bubble sort it takes a list of numbers now we may not want to modify the list of numbers in place because then our test cases will not be reusable so just to avoid modifying our test inputs we are going to create a copy of the list to avoid changing it and the way to create a copy simply call the list function with the list as input so now we are set replacing nums with a copy of nums now depending on your particular use case this may not be necessary so this is something that you can actually check while you're in a coding assessment or in an interviewer or talking to an interviewer just check with them do do they want an edit to be sorted in place or do they want a new array to be created if they want if they're okay with sorting it in place then you probably don't need this but you may still just want to keep it in because otherwise you may end up modifying some of your test cases unintentionally and that may lead to problems it's always good to create a copy of the input rather than modifying it in place okay so then let's come to steps one two and three and then we'll see step four which is the outermost step really so we iterate over the array so we go from we take i and we check the range len nums minus 1 so the number of elements in the array is n and n can be obtained using len nums then we want to go from indices 0 to n minus 2 so the total number of indices is 0 to n minus 1 but if you go to the n minus 1 or the last element there is no further element to compare it with okay so keep that in mind that you only want to run this iteration till your pointer comes to this point not till the last element and that is why we check if we put i in the range 0 to len nums minus 1. so the highest value that it can take is len nums minus 2. next we compare nums i with nums i plus 1. so we compare the number with the element that comes after it and if it is greater so that means these two are out of order so then we simply swap them so we set nums i comma nums i plus 1 equal to num i plus 1 comma num psi now this is a very interesting way of sorting in c or c plus plus or java you would have to write three or four steps to swap numbers but in python it's really simple first you say x y is let's say we're saying x comma y are two comma three so you can see they have the values two and three and then we simply write x y equals y x so what happens is the value of y gets placed into x and the value of x gets placed into y it's a single step for swapping two numbers there you go so we swap the two elements exactly what we're showing here swapping the two elements next we repeat this so now we're doing this from left to the penultimate element and in this way we have pushed the largest element to the end now we need to repeat this process n minus one times so that each time we are pushing one of the largest elements to the very end and in n minus one repetitions of these three steps we will end up with a sorted list and finally we return the sorted list and that's it so let's test it out with an example and by the way if some of this doesn't make sense so a simple way to debug it is to add print statements here so you can add a print statement and maybe just print this value so we've used underscore here because we don't actually use this value but let's say we wanted to use this value then we can print that this is iteration j and then inside it you can print that the value of i is i and you can also print the value of nums i and you can also print the value of nums i plus 1 and at the very top you can also print nums now if you add all of these print statements and then execute your algorithm now you will be able to see exactly what is happening inside each iteration so that's a great way to debug your code if you're facing any issues and also understand what the code does but in any case we won't need these so i'm just going to comment these so let's test it out so we get from test 0 we get the nums as input and then we get the output and we can print the input and the expected output and then finally calculate the result by passing num0 into bubble sort and then printing the actual output and finally whether the two match so you can see here now that the input was this unsorted list and then the expected output was the sorted version and that's what we got so in fact there was a perfect match and that's it so we've implemented our first sorting algorithm it was pretty straightforward a few lines of code as an exercise you can try to implement it once again from your memory just write it in plain english first and then try to implement it it's a good coding practice and we can also evaluate all the test cases that we have remember we created about nine test cases and to help you evaluate the test cases we've given you a helper function called evaluate test cases which is part of the jovian library so we installed the jobin library here pip install jovian and then from joven.python dsa so python dsa is the name of the course and that's also the module where we have helper functions for this course import evaluate test cases and evaluate test cases simply goes over the list of test cases that you have and it pulls out the inputs and passes them as arguments to the function provided here which is bubble sort and then gets the outputs and compares the outputs and also prints the information with like what was the input what was the expected output and the actual output and whether they match so let's check it out so you can see here this was test case 0 and that work which we just tested out here's a larger list including some negative numbers this worked as well you can see the test result is passed then you have another list here this seems to work fine too this is already sorted here you have one which is sorted in decreasing order that works here you have one with repeating numbers that works too the empty list works the single element works and this works too this is the same element repeated over and over and finally here is our final test case this had 10 000 elements remember so you can see that this was the expected output and this was the actual output so we have successfully sorted 10 000 elements and that's really the power of programming that without having to look at any of the numbers we've just written four or five lines of code and we've sorted 10 000 elements so all our test cases passed although do look here that it took about 15 seconds for the sorting of 10 000 elements now maybe that's not maybe that's not that bad but we we are looking at probably millions of notebooks every week at jovin so we want there to be a faster sorting algorithm okay so to before we improve the algorithm we need to understand the algorithms complexity and identify any inefficiencies now the core operation in bubble sort if you look at the code here once again is this operation of comparison so we're comparing a number with the next number and swapping now comparison almost always happens and swapping doesn't happen nearly as often so if you want to find the time complexity and we want an upper bound or the worst case time complexity we can assume that roughly every comparison also leads to a swap in the worst case so if we just count the number of comparisons as a function of the input size the size of the list that was given as an input that should give us an idea of the time complexity okay so here we can see that there are two loops and the length of each loop is n minus 1 and inside the inner loop there is a comparison so the total number of comparisons is n minus 1 times n minus 1 which is n minus 1 square or n square minus 2 n plus 1. now expressing this in the big o notation which is to get a rough idea of how the number of comparisons or the number of operations in the algorithm grows with time we can ignore the lower order terms like 2 n plus 1 so we can now conclude that the time complexity of bubble sort is order of n square and this is also known as quadratic complexity so we can now verify that bubble sort requires order one additional space that this is an exercise for you but here's a quick hint you can see that we are not allocating any new lists we did create a copy of the list but we didn't have to so let's not count that but apart from that there is no additional space that was required here we're not allocating any new variables we are creating this range but remember i mentioned that a range simple simply contains a single variable inside it which it keeps incrementing for a for loop so we have these two ranges so maybe we have two variables assigned so it's constant irrespective of the size of the input and that's how bubble sort requires order one additional space now you may be asked about space complexity and this is where it's a slightly tricky thing because sometimes strictly speaking space complexity also includes the size of the input because to store n numbers or n elements you need n spaces in memory so the space complexity of bubble sort in that sense is order n and this is something you can check with the interviewer if they're asking you what is the space complexity and you can ask them if they just want to know what is the additional space required so the overall space complexity is order n because we need to store the actual input list somewhere but on the other hand the amount of additional space required is order one which is a constant factor independent of the size of the list so that's that's how bubble sort works now analyzing this order n square complexity and keeping in mind that a list of 10 000 numbers takes about 12 seconds so if n is 10 000 and n square is multiplied by some constant is about 12 seconds then if you had a list that was of hundred thousand elements so that would be 10 n whole square or 100 times the same amount of time that it would take to sort it so that means it would take about 20 minutes to sort 100 000 numbers which is i would say is a bit inefficient now and a list of a million numbers would take close to two days to be sorted in python now if you do it in c plus plus maybe it might be uh four or five times faster but again the moment you go from a million to ten million well that will actually end up taking a year or so and that's bad and that is why n square or quadratic complexity is something that we would like to do away with because it grows very fast as soon as you hit maybe a ten thousand or a hundred thousand elements then it starts taking longer than a few seconds or a few minutes or a few days and at that point you can no longer use that particular algorithm so we need to optimize bubble sort and the inefficiency in bubble sort comes from the fact that we are shifting elements by at most one position at a time so each time we go through the list we capture some information about the list but we are simply moving one element from left to right so to speak and each time we're just moving it one at a time by doing swaps rather it would be nice to just place elements directly maybe a few positions ahead and that's where we will look at some optimized algorithms now another common algorithm that is used is called insertion sort and this is here is the code for insertion sort so you can look through the code for insertion sort here and here is an example you can see how it works and we will not look into insertion sort in a lot of detail but roughly this is how you arrange cards in your hand which is by starting to move cards around so that at the maybe on the left edge you have sorted cards on the right edge you have the unsorted cards and you keep moving the new cards into sorted positions that's how it works so here's an exercise for you go through this function read the source code and then describe the algorithm in plain english now reading source code is an essential skill for software development this is something that you'll have to do in your work whether you're doing software development or data science maybe because there are no comments in the code there is no documentation or the person who has written the code is not available or has left the company or this is some open source library so in all these cases you will have to read and understand code so read it and then describe insertion sort the algorithm in plain english then look it up online and see if it matches what you've written and then second is to also determine the time and space complexity of insertion sort and see if it is any better than bubble sort and explain why or why not so these are a couple of exercises for you so that's bubble sort and insertion sword now before we continue i just want to recall you that this is a jupiter notebook running on an online platform hub.binder.joven.ml and since this is free it will shut down after some time so you want to capture snapshot of your work at regular intervals and that's where you can use the jovian library so you install the joven library using pip install jovian import jovian and then run jovian.commit now when you run jovi.com it captures a snapshot of this jupyter notebook and puts it on your jovian profile so now this will be your profile when you run juvenile commit and you will be able to resume your work by clicking the run button on this page anytime and this notebook will go to your profile so you can just click on your jovian profile or just click home here and if you check either the overview or the notebooks tab you should be able to find your notebook here like here you go okay coming back now we're at step 6 where we want to apply the right technique to overcome the inefficiency in the algorithm now to perform sorting more efficiently we will apply a strategy called divide and conquer and divide and conquer is a very common strategy used across the board for many different kinds of algorithms and it has this general steps that is applied in different different ways across different problems so step one is to divide the inputs into two roughly equal parts okay they don't have to be exactly equal but two roughly equal parts and the idea here is that those two parts can themselves be used as inputs as sub problems so then we use recursion so we recursively solve the problem individually for each of the two parts so here you have a problem you have created two sub problems out of it and then you call recursion so the recursive solution itself will use divide and conquer and then keep going and so on uh but once it gives you the solution combine the results to solve the problem for the init for the original inputs okay so you have now results of the sub problems and you combine them you get back the final result and then the only last thing you need to know is because you're going to keep calling this keep doing this division recursively so if you have an input of size 100 you will call the same function on inputs of size 50 and 50 then you will call the same function for each of those 50 you will call the same function on inputs of size 25 and 25 so each half and as you keep going you will eventually end up with small or indivisible inputs and that is where you can solve the problem directly and include terminating conditions so that's where the recursion stops okay so you include terminating conditions for small or indivisible inputs so that's divide and conquer you take the problem divided into two sub problems recursively solve the sub problems get the solutions of the sub problems and then combine them so you can also call it divide conquer combine in some sense and merge sort is the algorithm that is the classic application of divide and conquer to the sorting problem so let's take a look at merge sort by looking at an example visually so here we have a list that needs to be sorted in increasing order so remember step one divide the problem into two sub problems so here we have half the list a little more than half here we have another half so we have split it into four elements and three elements then we take we call recursively we call the same sorting problem the same algorithm on these two so we split 38 and 27 into one half and 43 and three into another here 982 becomes one half and 10 becomes the other again we can split 38 in 27 we can split 43 and 3 980 to 10. so now we've ended up with single elements so with recursion we've ended up at this terminating condition we can no longer split the list so now we start combining the problems now if you're looking to sort a list with just one element 38 well that list is already sorted so you can return that and 27 is already sorted the single element so you return that now we have these two sub lists and we need to combine them each has one element so we can simply compare these two elements and we can tell that 27 comes first and 38 comes second so that's how you combine these two results to get 2738 then similarly with 43 3 you combine them to get 343 and you get 982 and 10. next you can combine these two results so this is where now the combination is important okay we need to look through and we can probably tell that 3 should come first and then 27 and then 38 and then 43 so we've combined them here and similarly here we've combined 9 10 and 82 and then we take the final results these two final lists and then we combine them back to get the fully sorted list okay and we'll talk about this combination or what is called the merge operation in a lot more detail soon but this is roughly the idea here you keep splitting it into half and then you combine the halves so let's now state it in plain english so first the terminating condition if the input list is empty or contains just one element then it is already sorted return it if it is not divide the list of numbers into two roughly equal parts then sort each part recursively using the merge sort algorithm and by the power of recursion you will get back two sorted lists then merge the two sorted lists to get a single sorted list and this is the key operation here and this is why it's called a merge sort because we are always merging sorted list and making bigger and bigger sorted lists out of them and the merge operation is something that you may be asked to write in an interview or a coding challenge apart from the whole merge sort operation itself so this is something that you can try to explain yourself so try to think about how the merge operation might work and explain it in your own words here is some space for you but let's jump into the implementation of merge sort then now we will implement merge sort assuming that we already have a helper function called merge and this is a very useful trick where your program may need some complicated piece of logic or some logic which you have not figured out yet so all you do is assume that you already have the function and write uh use it first and then implement it later so here's a merge sort algorithm so now we have the merge sort algorithm and we have numbers here given as an input to merge sort now here's the terminating condition if the length of numbers is less than equal to one which means if the list is empty or has just one element return the numbers then if not then get the midpoint so return length of numbers divided by two and remember using the double slash here because a single slash would return a decimal and we cannot use a decimal as an index or a position in the list so that's why we're using the double slash here so we take the length of numbers divided by 2. so if the size of the list is 10 so we get back five here then we split the list into two halves and here's some interesting syntax for you and let's look into what the syntax actually means so let's say you have a list so this is the list we have and let's say mid has the value well we can check it here one two three four five six so six elements by two mid has a value three now let's check x of mid what does that give us well that gives us one three five well actually x of colon mid means x of zero to mid and x of zero to mid means all the elements from position zero till before the position mid so that's very important once again it's like a range so you get the indices at position zero one and two not at position three okay so that gives us these three elements then let's check the other thing x of mid colon now what this gives you is this gives you the elements starting from the position mid all the way to the end so you can also write here minus 1 or we can also write here len of x minus 1 but or we can just skip it and python will automatically interpret that you want all the elements starting from mid to the end that is twelve five and one so positions three four and five and hence to split the list all we need is to invoke this one three five and twelve 1251 we get back two parts of the list so this is a nice thing about jupiter whenever you don't understand a line of code just create a cell above or below and try out a simple example so now we have the the left half num zero to mid and then the right half so numbs mid colon now here's where the magic happens we call the function recursively so we call the merge sort function itself so because we call merge sort on left and that gives us back a list a sorted list for the left half called left sorted and then we call merge sort function right and that will give us back a sorted list called write sorted and then we combine the results of the two halves by calling the merge operation so we now we are now saying that we want to merge left sorted and right sorted to get back the final sorted numbers and then we return the sorted numbers so that's merge sort so yeah it's almost seems like magic but it's pretty small pretty straightforward only about four or five lines of code if you combine some of these lines so then let's come to the merge operation because that seems to be the meat here right this is the only missing piece so to merge two sorted arrays what we can do is we can repeatedly compare the two least elements of each array and copy over the smaller one into a new array so here's what that process might look like let's say you have these two parts one four seven and zero two three and we want to get this sorted list and notice that these are both already sorted because these are the results of the recursive calls to merge sort so we keep a pointer on the left on each one so here we have the pointer at one here we have the pointer at zero we compare the two we take the smaller one and put it in the list how do we know we can put it because if this is smaller than this all these numbers are also greater than 0 and then since 1 is greater than 0 and all these numbers are greater than 0 are greater than 1 so that follows that all the other numbers to the right of 1 and to the right of 0 are greater than 0 and hence 0 should come in the first position so we put it there and advance the pointer now you can see here now we can compare one and two and this time one is smaller and you know that all the numbers here are greater than two so they're also greater than one and then all the numbers here are also greater than one hence we know that one is now the next largest number so we can now put in one and advance the pointer and keep going this time now you compare two and four so now you can put in two and advance the pointer now you put in three and then advance the pointer and at some point you will exhaust one of the lists and when you exhaust one of the list then you can stop comparing and you can simply copy over the remaining elements so we can now copy over four and seven and we've exhausted this list and we get back the sorted merged array zero one two three four seven so it's really simple it involves each step involves one comparison and incrementing one pointer so you're either incrementing this pointer or you're incrementing this pointer okay so let's now define the merge operation and you can see the benefit now of assuming that the function already existed now we do not have to worry about the actual sorting and recursion etc we simply have to worry about merging two sorted arrays so first we will create a list to store the results and we have nums 1 and num2 the two left and right list that we are going to combine then we are going to set up two indices or two numbers for iteration the two pointers on the two lists and we set up each of them at position zero so each of them are currently at position zero here and we loop over the two lists so we say while i less than len of nums one and while j less than len of nums 2. so if you have four elements in the left list then i can go from zero to three all four positions and if you have five elements in the right list j can grow from zero to five zero to four all five positions then we check and and we remember we want to make sure that both of these indices are valid if any of those have reached the end then you want to skip and we can simply copy over the remaining list right so as you see here as soon as we reach this point there's no more comparisons to be made so we can exit the loop so now we check which one is smaller so if we if norm's one i so the left list current element is smaller than nums to j then we append to the merged list num1i as we did here and we increment i so this is exactly what we've done here so we put in well let's say here so we put in 1 here and we increment the left pointer on the other hand if that's not true we append the element from the right so nums 2j and we increment the right pointer so in each case in each while loop we are incrementing one of the pointers and then when the while loop ends one of the lists would have been exhausted that's when the while loop ends so we can get the remaining parts of both the lists so we can get numbs1 i colon will get the remaining elements from the first list the left list nouns 2 j colon will get the remaining elements from the right list but remember since one of them is exhausted so one of these two is going to be empty right now we we can check which one is empty and simply add the remaining one but here's a simpler solution we just add both of them to the merged array so we append both the lists at the end and this automatically takes care of the empty case if the left side becomes empty then this adds nothing to the merged array and this adds the remaining numbers from the right side if the right side becomes empty then this adds the remaining numbers from the left and left side and this adds nothing so that's a small trick so that's the merge operation again not very difficult if you have any questions is take this out into specific cells and try it out with examples and you should see it working let's try out the merge operation now so here we have two sorted lists you can see here and there you go you can see that this is now arranged all these numbers are now arranged in a sorted order so now we have the merge operation and we have the merge sort operation so we can now test out the merge sort function so we get the first set of inputs and outputs from test 0 and you can see here that this is the input and this is the expected output and this was the actual output as well now let's test all the cases using the evaluate test cases function from jovian so here we're simply going to call evaluate test cases on the entire list of test cases and you can see all the test cases seem to be passing now if one of these test cases had failed what you should go do is you should go back and add some print statements inside your merge function or add some print statements inside your merge sort function the right places to add the print statements is right after the function definition right after in the body of the function it can be the first statement and then inside each loop so inside each loop whatever are the changing parameters you should print them inside the loop and then finally you can also print the return value of the function so in this way you can build a full picture of what the what your function is doing and that makes it much easier to solve issues so test cases and print functions make it easy to fix errors in code and don't worry if there are there are always errors in code what's important is you should be able to find a way to fix them easily and without test cases or without printing you may get stuck and you may just keep staring at the code and trying to figure out what exactly went wrong so please do that now one last thing i want you to notice is here the execution took only about 50 milliseconds on the other hand remember bubble sort took about 15 seconds to sort ten thousand numbers so that's mer sword is much much faster right a millisecond is point zero zero zero one ten to the power minus three seconds so in a second you can probably sort two hundred of two hundred list of size ten 10000 and that's what makes merge sort so much more powerful and because it is so much more efficient and as we analyze the complexity you will learn that merge sort is in fact more efficient in terms of the bigger notation as well so let's analyze the algorithms complexity and identify if there are any inefficiencies now analyzing recursive algorithms can get tricky and that's where it helps to track and follow the chain of recursive calls so what we'll do is we will add some print statements to our merge sort function and our merge function so we'll simply see what the merge sort function was invoked with okay so we'll add a print statement inside merge and we'll add a print statement inside merge sort both of them and we are also tracking something called a depth to track the chain or the depth of each recursive call and you'll see what i mean in just a second okay so this is what it looks like we called merge sort on this big list of elements unsorted and that merge sort internally led to two calls of merge sort so you can see this one here and this one here so you have two calls to merge sort one with the left half of the list and one with the right half of the list and they're unequal and these two merge sorts finally returned merged lists and we finally called a merge operation on the two of them you can see that this is the merge operation the final merge operation called here on the two merge sort lists and this merge operation is working with these two sorted lists okay so we can see that each merge sort invokes the itself invokes merge sort twice but this time with an area of half the size you can see merge sort was invoked with arrays of or lists of half the size and it also invokes the merge function once to merge the two resulting arrays the two sorted arrays now the two calls to merge or if you observe closely they themselves make two more calls to merge sort and one more call to merge and then those internal calls make two more calls to merge sort and one more call to merge and so on till we end up with single elements at which point merge sort simply returns that single element so the merge sort algorithm ultimately points down to a series of merge operations you can see here that each merge sort all it's doing is calling merge sort internally and then calling a merge operation so ultimately what we are doing is we are first merging 5 and 12 and then we are merging 2 and 6 and then we're merging minus 12 5 and 2 comma 6 and then we're merging 123 and we're merging 7 minus 12 and then we're merging 7 minus 12 7 and finally we're merging 1231277 and then finally we are merging the big list right so it's ultimately just a whole bunch of merge operations and if you look inside the merge operation this is where a comparison is happening and this is where this append step is happening so we are comparing and appending so those are the two key operations here and with every comparison there is append so if we simply count the comparisons once again that's happening that should be enough to get the time complexity and what is the number of comparisons that's happening well that's straightforward too if you have two lists nums one and nums two each and the total length of the two list is n so because the size the number of iterations is equal to in the in the worst case it would be equal to the lengths of the two lists combined so you may have to first maybe increment i by one then increment j by one then once again increment i by one and j by one so the total number of iterations here is len of numbers 1 plus len of norms 2 right but remember the merge was called if merge sort was called with a list of size n then merge was called with a list of size n by two and n by two roughly so the total list the total length of nums one plus nums two is actually the overall length n so that's the real trick here that merge the merge operation is an order n operation where n is the number of elements the total number of elements okay so this merge operation takes four plus five nine comparisons and this merge operation takes five comparisons and this merge operation takes three comparisons and so on now this way now if we visualize a problem now as a tree where we're calling merge sort with nl with n elements and that ends up calling merge sort with n by two elements and that ends up calling merge sort with n by four elements all the way down and then we start merging so here when we get to individual elements we are calling merge with literally single elements and as we come up here we are calling merge at this point we are calling merge with elements of size n by eight and n by eight but we are calling merge eight times so now each of these sub problems makes a call to merge and each of these sub problems has the list size n by eight so you have eight calls to merge of size n by eight so the total number of comparisons done is n and at every stage you can check this at the top level uh you are calling merge with n total elements so the total number of comparisons is n at the second level you're calling merge here once with n by two elements and you're calling merge here once with n by two elements so the total number of comparisons is two times n by two that's n and here you're calling merge with n by four elements four times so that's n so if the height of the tree is h then the total number of comparisons is n times h right so on each level you'd require n comparisons for the merge and you call merges at every level for each of these sub problems so the height of the tree is so the total number of comparisons is n times h now how do we get the height of the tree if the height of the tree is h and you can see here that as we go down this is level zero and it has one element this is level one and it has two elements this is level two and it has four sub problems and this is level three and it has eight sub problems so level k has two to the power k sub problems so if you keep going down this is level h minus one so level h minus one should have two to the h minus one sub problems but remember at the last level we simply we simply have sub problems or merge merge calls with single elements so that means we have a total of n elements here or n leaf nodes here so it follows that 2 to the power of h minus 1 is n okay so i'll i'll let you think about that in reason with that now this is something that you may have to work out on pen and paper to get correctly that if the height of the tree is h then 2 to the power h minus 1 is equal to n because at the bottom most layer you have n leaves in the tree so it follows that h is log n plus one so since we said that there are n times h comparisons and h is log n plus one so it follows that the complexity of merge sort is n log n and that's a big improvement from n square it may not seem like much but it is so n square for ten thousand is ten thousand times ten thousand but n log n for ten thousand is ten thousand times 12 or 13 log to the base two so that's about a few hundred times faster now even for an array of a million elements it will only take a few seconds to be sorted and you can verify this by actually creating a list of a million elements okay so the complexity of merge sort is n log n and you get it by drawing this sub problem tree and realizing that there are you get a sub problem tree of height log n or log n plus one and at each step you perform a merge operation or multiple merge operations totaling to n comparisons so so n times log n is the complexity of merge sort now here's also discussion about space complexity and this is something that i believe is an exercise for you so do read through this and see if you can reason why the space complexity of merge sort is order n okay so time complexity is order n log n and the space complexity is order n but here's a hint why it's order n you can see that inside the merge operation we are creating a new list and then we are copying over elements from each of the two lists into the new lists so we are allocating a new list inside merge and now it's so now that's no longer constant that list will have the same size as the size of the problem itself and hence roughly that's why the space complexity is order n okay so with that we conclude our discussion of merge sort it's a divide and conquer algorithm you split the list into half recursively sort both of them then merge the two sorted lists and the initial condition is one or zero elements now there are several extensions and variations of merge sort called the k way merge sort where we split not into two parts but into k parts then we have the counting inversions problem where we modify merge sort a little bit to also find some other info information about the list and finally we have hybrid algorithms which combine merge sort and insertion sort so what they do is for smaller lists they use insertion sort because that's more efficient and then for bigger lists they use merge sort so as they're splitting the list when you get to a small enough problem let's say 10 or less elements they use insertion sort and that brings us to our next question where we make one level of optimization and then we stop but here we will go one step further what we do is we will apply an another technique to overcome the inefficiency in merge sort now the time complexity is pretty good you can actually sort millions or even tens of millions of elements with merge sort quite reliably but it's a space complexity that causes a problem now because merge sort requires allocating additional space and that is additional space is as large as the input itself that makes it somewhat slow in practice because memory allocation is more expensive than computations so doing a comparison is very easy you just tell the cpu to compare two things in the memory or swapping them is also easy because you're still working with memory that you already have but when you have to allocate new memory you often have to then request the operating system uh to allocate the new memory and then you have to get its address and do a whole bunch of operations so it's let's say an order of magnitude more expensive than simply doing some computations so you should try and avoid memory allocations as far as possible now one or two variables is fine but if you're dealing with a million elements so you're probably going to need maybe a few mb of additional space and that is what may slow down your algorithm a little bit it would still be n log n but the constant factor now the cost of each operation will be higher because it involves an allocation now to overcome the inefficiencies the space efficiency of merge sort we will study another divide and conquer based algorithm sorting algorithm and this is called quick sort and quick sort the array in place which means it does not create a copy of the array internally for sorting inside each operation inside each combination operation so let's see how it works it's a pretty interesting a pretty smart trick so here's how it works if the list is empty or has just one element return it it's already sorted straight forward then pick a random element if not pick a random element from the list now this element is called a pivot now there are many strategies for picking a pivot one is to pick a random element one is to maybe pick the first element the last element what we'll do is we will pick the last element but you can easily augment our implementation to pick a random element and then reorder the list and this is the key operation here reorder the list so that all the elements with values less than or equal to the pivot come before the pivot element while all the elements with values greater than the pivot come after the pivot element and this element is called partitioning you're partitioning the array around the pivot so here's an example you let's say we take three as the pivot element the final element now what we want to do is we want to reorder the elements and the way we reorder is by doing swapping and comparison in whatever way we can and that's what we will really focus on the partitioning algorithm and you reorder it in such a way that all the numbers to the left of the pivot are smaller than it and all the numbers to the right of the pivot are larger than it now here's the key observation here once you do that you can tell that all these all these numbers can now be sorted independently and none of the numbers from here will move to the right of pivot and similarly all these numbers can also be sorted independently and none of the numbers here will move to the left of the pivot so the pivot is in the correct position in the final sorted array so it's now in its correct final position and you can simply call quick sort on this half or less than half this portion of the array and this portion of the array and there's no real combination required anymore right so because we're doing it all in place we simply call quick sort on each side of the array and once this gets sorted and this gets sorted recursively then you will have end up with the entire sorted list right and that's what that's how we then continue doing the process recursively now on the left half you once again pick a pivot and then you arrange the elements around the pivot on the right half you once again pick a pivot and arrange the elements around the pivot and so on and so on okay so as i said the key observation here is that after the partition the pivot element is at its right place in the sorted array the two parts of the array can be sorted independently in place now maybe once again take pen and paper and try to work it out yourself again all of this makes a lot more sense when you actually put it down and solve a real problem as a real example so here's an implementation of quick sort and once again we will assume that we already have a helper function called partition which can pick a pivot partition the array and return the position of the pivot element for the next quick sort step okay so this entire process going from here to here this is where we'll assume that we have a function and write the quick sort algorithm and then implement the partition function so here's what quick sort might look like now quicksort takes a bunch of numbers and apart from the numbers it also takes a start index and an end index now why are we doing this remember we want to avoid creating copies of the list that's the whole pro that's the whole thinking here the line of thinking so we will call quick sort not with a sub list which is which is a copy of a portion but we will call quick sort simply by changing the by passing the same original list but by changing the start and end index okay now there is some code here if end is none then we are sent setting end to the length of the list minus one and here's one more thing that we're doing so the final invocation to quicksort that we'll make will be something like this we may call quicksort let's say there are a few numbers here so we may call quick sort on a list something like this and in this case automatically start will have the value 0 and end will have the value none now remember the quick sort is going to sort the array in place but we also said that we don't want to modify our test cases so here's one assumption we are making that if end is none which means if quicksort is called just with the just with the list then we'll create a copy of the list right so we'll just create one copy at the very beginning right when the list is passed for the first time and then we will not create any more copies and you can even skip this line entirely but the only trouble is that we'll start changing our test case input so that's why let's keep it and let's keep a copy but this is only done at the very top level right so only when we start we create a copy so that we're not modifying the input list but never again so that's what we're doing here creating a copy if uh quick sort what was called with the list and setting end to len nums minus 1 which is the final valid index in the list anyway putting this aside this is the real condition here so if start is less than end which means let's say here you have start and here you have end now if start is less than end that means you have two or more elements right if start and end are equal that means you have just one element and if start is greater than n that means you have zero elements really so if start is less than n that means if you have at least two elements then we call the partition function we call the partition function on nums and we say that we want to partition the region start to end so let's say this is the region start to end we want to partition it so we want to pick a pivot and then partition it in such a way that elements to the left of the pivot are smaller than it and elements to the right of the pivot are larger than it for example if you want 4 to be the partition element 4 to be the pivot element then we will partition the array as 3 comma 4 comma 5 comma 23 so that 3 is smaller than 4 and 523 are bigger than 4 and we will return the position of the pivot element okay so now you partition the array and return the position of the pivot element so this is the position we get back and then we can call quick sort on this region and on this region so we can now call quick sort on start to pivot minus one and we can call quick sort on pivot plus one to end okay so now we are passing actually explicitly passing in values for start and end so this will not kick in the next time so no more copies of the list will be created so all the recursive calls will keep modifying in place so all the even the partition call will modify in place and we'll see how partition works in just a moment so partition gets the slice of the original list and it returns the position of the pivot element then we call quick sort on the left slice which is before the partition the element smaller than the partition and then we call quick sort on the right slice which is elements that come after the partition okay now here is how the partition operation works it's pretty straightforward too not that difficult so what we'll do is we will pick the final element as the pivot element but if you don't want to pick the final element you want to pick a randomized element well just pick a random position and move that element to the final position and that's as good as picking the final element now so random pivot simply involves picking an element moving it to the final position but assuming the pivot is in the final position we then keep two pointers left and right now remember we want to create we want to push all the numbers smaller than the pivot to the left and we want to push all the numbers larger than the pivot to the right okay and what we'll do ultimately is we will arrange them in such a way that some of these are smaller than the pivot and some of these are larger than the pivot and then we'll move the pivot between them so we'll see how to do that so you have the left pointer and the right pointer now here's what we do inside partition while these two pointers are far away from each other first we check if the element at the left pointer is smaller than the pivot well if the element at the left pointer is smaller than the pivot which it is you simply advance the left pointer forward so this goes to 5 and then we go back to the next loop now this time once again we check if the element that the left pointer points to is smaller than the pivot 5 is not smaller than 3 5 is greater than 3. so if that is the case then we check if the right pointer is greater than the pivot now if the right pointer is greater than the pivot that means this number is in its right position it's greater than the pivot so we move the right pointer back one space okay so that's the operation we just did now once again we check is the left pointer smaller than the pivot no it's not is the right pointer greater than a pivot no it's not so that means these two numbers are out of place right we ideally would want this to be smaller than the pivot and this to be larger than the pivot so we swap these two elements so now zero comes here and phi comes here now once again we can check is 0 the left pointer smaller than the pivot yes so move the left pointer forward then we is the left pointer smaller than the pivot no 6 is now greater than 3 so we check is the right pointer larger than the pivot yes so we move the right pointer forward because five is still in its correct position it's you know on the on the right edge and everything is greater than three so now once again we end up in this position that the left element is smaller than the is larger than the pivot so we check the right element the right element is smaller than the pivot we want it to be larger so we swap these two because these two are once again out of order and now you can see that one zero two are all smaller than the pivot and six five eleven are all larger than the pivot so we do one final check is two smaller than the pivot yes so we advance the left pointer and now both of the pointers are at the same position so now we can tell at this point that here or from this point position onwards all of these numbers are larger than the pivot so we simply simply swap this element with the pivot so there you go so you end up with one zero two three five eleven and six okay so that's the partition operation so again to understand it yourself do it on pen and paper write out write down write out this array create the pivot create the left pointer right pointer and keep creating copies of the array for each step of the loop okay and that's how you understand these things it's not that difficult it's just it involves two pointers so it's a little tricky now this is the code for partition and i will let you follow this code we'll go over this briefly but at by this point since we are halfway into the course now you should be able to read the code and then there are also comments here and understand what we have just discussed in plain english understand that in terms of code okay so one exercise for you is to explain this visual approach in plain english step by step and then the second exercise for you is to read the code and understand it or maybe even try to write it from memory so just take the english description and try to write the partition function from your memory not memorize the code itself but convert the english text into code okay so once again here you know we have the nums the numbers that need to be partitioned the start and the end and if end is none we simply set end to the last index which is len nums minus one then we initialize the start and end pointers so we initialize the left and right pointers remember we want to use the end element so this is the end element so we want to use the end element as the pivot so the left point the left pointer is start and the right pointer is n minus 1 that's what we that's what we've set here and then white while the right pointer is greater than the left pointer we increment the left pointer if the number at the left pointer is less or equal to the pivot we decrement otherwise we decrement the right pointer if the number on the right pointer is greater than the pivot otherwise the two of them are out of place and they can be swapped so we swap them here and finally we place the pivot in place between the two parts and that's it that's exactly what's happening here so let's see here let's see this partition we are taking this list and we are calling partition on it and 3 is the number that was used as a pivot so now 3 ends up here in between so you have 1 0 2 and 5 11 6. and the partition function returns the position of the pivot so now you can see how it is used in quick sort the partition function returns the position of the pivot and then we call quick sort on the left partition before the pivot and on the right partition after the pivot so now we can test out quick sort okay and here's another exercise for you add print statements inside the partition function so there are already some print statements you can simply uncomment them uncomment the print statements to display the list the left pointer and the right pointer and the beginning at end of every loop to study how partitioning works and similarly you can also add print statements inside the quick sort function to study how the recursive calls are going on so study what we've done in merge and merge sort and add the same print statements in quick and quick sort and look at these recursive calls now what you want is to have a completely clear and perfect idea of what your code is doing you don't want to be lost about it and that's why adding print statements and looking at small examples and making sure that it's working perfectly really helps so let's look at quicksort in action so here's an input and here's the expected output and here's the actual output and they match great and we can now evaluate all the test cases using the evaluate test cases functions for function from jovian so we import from juvenile python dsa evaluate test cases and call evaluate test cases here and you can see that it passes all the test cases and not only that you will also notice that it is marginally faster than merge sort for sorted lists sometimes you may not see that but yeah you can see here that it's you will see that in most cases quicksort is marginally faster than merge sort for larger list and that's because it is not allocating new space okay so now coming to the time complexity for quick sort now assuming that we are able to have a good partition each time so each time we are dividing the list into roughly equal halves roughly equal parts like you start with a list of size n and you partition it into n by two and n by two so this is what the sub problem tree looks like so you call quick sort with two lists of n by two n by two then you call quick sort with four lists of size n by two n by four n by four and so on now what is the activity that we're doing inside quick sort in each quick sort the core operation is partition right and that's what puts one element the pivot element into its right place and then the element smaller than it to the left of it the elements larger than it to the right of it so the partition is where the actual work the comparison and swapping happens and how many comparisons do we perform in the partition i would say that the number of comparisons is equal to the size of the actual list and you can see that here you can see that we are going on comparing numbers like this we are comparing each number to the pivot so each number gets compared to the pivot exactly once roughly and that means that there are a total of n comparisons if n is the size of the list okay so we have n comparison and partition so partition performs n operations or partition is an order n function and what is the height of the tree once again the height of the tree is log n because to go from n to one it takes log n steps you keep going n by two n by four and by eight and so on n by two to the power log n becomes n by n one and so the time complexity of quick sort is n login if you're able to partition the array into roughly equal parts and that is what happens on average if you're picking random pivots each time then you do end up with roughly equal parts maybe it's 75 35 75 25 but that's still more or less in the same range so the quick sort complexity is about n log in and this is called the average case complexity on the other hand if you have a really bad partition and a really bad partition is maybe you picked the smallest element as the pivot now if you pick the smallest element as the pivot then all the elements will go to the right of the pivot and you will end up calling quick sort on a problem of size n minus one and then maybe once again if you pick the smallest element as pivot all the elements will go to the right of the pivot once again and you will end up calling quicksort with a problem size of n minus two now this is an unbalanced t or a skewed tree and what happens in a skewed tree is that the height this time is the same as n you can see n n minus one n minus two n minus three so going up to one the height of three is n but the amount of work involved in partitioning is the same because you have to run through the entire list to partition the list right so that in this case the time complexity is roughly n times n minus 1 by 2. so the time complexity is about order n square and that's bad because that's as bad as bubble sort but despite the quadratic worst case time complexity quicksort is still preferred in many situations now it really depends on what kind of algorithm you need to use and what kind of memory constraints you have because quicksort's complexity is closer to end login in practice especially with a good strategy for picking a pivot and a good strategy is picking a random pivot but there's another one called picking median of medians you can check that out as well so that's n log n is the average time complexity of quick sort and then n square is the worst case time complexity of quick sort now here's an exercise for you verify that quicksort requires order one additional space which means that it does not really need to copy the array we did create a copy because we did not want to affect our test cases but we could have removed that line and quick sort would work just fine so because you do not need to create a copy of the list or the array it requires order one additional space but because space complexity also includes often the size of the space required to store the input so you can say that quicksort has the space complexity of order n okay so if you get the question about space complexity you may want to ask are you talking about the additional space or do you also want to include the input in the space complexity so that's quick sort and those are the two sorting algorithms we've looked at so we've looked at we've looked at bubble sort and we've looked at insertion sort and then we optimized it using divide and conquer and got to merge sort which is order n log n but it also has a space complexity of or the additional space requirement of order n which can be avoided using quick sort which uses order one additional space but can have order n square complexity in the worst case time complexity but with the right choice of a pivot it is closer to n log n so that's sorting and you can see that python is such an expressive language that all these sorting algorithms which are often quite confusing to implement in c plus or java are actually pretty straight forward to implement in python all you need to do is follow the method which is to state it first in plain english have some test cases ready to test your function and then write your code carefully checking each line for errors and create small functions wherever you need to so try not to have too much logic in one function a good rule of thumb is about seven to eight lines of code per function no bigger than that and that's not just for toy problems but that's also even as a software developer something that you can try to follow just have seven eight lines of code in any function if you have more than that try to split it into two functions okay and and this way it's very difficult for you to go wrong so now let's return to our original problem statement and let's read it once again you're working on a new feature on jovian called top notebook of the week or top notebooks of the week and write a function to sort a list of notebooks in decreasing order of likes now keep in mind that up to millions of notebooks can be created every week you want to build this for scale so your function needs to be as efficient as possible so first we need to sort objects this time and not just numbers and second we also want to sort them in the decreasing order of likes for each notebook okay so all we need to do is to use our merge sorter quick sort techniques that we've already discussed is to define a com custom comparison function to compare two notebooks okay but before we do that we let's create a class that can capture some basic information about notebooks so here we have the class so we're still following the method so to speak right the step one was to come up with the input and the output format so here is the input format our input format would be using this class so we create creating a class notebook which is titled username and likes so you create the class and that gets stored as properties titles username and likes and then we also have a string representation here then create some test cases so now we are creating some test cases here so we are creating some test cases in nb0 to nb9 and let's put them all into a list and you can see here that we now have a list of notebooks nb 0 to nb9 and you can see that because we have a string representation we can see that the first notebook is this our caution slash pytorch basics and it has 373 likes and the second one is this and it has 532 likes and these are clearly out of order in terms of likes next we will define a custom comparison function for comparing the two notebooks what it will do is it will return the strings lesser equal or greater to establish the output order between the two objects okay so it should return lesser when nb1 should come at a position or a index lesser than the position of nb2 in a sorted list okay so in in in case of our problem what that means is we want to sort things in the decreasing order of likes so the first notebook should have the highest number of likes and then maybe the second notebook should have the second highest number of likes and the third notebook will have a lower number of likes and so on so if you have two notebooks nb1 and nb2 and if nb1.likes is greater than nb2.likes so then nb1 should come at a lesser index okay so we will return lesser because it should come at a lower position in the sorted list so we return lesser because we want a decreasing order and if nb1 dot likes is equal to nv two dot likes then we return equal and if nb one dot likes is less than nb two dot likes so that means this is not uh is nb two is the more like notebook and bit one is the less like notebook then nv1 should actually come at a greater position so we will return greater okay so this is this comparison function should return whether the first input to it should come up should show up at a lesser position in the sorted list compared to the second input now in languages like c plus plus and java normally the convention is to return a negative number zero or positive number but i find that python allows you to return strings strings are firstclass citizens in python and it's a lot clearer when you are debugging things when you face issues to look at actual strings and it's also easier to write write code so i prefer using strings but you can also use you can also use numbers like negative zero or positive that's totally up to you so now here is an implementation of merge sort which accepts a custom comparison function so let's see the merge sort function so the merge sort function uses it takes a list of objects this time not a list of numbers and it also takes a compare function which by default we also provide a default comparison so that we can still use it with numbers now with numbers and default assumption is if you want sorting you want sorting in increasing order so this is what the default sorting looks like for numbers so that's pretty straightforward but you can also pass a custom comparison function so here we have the terminating condition if the length is less than 2 then we simply return the list then we get the mid index and then we call merge sort on the left half with the custom comparison function we call merge sort on the right half with the custom comparison function and we call merge with the custom comparison function now what happens inside merge inside merge earlier you know once again we have these two halves left and right and then we have a custom comparison function so we create pointers for the two of them and then we also create the final result list which is merged and then we iterate over the left list and the right list so while we are going through these we compare the left element and the right element so now we're calling compare now we're not doing the greater than less than comparison calling compare and if the result if the element on the left is lesser or equal to the element on the right then we append it to the result array and we increment the left counter otherwise so lesser or equal means that the element on the left the first element on the left should show up at a lower position in the sorted final sorted list so that's why we append it first otherwise we append the right child to the right element and we increment the right pointer and finally we attach any remaining elements here so this is something that you can review something we've covered in a lot of detail so now let's see let's call merge sort on our notebooks and let's check if the notebooks are sorted by likes and indeed they are you can see that at position 0 you have the notebook with the highest number of likes and then you have the next one and the next one and so on now since we have written a generic merge sort function that works with any compare function we can now very quickly use it to sort the notebooks by title as well or if we had maybe the number of views per notebook or the number of versions in each notebook or the number of comments on each notebook we could do that sorting as well so we could even use a hybrid of those so here the example we're taking is comparing by titles so here we have nb1 and nb2 and simple comparison strings can also be compared using the comparison operators so if nb1 dot title is less than nb2.title then we return lesser otherwise we return equal or greater and with this we should be able to sort them in the ascending order of titles you can see a n c i c i f e l i l o p y p y okay p y t h p y t h p y t o by torch okay so this is an order sorted in the order of titles an exercise for you is to sort in the order of username slash title which means you first compare the username and if the usernames are equal then compare the titles so you can compare you can probably write another comparison function compare username and titles and use that to do that twolevel comparison and use that for sorting okay now another exercise for you going forward is to implement and test the generic versions of bubble sort insertion sort and quick sort using these empty cells that are given here right so at this point in the course you should start writing code you should be writing maybe solving one problem every day to really practice the concepts and internalize them and while you're doing that you can also any problem that you work on any notebook that you create you can save it to joven.commit and i'll show you also how to create new notebooks so one way to create new notebooks is to go to jovian joven.ei click the new button and click blank notebook and you can give it a title let's say you are doing quick sort generic and you can set up privacy and create a notebook and that creates a notebook for you and then you can click the run button and run it so that's one way to do it another way you can do it is we've given you a problem solving template so if you come back to the lesson page you will find a problem solving template here now you can click on the problem solving template and click duplicate to create a copy of this notebook in your profile so let's do that and now this is on your profile so you can now click run and then run it on binder or you can even run it locally on your computer and make some changes to it and come back and run jovian.commit and you will end up with a link that you can share so now you can now go on twitter and you can just share this link so write out a tweet and tag us and also use the hashtag 60 days of python okay and maybe say this is your quick sort algorithm for generic objects and tweet it out and we will retweet your tweet so we want to support everybody who's taking part in this course on the course page you will find a link to the course community forum which is where you can go and ask questions where if you have questions about any of these and you can even discuss some of the ideas that are discussed here some of the exercises that are shared so you can go into lesson three for instance and create a new topic maybe you want to talk about the generic implementation of quick sort so maybe you can create a new topic and post a query there if you're not able to make it work post your notebook there and ask a question have a discussion and if you are helping other people out if you are answering other people's questions and you've written some really great posts there are links to some more problems that have been shared here so you can check out these links on each of these links you can try out problems you can make submissions you can solve these problems some of these are interview questions as well you can check if your results are correct and you can use the solving problem solving template as a starting point as we've just shared so there is a starter notebook with each assignment and in the assignment all you need to do is run the notebook so you can run it on binder for instance and then there is a question mark in a bunch of places you will find like question marks here in the text and you will find question marks here in the code so you simply need to put in your code your answers into the question marks so replace that with your code you can see here there are some question marks here so you replace that and step by step there are instructions to guide you there is there are comments to guide you so step by step you can solve it and then finally you can also make a submission so right at the very end when you run the code you will also be able to submit directly and when you make a submission then the assignment will get automated will get evaluated in an automated fashion instantly and you will get a pass or a fail grade now if you get a pass grade that's great but if you get a fail grade then you will also get some comments about what went wrong in your solution so you can use those comments to fix the issues so it's a great way to get quick feedback and keep fixing your issues uh especially watch out for edge cases so that's assignment one and then assignment two is called hash tables and python dictionaries a very interesting assignment where you are going to implement hash tables which power python dictionaries from scratch in python and you will also replicate the interface of python dictionaries so do check it out a very interesting assignment again very similar format you will find question marks in certain places you need to replace them with appropriate values expressions or statements and in this way by working through each of these step by step you can see here by working through each of these you will implement hash functions and hash tables which again are very commonly asked in interviews as well so this is an important assignment for from an interview preparation or coding assessment preparation as well and it also teaches you a lot of really good practices in python programming in particular so do check out assignment 2 as well and we will send you an email as soon as assignment 3 is ready but you can check back in a couple of days and you should see it on the same page pythondsa.com so what you do next review the lecture video and execute the jupyter notebook use the interactive nature of jupiter to experiment with the code complete the assignment and attempt the optional questions as well so each assignment has some required questions and you can make a submission as soon as you're done with the required questions but there are some optional questions which are slightly harder but i highly recommend doing that because they will improve your understanding give you more practice help you internalize the concepts better and then participate in forum discussions and join or start a study group so this is a great way to learn get together with some friends maybe watch the lecture together over a zoom call pause the video have discussions wherever you have doubts discussion is a great way to solve the specific doubts that you may have and it will also help you to articulate your understanding better because you when you explain to others you also answer a lot of your own questions so please do that this is data structures and algorithms in python thank you and good day or good night hello and welcome to data structures and algorithms in python this is a live online certification course being organized by jovian today we are on lesson four recursion memoization and dynamic programming my name is akash and i am your instructor you can find me on twitter on at akashness if you follow along with this course and complete the weekly assignments you can also earn a certificate of accomplishment which you can add to your linkedin profile and you will find hosted on your jovian profile as well so let's get started now to the data structures and algorithms course this is pythondsa.com is the course website and on the course website you will be able to find all the information about the course so you can view the previous lessons lessons one two and three and you can also view the previous assignments assignments one and two today we're on lesson four so let's open up lesson four the topic is recursion and dynamic programming now you can find a recording of the lesson here and you can also watch a version in hindi if you would prefer that in this lecture we will cover recursion memoization and dynamic programming by looking at two common problems in dynamic programming the longest common subsequence problem and then knapsack problem and we'll do this by coding these problems live using the problem solving template that we have been using one in one way or another since lesson one so let's open up the problem solving template this is a template that you can use to solve any coding problem and we will illustrate this by solving two problems using this template today so the first thing we need to do is to run this template you can see that there is some explanation and then there is some code here as well now to run this code you have two options you can run it using free online resources or you can run it on your computer the simplest way to run it is click the run button here and select run on binder and with just one click this will set up a machine on the cloud for you start a jupyter notebook server and you will be able to then execute the code and modify the notebook and save a version of it to your own profile so that you can continue working on it so there we have it now we have a running jupiter hub server i'm just going to zoom in here a bit so that you can see things clearly okay so this is the problem solving template and i said we're working on two problems so i have some problem statements listed out here you can see the first problem longest common subsequence is listed here and this is a part of the lesson notebook lesson page as well so you will find link to this problem statement on the lesson page too so let's first modify the title of this notebook problem solving template let's change this title to dynamic programming longest common subsequence let's get rid of this i don't think we need this then i'm going to keep the section on how to run your code so that if i share this notebook with somebody else they have a way to run it and then before we start the assignment or the problem let's just save this to our own profile so i'm just going to give it a name longest common subsequence this is an appropriate name for it so i'm going to give it this a project name install the jovian python library and just run jovian.commit now what this will do is we started out with a template and now we are editing the template by running joven.com we've saved a copy of the template to our own profile you can see this is the link where you will be able to access this notebook and you can run it and continue your work if this jupyter notebook shuts down if you want to continue tomorrow for instance okay so now let's look at the problem statement now i'll just copy over the problem statement here as well so that we can see it directly within the notebook there we have it now you can paste the problem statement and if you are getting this problem statement from some other source then it's always a good idea to include the link to the original source as well okay now we have a problem statement in front of us so the question is write a function to find the length of the longest common subsequence so that's a new term we'll unpack that between two sequences now let's first learn what we mean by a sequence now a sequence is a group of items with a deterministic ordering for instance a list a tuple a range or even a string these are some common sequence types in python so here i have the string serendipitous this is a group of items and this also contains an order you can see that e comes after s and r comes after e and so on so this is a sequence a list would also be a sequence so that would be a list of numbers so that's a sequence then we're looking at subsequence what is the subsequence now a subsequence is a sequence that is obtained by deleting or removing zero or more elements from another sequence for instance if you look at serendipitous and if we remove the characters s r e n i i o u s then you will be left with e d p t so e d p t is a subsequence of serendipitous now two things to note here edpt does not have to occur continuously so these elements can occur anywhere within the sequence but the order should be the same so e d p t occur in this particular order here and e d p t should occur in the same order here so d should occur after e and p should occur after d and t should occur after p so those are the two requirements for edpt to be a subsequence of serendipitous and visually speaking what we can see is if you take a sequence and then you draw boxes around some of these characters or some of these elements of the sequence and if you just take the elements in the boxes then in the same order then you end up with a subsequence so now we understand what a sequence is and what are subsequences and once again if this is this question is asked in an interview and you're not sure what you mean by a longest common subsequence and or even what a sequence is then you should ask the interviewer what do you mean by a subsequence or what do you mean by a sequence and they'll be more than happy to tell you it's very important to communicate whatever you're thinking whatever questions you have contrary to what you might think asking questions is actually a good thing the more questions you ask the more it is appreciated okay so now we've talked about a sequence and a subsequence now what's a common subsequence so look at these two strings serendipitous and precipitation now if we pick just these elements that are in the boxes r e i p i t o now you can see that rei pito is a subsequence of serendipitous and reipito is also a subsequence of precipitation so a subsequence which is common which is a subsequence of both sequences is called a common subsequence so rei pito is a common subsequence between serendipitous and precipitation now you can have many common subsequences for instance we could just look at re and re here and re would be a common subsequence too or you could just look at i t and i t and that would be a common subsequence as well or we've not picked n here but you could also pick r e n and r e n and that would also be a common subsequence between the two now the longest common subsequence as the name suggests is the subsequence which between the the common subsequence between the two sequences which has the maximum possible length and you can verify this you can try different subsequences and see that rei p i t o is the longest common subsequence between these two strings these two sequences and its length is seven one two three four five six seven so you have to write a function to find the length of the longest common subsequence between two sequences so that's a question and this is a visual example that tells you the answer okay so now that we have the question we've understood the question we can start applying the method that we have been learning throughout so this is the systematic strategy that we will apply and nothing about this method has changed since the first lesson even though we've covered a whole variety of topics like binary search and binary search trees and then sorting algorithms and divide and conquer this method has remained the same the first step is to state the problem clearly and identify the input and output formats then the second step is to come up with some example inputs and outputs and these will be used to test our solutions so we should try and cover all the edge cases and that will help us write code that is correct anticipating all the errors that we might face then we come up with a correct solution to the problem as stated in plain english very important for you to state the problem in plain english before you start coding so that you communicate your ideas and you also make it clear once you express yourself then you implement the solution and test it using example inputs and you fix bugs if you find any of them and you will be able to find bugs if you have written good test cases then you analyze the algorithms complexity and identify inefficiencies if you have any and most likely the first solution that you come up with it doesn't have to be optimal it just has to be correct so there will be some inefficiency but it's important to go through that process of first finding a brute force solution and then finding the inefficiency and then apply the right technique to overcome the inefficiency and repeat steps to three to six so you identify what's the right technique and in this case we will learn a couple of techniques called memoization and dynamic programming and then we go back and state the correct solution again then we implement the solution and test it and then we analyze it again and if there's further scope for improvement we do that otherwise we say that we've arrived at a optimal or good enough optimal enough solution okay i hope by this point this you've started to memorize this process and that's why we keep repeating it over and over that it should become second nature every time you see a problem so the first thing is to state the problem clearly and to identify the input and output formats now the problem is already stated clearly enough but let's just state it slightly more clearly so let's say we are given and just write it in your own words that's more important whatever is clear to you so we are given two sequences and we need to find the length of the longest common subsequence between them simple enough then we have two inputs now we decide the input and output formats we have sequence one a sequence example serendipitous sequence two another sequence example precipitation great and this these are the only two inputs that we require and the output would be the length of the longest common subsequence let's just abbreviate that as lcs which in this case is seven and we know what that subsequence looks like we've just seen it above so now based on this we can now create and you can see the problem is now created and before i talk about the next thing you if you double click on a text cell you can start editing it and here we are using a language called markdown so you can see this creates a block code this creates a bold font and this creates a code like font so let's see here no and the way to go back into the display mode is to press shift plus enter so now you can see here that now we have the problem we have the block code and then we have all the styling so markdown is a really useful and easy to learn language for formatting your text especially in jupyter notebook so do learn it but now based on this we can now create a signature of our function so our function len lcs will accept a sequence sequence 1 and sequence two and it will return something okay so that's the basic signature of our function and even though it's not doing much just establishing what the arguments are is the first step towards solving a problem and let's just save our work from time to time it's very important to keep saving your work on jovian because this is running on a free online service so this will shut down after some minutes of inactivity so just run jovian.commit and that will save the notebook to your profile and you can rerun it okay so now the next step is to come up with some example inputs and outputs and here we need to try and cover all the edge cases so i have written out a few test cases here already now the most common case is a general case of a string like we had serendipitous and precipitation that's a common case there is one of them both of them have some common elements and there's a subsequence common subsequence of length 7 but we may also want to test out another type of data and this is one of the nice things about python where you can write functions that operate not just on a particular class and its subclasses but on any kind of data as long as it satisfies certain criteria for instance strings and lists both allow indexing into them and picking out the ith element or the nth element from the sequence so they're both sequences so our function should be able to work with both strings and with lists then here is another case where we have two sequences and they have no common subsequence a function should not throw an error here it should gracefully return the number 0 because the empty sequence is a subsequence of every other sequence does that make sense think about it so in that case if you if there's no common subsequence then the empty sequence is the common subsequence so the answer is zero and here's one other extreme case where one is a subsequence of the other here's another case where one sequence is empty there's another case where both sequences are empty all of these are important otherwise you might miss out certain special cases and you will face an error when you code your solution finally you can also have this case where you have multiple subsequences with the same length for instance if you have a b c d e f and b a d c f e an a c e a c e is one long subsequence of length three and that's the longest you can verify and bdf is another subsequence which is common to the two and also has the same length those are some test cases now let's copy over these test cases here in an interview or a coding assessment what you might want to do is just write these as comments if you have just a single coding screen and try to list at least four or five if but go as far as you can because this will also help you streamline your own solution and it's always something that is appreciated by interviewers let's do that let's get let's copy over these test cases here and you can think of more so if you have some more ideas of things you should test come up with them there's no right number of tests whatever it takes for you to feel confident is what you need to do okay so now what we've done is we've taken these test cases and converted them into dictionaries so you can see here we have this first sequence sequence one and remember that's why we've written out that's why we've written out here the names of the inputs and the signature of the function now we can create test cases as dictionary so that we can test them all easily all at once so we have the sequence one and sequence two in the input sub dictionary inside the main test case dictionary and then we have the output which is the output of the function which should be seven and this you can verify so this is a general case then we have another case in this case we have two sequences these are both lists of numbers and in this case the output that we expect is 5 and we have another general case longest and stone in this case you can verify that o n e is the common subsequence it has the output three then here we have two sequences which do not have any common elements all these come from the left half of the keyboard all these come from the right half of the keyboard so that was a quick way to generate these two sequences then here we have dense and condensed and you can see that dense is actually a piece inside condensed so this is a special case where dense is a continuous sub string of the string but it even if we had d e s e that would still be a subsequence because d e s e occur in this order so that's one example and in this case the sequence one is itself the longest common subsequence and it has length five then we have this case where one of the sequences is empty and you can see in that case the output should be zero and both sequences are empty and here is the case where you can have multiple longest common subsequences and even in this case your function should be able to figure out the answer correctly so let's take this and let us copy over these test cases here so we have t 0 to p 7 so that's 8 test cases and you can add more test cases here please feel free coming up with good test cases is a skill that you should develop and what we'll do is we'll also put all these test cases into this function called lcs or longest common subsequent tests so that we have all of them easily available for testing at once okay okay now next step is to come up with a correct solution for the problem now we've seen the problem we have identified some scenarios now we need to come up with a simple correct solution stated in plain english it doesn't have to be efficient it just has to be correct so here's one idea here's one idea here you can see we have a couple of sequences let's create two counters idx1 and idx2 both starting at 0. so idx 1 will be a pointer which will start tracking elements on in the first sequence and idx 2 will be a pointer which will start tracking elements in the second sequence and what we'll do is we will write a recursive function so we'll write a recursive function which will compute the lcs of sequence one from idx to the idx1 to the end and sequence 2 from idx 2 to the end so what does that mean let's say idx 1 has the value 3 and idx 2 has the value 1. so you can see 0 one two three so sequence one idx one onwards is logy and sequence two idx uh idx2 onwards is lch m e m y so we are looking at this portion of the problem and this portion of the problem and our recursive function when invoked with idx 1 and idx2 should return the length of the longest common subsequence between these two portions so l o g y and l c h e m y now why are we doing this we need this longest common subsequence for the entire string don't we now here's the logic why why we're writing this recursive function which which can theoretically compute this subsequence for from any position onwards so here's how we do this if sequence 1 of idx1 so if idx1 was pointing to l and idx2 was pointing to l here as well if sequence 1 of idx 1 and sequence 2 of idx2 are equal then this character l belongs to the lcs of this portion and this portion okay why think about it it makes sense because these these elements are equal so if you pick the longest common subsequence of this and you pick the longest common subsequence of the remaining then you can always add l to bo to that subsequence and that will make the subsequence longer right and that way it follows that l will always occur in the longest common subsequence between l o g y and l c h e m y okay so we know now that this will occur l will occur in the longest common subsequence further the length of this longest the length of this longest common subsequence will be the length of the longest common subsequence between ogy and ch emy plus one okay and now you can see why a recursion is required because what we can now do is we can say that if sequence one of idx 1 and sequence 2 of idx 2 are equal then we simply call the recursive function on sequence 1 of idx 1 plus 1. so ogy and sequence 2 of idx 2 plus 1 ch emy and assume that recursion will give us the solution there and simply add 1 to it because this is equal okay so that's one case if sequence 1 of idx 1 and sequence 1 of idx 2 are equal great but if they're not equal right so for ins in this case for instance you can see that if i dx1 and idx 2 are both 0 so idx 1 points to a and idx 2 points to b so if they are not equal then one of the two things should hold either a does not occur in the longest common sub sequence between the two strings or b does not occur in the longest common subsequence between the two strings now we don't know which one but that's the power of recursion that we can just try both so we can simply ignore a and we can get the longest common subsequence between b s e and t and b est and check its length and then we or we can simply ignore b and we can get the longest common subsequence between absc and est and check the length now whichever is longer in length that becomes the solution for the two strings okay so this is what it looks like we start out with analogy and alchemy we compare a and a these two are equal so we know that the longest common subsequence is one the length is one plus lcs of analogy and alchemy okay now we compare n and l and now we see that they are not equal so either n does not come in the longest common subsequence or l does not come in the longest common subsequence so we try both we remove n here you see a l o g y and we remove l here we see c h e m now once again a and l are unequal so either a does not occur in the lcs of these two strings or l does not occur in the lcs of these two strings so if a doesn't occur in the lcs we can remove a and try again if l does not occur in the lcs we can remove l and try again and here once again we get a match so in this case we know that l occurs in the longest common subsequence of these two elements so now we can get the lcs of ogy and ch emy okay and then you know as these recursive calls complete you can see that this entire tree pans out you can see that each time you either get one child or you get two children and if you go all the way down and then you go back up and simply count the number of matches for each path you will kee and you take keep taking the maximum so here you get back an answer let's say you get back an answer of size two here you get back an answer of size one so the answer for this is simply the maximum of two and one which is two and then the answer for this is simply the maximum of two and let's say this is three then three and the answer for this is simply one plus three four okay so this is the way that we will build up the solution so we've now looked at the recursive solution expressed in text and we've looked at the recursive solution expressed as a tree now it's possible that it still may not make sense to you how exactly this is working and that is where you should start trying to create this tree yourself so pick up a pen and paper and then start drawing on pen and paper take an example and try to read each step here and try to work it out like a computer okay and just thinking about it that way will help you understand this algorithm now one last thing is that if either of the sequence one from idx onwards or sequence two from idx onwards is empty which means the index has reached the end point in after doing some recursion then their lcs is empty so the length is zero okay so that is the recursive solution here i will just copy over this recursive solution too along with the entire tree now obviously in an interview you do not need to write all of this in in a lot of detail or you do not need to so it helps to show a diagram sometimes but you don't really need to do all of this all you need to do is express yourself clearly that we will create two counters and the condition to check is whether these two elements at those counter positions are equal what do we do if they are equal what do we do if they are in equal and why are we using recursion here so we are using recursion we can because we can use reuse some of the sub problems to compute the final problem okay and understanding recursion is really important for solving data structures and algorithms problems because it's like a superpower pretty much pretty much every problem that you see one way or another can does boil down to recursion in one way okay so now let's save our work once again and now we're ready to implement the solution so we have the recursive solution in front of us and if you remember the four steps let's go let's go ahead and implement it so we see let's just call it lcs recursive and this will accept a sequence one and a sequence two and let's also initialize idx1 and idx2 because we will be calling this function recursively so we'll simply use these two counters idx 1 and idx 2 and set them to 0. now the first thing we need is if idx 1 is equal to the length of sequence 1 or idx2 is equal to the length of sequence 2. then we return zero again this is a common thing that happens that the base case or the end scenario is something when you're describing the algorithm you will describe at the very end as you're drawing the tree you will notice what the end case and scenario is but when you're coding the algorithm the end scenario or the base case comes at the very top because otherwise we'll try and access idx 1 from sequence 1 and that will throw an error so that's why you need to handle the base case at the very beginning okay next moving ahead if sequence one of idx one equals sequence 2 of idx2 great we found a match we simply return 1 plus now we can call lcs recursive on sequence one sequence two and we increment idx one by one and we also increment idx two by one both of these need to be incremented because we are going to use this element this common element as an element in the subsequence okay so there's just one recursive call here that was nice otherwise we have to either ignore the first element of or the current element from sequence 1 or the current element from sequence 2. so we have two options so we have option one which is we ignore the current element of sequence one so this becomes lcs recursive sequence one sequence two idx one plus one and idx2 and then we have option two this is lcs recursive once again with sequence one and sequence two and this time we increment idx2 okay so make sure you understand this piece because this is really the key here and then the length of the longest common subsequence is simply the maximum of option one and option two okay and that's it what may have seemed like a fairly tricky problem once you start thinking about it recursively okay what happens if we simply compare the first two and they're equal and they're unequal okay now we need to solve the problem for the remaining um either we add one or we take or we ignore one of the elements right once you get that thought the recursive thought then the solution and the code simply presents itself to you it's just about seven lines of code okay that's our lcs recursive solution now let's test it out let's look at a test case t0 okay so here we have serendipitous and precipitation as the inputs let's call lcs let's keep that around so that we can view it later let's cost call lcs recursive on t0 but of course we need to fetch from t0 the input and get sequence 1 out of the input and similarly we need to get the input and get sequence 2 out of the input you can see it it takes it returns the value 7 which is equal to the output by the way so if we simply put in here t0 output and i'm also going to put in this special command called percentage percentage time this is going to tell us how long the cell takes to execute yeah so now you can see here that we get back true and the cell takes 495 seconds or half a second to execute and that's it so now we have tested this test case one small thing i can tell you how to improve this slightly is because in t 0 of input is a dictionary and because the names of the elements of the dictionary are sequence 1 and sequence 2 which also match the argument names of lcs recursive you can see here we have sequence 1 and sequence 2. what you can do is you can simply say star star t0 input and python will automatically grab each key so sequence one will be passed as the argument sequence one and sequence two will be passed as the argument sequence two that's this is a small trick here that helps us speed up the reduce the amount of code we need to write okay now we've tested one test case but that's not enough we should be testing all the test cases so to test all the cases we can write a for loop for t in tests etc but we can do something else too we can use the evaluate test cases function from jovian so from jovian.python dsa the module we will import evaluate test cases it's a helper function that we've created for you but it's really simple to write you can just use a for loop as well and we call evaluate test cases on the function that we want to test which is lcs recursive and the test that we have which is lcs tests and when we do this it is going to try out each test case you can see it strike test k0 that was a pass it tried test case 1 and it's also printing out the input the expected output in the actual output the test case 1 was lists and lists work too because all we have used here is indexing and length and these are both things that are available in both strings and lists and this is something that's very nice about python the dynamic nature of the functions uh once again this worked perfectly fine then here we have another one longest in stone the expected output was three and the actual output was three as well here we have ads f e w ad and another string they have nothing in common so the expected and actual output are both zero here's one where one is the is already a subsequence of another so the smaller one becomes the longest common subsequence and then we have an empty string and then we have two empty strings and finally we have multiple longest common subsequences we still get back the right output now if any of these failed you would know exactly what went wrong for instance if you had an issue in this case where the two of these were empty then that would tell you that you've probably not handled that empty case properly and that is why having great test cases is very important okay and we can see the timings for these as well each of these took about well 480 milliseconds was the highest now that's still a bit high i would say 480 milliseconds because we are just looking at sequences serendipitous and precipitation which are of very short length if you're looking at a really long sequence for instance this technique is used for dna sequencing and we were looking at two dna strands or two in two dna strings and trying to get the common subsequence out of them and these can go into thousands or sometimes millions of elements that would make it rather slow okay so we do want to improve this algorithm further so let's do that and before that we can just commit our work once again but the first thing before we improve the algorithm is to analyze its complexity how long does it really take okay and identify any inefficiencies now to analyze the complexity let's look at an example and let's consider the worst case now when does the worst case occur here we've seen that if two elements match then we simply have one sub problem or one recursive call but if the two elements or two elements of the sequences don't match then we have two recursive calls so if you have two completely distinct sequences where none of the sequences none of the elements match then each time we will end up with two sub problems so that becomes the worst case so the worst case occurs each time we have two sub problems where the sequences have no common elements and here's an example this is a sequence of length six here's a sequence of length eight and this is what the tree will look like so now we have no longer put the actual sequences we've simply put what is the length of the string that we started with so here we start out with strings of length six and eight and then we say that we either ignore the first character of the first string or the first sequence or we ignore the first element of the second sequence and that gives us two sub problems and this time this the sequences have length five and eight in this case and six and seven in this case okay so we either reduce one from the left or we reduce one from the right and once again here we either reduce one from the left or we reduce one from the right so this way we create a tree and you can also see that a lot of common trees get created and that really is what is the inefficiency and we'll talk about that but what will happen here is five seven will then call four seven five six and five seven here will once again call four seven and five six and four seven and four seven will get repeated here and five six and five six will get repeated three times here so there's a lot of repeated calls that are going to occur and you can even see this here at the top you can see that alogy the problem was called repeatedly so that's really a source of inefficiency but now the question becomes that we know that all the leaf nodes will end at zero zero that's when the entire tree ends so can you count the number of leaf nodes okay can you count the num if you keep expanding this tree completely expand each of these don't skip any of them can you count the number of leaf nodes now if you count the number of leaf nodes we know that in a binary tree the number of leaf nodes if the number of leap nodes is l um then the height of the tree is if the number of leaf nodes is n then height of three is log n and based on that we can actually determine the actual size of the tree as well so we know that to count the number of unique paths from root to leaf will give us the number of leaves right so each time we have two choices we either reduce from the left or we reduce from the right so to get to 0 0 we would have to reduce all the elements from the left and we would have to reduce all the elements from the right that means if you have strings or if you have strings of length or sequences of length m and n then you would have to make m plus n choices in total and you so each time you have m you have to make m plus n choices and each time you have to choose whether you want to reduce from the left or from the right you have two choices and you have to make those two choices m plus n times that's the right way to put it really so that means each time you com you do two choices so you have two multiplied by two multiplied by two multiplied by two and you keep multiplying that and you will end up with two to the power of m plus n leaf nodes okay so here is an exercise for you draw this tree on a piece of paper mark out how the number of leaf nodes how the length of each part is m plus n figure that out and based on that can you conclude that it takes 2 to the power of m plus n leaves to complete this tree and if 2 to the power m of m plus n is the number of leaves then the total number of elements is in the tree simply double of that once again this is something that is very easy to verify you can check it here for instance if you just consider these two levels the if you have two leaves then the total number of elements in the tree is two plus one three actually it's double minus one so two into two four minus one three if you have three levels you can see here that if you have four leaves then the total number of elements in the tree is four into two eight minus one seven and you can see that here so it follows essentially that we have an exponential number of sub problems we have we are calling the recursive function an exponential number of times and inside the recursive function we are doing inside the recursive function we are doing a constant time work so you can see here that there's no there's no special work that we're doing all we're doing is some comparison and we're doing an addition both of them are constant time so we make 2 to the power of m plus n recursive calls inside each we do constant work so the time complexity is order of 2 to the power of m plus n okay that's a rough explanation we've not gone into a lot of depth because we've covered this over and over in three lessons but the exercise for you to is to verify how exactly it is 2 to the power of m plus n okay so that's our recursive solution and we know we now know that the time complexity is 2 to the power of m plus n let's just copy that over here and the inefficiency as we said in this algorithm is that we are calling the same problem we're calling the exact same problem the lcs recursive function is called with idx equal idx 1 equal to 5 and idx 2 equal to 7 and at x 1 equal to 5 and at x 2 equal to 7 the same time twice so each of these sub problems will be called twice and then each of the sub problems within them will be called twice and of course some of these sub problems will once again get shared so there's a lot of repetition now there's a simple solution here which is simply to remember some of these results okay and this technique is called memoization and you may also just call it memorization because you're just remembering some of these things but memoization is a technical term for it and we remember these solutions in our dictionary called memo so what we are going to do is we are going to follow the same recursive strategy but this time we are going to maintain a dictionary called memo and we're going to track intermediate results within the dictionary and if we find an intermediate result already exists in the dictionary then we will not compute it again okay so let's see so now we write lcs memoized or let's just say lcs memo for short it takes a sequence one and it takes a sequence two and this time we create this dictionary called memo and then we write a function inside it so we will write a helper function a recursive helper function inside the lcs memo function so that it has access to sequence 1 and sequence 2 and we will simply started out with idx 1 as 0 and idx 2 as 0 as well right x1 will track the position in sequence one idx2 will track the position in sequence two now the first thing we do is create using the two indices create a key so we are going to create the key idx one comma idx2 and if the key is present in the memo so this is the way to check if a key exists in a dictionary then we simply return memo of key simple the problem is solved we don't have to solve this problem because it's already it's already something that we've solved if it isn't then we need to solve the problem and save it in the memo now here we know that we can now write our same three recursive cases now if the base case if idx 1 is equal to the length of sequence 1 or idx 2 is equal to the length of sequence 2 then we simply set memo of key as 0 because by this point we have reached the end of the strings there's nothing left for us to compare lf idx sequence 1 of idx 1 equals sequence 2 of idx 2. so in this case this is the case where the current characters are equal so this is if we go go up here and look at the tree once again this is a case like this where the current characters that we are pointing at are equal so in that case we simply return we simply get the result as one plus the result for the remaining with the first character removed so in this case we simply set memo of key to 1 plus we call the recursive function again recurs idx one plus one and idx two plus one great else so this is the case where the two elements are not equal so and this is where we have two options i'm not going to write the two options separately let's just do a max directly here max and we say recurs with idx 1 plus 1 comma idx2 and recurse with idx 1 comma idx 2 plus 1 okay and finally from the recurse function we return memo of key so we have whichever case it is we have computed the result and saved it in the memo so this time these computations will not get repeated again and again and let us now return recurs of zero comma zero because zero comma zero is the entire string and that's it and this is the common strategy that you should apply whenever you come up with a recursive solution and you see the inefficiency coming because of the same problem being called again and again and again this is where you need to apply this technique called memoization right and in this technique you will then be able to simply store intermediate results so it's really simple you just create a dictionary and then you add one or two lines of code here and you make sure to save the result in that dictionary whenever you compute a result the next time you don't have to compute it okay and we can test it out we can test it out with all the test cases evaluate the test cases so lcs memo and lcs tests and you can see that all the test cases pass now not only do all the test cases pass you can see that the time taken is now lower okay so that's nice the time taken is now lower now we went from 450 milliseconds if we just go up here you can see that it took 480 milliseconds for the for finding the longest common subsequence between precipitation and serendipitous but in this case it only took about 0.234 which is 0.2 milliseconds so it is 2 000 times faster even for strings of length 7 or 8 and that's a huge boost let's analyze the complexity here let's uh look at the complexity now a quick and easy way to find the complexity of the solution is to see where the computation how many times the computation can occur now this is where the bulk of the computation is occurring in a recursive call and this computation is avoided if we already have something in the memo okay so that means that the only number of computations that we need to do is equal to the maximum number of elements that can end up in the memo now what are the keys in the memo look like the keys in the memo look like idx 1 and idx 2 great and what values can these take idx 1 can take 0 to m values if m is the length of sequence 1 let's say and idx2 can take 0 to n values if n is a sequence a length of sequence 2. so in total the possible number of keys is m times n the possible number of keys is m times n the possible number of things that you need to store in the memo is m times n and for each of them you do constant work and then the next time you try to access this you do not need to do the work you do not need to call any recursion you can simply access the memoization right so what that tells us is the complexity of this case and in any memoization case in general is equal to the number of keys which in this case is m times n so the time complexity here is order of m times n so we've gone from 2 to the power of m plus n which if you if m plus n was equal to 30 would be 1 billion to m time order of m times n so let's say both strings were 15 and 15 so that would just be 225 operations so we've gone from 1 billion operations to 225 operations simply by storing intermediate results and it's a very powerful technique that we apply all the time so now you can see here that the first time five seven is computed the next time phi 7 does not need to be computed again and that's why this tree here is actually marked out so this is the tree for memoization this the first time 4 7 is computed it never needs to be computed again so this entire tree of computation gets eliminated and similarly this entire tree of computation gets eliminated we are eliminating from 1 billion computations almost all except 225 computations so we are left with practically nothing and that speeds up your algorithm by a huge huge factor so that's memoization and as i said it's really easy to compute the time complexity of memorization just simply count the number of keys and then just track how much work do you need to compute each key assuming that you already have the recursive solutions for the remaining okay so how much work do you need to compute each key using some other existing solutions now in this case that was constant because all we needed to do was compare and add okay and i'll let you write here a simple optimized so a plain english explanation of memorization it's worth a it's a good exercise to try out but what we will also look at is another technique called dynamic programming now the downside with memoization is that it requires recursive calls and while it's not a problem for small cases when you have really large problems recursion has an overhead and the overhead for recursion if you see this way is that for this function execution to complete you need this function execution to complete and this to complete and for this to complete you need this to complete and this to complete right so the idea here is that for each new recursive call takes more space in the memory and it also takes longer because now we have to allocate some memory and then set up that function stack the function stack for the execution of that function so if you have a large tree then you're creating hundreds thousands or possibly millions of open functions all of which have their own memory and that can eat up a lot of memory and sometimes that can also take up a take longer time so the solution to replace recursion is iteration and how do we do that we do that using a technique called dynamic programming so we'll do almost the same thing there are a few changes here instead of using a dictionary to track intermediate results we will create a matrix because we know that sequence one uh the idx one can go from zero to n uh where or zero to n one let's say where n one is the length of sequence one and sequence idx2 can go from 0 to n2 where see n2 is the length of sequence 2 and what we can do is we can use a for loop or a couple of for loops to fill out all these sub problems without having to require a recursion okay and this is how we'll do it so let's say these are the two strings that we're working with this is string one t a c g t and this is string two and these this is what dna sequences look like so what we'll do is we will create a table of size n plus one plus one and n one plus one and n two plus one so you can see that there are n one plus one rows so if if this is of length n one these are n one rows and then there's an additional row and similarly there is there are n2 plus one rows here so if this is of length n2 there are there are n2 plus one columns so you can see these are n2 columns and there is an additional column here and table of inj so let's say table of uh if i and j are 0 so i is a pointer for the first sequence and j is a pointer for the second sequence so i selects a row and j selects the column so table of i and j represents the longest common subsequence of sequence 1 up to i which means sequence 1 so here if let's say i was 1 and j was 1. so this represents the longest subsequence of sequence 1 up to i so all the positions before 1 which means only the 0th position just t and sequence two up to j which means all the positions up to the first position of up to up to one so which means only the zeroth position so which means a okay so table one and uh table i j represents the longest common subsequence of these two of just a and t which is zero on the other hand if we skip ahead a little bit if we skip ahead to let's say this position you can count here i goes zero one two three four five six so this is 6 here and here we have 0 1 0 1 2 3 so this is so this is table of 6 comma 3 the table of 6 comma 3 takes the first six elements which is ta gtca and the first three elements aga of sequence 2 and it stores the result of the longest common subsequence between these two okay so i'll just let you look at the table and maybe even draw the table on a piece of paper and verify that the length three is right you can see here a g a a g a occurs here so a g a is a subsequence of t a g t c a so the longest common subsequence between them is three now what we'll do is we will now compare the next elements of we will now compare sequence 1 of i in sequence 2 of j so let's say we are looking at let's pick an example let's say sequence let's say i has the value i has the value 0 1 2 3 4 i has another value 0 1 2 i has the value 2 and let's say j has the value 1 so 0 1 so if we compare sequence 1 of i so which is g and sequence 2 of a sequence 2 of j which is also g and if they're equal so if they're equal then table of i plus 1 on j plus 1 which is this value right so remember i is 2 and j is 1 so table 1 of i plus 1 so table 1 of 3 is 0 1 2 3 and table and table 1 of i plus 1 j plus 1 is table 1 of three and a table a table of i plus one and j plus one i being two and j being one is table one of three and 2 and table 1 of 3 and 2 is the value 2. so this value is obtained by adding 1 to table 1 of i comma j so because these two elements are equal we we can then say that if we take the longest common subsequence of t a and a and add one to it that will give us the longest common subsequence of tag and a g so the exact same logic as recursion we have simply now reversed it so we now now looking at the last element so that we can keep filling out the last value using some previous values okay so this is one case similarly here's one other case where a and a are equal so the longest common subsequence between t a g t c a and the longest common subsequence between a g a is one plus the longest common subsequence between t a g t c and a g okay one plus this value so that's one case the other case is if they're not equal so let's look at this value for example over here so we have ta gt on this side and then we have okay let's let's look at this one uh we have ta gt on this side and we have a g ac on this side now t is the element here and c is the element here they are not equal so that means the longest common subsequence between these two either does not contain t or it does not contain c it cannot contain both obviously because one of the strings has to end so if it does not contain t then it is this result and if it does not contain t or if it does not contain c then it is this result so we simply take the maximum of these two maximum of these two to get the result for this if these two elements are not equal and that is how you fill out the table you start from the top the first row is zeros because we are we have empty strings and the first column is also zeros because we have empty strings to fill out an element you compare if the two elements are equal and if they are equal we simply add one to the diagonally left top left element if they're unequal then we take the maximum of the element above it and the element to the left of it and that way we fill out the entire table okay so that's the dynamic programming solution and i know this can seem a little bit complicated honestly i still get confused with dynamic programming a lot of times and that's why i like to just draw tables and write things out carefully okay and and especially you have to be specially careful with indices because here we are saying that if sequence i one i and sequence to j are equal then table one of i plus one and j plus one is one plus table i j so b just watch the indices carefully here but let's implement the solution let's implement the dynamic programming solution so let's say lcs dynamic programming so we'll just say dp here and we have sequence one and we have sequence two and the first thing we need is we need a table of results now this table for it let's just grab n1 and n2 so length of sequence one and length of sequence two and now we need to create a table with all zeros how do you create a table with all zeros the way to do it a way to create a list of zeros is this zero for underscore in let's say n1 let's give n1 and n to some values now if you want to create a list of zeros of length and one use you simply say zero for underscore or zero for x you're simply ignoring whatever value you're getting from a range arrange n one and that's going to give you a list of zeros but we don't want a list of n one zeros we want these one these want to be rows so we want each of these to itself be a list of zeros of length n2 so zero for x in range n2 and now we have you can see that we have five rows one two three four five then we have seven columns one two three four five six seven so this is the table that we want to create initially okay now this is a table that we've created this is going to be this exact same table and we're just simply going to start each string from position 1 this time not from position 0 because we want to have this additional row where we don't consider either of these that just makes computations a little easier now we say for idx one in len at x1 and range n1 so that's that's going to iterate over the rows and then for idx true in range n2 and that's going to iterate over the columns and first we compare if sequence one of idx 1 is equal to sequence 2 of idx2 if they're equal then we can fill out table of i plus 1 and j plus 1 as 1 plus table of i j okay and we can see this we can see this here suppose the first elements were equal so suppose this was suppose idx 1 was 0 and idx 2 was also 0 suppose they were equal then this value should be 1 so this value should be 1 plus the diagonally top element and that holds true anywhere within the list so wherever you have two elements equal like g and g are equal here so this value is one plus this value else we have table i plus 1 and j plus 1 is max of table i comma j plus one so you stay in the same row or you you go to the previous row or you go to the previous column which is table of i plus 1 comma j and this is the previous column okay so this is this case where g and a are not equal so if g and a are not equal then we take the maximum of these two values and that's it that is going to fill up the table for us and then we simply say return table we simply want the bottom right element we can simply say return table minus one minus one so this is going to get that last row last column and that's our dynamic programming solution let's do evaluate test cases here okay turns on there's no i okay let's just call this i and j turns out idx 1 is not defined let's just make these i and j now that we're doing this coding live you can see that even after a decade of coding i still make all of these issues says the list a list index is out of range it seems like i plus 1 and j plus 1. ah that's because remember we need an additional row and an additional column to track the case where either of the strings is empty so we need to get range n two plus one here and we need to get range n one plus one here okay that's why it helps to have test cases so that you can fix all of these issues now you have test k0 it passes and test case 1 2 3 all of them pass you can see that all test cases have passed and you can also verify that the amount of time it took is now lower than the amount of time it took for memoization okay and so that's the dynamic programming approach you simply create a table and you fill out the table sometimes just working with indices within the table can get confusing so it helps to work with it on paper and make it clear to yourself and then write it in english that's why we've written it in plain english here and now an exercise for you is to verify that the complexity of this dynamic programming approach is order of n1 times n2 so which is the same as memoization and it's actually more straightforward to see here because you have two for loops and then each of these for loops you're simply doing a comparison and an addition and there's not even any recursion to very very there's not even any recursion for you to worry about so you just do a comparison and you do an addition or you take a maximum pretty straightforward so order of n1 times n2 and it does not even invoke an another function so it does not take up too much memory it does not take up too much time it's very very efficient and this is how you solve pretty much every dynamic dynamic programming problem you write a recursive solution you come up with the brute force solution and keep in mind that recursion is almost always the way to go about creating a brute force solution so you come up with a recursive solution and then you identify you draw the recursion tree and if you see that the same sub problem is being called again and again that is a point where you can introduce memoization so you introduce memoization and sometimes you can just write the memoized solution and that's enough because it's easy to reason about you just put in a memo and you're done with it um even the interviewer or the coding assessment will accept that solution but in some cases you will be asked to then remove the recursion and write it as a in an iterative fashion and that is when then you have to start drawing a table and think about what are the rows and columns in that table need to represent so here the i j element of the table represented the first the first i elements of sequence one and the first rj elements of sequence two what is the longest subsequence between them and we used that to build the next row and the next next column and we then filled out the entire table and we simply used the last value now again this is not very straightforward uh how to come up with this and the way you do that is by solving problems so if you solve five to ten dynamic programming problems you will get some intuition about how to build the tables and it's always very helpful to solve it on pen and paper first especially with dynamic programming so that it's clear to you what each element of the table represents otherwise you may make a lot of off by one errors like missing the plus one here or missing the plus one here and get confused just like i did pretty much and that's the time the time complexity is pretty straightforward in most cases it is simply the size of the table but sometimes you may have to do more than constant work here so keep that in mind see what it is that you're doing inside your loop now inside of inside your loop if you have to go back and check the entire length of the string so that will introduce another factor into the equation so keep that in mind but in most cases counting the iteration should be good enough to give you an idea of the time complexity okay so that's the first problem and let us just commit this and now it's saved to my profile if i just open this up here you can see that now i have this notebook called longest common subsequences and i can share it online whenever you work on a notebook it's always a good idea to make it public put it up on jovian all you need to do is run jobin.com and share it online just press the share button and then you can share it on twitter linkedin facebook or wherever you like so that's the first problem that we looked at now let's come back to lesson four and uh by the way the problems that we're talking about all the problem statements the graphs the images you can see them in the second link here but we will once again open up the problem solving template and now we'll use it for the second problem let me run this once again and we're going to look at the second problem which is the knapsack problem so let's read the knapsack problem it's also called the zero one knapsack problem here's there are many variations of this problem but here's one way to state it that you might come across or something similar you are in charge of selecting a football or a soccer team from a large pool of players and each player has a cost and a rating so there's a selection going on you have to come up with a team for this year and you have a large pool of players each player has a cost and each player has a rating now you have a limited budget so you need to build a team within the budget so what is the highest total rating of a team that you can create which fits within your budget okay so this is the question here you have to maximize the total rating but fit it fit the total cost within your budget so we have two variables here rating and variables rating needs to be maximized cost needs to be simply optimized to the extent that it fits in the budget and just a simplifying assumption here is that you can assume that there is no minimum or maximum team size this is simplification and later you can introduce a criteria there as well that you want to build a team of exactly 10 people and see if you can also solve that problem in a way so that's the knapsack problem let's copy it over and here's a jupiter notebook a fresh problem solving template let's simply change the title here it is also called the zero one knapsack problem because each item can either be chosen or not chosen and let's give it a project name here too let's commit it and let's paste the problem statement here okay so that's the problem statement and this is a specific or a special form of a more general problem statement and we look at the general problem statement in a second we'll when we try to state the problem clearly but here's once again the systematic strategy will apply we will state the problem clearly identify the input and output formats come up with some example inputs and outputs and try to cover all the edge cases then we will come up with a correct solution for the problem and state the solution in plain english it just has to be simple correct solution not too complex then we apply the right technique to overcome the inefficiency and then we so we analyze the algorithm and identify any inefficiencies after implementing the solution and finally we apply the right technique to overcome the inefficiency and then repeat the process of stating the solution implementing it and analyzing it so to state the problem clearly what we can do is we can abstract out the problem in more general terms and that is what is stated here and let's just grab that and we'll take a look so here we have we are given n elements and each of which has a weight and a profit so you have n elements and here's the profit of each element and here's the weight you can of each element so you need to determine the maximum profit that can be obtained by selecting a subset of the elements weighing no more than a given weight w so you have a capacity a maximum capacity let's say the maximum capacity is 15 and you have to select certain elements so that you fill out the total weight is no more than the capacity and the total profit is maximized that's and this is why it's called the knapsack problem it's assuming here you have a bag or a knapsack with a capacity of 15 kilograms and these are the weights of the items and these are the profits now in this case you can see in this example the optimal selection is these four elements which have the weights five three two and five so that you fill up the total capacity of 16 or 15 and the of the solution on the maximum profit that you can obtain is 7 plus 4 11 plus 5 16 plus 3 19. now you can try other combinations and verify that this is actually the best solution do give it a shot so what are the inputs here so we have it's pretty clear we have an input weights so these are the weights of the this is a list of numbers containing weights and then you have profits a list of numbers containing profits and this should have the same length as weights and then finally you have a capacity the maximum weight allowed and there you go and now we have outputs so now the output would simply be the max profit so this is the maximum profit that can be obtained by selecting elements of total weight no more than w or no more than capacity okay great so that gives us a pretty good starting point now we can write a function signature here so we write max let's say def max profit and we can give it weights and we can give it profits and we can give it a capacity and we pass so now we have defined the problem we have stated we have identified input and output formats now we need to come up with some example inputs and test cases once again we have listed out a few test cases here so we will have a few generic test cases where you have just a random set of weights and profits and you identify the knapsack the optimal solution then here's one option where all of the elements can be included you can take everything here's another option where none of the elements can be included you have to think about all these scenarios here's one where only one of the elements can be included then you may also think about areas where you do not use the complete capacity okay you do not use the complete capacity because the optimal solution is actually taking a lower capacity so there may be a way to fill out to capacity but that may have a lower profit than another option which takes less than the complete capacity but has a higher profit so think about some cases here think about some good test cases here and i will just copy over these for now and then what we'll do is we will express these test cases once again as dictionaries so you have test 0 test 1 s2 all of these expressed are dictionaries and these are covering all the test cases that are mentioned here you can see here are some weights and some profits and the capacity is 165 and then the optimal solution is 309 now we are simply asking here for the optimal solution the maximum profit that can be obtained but an extension of this problem is to identify which are the elements that should be chosen and it's a simple extension it's a good exercise for you to try out and you can discuss it in the forums we have test zero test one test two test three and four and five so we have a total of six six test cases let's copy over these test cases here and let's put them here into a single string and that gives us the test cases okay now coming up with the solution so once again the first step is to try and come up with a recursive solution and a recursive solution is again quite straightforward we'll write a recursive function max profit that given an index so this time we have just one sequence so given an index within the sequence so let's say our index idx it computes the maximum profit that can be obtained using the elements from idx onwards so 31547 using all of these elements idx onwards the maximum profit that can be obtained right and using a given capacity so it will take an index so it will take an index and a capacity so if let's say the idx is one so it will then look at just these elements and if the capacity is 10 so it will try to fill the capacity of 10 and that's a recursive function and why are we creating a recursive function like this there's a simple reason now suppose idx has the value 1 and the capacity is 10 or let's say the capacity is 3 then the weight of this element is greater than the capacity so that means it cannot show up it cannot be selected because it cannot fit inside the bag the knapsack that we have so then the solution for this sub problem with idx equal to 1 and capacity equal to 3 is same as the solution for this sub problem with this element removed because you cannot include this element within the knapsack right so if you remove this element and simply consider these elements the remaining elements which essentially means idx plus one so max profit of idx plus one profit uh of weights idx 1 profits idx 1 and capacity is the answer for max profit of weights idx profits idx and capacity because the current weight 5 is greater than the capacity 3 which is which the recursive function has been invoked with so that's one option but the more general case is that you have enough capacity so let's say you have a capacity of 10 recursion was called with a capacity of 10 and you are at idx 1 so then you have two choices either you include this element in your knapsack or you do not include this element in your option because you don't know whether the optimal solution will have this element or not so you try both so there are two possibilities we either pick weights idx this element or we don't and what we can do is we can simply compute the result in both cases and pick the maximum so if we don't pick weights idx then once again if we don't pick this element so the capacity remains the same let's say the capacity was 10 so we simply try out to fill out the capacity of 10 using the remaining elements so we simply call max profit with weights idx plus 1 profits idx plus 1 onwards and the remaining capacity which is 10 but if we do pick the element if we pick the element and we had a capacity of 10 then the optimal then the solution the best solution in this case will have a profit 3 more than the solution for this case and since we also used of some capacity so we need to add 3 in the profit and we need to subtract 5 from the capacity right so if we pick weights idx then the maximum profit for this case is profits of idx plus max profit of weights idx plus 1 onwards profits idx plus on onwards but because we've used up some capacity we reduce the capacity in the recursive call okay and that is why a recursive call takes both an index and a capacity okay i hope that makes sense so here's a recursive tree that tells you the same thing we started the first index and we we have the capacity and if we don't pick the first element then we sim the answer is simply the to the best solution for second index onwards with the same capacity if we do pick the first element then the answer is the second solution onwards with the reduced capacity with the profit added okay and then we simply take the maximum of these two cases so we call these two recursive calls and then we simply take the maximum of these two cases to get back the final result or the final best answer and the final end case is that if we've reached the end if weights idx onwards is empty if the index that we're tracking has reached the very end then irrespective of what the capacity is the maximum profit is in that case is zero so let's try and implement this now let's copy this over as the explanation and let's try and implement the solution let's say let's call it max profit recursive and this is going to take a set of weights it is going to take a set of profits and it is going to take a capacity and is also going to take an index which the index will start out at zero so now if the index is we start with the base case so if i dx equals the length of weights in this case there's nothing left to do we simply return 0 because we don't have any more elements then we check if the weights idx is so the current element is greater in weight than the capacity then it's a pretty straightforward solution we simply return max profit recursive of weights profits capacity plus one sorry capacity and idx 1. so we simply ignore this element because we cannot fit it in the capacity that we have else we have two options we have option one option one is even though it can fit within the bag we don't take it we every because the optimal solution may still not have it just because it fits does not mean we should take it so we look at the option one which is once again the same as this where we ignore this element and then we have we look at option two in option 2 we actually put this element into the bag so since we are putting this element into the bag then we get we get profit from it so we get profits of idx and then we call max profits recursive and this time we call it with weights and profits and now the capacity has reduced a little bit because we have taken this element so now we can now we need to fill the remaining we fill the need to fill the bag with the remaining elements from idx plus one onwards with a limited capacity of capacity minus weights of idx and then finally we just put in idx 1 so that we can start calculating the solution from the next element onwards so that's max profit recursive again not very difficult it is just about six seven lines of code and let's try it out here's test zero let's try max profit recursive with test zero input and we need to get weights capacity and profit all of these out of it the simple way to do that is simply to put in star star and we'll get back all of these will get passed in capacity will get passed as a capacity parameter in weights will get passed against the weights parameter and profits as the profits parameter okay so we've encountered an error and that's completely fine completely fine to encounter an error i see so what we've done here is uh we have not really taken the maximum of these two we've just defined the two options so we do need to take max of option one and option two okay once again this is why helping test having test cases helps and you can see that now we call max profit and we can also add a timer here so max profit it takes 210 micro seconds but it result it returns a result 309 great we get back the result 309 here which is what we expected so our function is working correctly we can even evaluate it on all the test cases so from joven dot python dsa we import evaluate test cases and then we simply call evaluate test cases on all the inputs so we pass in max profit recursive and then we pass in all the test cases as tests now you can see that we have these test cases and each test case seems to be passing just fine all six x test cases have passed and these are the times they took so that's your recursive solution pretty straightforward once you reason it out once you maybe just look at an example draw a tree of recursion yourself work it out on paper the code is in fact in most cases fairly simple and this is what the recursion tree looks like each time we make a choice to either include the element or not include the element and now you can reason the complexity very easily because now we have n elements for each one we keep making this choice so that means we end up with 2 to the power n leaves and from there it follows that the complexity of the recursive algorithm is order of 2 to the power n right so it could be 2 times or c times 2 to the power n but and in the bigger notation it's order of 2 to the power of n so it is exponential and complexity and why is it exponential complexity once again there are it's a possibility here that we may be computing a lot of things repeatedly because we are creating so many of these sub problems so it's possible that we may be creating we may be recomputing a lot of data here so now the task for you or the an exercise for you is to write the memoized version of this so what is it that you need to memoize now the trick here is to look at what is changing within the recursive calls so now in max profit recursive you can see that weights and profits remains the same but it's the capacity and the idx that change so you can take the capacity comma the index the idx as the key in your memoization dictionary and each time you compute so each time let's say you compute this or you compute this or you compute this store the result in the dictionary before returning it and then at the beginning of the recursive function check within the dictionary if this value is already present okay so remember what we did for longest common subsequence we defined a recursive function internally we defined a memo a dictionary internally and the recursive function kept either checking the dictionary or filling the dictionary if it could not find a value and that could eliminate a lot of the repeated work in your problem okay so that's the challenge for you to try out implement the memoize solution and what we'll do is we will go ahead and we will implement the dynamic programming solution so let's just commit our work once again and we've analyzed the algorithms complexity in recursion it's order 2 to the power of n in memoization now that's an exercise for you what do you think the complexity will be well let's apply dynamic programming so let's look at a dynamic programming solution now once again for dynamic programming you have to create a table you always almost always have to create a table for dynamic programming and in this case we can see that there are n elements so there are n rows within the table because we have n elements to choose from and we we have a number of columns going from zero to capacity plus one going from zero to capacity and that's why there are total of capacity plus one columns and in fact what we can do is we can also include another column at the top here another row at the top here which we have not which is not shown here but what n represents n is the number of elements so what n represents or or what the a particular element in the table represents so table of i comma c what it represents is the maximum profit that can be obtained using the first i elements if the maximum capacity is c so if your maximum capacity is c let's say your maximum capacity is three what is the maximum profit that you can obtain using the first two elements so um here let's say we are at this position so using the first two elements of the list within this capacity okay so the first two elements have weights one and two and the capacity is three so you can you can actually pick uh sorry the first two elements are weights two and three and the capacity is three so you either pick this element or pick this element now if you pick this element the profit is one and if if you pick this element the profit is two so the solution is to pick this element and you get uh you fill the capacity three and you get a profit of two you cannot pick both because your capacity is three okay so that's the logic here a very simple visual representation now remember that there will also be a zero throw here which we have not shown but this is something that should be here another zeroth row so the zeroth row represents that you've not picked any of the elements and if you don't pick any of the elements it is simply going to contain all zeros and that's why it's not shown here the first row assumes that you have picked you can pick only the first element so you can you you can't pick the first element till a capacity of two and then from a capacity of two onwards you pick the first element and that has a maximum capacity of one the maximum profit of one the second row or the row number two with row with index two represents the fact that you can pick both of these elements and if you can pick both of these elements once again at capacity 0 none of them can be picked at capacity 1 none of them can be picked at capacity 2 this element can be picked which has a weight 2 and it gives you a maximum profit of one at capacity three this element can also be picked so now you have a choice to pick between the two of these so you might as well better pick this one because this is going to give you higher profit and then finally when the capacity becomes 5 you can pick both of these elements and you can pick both of these elements and that is going to give you a profit of 2 plus 1 3 and so on so you keep filling out this table for each step here or for each set of first i elements you fill out the capacity table and then you use the information to fill out the next row and the next column and so on okay and finally your what we need is using all the elements and using the maximum capacity that we have what is the maximum profit that we can obtain so the last element of the table will give you the result okay so what does the logic look like we will fill the table row by row and column by column now if table of i comma c table of i comma c let's say this is a certain position here table of i comma c can be filled using some values in the row above it okay now if you look at the table of i comma c you you look at look at this element for example yeah let's look at this element here so in here c has the value 3 and then i has the value 0 which is a row that is not shown 1 2 3 4. so i has the value 4 and c has the value 3. so if yeah so if weights of i is greater than c so zero one two three four uh if though if this if this weight so this weight the weight of this element is greater than the capacity so the weight of this element is 4 it is greater than the capacity then this element cannot show up in this maximum profit why because its weight is greater than the capacity so obviously it cannot show up in the maximum profit now if it cannot show up in the maximum profit then the then this cell can be filled using the value above it because in any case you cannot put in this element so you might as well get the result by using the first three elements and in that case the value of this cell is obtained from the value of the cell above it that's one case now on the other hand let's come here you come to this case into this cell in to fill this cell because you have a capacity of 4 you have the option of either choosing this element or of not choosing this element now if you do choose this element let's say you choose this element with a capacity of 4 with a capacity of 4 you get back a profit of 9 and now you have no more capacity left to create more to fill more elements on the other hand if you do not choose this element then that's the same as this value because if you do not choose this element then you have to fill the capacity of 4 using the value of using the first three elements and that simply gives you the same highest profit as the previous cell right so you just consider these two cases whether we choose the element or we do not choose the element now if if you do not choose the element the value comes from above if you choose the element then the value comes from where let's see if you choose the element the profit of 9 comes and you fill out the capacity 4 so you have no remaining capacity but on the other hand if the capacity was 6 and you choose the element then you have chosen the element and you've used up the capacity 4 so you can still use the previous three elements to fill the remaining capacity which is six minus four so which is your capacity of two so you can go back to the previous row and check the capacity two and see how much was the maximum profit that you can obtain with capacity 2 and it turns out that with capacity 2 using the first 3 elements you can obtain a maximum profit of 1. so the maximum profit here when you choose the element is 9 plus 1 n similarly here a maximum profit that can be obtained if you choose the element is 9 plus 7 minus plus from the previous row you pick the element with a capacity 7 minus 4 which is 3 so 9 plus 5 14 okay so that's the logic here sometimes you choose the element sometimes you don't choose the element and in fact the solute the result of this cell is simply the maximum of either not choosing the elements the maximum of this cell or choosing the element and subtracting the weight which is six minus four two so maximum of this and that okay so let's implement this same dynamic programming solution once again do work this out on paper it really helps to work it out in paper but let's say we have max profit dp the dynamic programming solution we have weights we have profits and we have a capacity and then let's say n is len weights so we need to create a table so this is our table our table contains n rows so we have len n and then in for each of the rows we contain we have capacity plus one oh we contain n plus one rows remember we also want to consider the case where we don't consider where we don't take any of the elements and it is filled with zeros and the number of columns is capacity plus one to check the values from zero to capacity so that's our table right now you can check what this capacity looks like let's say n has n capacity i have the values here n in this case is 5 and capacity is 10. we don't need a len here you don't need a len here as well it's all perfectly natural to make these mistakes this should be range not len this should be a range and this should be arranged too yeah now you can see that we have created n rows or n plus one rows so one for each of these and then one more row above containing all which will contain all zeros this is in the case where we don't pick any of the elements and then we've created 11 columns so this is for capacity zero so again the first column will also contain all zeros and this is something that you will often see in dynamic programming you will have an additional row at the beginning or at the end containing all zeros and that is simply to make your calculations or computations easier but what that will lead to is off by one error so you need to be very careful while doing this and now we'll fill out this value using either this value or by subtracting the weight of the element that's here and getting a value from the previous row so now we start iterating so when now we say for i in range n and for j in range c let's just say for c in range capacity it should be capacity table of i comma c and it's actually going to be i plus 1 and c plus 1 because we have these additional rows and columns table of i plus 1 comma c plus 1 is there are two cases here if weights of i is greater than c the current capacity then we can simply look at the previous row so which is this case let's say the weight 3 is greater than the current capacity 2. so then we simply copy over the value from the previous row the same column so we just say table of i comma c plus one we see so our capacity should go from the value of 1 because we don't want to affect the first column so the capacity goes from the value of 1 to a value of 10. so capacity c goes from the range of 1 to capacity and if the weights i is greater than the capacity then we cannot fill the table on the other hand if it is if it fits within the capacity then we have two options the table of i plus one comma c has two options so one is we don't use the current element we don't use the current element and that gives us stable ic once again the other option is we use the current element so we get profit from the current element so profits i but we do not get profits but that reduces the capacity so we then have to pick table of i but now we have to pick c minus weight weights of i okay and that should fill out the entire table pretty much that's a nice thing about dynamic programming you simply just have to write this one solution or this one recurrence and be careful about it and everything else is taken care of by this loop here now we simply return table of minus one and minus one and let's see if that works it's likely that there are some issues here but let's see we have test cases max profit dp with the tests that we have great so we are seeing an issue already i see here that this should be range and this should be range okay one thing that we haven't done here is well it seems like our solution is always zero ah this should be capacity plus one so that we this takes all the values from zero to capacity right so c the iterator should take the values from one two three four all the way up to the maximum capacity and the range does not end so the range does not include the end value so you need to put capacity plus one here okay now with that out of the way you see once again these off by one errors are always going to bug you with dynamic programming i've probably solved 50 or 100 problems in dynamic programming but i still make these errors but with that out of the way you can see now that each of the test cases seems to pass now there may be other cases which you have not accounted for but overall we've covered all the test cases here and we've ended up with now a dynamic programming solution and i'll let you figure out the complexity here but once again it's pretty straightforward because we are filling up this table and filling up this table simply requires this constant amount of work which is a comparison and then potentially another comparison and an addition and a subtraction so like four or five operations so you have this n times and uh you have this n times capacit n times capacity where n is the length of weights and capacitor or w is a total capacity so n times w is the number of iterations and that really also is the complexity the time complexity of the algorithm so that's the knapsack problem and now what you can do is try and figure out not just what is the maximum value but also figure out what are the actual elements that were chosen now you can do this for the knapsack problem and you can do this for the longest subsequence problem figure out the actual longest subsequence and it should be possible to do that with just a small modification now use the forum if you have any questions about the contents of this lecture go back to the lesson page and open up the course community forum here you can see here that this is the lesson for recursion and dynamic programming lesson you can post your question here and you can also discuss ideas on how to figure out what the longest common subsequence is and what the best selection for the knapsack problem is so what do you do next well you can review the lecture video and execute the jupyter notebook the next step is also to complete the assignment now we have released assignments one and two so far if you go back on the lesson page you will find lessons you will find assignments one and two and you can work on them there is sufficient time and also work on optional questions and do participate in forum discussions and or if possible join or start a study group too that's a great way to stay motivated this was lesson 4 of data structures and algorithms in python thanks and talk to you soon hello and welcome to data structures and algorithms in python this is an online certification course being conducted by jovian today we are on lesson five graph algorithms like bfs dfs and shortest paths my name is akash and i am your instructor you can find me on twitter on akashens if you follow along with this course and complete all the assignments and build a course project you can earn a verified certificate of accomplishment for this course so with that let's get started the first thing we'll do is go to the course website pythondsa.com now you can point your browser to pythondsa.com to open up the course page and on the course page you can enroll for the course and you can view all the previous lessons and assignments so do check it out and do check out the course project as well but for now we'll open up lesson 5 graph algorithms now on this page you can watch a video for the lesson later the same video that you're watching right now and you can also catch a hindi version if you wish and here is the code that we are going to use today the first notebook under the heading notebooks so let's open it up and this is a jupiter notebook hosted on jovian you should be familiar with it by now but here you can see that there are some explanations and then there are some code cells where we can write some code you can see that there's some code here now to actually execute and edit this code we will need to run this notebook you can find the instructions to run the notebook right here but the simplest way to do it is to click run and select run on binder now this will take a second or two but this will take your jupiter notebook and create a new machine in the cloud and send your jupyter notebook to that machine for execution this is a free service that you can access via jovian you can also run this notebook on your own computer directly if you wish so for that you can check the run locally option here okay so our jupyter notebook server is now ready so we can now start editing and writing some code let's just go full screen here okay so the topic today is graph algorithms bfs dfs and shortest paths using python now before we talk about graph algorithms let's just try to understand intuitively what graphs are now here's an example of a graph in the real world so this is the railway map of india you can see here all the train stations that you have in india they're represented using these black dots points they're also labeled so each train station points to a city or a village so all these are also labeled and then you can see connections between these stations so these are as you might guess railway lines and you see that there are three or four colors involved so these colors could represent different types of railway lines like different gauge meter gauge broad gauge etc or these could represent different zones so there's some information contained in the connections as well now another important thing is that each railway line between two cities will also have a certain length so that's what a graph is roughly and the kind of questions that you may want to ask here is for example is there a path from new delhi to hyderabad so given this information first of all the question is how do you even represent all this information how because you have so many railway lines connections between different cities so many hundreds of cities how do you even represent this so that you can start writing algorithms to answer these questions right so if you're building a search a trained search website then you would have to answer given new delhi and hyderabad is there is there a way to get from new delhi to hyderabad okay that's the first question that you might ask now if there is a way then the next question might be that what is the path with the shortest number of stops so do you go this way for the shortest number of stops or do you go this way or do you go this way another question could be what is the path with the shortest distance right so sometimes if you measure the distance and if you measure the number of stations the number of stops they may be different along different paths and one may be greater than the other in in certain cases so those are the kind of questions that we want to ask and answer today or another question could be what are all the stations reachable from new delhi within one stop or two stops or three stops or ten stops so those are the kind of questions we'll try and answer and for that we need a way to represent graphs in a more abstract fashion because this same question can be asked in a different context for instance here we are looking at flight routes international flight routes now once again you can ask the exact same thing here is there a way to get from new delhi to vancouver now if there is then how many stops will that require what is the minimum number of stops we can take to get from new delhi to vancouver or what is the minimum time it might take maybe if you you're okay with taking multiple stops but you want to minimize the the the time taken or the distance traveled because you're concerned with the miles or for some reason another thing you could ask is what is the minimum cost if there is a cost along each route okay now here's one more example from a very different domain this is hyperlinks or the internet essentially so you can see here here you have a whole bunch of websites and you have links on websites now links on websites point to other websites and in this case it is a oneway connection you can see that from this particular course website we have a link to ibm but from ibm you may not have a link to this course website now that's an interesting thing that's a slight variation here and this is called a directed graph because each connection here is has a particular direction now this is again interesting to ask is there a way to navigate from cs.umass.edu to ithaca weather if there is what is the shortest way what do what does that path look like so those are the kind of questions that we want to answer today and to do that we will need a more abstract representation of graphs and we start with the simplest possible representation where you have certain points or what we will call nodes or vertices so these are two terms that are used for these points so nodes or vertices a graph has certain nodes or vertices and just to make things easy these could be cities or these could be web pages or these could be something else but just to make things easy what we'll do is we will number the nodes so in our graph if we have 10 nodes then we will number the nodes from 0 to 9. okay this is and they can be numbered completely arbitrarily there's no reason to name number the 0 number this one what's more important is that we should use up all the all the numbers from 0 to n minus 1 if we're dealing with n nodes now why do we do that we'll see in a moment when we try to represent graphs using certain data structures like adjacence adjacency list etc but we want to number our nodes from 0 to n minus 1 and this number is arbitrary this 1 doesn't represent anything in the sense that 1 being greater than 0 or so on okay so these nodes have labels and then you have edges between nodes so an edge is simply a pair an edge is simply something like 1 comma 2. so a pair 1 comma 2 tells you that there is an edge between the node one and node two okay now as we move forward we will also store some information within an edge and we will call that weight of an edge and we will also later look at directed edges and those will get us directed graphs but let's start with this and let's see how we can now represent with this basic structure how we can represent a graph so we can represent a graph using two variables so one is called a number of nodes and the number of nodes is in this case 5 and then we can represent the edges using a list of pairs so in this case the pairs are zero comma one in this case the pairs are zero comma one that's an edge then zero comma four that's an edge too then we have 1 comma 2 so 1 is connected to 2 and the edge in this case is bidirectional so when we are saying 0 comma 1 we're saying it automatically says that 1 and 0 are also connected right so 1 comma 2 and then we have 2 comma 3 and which order we write these in doesn't matter we could have just written 3 comma 2 here as well or we also have 1 comma 3 and then we have one comma four great and then finally we have three comma four okay so this is how we represent this data structure which what we've drawn here is now represented in code using these two variables and we can check here if we simply print the number of nodes and the length of edges we can verify if this is roughly correct so you see we have five nodes and we have one two three four five six seven edges okay seems right to me we could there may be a mistake here but roughly uh we have set things up correctly okay now the question becomes is this question is this representation good enough now this representation is good enough if you want to convey the structure of a graph to someone i could give you these two variables and then without showing you this image and you could use this information to draw the graph on a piece of paper so this representation is complete it provides all the information about the graph but it may not be efficient for example if you want to find out which nodes the node 1 is connected to we would have to iterate over the entire list of edges we would have to go through this one and then check if either of these is one and check if either of these is one and so on so that makes it very tricky to access any information efficiently rather it'll be much nicer to just look at a list of nodes that one is connected to in some way and go from there now if you want to find the shortest path we would first have to find all the nodes that one is connected to and then for each of those we would have to find their neighbors and then for each of those we would find have to find their neighbors and so on so it would get pretty tedious to go through the list so many times that's why and by the way by a neighbor we represent we mean two nodes that are connected by an edge so zero and one are neighbors but zero and two are not neighbors okay so that's a very simple nomenclature that we can use and what we can say is if we track the path we say 0 1 2 and then if there is an edge between both of them we say that 0 1 2 is a path so 0 1 2 in this case is a path but 3 zero one is not a path because there is no path but there's no edge between three and zero okay and we'll see what what we mean by paths and neighbors and so on in some time but to work with graphs more efficiently we will represent them using what's called an adjacency list now the name it explains what it contains so the adjacency list contains a list for each node and it contains a list of all the nodes that are adjacent to that node now again adjacency is the same as an adjacent is same as neighbor so if for each node so for example for the node 0 we we maintain a list and that list contains the numbers one and four indicating that zero is adjacent to or zero is a neighbor of or zero is connected via a direct edge to one and four so that's why you have one and four here and then one is connected to zero two three and four you can see that one is connected to zero two three and four similarly two is connected to one and three three is connected to one two four and four is connected to 0 1 3. now this is more convenient for sure one because since this is an uh this is a list if you want to find let's say which nodes 2 is connected to we can directly access the index 2 within the list and this is why we number the vertices or the number of the nodes from 0 to n minus 1 so that we can access them directly in an adjacency list right so we directly access the number stored next to 2 and so we have one and three here so that's what makes it convenient and one important thing to notice here is that edges each edge goes twice so the edge zero one shows up in the list for zero so you can see here in the list for zero we have one and similarly in the list for one we have zero so each edge shows up in two adjacency list of each of the nodes that it connects okay so now the obvious next question might be to create a class to represent a graph as an adjacency list in python okay this is again a question that you might get asked a step or this might be part of another question that you may get asked where you're asked to perform a breadth first search or depth first search or find the shortest path but the first step you will have to do is define a class for a graph to maintain the information about the graph as the adjacency list okay so here we're creating a class graph and the first thing we'll need inside the graph is a constructor function so we need to put something inside the constructor function and we know that the first argument to any graph any class method in python is self which represents the object that will get created ultimately when we create an object of the class but apart from this what information do you need to create a graph now it's pretty straightforward we can simply work with this information because these two variables together specify the graph completely so let's simply accept num nodes and a list of edges as the information the first thing we can do is simply store num nodes in self.num nodes so that once we create a graph we can access the number of nodes very easily then we need to create the adjacency list so we need to create the adjacency list we'll call it self.data and initially we will create a list containing empty lists because and then we will fill out the empty list step by step so what we need is something like this in this case because there are five because there are five nodes so this is what we need to create the five empty lists now in general the way to create repeated elements is this you can say if you want to create a repeated element like this 0 times you type 0 times 10 and that gives you this list 0 0 or containing all zeros on the other hand if you create empty list times 10 and let's call this l1 and let's see what l1 is it looks like you've gotten an empty list you've got in a list containing 10 empty lists but let's just go into the first element so the first element is this first empty list and inside the first element let us add the value one okay and then let's look at the let's look at the list l1 once again and you see what happens this one gets inserted into all of these lists now what's the problem here now the problem here is that when we do this when we create a list containing an empty list or containing any object then the same object gets replicated 10 times but python does not create copies now when you're working with numbers it's fine because when you're working with let's say the number zero that's fine because there's no internal structure inside zero right so there's nothing you can change inside the zero it's a fixed value fixed immutable value so what so you can you can't really say l one of zero and change its value internally what you can do is you can set l one of zero to another value let's say you can set l1 of zero to one so instead of getting all zeros you get all ones but you cannot take this take the zero and change something inside it on the other hand when you have an empty list here so this is the same list that is showing up in 10 different showing up 10 different times each of the each of the elements in the list outer list is simply a pointer to this same empty list so what we can do is we can go inside this empty list and append something to it so since this is the same object that we are seeing over and over the one gets appended to the first list and because the rest of them are the same object we get back all once inside here okay so this is a com the reason we're spending time here is because there's a common common bug that you may unintentionally execute whenever you want to create an list of empty lists do not use this method so what's the method you should use then so here's one method you can use let's say you want to create a list of empty list of size 10 so you may be familiar with this object this this object called range this function called range what this does is if you view it as a list you can see that it contains all the elements from 0 to 9. okay now if you view the range itself it simply shows you 0 to 10 but when you convert it into a list you can see that internally it contains the value zero to nine okay so you can take this range and you can do something like this put this range or put anything which is iterable inside these brackets the list brackets and then say for x in range and simply put x so what did that do that did practically nothing we simply took x from the range of 0 to 10 and returned x itself so we created a new list like this but suppose we multiplied it by two here x by two so for each element in the range we are multiplying it by two so we get back a new list which is zero two four six eight so this is each element is the double of the elements that we have in the range now what we need is we need just empty lists right so we can simply put an empty list here and we can ignore this value x that we get here so now we get back a whole bunch of empty lists so let's call this l2 and what we are now doing is for each element in the range we are creating a new empty list so this is important so now when you do l2 0 dot append 1 and then check l2 you can see that one was only inserted inside the first list so keep keep out watch out for this this is something that you will probably go wrong with at some point i've gone wrong many times and one last change we can make here is whenever you're not using a variable in python it's always a good idea to just call it underscore you can still call it x but your sometimes somebody reading your code may not understand why you have declared a variable and not used it and assume that maybe you've made a mistake so just to make things very clear it's always a good idea to make something underscore it's also a variable name a valid name and mark something is underscore if it is not being used okay so with that whole discussion about lists we now know how to create a list of empty lists so here you have a list of empty lists or underscore in range num nodes so now we have created a list of empty lists then for each edge in edges we need to do something so we need to insert it into the right lists okay now what does for edge and edges look like so let's see for edge in edges print edge okay each edge is a pair we already know that and when you have pairs or tuples here you can get them get the values out so let's say let's call them n1 and n2 node 1 and node 2. you can get the values n 1 and n 2 out like this so now we can say print n 1 and print n 2. you can see that we are able to get values n1 and 2 out directly within the for loop so let's call this n1 and n2 and now this is a much more pythonic way of writing code so one of the things that we are also learning is how to write code which is more pythonic or which is idiomatic in python and this is again something that will impress people when you use it in an interview or a coding challenge so for n1 and n2 in edges what we need to do is first we get self data of n1 so this gives us the adjacency list for n1 the first node and here we append the value n2 and similarly we do the same for n2 and we append n1 to it and that's it now we've set up the graph let's create a graph g1 let's call this graph 1 maybe and we simply invoke the graph function and then we give it a number of nodes and the edges right so remember self will be passed in by python automatically as the object that is getting created so the graph one object essentially so now the number of nodes is five and we have a list of edges and let's see what graph1.data looks like so there you go you can see that zero is connected to one and four and one is connected to zero two three four and so on now while this is okay it would be nicer to print it like this so maybe let's see if we can print it like this and the way to do that is to define a wrapper function so we define a function called underscore underscore repr and it contains it simply takes self as the input and what we are going to do is we are going to go over we're going to call enumerate on self.data now what does that give us let's just check what enumerate on self.data give us gives us well maybe before we do that let's see what enumerate on a list gives us enumerate on a list gives us this object but let's just get the value out of it in a for loop because you can use an enumerate in a for loop and just print x so what enumerate gives us is it gives us the values from the list but apart from those values it also gives us indices okay so you can get an index i and a value v out of enumerate so then you can see that you can print both i and v here and you will get back the same output so what we can say is we can do enumerate self.data now because self.data contains these elements so what we'll get back is we'll get back pairs let's see here we'll get back pairs 0 comma 1 4 1 comma 0 2 3 4 2 comma 2 1 3 now this is starting to look a lot like what we want okay so we'll just take enumerate self data and these we'll take these pairs so the pairs will be a node so node n and its neighbors the so we have the node n so the node n will first be 0 and its neighbors will be 1 and 4 node n will be 1 and its neighbor will be 1 and 2 and so on and then so for n comma neighbors in enumerate what we'll do is we simply create a simple string and here we are using string formatting we are simply creating this string where we put this here we place a placeholder where we put n and then here we put a placeholder where we put neighbors again let's just see what that looks like and this is the best thing about jupiter while you're writing code you can test your code right then and there simply by creating putting data into a new into a new cell so let's see graph1.data so you can see here that now we have now we have converted that enumerated list into a list of strings so we have a string here this is the string 0 pointing to one comma four this is a string one point this one pointing to zero two three four and so on but this is still a list of strings what we need to return from the wrapper function is a single string so the way to join them together whenever you have a list of strings and you want to join them together all you need to do is you say what you want to join them with so we want to join them with a new line and then call the join function on that string and return that right so that is our wrapper function and we'll see its users in just a moment and similarly we have another function called str now wrapper is used when we simply type graph one so when we type graph one this is the output of the default wrapper function now this will get replaced by the wrapper function that we are defining but when we do str of graph one or when we do print of graph one or when we insert graph1 into string that is when the str function is used now we will simply use the wrapper representation so let's just put self dot underscore underscore rdpr and that's it okay so let's see now let's put let's type graph one here and you can see that now we have this representation printed using this wrapper function that we've defined so we have zero one four one zero two three four two connected to one three three connected to one two four and four connected to zero one and three okay so now we have a graph data structure that we've implemented using a class so the adjacency list and we have a nice way to print it out and this is just good programming practice now you don't have to do this in a coding competition or you don't have to do this it's good if you do it in an interview if let's say you're able to type this out quickly but when you are working when you are working on your own problems or on your own code or on a project always make sure that any classes you define have a good string representation so that when you type the name of a variable you understand what it represents and you don't have to spend time thinking about it make it clear to yourself okay so that's the adjacency list and we'll see how that is useful in just a few moments but here are a couple of questions for you try writing a function to add an edge to a graph that is represented as an adjacency list okay so here we've specified all the edges right in the beginning but can you write a function add edge which takes a couple of nodes and it inserts an edge between those two nodes and here's a hint this code might be useful so do try that out now here's another one can you write a function to remove an edge from a graph which is represented as an adjacency list here you may have to use the list remove functions to remove a particular element from a list but these are two good exercises to complete here okay now before we continue let's just save our work and we know that this notebook is running on binder which is a free service so we'll just save our work by running jovian.commit and what that will do is that will capture a snapshot of this notebook all the changes that you've made and put this on your jovian profile now this will go on your jovian profile from where you can continue running it continue executing it from where you have left off okay now another common representation for graphs is called the adjacency matrix which is slightly different from adjacency lists in this case for example the same graph here is represented using this matrix so what we do is we create a matrix of size n by n if n is the number of if n is the number of nodes in the graph and then for each node for instance since we have zero and since we have a edge between one and two so if you take the first row row number one and column number two you put a one there otherwise if there's no edge for example there's no edge between zero and two you take the zero throw and column number two the you put a zero there okay so you put a one wherever there is an edge between the two nodes and you put a zero wherever there isn't you can see that there is this reflection reflexive property here because one two is one and two one is also one because these are undirected edges now of course if this is a directed graph this would be different okay so an exercise for you once again is to represent a graph as an adjacency matrix in python shouldn't be too hard all you have to do is instead of so in adjacency list we initialized a list of empty lists here you may want to initialize a list of zeros a list containing lists of zeros okay and then you may simply just want to fill in the zero once in the right places now adjacency matrices have their own benefits sometimes they are more useful for example when you want to immediately check if there is an edge between two vertices or two nodes you can quickly look up look it up in the adjacency matrix but in the adjacency list you will have to get the list for one of them and then search through that list which is fine for most cases but in some cases you may just want an adjacency matrix as well so that's one other way you can represent a graph and that's an exercise for you okay so now we know we've represented graphs and now we can start looking at some graph algorithms and probably the most common graph algorithm something that you will ultimately get asked in one interview or the other if you're interviewing with a bunch of companies is breadth first search and breadth first search well this is what it looks like so suppose you have this this is a real world graph that we're looking at so these are cities in germany and you can see that there are roads between these cities and we have lengths of each road now we can ignore the lens for now what's important is that these cities are connected to each other but not all cities are connected to all of them all of the others so starting from frankfurt you may want to find out which are the cities that are that you can reach from frankfurt without stopping so which are the cities that are one edge away from frankfurt and if you look at it this way it turns out that mannheim castle and wurzburg are the three cities that are one edge away from frankfurt right so if you start drawing this tree of sorts so you will find that mannheim wurzburg and castle are one edge away okay then you might ask which are the cities which are two edges away from frankfurt so now the cities that are manheim is connected to karlsruhe and wurzburg is connected to these two cities and then castle is connected to this city okay so here you have these other cities and then you might ask which are the cities that are three steps away from the from frankfurt and that would be the remaining two cities augsburg and stuttgart okay now i'll let you think about this but what you will find in this way as you go step by step by step like first you're finding all the cities that are one step away so all the nodes that are one step away from a source node then you're finding all the nodes that are two steps away from a source node what this will give you is ultimately you will end up for each node you will find out how far away it is from the source and that will be the length of the shortest path between the two okay and you can verify that i'll let you think about it for instance if you see you can go to castle by going this way from wurzburg to nurenberg to mission to castle but that would not be the shortest path but binary search the this is called breadth first search brett first search will always discover the shortest path because we're first finding all the nodes at distance one and then we're finding all the nodes at distance two and then we're finding all the nodes at distance three and if a node at distance three has a shorter path then it would have been already found when we are finding nodes of length one or two or distance one or two okay so that's brett first search so here's one problem that you might face in an interview implement breadth first search given a source node in a graph using python and here is some pseudo code this is so it's always a good idea to write or explain your approach in plain english before you implement it so that you do not make mistakes while coding so here for here is the pseudo code so if you have to write a function bfs which takes a graph and a root or a source node so first we say create a queue so we're creating and this is taken by from wikipedia so first we create a queue and what's a queue well a queue is a very simple data structure a queue is simply a list and it follows a first in first out of policy so when you have a list and you want to add something into a queue it's also called enqueue the enqueue operation so when you want to add something into a queue you add it at the end okay so you have a list and then you simply keep adding things at the end you just append things at the end of a list but when you want to access something from a queue you do not access any value directly no you always access the first available value okay you access the first available value in this case what what is called the value in front and when you access a value it gets removed okay so it's so in this way you can see that it implements the the first gen first out policy like if first we enqueue one and then we enqueue three and then we on q4 and then we want to dq and when we want to dq we simply get the first value that was inserted which is 1. then maybe we enqueue a few more numbers 5 2 7 then we dq and then we get back the first value that we had inserted which is not yet dequeued so then we get back four or whatever was the was the second value inserted initially right so that's a queue and we let's see how a queue is useful so we create a queue and then we mark the label we mark root we label the root node as discovered okay so we need to somehow track which nodes have been discovered or visited and first what we'll do is we will mark the root node so let's say we're starting from the node three we will mark three as discovered so three is now discovered and as soon as we mark something as discovered we will enqueue it okay then while the queue is not empty which is why we have not accessed all the elements in the queue or well we have not dequeued all the elements from the queue we dequeue an element so we dequeue the first element which has not yet been removed from the queue and if we are looking for a particular goal node then we can simply end there like we found that node but we are not looking for a goal node so let's remove this code yeah so we get we get the first element or the first node from the queue which is not yet dequeued and then so for example initially we just have three in the queue so then we get back three we get three back from the queue then we check all the edges for three so we check that three is connected to one and three is connected to two and three is connected to four so we see all the edges for three and if the other end of the edge we check for each node let's say the other end of this edge is 2 we check if 2 is not yet discovered or not yet visited then we enqueued 2 into the queue similarly we check for 1 and if one is not yet already discovered we enqueue one into the list similarly for four we enqueue four into the list okay so we have dequeued three so three is no longer in the queue or we've moved forward are we no longer going to get q a three out of the cube but now we've enqueued two one and four and two one and four we now understand they are at distance one so when we pick the next element of the queue we dequeue the next element the first in first and first out we get back 2 and then we mark 2 as visited great now we visited 2. oh no we we mark as soon as we are adding something to a queue we also mark them as visited because we've identified that 2 1 and 4 are all at distance 1 from 3 and we've added them to a queue so we mark them as visited now when we get 2 out of the queue in the next iteration we check if there are any nodes which 2 is connected to those are not yet visited so 2 is connected to 1 but 1 is already visited so there's no need to enqueue it again and then 2 is connected to 3 but 3 is already visited so there's no need to encue it again and so we just move forward then we go to 1 and when we go to 1 we realize that 0 is not yet visited so we enqueue 0 4 is visited so we don't enqueue four okay and that's how we proceed so now what you should do is you should draw this on a piece of paper and work it out just write on a piece of paper what would be the first element that gets inserted and what will be the elements that we will insert into the queue etc etc but this is the algorithm here exactly what we what we just discovered so we dequeue in a vertex for all the edges that start from the vertex v or the node v if the other end of the edge is not labeled as discovered then mark it as discovered and enqueue it into the queue let's implement this let's see if we can implement this live so we are implementing bfs where we will get a graph and a source node the first thing we need to set up is a queue so the queue is empty then we set up discovered and discovered will be false initially and it will have the length so we want to mark it false for all the elements okay and remember now we can use this notation here because false is an immutable value so it doesn't matter so so we don't really need to use the range or the list comprehension notation here then here let's come here so we mark the label root as discovered so discovered of source let's just call it root so that we don't get confused with the terminology so we mark discovered of root as true great then we insert or we enqueue the root so we we type q dot append now enqueue simply means adding something to the end and you know how to do that in a list you simply call q dot append so q dot append root great now python list by default do not support a dq operation so what we will do is we will set up an index which will track the first available element in the queue okay so whenever we dequeue an element we will increase the index so that we move forward so here we have the index idx equal to zero so now while there are elements in the queue which means while the next available index is less than the length of the queue first we will get the current we will dq so dequeuing simply means getting the getting the first in element the element that was most recently inserted and has not been dequeued so we get current is q of idx and then we can also increase idx so as soon as we dequeue something we update the index so you can imagine that the index starts out here and when we dequeue this or delete this then we get that value out and then we update the index to the next position okay so now we have the current this is the dq operation then what do we have next now we want to check all the edges of current right so we are going to say for so remember we have the adjacency list representation so we will get for node in self.data current so self.datacurrent contains a list of all the nodes that are connected with the current node so for node in self.datacurrent if not discovered node so if you have not yet discovered the node then we first mark it at this as discovered and then we add it to the queue so we do q dot append node okay so what you end up with this way is first you have the source that got added to queue and then we inserted all the inserted all the nodes which were at a distance one from source and then we insert then if you follow the trajectory you'll see that we we will insert all the nodes that are at a distance to from q and so on right so ultimately when we end up with this entire process we will have the q and the queue will contain the list of nodes as they would be visited in a binary in a breadth first search okay so we can simply return the queue here so let's try it out so we have graph one and let's call bfs and graph1 is this graph so let's grab this image as well so let's simply copy the code for the image and come down here let's come down here and put the image here okay let's call bfs on graph one starting at the node three okay of course this should be called graph.data so because graph is the graph that we're working with so we need to check graph or data here okay so we start out with the note 3 and you can see that three first causes one two and four to get inserted and then one causes two to get inserted okay now that's bfs for you it's pretty much done at this point but what would also be helpful is maybe to keep track of what is the distance of each node right so we can also track we can also keep track of a distance so let's say we have a distance which we initially set to none or yeah which we initially set to none and we will track a distance for from each for each node so we have the distance here and initially we are going to set the distance for the root to zero of course because the root is at zero distance from itself and the distance here means the number of edges right then when something is discovered so when we are discovering a node and that node was not already previously discovered that means that the distance for that node is one more than the distance for the current node which caused it to be discovered right so the distance for so for example if you're starting with three the distance for one is one more than three which caused one to be discovered and the distance for zero is going to be 1 more than 1 which caused 0 to be discovered so that's the distance great we've now also tracked the distance one other thing that would be nice to have is what is called the parent if you see if you go back here you can see that it would be nice to know what led to carl's room being discovered was it mannheim wurzburg or castle so that we can work our way backwards and find a path from frankfurt to carl's room okay so for that what we can do is we can keep track of a dictionary of a list called parent once again we will have no parents uh by default so parent none and whenever we find a node and that node was not already discovered then we can set the parent of that node to the current node which caused it to be discovered okay and now we can return from the queue the distance and the parent so let's see if that works okay so it seems like now we have these are this is the this is the order in which the nodes are being visited you can see that 3 is the first node to be visited and 3 has and if you want to check the distance of 3 you can see that the distance of three is zero so this is distance is given in the order of the nodes in the order of the original numbering of the node so you can see that three is at a distance zero from itself obviously then you have one two and four now if you want to check the distance of one just check the index number one here so one is at a distance one if you want to check the distance of two now that is at a distance of one as well you can check here and then you want to check the distance of four 4 is also at a distance of 1 right so all of these 1 2 and 4 are at a distance of 1 from the root node 3 and also you can see here that the parent of 1 remember these are 0 1 2 3 4. these are the indices of the nodes so the parent of one is three and the parent of two is three as well and the parent of four is three three itself does not have a parent that's why this is none and finally the last node we visit is zero and it is at a distance two you can see it is the this distance here is indeed the highest and the parent for zero is one right so because one was the first node that caused zero to be visited it could have been four two but in this case just how we implemented it one was the first node which caused it to be visited so one is the parent of zero so if you now want to find the path from three to zero you can look at the parent of zero that would be one and then you can look at the parent of one that would be three and we are done so we can work backwards from the target we can keep checking the parent after parent of the target and that will give us the entire path so now we have the path we have the distance and we have the order in which these nodes will be visited so you may get asked bret first search in all these different variations but roughly this is what the code looks like and you can see here that the code is not too long now we have created all these additional additional lists but you don't really need them so the code is about 15 lines of code 10 to 15 12 to 15 lines of code not more than that so that's bfs again if you're working on a bfs problem it always helps to first state it in simple words and work it out with an example and then start coding so that you do not make mistakes while coding now one question that you can work on is to check if all the nodes in a graph are connected this may not always be the case so for example here you can see that all the nodes in the graph are connected but sometimes you may have a situation where some nodes are not connected for instance if these edges 1 1 2 and 3 2 weren't present then 2 would not be connected to 0 and maybe 2 is connected to 5 and 6 etc so here is one graph where not all the nodes are connected to each other you can see that there are nine nodes but there are only eight edges and if you look carefully you will see that 0 1 2 3 0 1 2 3 are connected but there is no connection from these nodes to 4 so 4 5 6 are then connected separately and then seven eight are connected to each other but not to one another right so can you use breadth first search to determine if all the nodes in a graph are connected i would reckon yes look at this q now this queue gives you all the nodes that starting from the source node are connected to the source node by zero one two three or so many steps if something is not connected it will not show up in the queue so you can simply check the length of the queue and see if that is less than the total number of nodes and then use that to determine if all the nodes are connected or not now another related question that you may get asked is to find the number of connected components in the graph now what's a connected component if you take a set of nodes that's connected that's one component and if you remove that then you look at the next set of nodes that's connected that's two components if you remove that then you take the next set of nodes that connected that are connected that and that gives you the third connected component and so on so in this case for example you have this is one connected component you can check by drawing the graph and then this would be one connected component and then these would form one connected component so zero one two three would be one connected component four five six would be another and seven eight would be another can you find the number of connected components or even can you list all the connected components of a graph using bfs yes you can again a very simple way to do it is just pick the first node perform bfs from the first node that gives you the connected component that contains the first node then find the first index which is the first node which is not yet visited start bfs from that node now that will give you the connected component for the second node and then find and then keep doing keep repeating this till all the nodes have been visited okay that's another question that you might get find the number of connected components or find a list all the connected components in a graph the bfs is a very versatile algorithm that can be applied to solve pretty much most graph problems that you may get asked in an interview so do do work on a few bfs problems and get some practice with it now another way to work through a graph to look through a graph is what is called dfs and this is the way in which you would normally explore a maze where you start out in one direction and then keep going so for example we started out here and then we kept going till we hit an end right so you can see here that we kept going until we hit an end and then we turned back and then we tried the next path and then we turned back and tried the next path and so on so we go like this then we turn back we try 5 go like this turn back we try 8 then we turn back try 9 10. that's another way to go about it and it's some cases in some cases bfs makes more sense in some cases dfs makes more sense and you can in most cases both of them work just fine for most problems so you can implement either one when you are faced with a graph problem so let's implement dfs or depth first search okay now here is a depth first search it's pretty straightforward you have you pick a node and then you pursue the the node and the next node then the next node and so on among the edges you pick one node and then once once you've exhausted the path along one edge you come back and try the next edge and then you come back and try the next edge so there are two ways to write it there is a way to write it recursively and then there is a way to write it without recursion and i'll leave it as an exercise for you to write it recursively but what we'll do is we will write it without recursion and you write without recursion we will use something called a stack we will use a stack and a stack is another data structure very simple list like data structure but it's just like a queue but it's different instead of being first in first out which is what we do in a queue in a stack we perform last in first out so here's how it works you start with an empty stack so you can think of it like this container or a cookie jar and you start putting in things into that jar you put in one and you put in two and you put in three so now when you have to remove an element from the stack or you want to access an element from the stack the only element that you can access is the element that was inserted most recently so last in first out that's a stack how is that going to be useful it's pretty straightforward if you think about it because this node when you start from this as the source you will add all these three into the let's say you add these three into the stack now if you add these three uh let's add them in this order so you start with this node then you add this this and this so you add these three into the stack then the last in value was two okay so then what you do is you extract two out and then you insert everything that two is connected to into the stack so you insert three into the stack and then you the last in value was three so you insert you take out three and then you insert four into the stack then the last in value was four then you take out four and you have nothing left to insert so now this entire path has been exhausted so then you end up with this five now when you end up with five you can insert its name neighbors eight and six into the stack and once six gets inserted into the stack uh then you take out six and you put seven into the stack and so on right so you can see how depth first search is working using a stack and roughly this is what the procedure the process looks like you start a stack it's empty push push the current source let's say the root node which you are starting with put the root into the stack now while the stack is not empty pop the stack so get the last 10 value from the stack and that gets removed as soon as we call pop then if that node is not already discovered then we mark it as discovered and then for all the edges from v to w so for all of its neighbors we simply push them into the stack right so that's it that's all we are doing all of its neighbors which are not already visited we can simply push push them into the stack okay so let's do that let's implement dfs and once again we will keep this picture in mind so let me just grab this picture here as well this is one of the nice things about jupiter that you can take these images and simply include them within your jupyter notebook while coding so that you don't make any mistakes so let's say we're writing define dfs and once again let's assume that we are going to start from 3 and this picture is graph one so let's say we are starting from three so define dfs graph and we have a root node that we want to start with and the first thing we want to do is we want to create a stack and you can use a list as a stack adding you can simply add things to the end and then pop them from the end so we create the stack and then we find discovered we mark discovered as false for every node len graft or data then we say stack dot insert so stack dot append so we simply add the number three to the end or the root number to the end so stack dot append root and then we don't mark it as discovered yet now this is the interesting thing in dfs because remember when you start out with three you want you don't want to mark four one and two all of them as discovered you want to put them into the stack but only when they come out you want to mark it as discovered because you want to discover four and then you want to discover zero before you discover one so that's why we put these into the stack but we don't really mark them as discovered just yet so that's why we are not marking the root as discovered then while lens stack is greater than zero we get the current value so the current value would be stack dot pop so interestingly python lists two support a pop operation so if you have a list and then you do l1 dot pop you can see that the value v that you get from l one dot pop is the value two and l one now has the value five comma six okay so you can use a dictionary or you can use a python list like a stack in fact we can even try append here to see the entire process let's say we are appending three and then we are popping three so we get back three and five six two remains so we pop the current node and then we mark it as discovered so we mark it as discovered here discovered of current is true and we may also just want to store that this is the result that we have so we may also just want to create a result list where every time we pop something we are also going to add it to the result list so let's say result dot append current and then we are finally going to return the result okay but here's the main logic so for all the nodes in graph dot data current we are simply going to push those nodes into the stack so we are simply going to say stack dot append node okay so what we do is we start with three and we then pop three and add it to the result and then we put one two and four into the stack we don't mark them as discovered yet then we pop one and then we put all of these zero two three four into the stack we don't mark them as discovered yet we mark one is discovered now then we pop zero because sorry then we pop four not one because we insert one to four so four is the last inserted value so then we pop for four we mark it as discovered and then we insert zero one and three now you can see that there is some repetition here we're also inserting three once again so just to avoid that what we can do is we can say if not discovered node only then add it to the stack right there's no point in adding something to a stack if it is not all if it is already discovered so now with that in mind let's see we start with three and then we insert one two and four great four is the last value inserted so three is discovered now four is the last value inserted so we pop four and then we insert 0 1 but we don't insert 3 because it's visited so now 1 is the last value inserted then we pop 1 and we try to insert some of these other values it seems like everything is already inserted so nothing will get inserted then the only thing that remains is zero so we pop zero then we pop once we have popped zero we are going to pop four so the order in which we expect to see things is three four one zero two i believe let's see dfs graph one starting at the node three okay so it looks like we have zero one so it looks like we made a mistake because we got some repeated values here and that's because we may want to just check if not discovered current we may want to just add this check and put everything inside this check so that any older values that have been inserted into the stack which are already visited later sometime through another value in the stack that gets ignored so we end up with three one three four one two zero right so it goes like this first we go from three to four to one to 2 and then we go from 3 to 4 to 0. so that's how it goes now a challenge for you is to also implement distance now in this case the distance will not really make sense because this is not the shortest distance anymore so when you want to get shortest distance from one node to another then you want to use bfs not dfs because if you track distance here you may end up going by dfs three to four to one to two and that is going to give you a distance of or a distance of three to getting to two although the shorter distance is one so maybe distance doesn't make sense here but what you may want to put in is the parent you may want to track the parent for each node should be simple enough to do whenever you are popping something you may just want to track its parent okay that's an exercise for you another exercise that you can try is to write a function to detect a cycle in a graph now when you're performing dfs let's say you are going about performing dfs starting at one and you do this and then you end up here back at one right because you go to from one to two two to zero and when you notice that zero points to one which is already visited that gives you an indication that there is a cycle in the graph a cycle is simply a path which leads from a node to itself so 1 2 0 1 is a path and a path is something a path is a sequence of edges so 1 2 is an edge 2 0 is an edge and 0 1 is the edge so this is a path but 1 2 and 2 4 is not an edge so 1 to 4 is not a valid path right so cycle is simply a path that leads a node leads from a node to itself so the challenge for you is to write a function to detect a cycle in a graph another challenge for you is to detect maybe the number of cycles in a graph okay so that's another thing that you can try out but we will move on to another problem now we will talk about weighted graphs and get closer to that example of the railway map that we looked at initially so here you have nodes so you have nodes numbered from 0 to 8 so you have a total of 9 nodes and you have edges too now these edges also have weights and this could be distances for example the railway line or this could represent any other information which is of value to you right so you decide what edge weights are what they mean in the abstract representation we simply call them weights so this is a weighted graph and here is an example of how we can convey the information about a weighted graph i can give you the number of nodes and then i can give you a list of edges so the first two elements of each edge tell you which nodes are connected like the nodes 0 and 1 are connected here and then the last element of the list or the third element of the list tells you if it is weighted if there is a weight associated with the edge okay so you have 0 1 3 and then you have 0 3 2 so 0 is connected to 3 and it has a weight 2 and so on and you can verify that there are 10 edges here and these are the 10 edges with the 10 weights so that's one variation that we see in graphs here is another variation this is called a directed graph in this case edges have a certain direction so this corresponds to the example of hyperlinks where we have pages web pages on the internet and one page can link to the other but the other page may not necessarily link back they may in which case you may have a bidirectional edge but in most cases there you would have a single unidirectional edge so you have 0 1 1 2 and 2 3. now directed graphs can be represented just the same way as undirected graphs all we need to do is we need to provide some information that this is a directed graph right so you can simply say uh directed equals true and that will simply and once you provide all these all this information that can then specify to the person who is going through this data that this is a directed graph right uh so here's how it's exactly the same as a normal undirected graph but when we create the adjacency list we can have a graph we can have a node from 0 to 1 but we should not put 0 into the adjacency list for one because there's no way from uh to there's no direct h from one to zero there's only a direct edge from zero to one so keep that in mind and similarly in the adjacency list now you will not set both the values zero one and one zero two one you will only set one of them corresponding to the one direction unless of course there is a bidirectional edge and what we can do is we can even combine directed graphs and weighted graphs so here's the here's what we'll do we will define a class which can represent weighted and directed graphs in python so we'll use it to represent undirected graphs directed graphs and weighted graphs all of these and we will take some information in the constructor to capture this detail so let's say let's create a class graph once again we will create a constructor now this has the self which is the object that gets created always the first argument to any method in a class in python then we take the num nodes then we take the edges and then we take a couple more arguments we take a argument directed which has a default value false and we take the argument weighted which has a default value false okay and we're going to store the information self dot directed let's store self dot num nodes as num nodes self dot directed as directed self dot weighted is weighted okay so now we come to the edges so for edge in edges what do we do now an edge can either have two values or three values if it is weighted if it is unweighted then it will have two values if it is weighted then it will have three values so we need an if condition here if self dot weighted then include weights else work without weights okay now we may want to also because we need to create an adjacency list so we will create self.data just as we have been doing so far and in self.data we will create a list of empty lists as we have done for underscore in range num edges now what we'll do along with self.data we will also create something called self.weight and self.weight will store for each corresponding value in the adjacency list it will store the weight of the edge between the two elements so for under and you will see how it works in just a moment num edges okay so we have self.data and self.wait and this will make it easier another way you can do it is instead of storing single values you can store tuples inside self.data which will correspond to the node and which will also contain the weight right so that both these are both ways to do it i'm just doing it this way but you can do it the other way as well where you can store tuples directly inside self.data suppose it is weighted then first we get the values out of the edge so node 1 node 2 and weight from the edge remember the edge is a tuple if and then first we set self.data node1 and append to it node2 and then we also set self.wait node1 so at the exact same location where we have node 2 at the exact same index we store the weight between the of the edge between node 1 and node 2 which is weight okay so now we've stored one direction which is node one to node two we may also need to store the second direction so if not directed so if if the graph is not directed only then we need to store the second direction so we just say self.data node two dot append node one and then self dot data node two dot append wait okay and that's the case when it is weighted if it is not weighted well the code is actually simpler so we simply get node 1 and node 2 from the edge and we say self.data node 1. dot append node 2 and then if not directed so there's no wait here so we simply check if the graph is not directed self.data node2 dot append node one okay so there's a bit of code here but the code is again fairly straightforward it's just a couple of things that we have to take care of whether it's weighted or not whether it's directed or not but now that we've done this we have a fairly generic representation for a graph right so now we can take this graph and remember graph one the graph one had this information so similarly we can we can create this graph we can use this graph class to represent graph one but we can also use it to represent one of these which is a directed graph a graph with weights or a graph with directed edges or a graph with both a graph with both weights and directed edges which we'll see in just a moment now one thing that we'll also do here is create a nice representation so let's just create a representation here now i'm not going to get into the code of this but roughly what we want is we want while showing the graph if there is a weight we also want to show the weight we'll show the weight alongside the other node so let's see we create a result the result will be this the empty string and then we'll return that result then we are going to say for i comma nodes comma weights in enumerate self.data and self.weight so now this is an exercise for you to figure out what exactly this is doing and you can apply the exact same technique take create a new create a new cell and put this data into a cell put the zip into a cell and then see what that represents if if you're not able to if it doesn't show something then try converting it into a list or using it in a for loop and then put enumerate around it and see what that represents so that you understand what i nodes and weights represent but i am simply going to write it here so that you see the final result okay so let's take nom nodes one once again and edges one it was called num nodes and edges so this was the initial data that we were working with let's create graph one and of course we want to do this only if it is weighted so if self dot weighted if it is not weighted then we have a different case where for i common nodes in enumerate self.data result plus equals okay let's see so graph one we are going to use the graph and we're going to pass num nodes edges and by default weighted and directed are both false so we don't need to specify them and let's see graph one this should be num nodes so you can see with live coding we always make mistakes and it's almost always bound to happen that's where jupyter notebooks are very helpful and it's always helpful to just test your function while you're writing it okay so now we've created graph one and graph one you can see is an undirected graph you can see that zero points to one and one points to zero then let's look at graph two so we're going to grab this data this contains let's call this num nodes two and edges two this is a graph with weights so now let's create a graph too graph and here we pass in num nodes to edges too and weighted equals true and let's say graph two okay there's a small change here yeah so now you can see for graph 2 this was the graph we were looking at here this graph let's grab this image as well yeah this is the graph that we were looking at and you can see that zero is connected to one and three and so zero is connected to one three and eight one three and eight and there are also weights associated so zero one has the weight three 0 3 has the weight 2 and 0 8 has the weight 4 and so on there seems to be something off here because 0 1 only seems to be connected to 0. i think we may have made a mistake somewhere in the code okay so we may just have to debug this code it seems like we may have made a made a small mistake somewhere because zero one uh one seems to be connected only to zero but one should also be connected to seven i don't see why that did not show up here this is the curse of life coding and that's why i have created a working i have some working code here i'm simply going to grab the working code right now and we'll just replace that but see if you can detect the bug in the code okay we don't the version i have does not require you to specify weighted so we can simply skip weighted here it detects automatically if the graph is weighted still something wrong here let's just quickly verify what's going wrong so we are going through the list of edges here and we are appending maybe let's just print graph two dot graph2.data maybe the issue is in the representation and not in the code graph two dot edges ah there seems to be some issue in the weight here so we may not have inserted the weights correctly ic so this should be called weight this should be called weight and so should this be called wait oh there was a syntax error here okay i think we fixed it finally let's see this should be called weight so we have an edge here we have too many values to unpack ah we simply pass weighted equals true finally and we need to make this a list it's finally done some good hardcore live debugging but we have this finally and again you get to see that when you're coding you will you will make issues you just need to but if you have a clear idea of how you've written the code it's easier to narrow down the issues by looking at the errors but let's see this graph here so we have zero connected to one three and eight and that's you can see that here one three and eight are zero connected to one three eight with the weights three two and four then we have three connected to zero two and four so we have three connected to zero two and four and we have six connected to five and eight you can see six connected to five with the value eight so great we have now represented our graph properly and this is why a representation is really useful because now we can check if our implementation is correct before we go on and implement any graph algorithms we can check if our representation is correct let's try one more let us also try this directed graph so we're going to grab this code and put it here let's call this num nodes three edges three and directed three let me grab this graph code here as well we are working with this graph and let's create graph three so for graph three we have graph and we pass in num nodes three we pass in edges three and you can verify that the edges are set up correctly and we just specify directed equals true so we don't really need this at this point we can just say directed true and weighted by default is automatically false so we have graph 3 here you can see that 0 is connected to 1 and 1 is connected to 2 but not to 0 so now we haven't inserted the opposite edge and then 2 is connected to 3 and 4 then 3 is connected to 0 and 4 is connected to 2. great so we've implemented we've now set up another graph and now here similarly you can check that if you have a weighted directed graph the code is still going to work fine that's an exercise for you and at this point let us just save our notebook using joven.com so the next question that we are going to look at is called the shortest path question and this is really what we started out with let's say you have a bunch of nodes and this is we have taken a directed graph here but you need not have a directed graph you can do this with an undirected graph too and that will be an exercise for you but you do need weights here now whenever you're talking about shortest paths in terms of weights that is when this algorithm makes sense now if you do not have weights in the graph then the shortest path can be found simply by performing breadth first search okay so whenever you're asked to find the shortest path the first question you should be answer asking is is there a weight involved or are there no weights now if there are way no weights involved then we're simply concerned with the length of the path the number of nodes in each path and in that case you can simply perform a breadth first a breadth first search but if you have weights whether it's directed or undirected then breadth first search alone may not be enough right because it may turn out that certain parts for instance you go from zero to three so you you go if you go via zero two four and three the length of the path is two plus three five plus four nine but if you sorry the yeah the total size the total size of the length of the path is two plus three five plus four nine but the number of nodes is four zero two three four on the other hand if you go via 0 1 3 in this case the number of nodes is smaller so there's just one in between so 0 1 3 there's just three nodes total but the length of the path is 14 which is far higher right so this could represent that you go to a far off place of via a train and then take a train to something that was actually closer even though there were more stops in a different route okay this is what we're going to implement now we're going to implement an algorithm to identify the shortest path from a given node to a given target okay so now this time we're going to focus our search between a node and a target so what is the shortest path in terms of the total weight of the path not in terms of the number of nodes in the path keep in mind what is the shortest path in terms of the total weight that we can find from a starting node to an end node and roughly the strategy goes like this and the strategy is called the distraus algorithm roughly the strategy goes like this you have the source node and the source node is at a distance 0 from itself so there's nothing there really but the first thing that we know the first and the only thing that we know is that for one of the siblings for one of the neighbors of the source node the direct edge will be the shortest path so for example we have one and we have two now you have directed you have direct edges from you have direct edges from zero to two and you have a direct edge from zero to 1. 0 to 2 has the weight 2 and 0 to 1 has the weight 4. now in this case suppose we had an edge from 2 to 1 and that edge had the weight one then you could go from zero to two with a weight two and then go from zero two to one by a weight one and the total weight you would incur to get to one would simply be three and that would be smaller than the shorter smaller than the direct edge right so even if we are looking at direct connections of the root we can't say that the direct edge is the shortest path except for one of the nodes right so if we just look at the node where the edge weight is the smallest so you start at the root and you look at the edge with the smallest weight then we can say for sure that the shortest path from the root to the next node to the node to is the direct edge why because this direct edge is smaller than or smaller than equal to any other direct edge so any other path that comes to two indirectly will contain an another direct edge and then some other edges right so it will have a length greater than or equal to this direct edge right so that's the key inside here that at every point you maintain a group of visited nodes so in this case initially just two zero is visited and then you find the first node which is at the closest distance from any node within the visited group okay so for example if we start out at zero and then we look at 1 and we look at 2 we see the smallest edges 2 so we add 2 into our visited group because we we know that this is the shortest path from 0 to 2 and at this point now we take all of the siblings or all of the neighbors of two and update their weights now because we know that zero to two is a direct shortest path so we can update the distance for four that four could be at a potential distance of two plus three five or there could be a shorter path so we've not yet added it we'll just update four and similarly if there was a edge to one we can update the distance of one and we can say that the distance of one is either 4 which was a direct edge or it can be 2 plus 1 if there was a direct edge from 1 so now we will get to know that 1 is at a distance of 3 which is smaller right in this case it's not but suppose there was a direct edge from 2 to 1 of weight 1 we would get to know that 1 is at a distance 3 so each time you add a new node as you mark a node as visited you you update the weights of or update the distances of all its neighbors and then you simply find the next node with the smallest distance right so you will find that the next node with the smallest distance in this case is four and then you update the numbers of four there's only one neighbor the next node with the smallest distance is three you update the weights of three and so on so that was shortest path in a directed graph but here let's see a shortest path in an undirected graph where we have more such cases let's just watch this from the beginning let's wait for the animation to start again so we start at zero then we check two okay we mark two as updated then we check nine then we mark three as updated then we update the distance of 14 but now we can see here that we have another path to go to 2 or we go to 3 that's why we track that and finally we get 2 we mark 2 as visited now we are considering 3 and using 3 we are updating the weights of all the other graph all the other nodes and then we are marking 3 as visited then we are using 3 to mark 6 as visited and so on right so at each point you have a group of visited nodes and you have distances for all the nodes that are connected with the visited nodes and then you pick the first unvisited node with the smallest distance okay now let's read the algorithm you first mark all nodes as unvisited and then you create a set of all the unvisited nodes and you call it the universal set so a set of all the unvisited nodes is called the universe call it the unvisited set assign to every node a tentative distance value now set it to zero for the initial node because the initial node is at a distance 0 and set it to infinity for all the other nodes so we now set the distance to infinity because we've not yet visited the nodes we don't know their distance then you set the initial node as the current node so there is a always a current node that we're looking at in this case we'll start with the initial node now for the current node consider all of its unvisited neighbors and then calculate their tentative distances through the current node right so you have the current node and the current node is connected to a lot of unvisited nodes and if we look at each unvisited node we know the distance up to the current node because the current node is visited and using that we can calculate distances for the unvisited nodes now if the unvisited nodes have distances set to infinity then we know that the distance from the current node distance y for going wire the current node is going to small is going to be smaller than the distance infinity that has been set but on the other hand if the if a distance has already been set for an unvisited node through some other node then we can simply compare whether it is better to go through the current node or whether it is better to retain the retain the distance that was obtained by some other node and just maintain that right so in this way we simply update the distances of all the unvisited nodes that are neighbors of the current node okay so for example if the current node is a and it is marked with a distance of six and then there is an edge connecting it with a neighbor b and then that edge has the weight or the length two then the distance to go to b through a from the source will be six plus two eight right so from the source to a is six a to b is two so the distance if you want to go to b through a will be six plus two eight on the other hand if b was already previously marked with a distance right so it was not visited but it was just marked with a distance greater than eight then we know that we have found a shorter path via a so we update its distance to 8. on the other hand if we have a value let's say the value of for visiting b by an another node d was seven so we keep the distance as seven right so we're simply updating the distance we are not yet marking these new we are not yet marking b as visited now when we are done updating all the distances for the current node then we mark the current node as visited and of course we remove it from the unvisited set right so we mark the current node as visited then a visited node will never be checked again because once you have visited a node you have found the shortest paths to it and you have used it to update the distances of all its neighbors you never need to visit it again so then find the first unvisited node find the first unvisited node that is marked with the smallest distance right so now we have a bunch of visited nodes and then we have a bunch of unvisited nodes many of those unvisited nodes have been marked with a distance so you simply get the first unvisited node with the smallest distance and make it the current node and then repeat the process okay so you start out with zero you see that you can mark two as you can mark the distances of four one and two so one gets the distance four and two gets the distance two now then you mark zero as visited now you see that the node with the least the unvisited node with the least distance is two so you get two and then you mark the mark the edges from two so you mark the distance for 4 as 2 plus 3 5 and suppose 2 had an edge to 1 then you would mark the distance for 1 as 2 plus 1 if 1 was the weight of the edge let's say you would mark the distance for 1 as the minimum of 4 and 2 plus 1 so which will be 3 so you can mark the distance for a 1s3 and that's it and then you remove 2 from the unvisited set next you find the next unvisited node the which has the lowest distance so if this edge existed that would be one but if since this says if this h does not exist that would be four so you get four and then you mark the distances for the neighbors of four and so on okay so what we'll do is we will create this we create this graph here which contains okay there should be a graph here that we can look at yeah so we'll create this graph here which contains uh 0 to 6 which contains 6 nodes 0 to 5. this is the graph we are creating let's just put it here this graph yeah so this is a graph that we'll work with and let's start writing our shortest path algorithm so def shortest path and we have a graph and that's it we have a we have a start node so let's call it source and then we have a target node that node that we want to get to so we want to go from zero to five and as soon as we have the as soon as we mark the target node as visited our algorithm is done right so first we mark everything as unvisited by setting visited false times lan graph.data so here we have marked visited then we have distance so we take we take the distance as infinity so here's a way to create infinity in python you just say float in and once again we set all distances to infinity then we are going to maintain a queue so because we have this first in first out kind of structure so we're going to maintain a queue the first thing we'll do is we will mark the distance for the source node as zero then we can insert the source node into q so q dot insert or q dot append source and then we'll set an index to keep track of what is the next element that we need to dequeue so the first element is what we need to dequeue so while index is less than zero and not visited target so while index is less than the length of the queue and the target is not visited so what do we need to do we need to get the current element from the queue so we simply get q of idx and then we increment increment idx by 1 so we increment idx by 1 here then we need to take all the neighbors of queue all the neighbor we also need to finally mark it as visited so let's just put in visited current equals true here but in between what we need to do is we need to update the distances of all the neighbors and then we also need to find the next node with the find the first unvisited node with the smallest distance okay so to update the distance of all the neighbors we have written a function called update distance so we'll call this function update distance or update distances where we will pass in the graph and we will pass in the current node and we will pass in the distance matrix or the distance array and we pass it in this way and what update distances does let's look let's look at it here and again it's always a good idea to extract out specific pieces of logic into separate functions so here you we're calling update distances where we have a current node and then we have the graph and then we have the distance so we get the neighbors of the current node using graph dot data draft or data current will give us the neighbors of the current nodes then we get the weights of of the neighbors of the edges connecting the current node to its neighbors so we get the weights as well now we go through each list of neighbors so for i common node in enumerate neighbors and then we check we get the weight so we now we have the node and we have the weight so we have for each edge the node that it is connected to and the weight of the edge and then we check the distance for the node if the distance for the node let's say hasn't already been said then it is infinity so in that case distance to the current node from the source plus the weight of the edge from the current node to the next node will be less than the distance so if the distance flow of current plus weight is less than the distance we simply update the distance of the node on the other hand if the distance of the node has already been set via some other node and that is less than the distance via the current node then we do not update the distance okay so that's all we are doing here and we can ignore this for now we'll come back to it but this is performing exactly that update distances function that we talked about then next we want to find the next unvisited node so here we have a function called pick next node which has a list of distances and it has visited so we want to track the minimum distance so we first set a variable called minimum distance to the value infinity and then we set a variable min node so this is the node with the minimum distance to the value none then we iterate over the all the lists all the nodes in the that we have in the graph so from 0 to n minus 1 and we check that if the node is not visited and the distance of the node is less than the minimum distance we've obtained so far then we set that node to the minimum node and we set the minimum distance to that value okay so we track the minimum distance the running minimum distance by going over all the nodes in the graph and we keep track of which node has the minimum which unvisited node has the minimum distance so finally what pick next node gives us is the first next unvisited node okay so here we can get next node is pick next node and we give it the distance and we give it visited okay so now if there was a next node it's possible that there is no next node because we've probably already visited everything that we can visit so if there is a next node then we enqueue it so we say q dot append next node and that's it that's pretty much it so that is our shortest path algorithm we create a visited list we create a distance list we create a queue where we will add things so this this will be all the all the nodes that we have visited will go through it or go through this one by one and the q in order will give us a list of all the nodes in their order of distance from the source node now what we need to return here is we simply need to return distance of the target and since that was what was asked here let's also mark current as visited through here soon enough so that we don't end up visiting current again and again all right so let's run the shortest path algorithm then here we have a graph this is the same graph that we see here now we can create a graph graph 7 and this is weighted and directed so we will pass in graph we will pass num nodes seven we will pass edges seven and then we will pass weighted equals true and directed equals true and this is graph seven okay this seems like it was it worked out right zero is connected to one and two with the weights four and two respectively and 5 is connected to nothing 4 is connected 3 is connected to 5 4 is connected to 3 okay this looks fine so now we can say shortest path in the graph from let's say from 0 to 5 in graph 7 and it says that the length of the shortest path is 20. so you have 2 3 four eleven so two plus three five five plus four nine nine plus eleven twenty so that seems to be right what would also be nice to get is just to see what that path is and for this we can introduce something called a parent so here we can simply have another thing called a parent which is set to none for each element so visited let's call this parent and let's set it to none by default and all we need to do is whenever we are enqueuing a node we need to track why it got enqueued right so if an if a node is getting enqueued then it is probably getting enqueued so sorry not whenever we are enqueuing whenever we are updating the distance of a node we need to track why why its distance got updated so inside update distances whenever we update the distance of a node we also set the node the parent of the node to that current node from which the distance got updated right and that's all we need to do when we update the distance of a node we need to track why did we update this distance by which node we did we come to update this distance so this way we have now tracked the parent and let's return not just the distance of the target but let's also return the queue and let's return let's just return the parent for now i think this should be fine okay so now you have the parent for each one so if you look at the fifth element 0 1 2 3 4 5 you can see that the parent of 5 is 3 so it seemed like we arrived at 5 from 3 and then if you look at the parent of 3 so zero one two three the parent of three was four it seemed like we arrived at three from four then you look at the parent of two it seems like we arrived at from at four from two then you look at the parent of two and it looks like we arrived there from 0 and 0 was our source so the path is if simply going reverse 0 2 4 3 5 okay and that's how you get the shortest path and not just the shortest path distance now notice that 0 itself does not have a parent because that was the source now you can repeat this with another graph let's say we take this other graph that we had this was graph two so let's grab this image here so let's get graph two and let's say shortest path graph two and let's get the shortest path maybe from zero to seven so it seems like there are two parts one goes by one and one goes by a six two three three two and seven so let's get the shortest path from zero to seven okay so we started out with zero and we end up at 7 so 0 1 2 3 4 5 6 7. it seems like the parent for 7 was 1 and then the parent for 1 was 0. so it's clear that it picked the path 0 1 7 and the total length of the path was seven sounds good we can try another one we can try two and eight so there are a couple of ways to go from two to eight one is to go wire three so you can go to six to other three ways actually but six two uh six z uh you can go at three zero and eight or you can go at three four and eight let's see which one it picks okay so now zero one two three four five six seven eight so the parent for eight is five oh sorry zero one two three four five six seven eight so the parent for eight is four so we came to eight wire four and then the parent for four zero one two three four apparent four four is three so we came to four wire three and then the parent for three zero one two three the parent for three is two so we came to three y six wire two so two three four is the path and the length should be eight plus one nine plus six fifteen great it seems like we've figured out the shortest path once again and this time this was an undirected graph okay so as long as you have weights you can apply this algorithm and this algorithm is called the dystra's algorithm and that's it so that's all we're going to cover today now one thing that we have not looked at very closely is the running time complexities so let's do a quick look at that let's do a quick look at let's say bfs and see if we can identify and get or guess the running time complexity and the full proof is left to you as an exercise but roughly it looks like this this is the main this is the main loop here so where we are going through the queue so the number of times this may happen is n which is the number of n which is the number of nodes and the number of times this might happen now inside each for each node inside bfs remember that we check a full list of nodes inside each node for bfs so the number of times this may happen is equal to the number of for each node we may perform an additional number of steps equal to the number of nodes it is connected to right so if we have n nodes so we have n while loops and then if we have a total of m edges and let's say those m edges are split across if i count the number of edges for each node the number of edges is e1 e2 e3 e4 and so on and then we so the num the num the size of this loop for the node n1 is e1 the size of this loop for the node n2 is e2 the size of this loop for node n3 is e3 so if you add up the list of all the edges e1 plus e2 plus e3 plus e4 so the total number of iterations inside this for loop turns out to be you can see here the total number of iterations inside the for loop will turn out to be the total the sum of all the adjacency lists okay and this total sum of all the adjacency list is equal to twice the number of edges you can see here the number of edges is one two three four five six seven and you can verify that the number of elements of all the adjacency lists put together is 14 because each edge is represented twice right so we end up if we have n so if you have n f n vertices and m edges we end up with n plus two m operations right so each of the n operations to start the while loop and then each of the two m operations those are to iterate over each adjacency list right and now when we are talking about complexities we can ignore the m if m is the number of edges we can ignore the factor 2 associated with it so what we end up with with is order of n plus m so order of n plus m is the complexity of breadth first search and now by this by this point you should be able to just work it out by looking at the code so do try it out and if you if it's not clear do ask on the forum but order of n plus m is the complexity of brett first search and you will find a similar complexity for depth first search as well order of n plus m for the shortest path algorithm however the complexity will be different because in the shortest path algorithm let's see it here in the shortest path algorithm what we do is we go over all the vertices so that's we insert each vertex or each node into the queue once and then we take it out once so this contributes a factor n then when we are saying update distances then it also contributes the factor m but when we are picking the next node we may we visit all the vertices once again right so here we are performing n operations inside when we are picking the next node so that gives us order of n square plus nm n square plus m yeah something like that so order of n square plus m or n plus m into n so that's you those are some complexities that you will see reported for shortest path and a way to improve this a way to improve the picking of the next node is to use what is called a min heap so that you don't have to look through the entire list of nodes each time to pick the next node but you can simply pick the next node in a very short time so there's a data structure called a min heap that you can look at the min heap allows is used to keep track of a bunch of numbers and easily track the minimum so you can keep a bunch of numbers around in a binary tree like this and the root will always be the minimum and the numbers on the left and right will always be larger than the root and then the same will be true for each subtree as well an insertion into this heap is of order login and deletion into this heap is of order login as well and then the min max in this case fetching the min or the maximum value is of order one so instead of mainta instead of looping through the entire list of nodes each time what you can do is you can simply insert nodes into this min heap and delete nodes from the min heap when they become visited and getting the next node is as simple as fetching the minimum value okay so check this out this is not something that will generally get asked this is a more advanced concept in fact even the distraught shortest path algorithm it's very unlikely that you will get asked but do review it and do try as an exercise if you want to go further try implementing and improving the distress algorithm using a binary heap so that will take the complexity for from m plus n times n to m plus n times log n okay and that may be better so do check that out that's obviously going to be better for larger graphs so do try to implement it in fact inside python there is a builtin heap called the heap queue data structure and that will that will optimize the pick next node operation in the distress algorithm so that concludes our discussion of graphs here there's a lot more in graphs graph theory is an entire course in itself but since this course is particularly concentrated on data structures and algorithms from the perspective of coding interviews and coding assessments this is as far as we need to go so what you should do is you should practice more graph problems related to breadth first search and depth first search that is really something that you need to become very familiar with breadth first and depth first search and shortest path may be in sometimes some some really hard interviews you may get asked the shortest path as well so do familiarize yourself with that but apart from that you don't really need a lot more but there are other algorithms you can look at minimum spanning trees you can look at topological sorting you can look at connected components that's another path you can look at detection of cycles and there's something called disjoint sets so there's a huge huge number of topics that we can cover in graphs but we'll stop our discussion here so what do you do next review the lecture video and execute the jupiter notebook complete the assignment and attempt the optional questions and finally participate in forum discussions very important if you're stuck at any point just go on the forum ask a question you can also share your code as long as it's not working to get help and you can also join or start a study group to learn together with friends and you can also find us on twitter at chopin ml and akash in s and the next lesson is data structures and algorithms in in data structures and algorithms is python interview tips tricks and practical advice thank you hello and welcome to data structures and algorithms in python this is an online certification course being conducted by jovian today we're on lesson six python interview tips tricks and practical advice this is the final lesson of this course so i hope you're excited my name is akash and i'm your instructor you can find me on at akashenist if you've been following along with this course and you have been working on the assignments and if you complete a course project as well then you can earn a certificate of accomplishment for the course which you can find on your jovian profile and also add to linkedin or download as pdf so let's get started first thing we'll do is go to the course website pythondsa.com so this is the course website pythondsa.com this is where you'll find all the information about the course you can watch all the previous lessons lessons one through five and you can also check out the previous assignments assignment one two three and you have the course project as well let's open up lesson six now on lesson six you will be able to find a video recording of the video you're watching right now and here is the code that we will look at today so today we will do something different we will simulate the experience of being in an interview so while we have given you a problem solving template and we recommend that you follow this template for any project or any notebook that you work on any coding problem that you work on and here on the problem solving template we also have a method something that we have been applying throughout this course to different kinds of problems different kinds of data structures and algorithms but in an interview obviously you will not have this template so we'll see how to apply this method during an interview and before we do that let's revise the method so that we can recall it from memory when we are working on the interview problem so here is the systematic strategy that we have been applying so far for solving problems and do check out the previous lessons if you haven't seen them for examples of how to apply it in detail so the step one is to state the problem clearly in your own words and identify the input in output format and then the second step is to come up with some example inputs and outputs and try to cover all the edge cases that you can think of you want to think of all the possible scenarios and that will help you write your code properly then step three is to come up with a correct solution for the problem and state that solution in plain english and then step 4 is to implement the solution and test it using some example input this is important while you're practicing but initially when you come up with a correct solution it will be a simple solution what is often called a brute force solution and in an interview setting you may not have the time to implement it from scratch so you may skip if the brute force solution is too straightforward then step five is to analyze the algorithm's complexity and identify any inefficiencies in the algorithm so what you can do in an interview is come up with the correct solution and describe it to the interviewer and then analyze its complexity directly and start identifying inefficiencies and then move on to apply the right technique to overcome the inefficiency so this is where you need to identify what which one of the techniques that you've learnt in this course do you need to apply is this a binary search problem is this a divide and conquer problem is this related to binary search trees is this something that you can solve in a similar way you'd solve sorting is it important to look at the worst case or average case complexity is this a graph problem or is this a recursion or is this a dynamic programming or a memoization problem so all of these things are something that you have to think about and as you practice more and for more problems so for each of the lessons if you try and practice about five to ten problems then you will start to recognize these patterns and when you're on step six when you're trying to come up with the right technique to overcome the inefficiency the ideas will automatically come to you so practice is very important to succeed in step six and once we have determined how to overcome the inefficiency through the right data structural algorithm then we state that solution implement it analyze the complexity right so this is how your a coding assessment or an interview should proceed for you and let's see let's pick up a coding problem and let's go from there so here we have a coding problem python sub array with the given sum and we read the problem but before that you can see that here this notebook is fairly empty and we what we're trying to do is we're trying to simulate the situation where you are on a call with somebody and they are interviewing you and typically they would be using some platform like a collab edit or maybe a platform where you can also run the code or a platform where the question is somewhere let's say on the right it's already printed it's from a preselected database on on the right on the left and on the right you can type your code and you can experiment with it now we're not using any third platform here what we'll do is we'll simply simulate that in our jupyter notebook okay so now we have this notebook running we've clicked the run button on the jobin notebook and here we are now the question is and this is a question that was asked during a coding interview for amazon of course a lot of other companies may ask similar questions too you are given an array of numbers and these numbers are all nonnegative you need to find a continuous sub array of the list which adds up to a given sum this is how interviewer might state the problem to you and then they may also tell you an example sometimes they don't and if they don't it's always a good idea to ask for example now you might sometimes feel that maybe if you ask too many questions the interviewer might think that that you don't know this or you're dumb in some way but that's not true it's actually the opposite the more questions you ask the better the interview the better the interviewer is able to convey what they want right now they're busy they're doing five interviews a day and they have their entire day's work sometimes they may just fail to state the question in its entirety and if you don't ask for clarifications you may assume the wrong thing and go ahead and implement something that's completely wrong and that completely deals your interview and trust me it happens more often than you might think okay so we here is one example so let's say if the interviewer did not provide an example you can ask them can you please give me an example for this problem and then they come back to you and they say suppose we have this array one seven four two one three eleven and five these are these are all numbers and they're all nonnegative some of these could be 0 as well but suppose we have this array and i give you the number 10 that i want you to find the large i want you to find a continuous sub array of the list which adds up to the given sum which is 10. so then they might also tell you that in this case the solution is this sub array starting from position 4 starting from the number 4 and going all the way up to 3 and you can check that there are no other ways to create 10 like if we took 1 7 that would be 8 and 1 7 4 would be 12. on the other hand 7 4 2 would be 12 again but 4 2 1 3 turns out to be 10 and once again on the right you will not be able to create the total of 10. so this subarray is what you have to return now what does it mean to return a subarray to return a subarray means to return the indices which is the index of the starting term or and the index of the ending term and sometimes we know in python when we're working with ranges typically the end index is outside of the actual data so you could return the index of 4 in the index of 11 so that we so the index of 4 is 0 one two so two is the index of four three four five six index of eleven six so if you return two and six and then i try to access the two to six two colon six range of the list then you will get get this list four two one three in fact that's something that we can very quickly verify here let's say l1 so you have one seven four two one three now if i say that the start index is the start index i and the end index j are 2 and 6 respectively and you can see l 1 of 2 to 6 is 4 2 1 3 right so although j is outside so that doesn't get included when we put it as a range and then we put in 4 2 1 3 and you can also verify that the sum is 10. all right so that's the problem now i've explained it to you in a lot more detail than an interviewer would but this is the process that you have to apply in your own mind what and sometimes what you can also do is you can repeat the problem back to the interviewer that's a great idea you you they've stated the problem to you they've maybe given you an example now you state the problem yourself in simple words remember that was step one so in the same way that i just have you can state the problem and then you have to figure out what are the inputs and the outputs so the input you have an array or array is also a list in python so let's say arr zero let's create let's make this the first an example first input and that would be one seven four two one three and then the target so your target sum is ten that's the input here and then the output that we want to want is so this is the output 0 that would be 2 comma 6 as we've just verified so this is the input and output format always makes sense to just create some variables for that before you start coding the next step is to think of what are all the cases that a function should be able to handle but actually before we do that we should also write a function signature because we know what the input looks like we know what the output is going to look like and we know what so we know what the function should look like so we can just say def and let's call this sub array sum and it's going to take an array it's going to take a target and there's going to be some logic inside it okay all right so that was step one sorry i forgot about the function signature but it always helps to just write the function signature because if you've misunderstood the problem still the interviewer can immediately correct you and tell you hey but you haven't taken a certain input or you've assumed an input which i have not provided okay all right so now we have the function signature now step two remember step two was come up with an exhaustive list of test cases to test the problem so you can do this in comments you can just create some comments and you can say i'm thinking about the problem and i'm just trying to think what are all the cases we need to handle and this is a great quality this is not something people do often but they should because this indicates that you are doing what is called test driven development which means you are thinking about all the ways in which your code code might be used and accounting for those before writing the code so kind of working backwards and it's a very useful way to avoid errors so now the first one could be a generic array where the sub array is in the center somewhere in the center right so which is what we have already seen here now the sub eric would be in the center or the sub array would be at the start or the sub array could be at the end or it's possible that the sub array there is no such sub array so there's no sub array which adds up to 10. you may also have the situation where you have a few zeros so you have a few zeros in the list that's one option here's one thing that can happen this could be that there are multiple sub arrays with the same sum now this is where you might want to just clarify with the interviewer hey what happens if we get two sub arrays which add up to the same number the target and the interviewer might say find the shortest one or find the first one or find any one but it's always good to clarify that one option could be that or you could also ask them what is what happens if there is no sub array that adds up to 10 and then they may tell you you can return none none or you can return 1 or whatever it is or assume that there is always a subarray so that will help you write your code and then you can obviously you may have to work with the empty array you may also have to work with the subarray is a single element and whenever we say arrayed we also mean list in python they're practically speaking the same thing for our purposes okay we've listed quite a few test cases and in that process we've come across a few more questions which we've clarified so now we're ready to start solving the problem now at this point what you may want to do is maybe just ask for a couple of minutes and keep a pen and paper close to you i'm going to use this tool instead so i'm going to use this tool instead so keep a pen and paper close to you so that you can work on this problem now let's come up with the simplest possible solution right so we have about two three minutes to come up with the solution and often the simplest solution is pretty obvious so in this case one simple solution could be if i could simply try every sub array then i will find at least one if that adds up to 10 if there is one so all i need to do now each subarray is defined by a start index that is where the first element of the array is and then and n index the end index is just next the next index the first index which is not in the array right so that's how we define the sub array remember so all we need to do is try all such values so all such values i i comma j where i goes from 0 to n minus 1 and where j goes from remember you could start out with the empty sub array so which means j also has the value i so here we are saying i and j both have the value 2 so l1 of 2 to 2 becomes the empty array so j grows from i to all the way beyond the last element which means if the last elements index is n minus 1 so j can go all the way up to n all right so i goes from 0 to n minus 1 and j goes from i to n and each time we start at an i and we check e j so we check j equals 0 and j equals 1 equals 2 j equals 3 4 5 and so on then we move i again and then we start over again and then we say we start with j equal to 0 j equal to 1 j equal to 2 3 4 okay and and we keep doing this to we find an array and we have exhaust this way we'll test all the subarrays so the problem is solved so that's the brute force solution and what you should do first of all is explain that brute force solution it may seem that this is an obvious solution what's the point of explaining it but to mention it because at this point the interviewer knows nothing about you so they don't know if you can even come up with a solution to the problem right they're trying to assess can you think about problems and they're trying to assess can you write code now if you don't tell them the brute force solution then they don't even know if you figured out the brute force solution so do tell them the brute force solution and generally you do not have to code it you can do the analysis in your memory in your mind and you can sort of write the code in your mind picture the code and based on that come up with the complexity analysis and directly say that the brute force algorithm will have such and such complexity okay now we will just write the code right now just to be very clear about it in case you have not you are not yet clear on how to write the code but in an interview this is the part which you can skip in the interest of time so f sub array i think it was called sub array sum sub array sum and let's call this server sm1 the first approach that we're taking here we have array1 and that's it we have array and then we have our target and we're saying remember that start i from i goes from 0 to n minus 1 that was the first thing so for i in range 0 to n minus 1 and what's n well n is simply the length of the array length of the array then j goes from i to n oops so i made a small error here this should say 0 to n because even in a range the last value is not taken so j goes from 0 to i to n so for j in the range i 2 this should be n plus 1 then because we want j to go all the way up to n and now we simply check if the sum of array i to j and then we've seen this array i to j is going to give us all the indices starting at i but ending just before j so if the sum of array i to j equals target then we found the answer return i comma j that's it so check if sub array sum equals target and if not let's just return none none maybe this is what we agreed but let's return none and that's it so that's your that's your code it's about one two three four five lines of code maybe six but that's a brute force solution if it's really short it doesn't hurt to write it because it then it's going to sit there and at least as a reference you have it but it's something you can discuss with the interviewer should i i mean if you if you are clear about the brute force solution and you can tell its complexity then you don't have to write one other tip is whenever you're coding it's always helpful to simply add a small comment above so that even if the interviewer is not able to follow your code they can just follow your comments and they can tell if your general strategy is correct right once again reading code is hard and especially when you are not familiar with the coding best practices in the industry the code that you write is sometimes difficult to read so while you learn how to write good code in the meantime it always helps to just mention comments makes it makes their job easier makes them easier it makes it easier for them to evaluate you otherwise you may spend five to ten minutes talking about something in your code which either they misunderstood or you made a typo etc okay so we have here the sub array sum one we've implemented the brute force solution maybe let's also check out some cases in and see if this root 4 solution works correctly so in an interview if you have the ability to run the code you can just run a few samples so let's say i simply take array 0 and target 0 and you get the value 2 6 and remember output 0 also has the value 2 6. so great it seems like our our technique work let's test a few more cases just to be sure subarray at the end subway at the start let's see if we can fix that so here is array 0. now if i take this remember 4 to 1 3 oops i think i didn't complete it let me also put in 11 comma 5 here yeah so remember 4 to 1 3 is the solution now if we simply take 4 to 1 3 11 5 and call sub array sum and put in this number here and put in once again the target zero was 10 oh this should be subway some one okay yeah so now you can see four two one three is zero one two three which is the range zero to four so it seems to have worked correctly let's do the same thing now list this time let's put this at the end so one seven four two one three eleven five this works fine two two six let's try another one let's try maybe 17 and that probably cannot be found oh it can one two let's see one zero one two three four five probably the sum of all of these four let's do six plus four ten okay now maybe there's a problem here because it seems like 17 is not the right sum so you have 1 plus 7 8 and 8 plus 4 12 12 plus two fourteen fourteen plus four eighteen okay so this seems like a mistake then and we can even check this out so we have l1 that's that let's call that l2 and 2 oh it says one to six i think i misread it so we are ignoring the 0th element so this does add up to 17 okay so 17 does show up let's try 18 which takes up the entire array works fine let's try maybe 4 which should just take the single number so that works fine too let's try 19 that should be none none okay we've tested this extensively and overall our solution seems correct this is the process whenever you write any code you should also test it out and it also gives more confidence to the interviewer but if you do not have the option to test it out if you do if you are not able to run the code right now then simply walk them through an example yourself like look at this example and then walk them through the exam okay so now we have the brute force solution the next step is to analyze the brute force solution now let's analyze it so you have here one for loop and we know that counting for loops helps us count the number of operations then we have another for loop so one for loop can go from zero to n so this may run n times then we have another for loop which goes from i to n plus one let's approximate here and say that it can run at most n minus 1 times or n times so n and inside each of these up at most n and then inside the second for loop you have the sum so this is very important now always carefully observe the operation inside your for loop so you have a sum which can be on an array of i to j now remember i can be 0 and j can have the value n that means in the the largest area that you can work with will have approximately the size n as well right so you have n and inside each of those you do n other loops and inside each loop you do work you do n additions right up at most n addition so that roughly gives you that this is going to be n times n times n so this is going to be an order n cube solution so if you are able to arrive at the order n cube solution at the order n cube complexity without implementing the solution great you have learned it but if you're not able to arrive um at the order n cube solu at the order and cube complexity for the brute force solution then you probably need a little more practice because this should become second nature to you just looking at a problem identifying the simplest solution and then finding the complexity of the simplest solution all right so now we have implemented it tested it and we've identified the complexity remember the next step find the inefficiency and overcome that inefficiency by applying the right technique so let's find the inefficiency then here we have let's say we are at this position so let's say you are looking at seven four two let's say i has the value 1 so you start out with i equal to 1 and j equal to 1 in the inner loop then what we do is we increment j by 1 and then we calculate the sum and this sum is 7. then what we do is we increment j by one more and we calculate this loop and this sum and this sum is seven plus four eleven then we increment this window once again and then we calculate this sum and that is seven plus four plus two so seven plus four eleven plus two 13 and then we move this and then we check it again so we are doing this over and over and over many many times right each time we are doing 7 plus 4 plus 2 plus 1 and 7 plus 4 4 plus 2 plus 1 plus 3 that seems like a lot of additional work maybe we can just avoid that what we can do is we can when we start out with a j we can keep a running sum and each time simply before incrementing j add this upcoming element which is the jth element into that running sum right and that way we don't have to do that entire sum inside each of the inner loops so that's one optimization and this is how you should explain it that's one optimization that i have come up with the second optimization that we can come up with is that the moment the sum the running sum that we're calculating the moment the sum becomes greater than the target value we can skip all of these right so we know that 7 plus 4 is greater than 10 and we know that the array only contains non negative number so what that means is 7 plus 4 plus any of these numbers is always going to be greater than 10 right you can obviously you can see this the number is not going to decrease if we keep adding positive numbers and so as soon as the running sum crosses this value we can break out of the inner loop we do not need to continue and look for higher values of g two optimizations helps to just write them down maintain a running sum so that you don't forget it and find it and second optimization is when some exceeds target break inner loop okay so now we have applied an optimization simply by just looking at the data in a lot of cases it's very straightforward you don't even have to apply any special technique and in this case we found these couple of optimizations so let's apply them so what we'll do is we'll define def subarray sum2 and here once again we have the array and we have target and this time we get the length of the array now once again i goes from the same value so i goes from 0 to n minus 1. nothing changes here so for i in range 0 to n minus 1. now here is where we want to start a running sum so s equals 0 this is our running sum then for j in range remember we start out with i and we'll go all the way oh this i keep making these mistakes all the time and by the way these are called off by one errors here what we did was i wanted to go to at the address n minus 1 but because ranges do not include the final value i put in what i put in n minus 1 was wrong i should be putting in n and i make these mistakes all the time even after many years of coding so always watch out for off by one errors anyway so j can j can take the range of zero of i to n so here we should put in n plus one and now first we want to check if the running sum is equal to the target right so so assume that we've been calculating the running sum step by step and we'll write and and at this current point the sum has become equal to target now if the sum has become equal to target then we simply return i comma j because this sum includes the sum from index i all the way up to just before j so initially the j also has the value i so the sum is 0 which makes sense but if that is not the case we check if it is greater than the target so is it possible that our sum has already exceeded the target in that case we don't need to continue this inner loop we can break out of this inner loop and the way to do that is by simply typing break and then if neither of these held true if neither of these was true so which is that the sum was not equal to the target it was not greater that means it is still less than the target so that means we need to then add array of j into the sum so we can say sum plus equal to oops sum plus equals area of j which is the same as sum equal to sum plus array of j in any case array of sum plus equal to array of j so we have added the jth element now remember if this is the pointer j we added the jth element and then we we will set j to j plus one that will happen automatically when we come into the next iteration and the next iteration will once again check if the sum is equal to the target if it is equal we return i comma j otherwise we check if it is greater than the target if it is so we break if it is still less we increment we move j once again so we add one and then we move j once again and then we check again right so that's our running sum looks good now once again if we were if it was found it would have been returned somewhere here since it seems like it was probably not found so if we come to the very end so here we return none none okay and once again let's test it out so let's try subway sum two it gives you two six subway sum two of none okay seems like there is an issue here yes so this is why you need test cases so it seems that array j took up an invalid value so why is that well that was because j can go to the point of n so the maximum value j can take is n so which means that you have already arrived at this position so now you can no longer increase the sum further right so if you've arrived at this position but you've still not reached the total of 10 then that means you may need to increase it further but you can't increase further so there's no number here to add so what we should do is we should here add a check if j less than n since j can go all the way up to n and that's it so we had a small bug and we fixed it now again this is something that you should work out for yourself on pen and paper so even while doing the optimization you can ask for a couple of minutes play around with it on pen and paper write a few examples relax you can even take up to four five minutes and if you if you're not getting any ideas you can simply talk to the interviewer you can speak out loud explain your thought process and in a lot of cases they will give you a hint because they want to see you succeeding okay so now this is the second implementation let's see okay this time it worked none none four two one three let's put in 10 here this should give you the value two comma six let's put in this so that's zero comma three let's test this out two so that's zero comma four yeah 0 comma 4. so it seems like it's working just fine yeah so seems like this is working pretty well so now we have the second optimized solution so let's look at the optimized solution and analyze it so we have one loop and then we have a second loop these two are the same but inside the second loop we are simply doing a constant operation we are just doing some comparisons and one addition not up to n additions so the complexity goes from order of n cube to order of n square by maintaining a running sum great now this at this point when you've described the solution to the interviewer and maybe also coded it you might ask them is this good enough and they can see that you've ex you've thought about it you've found the solution and you have tested it and it tests well and at this point they may just say i'm happy with the solution this is good enough or they may say can you do better now when they say can you do better most of the time it suggests that there is a better solution so let's see let's think about it a little more and let's see if there is a better solution now you can to can you do better we apply the exact same technique we have analyzed the complexity and now we need to look for inefficiency okay now we have removed the inefficiency on this side which is as we move j that is when we reuse the previous sum to compute the next sum so we've removed the inefficiency on this side and we've also added this also added this condition so that j only goes up to a certain point now of course in the worst case j may always go up all the way to the end but at least in a lot of cases j will not j will not not go beyond a point where the sum becomes larger than the target so these are good optimizations but what about i what about the left window now look at this here when you have seven four or let's start out all the way at one so we have one that's so first we started with the empty empty sub array that has the sum zero then we increment j so now the sum becomes one then we increment j now the sum becomes eight then we increment j once again and now the sum becomes 12. okay the sum has become 12 now that's a problem so what do we do what we are saying is we will take i and set it to the next value and then we will bring j back to zero or back to the value i so that we start with the empty sub array once again so now when we do seven and when we so that's that just has a value seven and when we do this we have to add up seven plus four now here's something that we could have done instead now as soon as the value became larger than the target value we could have simply moved this here does that make sense let's think about it so till this point this total was less than 10. as soon as we added this number on the right this total became more than 10. now we know that this product became more than 10 that means that if we slide this window if we slide the left window forward one step then the total may become less than 10 right it may still become stay larger in this case it stays larger or it may become less than 10. so if the total now becomes less than 10 then we can once again move this but the total has not become less than 10 so we will move this instead so now the total again is less than 10 so we can once again move this and now the total is still less than 10 so we move this now the total is still less than 10 we move this and we encounter 10 here but suppose we had not encountered 10 suppose this number was 4 instead then what we would have to do is move this right and now now the number becomes less than 10 so we always go we always try to maintain a window of size less than 10. the moment the window becomes greater than 10 we keep trying to reduce its size further to less than 10 right or exactly 10 as well it's possible that the size may become exactly 10 and then the problem is solved but we keep trying to reduce its size to a value till it becomes less than 10. so to revise the algorithm we start out with both i and j at zero then we increment j while the running now we have a single running loop and a single loop essentially so we increment j while the sum is less than 10. the moment it becomes greater than 10 we start incrementing i the moment the sum becomes less than 10 or less than target we start incrementing j and if we encounter the point where the sum equals 10 we have found the answer so that's the algorithm so let's write it sub array sum three now this is the array target now we have we have i we have j and we have sum all of them let's call it s because sum is a reserved word in python an existing function so all of these have the value 0 then we say while i is less than len array let's call that n so let's create n equal to len a r r i is less than n and j is less than n plus 1 remember because j can take the value n as well it is the exclusive end index now at this point you want to check first so if the sum s the current sum running sum is equal to the target then we simply return i comma j l if some is le less than the target then we simply increment j okay so now we can move the window forward so we we are incrementing j if the sum is less than the target so we increment j but before we increment j we should add the jth element to maintain the running sum so here we say s plus equals j or array of j and remember j can take the value n as well so that's where we do this only if j is less than n if there is indeed an element for us to add this is an error we faced last time and you will discover this when you write the test anyway and then we say l if s is greater than target and we can also just say else here but just for clarity let's say alif in this case what we want to do is we want to move i forward so suppose we end up in a situation like this and we want to move this forward for that we need to subtract s array of i first so we s we say s minus equals which is equal to s minus which is the same as s equals s minus array of i and then we increment i so we move the left window forward as well so we then repeat this so we first move j to a point then we as soon as we cross the target we start increasing i and then we keep doing that till we match the target and then finally we return none comma none if we have not found it so that's r sub array sum three this is seems like the most optimized solution and let's test it out so here we have sub array sum three and let's test subarray sum three here as well seems like it worked let's see so if you put in ten here you get two comma six let's say this is four two one three zero comma four let's put in 12 here that doesn't show up let's put in 17 here zero comma five thirteen one comma five let's try 19 that's three comma six let's see one plus three plus 7 plus 9 yeah that has the value 19. let's throw in a zero there and see if it works with zeros that's three comma seven works fine and let's see if it doesn't work out yeah okay great so this solution is correct too again if you don't have the option to run the code you can simply pick one example and walk through the working of the example now we have sub array sum three and once again we are ready to analyze the complexity and in this case the complexity would be this somewhat tricky is a little bit unusual because there is a while loop with two variables but remember that in each while loop either we exit which is the best case so we can ignore that or we either increment j or we increment i right so we increment j or we increment i and if we increment uh so j can go from the value 0 to n and i can go from the values 0 to n minus 1. so the total number of increments can we and we can do is the sum of the number of possible values of i and the number of possible values of j right remember this is not a product this time because this you do not have a nested loop so for each value of i you're not doing this rather you are incrementing each one and i only one of them each time so the sum of total number of values i can take is n the total number of values j can take is n plus one so the total becomes this number of iterations becomes two n plus one now of course there's the you can verify that a constant amount of work is being done here so we finally end up with the conclusion that this is an order n algorithm so this is finally an order n algorithm this is a good example of a problem where the stepbystep solution coming up with a simple solution and then thinking about the inefficiency in the problem and then applying in this case just common sense to solve the inefficiency step by step leads to the perfect solution and a very good solution in fact so you start out with the order n cube solution the order n cube is going to be pretty slow when you start hitting let's say even a thousand even a thousand elements if you have ten thousand elements it will take forever it will take maybe an hour or so if you have a million elements it will take hundreds of years on the other hand order n can work fine all the way up to a billion elements right so there's a huge difference between the sub array sum one two and three so where some three can work instantly for a billion elements so where is some one will take forever even for a hundred thousand elements and subarray two is in between and you can do the math and this technique where you can almost certainly tell what the next strat what the next step is so this was not really related to any of the algorithms or data structures that we have talked about this is what is called a greedy approach where you know some optimal strategy about the problem in this case you know that we can calculate the sums by maintaining a running sum so we just do that and then you also know that as soon as it becomes greater than a target we need to break out and then you know the next thing that when it becomes greater than target rather you can simply up update i so this is what what is called a greedy approach where you somehow know that just doing this will fix it right there's no real technique to be applied and these problems are somewhat tricky but you get the hang of these problems as well if you search for greedy problems online you get the hang of these by solving a few practice exercises so that's our first interview problem and we've solved it in about 45 minutes and this is approximately how long you will have for an interview a typical 45 minute to one hour interview we'll have about a couple of minutes of introduction maybe a few minutes just you talking about a project and the interviewer asking you questions but then the next 30 to 40 minutes will be dedicated towards solving a problem and this is what roughly the process will look like let's do one more example let's pick another interview question and let's see if we can solve this one so this is slightly different so this gives us one more variation to study by the way to run these you simply click the run button and select run on binder okay so this is an interview question that was asked during a coding interview at google and the question is given two strings a and b find the minimum number of steps required to convert a into b so what you can do is you can perform operations and each operation is counted as one step and the operations you can perform on a word are these you can either insert a character into the word or you can delete a character from the word so for instance here you can see that we are trying to convert intention into execution so either you can insert a character for example you could insert c here or you can delete a character for example you can delete i here or you can replace a character that is you can take n and replace it with e you can take t and replace it with x and e does not need to be replaced and here we've inserted c and then here we substituted n for u right so we have taken the word intention and by performing a few changes character by character by either inserting deleting or replacing a character we have converted it into the string execution so the number of steps required here is one two three four five now here's a challenge for you try and work this out on paper and prove that this is the best solution so because we need to find the minimum number of steps required to convert a to b okay so that's the problem and this is a moderately hard problem and variations of this show up as well so let's start applying the method now when you hear the problem a solution may not strike you up front that's perfectly all right don't panic sometimes when you're not able to immediately come up with a solution or identify how to solve this problem you enter a sort of panic and then you are unable to think don't do that remember have faith in the method and we will apply the method and come up with a solution step by step so the first thing is to state the problem in your own words so given two strings we need to perform operations a series of operations on the first string the operations could be deletion of a character substitution of a character with another character or insertion of a character and through these operations we need to convert it into a second string okay we have understood the problem if the interviewer had not given an example either you can state the example or you can just ask for an example whatever makes works for you so we've stated the problem now what are the inputs to the problem so the inputs are two strings so the inputs are strings like intention and execution so let's see maybe let's call them str1 this is intention str2 this is execution now one thing you have to be careful about here is you do not want to capitalize because sometimes what might happen is this i may match up with an i here in the in the proper solution but python obviously treats small and capital letters differently python doesn't know what's that the i which is lowercase and the i which is uppercase is the same so you will not be able to compare them so just to keep things simple either make everything uppercase or make everything lowercase but yeah this is what the input looks like and the output is going to be a single number so the output is simply going to be the edit distance so let's just call it output one and it is going to be the number five and here is something that you can verify so that's the input that's the output and function signature so of course this term edit distance is how this problem is described but here there is no edit there's no concept of edit distance that's mentioned so you can give a function name that makes sense for this problem so find the minimum number of steps required to convert a to b okay so let's just call it min steps for now so the function definition would be min steps and this would take an str1 and this would take an str2 and it would return an output for now we'll just put in pass here all right so now we have already clarified the problem if you had any questions this is this would have been a good time to ask the interviewer and make sure that you have a clear understanding now you have stated the input output and function signature the problem has been communicated back and forth properly the first step is done the next step is to list out some test cases right once again a very good quality listing out some test cases so you can say that now i'm just going to list out a few cases that i want my function to cover so that they will help me it will help me while writing the code now one is the general case which is listed above so this would be intention execution and we can take a few more examples like this now one example could be where no change is required so you are given the same strings one case could be that all the characters need to be changed so these are the two extreme cases one is no change is required and second is all characters need to be changed maybe added remove deleted lots of such things then you can check both strings of equal length so in this case they are in fact of equal length unequal length you can check both strings of unequal length one of the strings is empty your function should be able to handle that too then you may check things like it will if something only requires deletion if something only requires addition or if something only requires swapping right such things i guess this is pretty good at this point so now we can probably move forward so we have stated some test cases now you don't need to create all the test cases right now in an interview it can take a little take a bit of time so let's just move ahead and the next step is to come up with the simplest solution to the problem which is also called the brute force solution so now we have a lot more information about the problem in this mean time probably it has sunk into you and you may have been able to think of a brute force solution but if not don't worry there is a simple trick i'll tell you which you can apply whenever you are stuck and you can't think of a brute force solution so we're looking at you're looking at it in tension execution what am i going to do am i going to start from the left and right how do i check which one is how do i know if this is going supposed to be inserted or executed or replaced or substituted or deleted so the simple trick is whenever you're in doubt think about recursion see if there is a way to solve this problem recursively and what do you mean by solving a problem recursively can you reduce the overall problem to a combination of one or more sub problems so if you take a portion of the input and can you solve the same problem on the portion of the input and then use that to solve the overall problem okay so let's see let's see if there is a recursive solution possible here so here i have the same thing intention and execution now with recursive solutions normally you either start by looking at the first character or the last character so let's look at the first character character of each string right so we given these two strings and we need to find the number of operations to change this string into this string let's look at the first character now suppose the first characters were in fact equal suppose this was not intention but it this was n tension and this was execution so now we compare the first characters and we know that the first characters are equal okay so if the first characters are equal then obviously neither of them needs to be deleted or removed or obviously this character does not need to be deleted or removed or switched it's already matching so what we can do is we can just ignore the first characters and we can simply look at the remaining string so intention and execution because the first characters are already equal let's write that down so that we don't forget it and this is the recursive solution now this is where you can take a moment to work this out on pen and paper and that's perfectly all right what helps us to just talk keep talking about what you're doing but for recursion now first thing we know is if the first character is equal then ignore from both so just ignore the character first character of both strings and simply recursively solve the problem for the sub list or the sub string without the first characters in each of the strings right so you exclude e and exclude e from this and solve the problem for these two perfect now suppose the first character isn't equal so that's another case now right so that is the case where you have intention and execution so if the sub if the first character is not equal then either the first character has to be deleted or the first character has to be swapped so you may you may have to swap i with e or the first character or maybe something needs to be added before the first character okay now let's see one by one so if the first character is not equal either it has to be deleted or swapped or a character inserted before it there are only three possibilities right of course it's possible that we may do some other things insert characters after after it and so on but at that position after applying an operation either the first character will get deleted or the first character will get swapped and will be changed to e or the first character will now change to something else and the first original first character will become the second character now let's look at each case the first cases it has if it is deleted now the power of the beauty of recursion is that we don't need to guess which solution it is we can try all three recursively and then simply pick the best one so suppose we choose to delete the first character so suppose we say that we are deleting the first character now what that means is we've performed one operation and we've deleted the first character so now what we are left with is this so now what we end up is the second the string has remained the same only the first string has changed where we have lost the first character now what we end up with is with a sub problem where we need to find the minimum number of steps to change n tension nte and tion into execution okay so in this case if it has to be deleted then recursively find then recursively solve after ignoring first character of str1 okay that's one possibility and the you get the recursive solution and you simply add one to it that tells you the solution if you delete the first character the next option is that we change the first character i to e now if we change the first character i to e so one operation has been performed and then now these two have become equal now that these two have become equal we can move this forward and we can move this forward so now we can simply recursively solve the problem for n tension and execution find the minimum edit distance between the two and simply add one to it to get the number of steps required to change intention to execution by swapping the first character right from i to e so in this case you recursively solve after ignoring the first character of each right so it is one plus in both cases it is one plus the recursive solution after ignoring the first character of each because the one operation is something that has been performed okay now the final case the final case is you have intention and execution now we decide that we are going to shift the string forward and we are going to include we are going to introduce an e here so we are going to introduce e here so now what happens is the e is matching the e now i has gone on to the first position i has gone on to the next position here so effectively what has happened is that we need to recursively solve the problem for the original string in tension and the second string with the first character removed because we have inserted something before the first character in the first string so that is going to match with the first character of the second string and hence we simply need to recursively solve the problem for these two in this case what we are doing is the solution is one plus recursively solve after ignoring the first character of str2 okay sounds good looks like we've done that now what's the end solution going to look like the end case remember in recursion this is all well and good but at some point we are going to hit some kind of an end so let's see let's see if we can define such an end scenario so maybe let's say we have been performing recursion and then we ended up at a situation like this where there is nothing left in the second string but you still have some characters left in the first string right so you are at this position now and here this is gone there's nothing left in the second string so in this case to change recursive to change tion into the empty string all we need to do is delete all four so if you have a few character if you if the second string becomes empty then you simply find the number of remaining characters in the first string and delete them so that is the number of operations or the other possibility is that the second string still has some characters but you've run out of characters on the first string if you run out of characters on the first string but the second string still has some characters then in that case what you need to do obviously is you have the empty string and you need to take this convert this empty string into t i o n that is a recursive problem we are solving so you that you can do by adding t i o n great so you add t i o n and that is again going to be four steps which is the number of characters remaining in the second string okay so these are the two end cases now of course if both of them are empty then the answer is zero but if either of them is empty the answer is the number of remaining elements in the other one let's write the solution now we figured out the solution it took some time but again this is not a very straightforward problem so there are a few cases to figure out and while you are doing this while you are identifying each case either you can say it out loud to the instructor or you can write it as a comment whatever you feel more convenient with because the interviewer cannot see the work that you're doing on paper so it's very important for you to be able to convey it and that is why all this while in this course we have been saying that you need to express the solution in simple words because you need to tell the other person that you know the solution and they should be able to understand what you're saying without looking at your work without looking at the images that you've drawn and a great way to do it is either by writing or by speaking let's define it then def what's it called min steps and min steps is it takes str1 and str2 great now we are doing recursion and in recursion what we're tracking is the which character we are currently at so we could be at the zeroth character or the first character or the second character in string one and we could be at the zeroth character second first character second character in string two right so the the starting point of this window determines the sub string that we are solving the problem for so ideally we when we want to solve this problem for these two sub strings we can simply pass those sub strings but creating sub sub list or sub strings as a cost because you have to copy those characters out and then allocate some memory and put them into a new place so an easier way is to simply keep a pointer so we will keep two pointers i1 and i2 and these will signify that we should be skipping while computing min steps we should be skipping the first i1 characters or we should be starting from the i want index and we should be starting from the i tooth index for str2 okay so in your window if the i1 index if the starting if the starting index is equal to the length of string one so this is the end case and remember the end case while coding is always written first so if this is equal to length of str1 then we have known we have seen here that we need to perform these many additions so we simply return in this case str len of str2 minus i2 right and you can verify that this is the amount number of additions required alif on the other hand i2 is equal to len of str 2 so which means that you have exhausted the second string but the first string still has some values left so in this case you need to remove the delete the return remaining values in the first string so you just type len of str1 minus i1 right so these we have now solved the trivial cases now let's see lf str1 of i1 and str2 of i2 which means the first characters of each sub string that we are working with right remember we are just using arrays as a we're just using indices as a optimization what we really want to work with the substring so the first character of each substring str1 of i1 and str2 of i2 is equal now the first character is equal e and i are equal then we simply ignore both and solve the problem for the remaining string so we simply say return main steps and we pass an str1 we pass in str2 and then we simply pass in i1 plus 1 here and we pass in i 2 plus 1 here so what this is saying is that now we want to recursively solve the problem or a substring starting at i plus i 1 plus 1 so we have ignored the first string of the current substring and similarly we have ignored the first character of the current substring or of the second string okay so we ignore the first characters and that's it and there are no steps required here no operations required here right now because the first characters are equal now finally this is the final case else here we want to return one so we have to perform one operation either it is an insertion deletion or swap and what we can do is we can recursively check the cost or the number of minimum steps required for each case of insertion deletion and swapping and simply pick the minimum one and if to do it we add one then we get the total minimum number of steps we need to perform for the entire list right so again recursion is very useful because you can simply assume that you have the function which solves the problem and you simply need to take the result of the sub problem and combine them so we take the minimum off the first option is if the first character of str1 has to be deleted so which is let's say we choose to delete i if we choose to delete i then that means we have to solve the problem for these two so we say 1 plus recursively solve the problem after ignoring the first character of str1 so we solve min steps for str1 str2 now since we have deleted the first character of str1 we can skip ahead into the next because we are solving the problem now for the from starting from the next index and i2 remains the same right so remember here we have not affected i2 so we need to solve this problem recursively so this was the case of deletion next we have the option where you have swapped the first character so we have taken e and we have converted the it in we have taken i converted it into an e if we did that so then we can say that okay now these two characters are matching so now we can simply recursively solve the problem or the next character onwards after ignoring the current character so this becomes str1 plus str2 plus i1 plus plus 1 plus i2 plus 1 great so this is swap or replace and you might notice that this is this turns out to be the same recursive call as this except that we will add one to it because we have done the swap and finally if you are adding so if you're ad inserting so finally if you're inserting here something so if you are inserting e here let's say so in this case what we'll do is now we'll recursively solve the problem for intention and execution without the e in front so we skip the first character of the second string so we have main steps str1 str2 i1 and i2 plus 1. so this is rather nice and symmetric and that's it so this should be it let's run this okay there is a syntax error here that's perfectly fine there needs to be a comma here that's fine too i make a lot of syntax errors all the time and of course off by one errors i'm sure there are a few but yeah this is the minimum number of steps and this is a recursive function not too bad two four six around eight lines of code and let's test out some of the test cases here i'm just going to copy the test cases out here below and let's try as a general case which is intention and exception so let's see main steps intention and exception it says 5 4 okay why does it say 4 maybe let's test let's test a more simpler case first which is one of the strings being empty let's say we have intention and one of the strings is empty so we will need to delete uh let's just say int and one of the strings is empty this looks fine we will need to delete all three of these and that in some way tests out this case where or sorry tests out the second case where the second string is empty now we can test this case in this case also the in this case also the solution is three great looks fine let's test this case where str1 i1 and str2 i2 are equal so if you have integer and let's say you have india so i n i n would be the same so these would get skipped and here is where the recursion would kick in so t would have to be changed to d and then you would have to add i and e okay that looks fine too and let's check in tension and exception once again i don't know what's wrong here let's see so is it possible to do it with four i don't know it's maybe possible to do it with just four changes if you change i you delete i and then you delete n and then you delete t delete i substitute these two i don't think it is possible with just four changes so there's probably an issue i don't know what's wrong here it's possible i may have made a mistake here let me try another saturday and sunday okay so saturday satur needs to be changed to sunday s u n now s is the same so a t u r needs to be changed to u n so u remains the same now if we can what we can do is we can probably delete a delete t and take replace r with n so this seems to be fine all right so we'll probably unless i'm not seeing this so you have in tension and you have exception unless i'm not seeing something it seems like we may have made a mistake one one thing we could do is we can simply print out the strings that we are checking so let's see str1 is i1 onwards and str 2 is i2 onwards we are first checking intention and exception then we check let's also print the result here okay so at this point i would probably look through the loop here and see if the see if it is correct coming properly so you have intention and exception first we delete i then we delete n then we delete n then we delete t then we delete okay then we compare e and e so then we come back to n and exception and so on i think we'll have this might take some time to fix we'll come back to intention and exception but supposing we've solved the yeah supposing we've written the recursive solution correctly and i do have the recursive solution here so let me just grab that and put that in here let's see what's different okay probably the answer is 4 because i'm still getting 4 but supposing we have the recursive solution here so we have min edit distance this is the recursive solution and now what you need to do is you need to find out the complexity of the recursive solution now to find the complexity of the recursive solution what we can do is simply look at the recursive calls in the worst case so how you start out is you start out with a string of length n1 let's say and a string of length n2 we have one string of length n1 and one string of length n2 then you call either you call this min edit distance with i1 plus 1 and i 2 plus 1 so str1 and str2 you call them with i 1 plus 1 and i 2 plus 1 so that's one possibility or you call three recursive calls now one recursive call is the good case where these two match up so we want to look at the worst case where these two things don't match up so in that case you make three recursive calls right so you make three recursive calls and in each recursive call you are then going to reduce the problem size by one so you're either going to decrease i2 or you're either going to decrease the size of the first string or you're going to decrease the size of the second string or you're going to decrease the sizes of both strings right so just to keep things simple let's assume that in all three we are decreasing the size of either one of the strings by one so we are decreasing the total problem size which is n1 plus n2 by one right so the number of levels of recursion is going to be the total number of total length of each of the two strings so let's maybe just draw that graph here as well so let's take this so here you have n1 comma n two so let's assume these are the lengths of the two strings now n1 plus n2 what happens to it is that this n1 plus n2 calls three recursive functions so there are three recursive functions so let's just draw those three recursive functions so we have those three recursive functions here let's take this two and then those in those three recursive functions what we have is either you reduce either you reduce the size of the first string or you reduce the size of the second string or you reduce the size of both strings so either you end up with n1 minus 1 and n2 and let's reduce the size of that or we end up with n1 and n2 minus 1 or we end up with n1 minus 1 and n2 minus 1 okay so these are the three recursive calls that we're doing and then each of these will once again make three more recursive calls and so on now what is the depth overall depth of this recursive call now because we can see that each time the size of the problem reduces by 1 so if the size of problem is n1 by plus n2 in this case it reduces by 1 in this case it reduces by 1 and in this case it reduces by 2 but for simplification let's say it reduces by 1 here so the total size of the problem the total number of levels in this tree is going to be n1 plus n2 so you have three problems in the first layer the second layer will have three square problems the third layer will have three cube problems three times three times three and similarly you can go ahead and you will find that at the last layer you will have three to the power n plus n two minus one layers right and if you then add together all the layers what you end up with is that total total number of sub problems is 3 to the power n 1 plus n 2 right so you have a total of 3 to the power n 1 plus n 2 sub problems that you end up creating and because of that you have the complexity 3 to the power of n1 plus n2 in this case so that's that's the complexity so here we have a recursive solution and then we have the complexity of the recursive solution which is exponential 3 3 to the power of n1 plus n2 now at this point it will make sense to add memoization so whenever you see recursive solutions and you see repeated problems for example here itself you can see a repeated problem and then you can see that this problem will get repeated inside this problem and inside this problem too so there are a lot of repetitions and all we need to do is remove some of those repetitions and to remove those repetitions we can use memoization so what happens in the memoize solution it is exactly the same as the recursive solution but before doing any computation we check a memo we check a dictionary if we already have the solution for the changing variables which is i1 and i2 and if we have those if we have those solutions what we need to do is just return them directly if we do not have those solutions we need to compute the solutions put them in the memo and then return the value from the memo so let's write the memoize version so we have min edit distance with str1 and str2 and this we are calling memo okay this we are calling memo so now we have a memo the memo is going to be a dictionary and the dictionary is empty and then we define a function recurs so instead in memoization normally you have to write a recursive helper function now you can either write this outside or inside i like writing this inside because well it will have access to str2 and they do not need to be passed in so here we have i1 and i2 and first thing we do is we create a key so the key is i1 comma i2 now if key in memo which means if we have already computed the solution then we simply return memo of key if not then we have all the other cases so now we have alif now we can check if i1 equals len of str1 in that case don't return set the memo of key to len of str2 minus i2 lf i2 equals len of str2 then we return memo of key is len of str1 minus i1 lf okay in this case then we check if the first elements are equal so we have the exact same logic you can see the same cases coming up here so if you have str1 of i1 equals str2 of i2 in this case we have memo of e equals we simply ignore the first character so we increment i1 and i2 so exactly what we have done here so we simply call recurse this time with i 1 plus 1 and i 2 plus 1 right so we always call the recursive function but inside the recursive function if it has already been computed it will return from the memo and finally if we have and this is the final case which is where they are not equal so here memo of key becomes 1 plus min of let's see here so we have recurse so the insertion cases we will ignore the first element sorry the deletion cases we will ignore the first element of the current range from the first string so we recall recurs with i 1 plus 1 and i 2 otherwise we call recurse with i 1 plus 1 and i 1 plus i 2 plus 1 this is the case where we swap the first element of the first string so we can just recursively check after ignoring the first element of each and then we have recurse with i1 comma i2 plus 1 i2 plus 1 and there we go and that's it so now we have stored it in the memo and then we simply return memo of e at the very end and finally we call recurse 0 0 and that is our solution and there is a syntax error you can fix these syntaxes they're easy to fix and i've just realized that the solution in this case might actually be 4 because what we can do is we can change n to p so that's one step we can replace i n t with e x c so we replace i and t with exe that's three changes we don't change e and we replace n with p the solution is four so our solution was correct there was no issue there in fact this is not the best solution this is a sub optimal solution so this output should be four and that's okay this is something that happens all the time where you miss something and you just assume that you just say that you're going to come back to it at the end and then you move forward assuming that that code was right and then you realize that either you were correct or what your mistake was it's probably going to happen in one of five interviews anyway okay so now we've written a memoi solution great and we can start checking the memoi solution now so minimum edit distance memo let's call main edit distance memo and we get back the value 4 looks fine let's try saturday and sunday as we have so that's three so what you will do is you will leave a as it is change a t u r to u n by removing a t and changing r to n that seems fine let's test out some cases like this okay this is three six eight characters so that seems right we simply delete all the characters let's check out this here also eight characters we have to add eight characters let's say we have abc and xyz so this should be three if it is x y z k then maybe that will be four what if it's x y z a in this case also it's four so this seems to be working fine we have now taken the recursive solution identified the inefficiency calculated the complexity which was exponential identified the inefficiency and the which was repeated sub problems and then fixed the inefficiency by calling min edit dist by using memoization and now how do you compute the time complexity of memoization well the argument is if you only need to compute the solution for a key once and the computation apart from the recursive calls simply involves some comparison and a fixed number of comparison and an addition so the time required to compute assuming you have the recursive solutions is constant so that means if you simply count the number of memoizations that can possibly occur that gives you an upper bound on the total num number of operations it will be some multiple of that some constant multiple so i1 can take the value 0 to n 1 where n 1 is the straight length of string 1 and i 2 can take the value 0 to n 2 where n 2 is the length of string 2. so memo the keys in memo can be i 1 comma i 2 so you have n while n 1 values for i1 and 2 values for i2 so that makes it n1 times n2 that's the number of keys and that because there's a constant amount of time additional time required to compute the solution for a key that is also the complexity so the complexity is order n1 plus n2 so we've gone from 3 to the power of n1 plus n2 which grows very quickly even for 3 to the power of 3 to the power of 10 is pretty high we can check it out here 3 to the power of 10 is something like 59 000 3 to the power of 100 so if you have n one plus and 2 then that's e to the 47 that's going to be a lot of operations on the other hand if or in with memoization it is only going to take let's say 100 is split as two strings of length 50 and 50. only going to take 2500 operation so where it was taking 10 to the 47 operations now it takes only 2 500 operations which is pretty small so you can still work with lists of size up to 10 000 or 100 000 very easily using the memoi solution so that covers this problem and keep talking through your solution even as you're stuck even as you're confused just as i was it's helpful to just keep spend maybe two or three minutes trying to solve the issue and if you're not able to solve the issue just say that this is something i'll fix later and then move on assuming that you've fixed it and then keep talking and keep continue keep working on the solution and at some point later it's possible that the solution might like you now at this point you may be asked sometimes to implement a dynamic programming or an iterative solution like the when you talk to the interviewer and you're telling them that this is how i'm thinking i'm doing i'll do a recursive solution first and i can see that maybe there are going to be some sub problems there then i'm going to then apply dynamic programming so you can just check with them and in most cases they will accept a memoization solution because the dynamic programming solutions can take a little bit of time to solve to implement and they're always off by off by one errors and it's also difficult to explain the solution so you can most most cases get away with memoization but if they do ask you to do it with iteratively with dynamic programming then you'll have to go ahead and implement the dynamic programming solution so once again take a couple of minutes now and work it out on a piece of paper and then go back to them now for dynamic programming remember you have to create a table essentially so what the table will look like in this case is let's see if we can simulate a table what the table will look like is let's create a new sheet and in this sheet let us put the two words which is intention okay and let's put the word exception as well move this down too and let's also put in the indices ultimately this is what a dynamic programming looks like programming problem looks like you are ultimately going to create a table here and how we'll start filling the table is the ijth element so let's say this element int int e e x c e so this element represents the edit distance or the number of operations required to convert i n t e into e x c e and how do you check what the solution is now you know that e and e are equal so the final elements are equal so what that means is we look at this value then this value should tell us what is the minimum edit distance between exc and exc now since we can simply add e to each string and get this solution that means this solution is equal this value should is equal to this value all right so in the case where the corresponding elements are equal we simply copy over the value diagonally left top left value onto the current cell the other option is if they are not equal so let's say if we are here where here you have n and here you have p now there are three possibilities you you want to find the minimum edit distance between i and t e n and e x c e p now n is not equal to p and this is the original string so either we delete n now if we delete n then we need to find the solution for i n t e and e x c e p so if we delete n then this value will become one plus this value that's one possibility or another possibility is that we swap n so we swap n for p so now you get this becomes p and this becomes p so this value will becomes will become 1 plus this value because now we can ignore the p and simply get this previous solution for e x c e and i and t e so this value becomes one plus this value or the final option is that you can insert something just before n so if you insert something just before n which is going to be p so if you insert p just before n so you insert p just after n naught before if you insert p just after n then you have p after it already so you can just look at this value and this value is going to be one more than this value in the case that you insert something insert p after n right so there are three ways to come to this value either by deleting n or by inserting p or by changing n to p and what you can do is you can take the minimum of three values three or these three values and add one to obtain this value so that's the logic roughly speaking and you start from the left so you see okay e and i they are unequal so you need one operation to change them and there's nothing else to consider so that's done then e and n they are unequal now you need what you can do is you can either delete n if you delete n then you simply need to check e and i and you know that the solution for e and i is one so this would be two another another option is that you could possibly insert something but if you insert something the length of i n is going to increase so that's going to cause a problem so you can't insert anything another option is you change n with e but if you change n with e then you will no longer be able to if you change n with e then you will no longer be able to use this solution right because now you will have to match i with the empty list so that's going to be one as well so overall you end up with two and this is how you start filling the list so you start filling up from left to right and left to right and keep going top to bottom and as you fill out this list finally you will fill out this final value exception and intention and that will be your solution so that's the dynamic programming solution and you can see that it's getting tricky to convey the entire solution because there are so many cases involved here so typically you will not find dynamic programming solutions to requested in interviews and it will help you to just stick to the memoization solutions all right so with that we have covered two common interview questions and you can keep going so the idea here is to just apply the method remember the remember the method the problem solving template that we've covered state the problem identify input and output formats write a function signature come up with some example inputs and outputs or at least the scenarios come up with the correct solution stated in plain english implement the solution test it using example inputs and fix bugs if you face any then analyze the algorithms complexity and identify inefficiencies and finally apply the right technique to overcome the inefficiency and you repeat the process going back and stating the solution implementing analyzing and repeating now you in some cases you do not need to implement the root force solution if you don't have the time but when you're working with recursive solutions it always helps to implement brute force first before you do memoization or dynamic programming and some tips ask questions as many questions as you can as many as you need to clarify the problem show an example follow the method don't panic if you get stuck at a certain point give it a couple of minutes sometimes you can even ask the interviewer and they may be able to tell you that maybe what your error is or maybe you're not stuck at all what you're simply assuming something incorrectly but beyond a few minutes what you want to say is that let i'll fix this later assuming this is correct let's move on and then talk about complexity and optimization and such and such very important is to state the brute force solution to the interviewer and if you are unable to figure out a more optimal solution then the best thing you can do is to offer to implement the brute force solution so that you can at least demonstrate that you are able to write code and it's all right in a lot of cases you will not be able to figure out the optimal solution and in some cases there may not be an optimal way so there are some there are certain problems where there is just one way and that is the hard way or the brute force way and this is typically very true with a family of problems called backtracking something we've not really covered in a lot of detail but it is also another form of recursion so what do you do next so the next step for you ish is to review this lecture video and solve these problems yourself or take more problems ideally what you want to do is you want to take all the five different techniques that we've covered and let's quickly review what those five techniques were the first one was binary search so we looked at linear search and binary search which is a form of divide and conquer and along with that we also understood the complexity and big o notation and then you had some homework on linked lists and python classes but binary search is something that comes up often and the hint to detect binary search is simply to look for order whenever you see something being something being mentioned mentioned as sorted now that is an indication for you that this may be binary search sometimes what you may have to do is you may have to get things into a sorted form maybe by taking replacing elements by sum of values till that element or so on and once you get things into a sorted form maybe then you can do binary search that's one way to go about it and once again just do five to ten problems on binary search and you will be able to identify pretty much any binary search question in an interview then the next topic that we looked at was binary search trees traversals and here is something that is generally asked very directly so you will be given a question like binary search tree do something with the binary search tree and you can answer that question directly we've covered a lot of different things here so do check out lesson two for all the different things you can do with binary search trees traversals balancing and most of these are recursive solutions so it's also a good exercise on recursion and we've also looked at balanced binary trees and how can we optimize them further then you had an assignment on hash tables so hashing is a again a common question that is often asked so we built hash tables from scratch in python and we also handled collisions using a technique called linear probing and so this is something you can check out in assignment two so you may get asked just to implement a hash table in python or implement collision resolution in a hash table in which case you can use linear probing then you have the sorting algorithms where we looked at bubble sort and insertion sort merge sort using divide and conquer and quick sort where we had a quadratic worst case complexity but a logarithmic average complexity and that's a good thing because merge sort although it is logarithmic in the worst case it still takes up a lot of space and space allocation is slow and you may also not have the memory that's why we sometimes use prefer quick sort over merge sort when we are constrained for space then assignment 3 is pretty interesting where you will implement an optimal algorithm for polynomial multiplication using divide and conquer so do check out assignment 3 as well then we looked at dynamic programming we looked at recursion memoization subsequence and abstract problems and then we finally also didn't cover backtracking and pruning but we there are some questions there in the lesson notebook which you can try out which use backtracking and pruning as well then we looked at graph algorithms the last time which was graphs and adjacency list and adjacency matrices we looked at the depth first and breadth first search and how to implement them and we also looked at shortest paths and directed and weighted graphs this is a very important topic breadth first in depth first search you will get many questions related to these so do solve maybe five questions on each of these topics and you should be good with most graph problems asked in interviews now this project for you the course project if you haven't seen it already is to pick a coding problem so you can pick a coding problem from an online source like lead code hacker rank geeks for geeks etc and then use the problem solving template that we've shared with you this problem solving template as a starting point so just give it a name and then write the problem statement and implement the solution step by step to use the problem solving template to solve the problem using the method you've learned in the course then document your solution add explanations wherever required perform the complexity analysis all of this you should add in the jupyter notebook and then publish your notebook to your jovian profile and finally you can submit the link to your jovian notebook here do submit the link to your jovi notebook here and you can check out the discussion where you can change where you can post what you what you're working on so do post your notebook as well and finally today we have looked at a couple of real interview questions from amazon and google and how to go about solving them and we also addressed a few issues that we faced along the way so that was a helpful exercise and that's it so now you can review the lecture video execute the jupyter notebooks complete the assignments and attempt the optional questions so that the topics that we've covered they get consolidated and you do not ever have to look at this lecture again right practice is what really reinforces and consolidates your learning complete the assignments and attend the optional questions to practice and participate in forum discussions also very useful when you participate in forum discussions why by answering questions a lot of your own doubts get cleared so do participate in forum discussions and then join or start a study group if possible getting together with a group of four or five people is great it really helps you focus and uh improve your understanding by discussion so that's data structures and algorithms in python with that thank you very much for joining us on this journey as we learn data structures and algorithms in python a very useful topic to improve your coding skills and also something that you will almost certainly encounter in one of your interviews no matter which company you're applying to so i hope this is helpful to you do let us know on the forum how this course helped you if it did you can let us know in the youtube comments as well if you have questions if something was not clear do post that too when we make sure to come up with clearer explanations and clearer examples the next time if you have any feedback for us do post it in the comments or send us an email at support jovian.ai with that i will take leave and i will see you in the forums this is not the end of our journey with you so do stay active on joven there's a lot of great activity happening do check out the forums the newsletter and stay tuned for our next course thank you and goodbye
