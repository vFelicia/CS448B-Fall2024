With timestamps:

00:00 - learn how to build a decentralized fully
00:03 - distributed content addressable file
00:05 - storage system using go that can handle
00:08 - and stream very large files starting
00:11 - from scratch you'll learn how to create
00:13 - a peer-to-peer TCP library and go this
00:16 - course covers system design low-level
00:18 - programming and network protocols all
00:21 - while building a highly practical and
00:22 - scalable application Anthony GG
00:25 - developed this course ladies and
00:27 - gentlemen this is it this is going to be
00:29 - the 10hour plus video a full project
00:32 - where we are going to build a
00:34 - decentralized and fully distributed
00:37 - content addressable file storage that
00:39 - can handle very large files right that
00:42 - can stream very large files we going to
00:44 - build this completely from scratch we're
00:46 - going to build our own uh peer-to-peer
00:48 - TCP Library uh all from a blank page in
00:52 - goang I wish you the best of Lu guys
00:55 - because if you can complete this and you
00:57 - understand what's going on which you
00:58 - probably will you are going to be a
01:01 - goang maniac trust good luck and see you
01:06 - soon first of all first of all let's
01:08 - start with the basics we're going to
01:09 - make a main goal file I'm going to
01:12 - say package
01:15 - main what's going on here like this and
01:17 - let me say funk main so we can actually
01:19 - test
01:20 - things man I need to warm up not going
01:22 - to lie uh Funk main you're going to say
01:25 - fmt print Ln you're going to say we go
01:30 - Gucci like this and then we also what is
01:34 - this
01:34 - mmt
01:36 - doing whatever it is what it is
01:39 - sometimes a compiler cannot follow we're
01:40 - going to say a new folder actually maybe
01:42 - we should make a make file first right
01:46 - uh make file we going to say go I'm
01:47 - going to say
01:50 - build uh output is going to be bin FS
01:53 - maybe forever store like this then we're
01:55 - going to say run which always will do a
01:57 - build and then we're going to say do SL
02:00 - bin
02:02 - fs and maybe of course testing and
02:05 - that's going to be go test the whole sh
02:08 - bang uh and maybe minus for boss right
02:11 - you could also do dash dash race here
02:15 - but I don't know um cool okay is this
02:19 - working make
02:22 - run uh
02:30 - what's going on here go
02:34 - build go mod oh yeah I see maybe we
02:38 - should do go mod
02:41 - init can we do this GitHub um com
02:46 - andm forever
02:51 - store uh we Gucci okay and I'm going to
02:53 - do this um going to place ATS so we
02:57 - don't have these uh outputs in our um
03:00 - terminale make run we guci all right so
03:03 - we ready to get this party started so I
03:05 - think we're going to make
03:07 - our peer-to-peer lip first or maybe we
03:10 - switch things up and then we can go over
03:12 - to our disk uh storage which is
03:15 - basically what what what I think is
03:16 - going to happen is we just um going to
03:18 - send a file we're going to Hash that
03:21 - file uh just a hash a simple hash so we
03:24 - can have a nice key we're going to use
03:26 - the hash as a key then we going to add
03:28 - some kind of an in face Funk to
03:31 - transform uh the key to transform the
03:34 - the hashed file name yeah and then uh
03:37 - we're going to make these subfolders
03:38 - just like get does we're going to make
03:39 - these sub folders uh maybe in pairs of
03:42 - two store the actual encrypted data
03:45 - somewhere there and then we can have a
03:48 - nice way to uh do versioning of this
03:50 - files maybe we I don't know versioning
03:54 - um and all that good stuff right that's
03:55 - what we're going to do so we're going to
03:58 - do a lot of uh working with readers
04:00 - writers uh read closers and all that
04:03 - that goodu we even going to make a cash
04:05 - and an index system and all that
04:07 - beautiful stuff man it's it's
04:09 - insane
04:11 - um but first but first but first things
04:14 - first of course uh let's close this file
04:17 - and maybe let's close main we are going
04:19 - to make we have this bin we're going to
04:20 - make a new folder that's going to be
04:22 - peer to-peer all right and iner to Pier
04:25 - I'm going to make a new
04:27 - file maybe I can call this transport
04:29 - port.
04:31 - goo package peerto
04:33 - peer because we're going to make things
04:35 - very uh generic right um like it was a
04:38 - real
04:39 - Library so I
04:42 - think uh maybe we should first do TCP
04:45 - and then we can actually see what kind
04:46 - of things we need to do for our
04:48 - interface not quite
04:49 - sure or maybe we can do something like
04:52 - type uh Pier which is going to be an
04:55 - interface uh like this
05:00 - of
05:01 - course and then we could have something
05:03 - like
05:05 - a type
05:09 - transport
05:12 - interface all right I could say uh
05:16 - transport is
05:18 - anything that
05:24 - um is anything
05:30 - that handles the
05:32 - communication
05:35 - communication uh between remote between
05:39 - notes between the
05:41 - notes uh in the
05:46 - network yeah and for for document uh if
05:49 - you're writing documentation on your
05:51 - functions you should always start with
05:53 - um this word should be the first word
05:56 - here right and then we could say
05:58 - something like Pier is
06:01 - Pier
06:02 - represents actually Pier is anything of
06:05 - no Pier is an
06:08 - interface that
06:10 - represents the remote node right that's
06:13 - what a p is right A lot of people don't
06:15 - know but appear is basically just the
06:17 - remote node it's a
06:19 - representation of the remote node of the
06:22 - remote connection of the the dude or the
06:26 - girl that is dialing us or the dude or
06:28 - the girl we are
06:30 - connecting to so of course these
06:32 - interfaces are actually um empty for
06:37 - now uh so basically uh T is is anything
06:41 - that handles the communication between
06:42 - no and the
06:44 - network this uh can be of the
06:51 - form
06:53 - TCP
06:55 - UDP web sockets
07:00 - right going to make some documentation
07:02 - maybe we'll make it better I don't know
07:04 - um it is what it is but I'm teaching you
07:06 - best practices
07:08 - right okay so what I'm going to do is
07:10 - real quick start with the TCP because I
07:12 - think if we have the TCP right we can uh
07:14 - derive what kind of uh interfaces
07:17 - functions we need to have we need to
07:19 - implement and
07:24 - um
07:26 - yeah yeah uh it's going to be
07:31 - TCP wait it should be TCP and then
07:33 - transport right and you see where where
07:36 - it is going right you could make your
07:37 - UDP transport and whatever transport you
07:39 - want right uh in separate
07:41 - files uh as long as they implement the
07:44 - transport interface and actually maybe
07:45 - transporter interface should be
07:48 - better but I don't think it makes sense
07:51 - uh in goang they want you to make
07:55 - interfaces right
07:57 - but I mean why interface not interfacer
08:01 - then hey anyway uh we're going to say
08:06 - type can you please close this yes it's
08:09 - going to be type TCP
08:12 - transport going to be a strict uh I
08:15 - thing is that we need to be very careful
08:17 - so we can actually have something that
08:18 - we can Implement in all our other
08:19 - projects so we need to we need to
08:21 - engineer
08:22 - this like a boss right TCP transport
08:27 - um man that's a good good idea a good
08:30 - thing what what are we going
08:32 - to I think we need to have a listen add
08:37 - actually no I'm going to start I thought
08:39 - was I thought making some configuration
08:41 - for this uh
08:43 - configuration uh listen
08:45 - address and that's going to be a
08:49 - string maybe you want a
08:53 - listener and that should be a net
08:55 - listener which is an
08:56 - interface like listen
09:01 - listener
09:04 - yeah and I think the transport should be
09:07 - responsible for holding its Pierce right
09:09 - so we could do actually this listener I
09:11 - don't like that
09:13 - it's I'm going to make everything
09:16 - private for now and we will see if we
09:18 - need to make something public we will
09:20 - check how uh but I think starting with
09:21 - everything private makes a lot of sense
09:24 - uh Pierce is going to be a map of uh
09:29 - Pier right it's an interface no not Pier
09:32 - it's going to be a map of string and
09:34 - maybe we should make our
09:36 - own
09:41 - type for this um we could use a net
09:45 - other like
09:49 - this actually that makes a lot of sense
09:51 - to be honest to use
09:52 - this um that makes a lot of sense and we
09:55 - will see but it's not going to be the
09:57 - address
10:00 - I'm trying to think out loud right uh I
10:02 - think you B that's good that will
10:04 - benefit you more than just copy pasting
10:07 - stuff uh let's start with a net Adder we
10:09 - will see we will see uh because a net
10:11 - Adder if you open this it's basically
10:13 - nothing more than Network and string
10:15 - right it's it's it's a super easy
10:17 - interface to use and it makes a lot of
10:19 - sense so uh GD right you need to do GD
10:24 - and you're here if you use the Vim
10:27 - plugin um P map adder and then we're
10:30 - going to say it's going to be a pier
10:31 - right and if we open up our uh normal
10:34 - transport thingy we see Pi is going to
10:35 - be an interface that represents the
10:38 - remote note right so it's going to be
10:40 - this and we need to have
10:43 - um an AMU right and a
10:48 - mutex and I think you could call it am
10:51 - but maybe a PE lock actually we're going
10:54 - to call it a it doesn't really matter
10:56 - you will see because if you have
10:58 - different m texes
11:00 - how you going to handle that right uh
11:02 - that's going to be a
11:03 - sync uh RW mutex right and you see how
11:07 - you need to group things right because
11:09 - we have this map and we have this mutex
11:11 - right and this basically means it's a
11:13 - common practice in goaling that you do
11:14 - this uh that you put your mutex above
11:17 - the thing you want to protect it so we
11:19 - can see oh this mutex will protect the
11:20 - Pierce
11:23 - right um that's good
11:31 - then you're going to say funk new TCP
11:37 - transport
11:42 - uh it's going to be l
11:45 - n like this going to be a string should
11:48 - it be a net adder or we going to create
11:50 - one H good question and that's going to
11:54 - return we we have a couple options we
11:55 - could return a TCP transport like this
11:58 - right and then say return um TCP
12:02 - transport and say that the listen
12:03 - address is basically the listen
12:05 - address we give it like this right uh
12:10 - but we can also say we can also make
12:12 - this actually a little bit more
12:16 - convenient and say hey this is going to
12:17 - be a
12:18 - transport
12:23 - right of course if you're testing this
12:26 - if you make a test right let's say you
12:28 - have a test here Funk test test things
12:32 - uh the problem is of course that if you
12:34 - want to test this thing and you say for
12:37 - example uh t transport T is going to be
12:41 - a new TCP transport like this right and
12:43 - you give this an address like I don't
12:45 - know could be anything the problem is
12:47 - you cannot say t listener right you see
12:50 - it doesn't work because yeah even though
12:54 - you need to cost this
12:55 - to uh a TCP transport like this and then
12:58 - it's going to work right except you
13:01 - see decisions you need to be make that
13:04 - need to be made and I want to show you
13:07 - this kind of stuff because um yeah it's
13:09 - a little bit Advanced and like I said
13:11 - patreons you're going to learn in-depth
13:14 - stuff right very important stuff that
13:16 - will make the difference between a
13:19 - decent engineer and
13:23 - basically you know what I mean um you
13:26 - are the double weight you are the double
13:27 - the double Champion or
13:30 - your the double Division champion right
13:33 - Conor McGregor you know what I mean the
13:35 - best of the best that's what I'm going
13:36 - to teach
13:38 - you so that's a thing um in my opinion
13:42 - I'm going to try to keep the TCP
13:43 - transport like this um because it
13:46 - doesn't matter in my opinion I just want
13:49 - to show you these things CU sometimes
13:50 - people are returning the the interface
13:54 - right cool so uh we have this then I
13:58 - think we need to have some then
14:01 - um you know what let's let's uh try to
14:04 - do this in um in a TCP
14:09 - transport TCP transport test something
14:13 - like this and let's open up let's let's
14:15 - open up uh test here and then the
14:18 - transport DCP here so we can do stuff
14:22 - right going to say package uh peerto
14:24 - peer I'm going to say funk test TCP
14:29 - transport
14:30 - just to do stuff uh
14:33 - T is GNA be testing
14:36 - T right so let's save this real quick
14:41 - yeah so we're going to say for example
14:43 - um TR is going to be a new TCP transport
14:46 - and I'm going to say the address is
14:48 - going to be for example we could say
14:51 - that the uh
14:52 - listen add is going to
14:55 - be uh 3,000 or 4,000 I'm going to say
14:58 - okay listen address and then we could do
15:01 - something like
15:03 - um wait let me first to go we're going
15:06 - to use this for our tests go get get
15:10 - up.com I think it's
15:12 - stretcher and then
15:17 - testy and can I do something like assert
15:21 - equal
15:23 - TTR listen address listen address no we
15:27 - can't
15:33 - because if you're designing libraries
15:34 - and such or you're making production
15:36 - systems that's actually what what we're
15:38 - going to do we're going to make this as
15:40 - if this was a production system for one
15:42 - of your clients that are going to pay
15:44 - you a lot of money to build this so I
15:45 - need to teach you exactly how to make
15:49 - this quality code right quality it's
15:52 - going to take a little bit longer but
15:54 - hey it is what it is um so we're going
15:57 - to say uh get up I'm going to check if
15:59 - we imported this package actually uh get
16:00 - up come stretcher not quite sure of this
16:04 - stretcher and then test
16:07 - defy and I think
16:11 - assert man what's going on yes it's
16:14 - working I used this package so so many
16:16 - times in my life that I know it on the
16:17 - top of my head uh all right and now we
16:19 - can actually run this test like this and
16:21 - then everything is passing of course
16:24 - right but just want to make a
16:26 - point so we could do something like if
16:29 - we have a transport we should say a
16:31 - start function or an accept function
16:34 - depends on how a server is willing to
16:37 - use this so let's say we have um for
16:40 - example this is our server
16:43 - right uh how would we use this we're
16:45 - going to say for example
16:47 - TR
16:50 - accept or or it's accept
16:53 - already called by saying TR start right
16:58 - some things we need to to we need to
17:00 - take in consideration so let's
17:03 - say
17:07 - um so what what does a transport always
17:10 - do a transport always listens and
17:12 - accepts right it list listen and accept
17:15 - that's why uh I think maybe a function
17:19 - transport TCP transport you could say
17:22 - listen and accept something like this
17:26 - and then we could say
17:31 - or listener error is going to be net
17:37 - listen
17:43 - TCP T listen address what the hell is
17:46 - going on here vs code a little bit too
17:50 - enthusiastic uh T listener it's not
17:52 - going to be it's going to be
17:53 - T Liston
17:56 - address so we already know that we have
17:58 - have an error read right so we're going
18:00 - to say if the
18:01 - error uh is not
18:03 - nil we need to return this so I think
18:06 - listen and accept should return an error
18:09 - at all
18:14 - cases so we can actually return this
18:16 - error and then we could say tln
18:21 - equals
18:23 - listener
18:25 - lessener equals Ln like this or you
18:29 - could do for example say
18:31 - VAR uh like this and say add error and
18:36 - then
18:38 - um yeah or actually because it's only
18:44 - one and then could say something like
18:47 - T listener man this listen address man T
18:51 - listener R and then relieve the
18:54 - column that could actually also work
19:00 - depends all right so we have this listen
19:02 - and accept which is
19:06 - uhan and then we need to start up uh an
19:09 - accept
19:10 - Loop
19:12 - but yes this is going
19:15 - to return the error so we could
19:22 - say maybe a private function TCP to make
19:26 - it cleaner TCP transport
19:29 - uh we could say something like accept
19:33 - Loop like
19:43 - this and say for
19:47 - T
19:52 - listener it's going to be
19:56 - this it's con accept right so we need to
20:00 - listen
20:04 - wait this is a connection error is going
20:08 - to be T
20:10 - accept if there is an error in the
20:12 - accept we actually don't want to do
20:13 - anything for
20:22 - now you could say
20:26 - fmt uh print f I could
20:34 - say TCP trans TC
20:39 - TCP
20:41 - transport or actually TCP
20:44 - maybe
20:45 - TCP error accept
20:49 - error like this and then uh we could do
20:53 - a percentage percentage s a new line of
20:56 - course and then say the errors
20:59 - right and now we have a
21:01 - connection uh what are we going to do
21:03 - with this connection we're going to
21:04 - handle the con I
21:07 - think and then we could say accept Loop
21:09 - go accept loop I think we should say go
21:12 - start accept
21:14 - Loop and then we could say here go t
21:18 - start accept start accept Loop and then
21:22 - we could say return no here right now we
21:25 - have a con now we could say make other
21:27 - private function
21:29 - and I'm going to make handle come here
21:32 - it's very important if you're writing
21:34 - production code or very high quality
21:36 - code that you organize all your public
21:39 - functions at the top and your private
21:41 - functions at the bottom and always
21:43 - organize them based on how somebody
21:46 - would read it or based on
21:48 - the importance of a function right so if
21:51 - a function is more important put it more
21:53 - above and if it's just a simple helper
21:55 - function uh demote it to the the bottom
21:59 - right that makes a lot of sense because
22:00 - I don't want to scroll to a couple of
22:03 - string operation functions that
22:05 - basically makes no sense uh for me to
22:08 - read
22:09 - so and I think here you could say
22:12 - something like uh ttcp transports we
22:15 - could say handle con which is going to
22:18 - be a con net
22:21 - con and handle
22:24 - con because we know that we're going to
22:26 - call handle Con in a go routine so I
22:28 - don't think calling the turning in ER
22:29 - makes a lot of sense unless you're going
22:31 - to do some maybe a Channel or something
22:34 - but
22:38 - hey
22:41 - um
22:43 - so and now you could
22:45 - say we have a connection here and then
22:48 - you could say go T handle come come and
22:53 - call it a DAT right and then it can keep
22:55 - looping and keep listening and uh nice
22:58 - and tight nice and tight
23:02 - function and then here we could do for
23:04 - now we could
23:05 - say fmt print
23:09 - f um percentage plus
23:13 - [Music]
23:14 - v maybe a new
23:17 - line the connection and we could say for
23:20 - example
23:22 - um new incoming connection right cool so
23:31 - yes yes so basically how it's going to
23:34 - work is we have our transport which is a
23:35 - new TCP transport here and then we can
23:38 - say um
23:41 - Dr we don't have anything to start this
23:43 - listen and accept
23:46 - listen
23:48 - listen
23:50 - and
23:54 - accept all right uh so we could actually
23:57 - make test
24:04 - listen accept um this we're going to
24:06 - return an error so we could say
24:09 - assert uh assert nil
24:11 - T right that should give us no error
24:14 - right um let's run this test so it's
24:18 - working fine and we could also do
24:19 - something like for example if you do
24:22 - this and we run the test then it's going
24:24 - to return an error because this is not a
24:27 - valid um thing so so hey all
24:34 - good
24:37 - okay so thing we already
24:41 - know no matter what kind of Transport we
24:44 - have I think calling listen and accept
24:46 - is always something that can work so we
24:48 - can go to transport and we could say in
24:50 - our transport interface we could say
24:52 - listen uh and
24:56 - accept and basically does not then it
24:58 - returns an error that's the only thing
25:00 - it needs to do we don't care how or what
25:02 - this function is going to do it just
25:03 - need to be listen and accept because um
25:06 - that's something we are going to call in
25:09 - our server right and depending on what
25:12 - kind of Transport we're going to have
25:13 - we're always going to call listen and
25:14 - accept if it's UDP it needs to listen
25:16 - and accept UDP if it's websits it needs
25:19 - to do that if it's a local transport I
25:20 - don't even care what kind of transport
25:22 - it is it could be even a
25:24 - grpc listen and accept could be make
25:27 - could make sense here here right all
25:30 - right uh TCP transports are we going to
25:34 - see
25:38 - test okay so what we also going to do is
25:41 - if we are handling the
25:44 - connection um we need to
25:54 - basically the question rather is so are
25:57 - we good going to decode encode are we on
26:00 - or encoder and decoder is going to be an
26:02 - interface
26:03 - also but where are we going to call this
26:06 - is that something that's on the serice
26:08 - side or on the transport side or
26:10 - something in between right that's a
26:15 - thing
26:19 - um I think we're going to make a
26:21 - p we have this TCP
26:25 - transport that's here let's make I'm
26:28 - going to for now I'm going to make it
26:30 - here TCP
26:32 - P it's going to be a strict we're going
26:35 - to have a
26:37 - connection we're going to say TCP Pier
26:41 - represents represents the
26:45 - REM the remote noes over uh TCP
26:52 - established uh can we do connection
26:59 - yeah yeah yeah yeah yeah yeah what's
27:02 - going
27:04 - on Lost in Salvation uh TCP represents
27:07 - the remote nodee over TCP esta
27:08 - connection yeah con is going to be a net
27:12 - con um I think because we learned our
27:15 - lessons in all our protocols in the
27:17 - poker engine and in the and and and in
27:19 - the blockchain shenanigans you're going
27:21 - to say if this is an outbound
27:25 - Beach uh which is a boo right what is an
27:28 - B if we if we say uh TCP transport
27:34 - dial right and we
27:36 - dial to a
27:39 - pich that's going to be an outbound
27:43 - pich if we if you make connection with
27:45 - that Pier it's going to be an an an
27:47 - outbound but if so if we accept and and
27:51 - make a peer of the
27:52 - connection that's going to be um an
27:55 - inbound Peach right it makes a lot of
27:57 - sense like this for example um Let's do
28:00 - let's let's make documentation so
28:02 - basically
28:05 - um
28:08 - dial if we
28:12 - dial and accept wait a minute if we
28:21 - dial if we dial a connection
28:35 - outbound but if we
28:38 - accept and retrieve a connection
28:43 - e is this correct
28:48 - accept if we accept and retrieve a
28:50 - connection it's going to be outbound
28:52 - false well right because that's going to
28:55 - be an inbounded P I hope that makes
28:57 - sense
28:59 - um you could say
29:02 - con is
29:05 - the underlying connection of is the
29:10 - under connection of the
29:16 - P
29:20 - yeah um all right all right all right
29:23 - next thing we're going to do is
29:25 - basically
29:36 - maybe make a Constructor Funk new TCP
29:41 - P which going to be a TCP Pi or a pier
29:46 - doesn't even matter you're going to say
29:48 - return and TCP
29:50 - Pier of course if we make a new TCP
29:53 - we're going to say a connection which is
29:54 - going to be a net com and we're also
29:56 - going to say uh if if this is an
29:59 - outbound spe and then we can say come
30:02 - and outbound like
30:05 - this of course uh I prefer to do
30:14 - this although they have the same names
30:16 - still uh as for bothos as possible is
30:18 - always a good thing because I I think if
30:20 - you if you follow the blockchain from
30:22 - scratch we already had some nasty issue
30:24 - by not um providing the names
30:28 - in a more verbose
30:32 - Way new TCP P so we're going to make
30:34 - this P right we also going to need to
30:36 - have some way to add peers the question
30:38 - is are we going to do this with a
30:39 - channel I don't think so um but we're
30:42 - going to have a channel to communicate
30:44 - right because every kind of Transport is
30:47 - going to have a channel to
30:49 - communicate and we're going to call that
30:51 - as a as um as an interface function
31:00 - um handle connection do we
31:04 - actually I think we're going to need a
31:06 - pier
31:09 - here handle Pier uh that that's the
31:12 - thing the question is where are we going
31:21 - to H
31:35 - um and on I thought maybe we should do
31:38 - something like let's create a
31:40 - p right you could say that the PE is
31:42 - going to
31:44 - be in our case a new TCP Pier I'm going
31:47 - to say the com right and then if you
31:50 - accept it's going to be an outbound Pier
31:53 - so it's going to be true
32:12 - or you could make the peer here not
32:15 - quite sure uh probably going to change
32:17 - this
32:18 - actually we're going to make a new
32:20 - pier new incoming connection and let's
32:23 - do the spear and let's see if this
32:24 - actually works the question out is we
32:26 - cannot block uh for now actually we can
32:29 - we could do
32:32 - select like this and then
32:38 - um or we should call this in
32:43 - main could say that the transport is
32:46 - going to be a peer-to-peer
32:54 - new TCP transport
33:09 - forever
33:11 - store uh SL P2P I guess for some reason
33:15 - Vis Visual Studio code don't want to
33:17 - implement these
33:18 - things uh 3,000 like this now we going
33:22 - to say TR uh is going to be let's
33:26 - say log
33:31 - fatal
33:33 - start
33:35 - and accept question what's going on
33:40 - here listen and
33:42 - accept
33:47 - yeah listen and
33:50 - accept and uh of course we're going to
33:53 - we need to block here right real quick
34:01 - let's make run this uh nil what's going
34:04 - on of course because it's not uh yeah
34:07 - yeah yeah I see I
34:09 - see
34:13 - um let's do it like the traditional way
34:16 - right Edge
34:29 - clear make it all right so we are doing
34:32 - this thing let me quickly do uh
34:35 - tet uh
34:36 - talet Local Host 3000 all right so you
34:40 - see we are connecting and we say a new
34:42 - incoming connection so we already have
34:45 - easy we already doing
34:49 - TCP dopam
34:51 - mean dopam Meine you see this gives me
34:55 - dopamine and it should give you two
34:58 - uh okay cool listen accept is working so
35:01 - we have a new pier that's
35:03 - fine
35:07 - um uh now we need to make a very
35:10 - important decision because I want to
35:12 - make a handshake Funk which is going to
35:14 - be look uh what we're going to
35:18 - do uh I
35:25 - think because handshakes do we uh some
35:28 - some libraries need a handshake like our
35:30 - poker and what what's a handshake a
35:32 - handshake basically means U you connect
35:34 - to me or I connect to you it doesn't not
35:36 - really matter we connect and first of
35:38 - all before we are going to accept you as
35:41 - a new peer we're going to shake hands
35:44 - and if this handshake is not good we're
35:46 - going to drop the connection and Say
35:48 - Goodbye
35:50 - right um so that's why I think in
35:56 - TCP we're going to have something like
35:59 - what I
36:04 - call a
36:10 - handshaker or a
36:13 - TCP actually the handshaker doesn't even
36:16 - it it can no no I have an idea it could
36:17 - be any handshaker the handshaker could
36:19 - work
36:26 - over uh
36:29 - um a handshaker is going to be a
36:34 - handshaker and we could do something
36:36 - like this new file for example we could
36:38 - say this
36:40 - hand
36:41 - shake handshake Dogo we could say
36:43 - package peer-to-peer type uh
36:48 - hand
36:49 - hand
36:51 - Shaker
36:53 - interface uh and that could be something
36:56 - like is this
36:59 - correct my spelling hand yeah you could
37:02 - say
37:04 - handshake or or
37:07 - maybe shake
37:10 - hands nah
37:13 - handshake and the question is we're
37:15 - going to return an error doesn't really
37:17 - even matter
37:32 - it's going to be hard this
37:34 - handshaker
37:37 - because we're going to think about this
37:40 - but the thing is um because I'm not
37:42 - quite
37:44 - sure you see you could do like a
37:46 - handshaker right
37:49 - here um
37:58 - let's go to handshake and let's say type
38:03 - default
38:06 - hand uh handshaker man my spelling
38:09 - default handshaker is going to be a
38:19 - strict do we need to make this a strict
38:21 - does it actually make sense because we
38:23 - could do something like uh
38:29 - ah doesn't matter we're going to make
38:30 - this we could also do something like a
38:32 - type handshake Funk which is going to be
38:36 - a funk of type
38:40 - error something like
38:42 - this and I think that makes more sense
38:45 - because are we going to add stuff to
38:47 - this handshaker are we going to have
38:49 - things inside of this structure that's a
38:51 - good
38:53 - question I don't think so I can I think
38:55 - we can do something like this
38:58 - and make it even
38:59 - better and say the handshake Funk right
39:04 - and maybe we could do something like
39:08 - any could take an
39:10 - any I don't know to compare or something
39:12 - I have no clue and then in TCP
39:16 - transport wait
39:18 - handshake and we could say yeah yeah
39:21 - yeah yeah I have a good idea uh we could
39:23 - say
39:23 - transport and this is going to be the
39:26 - handshake funk
39:27 - handshake Funk right and this is going
39:30 - to be
39:35 - um handshake
39:38 - Funk right and if we going to construct
39:41 - this we're going to say the handshake
39:45 - Funk uh the handshake Funk is going to
39:48 - be a
39:50 - funk you could actually make this funk
39:53 - somewhere else but for now we're going
39:55 - to make a not funk
40:00 - it's going to be Funk
40:03 - any
40:07 - errors and say return
40:10 - n
40:13 - right so it's basically doing nothing so
40:16 - we could
40:18 - do could also do something like this
40:20 - right like like I said I'm going to
40:21 - teach you a lot of stuff so it's it
40:23 - could be a little bit slower but I hope
40:25 - you you have something about it and let
40:26 - me know poke me uh let me know what you
40:29 - think about these things should I go
40:30 - faster or should I explain these things
40:32 - you could also something do like this
40:33 - like a
40:35 - knp uh a NP handshake
40:43 - Funk which takes in an any we don't care
40:45 - and an errors and we
40:48 - say turn n right and then we could say
40:52 - instead of doing this here we could say
40:54 - yo this is a not handshake Funk we don't
40:55 - care right and and if you really want to
40:58 - be cool you can do in the handshake you
41:00 - could say hey I'm going to provide my
41:02 - users with an up handshake Funk right so
41:06 - if they don't need a handshake they
41:07 - could say
41:09 - yo oh man I need to sneeze oh
41:14 - no and I'm not going to cut this out I'm
41:16 - not going to go in this video to cut
41:18 - these things out that's not my style man
41:20 - everybody needs to sneeze and this big
41:21 - light is shining in my eyes make it it
41:23 - even worse uh so you could say
41:28 - handshake
41:29 - Funk handshake
41:33 - Funk
41:44 - is I don't
41:50 - know I don't know how to explain this
41:57 - because we need to uh probably make this
41:59 - handshake fun a little bit
42:03 - better and we going to see how this
42:05 - going to work so let's say we have the
42:07 - connection we have a pier which is good
42:10 - and then we could
42:21 - do I have an idea this handshake Funk is
42:24 - going to be look we're going to say
42:26 - something like this if R
42:30 - equals uh T handshake Funk with the
42:36 - connection and if the error is not
42:44 - nil
42:46 - actually I'm so sorry but I'm I'm going
42:48 - to be a
42:52 - perfectionist uh shake hands shake hands
42:56 - is going going to be a handshake Funk so
42:59 - we're going to say t shake hands with a
43:02 - connection and if it's an error we're
43:05 - going to
43:13 - say
43:15 - because we're going to here do go handle
43:19 - connection so we can actually start a
43:21 - read Loop right here uh we could say
43:24 - here
43:25 - con no not con uh
43:28 - um NR or decoder man I have so so many
43:33 - good itas this is
43:35 - insane oh man what you going to do guys
43:38 - listen oh we only at 44 minutes and I
43:40 - want to show so much stuff man we're
43:41 - going to make this is going to be oh my
43:43 - goodness I'm so excited I have so much
43:45 - dopamine you see I did this maybe 1,000
43:48 - times in my life and I'm still getting
43:50 - so excited by making these these
43:52 - programs as cool to use it's crazy what
43:56 - is this what why do I have an eror
43:59 - unnown field yeah I know hey man let me
44:01 - let me be
44:03 - happy is it is it possible
44:06 - compiler uh handshake Funk we're also
44:08 - going to say
44:12 - um a a
44:19 - decoder a decoder is going to be uh
44:27 - should we call this decoder it's going
44:29 - to be a decoder or is this or is this
44:31 - too
44:32 - generic right and then we could make
44:34 - look what we going to do guys it's going
44:35 - to be insane uh new file we're going to
44:38 - say um encoding maybe we're going to
44:41 - call this
44:43 - encoding go and we going to call
44:46 - um peer
44:48 - to package peer to peer basically what I
44:52 - was saying uh this decoder thing right
44:54 - so um let's let's get back because maybe
44:57 - you guys uh had a longer break than I so
45:00 - we have the shake hands right um which
45:03 - we actually need to
45:04 - handle um what are we doing this is
45:08 - going to be our read um our message read
45:11 - Loop so we're going to read from the
45:12 - connection and actually if you want to
45:15 - read you need to do something like this
45:16 - let's say we make a buffer which is
45:18 - a a new bites buffer right and then you
45:22 - could say n r uh is going to
45:24 - [Music]
45:25 - be uh is it
45:28 - Con read the buffer right con read the
45:31 - buffer like this and then let's just
45:35 - eliminate eliminate the error for now
45:38 - man what's going on uh and then we could
45:41 - say something like um the message is
45:44 - basically debuff n
45:47 - right that's that's that's a message but
45:50 - I want to have something uh better we're
45:54 - going to make uh we the file this
45:57 - encoding
45:58 - file we're going to say type
46:01 - um we don't need an encoder but we need
46:03 - a decoder but I want
46:07 - to keep these files in the same uh keep
46:10 - these TR interfaces in the same thingy
46:11 - in the same file so we could say um
46:15 - decoder it's going to be an
46:18 - interface and that's going to be
46:23 - decode and addos
46:27 - the question is how we going to do this
46:35 - um you could say decode
46:38 - any no it's it's not it's going to be
46:41 - decode me a slice of btes
46:43 - no you're going to say decode me and IO
46:45 - readers that's what we're going to do
46:47 - decode me and IO readers and um
47:00 - an
47:09 - any uh ah I'm I'm thinking we could
47:13 - actually make this
47:17 - um we could do so many
47:22 - things is this what we need I think so
47:25 - because we could do something like this
47:26 - right instead of doing all the
47:28 - shenanigans we're going to delete this
47:30 - and we're going to say uh read
47:33 - Loop and actually could we could boot up
47:35 - a new one but it is what it is we're
47:36 - going to do it here and we're going to
47:38 - say
47:40 - actually the decoder is going to be a
47:42 - decoder that's good so we're going to
47:47 - say uh in this case we're going to say t
47:51 - decoder
47:53 - decode uh the connection into whatever
47:56 - type you want for
48:06 - example let's we are doing so many
48:08 - things at once it's crazy uh we're going
48:11 - to say type uh this going to be a
48:12 - placeholder
48:14 - temp it's going to be a temp is going to
48:16 - be a strict uh there's nothing in temp
48:18 - because we don't care and we're going to
48:20 - say here in this case we're going to say
48:24 - message uh wait what's going on
48:28 - message is going to
48:34 - be uh and
48:36 - temp and I'm going to say decote me the
48:39 - message right uh that's good and that's
48:42 - going to be an
48:44 - error if the man I'm thinking so hard
48:47 - that I cannot
48:49 - type if R is going to be
48:53 - this uh man yes no
48:57 - that is not nil because my my brain is
48:59 - already uh at the handshake because it's
49:02 - red it gives me an error uh and I'm
49:04 - going to
49:08 - say we cannot actually log here right we
49:11 - cannot
49:15 - return are we going to are we going to
49:17 - do a
49:18 - um Parma that are we going to do a perad
49:22 - that connection where if he sends us
49:24 - something we cannot decode we going to
49:26 - drop him I don't think so uh maybe we
49:28 - could do it could do cool stuff we could
49:31 - say for example um something like a l
49:35 - decode error right that's going to be
49:38 - zero and each time we have an error
49:41 - we're going to each time we have an
49:43 - error we going to say l de code error
49:45 - Plus+ and if uh the L de code error
49:49 - equals five times or something then we
49:52 - going to drop the
49:53 - connection hey spam protection something
49:57 - like this I don't know I'm not sure I
49:58 - just came up with this to be honest I
50:00 - just came up with this Shenanigans uh it
50:03 - could be a good idea actually um man I'm
50:07 - I'm so today it's my creative day not
50:09 - going to lie I'm creative today I need
50:11 - to abuse it so we're going to say fmt
50:13 - print uh F we're going to say percentage
50:18 - we're going to say actually it's TCP
50:21 - right uh we could say
50:23 - TCP TCP error once again and then we
50:26 - going to
50:27 - say
50:29 - s new
50:31 - line
50:34 - Eros
50:37 - continue like this
50:45 - right there's no PE do we actually care
50:48 - could be connection I don't care maybe
50:50 - we need to delete this this login I
50:52 - don't know so we have this
50:54 - spe we're shaking hands with
50:59 - connection maybe maybe we want a
51:07 - PE maybe maybe you want a peach
51:12 - handshake what's going on
51:15 - here handshake handshake funk
51:28 - handshake with
51:30 - a man what's going on
51:36 - here crumbles on my keyboard I hate it
51:38 - so hard I'm going to
51:41 - lie TSH hands why why is this uh giving
51:45 - us
51:50 - issues we don't have this function
51:58 - did we what's going on here did we not
52:00 - rename
52:02 - this what's going
52:06 - on oh man I forgot something let me
52:09 - quickly do get
52:13 - inet yeah sorry guys I missed actually
52:16 - um committing the first episode but I'm
52:18 - going to do it right now uh get commit
52:21 - uh
52:24 - if1 peer to peer uh peer to peer to peer
52:28 - lip something like that right and then
52:30 - it's going to be a couple more things in
52:32 - it but hey it's it's it's in the patreon
52:36 - community right it's in the patreon
52:38 - community you guys
52:39 - understand um so we have the shake hands
52:43 - that's good that's good everybody's
52:45 - happy Okay cool so we're going to shake
52:47 - hands if there is an error in Shake
52:48 - Hands we actually need to drop this
52:50 - connection so we're going to see
53:01 - actually we should start a b loop with
53:03 - the we
53:06 - should do we actually want already
53:09 - appear I'm not
53:14 - sure yeah maybe we going to set
53:16 - something in the peer we never
53:23 - know like
53:25 - get joining joining the the YouTube
53:28 - Studio which is basically my living
53:31 - room um wait we need to do some many
53:34 - design decision decisions uh new peer
53:38 - Shake hand let's shake hands with the
53:39 - peer we don't care right we will see if
53:41 - this n we going to say
53:43 - con
53:46 - close and actually
53:49 - return return this this this thing
54:06 - uh man why
54:08 - why so many lag in in in in this this vs
54:11 - code uh ver uh
54:15 - ER
54:17 - invalid handshake equals
54:22 - errors
54:24 - new invalid hand shake and always make
54:28 - your errors low caps why is it not
54:31 - working it is working
54:33 - um could say addage hand is
54:39 - returned if the
54:42 - handshake
54:45 - between the local and remote
54:49 - noes could not be
54:55 - established EST
54:57 - that bled man all right so we're going
55:01 - to say return
55:04 - at invalid handshake like this we
55:10 - couldn't of course we can't we are
55:13 - literally
55:23 - damn here
55:42 - ah it was such a nice thing the problem
55:45 - is of course we have this start accept
55:46 - Loop and then we have this
55:52 - uh no man we cannot have this
55:56 - because it's
55:58 - all just return and we're going to we're
56:00 - going to just log this
56:03 - out like
56:09 - this actually let's tight it up I'm
56:11 - going to say TCP
56:13 - erors TCP handshake
56:17 - erors like
56:21 - this very important that we first shake
56:24 - hands before we are going to decode here
56:27 - right because in this handshake it could
56:29 - be that we in the handshake function are
56:30 - actually reading from a connection so we
56:32 - need to be very careful with
56:35 - this um all right
56:53 - so yeah
57:01 - um let us actually open up main so we
57:03 - don't do we have a decoder we don't have
57:05 - a decoder right that's a problem uh so
57:07 - we're going to say TCP
57:17 - transport we need to have options right
57:19 - because otherwise we need to have we
57:22 - need to have some options to be honest
57:25 - um type DCP
57:29 - transport Ops going to be a
57:33 - strict and we actually going to say the
57:35 - listen man we need to do a lot of stuff
57:37 - not going to lie this going to take a
57:39 - lot of time we're going to say that the
57:41 - listen adders going to be a
57:46 - string we're going to have
57:50 - um handshake
57:53 - Funk hand
57:56 - Shake fun is going to be uh a hand shake
57:59 - Funk we need the
58:02 - decoder which is going to
58:05 - be
58:24 - decoder I'll make options like this this
58:26 - maybe I don't know or
58:28 - Ops or
58:37 - com I don't know how do I need to call
58:40 - this TCP transport Ops that's that's
58:43 - what it going to be um and then we're
58:46 - going to say instead of the chaning
58:47 - we're going to say give us give us the
58:49 - Ops which is going to be the
58:51 - TCP
58:53 - transport Ops and we're going to say
58:56 - shake hands we don't need all of this
58:58 - again Shenanigans we're going to say
59:00 - that the Ops I mean the TCB transport
59:02 - Ops is going to be the Ops like this and
59:05 - then instead
59:10 - of we can make this
59:13 - public listen add yeah that's
59:18 - fine it's all fine of course T shake
59:22 - hands that's going to be
59:24 - t uh handshake Funk right and then of
59:27 - course uh it's going to be T decoder
59:29 - right T decoder uh decode yeah yeah yeah
59:32 - yeah yeah like this so if not if you go
59:35 - to main um we're going to say that the
59:38 - Ops TCP Ops right is going to be peer
59:42 - top uh
59:44 - TCP
59:46 - transport
59:48 - Ops like this we going to say that the
59:50 - lesson
59:51 - Adder is going to be 3,000
59:57 - uh decoder that's a good
60:01 - question I don't
60:04 - know and the
60:09 - handshake going to be a default not
60:11 - handshake
60:15 - Funk not handshake Funk because we're
60:18 - going to we're going to do no handshake
60:19 - because it's always going to
60:21 - be okay
60:23 - so yeah you could also Al say that the
60:26 - handshake Frank is going to return a
60:27 - Boolean if it's going to handshake yes
60:29 - or no but if it's return an arrow you
60:30 - can have a better logging uh
60:35 - thingy the problem is we don't have this
60:37 - uh TCP
60:39 - Ops we don't have this um decoder
60:45 - right so if you go to
60:48 - decoder encoding I mean could say type
60:52 - go
60:56 - go why am I laughing a lot of people
60:58 - maybe don't uh is going to going to
61:00 - going to understand this but we are
61:01 - using GOP so many times and I don't like
61:03 - GOP I actually like it but it's
61:05 - not yeah it is what it is man uh
61:09 - GOP
61:11 - decoder strict is that a strict yeah why
61:14 - not actually we don't need this right so
61:17 - we could say funk
61:19 - um deck which is going to be a Gob
61:23 - decoder help
61:30 - do we need a pointer probably not right
61:33 - I mean well we could do that because
61:35 - then we could check if it's n and anyway
61:37 - we're going to try
61:38 - without uh it's going to be a hub
61:40 - decoder we're going to say
61:43 - decode we going to decode um the
61:47 - io AR is going to be an IO
61:50 - reader and we going to have V is going
61:53 - to be an any I'm going to return an
61:55 - error right so how we're going to do
61:56 - this actually very easy we're going to
61:57 - say return can we return yeah we can we
62:01 - can say uh Hop new decoder we're going
62:05 - to say the reader and we're going to
62:09 - decode
62:15 - V hey hey I cannot do it it's that easy
62:20 - I mean it's plug and play right now we
62:24 - going to go to main and then we're going
62:26 - to say
62:28 - yo the decoder in our case you can make
62:31 - any decoder you want you could decode it
62:33 - in in and I don't
62:36 - know you're the b Ras if you want to
62:39 - extend this with your own decoder man go
62:41 - ahead and send me the code so I don't
62:44 - need to do it decoder is going to be
62:58 - aop a peer toe goop decoder easy that's
63:01 - what we're going to
63:03 - do
63:06 - yes all right so now we can actually do
63:10 - some cool stuff right we can we can uh
63:12 - we can
63:13 - test all right so we have this handshake
63:15 - yes yes yes decoder uh what's going to
63:17 - happen we have this me this is not true
63:19 - first of all we need to make something
63:20 - that we can actually use in some kind of
63:23 - uh
63:27 - Channel a
63:35 - message if you want to send something
63:37 - over the
63:47 - wire I'm thinking actually how we going
63:49 - to do this
63:59 - maybe we could do nah that doesn't make
64:01 - any sense we could make a new file I
64:03 - know it's a lot of files
64:05 - but uh message go we could say uh
64:08 - package peer top we can actually
64:10 - Defector this and and and do whatever we
64:12 - want right uh I'm going to say type
64:16 - message RPC is it not
64:22 - RPC is it RPC
64:28 - actually I'm going to make this even
64:30 - even just more genetic or just message
64:32 - right it's going to be a
64:34 - strict and uh a message is going to
64:38 - be or we make it like this btp
64:42 - message actually why because it's
64:44 - already in full P
64:48 - message
64:51 - um it's going to hold a payload which is
64:53 - going to be a slice of bites
65:11 - actually it could be any
65:28 - is that uh payload do we need to know
65:30 - from W
65:31 - comes we actually always no
65:36 - right or not I
65:42 - mean uh message
65:46 - represents
65:49 - uh any
65:52 - arbitrary message any arbitrary data
65:58 - message holds any arbitrary data that is
66:02 - being sent
66:05 - over uh over the over each
66:14 - transport uh
66:17 - between
66:21 - two notes
66:26 - the
66:30 - network and then we could say something
66:32 - like this message is going to be a
66:34 - message we're going to decode this stuff
66:38 - and after this we're going to say fmt
66:41 - print
66:43 - F uh percentage V new line the message
66:49 - and we could say um message we're going
66:52 - to change this right but just for
66:54 - testing to see if this
67:08 - works actually actually actually
67:10 - actually
67:31 - H it doesn't does it make sense to
67:38 - make what do we
67:42 - actually let's do make
67:45 - run all right that that's running that's
67:47 - running so we're going to use uh or
67:50 - Shenanigans uh Local Host 3000 all right
67:55 - so we have new incoming connection hello
68:14 - there are we hand yeah we hand
68:27 - can I actually de code this in a
68:30 - message because we're not sending a
68:33 - message
68:40 - right because the message is always
68:42 - going to be unless we have something
68:50 - uh it cannot it Gob cannot encode this
68:54 - uh that's the thing
68:59 - why am why are we decoding by the
69:06 - way yeah decode decode right decode
69:08 - encoding
69:11 - decoding
69:13 - uh the problem is look if if you do this
69:16 - real quick uh damn this was such a good
69:19 - idea not going to lie we could do like a
69:20 - buff it's going to be a new
69:23 - bites buffer then we could
69:26 - say
69:28 - n is going to be con
69:31 - read uh the buff right uh if add of
69:35 - course is not
69:38 - n we going
69:44 - to the OT and then we going to
69:48 - say uh like here we going to say buff M
69:53 - can we do this
70:07 - okay so this this is basically something
70:08 - else right so we say uh tell net Local
70:12 - Host uh
70:17 - 3,000 now see that that's working right
70:19 - so we have this um these messages and
70:22 - the reason why a normal message not work
70:23 - is because it's go and coding
70:30 - but
70:32 - hey of course it's not going to work
70:35 - because tet does not send any go
70:36 - encoding so how do we fix this how do we
70:39 - fix this
70:43 - well well then we write our own encoder
70:47 - that works for uh for normal connections
70:49 - isn't it I'm going to comment this
70:52 - out make this message
70:56 - yes that's what we're going to do we are
70:57 - actually insane trust me we're going to
70:59 - go to
71:01 - encoding and we're going to say
71:08 - funk not P coding just plain bites yeah
71:12 - that's that's a good idea you're going
71:14 - to make a type uh KN KN
71:18 - decoder which basically not going to
71:19 - decode anything
71:22 - right and I think always uh providing
71:24 - something for Library like KN this KN
71:26 - that KN KN everything it's interesting
71:28 - because users can just use this directly
71:31 - for their test and and and all that
71:33 - stuff uh so we're going to say funk
71:35 - actually I'm going to copy this whole sh
71:36 - bang real quick so I don't need to type
71:38 - that much I'm going to say this is going
71:40 - to be a KN decoder decode is all the
71:43 - same thing and we're going to say
71:45 - basically we're going to say uh actually
71:48 - I'm going to make a new buff going to
71:50 - make a new bites
71:52 - um buffer like this and I'm going to say
71:55 - buff read can I do
71:58 - this is that a
72:01 - thing I probably it's probably no it's
72:05 - different right it's or read buff is
72:09 - that a
72:12 - thing ah we can't it needs to read bites
72:15 - um doesn't
72:16 - matter you're going to say that the
72:18 - buffer is going to be
72:26 - uh 28 or something I'm going to read the
72:28 - B going to be
72:30 - n like this if
72:36 - add turn add and otherwise you're going
72:38 - to
72:47 - say of course this any is of course well
72:50 - is is is a problem
72:52 - right iaka um
73:15 - I'm thinking actually because
73:29 - do we want to do the encoding in
73:35 - in because we are in our in we are in
73:38 - our transport right we are here in our
73:40 - transport so making this is already
73:42 - hardcoded
73:59 - isn't
74:12 - it because this could work like this but
74:15 - I think we we
74:20 - we I mean
74:43 - how you decode everything into a message
74:45 - right into into into a message instead
74:47 - of this any
74:49 - type uh we could say it's going to be a
74:52 - message and we're going to use this as a
74:54 - communication
74:55 - at all times but what's the payload
74:57 - going to be that's that's generic that's
74:59 - depending on the platform that's what
75:00 - you're going to that's that's what
75:02 - you're going to
75:03 - decode with with with whatever we don't
75:09 - know we actually don't know we we need
75:11 - to give the user the option ourselves
75:13 - the option because maybe depends on what
75:16 - we are going to build um so we could
75:19 - then we could actually do something like
75:20 - this yo uh the message is going to
75:23 - be this is actually this is this this
75:25 - this this this uh need a pointer right
75:28 - because I'm we going to say the message
75:29 - payload that's going to be the buffers
75:33 - uh with this
75:38 - right and then we could uh actually
75:41 - delete all the
75:43 - shenanigans always make it a message oh
75:45 - I think my my cap lock is
75:49 - on right and then we have this message
75:51 - uh which is going to be the message
75:56 - and
75:58 - uh
76:03 - yeah do we wait wait wait we need to
76:05 - make sure it's a
76:06 - knob or
76:16 - default default coder yeah yeah yeah
76:19 - yeah yeah and then we're going to say uh
76:21 - basically in main we can just
76:23 - configurate this we're going to say this
76:25 - decoder is not going to be it's going to
76:26 - be the default decoder right like this
76:30 - what's going on
76:33 - here yeah yeah yeah I see I see I
76:42 - see it's not going to be
76:48 - any got be a message
77:00 - make run V again what's going on with
77:05 - V where is
77:09 - V all right so let's say uh
77:13 - tet Local Host Lo Local
77:18 - Host
77:21 - 3,000 hello ah you see now it's working
77:24 - right so we could give some messages
77:26 - some random stuff and then we can see
77:28 - that we are actually having a message
77:29 - with a payload yeah and then what we
77:31 - could do before we going to pipe this
77:33 - into a channel we are going to go to
77:37 - what's going on with TCP transport test
77:39 - yeah that's broken I guess uh but we
77:42 - could go into TCP
77:44 - transport and in what we could do
77:49 - is uh if we take message we could say
77:53 - we're going to have a from so we always
77:55 - know uh it should be an
78:15 - ADD and now we could say something like
78:19 - uh we have this message decod it and
78:21 - then we going to say message from it's
78:24 - going to be become
78:27 - remote remote edit and that's not going
78:29 - to work uh that's going to be a problem
78:31 - because like we mentioned in the poker
78:32 - engine it's not because the the if we
78:36 - dial somebody and his remote address is
78:38 - going to be the address he's listening
78:39 - to and actually I want to have his
78:40 - listen address because uh so we can
78:43 - actually send
78:45 - back much more
78:47 - easy but uh that being said that being
78:51 - said actually for now it's good enough
78:53 - right we could say make run and then we
78:56 - can say here go run oh go
79:00 - run
79:02 - down Local Host uh
79:06 - 3,000 and can say hello right and then
79:09 - we have this message and it's coming
79:11 - from this other guy here and that's the
79:13 - payload right and then we're going to
79:14 - send that into a channel just a generic
79:17 - Channel with a message right and
79:19 - everybody that's using the library we
79:22 - for the most part um we can then say
79:24 - okay it's a channel we have this here
79:26 - and we're going to handle it in the
79:27 - server and that's going to be decoded
79:30 - the p is going to be
79:37 - decoded could be an
79:45 - N it's could be an any uh we going to
79:51 - see you're going to see because now it's
79:53 - it's it's it's a default encoding which
79:55 - is basically plain bytes but it could be
79:57 - that it's that even those two messages
79:59 - are going to be sent over go up encoding
80:01 - over Proto buffer and then how we handle
80:04 - the inner
80:05 - bites could be another encoding decoding
80:08 - I don't know we're going to see how this
80:09 - going to work um I think this
80:12 - is good for this
80:15 - video uh I think the next video we are
80:18 - going to actually finish this up we're
80:20 - going to finish this this complete up so
80:22 - we can actually start uh with our key
80:25 - with our dis dis storage thing make a
80:27 - server use our own uh library to connect
80:31 - and everything is going to be nice nice
80:32 - nice or maybe we actually going to do
80:36 - our be Discovery and stuff also in this
80:38 - Library not quite sure we're going to
80:39 - see so let me do make
80:42 - run okay I think we started with this uh
80:46 - peer-to-peer package right we are
80:48 - implementing our own peer-to-peer
80:51 - package let me see uh the main
80:56 - yes and then I think TCP
81:00 - transport all right we have these things
81:02 - so I think what we're going to do next
81:04 - is basically we are doing this message
81:07 - decoding here and it's not the decoding
81:10 - of our payload but it's the decoding of
81:12 - the RPC actually the RPC between between
81:16 - two peers and I think we what is the
81:20 - stamp actually what the
81:22 - hell I think remove the stamp so I'm
81:24 - really so I'm left over relix uh let me
81:27 - do settings real quick first and make
81:29 - this uh 18 for the blind homies I think
81:33 - what we're going to do is open up
81:35 - message and I think we're going to
81:37 - rename this to
81:39 - RPC an RPC strict that makes more
81:43 - sense RPC and maybe we should rename the
81:46 - package to RPC but
81:50 - a um
81:54 - message so we're going to say this is an
81:56 - RPC we're going to say
82:00 - RPC this should be an
82:03 - RPC
82:05 - and this is going to be an RPC and of
82:08 - course this is going to be an RPC RPC
82:11 - all the things uh what is going on here
82:13 - this should be a small caps RPC by the
82:15 - way and let me open up
82:21 - um I think we Gucci actually and I think
82:23 - we have some
82:25 - the test is is actually
82:28 - broken uh yeah that that's because we
82:31 - basically have uh or transport options
82:33 - right instead of making this so we
82:35 - should do like Ops it's going to be
82:41 - transport DCP
82:43 - transport Ops like this and I'm we going
82:47 - to say that the listen address is going
82:49 - to be uh let's do
82:52 - 3,000 3,000 please
82:56 - we need the handshake right we did those
82:58 - handshake funk that's going to be a knob
82:59 - handshake Funk we're going to for now
83:01 - we're not going to implement any
83:02 - handshake Funk so you see that we have
83:05 - the ability to create a handshake Funk
83:08 - but we don't going to use it and then we
83:09 - need a decoder and of course we provided
83:12 - the default
83:13 - decoder uh so we can just use that and
83:16 - then put in
83:18 - opts what going on
83:20 - here op inside here and then we want to
83:25 - assert the listen Adder is that's going
83:26 - to be the listen Adder
83:30 - listen Adder like
83:37 - this uh and that's going to
83:41 - be we could do something like this right
83:43 - to test
83:45 - it like this make test real quick
83:56 - undefined message encoding yeah we need
83:57 - to change this it's going to be um an
84:02 - RPC do we actually want a
84:05 - pointer not quite
84:12 - sure not quite
84:17 - sure make
84:20 - test I think we're blocking in a test by
84:23 - the way yeah the select
84:26 - statement this should be good let's make
84:28 - test real quick uh and everything is
84:30 - working fine that's good then let's go
84:32 - to
84:35 - main uh let's do a make
84:38 - run that's working let's open up uh
84:47 - talet my microphone is is is doing crazy
84:50 - stuff uh talet is going to be Local Host
84:52 - 3,000
84:56 - uh now we're going to actually send some
84:58 - messages by the way we're going to say
85:00 - um hello
85:03 - you and then see what's going on yeah so
85:06 - it's all working fine we have uh from
85:08 - from who is this is this Comming and the
85:11 - payload which is sending which is
85:13 - fine working all good
85:19 - um let's open up transport real
85:22 - quick the P interface I think the first
85:25 - method we're going to have in our p is
85:27 - close very
85:29 - important uh close like this so we can
85:32 - close the p is
85:35 - connection and if we open up TCP
85:39 - transport or transport itself uh enable
85:41 - to read these
85:43 - messages we need to have some function
85:45 - which is called a
85:46 - consume which will return a Channel of
85:50 - RPC
85:54 - and now we need to make sure that it's
85:56 - going to work so we're going to say uh
85:57 - TCP
86:06 - transport uh and that's going to be let
86:08 - me quickly think about this you're going
86:11 - to say an RPC Chen which is going to be
86:13 - a chen of
86:17 - RPC a Channel of RPC and then I'm going
86:19 - to say here that the RPC channel is
86:21 - going to be make me a chen of RPC easy
86:28 - then we need to in in in uh Implement
86:30 - our uh interface we're going to say t
86:34 - TCP transport we're going to say
86:38 - consume and that's going to return a
86:40 - Channel of RPC and you see this this
86:42 - syntax right this basically means if you
86:44 - watched the concurrency for beginners
86:47 - this basically means we can only read
86:48 - from the channel and we cannot send to
86:50 - the channel right very important and
86:53 - we're just going to return
86:55 - T RPC Channel like this and then we
86:58 - could say
87:01 - consume implements
87:04 - the
87:06 - transport interface just like
87:11 - that you could
87:13 - say uh which will
87:18 - return a read
87:21 - only Channel
87:28 - uh for
87:30 - reading the incoming
87:33 - messages sent from received from another
87:36 - P actually
87:39 - received from uh another P another p in
87:44 - the
87:47 - network
87:49 - yes that's
87:51 - good all right so now we need to let's
87:54 - do this cursor out of the
87:57 - way now we need to find a way to
87:59 - actually put that uh into our into our
88:02 - channel right so right now we're just
88:03 - printing this
88:05 - channel but we going to say something
88:08 - like that the the RPC channel is going
88:12 - to be the
88:14 - RPC it's going to be an
88:16 - RPC it's going to be the RPC right
88:18 - what's going
88:21 - on that's a pointer we don't want that
88:25 - although we need the address here for
88:27 - the
88:29 - coding so that's
88:33 - good yeah this is is is failing because
88:36 - uh P does not implement the
88:39 - the the close interface right the peer
88:42 - interface so we're going to
88:44 - say uh P TCP P by the
88:50 - way we're going to say close going to
88:53 - return an errors
88:55 - and we're just going to say return
88:57 - P come close and then we can say close
89:03 - M uh
89:06 - implements the P
89:09 - interface just like
89:12 - that all right I think that's good
89:19 - um let's test that out right
89:28 - how we going to do this we're going to
89:29 - say uh listen and accept maybe we going
89:31 - to boot up a new go routine here quick
89:33 - to test this real uh real
89:37 - fast we're going to say
89:42 - for TR
89:44 - consume is going to be the
89:50 - message I think it's something like that
89:59 - uh print Al
90:01 - Lan
90:03 - message or we could say print F what's
90:06 - going on here print F and then say
90:08 - percentage plus
90:09 - fee uh maybe a new
90:14 - line something like that is it going to
90:16 - work uh I have no clue let's let's run
90:19 - this uh running is going it's working
90:22 - you could say Tet
90:24 - Local Host
90:26 - 3000
90:28 - hello yeah it's working fine right
90:30 - although we have this Relic this slend
90:32 - Relic for some
90:36 - reason yeah we don't have a a bad new
90:45 - line uh it's crazy why is this wrong oh
90:48 - yeah of course this is not a this is a
90:49 - new line I see make run we could say tet
90:53 - uh Loc
90:54 - host 3,000 and then do it
90:58 - again yes perfectly fine so now we can
91:01 - consume it's very important because if
91:02 - we uh attach
91:06 - or transport to a server or something in
91:09 - some way then we need to have we need to
91:12 - call consume on any kind of transport
91:14 - and the TCP transport will return his
91:16 - channel but for example any other
91:18 - transport will also return it his uh
91:21 - respective Channel which he communicates
91:23 - over over the wire and in our case it's
91:25 - TCP but it could be anything right we
91:26 - need to make it
91:29 - generic so that's
91:32 - fine
91:33 - [Music]
91:37 - um it's it's actually capturing output
91:39 - what's going on here let's close that in
91:41 - my OBS I hope it's
91:43 - fine all right so we have that the next
91:46 - thing we going to do is um we need to
91:49 - find a way because let's open up real
91:53 - real quick PP transport I'm going to
91:54 - show
91:58 - you yeah so this spe map I don't think
92:01 - we going to we going to keep them we not
92:03 - need a spear map because I think the
92:05 - transport is not going to be responsible
92:07 - to keeping the peers because peer is an
92:08 - interface so we could um I think the
92:11 - server is responsible to maintaining a
92:14 - list of his peers which could be a
92:16 - peer interface which could be any peer
92:19 - right it could hold uh peers that are
92:21 - connected with ECP it could hold Speers
92:23 - that connected with a local transport it
92:25 - could even hold Spears connected with
92:27 - grpc it does not really matter a p is an
92:30 - interface and our server could hold any
92:33 - kind of peer any kind of connection with
92:36 - his Respec uh respective
92:39 - transport that is the beauty of this
92:41 - genetic
92:42 - implementation but we need to have a
92:44 - function we need to have a way to notify
92:47 - the
92:48 - server that there is a new peer that the
92:51 - server can do with a new peer whatever
92:53 - he wants
92:54 - so I think to do that is to do something
92:57 - in
92:59 - TCP and we could say
93:02 - something we have decoder we have H fun
93:04 - we could say that the perer fun or
93:06 - onp is going to be a
93:09 - function of a P with an error right and
93:12 - then we could
93:14 - say that if this function returns an
93:16 - error we are not we're going to drop the
93:22 - P um how we going to do this
93:25 - um first of all I think I'm going to do
93:28 - something like this I'm going to say a
93:29 - defer
93:30 - fun
93:33 - here I'm going to call
93:35 - it or not how does it work it's like
93:39 - this right and then we going to say
93:42 - um actually do it here and then maybe
93:45 - say V error add
93:51 - error then yoink paste it in here and
93:55 - then we could say uh something
94:00 - like uh
94:02 - dropping p
94:05 - connection read Loop
94:09 - yeah uh dropping peer connection and
94:12 - then we could say an error which is
94:13 - going to be the error here on
94:15 - top then we're going to say con
94:21 - close so we could not do doing anything
94:24 - here we could just return
94:29 - here this can be
94:34 - good and here we could say if error
94:37 - first of all we're going to say if T onp
94:42 - right if that's not nil if somebody
94:44 - provided this function then we're going
94:45 - to call it if somebody does not provide
94:47 - this function then we're not going to
94:48 - call it but if somebody has uh provided
94:51 - us this function then we going to call
94:53 - it then we going to say uh if R is
94:56 - T on
94:58 - P and we going to say p no it's going to
95:02 - be the pier yeah we just
95:04 - made and if the error is not
95:07 - nil then we're going to
95:11 - say these erors needs to
95:13 - be can new erors
95:17 - actually we're going to just return
95:28 - yeah something like that so basically
95:31 - what happens is we're going to do our
95:32 - handshake if that's okay then we're
95:34 - going to do the on peer if that fails
95:36 - we're going to drop if that continues
95:38 - then we're going to start our read Loop
95:42 - right
95:45 - um yeah I think that's fine so if you go
95:50 - to main
95:54 - we could say here uh onp let's let's try
95:57 - this without let's try this without
95:59 - first uh make run so that should be
96:03 - normal right you could say uh tnet Local
96:08 - Host
96:10 - 3,000 hello you see everything is
96:13 - working fine we got these
96:15 - messages uh but if we say something like
96:19 - uh onp right and we're going to say
96:22 - that's a function of uh
96:25 - p
96:27 - eror and then we going to say something
96:29 - like
96:32 - um return fmt error
96:36 - F
96:37 - failed the onp
96:49 - funk uh there should be a peerto peer
96:51 - peer like this
96:54 - and we run this
96:57 - again right and then we connect in Local
97:00 - Host 3000 right wait let me do
97:06 - this right it it it instantly drops a
97:09 - connection right so we connect it and
97:12 - and and suddenly tet just exits
97:16 - out and that's because here right
97:18 - dropping p connection filthy on P Funk
97:21 - which is nice because that means that
97:23 - our logic is is working and of course uh
97:26 - we could say here right we could say
97:34 - um let me
97:40 - do we could say onp or
97:44 - something we don't need to specify it in
97:46 - the in uh directly into the transport
97:51 - options right you could say on PE is
97:53 - going to be onp here it's going to work
97:55 - perfectly fine as long as it has the
97:57 - correct signature
98:00 - right um that's
98:06 - fine now we return an error but we could
98:08 - also just return nil right so it's going
98:10 - to work so we could return nil here and
98:12 - then we could say
98:13 - fmt uh print Ln and we could
98:19 - say uh doing some logic with the
98:24 - appear outside of TCP
98:32 - transport and let's boot tet up and then
98:35 - we could say hello we can send messages
98:38 - and then uh we're going to say doing
98:40 - some logic with the p transport so it's
98:42 - all working fine if we have a new peer
98:44 - um we are actually in a good spot that's
98:49 - nice all right let's close it up
98:55 - yes I think it's good so
99:01 - um yeah yeah yeah yeah yeah yeah I think
99:04 - we're in a good spot it's going to be a
99:05 - short episode this one because I think
99:08 - right now we have everything we need to
99:11 - have uh or maybe wait we can actually
99:14 - not I want to test
99:17 - something because on pier we could say
99:19 - this is the pier
99:21 - right and I want to test something what
99:24 - happens if we do be
99:27 - close that's a good
99:32 - question what happens if you do
99:36 - that I'm going to I'm going to check it
99:39 - out it's a very important thing because
99:41 - that's going to
99:42 - basically um drop the Pier from from
99:49 - whatever yeah so we see that's good that
99:52 - we have this eror now we have this Loop
99:53 - right use of closed network connection
99:55 - and it's in the
99:57 - read
100:08 - um how are we going to fix this let's
100:11 - open up p real
100:13 - quick which is in transport
100:16 - right close it's in TCP transport
100:21 - actually it's here right uh if you have
100:23 - an error we keep
100:36 - looping uh let me
100:42 - see so what happens is that we we have a
100:44 - we have an error here in this decode
100:53 - what are we going to do are we going to
100:55 - drop the connection or we going to check
100:57 - the
101:02 - errors good question do uh let
101:06 - me can we do
101:10 - net at
101:18 - closed so I think we could do something
101:20 - like this because I think if if if
101:22 - somebody sends us a wrong payload I
101:24 - don't think we need to punish it I don't
101:26 - think we need to punish him and say yo
101:28 - you're out because you sent a wrong
101:30 - payload but of course uh we could say
101:32 - something like this right R is going to
101:35 - be
101:37 - this and then we could say uh if
101:46 - f is going to be net a con closed then
101:51 - we going to say uh return
101:56 - and we could do it like
101:58 - this and otherwise we're going to say
102:01 - the TCP read
102:05 - error is that something that's going to
102:07 - work let's try it
102:09 - out uh
102:11 - talet uh Local Host
102:17 - 3,000 use to close network connection
102:20 - it's it's not working
102:28 - [Music]
102:33 - oh it's
102:35 - return yeah I think it's
102:44 - fine Clos it it
102:51 - is I CL turn my is already closed yeah I
102:56 - think that's good right
102:58 - because can we can we can we Panic the
103:00 - air to see what kind of a this
103:06 - is it's a very important thing we need
103:09 - to get uh uh working let's not make run
103:13 - it's going to be tet
103:19 - right yeah you see it's it's a use of of
103:22 - of Clos Network
103:29 - connection the question is is is
103:36 - um let us
103:41 - see reflect uh type
103:46 - of as
103:57 - it's a net up
104:02 - error
104:07 - H that's um
104:25 - can we not do
104:31 - this
104:40 - damn okay I think we need to investigate
104:43 - this I think enable to make this
104:48 - um let's
104:51 - return let's return for now let's see
104:53 - let's just
104:58 - return
105:00 - right and now it works right now we have
105:03 - dropping a PE uh because we have a use
105:05 - of closed network
105:08 - connection I think there should be a way
105:09 - so we can assert this specific
105:12 - error so we only drop the beer if it's
105:15 - that
105:17 - error instead of just a normal error
105:20 - actually uh another error for example a
105:23 - code error or something right but hey uh
105:26 - I think we need to figure it out uh soon
105:28 - I will check it out how we can do this
105:30 - maybe it's it's I don't know we can we
105:32 - can see we're going to make it work it's
105:34 - not a big big of a deal for now um I
105:36 - think we have a good portion of our
105:37 - peer-to-peer lip then we're going to
105:39 - make the storage then we're going to
105:40 - make a server Implement that storage
105:42 - into the server and then we can do some
105:44 - um
105:46 - Shenanigans let me see uh what do we
105:49 - have main um I think we're going to make
105:51 - a new file we're going to call
105:54 - this uh storage go I think or
105:57 - store doesn't really matter uh package
106:03 - main I'm going to
106:04 - [Music]
106:07 - say type
106:09 - storage or store maybe store maybe store
106:12 - is good uh it's going to be a
106:16 - structure and then let me quickly find a
106:18 - good spot
106:20 - here and um I do we need something maybe
106:24 - store options or something type uh store
106:29 - Ops it's going to be a strict
106:35 - also and we going to we're going to have
106:37 - some some some stuff uh I'm going to I'm
106:40 - going to keep this here for now let's
106:41 - let's
106:42 - do let's go now with this
106:44 - cursor store test what is
106:48 - this I'm going to do the first function
106:51 - so if you want to write to dis right so
106:53 - basically what we're going to do is some
106:54 - kind of a Content addressable storage
106:57 - where we can save anything in a deep
107:00 - nested folder based on the
107:04 - transformation of the key you will
107:07 - see uh so I'm going to say something
107:09 - like Funk s
107:13 - store uh right stream because I'm want
107:16 - to stream it or try at
107:20 - least we're going to say key is going to
107:22 - be a string and then we're going to say
107:23 - an r i your reader right what's going on
107:27 - here uh a read it like this we're going
107:31 - to return an
107:38 - errors uh yes let's save it real
107:42 - quick and
107:45 - then so something like this right so the
107:47 - path
107:48 - name we could do it maybe this the path
107:52 - name is going to going to be some kind
107:54 - of a transformation of the key
107:59 - right so we could say something like
108:04 - um
108:07 - transform
108:09 - Funk or
108:12 - maybe bad transform Funk which is going
108:15 - to be a
108:17 - type of a bad
108:20 - transform Funk right and I'm going to
108:23 - say it's going to be a function we're
108:25 - going to say of the string of the key
108:26 - and it will return a string it's easy as
108:30 - that and
108:32 - then you could say the stups that the
108:35 - pad transform fun is going to be a pad
108:37 - transform Funk right need to be that
108:42 - signature yes and then we could say here
108:44 - that the store
108:46 - Ops we could just embed it and we could
108:49 - say a funk new store I'm going to give
108:53 - this uh opts which are store
108:56 - opts and we going to return a pointer to
108:58 - a store maybe an error not quite sure
109:01 - I'm going to
109:04 - return uh pointer to the store and I'm
109:06 - going to say that the store
109:10 - Ops are going to be the Ops
109:13 - right something like that of course if
109:17 - you make a test
109:19 - file uh I'm going to make the store test
109:22 - actually
109:24 - store test go right and I'm going to
109:26 - rename this real
109:28 - quick to
109:30 - store
109:32 - yes uh let's close this and let's make
109:35 - another file what's going on here let's
109:37 - open up store on this side and of course
109:39 - test on this side we're going to say
109:41 - package
109:42 - main Funk test store
109:46 - t uh it's going to be testing T and then
109:49 - I'm going to say
109:52 - for example uh that the S is going to be
109:56 - a new store we need options and options
109:59 - going to
110:01 - be store
110:07 - options yeah and the transform
110:11 - Funk uh let's make a default one for
110:15 - Now default
110:18 - pad transform Funk going to be a funk of
110:24 - key
110:25 - string to a string and we going to
110:29 - return actually let's let's make it
110:30 - let's make it clean what's going
110:33 - on let's make it clean we're going to
110:35 - say return the key very simple uh
110:42 - thing that's going to be a
110:45 - v yeah and you could say default pad
110:48 - transform Funk which is all good and we
110:50 - going to say the Ops here
110:53 - and then we have a
110:59 - stor what going on
111:03 - here all
111:04 - right yes so we have this Pat name and
111:08 - then we could say something like s uh
111:11 - pad transform Funk dis key right and
111:14 - then we have a pad name let's return no
111:23 - let's bring it up
111:24 - higher and then we going to say
111:26 - something like
111:34 - um the file and the error is going to be
111:36 - OS actually we need to make
111:41 - um if s is going to be OS mad and I
111:45 - think we need to do all especially uh
111:47 - for our content addressable
111:49 - Shenanigans we're going to mcut all the
111:52 - key no the pat
111:54 - name like this you're going to say if
111:56 - add is not
111:57 - n I'm going to return the
112:00 - Eros what does madol do a file name I
112:04 - think it's I'm not quite sure with this
112:06 - file name is file permissions We Will We
112:09 - Will um figure that out I think it's
112:12 - more the
112:14 - perm not quite
112:18 - sure so we're going to make all the
112:21 - folders We we are needed and you will
112:22 - see you will see
112:26 - why uh and then we're going to
112:31 - say now we need a file name
112:38 - actually and the file name for now is
112:40 - going to be the key we
112:44 - can't let's say it's some file
112:47 - name uh we don't care for now we're
112:50 - going to fix this because we're going to
112:51 - use uh some tricks
112:53 - we're going to make a hash of the
112:55 - contents right we're going to make a
112:56 - hash and that's going to be the file
112:57 - name inside of that Pat name folder
113:00 - that's pretty neat you will see thought
113:02 - about this last
113:06 - night then we going to actually say here
113:09 - um
113:11 - f is going to be OS uh open you're going
113:15 - to open the file I think it's the PAAD
113:19 - name plus slash
113:23 - uh the file name like this and I'm going
113:25 - to say if there is an error we're going
113:27 - to
113:29 - return the
113:30 - errors then we have a
113:33 - file and then we're going to say if I
113:36 - think it's n n add is going to be
113:40 - IO copy for streaming for streaming copy
113:43 - right because IO copy let me quick I
113:45 - will show you um you're going to stream
113:47 - this right you're going to
113:49 - not you will
113:51 - see I I copy we're going to say copy the
113:54 - file with the reader and if there is an
113:59 - error we going to say return the F maybe
114:04 - we should do an fmt or maybe a
114:06 - lock uh print F I'm going to
114:12 - say uh
114:16 - written per D
114:20 - bytes to dis
114:24 - like
114:26 - this and that should be
114:30 - good M we could do something like this
114:32 - right
114:39 - um you're going to say Pat and file
114:44 - name is going to
114:50 - be it's going to be the bat name
114:53 - plus it's going to be this this thing
114:54 - that we did and then the file name right
114:55 - and then we could say bad and file name
114:59 - that's not true this
115:01 - one Pat and file
115:05 - name did I make a
115:08 - mistake bad
115:11 - n what's OS open
115:13 - actually just a name
115:16 - right oh yeah let's see what's going on
115:19 - here like this
115:26 - I could do something
115:27 - like percentage
115:31 - s and maybe do the pattern file
115:36 - name all right um
115:39 - yes let's test this real quick so we're
115:41 - going to say and now we're going to make
115:43 - our transform F and make it
115:47 - beautiful so we have this s is going to
115:50 - be a new store Ops yes we going to
115:54 - say
115:56 - um let's say we want to store something
115:59 - right let's say we want to
116:01 - store s right
116:04 - stream let's make a key uh let's say
116:06 - it's going to
116:08 - be my special picture right could be a
116:12 - special picture and I'm going to say
116:14 - this need to be a reader right let's
116:15 - let's say data is going to be bytes new
116:18 - reader and we going to say uh bytes
116:24 - some
116:25 - GP some
116:27 - GP bytes right it's it doesn't matter
116:31 - it's bytes but right so we're going to
116:32 - say it's going to be some gpeg
116:35 - right uh and then we're going to say
116:37 - data and then we're going to say
116:40 - if actually we should use uh testify to
116:43 - be honest but
116:45 - hey we're going to say t eror and then
116:49 - the add like this and then
116:53 - yeah I think that's good enough uh to
116:55 - test can I do make test real
116:59 - quick no such file or
117:06 - directory um what are we
117:15 - making we need to make create file
117:23 - maybe we need to do us
117:26 - create that could also be a case
117:30 - hey make
117:33 - test yes so you can see written 14 bytes
117:36 - to dis and this is our uh location right
117:39 - my special picture some file name let's
117:41 - open up B I mean b let's open up you see
117:45 - it's my special picture the folder and
117:47 - now we have our file name
117:50 - right which is good
117:53 - uh can let's keep it there of course
117:55 - we're also going to do a configuration
117:57 - where we can set the root of the of the
117:59 - file system and blah blah blah blah blah
118:01 - yada y y right so all right so let's
118:05 - make a let's make a nice uh transform
118:07 - function uh we we're going to test this
118:09 - real quick here we're going to say funk
118:12 - test uh pad
118:15 - transform
118:17 - Funk I'm going to say t uh testing
118:25 - T and we going to make
118:31 - this let's make it at the top I know
118:35 - we're going to split things out as usual
118:37 - right we're going to we're going to make
118:37 - things beautiful as as later
118:40 - on uh let's make it how can I call
118:47 - this let's make it
118:50 - C uh C control add
118:54 - ible
118:56 - bat transform
118:59 - Funk and we're going to take in
119:02 - a a key which is a string we're going
119:06 - to return a string all right and this is
119:10 - the magic you will see this is going to
119:11 - be so cool uh so we're going to say fun
119:16 - funk all right so we're going to take a
119:19 - sha one or an nd5 it doesn't matter I'm
119:22 - going to take a sh one because we will
119:23 - have more bites uh we're going to have a
119:26 - longer a longer a longer
119:28 - thing because I think md5 let me open up
119:31 - md5
119:32 - md5 um Su yeah what's md5
119:40 - size we don't
119:42 - know I think it's 20 or 16 I don't know
119:46 - I
119:47 - forgot so guess controlable pad
119:50 - transform funk
119:54 - how we going to do this
119:57 - um first of all let's let's let's hash
120:00 - this thing so we're going to say that
120:01 - the
120:02 - hash is going to be sha
120:06 - one
120:08 - sum of the key
120:12 - right can we not do this we need to have
120:15 - byes right uh bites of the key
120:24 - then we have a hash then we're going to
120:25 - say that the hash
120:28 - string is going to be hex because now we
120:31 - have bytes right you're going to say hex
120:32 - and code to string to string and it's
120:35 - going to be the hash
120:43 - right uh what what's going on oh this
120:45 - will what does it return hash I think
120:47 - hash returns a 20 yes 20 by and of
120:50 - course uh and go to string a slice so we
120:53 - can convert this to slice by doing this
120:55 - a very neat trick by the way guys uh if
120:58 - you want to convert a fixed uh let's say
121:01 - you have a a 20 byte right and you want
121:04 - to convert this to a slice then you need
121:07 - to do this
121:11 - right easy trick because a lot of people
121:14 - are still using these Loops to uh
121:16 - convert it to to a slice which is okay
121:19 - but it's it's unnecessary right it's
121:20 - unnecessary performance
121:22 - waste of
121:25 - CPU U so we have this hash
121:28 - string and now we going to say something
121:30 - like the block
121:34 - size and that's going to
121:36 - be so we have 20 right let's say a
121:41 - or a pad block size let's say a block
121:44 - size of five and I'm going to say that
121:46 - the slice
121:49 - length and that's going to be
121:58 - I have no
121:59 - clue I think it's
122:02 - Len uh the hash
122:05 - string divided by the block
122:08 - size and then we going to say that the
122:19 - PS wait now I need to think
122:22 - this is going to be on the top of my
122:24 - head not
122:31 - um that's is going to
122:38 - be is it slice length yeah yeah yeah
122:41 - yeah it's this it's this it's slice
122:43 - length yeah yeah so pads wait so we
122:45 - could do yeah yeah
122:46 - yeah uh Pats is going to be make me a
122:51 - slice of uh slice of bytes I
122:55 - guess or even a slice of string actually
122:58 - and we going to say the slice L I'm
122:59 - going to pre-make
123:01 - it oh yeah and then we going to say
123:04 - Forge and I'm going to Loop through L
123:07 - pads I
123:09 - guess or even even you could say slice
123:11 - Len it doesn't really
123:14 - matter slice L is actually it's already
123:17 - a number right so what am I doing here
123:19 - uh like this
123:23 - now we going to
123:24 - say
123:25 - from to is going to
123:36 - be uh it's going to
123:41 - be I
123:43 - times block
123:48 - size I times block size
123:55 - plus block
123:58 - size and I'm going to say they're going
124:01 - to say Pat y
124:04 - equals the hash string look at this the
124:07 - hash string from
124:11 - two right and then we going to now we
124:14 - have this
124:16 - Pat and then we could say return strings
124:20 - join man this is is actually insane uh
124:22 - strings
124:27 - join uh strings join strings join
124:29 - strings join the the the the the pads
124:33 - can we do this actually we can't because
124:36 - we can we can we can strings joins pads
124:39 - and then we're going to join it with the
124:40 - slash right for the pad thingy yes let's
124:43 - try this let's try this we're going to
124:44 - say that um the pad the pat name from
124:48 - our key right so we're going to let's
124:50 - say we have a key right we're going to
124:51 - store for example um a bite it's going
124:54 - to be a string actually so we're going
124:56 - to say mom's best pictures mom best
125:00 - picture right and the pth name of that
125:03 - uh thing is going to
125:05 - be so we're going to each key is going
125:08 - to be transformed to a certain pad on
125:13 - disk mom's best
125:16 - picture and the pad name is going to
125:19 - be uh C pad transform we're going to
125:22 - give that key and then we're going to
125:24 - basically I don't know what it's going
125:26 - to be so so let's let's print it out uh
125:29 - fmt print Ln the pad
125:35 - name let let us run this you see this is
125:40 - our pad
125:43 - name right so we're going to make a
125:45 - folder this folder then inside this
125:47 - folder we're going to make this folder
125:49 - and inside this folder this this this so
125:50 - we're going to go in depth right so
125:53 - we're going to have a nice nice nice uh
125:56 - depth of folders for every 10 and uh
125:59 - yeah so we can store these
126:01 - things on disk that way and we could we
126:05 - we we we can change this up right it
126:07 - could be that we only have two depth or
126:10 - or a three depth or whatever but now we
126:12 - have a five
126:14 - depth which is
126:16 - good
126:19 - nice the question is how how are we
126:21 - going to test this
126:24 - um actually what we could do is um run
126:28 - this
126:30 - again I have no clue man I'm going to
126:33 - just copy this and I'm going to say uh
126:36 - if bad
126:39 - name it's not the best thing to do but
126:41 - hey if bad name uh is
126:44 - not
126:46 - this let me going to say t erors
126:53 - let say
126:59 - actually expected expected pad name
127:02 - you're going to say something like this
127:03 - let's let's yink it and paste it in
127:08 - here expected bad name I'm going to say
127:10 - Dem eror
127:12 - f
127:15 - t
127:17 - have this want this
127:22 - Bad Name expected bad name and we don't
127:25 - need to do this D by the
127:28 - way all
127:31 - right something like that something like
127:34 - that all right so we're going to say
127:36 - that the pad name is going to be
127:39 - transform Funk so we could do it's not
127:42 - going to be the default transform Funk
127:43 - we're going to say it's the gas pad
127:44 - transform
127:46 - fun and you can make your own transform
127:48 - funks and and and we can extend it with
127:51 - with whatever ever you want to you want
127:52 - to do you could do a git gtit type thing
127:55 - uh it doesn't matter
127:57 - right all right so the next thing we
127:59 - need to do is this file name this file
128:01 - name is not okay we want to have uh an
128:03 - md5 hash or something even a sha hash it
128:05 - doesn't really matter it needs to be
128:11 - hashed
128:16 - so and of course things are going to be
128:18 - encrypted I know but for now
128:26 - I think the problem is we have this
128:28 - reader right this reader so what we
128:32 - could do enable to Hash the contents of
128:35 - the reader the bytes of the reader right
128:37 - we need to read but we also need to
128:40 - read to to copy it to the file right we
128:43 - have the file we have our reader and we
128:45 - need to copy the reader into the file
128:46 - which will read and once the reader has
128:48 - been read it's it's done so enable to do
128:51 - that I think you're going to first Le
128:53 - into a buffer so we're going to say
128:54 - buffer is going to be a new byes buffer
128:58 - right it's very interesting actually
128:59 - because we do a lot of this uh
129:01 - networking stuff and now we are doing
129:03 - these these these um file reading
129:07 - Shenanigans which is nice
129:11 - right and now we going to
129:13 - say I'm going to say IO copy and we
129:16 - going to copy this reader into a buffer
129:27 - and then we going to say something like
129:29 - that the file name
129:33 - itself the file name
129:36 - bytes is going to be
129:38 - md5 the sum of the buff um
129:45 - bytes like this now going to say that
129:48 - the file
129:50 - name it's going to be a hex and
129:53 - code to string of the file name
130:00 - bytes then we can do this patn file name
130:06 - thingy then we're going to create it and
130:08 - of course this reader is already already
130:10 - uh we can do anything with it so we're
130:12 - going to
130:13 - say can we do
130:17 - buff that would be
130:20 - nice that would be nice is it going to
130:24 - work yes look at this so so now we're
130:28 - going to see right let's open up our
130:29 - folder so we're going to say this one
130:32 - and inside this folder we have this
130:34 - structure this structure this structure
130:35 - 1 2 3 4 5 6 7 why do we have so
130:41 - much yeah it's it's normally it's
130:43 - because yeah
130:46 - yeah is it
130:53 - yeah so we have these nested folders
130:55 - right I think it's okay let
130:59 - me it's D and this one this one this one
131:03 - this one and then we have this file
131:04 - which is jumz so we are storing this on
131:07 - dis already it's nice nice look at these
131:08 - folders I like it I like it and if we
131:11 - want to read it's the same principle we
131:12 - we know exactly we transform the key we
131:15 - want to read and it will
131:16 - be wait wait we have a trouble
131:24 - we cannot we can we cannot transform it
131:26 - like that because how do we read
131:29 - something if we read it we need to no no
131:31 - no we can't we
131:33 - can't we made a mistake uh let's close
131:37 - this up we cannot do this file
131:46 - invites I think
131:55 - uh that's not
131:57 - true because right now we are storing
132:00 - let's let's make
132:03 - um I think we need you you know what I'm
132:06 - going right because if we want to read a
132:08 - key and we have our key but we don't
132:10 - know what's inside most of the time
132:13 - so if we want to have the full pth we
132:16 - need to have the bites of the thing we
132:18 - want to read the the content of the data
132:20 - so we can hatch to know its file name
132:23 - but that's that's impossible right to
132:25 - get something
132:27 - so let's I have an idea I have an idea
132:30 - we're going to say something
132:34 - like something like a type
132:37 - uh a pad key going to be a
132:41 - strict and a pad key is going to hold
132:44 - the
132:45 - pad the pth name which is going to be a
132:48 - string but also the
133:05 - original is it the thing original key
133:09 - Maybe original original is
133:16 - good so the spad transform Funk could
133:20 - return a pad
133:26 - key why we going to return a pad key and
133:29 - I'm we going to say that the
133:32 - um we could say return me a pad
133:37 - key and the pad key is going to have the
133:40 - um the pad name and the pad name is
133:43 - Going to Be Strings it's I'm going to
133:45 - just going to type it out again uh
133:47 - strings join this thing that we did
133:50 - right we're going to say pad
133:51 - and then we're going to join it with
133:54 - this and then we're going to say that
133:56 - the original is going to be the hash
133:59 - string right like
134:07 - this uh expected Pat name and I'm going
134:09 - to say expected
134:11 - Pat expected
134:15 - original or
134:18 - Ori key uh and that's going to maybe the
134:22 - pad key but without these things
134:28 - right I'm making so
134:30 - or
134:32 - G no man I cannot type
134:40 - original so then we going to
134:42 - say bad key here now we going to say the
134:47 - pad key
134:51 - uh Pat name is going to be this
134:57 - right and then we could actually copy
134:59 - this again paste it then I'm going to
135:01 - say pad key
135:03 - original should be the
135:07 - expected pad
135:09 - name it's going to be Pat name
135:11 - original what's going on with your
135:13 - original key
135:22 - no it's going to be expected original
135:25 - key yes is this going to work
135:32 - work yeah of course we have some issues
135:34 - I
135:41 - understand so we're going to say that
135:42 - the pad key can I make this like this or
135:45 - this I don't care and then we going to
135:47 - say make everything it's going to be the
135:48 - pad key
135:53 - Bad
135:58 - Name Bad
136:02 - Name wait we don't need this we can we
136:05 - don't need to copy this actually we can
136:07 - uh I
136:10 - think I think
136:15 - we Pat and file is going to be the pad
136:17 - key uh this and then we going to say
136:20 - actually what we could do
136:21 - look at
136:25 - this let's do it like this I don't know
136:27 - what what I'm doing actually uh bad name
136:30 - yeah of course we have some issues in
136:32 - our
136:33 - test
136:34 - uh like this and then we going to see
136:38 - what's going on
136:41 - here what's going
136:47 - on oh it's the
136:51 - yeah it's true what's going on unnown
136:53 - field pad
136:58 - name and we going to we can make a
137:00 - function right we can say uh
137:06 - Funk uh we could say pad key and let's
137:10 - say file
137:13 - name yes file name is going to return a
137:16 - string and we could just return uh like
137:19 - this we could say return
137:21 - and we can make it clean we could say
137:23 - fmt s
137:25 - Sprints s and we could say it's going to
137:29 - be percentage s/ percentage s and that's
137:33 - it and I'm going to say
137:35 - ppad name p
137:41 - original s
137:44 - print what's going on F yes that's the
137:48 - file
137:49 - name so we're going to
137:52 - make the pad
137:55 - name the patn file
137:58 - name only thing we need actually we
138:01 - could do
138:07 - it that's going to be pad
138:11 - key file
138:13 - name right and instead of copying this
138:16 - BFF we can copy the add
138:18 - right I think that's going to going to
138:20 - be some
138:23 - uh there going to be something I think
138:24 - we are at a good track Let's test the
138:27 - storage yes so we are written to dis
138:30 - this whole
138:31 - shebang right so now you can see that we
138:34 - make these folders right and the file
138:37 - name is going to be the path name but
138:40 - then laid out so then we can find it but
138:42 - then we can retrieve it right all right
138:45 - so what I want to test um
138:52 - is basically uh
138:56 - reading so let's make something like
138:58 - Funk s store let me let me move it up
139:04 - here Funk s store I'm we going to say uh
139:07 - read
139:09 - stream a key which is a
139:12 - string and it's going to return
139:16 - us that's a good question are you reader
139:20 - it it it's sounds weird but and an error
139:24 - maybe uh because we're going to W these
139:26 - functions right so now read stream right
139:28 - stream is going to be internal functions
139:30 - but we're going to wrap them with read
139:32 - right and and and easy easy API to
139:35 - use
139:38 - um right so we're going to say that the
139:40 - pad key we're going to say the same
139:42 - thing right the pad key is going to be
139:45 - Asad transform fun of the key right
139:51 - and we going to say that the file name
139:52 - or the full PAAD actually
139:54 - maybe uh the full PAAD is going to
139:59 - be actually can we I think we're going
140:02 - to say OS open and we're going to
140:07 - say it's going to be an f file and an
140:10 - error it's OS open and I think you're
140:12 - going to say the pad
140:13 - key uh file name no it's file name it's
140:20 - I don't like this file name thing
140:25 - because where is Pat key file
140:30 - name the pat name the
140:36 - original I don't like original uh this
140:39 - is going to be file
140:40 - name we're going to refector this uh and
140:43 - I'm going to say this is going to be the
140:44 - full
140:49 - pad the pat P name and this the file
140:52 - name will give us the full pad is that
140:53 - is that correct uh leave some
140:56 - comments if you think I'm I'm wrong if
140:59 - if you think we can do this better
141:00 - because
141:01 - hey so the full pad is going to be the
141:03 - pad name with the file
141:09 - name because this is the file name right
141:11 - I mean it's clear as that of course
141:13 - that's we're going to bat name original
141:16 - is going to be the file name
141:29 - yes full pad of course we have some
141:31 - issues here uh and
141:38 - here let's make it full pad
141:51 - and of course here also uh going to be
141:54 - full pad yes and then we're going to say
141:57 - here pad key full pad that's we're going
141:59 - to that's we're going to open if there
142:01 - is an error we're going to return can we
142:03 - return n as a yeah we can we're going to
142:07 - return
142:08 - no Ed then we have a
142:13 - file the question is we can we can um
142:21 - what do we want to return if we want to
142:22 - do a read
142:29 - stream that's a good question I think
142:31 - file is is a reader
142:38 - right file as a
142:47 - reader H but I think we need to this
142:50 - read stream because we're going to do
142:52 - decryption and
142:56 - stuff decryption needs to happen on the
142:59 - client side I think which happens
143:05 - right well I mean we're going to
143:08 - get um this is a hard
143:15 - one is file reader that's a question let
143:17 - me I think so right yeah yeah it needs
143:19 - to be
143:22 - yeah we
143:25 - can of course we need to close these
143:27 - files
143:31 - right that's a thing so the problem is
143:34 - with we reading we're reading a file
143:36 - from this but we need to make sure we
143:37 - close this so I don't think it's going
143:38 - to be a reader but a
143:40 - read
143:46 - closer which basically means we can just
143:49 - do this
143:51 - return the whole sh bang but that
143:52 - doesn't make any
144:02 - sense but then we can wrap this in a
144:04 - function and we could say for example s
144:06 - store and uh just
144:09 - read read the key is a
144:12 - string and then what we could do here is
144:17 - um H we could bites or a
144:30 - reader not quite sure guys what we need
144:32 - to do here there are a lot of
144:35 - options uh to be honest so we could say
144:37 - for
144:43 - example Del stream this Str this key
144:51 - we return n
144:55 - n right and then we could say uh we
144:58 - going make a
145:00 - buffer new bites
145:10 - buffer h
145:21 - you're going to say I copy F
145:25 - buff
145:27 - no buff
145:29 - F and I'm going to say f
145:36 - close and then we're going to return the
145:39 - buff no actually what you could do is
145:55 - let's do
145:56 - this let's going on what did I
146:05 - do let defered heat F
146:09 - close should I do it like
146:17 - this actually I think it's fine uh I
146:20 - think it's fine we can say
146:24 - defer I'm we going to say add and then
146:26 - we going to return add
146:31 - right doesn't does it
146:35 - huh what what what happens here written
146:38 - add right oh yeah new new variables yeah
146:41 - I
146:42 - see um yeah yeah it's fine it's
146:46 - fine is that a thing
146:52 - Let's test this right so let's let's put
146:54 - it up higher so we're going to say here
146:55 - data we're going to read uh what is this
146:57 - my special
147:00 - picture let's make a key I'm going to
147:03 - say the
147:05 - key uh what's going on there going to be
147:09 - mom
147:14 - specials you're going to read the key
147:16 - these are the bytes these are the data
147:19 - right this is a new store like we're
147:20 - going to write this and then we're going
147:21 - to read this right then we're going to
147:23 - say uh that
147:25 - the
147:26 - s s is going to be S
147:31 - read uh we're going to read the key we
147:35 - going to say if
147:38 - s is not
147:42 - nil the error
147:48 - right T eror
147:54 - um now we have this reader right and and
147:57 - I think it's important to return a read
147:58 - because then you are then you are
147:59 - flexible then then we are flexible if
148:02 - you just return the btes I think it was
148:04 - important to to close the file so we
148:07 - don't need to do that the users well we
148:09 - don't need to do that later
148:11 - on but a reader is important to have so
148:15 - we're going to say uh R is going to be
148:17 - we're going to say that the B
148:24 - going to be IO till read
148:28 - all
148:30 - R uh if R is do we need
148:34 - this and we're going to say
148:43 - um wait what you could do is instead of
148:46 - doing we're going to say this is going
148:47 - to be
148:48 - bites like this
148:51 - and we're going to say this is going to
148:52 - be a bite uh new reader
148:57 - here my mic is
149:01 - constantly doing stuff it doesn't need
149:03 - to
149:04 - do hey anyway it is what it is um yes
149:09 - we're going to do it like this because
149:11 - then we're going to read this bites and
149:13 - then we could say
149:14 - if uh B is not equal to the data right
149:20 - that we that we put
149:27 - in you're going to say t add F you're
149:29 - going to say want
149:31 - this can we do s I think so
149:37 - have uh
149:39 - this we want data we have
149:43 - B what's going on what B is not
149:47 - data damn it's it's I see
149:52 - well what you could do is this right you
149:53 - could
149:54 - say string
149:57 - B string
150:01 - data is that a
150:03 - thing yeah look at this it just work it
150:07 - just working so because we could say fmt
150:11 - print uh print Ln and we could say
150:15 - string uh B right so you could see what
150:17 - we readed right
150:21 - some geg bites it's fine it's working
150:24 - yay all right
150:26 - so help me what's going on
150:37 - here we can
150:41 - read of course I think we need to do
150:43 - some more stuff in here but hey it's
150:45 - fine for
150:46 - now um
150:54 - and I'm
150:57 - thinking my special picture so we have
151:00 - these cool St oh we
151:14 - have what the hell is going on here
151:32 - the of course if you store the same file
151:38 - again this is weird Behavior
151:45 - well so it's going to Hash but why is it
151:48 - the same pad and not the same
151:57 - thing ah see yeah of course it's it's
152:00 - hashing the same pad uh we do an
152:04 - md5 no we
152:07 - don't anyway uh doesn't
152:12 - matter we will fix that uh we will see
152:15 - what what is this uh how how that
152:16 - happens it doesn't really matter because
152:17 - it's the same file the question about
152:19 - the is what what do we need to do when
152:21 - we are storing the same file once again
152:23 - so we we're going to fix that all later
152:25 - on uh the basics
152:28 - first actually we should we should
152:31 - um let's make a delete function so we
152:34 - can actually clean up our test otherwise
152:37 - if we run the test we will have these
152:38 - folders sitting around
152:41 - right um we have read here let's make a
152:46 - delete if you really want to delete
152:48 - something right uh we're going to say
152:50 - delete we're going to delete a key we're
152:52 - going to return an error and the first
152:55 - thing we're going to do like usual is
152:57 - make our pad
152:59 - key that's going to be S transform
153:05 - Funk with the
153:13 - key and I think we need to do
153:26 - [Music]
153:31 - H let's do
153:34 - F actually do we need to stat this to be
153:37 - honest
153:39 - because can we not do something like
153:44 - OS
153:46 - remove removes the name the named file
153:49 - or empty that Dory if there is an error
153:51 - and what's remove all removes remove all
153:55 - removes pad and children contains it
153:57 - removes everything it can but Returns
153:58 - the first okay see maybe I think I
154:00 - remove
154:01 - all and it's going to be the pad key
154:05 - full
154:09 - pad like
154:13 - this uh let's return the OS
154:24 - of course this we can actually just
154:26 - return
154:32 - this unless we want to
154:35 - lock and even then uh even then but we
154:39 - like I said this is very very early I
154:42 - think we're going to add much more to
154:43 - this later on in these things right
154:46 - especially if you want to work with a
154:48 - cach and everything so I'm going to
154:49 - Implement a cach and if you want to work
154:51 - with a cache we need to bust the cach
154:53 - and if you delete and blah blah blah and
154:54 - all that good stuff right so that's why
154:56 - this function will be
154:57 - bigger we can actually make a
155:02 - deferred
155:16 - funk I could say something like this
155:18 - right or or
155:25 - this uh it's going to be pad key full
155:29 - pad
155:29 - maybe actually file name
155:37 - maybe right this is going to work no
155:40 - idea um can make this test right you
155:42 - could say
155:44 - funk test delete
155:53 - going to be a t testing.
155:56 - t
156:01 - um could copy
156:12 - this let's write
156:15 - it let's write Mom special key
156:28 - uh and let's then
156:33 - say uh if s is as
156:37 - delete
156:44 - key the error F not not error F uh
156:53 - let's make another function
157:04 - actually has key we need to make this
157:07 - pad Keys all the time right we need to
157:09 - make this transform funks uh all the
157:12 - time let's going
157:15 - on I think it could do something like um
157:18 - file
157:19 - information is OS
157:23 - stat uh the key no not the key the pad
157:27 - uh full
157:33 - pad what am I doing here with this
157:35 - capital
157:36 - P full
157:40 - pad uh we're going to do with this AR
157:43 - has do we care about
157:46 - this look look at this what we're going
157:48 - to do is if add not n going to
157:52 - return
157:55 - false is that a thing actually should we
157:57 - do
157:58 - this so let's say if we have and we and
158:01 - we are trying to stat something and we
158:03 - get an error in stating I'm going to
158:06 - turn false you know what I mean it's
158:07 - it's uh then we going to say
158:11 - um how can stat actually turn n
158:16 - anyway wait maybe let me let me see what
158:20 - stat
158:22 - does stat Returns the file info
158:26 - describing the the file name if there is
158:29 - an error it will be bad
158:39 - error it's a bad AR
158:43 - right because we don't get this file
158:45 - info right
159:07 - uh is not exist buting whenever the is
159:09 - know report directly exit
159:19 - Cod should use
159:25 - FS uh FS a not exist is that a
159:39 - thing I don't exist
159:51 - man this is this is
160:06 - crazy
160:09 - huh if F what is this should use return
160:13 - R is not equal resist instead of
160:17 - if why
160:29 - because if the error is the file not
160:31 - exist then we return files right because
160:32 - we don't have the file
160:37 - then I don't understand am I am I stupid
160:45 - maybe
160:47 - baby man
160:55 - let me clean up these folders real quick
161:03 - actually do we have we have no
161:05 - Shenanigans right so basically what I'm
161:07 - going to do is I'm going to test store
161:09 - delete key I'm going to store this key
161:10 - and I'm going to delete this
161:13 - key so I'm going to run this test
161:20 - and then is see delete it from
161:26 - disk but the problem is this they're
161:28 - still here but the file is gone the file
161:31 - is
161:32 - gone the file is gone but the the folder
161:35 - is still
161:37 - there oh
161:39 - man so what do we
161:43 - do do we remove these folders also or or
161:45 - what is this I thought I thought remove
161:47 - all
161:49 - I really I really I really thought remov
161:51 - all would remove the whole
161:53 - shebang not going to
162:02 - lie what what happens if you do remove
162:05 - all the pad key and we say we're going
162:08 - to remove the pad key pad
162:12 - name what's going to happen then if you
162:15 - do this
162:17 - again as the this
162:24 - boom that's that's that's that's
162:46 - crazy it's deleting that's for sure
163:02 - remove removes the named
163:11 - file remove remove bad and any children
163:14 - it
163:15 - contains oh but ah
163:25 - man why is it not working the bat name
163:38 - Pat that's crazy
163:53 - that's crazy uh I was really really
163:56 - really assuming that o REM move off
163:58 - would delete the whole She Bang but
164:00 - apparently it
164:07 - isn't uh let me think then we could do
164:10 - two times right we could do but that
164:11 - doesn't make any
164:14 - sense oh oh but that's it's full pet
164:17 - full pet
164:20 - yeah full pad right so we're deleting
164:22 - the full pad so I don't know I don't
164:23 - know I don't know why this is not going
164:25 - to work to be
164:26 - honest why does vs code not
164:31 - yes boom so we deleted this file name
164:34 - yeah I
164:36 - understand it's gone I completely
164:39 - agree H weird
164:44 - Behavior Uh so let's do something like
165:05 - I'm not quite sure if this the right
165:06 - approach to be honest but
165:09 - hey now
165:13 - return we're going to say patk full Pat
165:16 - Uh we're going to say yeah no not the
165:19 - full pad this is going to be then the
165:20 - the the the pad name right pad name it
165:23 - should delete everything it is what it
165:25 - is I don't
165:27 - understand um let's let's open up let's
165:29 - remove this folder once again now right
165:33 - and let's do this
165:34 - again all right now now everything's no
165:37 - what's going
165:46 - on you know what
165:50 - you you you know what we're going to do
165:52 - what is this man is is this window
165:53 - Shenanigans what we going to do is
166:02 - um we're going to say pad key make a new
166:05 - function you're going to say p bad key
166:13 - first pad name and that's going to be
166:17 - it's going to return a string
166:20 - and we're going to say
166:23 - um return strings
166:28 - split thep pad name and we going to
166:32 - split it with this and we're going to
166:34 - return the
166:39 - first all right and we're going to say
166:41 - we're going to double check because we
166:42 - are doing a ray so let's do pads like
166:45 - this uh we're going to say let's make it
166:47 - actually good right because
166:51 - um people going to roast me so we're
166:53 - going to say this this is going to be
166:54 - the pads right I'm going to say if
166:57 - Len uh
167:02 - pads if if if l p is zero right I'm we
167:05 - going to say um we could Panic here
167:07 - because if we want a first pet name and
167:09 - it's zero but let's return nothing it
167:12 - doesn't
167:16 - matter I mean you could say yeah Pat
167:18 - name needs to return a string and an
167:19 - error but you could man if you could
167:22 - yeah yeah I know but still I'm not I'm
167:24 - not I'm very I'm a big fan of errors and
167:27 - handling errors very important but these
167:29 - things if you are trying to get the
167:31 - first Pat name but the you cannot make a
167:34 - pat name something is terribly wrong in
167:36 - your
167:37 - system in my
167:41 - opinion something to think about you
167:42 - could say return now we're going to
167:44 - return the pads zero right the first one
167:47 - right so instead of doing this where is
167:50 - M
167:53 - remove delete here let me try something
167:56 - real quick let me comment this out we're
167:58 - going to say remove everything but we're
168:00 - going to say pad
168:02 - key the first pad
168:07 - name
168:09 - okay delete
168:13 - Perman do it again
168:19 - hey you
168:21 - see now it's
168:25 - working
168:28 - ha so can we actually do the complete
168:31 - test actually uh let's let's do
168:36 - it test Le key yeah yeah yeah so we're
168:39 - going to do do our test here read
168:42 - everything and we're going to test this
168:44 - and then we're going to basically just
168:46 - say um
168:54 - as
168:55 - delete
169:04 - key yes it's working yeah
169:09 - baby uh
169:11 - yes of course we also want to basically
169:13 - for our test if you want to do a
169:14 - complete tear down where we delete
169:16 - everything we just stored we need to uh
169:19 - implement the root of the storage we
169:21 - need to know where the root of the
169:22 - storage is and um once we know that then
169:26 - then we can just delete the the delete
169:28 - the complete
169:29 - roote uh basically so we could actually
169:32 - say should we make a function
169:35 - clear not quite sure but anyway um let's
169:38 - open up store and store test real
169:40 - quick and uh what we already can do is
169:43 - save things we're going to make these
169:45 - folders uh based on the key right based
169:48 - on the key we're going to transform that
169:49 - key and then we are going to create some
169:51 - some pad to the file right uh content
169:55 - addressable but the problem is there is
169:56 - no way to specify a root right we cannot
169:59 - just store that randomly on disk we need
170:02 - to have a root that contains the whole
170:06 - shebang so how we want to do this uh is
170:08 - basically a couple things actually
170:10 - because I was I was uh inspecting this
170:12 - code base and um we made a a mistake
170:14 - well not a mistake we forgot something
170:17 - so we have this
170:19 - let me put out of the way this uh cursor
170:22 - so we have this default Pat transform
170:23 - fun which is basically the
170:25 - default uh and we have no way to
170:27 - [Music]
170:29 - basically uh add default values right so
170:32 - we could do something like here new
170:33 - store and we could say like if the Ops
170:36 - uh the pad transform Funk is nil then we
170:38 - could actually say that the Ops pad
170:40 - transform Funk is the default pad
170:42 - transform fun but that's not going to
170:43 - work because we
170:45 - changed this interface uh let's go up
170:48 - top
170:50 - we changed where where is the thing this
170:52 - pad transform fun is basically takes a
170:54 - string and and returns a pad
170:57 - key but we are returning a string still
171:00 - in this transform fun so we need to say
171:02 - it's going to be a pad key and that's
171:04 - going to be that's going to
171:08 - return uh that's going to return a pad
171:10 - key and I think because it's the default
171:13 - function we can say that the pad name is
171:15 - going to be the key and then the file
171:18 - name can also be the key why not right
171:21 - so that's going to that's going to work
171:22 - perfectly fine the next thing I want to
171:25 - do is basically add a root in the store
171:27 - UPS which is going to be a string it's
171:28 - going to
171:30 - be uh root we can say root is
171:36 - the uh folder name of the
171:42 - root of the root
171:53 - containing containing all the files
171:56 - maybe
171:57 - folders uh files of the
172:02 - system like
172:04 - this and then we could say
172:09 - something here right we could say if the
172:11 - op actually we could say uh let's let's
172:14 - make a constant we're going to say
172:16 - default uh
172:20 - root folder name or something I don't
172:21 - know and we could say it's going to be
172:23 - GG wait my my keys my it's
172:27 - still it's back to International and it
172:29 - needs to be us keyboard layout otherwise
172:31 - uh my quotes are up we're going
172:33 - to say GG
172:37 - Network like this and then we could say
172:43 - something
172:44 - here if opt root actually we could say
172:48 - if the length of the Ops root equals
172:52 - zero that's how I that's basically how I
172:54 - check if strings are zero you could to
172:57 - basically like this right is the same
172:59 - thing if Ops root equals uh this right
173:03 - but I don't like it for some
173:06 - reason I don't like it so I'm always
173:09 - doing if Len of the string is zero then
173:12 - we could say that the op root is going
173:14 - to be the
173:15 - default uh default root folder name
173:24 - of course now the whole system is is
173:25 - broken right because we have
173:28 - um what is this we can delete it I
173:33 - guess because if we want to
173:40 - write uh so we're going to say Pat key
173:43 - and then we going to M the bang
173:47 - right the the pad name of the pad key
173:49 - the problem is we need to append I not
173:51 - append preent we need to preent the root
173:55 - name to
174:01 - this so actually it could be something
174:03 - like uh s
174:05 - Roots like this but that's that's a
174:07 - nasty way to do that I know right is I
174:11 - just want to test this real quick let me
174:12 - open up my folders and let's uh run test
174:15 - here right it's not going to work
174:30 - um why why is it panicking actually I
174:32 - don't
174:33 - understand now basically it's it's tried
174:36 - to
174:45 - open uh it's try to open that shenan
174:55 - it's a right stream it's maybe because
174:57 - we're also doing read streams here let's
174:59 - let's uh
175:01 - Delete so we're going to WR stream
175:04 - here we already have these uh these
175:07 - complete folders here that's fine so
175:09 - something is
175:12 - working all right let let us test uh
175:15 - just writing right that's going to fail
175:25 - uh that's going to
175:32 - fail it's the full pad yeah yeah yeah I
175:35 - see I see what's going on so we
175:37 - basically do this m all with the root
175:39 - and then we making a full pad and then
175:40 - we are going to create but the full pad
175:42 - also needs to be the root uh plus the
175:46 - full pad right
175:49 - let me delete this folder once
175:52 - again and let's run this again right now
175:55 - it's it's going to work perfectly fine
175:57 - so we have our root and then we have our
175:58 - file here which is some gpeg bytes so
176:01 - that's already a good start
176:05 - um okay so how can we make this cleaner
176:08 - with this root
176:15 - thingy let me close this bites thingy
176:22 - I'm
176:23 - tired it's still
176:25 - early and I'm trying to do this as raw
176:27 - as possible right no no no no
176:30 - prerecorded Shenanigans
176:34 - so wait what is this pad name and then
176:36 - we have the full pad with which is
176:38 - basically the pad with the file name and
176:40 - this is going to be uh the pad key pth
176:42 - name which is going to be the pth
176:43 - without the file name
176:51 - what we could do is make a transform fun
176:53 - with the root do we want that I don't
176:55 - think
176:58 - so or we could do something like pad key
177:02 - uh something like pad key root or
177:04 - something and then say that's going to
177:06 - be the S
177:08 - root but I don't like
177:14 - it I don't like that so what we could do
177:17 - is
177:21 - basically you can keep it like
177:26 - this I'm also thinking maybe should do a
177:29 - pad transform fun with the key and the
177:31 - root or
177:33 - something like
177:38 - this but that's then it's not a
177:41 - separation of concerns right I want to
177:42 - have this function as pure as
177:46 - possible uh so what we could do to make
177:49 - it a little bit cleaner is
177:52 - basically uh it's going to be the pad
177:55 - name with
177:57 - root and that's going to be an fmt S
178:00 - print
178:02 - F yeah as print uh F yeah like this
178:06 - we're going to say
178:08 - percentage s/ percentage s and then
178:11 - we're going to say it's going to be the
178:12 - S
178:13 - root and the pad key uh is going to be
178:16 - the pth name I guess
178:19 - bad name yeah like this right it's
178:23 - already a little bit cleaner we're going
178:25 - to say pad name with
178:29 - root then we have this full
178:32 - pad and then we we could say the same
178:34 - thing like full pad with the root right
178:38 - and let's just uh let us copy this bad
178:41 - boy but that's not going to be the pad
178:43 - key pad name it's going to be the full
178:45 - pad right
178:49 - actually yeah then we can say full pad
178:51 - with
178:53 - root full pad with root and then this is
178:56 - going to
178:57 - be we written to B we written to the dis
179:00 - and it's going to be the full pad with
179:01 - the root is that a
179:03 - thing I don't know let's delete
179:08 - this and let's run it again it's all
179:11 - working as expected that's perfectly
179:15 - Gucci so let's Del it again I think what
179:18 - I'm going to do is make the delete
179:19 - function uh right now because then we
179:21 - don't need to do it
179:24 - manually but let's make this test work
179:27 - first right so then we're going to read
179:29 - we're going to read the
179:31 - key we're going to read the key
179:34 - actually so that basically means we need
179:36 - to fix it what's what's what's going on
179:38 - with right
179:43 - stream test it doesn't detect it's
179:46 - telling me probably that it's not
179:47 - getting used although we're using it in
179:50 - our test but
179:52 - a and this thing uh this can be
179:55 - different we could do if
179:57 - erors uh is s o not
180:03 - exist is the same
180:08 - thing right so if if if it's not
180:10 - existing then we return false otherwise
180:12 - return
180:13 - true uh read read read read read where
180:15 - is read what's going on here
180:19 - like this should be fine uh where is
180:23 - read
180:25 - here so we're going to do a read stream
180:27 - is this one we're going to say that the
180:28 - pad key is uh transform fun with the key
180:32 - and then we're going to say read me the
180:33 - full pad that's not true we're going to
180:34 - say that the pad key uh with root is
180:38 - going to be an fmts actually what we
180:40 - could do is um it's
180:43 - fine I mean we could we could make these
180:45 - things like I said in an application you
180:47 - can keep making things even better and
180:49 - better and easier to to use but
180:52 - hey uh percentage s/ percentage s and
180:55 - it's going to be the S root and then
180:57 - with the bad
180:59 - key like this and then we could say open
181:01 - me the pad key with root
181:05 - right is
181:15 - that I think it's going to be the full p
181:18 - with root to be
181:26 - honest it's going to be a reading that
181:28 - should actually work I
181:31 - think it
181:37 - isn't I see what's going on what's it
181:40 - doing
181:46 - here oh yeah I do the key that's
181:49 - crazy uh full Pat
181:57 - right yeah so we have written um 14
182:01 - bytes to dis that's
182:05 - fine the question is why don't we do we
182:07 - print that out we
182:10 - don't we could we could try right you
182:12 - could try if if you're actually reading
182:14 - this thing uh print f
182:18 - yeah it's gonna it's it's it's working
182:19 - fine because we say want F so that's
182:21 - fine right but hey if you want to see it
182:23 - on the screen we could do string
182:25 - B uh and run this thing again what's
182:27 - going on here print F you could CH print
182:30 - alen uh and do this boom some gpeg bite
182:35 - working working as
182:38 - intended that's good and then we're
182:39 - going to say delete key the question is
182:41 - is is this going to work probably not we
182:43 - we need to do some changes so let's open
182:46 - up delete it's above here so we're going
182:48 - to say uh pad key pad key the file
182:53 - name but we're going to remove the first
182:56 - pad name that's
182:58 - actually that's fine right so we could
183:01 - say first pad
183:03 - name uh with
183:06 - root which is going to be an fmts print
183:10 - uh F same Shenanigans percent s/ percent
183:14 - s and it's going to be the S root and
183:17 - the pad key
183:19 - uh
183:20 - first pad let's just type it out instead
183:23 - of typ hint then and then we're going to
183:25 - delete uh everything inside this we're
183:27 - going to say the
183:28 - first bad name and let's type it out
183:32 - again with root sometimes it's fine to
183:34 - not rely on your typ
183:36 - hinting I'm so
183:38 - sorry spell
183:41 - Rusty and I'm going to delete this
183:48 - the question is what what what is it
183:49 - going to delete it's going to delete the
183:50 - whole shebang uh let's see right so we
183:53 - have this thing I'm going to do run
183:55 - test it's hey look at this it's working
183:58 - perfectly
184:00 - fine yes that's already a good start
184:03 - sometimes things go like it should
184:09 - be that's great that's clean that's
184:11 - clean that's clean Let's uh do we need
184:12 - to have something else we have delete
184:14 - has has has has
184:15 - has has key
184:20 - where is
184:21 - Hy a hasy
184:24 - h uh we're going to do this uh transform
184:27 - Funk we're going to see if the stat to
184:29 - the full
184:33 - pad uh I need to say full pad with root
184:36 - right uh full pad with
184:41 - root and that's going to be again again
184:43 - I know I know uh s print F uh percentage
184:48 - s/ percentage s is going to be S uh
184:52 - roots and the pad
184:54 - [Music]
184:56 - key uh it's going to be the full pad I
184:58 - guess
184:59 - yeah so a function actually is
185:03 - it yeah yeah yeah and I'm going to say
185:07 - that the full pad with root is going to
185:09 - be this how do we test this has
185:13 - thingy that's delete um
185:23 - well let's just test everything in
185:28 - uh let's do it here right you could say
185:31 - um
185:32 - if
185:36 - okay s
185:39 - has uh the
185:41 - key and it's okay it's not okay actually
185:44 - what we uh what we're going to do is
185:46 - this right
185:48 - actually no if it's not okay it should
185:50 - have it right so we could say if not
185:52 - okay and we could say the
185:55 - errors
185:57 - F uh you could say expect
186:00 - it to have
186:05 - key
186:10 - key
186:12 - noise
186:14 - man sometimes and like I said this chair
186:18 - I need a new chair it's my back hurts
186:20 - everything
186:22 - hurts it's just a simple uh living
186:25 - living room chair you know where you
186:27 - just eat and and dip and dip them but
186:29 - I'm sitting here for for hours and hours
186:32 - it's it's crazy and I'm an old man and I
186:35 - need to have a I don't
186:39 - know so yeah uh this is this is nice
186:43 - what I'm going to do is real quick I'm
186:44 - going to say get at and then I'm going
186:45 - to do a get uh command
186:48 - M uh added roots to the
186:55 - store maybe going to say added root
187:00 - option to maybe store
187:04 - Ops like this Gucci
187:07 - Gucci and once again for the people that
187:09 - are uh
187:11 - patreons thank you for the support of
187:13 - course like usual thank you thank you
187:15 - very much if you're not in the Discord
187:17 - uh DM me or or DM me on patreon or
187:20 - something and I will give you the
187:22 - correct role in Discord right you get a
187:23 - better role so we have our private you
187:25 - can join the private channels uh where
187:27 - I'm basically continue continue helping
187:29 - people out right um so do that let me
187:33 - know if you are
187:34 - not if you don't have the correct uh
187:36 - role yet and I will happy to give you an
187:40 - exclusive status the stat of the status
187:42 - of the high value engineer software
187:45 - engineer which you are or you're going
187:48 - to
187:51 - become yes so that's
187:54 - fine what do we need
187:56 - more actually what I want to do in these
187:59 - um in these tests actually is make maybe
188:03 - make a tier down or maybe make uh some
188:06 - helper functions for example uh we could
188:08 - say new actually new
188:11 - store we're going to say testing do we
188:13 - need a
188:15 - testing I don't think we need actually
188:18 - [Music]
188:22 - um yeah we going to we going to some
188:25 - helper functions for us test it it will
188:27 - it will make uh our life easier what's
188:29 - going on here a
188:31 - store uh we could say return
188:37 - actually let's do this copy this
188:50 - do we want a
188:54 - root we don't want to I think GG is fine
188:57 - G G network is fine the default one so
188:59 - we're going to make our cast uh
189:01 - transform
189:02 - thingy and then we can actually just uh
189:05 - return this new
189:08 - store let's make a function uh it's
189:10 - going to be tear
189:15 - down and what do we want with tear down
189:17 - actually
189:24 - H
189:29 - um do we want testing T I think testing
189:33 - T and maybe the store
189:35 - itself not quite sure
189:43 - actually wait in a we need to delete
189:46 - everything
189:49 - do I have coffee actually yes lucky well
189:53 - this is basically a once in a lifetime
189:54 - opportunity that I have
189:57 - coffee available when
190:00 - I when I didn't expect it so we're going
190:03 - to do a tear down
190:05 - function how can we actually remove uh
190:07 - the whole She
190:13 - Bang uh I think we could do something
190:15 - like if R is going to be OS where do we
190:17 - do this uh remove
190:22 - all actually we should make a function
190:25 - like uh for example F
190:27 - store and then the store one then I
190:29 - think the store is basically complete we
190:31 - can store things we maybe need to come
190:32 - back to add or cash and everything but
190:34 - hey the next thing is to couple this on
190:36 - a on
190:38 - a on our Network so we can store things
190:40 - and then distributed that's that's the
190:44 - that's where the magic is going to
190:45 - happen uh but this needs to happen also
190:46 - right so we're going to a clear function
190:48 - right not quite sure what it's going to
190:49 - do will probably return an
190:52 - error uh we're going to
190:56 - say remove all and I think we could do
191:00 - something like s
191:01 - root uh and actually do return isn't
191:04 - that amazing is that a
191:10 - thing uh if add is going to be as
191:14 - clear and the error is not n
191:18 - and we going to actually D
191:22 - error s is that a
191:25 - thing let's let's try this real quick
191:29 - um so we don't need the stuff what we
191:32 - could say here is basically
191:33 - say s is going to be a new
191:39 - store like this
191:48 - and we going to say defer as tear down
191:50 - clear clear clear no tear down tear
191:54 - down help
191:57 - tear down
192:00 - DS is that a thing I'm not sure let's
192:05 - try yes you see now GG network is
192:08 - completely gone and now we can keep
192:10 - running these tests right okay of course
192:11 - it's it's it's getting cashed right it's
192:13 - getting cashed uh maybe we going to make
192:15 - a new key Fu and bar uh it's getting
192:19 - cached so let's change this so the cach
192:21 - can be busted here you see and
192:24 - everything is working perfectly fine and
192:26 - we don't have any relics in our folders
192:28 - uh from the test which is nice uh and
192:31 - the reason why we pass tear down in test
192:33 - uh where we pass testing. TNT damage
192:35 - basically so because clear can return an
192:38 - eror and then we can assert it and uh
192:39 - it's all fine and to be honest we could
192:43 - move these the shenanigans completely at
192:45 - the bottom of the file and because
192:47 - they're just helpers
192:49 - right so how do we need to test actually
192:52 - a little bit better this uh test store
192:54 - what we could do is
192:57 - um we could do we could do this right we
192:59 - could make a for Loop and we place
193:02 - everything in this for Loop right oh I'm
193:06 - I'm I'm itching what is this Fu and bar
193:09 - thingy wait wait wait wait I made a
193:11 - mistake I
193:13 - guess uh so this is a for Loop for Loop
193:16 - for Loop
193:20 - we're writing these
193:22 - btes where is our
193:26 - key we don't have a key what the hell is
193:28 - going on okay key is gone but it's no
193:30 - problem uh because we're going to make a
193:32 - new key we're going to say that the
193:33 - key is going to be
193:36 - fmts uh print F and that's going to
193:42 - be let's make this Fu underscore uh d
193:48 - which is going to be the Y right so we
193:50 - have count was count how many times we
193:52 - going to do this you can test this uh 50
193:55 - times right then we're going to make
193:58 - some data we're going to say some geg
194:00 - bytes we could make some function for
194:01 - random bites but hey doesn't really
194:03 - matters
194:09 - uh I'm going to make a new key does it
194:12 - matter actually that we have a different
194:13 - file size I don't think
194:15 - so so now we can actually do this uh
194:17 - completely the same time you're going to
194:18 - write to dis 50
194:21 - times and
194:23 - um with different
194:26 - Keys you see and it's it's it's all
194:28 - different keys right here 14 bytes I
194:34 - know what's going on here stop vs
194:39 - code yeah
194:40 - fine and we have no relics in our folder
194:43 - which is fine
194:48 - so we're basically testing uh writing
194:50 - we're testing has we're testing read and
194:51 - we're testing delete at the same time
194:54 - but if we delete
194:58 - um we need to assert we need to make our
195:01 - test pinpoint precise right pinpoint
195:03 - perfect we're going to say uh a not nil
195:07 - and we going to T error uh this error
195:10 - that we returning and then we need to
195:12 - say to make this actually perfectly fine
195:15 - then we need to try to see if we have a
195:18 - key um and then we're going to say if
195:20 - it's okay right if we have the key
195:23 - expect it to not have that key right
195:26 - because we just deleted every 10 right
195:28 - uh and we're going to do this 50 times
195:30 - so that basically means we're testing
195:31 - every
195:32 - 10 uh we have so we don't need to test
195:35 - this delete because we already testing
195:38 - this and we don't need yeah that's fine
195:40 - test store a new store tear down I think
195:42 - this is perfectly fine we're testing in
195:44 - one test we're testing the whole She
195:45 - Bang 50 times with different
195:47 - keys so we could do make test is going
195:50 - to fail because we have um an error in
195:52 - in in our uh TCP at somewhere so test
195:55 - that's failing boom right and I think
195:58 - the tests are are perfectly working yes
196:03 - Gucci do we have in our make file
196:08 - actually we have verbos on I'm going to
196:10 - delete verbos in make file so if we test
196:12 - make test right then we don't oh yeah
196:15 - it's printing anyway
196:20 - my ask see why
196:25 - it's make R yeah I see I see
196:29 - uh make t
196:33 - actually anyway uh why why actually why
196:35 - is it failing it's uh in peer top what
196:37 - what's going on uh TCP transport test or
196:40 - something
196:47 - what's going on help help
196:51 - yeah what's going on here uh don't test
196:54 - this it's going to that's working fine
196:56 - who why do we have tests we have
196:58 - transport test
197:00 - handshake store
197:05 - test why is it
197:11 - failing that's that's insane make test
197:13 - what's going on fail
197:20 - ah it's the pad transform thing that's
197:21 - feeling that's weird that's
197:23 - weird um that's that's weird store
197:29 - test this this is failing you see uh we
197:32 - want
197:35 - this
197:39 - who this is the exact same thing what's
197:42 - going on here
198:05 - um
198:10 - wait if the pat name and file name is
198:13 - not the expected uh file name
198:19 - wait wait wait wait wait wait wait
198:20 - what's going on here what's going on
198:22 - here
198:24 - half wait let in N vs code we can
198:27 - actually hover my mouse is broken you
198:30 - see if you hover this then you see on
198:32 - the other side that it's basically
198:34 - mimicking the
198:35 - same you see it's the same thing so we
198:38 - have this but we want this but it's the
198:41 - same
198:42 - thing so store test is going to be
198:47 - why why are we doing this not
198:57 - equal it's 19 line number 19 what's
199:01 - going
199:02 - on it's this one uh if the pat name file
199:05 - name the pad key file name is not the
199:07 - expected file
199:10 - name but they are the exacted file name
199:25 - wait this is not correct right because
199:27 - they
199:36 - expected the pat key file name that's
199:38 - not this one right the file name is the
199:40 - expected original key
199:48 - this is expected file
199:51 - name this is the expected file name and
199:54 - this is the expected path name right so
199:57 - this should be equal and the file name
199:59 - should be uh the expected
200:02 - um file
200:04 - name right and I'm going to say here uh
200:07 - expected uh file
200:09 - name that should be right all
200:13 - right I remember that we that we changed
200:15 - some stuff up so that could that could
200:17 - be the
200:20 - issue uh
200:35 - okay yeah I think I think this is fine
200:39 - so we can write stuff we can read stuff
200:41 - we can delete stuff we can clear the
200:43 - whole shebang we can test if we have a
200:45 - key I think this is uh a very good start
200:49 - to swap back to our
200:53 - um
200:58 - server this SW back to our server and
201:00 - then we can attach this storage
201:03 - there store a file and then we going to
201:06 - basically replicate it to to to all our
201:09 - other uh notes in the network and we're
201:11 - going to do some encryption and we're
201:13 - going to see uh what what we need to do
201:15 - so hey we at a good part somebody from
201:17 - the community uh noticed something um
201:20 - not quite sure if you remember but we
201:21 - had this uh weird warning on uh eror is
201:25 - somewhere I think in has in the has
201:30 - key yeah here uh although the warning is
201:33 - is is uh already fixed uh I think we can
201:36 - make this even better right instead of
201:38 - doing error is and check if it's false
201:40 - blah blah blah we can actually uh do
201:42 - this and return this directly what's
201:46 - going on like this
201:47 - right uh actually return this like this
201:51 - and that should work perfectly fine
201:52 - let's do make run test actually yes
201:55 - perfectly
201:56 - fine the next thing I also want to do is
201:59 - make uh an exposure of uh the right
202:02 - stream because we have this right stream
202:04 - here and I want to expose this as a
202:06 - private uh function so we're going to
202:08 - say instead of making this
202:11 - uh because I think we're gonna we're
202:13 - gonna do some more stuff in it uh later
202:16 - on
202:17 - but for now I'm going to expose it as a
202:19 - simple
202:20 - right uh store we're going to just say
202:24 - write which will take in a key which is
202:26 - a string and also take in an IO
202:28 - reader we will return an error and then
202:31 - we can actually just say uh return me as
202:35 - right
202:36 - stream with the
202:38 - key what's going on here key and R like
202:43 - this and it will all work fine the next
202:45 - thing I want to do is start creating our
202:47 - server uh new
202:49 - file we could call it file server or
202:51 - server I don't think it really matters
202:55 - um let's call it server package main
203:00 - rather we're going to say a
203:02 - type server which is going to be a
203:06 - structure we're going to have uh wait
203:09 - let's make some options
203:11 - right server options it's going to be a
203:14 - strict also we need a listen
203:18 - Adder uh for our transport right uh
203:21 - because we need to embed our peer
203:22 - to-peer lip into the server thingy so we
203:24 - going to
203:27 - say let's call it file
203:33 - server file server UPS let's now there's
203:35 - going to be a string we also need a pack
203:38 - uh a storage rout
203:40 - Right Storage
203:42 - root it's going to be a string also and
203:45 - of course some uh we also need a private
203:47 - key and and all that
203:49 - stuff um not quite sure we need to
203:51 - implement
203:53 - that because we going to encrypt right
203:55 - we're going to encrypt uh probably uh
203:57 - some some stuff or maybe an encryption
203:59 - key doesn't need to be a private key we
204:02 - will see we will
204:05 - see storage root uh file server
204:13 - um h
204:18 - we can say file server opt right
204:21 - here new file
204:27 - server it's going to return a file
204:29 - server we could actually say something
204:30 - like uh return and file
204:33 - server I we need a store that's that's
204:36 - what we need a store which is going to
204:37 - be a pointer to this
204:40 - thing store we just created right and
204:43 - then we going to say that the store
204:46 - is going to be I think a new store if I
204:48 - remember
204:54 - correctly it's going to be the file
204:57 - server Ops and then we could say here
205:00 - that it's going to be the
205:02 - opt storage
205:11 - route what's going on in new store
205:13 - actually what's going on uh store
205:20 - pad transform fun that's the
205:25 - thing uh are we goingon to yeah yeah
205:27 - yeah I see I see see see see see so what
205:31 - a I think we
205:37 - should it's going to be a pad transform
205:39 - thing to be
205:41 - honest because we need to we need to
205:43 - pipe in we need to aggregate all these
205:46 - options I
205:53 - think uh yeah
206:01 - yeah we can no no no I see I see what's
206:03 - going on I see what is going
206:08 - on uh I think this going to be the store
206:11 - Ops we need to make the store Ops right
206:12 - it's going to be a
206:13 - store Ops
206:18 - like this and then we're going to
206:20 - say at the storage
206:23 - route is going to be Ops storage
206:27 - route and the bad transform fun is going
206:30 - to be the Ops bad transform fun
206:36 - right it's not going to be it's going to
206:38 - be the root here I that I think yeah
206:40 - yeah yeah and then we're going to inject
206:42 - these stor
206:44 - Ops into this uh new St stingy that's
206:48 - fine and of course we're going
206:50 - to the file server Ops going to be the
206:53 - Ops
206:56 - here and then we need something like a
206:58 - function run uh it's going to
207:01 - be we could say FS but uh s is fine I'm
207:05 - going to say file
207:06 - server Ops it's going to be a
207:09 - run or maybe start actually don't like
207:15 - run let's put it higher on the
207:22 - screen I think we also need a uh TCP
207:25 - transport which is going to be a
207:26 - transport I think it's going to be an
207:29 - interface we could say
207:35 - transport going to be a peer-to-peer
207:37 - transport is that in the
207:43 - configuration all right so how do we run
207:45 - this transport by the way
207:53 - um right we only have this interface
207:56 - only to listen and
208:03 - accept
208:14 - um where is listen and accept
208:18 - it returns an
208:24 - error so we already know that start can
208:26 - return this error and we could say that
208:29 - uh if R is going to be
208:31 - S
208:33 - transport uh listen and
208:36 - accept and the error is not going to be
208:38 - nil here then we going to return the
208:42 - errors right away
208:47 - is this
208:48 - blocking it
208:51 - isn't so it's going to start this accept
208:53 - Loop which is
209:01 - fine which is perfectly fine uh let's
209:04 - let's do quickly return null let's go to
209:07 - main to see how we can uh make this work
209:10 - all right so we have this TCP transport
209:12 - Ops right the question rather is are we
209:14 - going to pipe everything into file
209:16 - server options probably we
209:21 - do because we're going to configure this
209:24 - complete server which then will spread
209:26 - out this configuration to the other ones
209:28 - I think that's the way to go so we're
209:30 - going to have a
209:34 - transport uh or maybe we can just say
209:37 - that the transport options
209:46 - it's TCP transport options that's nasty
210:00 - because
210:10 - Yik uh TCP transport Ops
210:19 - uh transport Ops like this
210:25 - right um
210:27 - yes this be transport UPS that's a
210:34 - f wa I'm thinking right so then we need
210:37 - to specify
210:47 - actually no no no no no no no no no no
210:49 - no no no no no no we're not going to do
210:51 - this uh we're going to say transport and
210:53 - we're going to yeah I see look what
210:55 - we're going to do uh let's clear
210:57 - everything here on
210:59 - peer let's let's that's what we need we
211:02 - need an on PE but we're going to say
211:03 - like this we're going to say that the fs
211:05 - no let's say s because otherwise we can
211:08 - um it's going to be a new server file
211:11 - server by the way uh we need to take
211:13 - options we're going to say the F uh s
211:19 - file server options it's going to
211:23 - be it's going to be a file server
211:25 - options right what do we need we need a
211:27 - listen address which is going to be
211:28 - let's say the classic one 3,000 one of
211:30 - my favorite ports at all
211:33 - times uh the storage route we're going
211:35 - to say storage root is going to be it's
211:36 - pretty important because we're going to
211:37 - say 3,000
211:41 - of files the
211:44 - reason or Network I don't know man uh
211:47 - the reason why we're going to do this
211:48 - because we're going to boot up multiple
211:50 - notes right to see if they are um
211:53 - replicating their their their state
211:55 - right because everybody needs to have
211:57 - that that uh that
211:58 - thing everybody needs to have the
212:00 - storage the same the terministic storage
212:02 - uh so we can make 3,000 Network 4,000
212:05 - Network and all that stuff so we can see
212:07 - that otherwise it will store everything
212:08 - on our on our disc right if it makes a
212:11 - lot of sense uh then we're going to say
212:12 - the pad transform fun we're going to say
212:14 - it's just going to be a gas a default
212:16 - one we can make as much as we want but
212:18 - we already have a cast and I like it you
212:20 - can Implement whatever you want it does
212:22 - not need to be exactly that uh content
212:24 - addressable
212:26 - storage uh and then we're going to say
212:28 - transport right so the transport is
212:29 - going to be a TCP transport and we can
212:31 - make it like this we could say TCP
212:34 - transport is going to be a peer-to-peer
212:38 - new a TCP
212:41 - transport like this and we need to give
212:43 - it up so we're going to say TCP
212:45 - transport
212:47 - actually well man it's fine we're going
212:49 - to say TCP transport
212:51 - Ops and it's going to be a peer-to-peer
212:56 - TCP
212:58 - Ops what do we need let me open up TCP
213:01 - the other side real quick for the
213:04 - options uh transport Ops we
213:07 - need handshake
213:09 - Funk
213:13 - decoder and on P
213:17 - I don't like to specify all that
213:21 - Shenanigans I think we need to have some
213:22 - defaults do we have
213:27 - that do we check
213:34 - that decoder decode
213:38 - um damn damn damn damn
213:41 - damn do we have decoding and
213:44 - coding I hope the yeah I see a
213:49 - c uh not quite sure let's say uh listen
213:52 - add is
213:54 - actually so we don't need a listen
213:56 - address
214:03 - here man this is going to be nasty
214:07 - listen we don't need
214:10 - this back to TCP
214:14 - transport options we need a handshake
214:17 - Funk we can we do no uh peer to peer I
214:21 - saw it already Yes a not handshake fun
214:23 - because we for now we don't need one and
214:26 - then we going to say the Cod you see how
214:27 - how cool it is that we can actually
214:29 - control all these
214:31 - things uh of course we only need to
214:33 - specify it once but it's nice to have
214:34 - these interfaces and these functions so
214:36 - we can make our program uh much more
214:38 - generic and
214:41 - testable although this decoder is also
214:43 - an interface but we're going to say this
214:44 - is going to be a p to
214:46 - Pi we oh we have a default decoder look
214:48 - at this man man man we are literally
214:51 - gods look at this we have a default
214:53 - decoder and then an onp
214:57 - function we need that onp function but
214:59 - not for
215:00 - now uh we could say to do uh oner Funk
215:05 - like this and then we can say it's going
215:08 - to be the TCP transport
215:10 - Ops that's our TCP transport and then we
215:12 - can say in our transport which is going
215:14 - to be an interface but TCP transport
215:16 - implements that we could do this then we
215:18 - say file server opts and then we say
215:22 - s
215:23 - start going to return an error so we
215:25 - could say if uh f is going to be this
215:28 - starty
215:29 - thingy and the error is not nil uh we
215:32 - can
215:33 - actually uh I let's just look fail out
215:36 - here because it's just testing you're
215:38 - just architecting
215:41 - stuff uh of course if you make run I
215:43 - think uh the problem is with make run
215:45 - that that we will We let's block here
215:47 - real quick uh like
215:54 - this okay the problem is we don't see
215:56 - anything happening so I think we should
215:58 - have some default and the birds are
216:01 - basically eating breadcrumbs outside
216:03 - it's nice to
216:05 - see but they are distracting me because
216:08 - they're with a lot uh so some logging I
216:10 - think in transport uh wouldn't be too
216:12 - bad right here we're going to say go
216:14 - accept and we could here do a simple
216:16 - login actually maybe a log or something
216:18 - uh print
216:20 - Ln or NF actually you could say
216:25 - um uh TCP
216:30 - server actually transport maybe DCP
216:33 - transport listening actually listen uh
216:36 - listening on Port and then we could
216:40 - say uh percent s and then maybe a new
216:43 - line actually and then we're going to
216:44 - say here
216:46 - uh T listen add listen listen add
216:52 - yeah uh because this is uh yeah yeah
216:55 - it's
217:01 - fine
217:02 - M you see so TCP transport listening on
217:05 - Port 3000 all good all set
217:09 - up um and I wish I could this this
217:12 - terminal on Windows basically you see
217:14 - that the difference between my fonts
217:15 - size and uh this terminal uh font size
217:19 - is is is
217:21 - different and I
217:23 - already looked it up and I I have this
217:26 - uh settings zoom
217:31 - level where is zoom level
217:36 - Zoom I think it's in in my other
217:38 - settings uh but I I'm going to plan re
217:42 - remake my config and actually uh Drive
217:45 - vs code to the Limit because you can you
217:47 - can basically do everything in vs code
217:49 - right you can hook into everything I'm
217:51 - goingon to make it completely uh myself
217:54 - completely minimalistic even more um
217:57 - performant as it is uh on my side so I
218:01 - will share that just just a side just a
218:04 - side I know this is forever store but
218:06 - hey I have no friends let me talk to you
218:10 - I cannot explain this to my girlfriend
218:11 - because she doesn't understand so
218:12 - talking to you you understand what I
218:14 - mean so that's nice all right let's go
218:18 - so yeah everything is
218:25 - running uh I want to
218:37 - uh that's our
218:43 - server so it's all fine wait I'm
218:45 - thinking uh we could do a couple things
218:48 - we could make this with with an HTTP
218:50 - which is fine but I'm going to make this
218:52 - as a terminal app right so we have our
218:54 - terminal and then we can basically
218:58 - um run it and then we can ex uh execute
219:01 - commands or something with it right we
219:03 - can execute commands with
219:04 - it and we can add files to the terminal
219:08 - and and replicate it store FM I don't
219:10 - know uh we can do a couple things but
219:13 - I'm thinking what the next step is
219:16 - do we need the Pierce we probably need
219:23 - them
219:30 - um let me quickly think about this to be
219:36 - honest how are we going to do
219:42 - this I think we should actually find a
219:45 - way to encrypt these files which is
219:47 - going to be a simple
219:50 - encryption that's going to be
219:52 - fine that's uh for another
219:56 - episode uh let's go to servers real
219:59 - quick so how are we going to use this we
220:00 - have our file server which basically
220:02 - will boot up and now we need to find a
220:04 - way to command this
220:08 - ST which could be directly no we can't
220:15 - the thing is file server right now and
220:18 - bet
220:22 - store but do we want to store a bet file
220:27 - server we don't so actually we give
220:30 - commands to the server right so we could
220:33 - say which does not mean that it needs to
220:35 - be over HTTP it could be we could say f
220:38 - file
220:40 - server uh file server you're going to
220:43 - say store
220:45 - or
220:47 - something store file I think store is
220:55 - good key
221:00 - string uh what how do we want to do this
221:02 - do we want to store bytes
221:24 - let me do this uh
221:30 - return s store
221:33 - right and we going to say key with the
221:36 - reader the thing is
221:48 - what we could do is basically have a
221:49 - channel for this
221:52 - thing a Channel with a
221:55 - reader and I probably should uh think
221:58 - thought about this a little bit more
221:59 - before I started this video I'm going to
222:01 - do this
222:02 - because otherwise we are losing a lot of
222:07 - time so just to to share my my thinking
222:11 - process here we have a storage which is
222:14 - just a simple
222:16 - thing that can store files on disk based
222:18 - on a transform fun and everything right
222:21 - then we're going to have a server and
222:22 - this is basically the server that will
222:24 - be running as a demon right and it will
222:29 - um
222:32 - receive me it it will receive messages
222:35 - it will um be in a distributed beer top
222:39 - Network so each if it's yeah I I I know
222:42 - I know I know I know I know what the
222:43 - next step is we need to have some
222:48 - um some messages to be honest instead of
222:51 - doing this
222:52 - store I know I know what the next step
222:54 - is my bad my bad so what we need to do
222:57 - is uh this server needs to
223:01 - have a
223:04 - loop going to be
223:07 - S uh file
223:11 - server was this file server up start
223:13 - this is not uh
223:19 - we're going to make a
223:22 - loop you're going to make a for select
223:24 - Lo by the
223:37 - way let's make it uh a quit Channel real
223:41 - quick quit channel is going to be a chen
223:44 - uh with
223:46 - only
223:48 - actually going to be a Channel of an
223:50 - empty strict like
223:55 - this I'm going to make a
224:02 - channel is that no we don't need to do
224:04 - this uh that's only when we actually
224:06 - want to close
224:08 - that and of course we're going to say
224:10 - case and I think we could do
224:17 - S
224:22 - transport don't we have that it's this
224:25 - right transport DCP transport what's
224:28 - going
224:41 - on transport yeah it's transport it's as
224:43 - transport
224:46 - uh it's consume I think that's the
224:49 - thing can we do
224:54 - this let's print the L real quick this
224:58 - message we made an error what's going on
225:01 - with this message expect it we we made a
225:04 - little mistake I guess and I
225:10 - cannot find where it
225:13 - is what's going on
225:17 - unexpected default unexpected case uh
225:25 - 36 oh yeah we need is it case man hey
225:28 - what am I doing what am I
225:31 - doing wake up uh FM
225:36 - fmt wake up my
225:39 - man yeah yeah it's yeah I know I know
225:41 - but we also going to have a case quitch
225:43 - and everything we going to say
225:46 - uh like this right I'm going to say Cas
225:50 - s you could return here
225:54 - whatever we could break here I like to
225:57 - break uh maybe we can do some defer
226:00 - functions here right defer so if we
226:03 - return that we can execute that defer
226:05 - functions or we can use um another loop
226:09 - and then we can break this other loop
226:10 - and then do do do our Shenanigans here
226:13 - or logic everything is fine nothing is
226:16 - wrong um it's it's what you what you
226:19 - want right how you how you want to do it
226:21 - it's going on why
226:23 - yes so we have the squit CH I think some
226:25 - some something what I'm always doing is
226:27 - uh make this squid function here uh wait
226:30 - this is Loop we can say
226:33 - funk as uh file
226:39 - server uh quit or stop
226:45 - I don't know maybe stop or
226:46 - something uh and then we could do
226:48 - something like um we could do this close
226:51 - s quitchen
227:01 - right all right uh so we have this Loop
227:05 - where are we going to loop I
227:07 - think at run right start you could say
227:11 - go actually we can block right we can
227:13 - block at start or we don't block at
227:14 - start that's a question are we going to
227:16 - I think it's always a good idea to block
227:19 - and then give the opportunity to the
227:20 - user to call this in a go
227:24 - routine because then he will have a quit
227:26 - Channel if he
227:29 - wants he can quit it if he wants
227:36 - uh yeah
227:43 - maybe yeah let's let's let's
227:47 - block for now not quite sure right and
227:50 - then we can do this
227:53 - right yeah so it's all fine it's Block
227:55 - in uh that's good that's good that's
227:57 - good and actually we could
228:00 - do
228:03 - um we can start it here and we can say
228:06 - go
228:07 - Funk like
228:10 - this and then we could say uh time sleep
228:15 - time
228:17 - second times I don't know 3 seconds or
228:20 - let's say three seconds and then we
228:22 - could say uh s
228:25 - quit like this stop actually what the
228:28 - hell s stop
228:32 - right is that a
228:36 - thing like this
228:40 - right not quite is going to work
228:43 - perfectly fine I think so
228:45 - yeah you see uh it stopped right because
228:47 - we we we closed our quit
228:49 - Channel um but there
228:52 - is we can actually do it like
228:57 - here and see that's why maybe let's
228:59 - let's do something different let's let's
229:00 - make it a defer fun here uh for that
229:03 - shenanigans
229:27 - uh user create action I don't know
229:31 - um files stop due to user quit action
229:34 - the the thing is because sometimes it
229:36 - can stop for for another reason I don't
229:38 - know maybe we can just uh do this do we
229:41 - need to close
229:43 - something I think we could we could
229:45 - clean something up uh maybe the
229:47 - transport I don't think we have a close
229:49 - thingy right in our transport you see we
229:52 - have uh listen accept and consume maybe
229:54 - what we need to have is something uh in
229:56 - our TCP
229:58 - actually let me open up TCP transport
230:01 - because it could be that we need to stop
230:02 - something right we have a listener
230:04 - right you see we have a listener so I
230:07 - think a good thing to have in our
230:10 - transport interface is a
230:12 - close right
230:15 - let's return an error because uh close
230:17 - and an error is always good and then we
230:19 - can go to TCP transport because we don't
230:21 - implement this we could
230:24 - say uh Funk D DCP
230:28 - transport
230:32 - close and we could say uh return T
230:40 - listener
230:42 - close do we need something else
230:46 - to close list listen what am I doing
230:49 - listener
230:55 - right transport
230:59 - interface look at this boys
231:01 - girls we are doing good stuff right so
231:04 - that's what I was saying in the
231:05 - beginning like okay we have this
231:06 - transport interface but we don't know
231:08 - yet what types of functions is going to
231:11 - be exposed what is going to be what's
231:13 - going to be needed although I don't want
231:15 - to have a a a whole complete Chang list
231:18 - of of uh interf uh functions on that
231:22 - interface because that's not a good
231:23 - practice then we can uh do do some uh
231:26 - composability uh if we want but I think
231:29 - what do we have now uh let let's open up
231:31 - transport real quick to check I think
231:33 - three functions I think three or four is
231:34 - the
231:40 - maximum I think
231:46 - maybe may I don't know three four five
231:48 - Max
231:50 - right uh so we can
231:54 - do we close stop we we and then here we
231:58 - do quit and then we have our defer fun
232:00 - we could say S transport close
232:03 - right like
232:08 - this and maybe we need to do more
232:10 - cleanup and ntcb transport like the p
232:12 - and everything that we will see make run
232:15 - and let's see if everything is going to
232:16 - be fine no errors or
232:18 - something okay we have because we say
232:20 - use of close network
232:23 - connection um that's fine we can fix
232:26 - that new incom connection yeah it's
232:28 - because we close that stuff we're going
232:31 - to say TCP
232:41 - transport because this is this keeps
232:43 - running right this keeps raining so
232:44 - that's bad so what we're going to do is
232:46 - uh we're going to accept here so if it's
232:48 - closed it's fine ah I see yeah yeah yeah
232:51 - so we're going to close it here right
232:54 - and then we say this and then we're
232:55 - going to handle yeah yeah yeah I see
232:56 - what's going on
233:01 - uh I think we need to do something like
233:03 - this right if we because we're closing
233:05 - it this listener I think it's fine but
233:07 - we're going to say
233:09 - here uh if errors once again uh if
233:13 - errors is
233:15 - is R is going to be I think it's um net
233:20 - R
233:26 - closed
233:36 - yeah you're going to return this
233:37 - function right
233:48 - that should that should actually fix fix
233:50 - your thing I think right so then then
233:52 - everything is nice and and and tidy
233:53 - cleaned up file serice stop to user
233:56 - interaction that's fine you see we don't
233:58 - have any errors it's uh The Listener is
234:00 - is being cleaned up we we uh fetch the
234:03 - error because yeah I think it's
234:05 - everything is fine uh what we need to do
234:07 - later is to see if we have if we have
234:09 - peers or something what how we going to
234:11 - clean that up right um because each Pier
234:13 - is a con connection and
234:16 - and right it's going to be he right uh
234:19 - so we need to check that later on if we
234:21 - have connections how we going to fix
234:25 - that yeah so I
234:29 - think uh I think in the next episode
234:31 - what we're going to do is
234:36 - basically try to
234:39 - connect and exchange messages so we can
234:42 - uh if if one stores
234:45 - we're going to try to connect with each
234:46 - other and then if one is
234:48 - storing uh we're going to have a list of
234:50 - bootstrap notes right that's always
234:52 - important that you have a list of bootp
234:53 - notes so we can connect to two or three
234:56 - people and then these people are going
234:57 - to give us their peers and and at the
234:59 - certain point of time we're going to
235:00 - connect to whatever uh maximum
235:02 - connections of 20 different notes or
235:03 - maybe 100 whatever we can configure um
235:07 - so they basically gossip and do peerc
235:09 - Discovery right but to make it simple in
235:11 - the beginning we're just going to have a
235:12 - simple list of of pred find boep noes
235:15 - we're going to connect to them and if we
235:16 - store a file uh we're going to broadcast
235:19 - that file to everybody else right uh
235:21 - that's what we we going to achieve in
235:23 - the next thingies then we're going to do
235:25 - some encryption and we're going to make
235:26 - it better and better and better right
235:28 - all right all right let's continue uh
235:30 - what I think is going to be episode
235:32 - eight of um forever store and
235:37 - um the previous episode I think uh well
235:40 - I think I'm pretty sure because I just
235:41 - made it uh we basically created or our
235:44 - file server uh and now we need to I want
235:47 - to connect a couple servers together uh
235:50 - or at least
235:51 - two and I
235:53 - think uh what we need in uh the file
235:56 - server Ops is basically a list of
235:58 - bootstrap nodes right uh boot TR noes
236:00 - which going to be a slice of
236:06 - string and what we're going to do
236:09 - then is basically if we
236:19 - start we could do a listen and accept
236:23 - and
236:24 - then um we could make a function
236:27 - actually you could say
236:30 - uh like this is going to be the file
236:34 - server
236:37 - bootstrap
236:39 - Network I think it's going to be a thir
236:41 - eror because uh it could be and then we
236:43 - could save 4
236:47 - S not quite sure what it's going to be I
236:49 - think it's uh
236:52 - adder in s bootstrap
236:57 - noes range
237:04 - actually what is that let me quickly see
237:06 - uh y string okay cool sometimes I I I
237:08 - switch these guys up with uh with each
237:12 - other uh and then we need to do
237:13 - something like S
237:15 - transport dial right that's what we need
237:18 - to
237:20 - do uh and we don't have a dial
237:29 - right let's return n here real quick uh
237:32 - what we're going to do in our TCP
237:34 - transport actually here I'm going to
237:37 - make a dial
237:38 - function and then we're going to dial an
237:40 - address actually a
237:42 - string going to return an error
237:45 - right so if you go to TCP transport we
237:48 - can make this dial
237:52 - function we have consume close yada yada
237:55 - yada let's make it here it doesn't
237:57 - really matter uh T it's going to be TCP
237:59 - p no
238:00 - transport
238:02 - dial add
238:05 - string
238:08 - error and we could say that the
238:10 - connection uh and an arrow is basically
238:12 - net dial which is going to be be
238:15 - TCP the added man my hands are itchy
238:18 - what's going
238:20 - on random random stuff if there is an
238:23 - error of course we're going to
238:25 - return uh return null now we have a
238:29 - connection so what we need to do is
238:31 - actually create a peer I
238:33 - guess because right here in uh start
238:37 - Loop handle
238:41 - come we can do handle come
238:48 - is
238:50 - it uh we can do handle
239:00 - con but we see that it's outbound so we
239:03 - could
239:04 - say in handle
239:07 - con uh we could say is this outbound
239:18 - like this here
239:19 - right and this is start accept Loop so
239:22 - this basically outbound is going to
239:24 - be what that be
239:29 - true we're accepting so it's not an
239:31 - outbound
239:32 - right going to be
239:35 - false and I think we could do
239:39 - here uh go T handle con
239:44 - which is going to be the
239:46 - connection and this is going to be true
239:48 - right this going to be an outbound comp
239:49 - because we're going to dial and we're
239:52 - going to return null
239:55 - here does it make sense uh I think so
239:59 - dial uh
240:02 - implements the transport
240:07 - interace always I'm always after all
240:11 - these years I'm not sure do we need to
240:12 - do a punctuation after our comments yes
240:15 - or no I have no clue right
240:18 - because some people do it and some
240:20 - people don't and the question is what is
240:22 - the correct thing is there a correct
240:24 - thing what do you think let me know let
240:25 - me know in the comments I'm I'm
240:28 - curious um although this is basically
240:30 - nothing we need to discuss to be honest
240:32 - because it's basically it doesn't really
240:33 - matter but still sometimes that question
240:36 - raise UPS uh in my mind so let me know
240:38 - what you think about it
240:40 - right let me know and it's up to you you
240:43 - can choose it's all fine for
240:48 - me uh what is going on with this I'm
240:50 - going to mute my output volume of
240:53 - the of my audio
240:59 - captured yeah that's uh not quite sure
241:02 - if the volume if the volume guys let me
241:03 - also know if the volume is fine I have
241:05 - no clue what's going on let me know uh
241:08 - if the volume is good or bad
241:11 - right uh all right so we have this dial
241:14 - right can we do this so we're going to
241:16 - say here if
241:17 - a is going to be actually we can dial
241:21 - them uh in a go
241:25 - way we can say go frun here
241:31 - right uh like this uh and I think we
241:34 - need to do we need to do other string we
241:36 - will see what what the what the thing is
241:37 - telling us uh vs code what Al is going
241:40 - to tell
241:41 - us uh S transport
241:47 - you're going to dial the
241:50 - address uh this is just for logging
241:52 - purposes because
241:58 - um actually it's a good a good question
242:01 - to be honest are we basically going to
242:04 - this is returning an error although we
242:05 - cannot return because we're doing it in
242:06 - a go
242:08 - routine
242:10 - uh let's just print this right let's
242:13 - let's just print is
242:20 - out why not okay you see this is
242:23 - basically already the the error we have
242:25 - here right uh the warning so it need to
242:26 - be an add switch is a string and then me
242:28 - say
242:30 - Adder all right that's what we're going
242:32 - to do we're going to bootstrap the whole
242:33 - sh bang and we're going to do that in
242:35 - start right um
242:48 - I'm thinking uh we are looping but we're
242:50 - also put uping the
242:58 - network I have no
243:03 - clue let us see let us
243:07 - experiment yeah we're closing the server
243:09 - here
243:11 - yada y yada uh so transport options is
243:14 - here we're going to say that the
243:16 - bootstrap do we have this in transport
243:18 - no it's not in transport
243:21 - options actually are we do no I don't
243:24 - think transport is going to be
243:25 - responsible for for dialing um well it's
243:28 - responsible for dialing but not
243:29 - responsible to to do Shenanigans with
243:32 - the with
243:35 - the with the bootstrap thing that's
243:37 - something we we need to take care of
243:39 - ourselves uh it's going to be here bootp
243:41 - notes and we're going to make a list of
243:42 - a of a string
243:44 - and I think uh what we're going to do
243:46 - here is basically um let's do 4,000
243:49 - although we are not connected right I'm
243:51 - going to see what eror is it throwing at
243:58 - us
244:03 - yeah
244:08 - nothing what's going on
244:11 - here are we calling this yeah right
244:29 - let me quickly do
244:36 - this how's it going on
244:44 - what is going
244:46 - on we don't do anything here
244:57 - um what's it going on here going to say
245:00 - uh
245:06 - bootstrapping not work man what's going
245:10 - on I'm I'm confused because I'm thinking
245:11 - already uh a step further
245:14 - and I cannot do two things at the same
245:15 - time what uping the N that's fine
245:19 - right it should return as a n or at
245:22 - least Panic
245:26 - though what's going on
245:30 - here who's network it's all fine I think
245:34 - the problem is that we don't have any of
245:35 - these um
245:57 - yeah you're going to say
246:11 - attempting attempting to C connect with
246:14 - this guy uh and then we're going to say
246:16 - transport dial the address and if they
246:18 - we're going to panic so it's probably
246:20 - something in TCP transport
246:34 - then so there is no
246:41 - error uh that's crazy
246:52 - um what the hell is
247:02 - this what is going on
247:12 - here are recalling start yeah recall
247:14 - start
247:16 - right uh and why is this uh maybe we
247:19 - stopped maybe it's basically it's trying
247:21 - to dial and dialing timeout as basically
247:24 - uh longer than three seconds that could
247:26 - be that could be nasty if it's so we're
247:28 - going to stop quitting the server we're
247:31 - going to just wait what's going
247:37 - on look at
247:41 - this I see uh maybe no no we can't do
247:45 - that right we can do
247:48 - that we could do Local Host but this is
247:50 - going to be fine we don't get any
247:54 - erors what is going
248:06 - on H
248:15 - connection fuse right so returning an
248:18 - error right if ER is not n return an
248:19 - error we dial this
248:26 - here because start is
248:37 - maybe what is going on
248:48 - see we don't get any eror not no
248:52 - Panic I time to connect with the
249:07 - remote banic heat who who what
249:19 - maybe I made some stupid mistake and you
249:21 - guys already can see
249:23 - it but I cannot see
249:26 - it after the panic
249:47 - man I'm I'm literally confused I'm not
249:49 - going to lie I'm I'm I'm totally stuck
249:51 - here
249:54 - um it's not executing Hispanic if a is
249:58 - transport
250:00 - dial the
250:03 - adders and the add is not nil
250:29 - wait turnill oh my
250:33 - goodness oh my
250:36 - goodness
250:38 - oh I could easily it's 15 minutes in I
250:41 - could easily
250:44 - remake this video right that's 15
250:46 - minutes I just delete my code get reset
250:48 - hard and go back and and do it if
250:50 - everything is fine that I'm basically a
250:52 - God and don't make mistakes with this
250:54 - I'm going to leave this in I'm not going
250:56 - to redo it it uh oh man look at
250:59 - this oh and I didn't see it and you guys
251:02 - probably saw this oh man I'm I'm going
251:05 - to leave this in this is this is
251:07 - actually too too too funny uh to delete
251:10 - oh man oh
251:13 - it's actually smiling because it's it's
251:15 - I thought what the hell is going on this
251:16 - makes no sense uh okay cool uh man man
251:20 - man man man after the Panic
251:28 - everything okay what's going on it's
251:30 - still not doing anything okay that's
251:32 - because
251:35 - um wait uh so we dial this thing and if
251:39 - the error is not nail we're going to
251:40 - return the error and dial here
251:44 - uh which actually should
251:53 - Panic what is
252:00 - this it's anel Anthony please can
252:05 - you can you stop doing the
252:08 - shenanigans for once in your life all
252:11 - right what the hell I'm going to leave
252:12 - this in
252:13 - uh it's it's just too ridiculous okay
252:15 - cool this is fine uh so we're going to
252:16 - print this error here and we can
252:18 - actually return this uh yeah let's let's
252:20 - let's do not go routine this so we can
252:22 - actually have an but do we care if we
252:25 - don't want to actually guys I don't
252:27 - think it actually matters here uh I
252:29 - think we're going
252:31 - to I think we're going to break no
252:33 - continue actually if this guy is not uh
252:36 - dialing and then what we're going to say
252:38 - is basically do the G Funk
252:41 - anyway here
252:45 - I'm going to do the gunk
252:48 - anyway okay we cannot
252:50 - continue why
252:57 - not oh yeah see I see of course we
252:59 - cannot it's another thing it's fine it's
253:02 - fine oh guys what is this uh we're going
253:04 - to print this thing
253:06 - yeah now we need to sh we block are we
253:08 - blocking are we blocking I think we
253:09 - blocking make Run Okay so uh the
253:12 - connection refused that's fine no big of
253:14 - a deal it's good right uh so what we're
253:18 - going to do
253:19 - is oh man it's too funny uh what you
253:21 - want to do is make a function here
253:23 - actually I'm going to make it a
253:24 - top make uh a
253:27 - server uh I think you're going to set
253:29 - the listen adders here real quick listen
253:31 - Adder which is going to be a string and
253:34 - actually what I'm going to do is also
253:36 - the root which is going to be a string
253:38 - here and it's going to return as a file
253:40 - server and maybe an error I don't know
253:44 - this is actually just a convenient
253:46 - function uh to to testing right uh so
253:48 - we're going to do all the shenanigans
253:49 - here uh copy the whole She Bang paste it
253:52 - in here right and then we're going to
253:54 - say that we're going to take the Liston
253:55 - address
253:57 - here uh all the same all the same all
253:59 - the
254:02 - same uh we could do something nasty uh
254:06 - we could say listen addage plus uh this
254:11 - right uh bootstrap notes is going to
254:13 - [Music]
254:20 - be we cannot do this actually uh we're
254:22 - going to
254:24 - say uh
254:26 - string root and then notes it's going to
254:30 - be a slice of string
254:34 - right uh yeah like
254:39 - this actually
254:44 - I'm going to do it like
254:46 - this uh
254:50 - string wait it's going to be this
255:00 - right can I do this actually probably we
255:03 - can it's fine now we have the server and
255:06 - we can actually return a new file server
255:08 - here do
255:09 - we yeah why
255:11 - not return a new file server
255:15 - and then we can say something like uh
255:18 - that leaded this this whole
255:20 - thingy and we could say
255:26 - um S1 is going to
255:30 - be make server
255:32 - actually uh make server he going to
255:35 - listen at 3,000 uh what's this the root
255:39 - is going to be actually we do the root
255:41 - itself
255:46 - so we don't need to
255:48 - root yeah it's
255:52 - fine uh now we going to say boot step
255:54 - notes uh that's going to be 4,000 the
255:56 - problem is um actually it's not going to
255:59 - have one doesn't matter because if there
256:02 - are none we're not going to connect
256:03 - which is fine then we going to say s one
256:07 - start maybe an
256:10 - error actually could we do
256:13 - we can't because we need to run this in
256:15 - a in a separate
256:19 - thing like this
256:21 - right and maybe we could
256:31 - do is it going to is it not going to
256:33 - format this for me what's going
256:35 - on uh the reason why I want to do this
256:37 - in a function is because then we can
256:38 - actually catch we can do this right lock
256:41 - uh fatal
256:43 - this is that a
256:46 - thing I think it
256:50 - is yeah it's
256:54 - fine uh we're also going to make a
256:56 - server
256:57 - two which is going to be this guy 4,000
257:00 - right and then we're going to say that
257:01 - the bootp note is going to be 3,000
257:03 - right which is easy and then we're going
257:05 - to say here as to
257:08 - start like here it's going
257:10 - on and that will actually uh boot up
257:13 - these two notes I think I think not
257:14 - quite
257:20 - sure yeah it's working the only thing we
257:23 - need to fix is uh transport listening
257:25 - yeah yeah yeah attempting to connect
257:26 - with remote
257:27 - 3000 uh TB trans listening on Port 3000
257:30 - attempting to connect with remote that's
257:32 - because we have no bootp noes what we
257:34 - could do is basically uh
257:39 - if uh can are we going to do this here I
257:41 - think we could do it here right you
257:42 - could say uh if the length of um s
257:47 - bootstrap notes is
257:52 - zero and maybe we have an empty
257:59 - string maybe we have an empty string
258:01 - that could also be the case to be
258:06 - honest yeah it's an empty string that's
258:09 - nasty probably because we do it like
258:11 - that uh
258:15 - um although the check is good what we
258:17 - could do here is basically uh
258:20 - if L Adder equals
258:25 - zero uh we could say continue
258:32 - actually see perfectly fine uh so we do
258:36 - this stings it's fine we have a
258:38 - logging do we actually want that date
258:40 - I'm not sure maybe we going to make a
258:42 - prefix
258:44 - uh in some sense we could that later um
258:46 - TP transport listening yes yes yes we
258:48 - have a new incoming
258:51 - connection that's
258:57 - fine uh new incom atcp transport I guess
259:00 - new incoming connection I don't like the
259:01 - way it doesn't tell us anything
259:20 - okay uh that's all good all good so what
259:23 - we going to do do we have a sent in the
259:25 - spear wait let let's first things first
259:27 - let's make our
259:37 - server uh
259:43 - it's going to be a map string uh as
259:45 - going to be
259:47 - appear appear to P like
259:50 - this uh I want to have a sync
259:54 - mutex wait let me
260:00 - do uh P
260:03 - lock is a Sy mutex
260:08 - right uh p is going to be make me a map
260:14 - string uh point no no no pointers PE
260:17 - like this is fine it's going to be a
260:19 - peerto peer
260:20 - peer yes yes yes um we could also do
260:25 - some some mechanic where we add peers
260:27 - and delete peers based on a
260:30 - channel but
260:32 - um yeah I don't want to over engineer
260:35 - channels you know it's it's I did I did
260:37 - this in my blockchain series I did this
260:40 - in I think in the ex I did this
260:42 - everywhere this ADP with his channels
260:44 - I'm not going to do it this
260:47 - time because why
260:49 - not why not a mutex it's not going to do
260:52 - anything it's not that it's a performant
260:53 - action adding a pis is just I don't know
260:56 - it doesn't matter it doesn't
261:03 - matter now we need to add P Funk right
261:13 - uh
261:14 - Funk file server on peer it's actually
261:18 - nice to test our own peer-to-peer lip uh
261:20 - maybe we should actually make one uh but
261:23 - actually open source one but a good one
261:26 - and I think for now it's it's working
261:28 - fine we have on peer uh which is
261:30 - basically where
261:33 - is dial list and accept close
261:37 - uh no on P is basically just um
261:48 - where is on coming from it's just a TCP
261:51 - transport thing right on PE doesn't
261:58 - matter the thing is should this be
262:00 - should that be in an interface where the
262:02 - transport needs to call on pier each
262:04 - time it has a peer
262:06 - actually actually maybe this needs to be
262:09 - in our
262:11 - um of course it needs to be
262:14 - because uh no because it's TCP transport
262:19 - Ops Next Level right or not next level
262:23 - or complete garbage it's either one of
262:25 - two it's binary right there either an
262:27 - Next Level move or it's either just
262:30 - complete dog there is no in between
262:32 - and the weird part is that I have no
262:34 - clue what it is um because you know what
262:37 - you could say yeah but transport needs
262:39 - on peer right because uh each transport
262:41 - will have a Pier which is an interface
262:44 - and each time it's connected the
262:45 - transport can call on
262:48 - peer which then everybody in everybody
262:52 - has that transport interface can call on
262:54 - p on it and and Y
262:58 - yada that's not true I think this is the
263:00 - best option uh where where we have just
263:02 - have an onp which is a generic function
263:05 - which is also generic right it's not
263:07 - something that's hard it's genetic
263:08 - function um this actually crazy because
263:12 - TCP transport Ops and we do on peer
263:15 - which in my opinion should not take a
263:17 - peer but a TCP Pier to be
263:20 - honest uh yeah I think that's the thing
263:23 - maybe we going to change
263:27 - that let me know what you think about
263:29 - this uh I think it's fine because now
263:32 - what we can do I think is uh where is
263:34 - our uh onp
263:37 - thingy and that's what I love to do the
263:39 - most man is the making these things it's
263:41 - it's insane I like it
263:43 - uh and once we have a good lip a good
263:45 - P2P lip we can use it in all of our
263:47 - projects right it's a lot of boiler
263:49 - plate all the
263:51 - time uh so we have on peer which will
263:53 - basically takes a p which is going to be
263:55 - a TCP
263:59 - Pier but that's nasty actually we could
264:02 - say p it doesn't
264:04 - matter uh so this G be compatible with
264:07 - everything later
264:09 - on something we need to think about and
264:11 - an error right because uh this takes an
264:15 - appear oh
264:20 - wait actually I think I'm going to keep
264:22 - it uh this
264:25 - way because I'm going to keep it PE
264:27 - because why because
264:31 - um this will make it compartible for
264:33 - other transports this
264:39 - onp because we have this P yeah yeah
264:42 - yeah yeah yeah yeah yeah because then we
264:46 - can call on p on each trans because now
264:48 - it's only TCP transport but it could be
264:50 - that we have uh web soet transport uh
264:53 - UDP uh whatever you want to grpc
264:56 - whatever so and every and and and and
265:00 - that's why we have this genetic peer
265:01 - thingy right this could be this could be
265:03 - a peer over over uh TCP could be a peer
265:06 - over UDP so this all peer can work on
265:09 - everything if we decided to if you or me
265:12 - me or whatever is going to use this
265:14 - decided to add other transports right
265:18 - okay so this debate is done the debate
265:20 - is
265:23 - closed and hey guys listen
265:27 - um if you have remarks or things you
265:31 - think hey why don't we do this or let's
265:33 - collaborate right I hey I'm open for
265:36 - everything I'm open for everything this
265:39 - is how I should do it but it's not this
265:42 - not this do
265:44 - not this does not mean that this is the
265:47 - best way it is a way it works for
265:50 - me but maybe something is better right
265:52 - we don't know and actually to know that
265:54 - we need to use it right that's why I'm
265:57 - I'm I'm going further and further and
265:58 - further because by using different stuff
266:01 - we know ah damn actually or a function
266:04 - we just implemented is not going to work
266:06 - after a couple days or something right
266:09 - uh and that's why you can make things
266:10 - better and better
266:12 - uh on P what we going to do with on P
266:15 - we're going to say
266:19 - s uh we're going to PE lock lock this
266:22 - thing and then we're going to say
266:23 - defer uh as per lock uh
266:28 - unlock unlock or boy and I'm we going to
266:30 - say as beers with uh how are we going to
266:33 - store this that's a good
266:36 - question it doesn't actually matter we
266:38 - could say
266:39 - p uh we cannot store this guy we need to
266:42 - have some more function in our in our uh
266:44 - interface speed interface right we only
266:46 - have P I think we need to have like
266:50 - um
266:54 - address or maybe we can make it
266:56 - compatible with uh with
266:59 - goine and we say remote adders uh which
267:02 - is going to return a
267:04 - string
267:08 - right and then DCP P close and I'm going
267:12 - to say funk
267:15 - P TCP p and then we could
267:19 - say remote
267:23 - adders string return BC remote adders
267:28 - Network we don't
267:33 - care ah I see it's uh it's uh are we
267:37 - going to do a net
267:38 - Adder why not let's make it compatible I
267:41 - mean
267:42 - if we make this uh more compatible with
267:44 - the go thing I think it's going to
267:47 - be uh I think it's going to be good
267:49 - right especially if you want to open
267:50 - source this peer to peer lip returning a
267:52 - net Adder think a lot of people
267:55 - appreciate that because to be
267:57 - honest uh let me go back to uh TCP P
268:02 - TCP TCP it's in in transport
268:08 - yeah uh and another thing is basically
268:10 - yeah why is TCP p in in in TCP transport
268:13 - and not in TCP package uh TCP file it
268:17 - doesn't matter right um I like to group
268:21 - things a lot of people like to split
268:23 - things out and make TCP the file with
268:26 - only 20 lines or something I think it
268:28 - doesn't make any sense uh but that's
268:30 - also a personal preference I don't
268:32 - matter I don't care I like to group
268:35 - things in one file because yeah I don't
268:38 - scroll through the files that much I
268:40 - just try to search for things and uh um
268:43 - I don't care if a file is 1 million
268:44 - lines or
268:46 - something 1 million is too much but hey
268:49 - you get the point right uh so remote
268:52 - Adder is basically let's say remote
268:55 - Adder uh
268:57 - implements
268:59 - implment the P
269:03 - interface and uh will return the
269:08 - remote actually and we'll return
269:13 - remote address of
269:15 - the uh underlying connection of the pier
269:20 - of it's underlying connection maybe of
269:24 - it's underlying
269:33 - connection all
269:36 - right that's fine so now back to here we
269:41 - could say s B and then say uh we could
269:44 - say remote
269:46 - Adder uh but we are using strings we
269:48 - could actually use uh remote adders
269:50 - ourself but we're going to say
269:52 - string like this
269:54 - right uh and then we're going to say
269:56 - it's going to be P right that's it and
269:58 - then I'm going to return all so
270:04 - yeah that's this and maybe going to
270:06 - we're going to do uh FM log or something
270:08 - I don't know log print
270:10 - Ln or
270:12 - f
270:22 - um connected with
270:29 - peer wait connected to it can we say
270:31 - addit p to the P map something connected
270:33 - to it uh remote which is going to be
270:36 - this and we can actually
270:37 - [Music]
270:40 - do B we can actually do something nice
270:43 - right because p is just a p i don't
270:45 - think we have a
270:53 - Stringer yeah we could Implement string
270:56 - yeah we're not going to do that we're
270:57 - not going to do
271:00 - that we can say a remote Adder because a
271:02 - remote Adder will uh it has a Stringer
271:04 - interface which is cool because I think
271:06 - if you go to remote
271:09 - Adder uh it's going to be a net Adder
271:11 - right you see see this implements a
271:15 - string do we want that to be implemented
271:18 - in our P I don't think so right I don't
271:21 - think so uh connected with the remote
271:23 - right let's see what's going on
271:25 - here uh are we doing wait wait wait
271:28 - first of all we have our on peer but of
271:29 - course we need to implement
271:31 - this
271:38 - into rtcp transport where are we where
271:40 - are we making this a you see the problem
271:44 - already let's go to main because we need
271:46 - to implement this this on PE we need to
271:47 - inject the pointer of this function into
271:50 - TCP transport right this onp you see
271:52 - it's going to be onp
271:55 - here uh so that basically means that
272:02 - we need to have our server
272:05 - first a
272:12 - uh can we
272:27 - do let me see what I can fix uh so the
272:31 - server is going to be this guy you're
272:34 - going to return the server here and then
272:36 - we're going to say that the onp
272:38 - transport onp is going to be the server
272:39 - onp
272:44 - uh so yeah is that going to
272:50 - work make
272:52 - run
272:56 - yeah so we have a new incoming
272:58 - connection from our TCP transport I
272:59 - don't think uh
273:02 - TCP we actually want
273:10 - that what's this new in connection yeah
273:12 - we don't want that actually that's
273:19 - loging connected with remote connect
273:21 - with remote so they both connected uh
273:23 - it's pretty fine actually maybe I
273:31 - um I was thinking maybe we want a string
273:34 - I don't know or maybe we don't so we can
273:37 - connect with each other that's fine the
273:39 - next thing we need to do is uh I think P
273:42 - has a scent function TCP P it's going to
273:44 - be a longer episode a little bit doesn't
273:45 - matter
273:48 - uh yeah so TCP P has this Con no no wait
273:52 - where is transport yeah P remote add
273:56 - close we also need a sent right we going
273:57 - to sent which will take in uh a slice of
274:00 - bytes and it's will returning an error
274:02 - that's what we're going to do uh very
274:05 - important and we're going to go to TCP
274:07 - TCP
274:08 - transport new TCP remote that close and
274:11 - all that stuff if we're going to write
274:12 - which is basically a very simple
274:14 - function uh we're going to say TCP pach
274:19 - uh
274:19 - sent uh
274:22 - bytes uh like this we're going to return
274:25 - an
274:25 - error yes and the only thing we're going
274:28 - to say is underscore R is going to be P
274:32 - com uh
274:36 - right right like this we're going to say
274:38 - B write the bytes and then we're going
274:40 - to return the eror
274:50 - um we could also just start this thing
274:52 - but I don't want to do that we are
274:54 - handling the read functions here which
274:55 - is
274:58 - fine yeah yeah
275:00 - yeah so and the next thing we're going
275:02 - to do basically is now that we have the
275:04 - scent function for our Pierce is um each
275:08 - time we want to store we're going to
275:09 - send that to to the other one
275:13 - is going to get that message a store
275:14 - message and then he's going to he's
275:15 - going to also replicate it so that's for
275:17 - the next it's going to be amazing I'm
275:18 - I'm actually thrilled to continue the
275:20 - previous episode I think we created our
275:22 - server right we created our server um
275:25 - which basically I think we also had
275:28 - something in
275:29 - main yes we created our server we have
275:31 - uh connected uh server one with server
275:34 - two let's uh make run real quick what's
275:36 - going
275:37 - on make run yeah so they're basically
275:40 - connected with each other uh which
275:42 - basically means that we can start
275:44 - sending files right uh of course we need
275:47 - to encrypt and all that stuff uh and
275:49 - another um major important thing is that
275:51 - we cannot for privacy reasons I don't
275:54 - think we can
275:56 - store uh wait I I will explain I will
275:59 - explain because we're also storing a key
276:01 - and it could be that our key would be
276:03 - for example uh my
276:06 - NES my
276:08 - NES which basically we don't want that
276:11 - that it's that key is being stored on uh
276:14 - on remote uh servers right so we want to
276:17 - basically store directly the the hash of
276:21 - the of the pad of the keypad of the pad
276:22 - key right uh but that's for later on um
276:26 - today we're going to do I think some
276:27 - some interesting stuff because we need
276:29 - to stream large files uh over over the
276:32 - network right so let's let's get started
276:36 - um yeah so let's open up main that's
276:40 - already here right uh let's let me put
276:42 - that a little bit
276:43 - higher so what we're going to do for
276:45 - example is uh let's say we have S server
276:48 - two is is being started right so what we
276:51 - could do is basically say something like
276:53 - S2 and we could say store file right
276:55 - something like this store
276:57 - file uh at a given uh key and then we're
277:01 - going to say
277:04 - um I don't know we could say that uh the
277:07 - contents the data it could be an I/O
277:12 - uh it's going to be a new reader
277:13 - actually not IO it's bytes right going
277:15 - to say it's going to be bytes new reader
277:17 - and it's going to be for example
277:20 - um my uh Big Data file here like this
277:26 - right and then we going to store this
277:28 - data here that's that's the thing and
277:31 - what's going to happen is uh let us go
277:33 - over to
277:35 - server
277:36 - um bootstrap Network
277:43 - yeah let's do it here right so we could
277:45 - say for example this going to be S uh
277:47 - it's is a file server right and we're
277:50 - going to say store data or store file uh
277:53 - anything right could be it could be
277:55 - legit anything it's a forever anything
277:57 - store
277:58 - right uh that's going to be we're going
278:00 - to store this at a certain key which is
278:02 - going to be a string right and we going
278:04 - to say uh it's going to be an R which is
278:06 - an iio reader and we going to error uh
278:09 - an error right that's the thing like
278:12 - this let's return
278:15 - n for now right so the first thing we
278:18 - need to do is basically first of all uh
278:21 - store this
278:22 - file to disk
278:25 - right then we need to basically
278:28 - broadcast um this file to the network
278:33 - right that's that's the thing to all
278:34 - peers actually uh store this file to all
278:39 - known peers in in the network right
278:42 - because it could be that we only know
278:43 - two peers but these P are going to
278:45 - broadcast it back so everybody uh is
278:47 - going to get that
278:49 - file that's the the the main goal of
278:52 - this and of course we need to encrypt
278:55 - that stuff right that's uh that's for
278:56 - sure that's for
278:58 - sure uh so how we going to do this is
279:01 - basically let's make a a simple
279:03 - broadcast function right so we can we
279:05 - can try to scolding this out let's say
279:08 - it's going to be broadcast
279:11 - uh and we want to
279:15 - broadcast a
279:17 - p now we want to broadcast a p which is
279:20 - going to be a payload and we're going to
279:21 - say
279:22 - error
279:23 - right so this payload uh is going to be
279:28 - a
279:29 - type is going to be a
279:32 - strict and this payload is going to have
279:35 - a key
279:36 - right because we we're going to send
279:39 - this file but the people need to know uh
279:42 - the receivers need to know the peers
279:44 - need to know which key is going to be
279:45 - stored of course for now we're going to
279:47 - just store the key like we it's going to
279:48 - be uh let's
279:50 - say uh let's go back to to main it's
279:52 - going to be the key for example
279:55 - uh
279:56 - my private data right that's going to be
279:59 - my key of course we don't want to store
280:03 - my private data as a key as plain text
280:05 - uh it could be we know that but the
280:08 - others cannot know that right of course
280:10 - it's not that big of a deal because
280:11 - everything is being encrypted but still
280:14 - right still privacy first that's very
280:18 - important so but for now we're going to
280:20 - just store it like this we're going to
280:22 - send it over like that and then later on
280:23 - we're going to we're going to just uh
280:26 - put the hash so actually maybe we should
280:28 - already put a hash anyway we will see so
280:31 - there's going to be a key which is going
280:32 - to be a string that's what we know right
280:34 - and then we're going to have um I don't
280:37 - know maybe the data and that's going to
280:40 - be a bite
280:42 - uh like this right it's going to be a
280:45 - bunch of
280:49 - bites
280:50 - so but we want to stream right we want
280:53 - to stream that bites because of course
280:54 - we need to copy this once but we don't
280:56 - want to copy this to uh you know what I
280:59 - mean we we want to stream this to all
281:02 - the peers because if we it's very
281:05 - important lesson actually uh if you go
281:07 - to PE TCP no um yeah TCP is fine right
281:13 - we have this sand function right you see
281:16 - here con right so it basically takes
281:18 - these bytes all the
281:19 - time uh they want to do that we want to
281:21 - basically stream uh the whole
281:22 - Shenanigans over the connections to all
281:25 - the peers at
281:28 - once some
281:30 - coffee so en able to do that we we going
281:33 - to refactor PE a little bit uh let me
281:37 - return nil here right so what we're
281:40 - gonna do
281:41 - is what I want to do here let's um make
281:45 - this more clear so in broadcast we could
281:48 - say for example 4ore
281:51 - Pier uh in Range s peers right then we
281:56 - could say for example uh let's read the
281:58 - btes here it's going to be for example
282:01 - uh B is going to
282:03 - be
282:06 - I uh read all and we going to
282:12 - actually the p is already bit right yeah
282:13 - yeah yeah no no no no what you could do
282:15 - is basically
282:16 - [Music]
282:20 - do make a buffer or something we going
282:23 - to be a new bites
282:26 - buffer like this and then we could say
282:29 - if at
282:34 - um it's going to be Hop new
282:38 - encoding new encoder and we're going to
282:41 - say uh the buffer because that's a
282:43 - writer and I'm we going to say encode
282:46 - the payload right and if the ER is not
282:51 - nil we can return the
282:53 - a right return the arrow
282:58 - here something like that uh what's going
283:01 - on with peach no no no it's not it's
283:02 - going to
283:08 - be yeah this is the buffer yeah yeah
283:10 - yeah and then what we could do uh so
283:12 - everything is in the buffer right now
283:14 - and then we could say for example uh P
283:19 - sent uh buff bites what's going on here
283:23 - uh
283:24 - buff bites like this right that's
283:27 - something we could do but I don't like
283:29 - that so what I want to do is basically
283:32 - delete this whole thing what I want to
283:34 - do is basically this I want to
283:36 - return um hop or actually any encoder we
283:41 - can make an interface for that uh new
283:45 - encoder and I want to basically
283:48 - encode directly to the Pier's connection
283:51 - but we don't have access to the peer
283:53 - connection and then we could say uh and
283:56 - code the payload
283:59 - right but then and then we can Loop to
284:02 - all the peers and do the same with one
284:03 - Pier if that makes sense so let's let's
284:07 - let's make this
284:09 - uh you're going to make this clean
284:11 - listen this going to be insanely
284:13 - good so in able to do this what I want
284:15 - to do is uh if you open up um transport
284:19 - right this Speer interface we have
284:21 - remote adder and all that stuff and we
284:24 - could say so we need the con here right
284:26 - we need the con of the PE to make this
284:28 - work right but uh it's a private
284:31 - variable so what we could say is make a
284:33 - function
284:36 - right like this make a function and say
284:38 - come here right which is going to be
284:41 - turn a NETCOM because a NETCOM uh is
284:43 - basically a reader and writer right
284:45 - that's what you could
284:47 - do uh why is it not working uh yeah of
284:50 - course because ccpp does not implement
284:52 - this but why are we doing this right
284:54 - what it can it can be even simpler so
284:56 - instead of doing this we can do
284:58 - interface embedding right uh we could
285:01 - say send can be here we could just do
285:03 - this right we could say net con just
285:06 - like
285:07 - that and then instead of saying con here
285:11 - we could just do Pier because p is
285:13 - already uh will have all these functions
285:15 - attached to it right so if you go to TCP
285:19 - peer uh instead of doing this remote
285:21 - added close stuff right we can delete
285:24 - all of
285:25 - this and it will it will be perfectly
285:28 - fine I guess because um yeah the only
285:31 - thing we need to do here is and instead
285:33 - of making this Con a variable we could
285:37 - just say uh net con here right
285:41 - just a NETCOM you could actually say uh
285:44 - that this is going to
285:46 - be uh the
285:50 - underlying uh
285:52 - connection of the
285:55 - p uh which in this
285:59 - case is a TCP connection
286:04 - right and instead of doing this we can
286:07 - as a private
286:09 - variable uh we could do this make come
286:12 - uh
286:13 - public right so what happens now is that
286:16 - the TCP P will instantly implement the
286:20 - as a netc it will be a netc it it
286:23 - implements all these functions so that
286:26 - means uh that we can use this directly
286:29 - as
286:35 - um as a as a as a as a as a writer or a
286:38 - reader right directly into this encoder
286:40 - of course p is payload here so not going
286:42 - to work but we could do for example this
286:44 - right uh for range p and
286:48 - uh S Pierce like this right uh we could
286:53 - do this we cannot return because it's
286:55 - going to be an issue you're going to say
286:57 - go new encoded P directly you see that
287:00 - works perfectly fine and then we could
287:01 - say if r y y uh is not
287:05 - n if the add is not then we can return
287:08 - the error right and in this case we're
287:10 - going to return n
287:12 - this will work
287:13 - fine but
287:15 - still what we could do is even uh
287:18 - something
287:20 - better and let's basically say that
287:22 - we're going to make uh
287:25 - Pierce and Pierce is going to be I want
287:27 - to stream this directly to all the peers
287:31 - like a streaming
287:32 - service so what we could do is say uh p
287:35 - is going to be a slice of Pier right any
287:39 - Pier uh is going to be a peer to PE peer
287:41 - actually peer to peer peer like this
287:44 - right then we going to
287:49 - Loop uh for actually this going to be
287:51 - Pierce yeah uh let's let's delete every
287:54 - 10 and then we're going to say Pierce is
287:56 - going to be append Pi Pier like this so
288:00 - we have a slice of
288:02 - Pi and then what we could do is um say
288:07 - that we have a multiwriter
288:09 - multi writer is going to be an
288:13 - IO multi writer actually and we're going
288:17 - to say it's going to be
288:21 - Pierce uh I think it's going to be this
288:23 - actually it's not going to work because
288:26 - uh multiwriter wants
288:28 - um you're going to say it's going to be
288:30 - IO
288:33 - writers right and that's going to work
288:35 - perfectly fine so this is very important
288:36 - to understand right so our P or TCP p or
288:41 - even p uh in
288:43 - general is an
288:45 - interface but P embeds the neton
288:48 - interface which basically
288:51 - um also implements the writer reader
288:54 - interfaces right this is this is a this
288:56 - is the peak of goang engineering I swear
289:00 - to God this is the peak of goang
289:02 - engineering so uh netcon also implements
289:05 - reader writer so what we could do is
289:06 - basically tell us that the slize of P
289:10 - can be as slice of iio writers which we
289:13 - can just append peers into it so we can
289:15 - then make a multiwriter of all the peers
289:19 - and then we could just return uh
289:23 - goop uh new encoder which is going to be
289:26 - the multiwriter and code me the whole
289:30 - payload and we're
289:33 - done that's nasty that's that's not
289:35 - nasty this basically insane I'm not
289:37 - going to lie um yeah
289:42 - I did this before um using the
289:44 - multiwriter and and we going to do some
289:46 - some some some cool stuff um yeah yeah
289:50 - yeah so that's it
289:53 - right that's cool what's going on in
289:56 - Mage yeah store file yeah yeah yeah we
289:59 - don't have store file right store data
290:01 - actually what's going
290:04 - on right my private
290:07 - data so it's now we already heing store
290:09 - data so this is It's is interesting
290:11 - because what's going to happen is that
290:14 - um we need to
290:17 - make this payload thing let me quickly
290:20 - delete this and paste it in here and we
290:23 - of course going to split things
290:25 - out so what you going to see is that the
290:30 - payload you're going to make a
290:32 - payload uh so the first thing we going
290:34 - to do is basically store this on disk
290:36 - and you can see that we're going to have
290:37 - some problems so we're going to say if f
290:41 - it's going to be s store uh
290:44 - write the file the key the reader if
290:48 - there is an
290:50 - error we going to return the error right
290:54 - so first of all we're going to store it
290:55 - to our own disk which basically means
290:59 - we're going to read from the
291:02 - reader but at this case here after we
291:06 - read the reader is empty right because
291:09 - there is already being red it's
291:11 - completely
291:12 - empty so what we need to do because we
291:15 - need to read it because we need to uh
291:17 - also send it back over the network
291:20 - right so what we're going to do is I
291:23 - think we're going to make a buffer which
291:25 - is going to be a
291:27 - new uh bytes and actually I can show you
291:31 - first let's let's let's do some
291:32 - demonstration what's going on so let's
291:34 - say
291:36 - um let's make the buffer yeah let's make
291:39 - the buffer we're gonna say it's going to
291:40 - be a bites buffer actually new buffer
291:43 - maybe it's going to be a new bites
291:47 - buffer right and then we're going to say
291:50 - IO
291:51 - copy we could say uh we don't care of
291:54 - this we're going to say the error is
291:55 - going to be IO copy which will basically
291:57 - do a streaming copy of reader and writer
291:59 - destination and source so we're going to
292:01 - say uh wait what's going on I think copy
292:04 - uh the first thing is the destination
292:06 - what's going on I cannot man nasty uh
292:09 - copy is destination
292:12 - right so the destination is going to be
292:14 - the buff right and the source is going
292:15 - to be the reader right uh I'm going to
292:18 - say if the error is not n you're going
292:21 - to return the error here right and then
292:23 - we going to say fmt
292:25 - print and print me The
292:29 - Buff uh
292:31 - bytes right so if we going to say here
292:38 - yeah if we run this
292:41 - wait of course we basically block here
292:44 - right so we cannot do anything here so
292:46 - we're going to say go and let's time
292:47 - sleep here so it it has time to boot up
292:50 - uh we going to say time
292:52 - sleep
292:53 - um let's say two seconds right maybe one
292:57 - actually
293:03 - yeah right so we're going to go start
293:05 - this thing right so we written to disk
293:07 - right that's fine we written to 22 bytes
293:09 - to dis but then we see that the buff
293:12 - even though we copied from the reader
293:14 - the buff is empty so if you want to send
293:16 - that
293:17 - buff because we're going to make a
293:19 - payload right we're going to say here
293:20 - this is going to be the the
293:22 - P which is going to be a
293:27 - payload and actually what I want uh this
293:30 - should be appointed to a payload because
293:31 - I don't want to copy the shenanigans
293:33 - into a function right because if you
293:35 - have large files so we're going to point
293:36 - to to the to the
293:38 - payload and then we're going to say that
293:39 - the key is going to be okay we need to
293:42 - have the pad key so we don't so we are
293:43 - sure we we don't expose the the the
293:45 - plain bytes of the key but yeah that's
293:47 - for later on so we're going to say it's
293:48 - going to be the key and then we going to
293:50 - say that the p uh the data right the
293:52 - data could be the both bites right
293:54 - that's what we're going to do both bites
293:57 - right and then we could say here um
294:00 - return as
294:02 - broadcast we're going to broadcast the
294:06 - payload that's what we're going to do
294:07 - right and then we're Gucci but the
294:09 - problem is
294:11 - that it's going to broadcast
294:13 - nothing right you can see this uh I
294:15 - think if you do make a
294:19 - run uh actually let's block here so we
294:22 - can see what
294:24 - um what the other site is going to
294:26 - receive uh make
294:29 - run you see it's getting it's getting
294:32 - this uh garbage thingy
294:35 - right wait let
294:38 - me let us let us make this real quick
294:41 - this is actually interesting guys this
294:42 - is so interesting you probably need to
294:44 - watch this a couple times to completely
294:46 - understand but this if you know this
294:47 - you're literally a God what's go if you
294:49 - can do this guys I swear to God uh this
294:51 - is years years years of experience and
294:53 - years of of figuring things out how
294:56 - things work this is nasty so this is
294:59 - transport print consume right so we're
295:00 - going to print out this message but what
295:02 - we're going to do is basically say that
295:04 - we're going to decode this into a
295:05 - payload so we're going to say uh p is
295:07 - going to
295:09 - be uh uh a payload or actually make it
295:13 - better
295:14 - p uh is going to be a payload right and
295:17 - then we're going to say
295:19 - if is going to be uh
295:23 - hop uh what's going on Hop new decoder
295:26 - right we going to
295:28 - decoder hands so called uh what are we
295:31 - going to
295:38 - decode uh we're going to make
295:43 - B new reader
295:45 - p no MSG payload actually we could make
295:49 - this into a reader directly from the
295:54 - T where are so so many things we can do
295:57 - not going to lie and I'm going to say uh
295:59 - decode me this uh thing
296:02 - into a payload can we make this a
296:05 - pointer I don't think it's going to
296:08 - work yeah it is
296:11 - uh if the is not n then we're going to
296:12 - basically log fatal out for now uh this
296:16 - error because actually we we we should
296:18 - not fatal out we
296:20 - could Loop
296:23 - right right this is what going to happen
296:25 - right let's let's make
296:32 - run wait uh what's going on spads
296:43 - I think it's just
296:53 - um
297:00 - uh wait fmt print LM let's say we're
297:03 - going to receive let's see if if if
297:05 - receive receive
297:15 - refuse going
297:19 - on uh yeah I think we need
297:24 - to who is
297:29 - dialing maybe we need to sleep
297:32 - here give this guys time to boot up
297:35 - before they connect
297:41 - yeah so we receive a message uh yeah
297:44 - yeah yeah yeah we receive a message cool
297:45 - cool cool cool yeah I forgot we need to
297:47 - do this I'm going to say print F right
297:49 - and uh we're going to say uh it's going
297:51 - to be a percentage plus v like this
297:54 - we're going to make a new line and we're
297:55 - going to say it's going to be the
297:56 - payload right uh so make let's make run
297:58 - this
298:03 - again you see so it's it's telling us
298:06 - the key so that's the first problem we
298:07 - have so this is this is being received
298:09 - on the other side right so we store to
298:11 - dis and we broadcast and this this this
298:13 - this uh this output is basically on the
298:16 - outer note of the network right and we
298:18 - already see it's my private data which
298:20 - is not good but hey we're going to fix
298:22 - that but you can see that the data is
298:24 - empty right that's a problem and that's
298:26 - because we already read from the reader
298:27 - can I not close this
298:29 - yeah so how we're going to fix this is
298:31 - we're going to do some nasty Nifty
298:33 - mechanics of course because we are the
298:35 - club of the high value Engineers high
298:37 - value software Engineers so what we're
298:39 - going to do is
298:44 - um here so what we're going to do is
298:47 - we're going to make this buff but we're
298:48 - not going to copy right what we're going
298:50 - to do is what's going on we're going to
298:52 - make this buffer then we're going to
298:53 - make uh a t which is going to be iot
298:57 - reader is it a new T reader no it's iot
299:01 - reader and um
299:18 - it writes it from
299:21 - yeah yeah yeah it writes so we're going
299:25 - to make the BFF Heat and the r e is that
299:26 - correct so we're going to read from
299:32 - um wait am I confusing
299:37 - this yes yeah yeah it's this it's going
299:39 - to read and it's going to write to
299:40 - buffer that's cool but we need to do
299:42 - this before we write this to the store
299:47 - right make the buffer
299:55 - here and then we have this t- reader
299:58 - right so what we're going to do is we're
300:00 - going to read we're going to write a t-
300:03 - reader and then we have the B bites
300:12 - boom We written to
300:14 - dis and we broadcasted it to
300:17 - everyone that's what we
300:20 - did
300:27 - so because uh if you don't believe
300:35 - me we going to see um B can we do B
300:44 - string actually uh B string is here yeah
300:47 - yeah what we're going to do is on the
300:48 - other side we're going to say story that
300:50 - we're going
300:51 - to we're going to we going to going to
300:53 - say this one
300:55 - um
300:56 - P let's do a
300:59 - string of P
301:03 - data and then make
301:08 - run let's go going on
301:11 - here unexpected end of
301:14 - file you see okay I think there there so
301:17 - much it's basically the sleep we need to
301:19 - make sure uh that it's okay because they
301:21 - are we will see so you see my big data
301:25 - file that's what we receive on the other
301:27 - site which is perfectly fine uh I see
301:30 - sometimes we have an issue I guess let
301:32 - me make run we will debug
301:34 - this yeah I think it's something to do
301:37 - with this connection with the time
301:38 - sleeps maybe second is not enough we
301:39 - will see we will
301:41 - see uh
301:43 - yes okay so the thing is uh this consume
301:47 - we're not going to make our our logic
301:48 - here right that's not that's not the
301:50 - best uh approach what we're going to do
301:51 - is
301:53 - basically um we're going
301:55 - to make a function we're going to say
301:58 - here s file
302:00 - server because we know we also need to
302:03 - store it on the on this right on the
302:04 - other side we're going to say
302:06 - handle message I guess
302:10 - uh handle message uh or handle payLo is
302:13 - may be a better
302:16 - thing it's going to be a p which is
302:18 - going to be a pointer to a payload like
302:21 - this and we going to say an
302:32 - error
302:38 - um I think the
302:45 - payloads wait I have an idea I think
302:47 - it's going to be handle
302:52 - message which needs to be a message
303:07 - actually how we can make this even
303:08 - better I'm thinking uh so we have a
303:10 - payload key string uh we could also make
303:12 - a message which is going to be sent over
303:14 - the wire uh so it's going to be a
303:18 - structure and we going to say that the
303:21 - uh man this is
303:26 - nasty uh maybe you should say
303:33 - from going to be a
303:35 - string and then we going to say uh that
303:37 - the payload of the message
303:42 - that could be any I think something like
303:45 - that because then we can actually
303:49 - uh and this is a payload I don't think
303:52 - it's going to
303:57 - be could make it as a data message which
304:00 - is going to be a key
304:03 - data uh so this is going to
304:07 - be going to be a data message right but
304:10 - then we need to make this into a message
304:11 - so we're going to
304:13 - say we going to
304:17 - broadcast we cannot we need to broadcast
304:19 - a
304:20 - message so we're going to say
304:27 - here a message and we're going to encode
304:29 - the message here right and then we're
304:32 - going to say uh broadcast uh a message
304:37 - and we need to make a Constructor we're
304:38 - going to do that later on and it's going
304:40 - to be
304:41 - from is going to
304:49 - be and we don't know the listen address
304:52 - that's
304:58 - crazy we don't have that that's maybe
305:01 - interesting what we need is the listen
305:03 - of the transport let's go to transport
305:04 - real quick dial listen and accept
305:07 - consume
305:13 - actually do we need that listen adds I
305:15 - think we need to be
305:20 - honest listen Adder which is just going
305:22 - to return the listen adders of the
305:23 - transport I think is that a
305:31 - thing because we make a new
305:35 - um file server but we don't Store The
305:38 - Liston address
305:42 - because we sto a transport here I
305:48 - see yeah so I think listen add is pretty
305:51 - fine for the transport
305:53 - interface TCP transport Let's uh make
305:56 - this real quick we're going to say funk
305:58 - uh
306:00 - P that's a p do a p we don't need that
306:03 - transport here here here here here Funk
306:07 - D let's put it higher
306:11 - it's going to be a
306:13 - TCP transport listen Adder it's going to
306:18 - return a
306:22 - string uh we're going to say a return
306:25 - the listen
306:27 - added we don't have this it's private I
306:34 - guess we
306:36 - don't what's going on
306:48 - what's going on
306:53 - here ah
307:01 - it's I see what's going
307:05 - on it's the same thing each how how we
307:08 - going to fix this
307:18 - um because we make the the transport uh
307:21 - the problem
307:23 - is in main you can see we make the
307:27 - transport we make the transport here and
307:29 - then we put that into uh
307:35 - yeah wait we going to fix that later on
307:38 - uh we're going to fix that later on
307:39 - where is where is uh transport interface
307:42 - because I don't like to have a listen
307:43 - address here to be
307:45 - honest so we're going to just uh do
307:47 - something
307:49 - nasty and we going to say from need to
307:51 - be
307:52 - too and we going to say that the
307:55 - data no it's going to be the payload of
307:57 - the message I guess yeah the payload is
308:00 - going to
308:01 - be B it's this data message here
308:15 - yeah and this is going to be done then
308:17 - we're going to say it's going to be a
308:19 - message all right and we're going to
308:22 - encode into a message instead of a
308:25 - payload uh because we can send other
308:27 - messages also right a message here oh
308:30 -  it's the same that's nasty uh let's
308:33 - say m
308:40 - uh payload like
308:45 - this it's any we need to switch this we
308:48 - need to switch this and then here we're
308:49 - going to say handle message which is
308:51 - going to be uh a message which is going
308:54 - to be a
308:55 - message we're going to return this
308:58 - actually we could check the error if R
309:00 - is going to be S handle the message
309:03 - which going to be the
309:06 - m n m n
309:10 - M and if the
309:13 - Eros uh is not
309:15 - nil we can uh lock yeah we need to print
309:19 - land these things
309:21 - actually
309:26 - uh right and then we we we call this
309:34 - function and what you're going to say
309:36 - here is basically uh switch
309:40 - MSG
309:43 - payload uh type going to be a v
309:50 - actually do this and we're going to say
309:52 - case if it's
309:56 - um if it's a data message right then we
310:00 - could say
310:01 - print
310:03 - actually can do it like this right we
310:05 - can actually say print
310:10 - is it print F we don't have that that's
310:12 - nasty let's do
310:13 - fmt print
310:15 - F I'm going to say received
310:20 - data uh plus V new line
310:26 - V uh let's return
310:32 - n is is going to work
310:39 - all right we we still have this
310:40 - unexpected end of file we need to fix
310:42 - out why figure out why this is happening
310:45 - we will see we will see normally it's
310:46 - going to work perfectly fine no it isn't
310:48 - uh wait wait wait wait wait wait wait
310:49 - what's going on what's going on what's
310:50 - going
310:59 - on so this data message is going to be
311:01 - the payload
311:12 - you're going to broadcast that message
311:15 - yeah uh key B and bites and then we
311:17 - going to say this
311:25 - from uh I don't think we need the from
311:27 - by the way but
311:36 - hey the end of file why do we have that
311:48 - um is it B
311:50 - bites and the message in broadcast and
311:52 - broadcast will actually uh
311:55 - basically hop and code the message
312:11 - I think it should work but I think we
312:16 - have let me quickly check what's going
312:18 - on here uh do we need to sleep longer I
312:20 - have no clue to be
312:31 - honest I don't think it's a problem to
312:33 - be honest guys but hey we can try we can
312:37 - try
312:44 - okay so we we Rite it that's the thing
312:46 - right so that's cool so if if you open
312:47 - up our thing that that's fine still have
312:50 - some issues I think you make a mistake
312:52 - uh my big data file here so that's
312:53 - perfectly fine in the 4,000 Network
312:55 - which is basically server two all
312:57 - working all working like intended uh
312:59 - just one more thing I want
313:01 - to what is this um as you can see the
313:05 - camera is at top right and I have the
313:07 - lunar Vim shenan go going on um I think
313:10 - it has a better
313:12 - terminal uh bigger fonts and everything
313:15 - so that's fine uh so let's make run and
313:17 - so we can continue where we left off
313:19 - right and I'm going to say the next
313:20 - couple of episodes going to be super
313:21 - super important we're going to do
313:23 - advanced stuff uh and I can swear to God
313:27 - that if you know these Concepts very
313:30 - well um you're going to be you're going
313:32 - to know more than everybody else I can
313:33 - swear if you if you get if you grab
313:36 - 10,000 go developers uh I think only
313:39 - handful will know how these things going
313:41 - to work so we see that we have disc
313:42 - corrupted data uh here right so
313:45 - basically uh that's
313:48 - because uh if you go to our decoder
313:50 - right you can see our decoder which is
313:52 - basically let's open up thisp I'm going
313:53 - to show you real quick normally you guys
313:55 - should know if you follow along uh the
313:56 - decoder is basically the staying in the
313:58 - read Loop where we decode a message
313:59 - right and uh what we do is we decode the
314:02 - prefixed set of bytes a pre-allocated
314:04 - slice of 1028 bytes and you can already
314:07 - imagine that this is perfectly for or
314:09 - normal messages but it's not suited
314:12 - for big files 4 GB 8 GB 10 GB that's
314:17 - that's impossible um it's already too
314:19 - small and uh upping the size will
314:22 - basically uh make every computer crash
314:25 - because most of the computers don't have
314:26 - so much RAM to work with so what we're
314:29 - going to do is we're going to
314:30 - stream uh we're going to stream data
314:33 - directly to a file right so we need to
314:35 - do some some changes for that
314:39 - so we have our server
314:41 - here the first thing we're going to do
314:43 - is we're going to we're going to delete
314:45 - some stuff test some stuff and then make
314:46 - it better so basically this data message
314:48 - we're going to delete this real quick uh
314:51 - this message is perfectly
314:54 - fine I'm going to everything in here I'm
314:56 - going to basically comment
315:00 - out
315:06 - um and the next thing we're going to do
315:08 - is basically Let's test something let's
315:10 - test something real quick I'm going to
315:11 - say
315:13 - um foror p in Range s p is going to be
315:19 - this we're going to say uh if R is going
315:22 - to be Pier
315:24 - sent uh some bytes which we don't have
315:27 - yet and then we're going to say um add
315:31 - not nil we're going to return the
315:34 - error here then uh let's let's make a
315:36 - simple message um
315:43 - going to say this is a message uh this
315:45 - is from are we actually going to use
315:47 - this I don't think we're going to use
315:49 - this message for by the way uh we're
315:51 - going to say that the payload is going
315:52 - to be a slice of bytes just to test this
315:55 - is just a test to give you a concept uh
315:58 - what's going on and why we need to do
315:59 - this it's very important to understand
316:02 - uh this is really really really
316:03 - important trust me
316:06 - um so we're going to say here for
316:08 - example uh um it's going to be the
316:10 - storage key for example we going to send
316:12 - the storage
316:14 - key simple
316:17 - thing then we going to actually encode
316:20 - this with G encoding going to say if R
316:22 - uh is
316:24 - uh uh new
316:27 - encoder and we going to say we need a
316:31 - buffer actually let's make a buffer real
316:32 - quick going to say buff is going to be a
316:35 - new byes buffer which is basically just
316:38 - exactly what it is buffer and we're
316:40 - going to encode that in the buffer
316:41 - because a buffer is a writer and a
316:42 - reader and then we're going to say
316:44 - encode and we're going to encode the
316:47 - message uh I don't know do we need a
316:49 - poter I don't think so and then we're
316:51 - going to say R is not n and we're going
316:53 - to return the r uh let me find the plus
316:57 - sign here what's going on like this
317:02 - perfectly fine so we're going to have a
317:05 - message we're going to send that over to
317:07 - all peers
317:10 - and then we're going to return n here
317:12 - real quick we're going to clean
317:13 - everything up trust trust
317:15 - trust and then we're going to see where
317:17 - we're going to fetch the message on the
317:18 - other side of the network on other notes
317:23 - right where do we do this it's here
317:25 - right so we're going to handle this
317:26 - message we're going to comment this
317:28 - out uh we're going to comment this
317:33 - out we're going to call this we're going
317:35 - to delete this this is going to be an
317:37 - RPC this is going to be an MSG we're
317:39 - going to say RPC is going to be RPC
317:42 - payloads we're going to decode the MSG
317:44 - like this and then we're going to say
317:46 - fmt uh print Ln or
317:50 - maybe print F actually I'm going to say
317:55 - receive um percentage s and we're going
317:59 - to make a string out of
318:01 - [Music]
318:03 - the MSG payloads and we're going to cost
318:06 - that to a slice of B Because payload is
318:08 - a um and we're going to make better
318:10 - messages this is just for testing a
318:12 - payload is an any type and we are
318:13 - sending bytes on the other side remember
318:15 - we made this um storage pad B thingy so
318:18 - we're going to cost that and we're going
318:19 - to print that
318:21 - out uh so let me quickly make a run this
318:24 - to see what's going on uh of course in
318:26 - the
318:27 - spear uh scent yes we need to put in the
318:32 - buff
318:33 - bytes just like
318:35 - that and we're going to say make run and
318:37 - see data message okay we have some
318:39 - relics uh left over message I'm going to
318:42 - search for these guys here one and then
318:46 - we
318:47 - have I think that's
318:50 - it let's zo make Run Okay so the the the
318:53 - thing is running that's fine okay so we
318:56 - received storage key so everything is
318:58 - working like intended right so but
319:01 - that's what we're going to do we are
319:03 - going to
319:04 - send a message type a specific message
319:08 - type it could be
319:09 - hey uh a message type
319:12 - store store file which will basically
319:15 - means uh we'll hold the key and um so we
319:19 - know oh the next thing we need to do is
319:22 - open up a stream because we're going to
319:25 - receive a file and we need to store it
319:26 - right that's what we're going to
319:30 - do with all complications that uh
319:32 - probably will
319:34 - arise so how we going to do this
319:37 - right so we're going to mimic a stream
319:39 - we're going to mimic a stream uh we're
319:41 - going to mock one here right so
319:44 - basically this
319:45 - one uh so we we sending this right what
319:48 - we're going to do is we're going to make
319:50 - a simple payload right and we're going
319:54 - to say this a SLI of bytes and we're
319:55 - going to say this large
319:59 - file right this is going to represent a
320:02 - large file which is clearly not but hey
320:05 - um
320:10 - what we're going to do
320:13 - then is we're going to again loop loop
320:15 - again to all the p and we're going to
320:17 - make this better it's just for for
320:18 - demonstration right so the first thing
320:20 - we do is we send the
320:23 - message describing what we're going to
320:25 - do storing retrieving blah blah blah so
320:28 - and then we're going to send a big file
320:30 - that's what we're going to mimic here so
320:32 - we sent the message and then we sent the
320:34 - big file which need to be streamed
320:37 - right uh um but you're not going to send
320:39 - the above bites we're going to send the
320:43 - payload
320:47 - right yes right that's what we're going
320:49 - to do so if we test
320:57 - this right you're going to get some
320:59 - issues uh and that's normally fine
321:01 - that's because
321:05 - um let's open up servers we are in by
321:08 - the
321:09 - way right
321:12 - [Music]
321:19 - um I think we already received this
321:21 - first
321:23 - right yeah it's this unexpected
321:27 - Shenanigans um so we received the
321:29 - storage key already which is fine but
321:31 - then something happens right uh so we're
321:33 - going to fix this real quick and
321:35 - actually what I want to do here is a new
321:36 - line right so what I want to do is in
321:40 - this case I basically want to read right
321:43 - so we first read a message and then
321:45 - we're g to open up the the file for the
321:48 - stream right so what we're going to do
321:56 - is
321:58 - um I'm going to make a
322:02 - buffer no we don't need to
322:09 - wait the first thing we going to do is
322:11 - we we cannot read here right it's very
322:13 - important and it can be some confusing
322:14 - I'm not going to lie uh but hey you can
322:16 - always jump in the Discord and ask
322:18 - questions so what you could do here is
322:20 - basically
322:25 - um we cannot read here right so well we
322:30 - are reading
322:32 - here but we always transferring this RPC
322:35 - message to the to our server that's the
322:37 - way we communicate
322:40 - but we need a way here
322:42 - to read from from the pier if that makes
322:46 - sense and the way we're going to do this
322:49 - is to fetch the peer first so we're
322:52 - going to say that the pier
322:54 - okay is and that's why we need to have
322:56 - this from address in in the RPC method
322:59 - right so we're going to say p okay is
323:01 - going to be S
323:04 - Pier RPC from right and we going to say
323:08 - f not
323:10 - okay and maybe I I'm going to quickly
323:13 - can we return another no let's Panic
323:15 - here because that's very important we
323:16 - have a p it's going to say no
323:18 - peer uh in PE
323:22 - map actually P not found
323:24 - maybe uh peer not
323:28 - found in the peer
323:32 - map right uh then we have a p here let
323:35 - let let us see if we if we can find a p
323:37 - if that if that's working fine uh let's
323:39 - say just be it's probably not going to
323:41 - format but it doesn't matter just for
323:43 - testing purposes real quick right uh RPC
323:46 - from we don't have that right so uh I
323:48 - think we have a problem in this message
323:50 - real quick yes we're going to delete
323:52 - this net address we're going to make it
323:53 - just a plain string and then we're going
323:55 - to open up um TCP
323:59 - here and we're going to say instead of a
324:01 - remote address we're going to make it a
324:03 - string which is fine let's this this
324:06 - mouse is in the way uh then we going to
324:09 - make run just like that and see what's
324:12 - going on see if we get the
324:14 - pH okay so we still have this interface
324:17 - uh conversion what's going on here real
324:19 - quick
324:23 - um stop to use quit action that's
324:26 - nice uh
324:28 - server 143 actually what's going on
324:32 - here yeah it's this one I know I know I
324:34 - know know so what we're going to do we
324:36 - have the p is working that's that's
324:37 - that's good news right
324:39 - so what we're going to
324:42 - do is we're going to say we could say
324:45 - per read but we can't right and we're
324:47 - going to fix everything but first of all
324:49 - I want to I want to show you something
324:50 - right I want to I want to make things uh
324:52 - work so what you're going to say this is
324:54 - uh this is a TCP right so what we could
324:56 - do to access the read function of the
324:58 - connection of the underlying connection
325:00 - right actually I think
325:06 - um now we can't uh
325:09 - um is
325:11 - that we can we can read that's amazing
325:14 - that's amazing uh so we're going to say
325:16 - p
325:26 - read let's make a simple buffer now I'm
325:29 - going to say make a slice of btes Let's
325:31 - Make A th000 and we're going to read B
325:35 - and we going to say underscore R is
325:37 - going to be period so we know that
325:38 - something is wrong maybe we going to do
325:40 - this uh this need some that did need
325:43 - need some effector that's for sure but
325:44 - just to make things clear uh let's Panic
325:47 - here on this error because normally it
325:48 - won't happen I
325:57 - think all right the problem is right now
326:00 - that we are stuck at
326:02 - reading right so we basically are stuck
326:05 - uh at reading here from the connection
326:12 - um I think let's Panic
326:20 - here and if the Panic is not getting
326:22 - triggered we know that we are stuck I
326:23 - think we are
326:25 - stuck yes we are stuck right the problem
326:29 - is guys the the big problem is that in
326:31 - this
326:32 - TCP we have a read Loop here and it's
326:36 - the same read loop from this connection
326:38 - right this connection is the same
326:41 - connection sitting in this peer here in
326:44 - this peer right so the problem that's
326:47 - going to happen is
326:49 - that they going to read at the same time
326:51 - from this
326:53 - connection which is not the problem why
326:56 - we are hanging it's the problem that
326:58 - maybe after hanging we're going to have
327:00 - inconsistent results because W is going
327:02 - to read first and and and so on so we
327:06 - need to find a way
327:10 - to communicate between this gou team or
327:14 - this threat or whatever and this read
327:17 - Loop because if this message is going to
327:20 - be a message
327:23 - stream a store message or something then
327:26 - we know we need to add uh a weight group
327:28 - or something and that's exactly what
327:29 - we're going to do so I'm going to
327:31 - install a weight group and I'm going to
327:32 - say uh it's going to be a sync uh weight
327:36 - group like that and we're going to say
327:40 - uh wi is going to
327:42 - be a
327:44 - sync weight group just like this right
327:48 - and what we're going to do is and of
327:51 - course we need to check the message and
327:52 - we're going to all do all that stuff uh
327:55 - you will see first of all I want to make
327:57 - I want to test things if this actually
327:58 - going to work what I was thinking to
328:00 - do so uh what we're going to do is we're
328:03 - going to decode this is all fine
328:11 - uh let's say we going to uh we
328:13 - do p VG it's going to be
328:18 - IG adds and we're going to say add
328:21 - one then we're going to say print
328:26 - fmt uh print L
328:32 - waiting uh till stream is done
328:36 - right that mean we're going to copy this
328:39 - here we're going to wait the weit group
328:42 - is going to wait here right and then
328:45 - we're going to say here um stream
328:49 - Dum
328:51 - continuing normal read Loop that's
328:55 - what's going to
328:58 - happen all right
329:05 - so let's let's try it out
329:09 - okay so we are waiting till the stream
329:11 - is done right so that's cool that's that
329:14 - that's very important aspect so the
329:16 - thing is if we are waiting here we
329:18 - cannot continue the read Loop right we
329:21 - cannot continue this for Loop which
329:22 - basically means that this decod or
329:24 - decode will not get triggered so it will
329:26 - not read or read stream and will
329:29 - interfere with the stream we are
329:31 - actually going to read here if that
329:33 - makes sense that's the thing and I think
329:34 - it's pretty
329:35 - nice of course we have some issues uh
329:38 - because this reading Shenanigans is not
329:39 - going to work for some
329:43 - reason
329:44 - [Music]
329:54 - um although we sending this file to
329:56 - allps
329:58 - though um yeah I think I know what's
330:01 - going on um yeah um we need to sleep
330:05 - here I guess because it's going to send
330:06 - so
330:09 - fast after each other that we are going
330:10 - to decode this into one message I think
330:12 - that could be the problem not going to
330:14 - sure not quite sure I'm going to sleep
330:15 - for the um to be to be sure actually uh
330:20 - it's going to be let's let's sleep three
330:22 - seconds or something and uh the reason
330:24 - we are going to fix this later on is
330:26 - again a fix we need to make is to uh fix
330:28 - our
330:33 - um or or a default decoder that's not
330:36 - enough
330:47 - wait so we received the storage key
330:49 - which is
330:50 - nice that's the first bunch of bites we
330:54 - need to receive is this one that's
330:58 - fine oh what are we doing no no no it's
331:01 - fine we sending storage key
331:03 - here uh and then we are going to send
331:06 - back a payload over
331:09 - these Pierce yeah pier and payLo which
331:12 - is this large
331:16 - file that should be
331:18 - fine so why don't we receive
331:21 - it here
331:38 - [Music]
331:44 - um wait I'm a little bit confused
331:52 - now so we make this bite we read and we
331:55 - we cannot Panic here for some reason
331:56 - it's not going to
332:05 - trigger no we need to wait this seconds
332:08 - before the stream will arrive yes oh we
332:10 - Panic DDD that's fine that's fine fine
332:11 - fine fine fine
332:15 - um yeah yeah I see of course we're doing
332:18 - this we are so bad we are so bad we
332:19 - don't need to print this here right
332:20 - we're going
332:24 - to wait wait wait wait man man man man
332:27 - we're going to
332:28 - print here right that's the first thing
332:30 - we're going to do we're going to print
332:32 - our first message the storage key then
332:34 - we're going to grabb the peer then we're
332:35 - going to read from it and then we're
332:37 - going to print
332:40 - um again but we're going to receive Big
332:44 - Data wait we're going to just do nothing
332:47 - we're going to say
332:50 - um wait this going to be this it's going
332:52 - to be a string of the
332:55 - buffer I think that's
332:59 - fine let's see what's going on
333:08 - boom then we have a large file that's
333:09 - perfectly fine this is what we see so I
333:12 - hope you guys see what's going on
333:14 - so the storage key is getting fetched
333:17 - from here which will then be piped into
333:19 - W group uh which will then be piped into
333:22 - this RPC message which will be consumed
333:25 - here we decode the message here and we
333:28 - print it out
333:30 - here right here is where we print out
333:33 - the message the storage
333:35 - pad then we're going to fetch the p from
333:38 - who did we received it we're going to
333:41 - fetch that PE in our peer map we're
333:43 - going to make a bite and we're going to
333:44 - read the next incoming which basically
333:46 - should be the stream that's incoming
333:50 - right because this is not going to read
333:52 - because we block with this group right
333:54 - and the next thing we need to do here is
333:55 - basically after we
333:57 - um received our big file what we're
334:00 - going to do here is just say p VG and we
334:02 - going to call it uh d right like this
334:06 - and then
334:08 - uh we can make
334:10 - run a PG undef find yes of course uh the
334:13 - reason why we cannot do that is
334:15 - because uh p is
334:18 - basically um transport here right p p is
334:23 - an interface and we only have net and
334:24 - scent and net and sent right so what we
334:27 - could do is we could give it actually
334:29 - another interface and we're going to do
334:30 - that but another neat trick is to
334:31 - basically cost this to a TCP perer um
334:36 - but I wouldn't do that uh because then
334:39 - it basically abstracts completely the
334:41 - way um it will not abstract the way why
334:44 - we made the speed Dynamic uh and and
334:46 - generic right so we're not going to do
334:48 - that we're going to fix that later on uh
334:50 - we're going to make run and to see if
334:51 - this works so normally what we should
334:54 - see is a complete round trip of a
334:55 - complete streaming uh Shenanigans right
334:58 - we're going to receive you see we
335:00 - received the large the large file here
335:02 - and then it said stream done continuing
335:04 - normal read Loop and everything is
335:10 - Gucci okay but now we need to refactor
335:13 - this into something that's actually
335:16 - usable because this is spaghetti wety
335:18 - right this is arms are heavy and knees
335:20 - weak at the same
335:21 - time
335:24 - so first of all it's good that we have
335:27 - this
335:33 - right
335:36 - um yeah yeah so what we're going to do
335:38 - is first of all uh we're going to have a
335:40 - message which is a payload any
335:44 - right then we're going to make actually
335:46 - we should actually uh we should split
335:48 - these messages out but let's do it here
335:50 - for now we're going to say
335:52 - type it's going to be a
335:57 - message store
336:02 - file the question rather is um
336:10 - yeah why
336:16 - not I'm taking because message store
336:18 - file uh a pad key is somebody receive a
336:23 - I'm sending a bad key to
336:25 - you that means that I want to retrieve
336:28 - it no it's going to be store file you're
336:30 - going to say the key and the key is
336:31 - going to be a
336:33 - string maybe it's going to be a pad key
336:35 - to be honest
336:39 - or a pad
336:41 - name the pad actually the key let's make
336:44 - it key that's that's better so we're
336:46 - going to store a file based on a key so
336:49 - what we're going to do if you want to
336:50 - store
336:55 - data uh we're going to make a payload uh
336:58 - and that's going to be not this one it's
337:00 - going to be
337:00 - [Music]
337:04 - the um it's going to be a message
337:09 - store
337:13 - file yes and we going to say that the
337:16 - key is this uh a low small case actually
337:19 - I'm going to say that the key is going
337:21 - to
337:22 - be the key we give it right there at
337:25 - store
337:26 - data that's fine that's
337:30 - fine then we're going to uncode a
337:32 - complete message we're going to send
337:33 - that to all the peers that's fine right
337:36 - let's let's keep it like this
337:38 - we're not going to hassle with these
337:39 - things right now uh so we're going to
337:41 - comment these guys
337:42 - out and the next thing we going to do
337:45 - let me oh my back hurts once again man
337:49 - the next thing we going to do is
337:50 - basically see if we can fetch this
337:56 - thing on the other side which is
337:59 - basically
338:02 - here um what is this a t reader
338:10 - yeah that's because you're going to yeah
338:11 - yeah see that's that's for later
338:15 - on here
338:23 - um this is going to be the message I
338:25 - think this is not going to work right
338:27 - this Bel bite it's going to be
338:29 - nasty uh what we going to do here is
338:32 - quickly actually what we're going to do
338:34 - is let's print it out in a in a dirty
338:36 - way in a print
338:38 - fway going to say percentage plus v uh
338:42 - new
338:43 - line which then we're going to say
338:45 - message and maybe uh let's only print
338:47 - the
338:53 - payload let's see uh what we
339:05 - get nothing
339:18 - um we're going to decode the RPC yeah
339:21 - this should be a
339:29 - message what's going on here
339:44 -  what is going
339:55 - on so we make a new by buffer we encode
339:58 - that into the buffer we range over all
339:59 - the peers and then we going to send the
340:02 - buffer bites to all the peers
340:05 - yes so why don't we receive
340:17 - anything
340:21 - um we don't have any OT
340:31 - even what's going on here
340:43 - I'm confused real quick don't we get any
340:45 - messages
340:52 - anymore what did I do what is going
340:58 - on wait no nothing is happening it's
341:01 - main it's main broken
341:11 - I'm going to store data which is
341:13 - basically um this private key my private
341:16 - data yes yes
341:18 - yes but we don't consume anymore uh why
341:21 - is
341:25 - that we're going to add one that's fine
341:37 - what's going
341:44 - on am I still sleeping
341:49 - no that's
341:56 - possible we we we don't consume anymore
341:59 - why is
342:02 - that um
342:07 - are we actually calling this what the
342:09 - hell's going
342:17 - on we panic in DDD that's fine because
342:21 - we call store data
342:23 - right so that's good uh we're going to
342:26 - encode this we range this uh let's Panic
342:28 - here maybe to see if it's uh being being
342:31 - being sent of course of I think so
342:33 - there's no reason to
342:46 - wait did we made a
342:49 - mistake uh we are blocking at
343:03 - Pierce we are blocking uh before we s p
343:07 - is going to block I
343:09 - think it's the Hop en
343:22 - coder it's the Hop encoder for some
343:25 - reason that
343:27 - blocks yeah you can see that we are
343:30 - basically blocking here but not
343:32 - here has probably to do with these
343:34 - messages I think ah I know what it is uh
343:38 - I think we have a book I think it's uh I
343:40 - know what it is it's um look at this
343:43 - guys and we need to fix uh this thing
343:45 - it's going to be a go register actually
343:48 - um go
343:51 - register it's going to be which is the
343:54 - thing
343:58 - um message store file that's that's the
344:02 - interface type you need to register
344:03 - right is anything that we are placing in
344:05 - the any
344:07 - anything that we are placing any kind of
344:09 - type we are we are embedding in this any
344:12 - type let me open up
344:14 - message a
344:17 - message here you see this payload uh all
344:21 - types we we place in there needs to be
344:23 - registered with the Goen coder otherwise
344:25 - it cannot register an interface that's
344:26 - the problem that's I hope that that's
344:28 - the problem not quite sure um that's why
344:30 - it's it up uh no it's DDD is the
344:33 - same thing let's DD I'm going to delete
344:36 - this right so now now it's working
344:41 - right let's make
344:47 - run yes uh payload is key my PR data
344:52 - that's perfectly fine so we have the key
344:55 - we know it's a storage we know that the
344:58 - message type is a stream a a store file
345:01 - so we
345:03 - now um can open up the connection for
345:06 - streaming open up a file and pipe these
345:10 - two together and make that happen and
345:11 - that's what we're going to do and
345:12 - refector that stuff in the previous
345:14 - episode basically let me comment this
345:15 - out we basically did um some Shenanigans
345:19 - where we
345:20 - could uh store where we could actually
345:22 - send a message type store file and if we
345:26 - receive it on the other side on a note
345:27 - we can uh we know it's it's a store file
345:30 - so we need to open up a connection a
345:32 - streaming connection right and uh we get
345:35 - this large file right here so now it's
345:37 - actually time to store that into a file
345:40 - right to store it into a file and to
345:42 - clean things up um yes so let's get
345:45 - started so basically we make this
345:47 - message here of
345:50 - course um let me quickly think we're
345:53 - going to encode this stuff and then
345:55 - we're going to send that
345:56 - [Music]
345:57 - to our peers we're going to sleep here
346:00 - that we need to fix later on all right
346:03 - so let's let's go to
346:07 - here right because
346:09 - here is where we're going to read from
346:11 - the P right here is where we actually
346:13 - need to store that stuff so why don't we
346:15 - clean this a little bit uh up to be
346:18 - honest so we have this handle message
346:21 - here wait uh let me see we decode the
346:25 - message yes yes yes okay cool uh what
346:28 - you could do here is basically let's
346:30 - comment this
346:32 - out so we're going to handle a message
346:34 - which is going to be a type of message
346:36 - which is fine we don't have a data
346:37 - message we're going to say case uh
346:39 - probably the
346:40 - message uh store
346:44 - file yeah like
346:46 - this uh let's make uh another function
346:49 - going to say file
346:53 - server uh
346:57 - handle message store file which is going
346:59 - to be what going
347:03 - on and that's going to be I think do we
347:06 - need a from we probably need that right
347:09 - from it's going to be a
347:10 - string and then we going to have the
347:15 - message I think it's going to be
347:18 - yeah a store file message I
347:24 - guess message store file maybe an eror
347:28 - here
347:30 - right and let's uh what we're going to
347:32 - do is um return null here and see if we
347:35 - actually can can make that work we're
347:38 - going to say uh print F we do a percent
347:40 - fee P Fe new line and then we say the
347:42 - message
347:46 - here we going to say return
347:52 - s handle message uh store
347:57 - file need to warm up not going to lie
347:59 - and we going to say
348:01 - V and
348:03 - from we don't have that
348:08 - um I think we're going to do here in
348:10 - handle message we are going to get a
348:13 - from which is going to be a
348:17 - string pass it in
348:22 - here so we're doing all that shans let's
348:25 - comment this
348:27 - out we're going to decode
348:32 - it so we're going to decode this message
348:34 - and then we're going to say if
348:39 - it's going to be S handle
348:42 - message
348:49 - RPC we could actually handle the
348:51 - decoding there and handle message
348:54 - instead of this uh thingy but it doesn't
348:56 - really matter uh so we going to say
348:58 - message I think it's going to be the
348:59 - message payload
349:01 - right
349:04 - yeah if the DAT is not nil we going to
349:08 - uh maybe a print a l
349:11 - here uh like this the error and then
349:15 - maybe return or continue not quite sure
349:16 - what you're going to
349:18 - do
349:20 - um that's going to be the message
349:25 - then what's going on and handle message
349:28 - wait let me quickly see it's going to
349:29 - take a message itself yeah I see what's
349:31 - going on uh we need the message here and
349:33 - then we need a pointer which is this
349:35 - which is fine
349:38 - all right let's see if this con um is
349:41 - going to work let's see make
349:50 - run wait uh or we receiving
349:56 - this let me quickly check uh
350:01 - received store file NSG like this
350:05 - right should
350:09 - work delicious coffee yes receive file
350:12 - private data is the key that's
350:15 - fine um
350:18 - okay okay okay okay okay
350:20 - okay we we can clean things up right so
350:22 - we don't to do we're going to fetch the
350:24 - p and all that stuff yeah yeah yeah yeah
350:26 - so that's what we need because we're
350:27 - going to open up a connection
350:29 - right so what we're going to say is
350:33 - um the same thing I'm going to say p uh
350:36 - okay
350:37 - is going to be
350:40 - ASP from right uh if we don't have okay
350:44 - we're going to
350:46 - say fmt error
350:51 - f p and then percent
350:58 - s in the P
351:03 - map we could save from some nice error
351:05 - then we have a p here here that's fine
351:09 - let me open up a server on the other
351:10 - side so we can actually
351:12 - um see much better what's going on and
351:14 - I'm getting a little bit of a cold or
351:15 - something I'm not quite sure what's
351:16 - going on and that's my own fault because
351:19 - I'm basically uh walking outside without
351:22 - any um jacket or something you
351:25 - know
351:28 - just bare naked
351:33 - almost I think this is good it's he it's
351:36 - he it's so we have the p and then yeah
351:38 - Okay cool so what we're going to do then
351:40 - is basically we know that's a
351:47 - file so we could
351:51 - say as uh as store Write we're going to
351:56 - write
351:58 - um the
352:01 - key we're going to write the key and
352:03 - then we need a reader which is basically
352:05 - the peer right we're going to read from
352:06 - from the
352:08 - spear and if the error is not nil from
352:10 - the storage we're going to return the
352:11 - error from
352:13 - here actually we could return
352:18 - right
352:25 - um we could just return
352:33 - this H are we going to return this or
352:36 - are we going to do it like this maybe
352:38 - maybe they need to be some logic here
352:40 - later on not quite
352:45 - sure well let's just return
352:51 - it let's just return it and we're going
352:53 - to see what's going on
353:01 - here uh okay
353:10 - taking a comfortable
353:17 - position
353:22 - yes what's going on here so we have this
353:26 - payload that's my mic CD kicking in
353:29 - right again once again so we're going to
353:31 - handle the message then we're going to
353:33 - do la la la la la and the speed and done
353:35 - and all that stuff we going to basically
353:37 - do delete
353:41 - this um and then we are
353:46 - going so what we're going to do here is
353:49 - basically uh again assert this to a TCP
353:56 - P do we have this
354:03 - Weg it's going to be a peerto peer TCP
354:10 - I'm going to call done on this we need
354:11 - to fix
354:20 - that
354:24 - um let's delete this folder because
354:27 - we're going to see if we're going to
354:27 - store
354:29 - something let's see what's going on
354:32 - right let's see what is actually going
354:35 - on
354:45 - okay I think
354:47 - we okay we have this
354:50 - folder but we don't have
354:52 - [Music]
354:54 - any contents in
354:57 - it okay okay and I also saw that we have
355:00 - two uh read streams which is not um what
355:04 - we want
355:13 - of course we are a legit trash right
355:15 - look at this of course of course not
355:17 - going to work uh what we need to do is
355:22 - this and if the error is not nil we are
355:26 - going to return the error here and then
355:28 - we need to uh call dumb and then we can
355:31 - say return no
355:38 - let's
355:43 - see wa the stream is done uh okay we are
355:46 - blocking and I think I know why but
355:48 - still I think we should have some file
355:51 - yes that's already been done so we can
355:53 - already
355:55 - um call
355:58 - store on a server it will broadcast this
356:02 - and then the other server will just
356:03 - store it but we're blocking and I know
356:04 - why I will I will explain
356:08 - I will explain exactly what's going on
356:10 - so
356:11 - basically uh what's this let's kill
356:15 - this so what is going on is uh let me
356:17 - open up store uh real quick here so if
356:20 - you open up store let's go to
356:23 - right uh stream it's actually small caps
356:27 - right right
356:30 - stream here so right stream is basically
356:33 - going to uh copy right and we tested
356:37 - this and it's all working fine we don't
356:38 - block here but you see I'm going to do a
356:41 - panic here so you know
356:43 - here with some exclamation marks you
356:45 - will see that we are blocking and that
356:46 - we don't hit that
356:49 - Panic although in our test it's working
356:51 - perfectly f as because we're using a
356:53 - bytes uh we make a new reader out of a
356:55 - slice of bytes which basically will
356:57 - return end of file
356:59 - um if we had the last bite written right
357:02 - you see stream is done and we don't
357:04 - panic out so the problem is that if you
357:06 - read from a connection right a
357:08 - connection will always will not return
357:10 - in the file so that's why basically our
357:14 - storage keeps waiting for new stuff to
357:17 - write in in in that
357:20 - reader so what we need to do is um a
357:24 - couple things we could do we could say
357:26 - copy n and then say we only want to copy
357:28 - 10 bytes or or n and and certain bytes
357:31 - right that's how we can fix
357:33 - it but we also can fix it by using some
357:36 - kind of a limit
357:42 - reader uh but where are we going to do
357:49 - this limit there where are we where are
357:56 - we yes so we basically sent this file of
357:59 - course this needs to be a file that's
358:01 - for later on let's first
358:03 - fix where are we doing that stuff man
358:09 - here we store
358:11 - right so we need to have a way to find
358:18 - out uh how many how many bytes this this
358:21 - is going to
358:23 - be because we could make this into an IO
358:26 - uh it's going to be a limit
358:28 - reader limit
358:31 - reader like this and let's say we want
358:34 - to read how many bytes is this thing let
358:36 - me open up
358:39 - um I don't know let's say we want to
358:41 - read 10 bu or something
358:43 - right and we're going to make
358:50 - run then normally it should um you see
358:54 - now now we Panic right but the problem
358:56 - is we only uh because the limit reader
358:58 - basically will say yo this is a reader
359:00 - but uh only read the amount of bytes you
359:04 - specify if you know open up this file
359:06 - you will see that this large right we
359:09 - only have written 10 bytes so it's
359:12 - actually an easy fix right so we need to
359:14 - find a way to get
359:17 - uh to get the size of of that thing we
359:20 - need to let uh the other side know
359:23 - what's coming
359:25 - in uh so what we could do is
359:31 - basically open up our message
359:36 - this one uh message store file we could
359:38 - say actually the size that could be an
359:40 - INT
359:41 - right so that's what we're going to do
359:43 - and in this case uh large file is
359:46 - basically this large file is 15 right uh
359:49 - and you will see we're going to specify
359:51 - the correct size uh not hardcoded in a
359:54 - in a in a in a bit of
359:59 - time so we're going to send that over so
360:02 - basically that means that if we handle
360:03 - this message
360:07 - um handle message store file this is
360:11 - here right right so we can see a limit
360:13 - readed and we going to say it's going to
360:14 - be
360:16 - um what's going on
360:20 - here it's going to be p and MSG
360:27 - size what's going on here yes like
360:34 - this what going on
360:37 - here an
360:40 - N64 okay okay okay okay
360:43 - okay uh it's all
360:46 - fine we going to we're going to change
360:47 - this hey all good my man and let's make
360:51 - run real quick and see what's going on
360:53 - what's going on everybody's sending me
360:54 - messages man it's legit
360:57 - crazy boom everything is working like
361:00 - intended we got this Panic uh and let us
361:04 - see boom this larg file so now we have a
361:06 - way to actually
361:08 - completely uh unblock
361:11 - here and we are fine right so we're
361:14 - going to close
361:18 - this um that's fine fine fine fine
361:26 - fine uh
361:34 - okay okay but now we are sending this
361:36 - large file which is basically not what
361:37 - we want to send
361:49 - right
361:53 - um what is this
361:55 - reader uh that's going to be the reader
361:57 - we give it so that's
361:59 - fine so let's
362:02 - delete um
362:07 - let's delete
362:09 - pent and let's do something like um IO
362:14 - copy which is going to be a streaming
362:16 - copy right we're going to say IO copy
362:18 - and we're going to copy to the peer and
362:20 - the reader is going to be the reader we
362:21 - give it or we could say by let's just
362:24 - try it with this uh by new reader
362:29 - payload and we're going to say maybe we
362:32 - going to say
362:33 - NF this and then say
362:37 - if the error is not nil we can return no
362:41 - we cannot
362:42 - return can we yes we
362:45 - can I'm going to return the error here
362:48 - and then we could say here fmt
362:54 - print received and
362:58 - written percent D we
363:02 - can't to disk we need to do it like this
363:05 - and just for logging purposes and let's
363:08 - see if that's going to
363:15 - work yes 15 bytes with dis all
363:19 - good all good but now we're basically
363:21 - doing still this are we doing this large
363:23 - file yeah we're doing this large file
363:24 - right let me quickly see if it's working
363:26 - double check yes yes yes all fine so
363:30 - what we're going to do now is actually
363:31 - take this reader right that's what we're
363:33 - going to do the reader we actually give
363:34 - it and store data in our main right you
363:36 - see in our main uh we are calling here
363:40 - uh bu new reader my big data file here
363:43 - and I'm going to store this at my prev
363:46 - data key and it's going to
363:48 - [Music]
363:49 - be the data we give it right so instead
363:53 - of making the spay load here we're going
363:55 - to say we don't need to make a byes new
363:57 - reader because it's already a reader
363:59 - Let's test that out make run
364:19 - okay unexpected an a
364:31 - file
364:33 - how is this possible
364:39 - we going to from
364:42 - AR which is this thing here
364:47 - right I see what's going
364:50 - on or not no I don't see what's going
364:57 - on I thought it was something to do with
364:59 - this with the file size
365:05 - maybe it is is
365:08 - it we can't
365:13 - right I think it is by the
365:19 - way it's stting at the same key
365:22 - [Music]
365:25 - um yeah I think the problem is that we
365:28 - don't know
365:39 - going be 15
365:48 - uh 22 just counter cter bites manually
365:54 - is that the
366:03 - problem yeah that's problem now it's
366:06 - working fine
366:08 - right all right so we need to find a way
366:10 - to get actually uh the size of the
366:12 - file um so if you want to make this
366:14 - reader right the first thing we need to
366:16 - do is actually store it right we're
366:17 - going to say s uh it's going to be s
366:22 - store uh and we could say no not store s
366:25 - store right the key uh is going to be
366:29 - the all right and then you're going to
366:30 - say here as not n we could return an
366:34 - arrow here right
366:37 - just like that but the thing is uh that
366:39 - we need to do our let me open up server
366:41 - real quick T do we have a
366:45 - t t t t why can I not type what's going
366:49 - on T
366:55 - here man what is it doing
367:06 - yeah so we need the ster that's what we
367:09 - need we're going to copy this hop hop do
367:13 - it here let's delete
367:16 - this uh we can do
367:19 - this right we make a buffer we make a t
367:24 - reader we're going to store the
367:31 - file um
367:37 - this buffer can we reuse that buffer no
367:40 - I don't think
367:42 - so let's make it the message BFF
367:59 - then let's make it a message
368:04 - buff what can we do with this T we can't
368:07 - T can only read
368:15 - right T can only read so we have um we
368:20 - store it to our own disk then we're
368:21 - going to send that to the network to
368:24 - broadcast
368:26 - this it's actually in here all
368:30 - right uh let's delete this function
368:39 - okay okay
368:40 - okay so what I want to do actually in
368:43 - store is find a way to
368:45 - return if you do right stream what I'm
368:48 - going to do is actually return this and
368:50 - it's going
368:50 - to I'm going to return an
368:58 - in so we don't uh restore nothing we
369:03 - written nothing
369:05 - uh 0 n actually no that's not true it's
369:09 - going to be
369:13 - n that's an we're going to do it an uh
369:15 - an N64 for some reason it's an
369:18 - N64 like that and of course our test
369:20 - will be
369:22 - broken it's going to be right we're
369:24 - going to do the same thing it's going to
369:25 - be in N64 which is the file size
369:40 - yeah so now we could say uh this we
369:43 - could say um it's going to be T you
369:47 - could say
369:47 - n or actually size
369:54 - maybe uh yeah if add is not nil and then
369:59 - we pipe the size well pipe we're going
370:01 - to assign the size to the size
370:05 - is good very
370:09 - nice and
370:14 - then I think we're
370:16 - good let's uh let's open
370:20 - up this thingy let's delete
370:24 - this what's going
370:28 - on Windows man all right so uh all
370:31 - folders are gone let's make run
370:36 - let's see what's going on I store right
370:39 - that's basically in server 160 I yeah
370:42 - see it's a he right uh let's do this
370:46 - because we don't need
370:52 - this make aun
371:11 - yeah I think we uh up or t reader
371:14 - not quite
371:17 - sure this is
371:21 - T B bites it's this B
371:48 - oh yeah yeah yeah of course I think uh
371:50 - we made a mistake
371:54 - here this needs to be the message bth I
372:00 - guess is that true
372:14 - received and written zero bytes to dis
372:17 - e
372:22 - um of course we we got these two files
372:25 - right and we got nothing here right but
372:27 - we got Big Data file here so it's it's
372:37 - who is sending
372:41 - this yeah it's it's two right so we
372:44 - store the data so we store it at our own
372:48 - uh disk is fine right we stored it at
372:50 - our own disc but broadcasting is uh in
372:54 - problem or not what's going
373:03 - on yeah yeah yeah yeah so broadcasting
373:06 - is a
373:26 - problem wait wait wait wait wait uh oh
373:29 - yeah we do R that's not true
373:36 - of course we made a mistake this needs
373:37 - to be the
373:40 - buffer wait we need to be careful right
373:42 - because uh these file namings are
373:44 - basically blocking
373:46 - us
373:57 - um
373:59 - yay oh we did it we did it I think it's
374:01 - going to work so we have 3,000 here file
374:04 - here file there yes we distributed our
374:07 - storage man amazing all right but hey we
374:11 - are still not there because it's garbage
374:12 - right it's garbage code let me quickly
374:14 - do my um the serious position the
374:17 - position where we where we yeah if I'm
374:19 - in this position it means it means uh
374:22 - things are got to get serious
374:24 - right all right so we do these
374:29 - things I have this this this Micro CD
374:32 - man it's crazy what's going on why am I
374:35 - why why why do I have
374:40 - that okay so I want to change some names
374:43 - because this is the
374:46 - buffer this is a message
374:53 - buffer message buffer buffer that's fine
374:56 - that's fine that's
375:00 - fine how you going to name this
375:23 - um let's make this a file buffer right
375:26 - let's make it a file buffer and then
375:28 - we're going to say here that that makes
375:30 - more sense uh file buffer that makes
375:34 - more sense
375:36 - that is fine H H hop cool cool
375:42 - cool I think the store data is is kind
375:45 - of
375:52 - good maybe we should do this to make it
375:55 - even more
375:57 - cleaner right that's fine I like it MSG
376:00 - is this
376:01 - one I like it then we do we decode a
376:04 - message here here that's fine that's
376:06 - fine okay cool that's that that seems
376:08 - that seems
376:09 - good that seems
376:17 - clean where is this one and then this
376:19 - message thingy handle
376:21 - message what we do here is basically
376:23 - this one I don't like we need to fix
376:25 - that we store it
376:33 - here what I'm going to do store is
376:35 - actually
376:37 - um delete this thing so we can actually
376:40 - do it here and we're going to say
376:42 - n uh like
376:46 - this and then we could say here uh
376:57 - fmt
376:59 - written uh bytes to disk
377:07 - new line of course what's going on
377:10 - here what's going on
377:12 - here and then we're going to say uh it's
377:14 - going to be n then we're going to call P
377:18 - done but still we need to fix some stuff
377:20 - because there are a lot of things not
377:21 - okay because right now we do this here
377:23 - in TCP transport right you could see we
377:25 - are hardcoding this
377:27 - stuff uh because it could be that we are
377:29 - just sending a oneoff message then we
377:30 - don't need to lck the stream so we need
377:32 - to have functionality for that that's
377:34 - what we need to do uh what also we need
377:36 - to do is try to uh retrieve
377:40 - files uh if we can uh store a file if
377:43 - you can retrieve a file that's fine we
377:45 - need to do the encryption clean stuff up
377:48 - make some tests and I think then we're
377:50 - almost done with this of course you can
377:52 - expand upon this uh much further and
377:55 - further further but I think if we all
377:56 - have these things in place we have a
377:58 - very nice project that we made um which
378:01 - you guys could use uh to get a I don't
378:04 - know a higher pay job or something this
378:07 - basically if you show this guys be
378:08 - honest
378:10 - um they they they don't know what's
378:13 - going to happen uh in the previous uh
378:14 - episode if I'm correct me if I'm wrong
378:16 - uh we could actually uh distribute our
378:18 - files so if we store a file uh on a
378:21 - certain key we can actually uh
378:23 - distribute that between all the
378:25 - connected nodes which is perfectly fine
378:27 - which is actually the intention right so
378:29 - basically it means that if our uh
378:31 - computer blows up uh our file is safely
378:34 - stored somewhere else which we should
378:36 - able to retrieve if we don't have it
378:39 - right so that's what we're going to do
378:40 - now um yes that's what we going to do
378:43 - now so let's open up uh this
378:48 - thing first of all I think we need to do
378:51 - is
378:52 - basically um inore data right what we do
378:55 - here
378:56 - is this a bunch of thing right this this
378:59 - whole shebang what this does is it
379:02 - basically encodes the message and then
379:03 - it's going to send to all the
379:05 - peers uh and I think we should have a
379:08 - broadcast message do we have that yes
379:10 - broadcast here I think we're going to
379:11 - rename this to stream and uh actually uh
379:14 - make a new one we're going to say file
379:17 - server uh
379:20 - broadcast and we going to broadcast a
379:22 - message it's going to be a pointer to a
379:24 - message uh which will return an
379:27 - error like this right let's delete uh
379:32 - let's clear the highlights uh and then
379:33 - we can actually copy uh this
379:37 - thing so
379:38 - let's copy the buffer
379:42 - Boom place this in
379:44 - broadcast and uh instead of we could say
379:46 - just buff
379:49 - here uh like this just say
379:54 - buffer and I'm going to say buff bites
379:57 - and return n here I
380:00 - guess um so this is going to basically
380:03 - encode it and broadcast this to all the
380:05 - peers and now we
380:07 - can uh here say if the eror is going to
380:11 - be as
380:14 - broadcast uh point it to the
380:17 - message if the error is not nil just
380:21 - going
380:23 - to we can return uh return R which is
380:27 - fine now we going to sleep and we going
380:29 - to fix this sleep uh very soon very soon
380:32 - then we going to copy the whole sh bang
380:34 - and I think think we should do a multi
380:35 - writer uh here soon I'm going to say to
380:38 - do and let me do a high
380:42 - comment uh gfg is going to be
380:47 - green like this fine uh to
380:52 - do uh at uh
380:55 - NDM use uh a multiwriter
381:01 - here like this myty a myy
381:05 - a multiwriter yes um so that's fine for
381:09 - now is this going to work let me quickly
381:12 - test make run to see if this all working
381:14 - perfectly like
381:20 - intended yes right uh we have written
381:23 - two times which is basically one on
381:25 - 4,000 and one on the 3,000
381:27 - server good good good so the next thing
381:29 - we going to do is
381:31 - um store data actually what I'm going to
381:34 - do I'm going to I'm going to rename this
381:35 - to store
381:38 - actually um it's not going to work so
381:42 - we're going to say
381:44 - store perfectly fine everything is out
381:47 - we're going to call this store and I'm
381:48 - going to say funk s file
381:51 - server and we're going to call this get
381:53 - which is going to be a key
381:56 - string and that will return I think it's
381:59 - going to return an IO reader
382:01 - right and an error
382:05 - like this
382:07 - right so if we want to do a get is
382:09 - basically the first thing we're going to
382:10 - do if we're going to say
382:13 - um if s store has if we have the
382:20 - key then we can retrieve it locally
382:22 - right then we can say return as uh
382:26 - store
382:28 - read key right but if we don't have the
382:32 - key right then we can actually say
382:37 - um going to return n
382:42 - here actually let's let's just Panic
382:46 - right uh don't have
382:50 - actually yeah you could
382:56 - do don't have file locally right that's
382:59 - what we're going to say
383:00 - here uh
383:04 - which then because I think we already
383:08 - have these files so we can comment this
383:09 - out and I'm going to say
383:12 - um or error is going to be S2 get and
383:17 - let me get some uh Fu which we don't
383:19 - have and if the error is not
383:22 - nil we're going to uh log
383:27 - fatal the errors right and otherwise we
383:30 - could say that the B uh R is going to be
383:33 - IO
383:37 - it read all the the reader here if let's
383:42 - copy this real
383:44 - quick like
383:47 - this and then we can say fmt print Ln
383:52 - the string of the bytes right let's make
383:55 - run real quick it's going to panic out
383:58 - right because we don't have this Fu
384:00 - thingy right don't have file locally
384:02 - which is fine but if we say uh that the
384:04 - key is going to
384:05 - [Music]
384:07 - be my private data
384:09 - right and we do make run then it's going
384:12 - to what's going
384:13 - on let's read all what am I
384:19 - doing private data like
384:22 - this that normally we should we should
384:25 - get a
384:27 - file Big Data file here right that's
384:29 - actually uh you can see big data file
384:31 - here that's that's what we stored in
384:33 - these files right so it's good it's
384:35 - working like intended right so if we
384:37 - don't have the file locally we're going
384:39 - to actually search for this file in the
384:41 - network right so we're going to say type
384:44 - uh message type get no message type
384:49 - message get file it's going to be a
384:51 - structure right and we're going to say I
384:54 - think we only need a key for
384:58 - now right and then we could say
385:01 - something like the message is going to
385:03 - be uh a
385:07 - message the payload is going to
385:09 - be a
385:11 - message get
385:15 - file and we're going to say that the key
385:17 - is going to
385:19 - be the key we want like this and I'm
385:22 - equal to if f is going to be as
385:26 - broadcast I'm going to broadcast this
385:32 - message and if the error is not
385:37 - nil uh we're going to return the error
385:40 - like
385:41 - this and uh instead of saying Panic we
385:44 - could
385:49 - to a print uh F don't have
385:56 - file
386:00 - locally key right don't have file
386:03 - locally uh we could say fetching from
386:14 - Network like this and then we're going
386:17 - to broadcast that stuff and uh that
386:19 - should be handled on the other side of
386:21 - the network hey so we're going to handle
386:23 - a a message here so we're going to say
386:26 - case message get
386:28 - file we're going to say return s
386:32 - handle message get file from V we don't
386:38 - have that so we're going to say funk
386:40 - as file server handle uh message get
386:47 - file what's going on like this and
386:50 - that's going to
386:52 - be from string and of course a message
386:55 - get file is it a
387:01 - pointer we don't need a pointer because
387:03 - we didn't do it in the other side we
387:04 - going to return an
387:07 - error um
387:17 - yes let's n and say
387:20 - fmt print
387:32 - Ln okay we need to get a file from this
387:34 - and send it over the
387:36 - wire uh let's see if this is going to
387:38 - work actually what we need to do is um
387:41 - block real quick on get otherwise it's
387:43 - not going to work we're going to
387:43 - broadcast this and I'm going to say
387:44 - select real quick to test it
387:47 - out uh what's going on clear make
387:53 - run um yeah yeah yeah of course we just
387:56 - copied some stuff actually a handle did
388:01 - we uh 79
388:06 - that's not going to
388:09 - work uh and then
388:13 - 89 yeah of course we we we we turn
388:20 - yeah
388:22 - uh
388:27 - yes of course cannot use message as
388:30 - message and broadcast okay okay okay
388:32 - fair enough my friend you're right and
388:34 - if you're right you're right so we're
388:37 - going to do this
388:38 - Shenanigans my big data file
388:42 - here yeah okay good that's because we
388:44 - actually um we have this key right so
388:47 - we're going to see um a new key we don't
388:53 - have that's something we don't have in
388:56 - our in our storage right so normally uh
388:58 - it should now send
389:02 - message okay so we can see don't have
389:04 - file uh blah blah blah locally fetching
389:06 - from the network that's fine but we also
389:08 - need to make sure we can send our new
389:10 - message over the network is this thing
389:12 - we want
389:12 - to what's going on
389:19 - actually what did I
389:26 - do copy this paste it in and then we're
389:29 - going to say message store file we also
389:30 - going to say message get file right so
389:32 - remember for the go and coding we need
389:34 - to everything that's basically could be
389:36 - an interface in an any type anything
389:38 - that could be in there we should
389:39 - register that to the go and coder so
389:41 - that's what we do and then we could make
389:44 - run to see uh cannot use blah blah blah
389:46 - again I think we made a mistake it's
389:48 - because uh like
389:50 - this my bad my apologizes so normally
389:54 - right now we should have um yes so need
389:59 - to get a file from disk and send it over
390:01 - the wire right that's uh a
390:06 - thing wait until the stream is done why
390:08 - is that it's because we lock it yes yes
390:10 - yes we need to fix that because it's an
390:11 - a dirty
390:19 - thing so we sent that over the wire
390:22 - that's
390:23 - fine completely Gucci
390:29 - um here so what we're going to do here
390:32 - is
390:34 - first of all we need to uh make sure
390:36 - that
390:36 - [Music]
390:44 - we uh what are we going to do here maybe
390:47 - you could do ifs
390:49 - has because it could be that our remote
390:51 - doesn't has it right you're going to ask
390:53 - for all the peers hey yo give me a file
390:55 - but if he doesn't has it he doesn't have
390:56 - it uh and I
390:58 - think we should to respond with
391:00 - something I not sure what we're going to
391:02 - do here I think you're going to say if
391:04 - has uh MSG
391:08 - key if we don't have it uh I don't think
391:12 - we going to we just going to print
391:13 - something out we going to say print Ln
391:15 - of print or print F rather
391:23 - um uh cannot fetch
391:38 - cannot read file from disk uh actually
391:40 - file does
391:50 - not on disk all right that's that and if
391:53 - we have the
391:55 - file we need to basically fetch the file
392:07 - uh we need to fetch the file it's going
392:09 - to say that the
392:12 - um it's going to be a reader and an
392:14 - error right and that's going to be s
392:18 - store
392:20 - read we're going to read uh MSG key
392:24 - right and if there is an error of course
392:26 - then we're going to return an
392:32 - error and now we have a read here right
392:34 - so we have our reader here that's what
392:35 - we're going to send over the wire so we
392:37 - need to open up uh a stream
392:41 - actually with the
392:44 - connection and that's basically the p uh
392:48 - okay is going to be as peer
392:52 - from right and if not okay which
392:56 - basically mean this spe does not exist
392:57 - so we could to return an fmt error
393:00 - f p
393:03 - not in map
393:09 - whatever like this then we have a peer
393:12 - so what we could do then is basically
393:14 - copying uh files from this
393:17 - guy to the peer uh we could do that with
393:20 - um n r is going to
393:23 - be IO copy very important uh thingy and
393:28 - the destination is going to be the peer
393:29 - and what we are going to copy is
393:31 - basically the reader we just fetched
393:33 - from our dis and that's why we're using
393:35 - readers right you could say yeah but why
393:36 - are you using readers in in our storage
393:38 - and and people always use bites bites
393:40 - stop using bites right stop using btes
393:44 - you should use readers because it's
393:46 - compatible with the whole universe you
393:48 - know what I mean reader is so compatible
393:50 - you see why we're using read is because
393:53 - we need
393:55 - them it's Plug and Play It's Plug and
393:58 - Play boys and girls and everything
394:00 - else uh then we going to say if there is
394:02 - an error of course we're going to return
394:05 - an
394:06 - error all right and then we could we
394:09 - could actually log this out I could say
394:10 - parent uh
394:15 - f um
394:18 - row this is root a thing
394:34 - and I'm we going to say written n bites
394:36 - over the network to
394:38 - from and I made a mistake
394:41 - us that's
394:45 - fine now let me quickly see I don't
394:47 - think it's going to work but hey let's
394:48 - test it out listening to the transport
394:52 - uh of course we not we we're not going
394:53 - to have that file right so we're going
394:54 - to say does not exist on
394:59 - disk uh no such file directory open
395:02 - that's cool that's cool why is this
395:04 - uh we are opening
395:09 - stuff oh yeah yeah of course what what
395:11 - are we doing fmt print F we could return
395:13 - an error we need to return this as an
395:15 - error
395:18 - actually I we don't need a new line
395:21 - here uh is
395:24 - this so
395:35 - right so this going to be much more
395:36 - cleaner so uh like
395:42 - this right so it's it's telling me need
395:44 - to serf server file uh but it does not
395:46 - exist on the dis right that's cool uh
395:49 - just this little typo here like this and
395:52 - then we're going to say f uh file server
395:54 - stop du to server action quit uh not
395:56 - quite sure why that is is it probably
395:59 - for um handle get file here is here we
396:03 - going to handle a get
396:07 - message oh yeah we return heat yeah I
396:14 - see can we continue
396:20 - here I'm not going to do anything
396:23 - actually because these these errors
396:25 - causing
396:30 - um need to Sur F but I think that's
396:33 - better yeah uh and this error is
396:35 - basically not not that good um file
396:38 - server stopped due to
396:43 - error or user qued action something like
396:46 - that it Mak more sense each time we
396:48 - return here this function is going to
396:49 - get T first right uh and go and I think
396:52 - we're going to do the same thing here to
396:54 - be honest don't want to quit we just
396:56 - want to print out the error right and uh
396:58 - we could actually say uh
397:04 - decoding
397:13 - errors uh like this copy this paste in
397:16 - heat and we going to say heat handle
397:17 - message
397:20 - error much more cleaner eh all
397:26 - right intense intense not going to lie
397:29 - it's intense boys but it's nice it's
397:30 - cool I like it I love it and I hope you
397:33 - love it too I just want to make sure you
397:35 - guys are absolute animals on the
397:38 - keyboard with go and it doesn't even
397:40 - matter if it's with go this is basically
397:42 - uh programming this is about programming
397:44 - right this is go okay but you can do it
397:46 - in every single language out there it's
397:48 - just knowing how to do things is just
397:49 - knowing how connections work how how it
397:52 - is what it is if
397:54 - you you can literally give me any
397:56 - language and I will make the same thing
397:59 - literally just rust I don't care uh rust
398:03 - python even in JavaScript call me a
398:05 - language and I will make it happen
398:07 - although goang is my best language
398:09 - because I know a lot of things in the
398:10 - top of my head and in rest I don't but
398:13 - it doesn't care because all the things I
398:14 - don't know I know where to find them you
398:16 - know what I mean it's it's all it's all
398:18 - the mindset it's all knowing how to do
398:20 - things and if you know how to make these
398:22 - decentralized distribute storages you
398:24 - literally can make so much because you
398:27 - know these Concepts that's the most
398:29 - important thing to know uh and and even
398:32 - though these Concepts maybe you don't
398:33 - don't want to build a decentralized uh
398:35 - content addressable storage knowing
398:36 - these stuff can help you build other
398:38 - things you want to build right it's it's
398:41 - it's just knowing these principles this
398:45 - mechanics all right
398:48 - so okay cool what we're going to do is
398:51 - uh we are 4,000 right so what we could
398:54 - do is uh we are
398:57 - 4,000 which we're going to delete the
399:00 - whole folder of 3,000 uh 4,000 yeah
399:03 - what's going on here
399:06 - still is this a filter real
399:14 - real what's going
399:17 - on anyway it doesn't matter so we don't
399:21 - have um or
399:27 - folders so we're going to get
399:31 - the my private data
399:36 - which then basically will
399:43 - um well this this this we will have this
399:46 - right so we're going to actually can we
399:47 - can make a log line we could say ft
399:49 - print F real quick here and we're going
399:52 - to
399:56 - say got file percentage
399:59 - s serving over the network
400:11 - actually serving
400:15 - file over the network new
400:24 - line m g
400:28 - key like that uh make ritten real quick
400:46 - yes so we serving file my priv private
400:49 - data over the network and then it sets
400:51 - written 22 bytes over the network to
400:53 - that guy wait until the stream is done
400:55 - and then we have a decoding error yada
400:56 - yada yada
400:58 - so we copy this right that's good that
401:01 - this copy is working it's perfectly fine
401:02 - because that's reader we sering that
401:04 - over the network and of course we get
401:07 - this decoding error because right now
401:09 - the file is being uh
401:12 - decoded in the TCP
401:15 - Loop uh in in
401:17 - the transport in the TCP trans the file
401:21 - is being decoded here right here this
401:23 - thing we got it here right but that's
401:26 - not because we don't uh
401:28 - [Music]
401:30 - basically I'm happy with the result
401:32 - already but the the problem is that we
401:38 - um is's a multiwriter
401:41 - here right so we do a broadcast but then
401:44 - here we need to actually
401:51 - um open up a
401:53 - stream looking for my words so are we
401:55 - going to do this to open up a stream is
401:57 - basically we need to broadcast this
402:00 - to
402:01 - um read from every
402:04 - P that's what we need to do and we need
402:06 - to find a better way soon but
402:09 - hey going to be range as
402:15 - PE we need to do a copy we're going to
402:17 - say n r is going to be IO
402:21 - copy and we need to make a file buffer
402:23 - actually we need to make a file buffer
402:24 - for everyone because we actually don't
402:27 - know uh if you have a
402:29 - file maybe we should first ask there are
402:32 - a lot of mechanics we could do make this
402:33 - better guys we could first we instead of
402:36 - assuming they're going to serve it we
402:38 - could first ask if they have it and if
402:40 - they have it then we open up uh so we
402:42 - could say hey do you have this file he
402:44 - responds yes I have it okay I open up a
402:47 - stream or you could say uh what we're
402:50 - going to do right now is basically yo do
402:51 - you have this file I'm waiting for you
402:55 - actually not good so we we need to fix
402:57 - it we need to fix it uh but hey we built
402:59 - this up don't be too greedy in your over
403:02 - engineering because because that will
403:03 - basically kill your dopamine levels so
403:07 - we're going to Loop through the spe
403:08 - we're going to make a file buffer which
403:10 - is actually not
403:11 - true uh we going to make a file buffer
403:15 - which is going to be a new
403:17 - bytes
403:20 - buffer then we going to say uh who is
403:22 - the destination the file buffer is a
403:24 - destination and the p is going to be the
403:28 - reader and we going to say if there is
403:30 - an error of course we are going to
403:32 - return that error actually we should not
403:34 - do this because U but yeah we're going
403:37 - to actually we're going to fix this
403:38 - later on because if we return here an
403:40 - error uh this get is going to basically
403:47 - return and it could be that just this an
403:49 - invalid peer right it could be that the
403:51 - first p is going to turn n while the
403:53 - next p is going to serve or the file
403:55 - perfectly fine so we cannot do this but
403:58 - uh for now it will be fine and then we
403:59 - could say that we are receiving uh fmt
404:04 - print
404:05 - Ln uh
404:19 - received I think something is wrong with
404:21 - my
404:25 - um let me quickly check is it Windows
404:27 - Intel once again no it's us hey hey so I
404:30 - have basically I don't know why I have
404:31 - two keyboards one is us one one is
404:33 - international and I don't need
404:35 - International I don't know why Windows
404:36 - keep doing that should probably delet it
404:38 - uh but hey deleting in Windows is a pain
404:40 - in the ass not quite sure why that
404:43 - is
404:50 - um can we actually print out this
404:55 - buffer actually we could do buff string
405:00 - right is is going to work I assume
405:05 - not uh
405:08 - buff of course
405:17 - not how many BS do we
405:21 - have where is
405:28 - BFF okay let's uh one 109 let's let's
405:30 - let's open up this line real quick did
405:33 - we not save this what hell's going on
405:35 - just not saved it my
405:37 - bad all right so we're going to do those
405:39 - Shenanigans
405:52 - um what's going on uh so we waiting till
405:54 - the stream is done I think that may be a
405:56 - problem with till stream is
405:59 - done these vs in our in our Peach um
406:03 - we need to fix that
406:05 - soon so don't that file locally fetching
406:08 - it from the network then we wait till
406:09 - the stream is done not quite sure who
406:10 - that is serving file my private data
406:13 - over the network that's uh the
406:16 - remote we then going to write 22 bytes
406:18 - over the network which is
406:20 - fine uh but for some reason
406:41 - I think this
406:54 - uh I'm thinking for a good a good thing
406:57 - receiving stream from
407:00 - Pier and we could do this and then say b
407:05 - um remote data or something like
407:12 - that uh I think it's blocking there
407:14 - because we already read it from our
407:15 - other loop which is not
407:20 - closed wait
407:23 - until right receiving stream from a pach
407:33 - I think it's the same issue once again
407:36 - where we need to make sure that we time
407:38 - sleep here because um ah we need to fix
407:42 - that guys I'm going to
407:44 - lie we need to fix this stuff uh because
407:49 - otherwise otherwise we're going to read
407:51 - the whole shebang into the buffer into
407:53 - this in in this the code function you
407:55 - see so we have this uh 10,28 so
407:58 - basically because we broadcasting here
408:01 - and then we instantly uh trying to
408:03 - receive is
408:14 - it not quite sure I I think I'm wrong I
408:16 - think I'm wrong to be honest I think I'm
408:18 - wrong sometimes I can be
408:30 - wrong it's decoding out which come from
408:33 - an unexpected kind of
408:43 - file ah I see I see I see we need to be
408:46 - careful because um
409:03 - it's this copy thing uh the copy thing
409:05 - is a problem uh
409:09 - yes
409:16 - wait two problems two problems arise
409:19 - it's a copy thing is first because it's
409:20 - a connection which will not uh
409:31 - stop uh yeah yeah yeah yeah yeah yeah
409:33 - yeah
409:48 - uh don't file from the network that's
409:51 - fine receiving from the PE
409:54 - um wait tell the stream is done it's
409:56 - still not
409:59 - done he's sending 22 bytes right
410:24 - um so the problem is basically that we
410:27 - uh in our TCP transport that we read
410:30 - here first once again um so so it's
410:32 - going to be some juggling around with
410:34 - these weight groups and I think it's
410:35 - going to be a very good way a very good
410:38 - start to do this because uh we cannot
410:40 - leave it like this uh we can't we just
410:42 - can't it's bad it like I said it works
410:45 - it worked till it was good till now
410:47 - right some things you implement things
410:48 - to make things work but for for at a
410:52 - certain point of time things cannot work
410:53 - anymore you know what I mean and then
410:55 - you you fix them and that's how you come
410:57 - to a complete solution so the good thing
411:01 - is that we um
411:05 - have a way that that we actually can can
411:07 - can uh request files from the network we
411:11 - are copying them but we uh have a
411:14 - problem receiving them so we need to do
411:16 - some couple fixes and I think it's going
411:17 - to be an excellent episode to do these
411:20 - fixes in the next one so let's continue
411:22 - with our forever store and uh let me
411:25 - quickly do a make run to see where we
411:26 - start where we stopped so I think we um
411:30 - started with retrieving a file
411:33 - but the problem is if we don't have the
411:34 - file then we need to fetch it from uh
411:36 - all our other peers of at least from one
411:38 - Pier right the problem is we we we going
411:40 - to we're going to run into issues and um
411:43 - the reason is if you go to this
411:45 - transport right um this transport we we
411:48 - have this this p w ad and and and weij
411:52 - weight it basically means that um we
411:55 - hardcore this right because why do we
411:57 - need to wait is because we're going to
411:58 - receive a message like a plain message
412:01 - which we go up and code right and decode
412:03 - on the other side but the problem is
412:07 - that we need to find a way to close that
412:10 - we're doing that in in um in our
412:14 - server somewhere but the problem is the
412:17 - way we are doing it right now will is
412:19 - causing issues right so everything was
412:21 - fine until it lasted right until today
412:24 - so we need to do some some creation
412:26 - handing to to fix that right to support
412:28 - it in our in our lip so what we're going
412:30 - to do is we're going to support stream
412:33 - in our library super important right but
412:36 - the first thing I'm going to do is um
412:38 - I'm going to open up main real quick and
412:40 - uh instead of doing this uh get thingy
412:43 - which did not work yet right uh we're
412:47 - going to test it with data um with our
412:50 - with our store with this this this
412:52 - function basically works perfectly fine
412:54 - right if we delete uh these two bad guys
412:58 - here if we delete these permanently
413:00 - right uh and we then do a make run
413:04 - here and normally it should uh basically
413:10 - work like this and everything is fine
413:13 - right so we have this network here 3,000
413:15 - with a file uh Big Data all good and
413:17 - then we have 4,000 with the file Big
413:19 - Data all good right so uh the best thing
413:23 - is that we test there a very common
413:25 - practice is that you always if you want
413:26 - to do a effector you test this with um
413:29 - things that already working instead of
413:30 - things that are broken right okay so how
413:33 - we going to do this very very important
413:34 - episode I'm not going to lie this is
413:38 - um how do you say that the cream on the
413:42 - on the pie or something I don't
413:43 - know yes the first thing we're going to
413:45 - do is we are going to open up and
413:49 - coding encoding here right because what
413:52 - we do right now is we read this uh 1,28
413:56 - uh stuff and uh I already mentioned this
413:58 - in the previous episode that's causing
413:59 - issues so what we're going to do is I
414:02 - was thinking about this and uh I'm not
414:03 - going to lie I was thinking about this
414:05 - for a long time um but I figured I
414:09 - figured something something neat I
414:10 - figured something out which I'm going to
414:12 - teach you what we going to do actually G
414:14 - I think it's going it's it's it's
414:16 - implemented in a lot of other uh stuff
414:18 - also um what we're going to do is we are
414:21 - going to uh make a peak buff right a
414:24 - peak buff and that's going to be make me
414:26 - uh a slice of
414:29 - bites slice of bites and we're going to
414:31 - make a one bite so we're going to Peak
414:33 - the first bite right and we're going to
414:35 - say uh first of all we're going to do
414:38 - something like
414:39 - if R is going to be nothing because that
414:43 - is the bites written right this is R
414:44 - because we're going to read from the
414:46 - reader right I'm going to say R read me
414:49 - the end to the peak buff and if the
414:51 - error is not
414:54 - nil then we are going to what's going on
414:57 - here please V code yes then we're going
415:00 - to return the error like usual
415:04 - what did I do here if what's going on
415:08 - all right so if uh we're going to read
415:10 - the the shenanigans
415:12 - here and then we going to say that uh
415:15 - first of all what I'm going to do is
415:16 - going to open up message right and we're
415:17 - going to add some support for streaming
415:19 - in our RPC we're going to say stream
415:21 - which is a Boolean right because then
415:23 - we're going to know that we are
415:24 - streaming and if you are streaming we
415:26 - know exactly what we need to do we need
415:27 - to lock our stuff and then we need to
415:30 - have a way to unlock it when the
415:32 - streaming is done so we don't receive
415:34 - other messages in that read Loop right
415:36 - that's important and I'm going to I'm
415:38 - going to show it once again right this
415:39 - is the read Loop this thing is our read
415:42 - Loop which will basically each time
415:45 - there's a connection this read Loop will
415:47 - run in other go routine reading from
415:49 - that P reading from that
415:51 - connection but if we need to uh so each
415:54 - time there's a message being sent over
415:55 - the connection we're going to read it
415:56 - here decode it into an RPC pipe that uh
415:59 - into our Channel and we can read it in
416:00 - our server but if we are
416:05 - streaming we need to lck this read Loop
416:07 - because
416:09 - otherwise we're going to have problems
416:12 - right so we cannot open up two two
416:14 - streams of reading two two read Loops
416:16 - it's impossible so we're going to lock
416:18 - the main read Loop uh we're going to say
416:21 - hey log this because I'm receiving a
416:22 - stream so we can fetch the stream
416:24 - directly in our server that's what we
416:26 - going to do I think it's a very very
416:28 - very nice uh option we're going to add
416:30 - to our lip right
416:32 - so message here we're going to have a a
416:36 - config an option A support for streaming
416:38 - in our lab so we're going to say here
416:41 - that uh stream is going to be the peak
416:45 - buff the first bite right because we
416:47 - it's only one right uh and that's going
416:50 - to be equal to for example I'm going to
416:51 - say uh 0x2 right and actually what we
416:54 - could do is
416:59 - um maybe we could do in
417:03 - uh we going to do this in message we
417:05 - could say for example
417:15 - um how we going to how we going to call
417:17 - this this this variable that's a good
417:18 - thing
417:21 - uh if the pig buff is uh streaming type
417:25 - I don't know man uh maybe stream type or
417:27 - something
417:32 - it's going to be
417:35 - 0x2 actually what is it the type you
417:38 - could say
417:39 - const con stream type is going to be Z
417:42 - X2 and then
417:46 - um message type is going to be 0x one or
417:49 - something
417:51 - right and actually why I do that I can
417:53 - do
417:54 - this do this delete this and this
417:58 - something like that right so we go to uh
418:01 - peerto peer uh stream
418:07 - type what going on
418:16 - here
418:22 - Shenanigans we are in we are in we are
418:24 - in P yeah it's my it's my bad so if it's
418:26 - going to be um if the peak buffer is a
418:29 - stream type
418:35 - actually sorry guys I'm going
418:43 - to incoming message and I'm going to say
418:45 - incoming
418:47 - Stream So if the peak buffer is an
418:53 - incoming stream yes right now we're
418:56 - going to say if stream right so if if
418:59 - this if it's a stream then we're going
419:01 - to say that the RP the message which is
419:03 - our why do we call this actually message
419:05 - anyway doesn't matter we're going to say
419:06 - the message stream right is going to be
419:09 - true right otherwise it's going to be
419:12 - false and we're going to return here
419:14 - right we're going to return there is no
419:15 - need to decode right there's no need to
419:17 - call this right
419:22 - um could say in this
419:25 - case in case of a
419:28 - stream we are not
419:34 - decoding what is uh being sent uh over
419:38 - the
419:42 - network why am I actually searching for
419:45 - w like this is
419:49 - better we are just
419:51 - setting
419:54 - um Stream True
420:03 - so we can handle
420:08 - that in our logic or something I don't
420:10 - know uh it is what it is all right so
420:12 - we're going to say stream through and uh
420:14 - it's fine then then then then then we
420:16 - need to go to TCP transport right so for
420:19 - our TCP transport what we're going to
420:21 - say is
420:23 - um I'm going to decode this right and
420:27 - then we're going to say first thing
420:28 - we're going to do is if RPC stream
420:34 - right uh then we going to actually we
420:37 - can do this uh this RPC from can be can
420:39 - be on top that's all good the OU add if
420:43 - it's a stream we going to add uh the OU
420:46 - and we're also going to wait for the VG
420:48 - for the weight group
420:51 - right that make
420:53 - sense so if it's a if it's a stream
420:56 - we're going to wait so we're going to
420:58 - say
421:00 - um fmt print F and we could say uh this
421:08 - we could say the address of the thing
421:17 - um
421:21 - um how we going to call this
421:25 - incoming incoming
421:29 - stream waiting
421:35 - I don't know something like that and
421:36 - then we going to say here actually a new
421:38 - line
421:39 - maybe and then we're going to say here
421:41 - it's going to be um do we have the com
421:44 - com remote Adder so we know who is
421:46 - saying that now we're going to say here
421:49 - um
421:50 - resuming stream
421:54 - closed uh
421:56 - resuming Rel Loop
422:02 - like that that's cool and then we going
422:04 - to here we going to say continue right
422:05 - because there's no way because we're
422:07 - streaming which basically means we we
422:08 - fetched everything we need to have on
422:10 - the other side on our server or
422:11 - something or somewhere else so there's
422:12 - no need to to pipe an RPC into it with
422:15 - basically hold no bytes
422:18 - right so we're going to say Ouiji add
422:20 - we're going to say Ouiji weight right
422:22 - that's the first thing we're going to do
422:24 - all right so you can already imagine if
422:26 - we run this right now that that we're
422:28 - going to have uh big troubles right
422:29 - we're going to have inconsistent data
422:32 - because we are basically sending an U we
422:34 - we are peing the first bite and then the
422:36 - rest is basically completely broken
422:38 - right so what we're going to do is um in
422:41 - our server right in our server uh and I
422:44 - think it's broadcast we need to have
422:47 - broadcast it's actually I need to search
422:49 - for broadcast
422:50 - here yeah like this uh so here what
422:54 - we're doing here is basically we are
422:55 - sending a just a normal message right
422:58 - broadcast is just sending a plain
423:01 - message it's sending give me a file
423:03 - store a file with a file uh with a file
423:05 - name and all that stuff and a file size
423:08 - uh but it's not doing any streaming
423:09 - Shenanigans right it's not sending us
423:11 - that bytes over the network those file
423:14 - large file bytes so what we're going to
423:16 - say here is instead of we going to say p
423:19 - we're going to send
423:21 - um we are going to
423:25 - send the the the streaming incoming
423:27 - streaming type right this this bite
423:29 - we're going to say pent we're going to
423:31 - send a slice of bytes and uh it's going
423:33 - to be a peer-to-peer
423:35 - uh incoming message
423:41 - right you're going to say incoming
423:43 - message bite I don't know uh not not
423:45 - quite happy with the naming yet right so
423:48 - we're going to send an incoming message
423:50 - so we know that if we are here right if
423:53 - we are in um
423:56 - encoding here right so we Peak so we
423:59 - know that this is the first bite
424:02 - this is the first bite we are sending is
424:04 - going to be the peak buff which going to
424:06 - determine if it's an incoming stream or
424:08 - just a normal message right the next
424:10 - thing we need to do is find out where we
424:12 - are uh sending that stream
424:16 - over uh this is get receiving stream
424:19 - from P this is a receiver that doesn't
424:23 - matter
424:25 - uh handle message handle message get
424:28 - file store file you see here are we
424:31 - closing right here are we closing the
424:34 - the weight group is because the stream
424:36 - is done right so what we need to
424:39 - do is where are we sending
424:43 - this it's all right so we need
424:50 - to somewhere we need to copy copy copy
424:53 - copy
424:54 - here right so what we do here is we
424:56 - broadcast a
424:59 - message we're going to receive that
425:01 - somebody is willing to store a file so
425:04 - we have the file name and the file size
425:07 - we then prepare on the other side we
425:10 - prepare we open we open a file on disk
425:12 - which basically our storage right right
425:14 - stream and then after 3
425:17 - seconds this guy is going to send the
425:21 - Stream So the first thing he needs to do
425:23 - is basically say peer sent right each
425:26 - spe we need to send uh a bite and that
425:29 - bite is going to be uh your body guessed
425:32 - it it's a peer-to-peer
425:34 - uh
425:36 - incoming stream just like
425:40 - that right and
425:44 - normally and I said only normally they
425:47 - should actually work perfectly fine not
425:49 - quite sure let's see what's goinging
425:59 - on yes yes I think it just worked
426:02 - perfectly fine incoming stream we wait
426:04 - in then we receive the stream we are
426:06 - written 22 bytes to dis and then we
426:07 - close the stream and we resume the read
426:09 - Loop right so to make this even more
426:11 - test we actually happy because it was um
426:15 - it's Advanced guys this is Advanced I if
426:17 - you know the stuff it's it's
426:19 - insane um let's open up main because I
426:22 - want to
426:24 - basically let's open up main here so I'm
426:26 - definitely not coding in this
426:28 - window uh I'm going to make this like a
426:30 - four
426:32 - because I want to make it a little bit
426:33 - more performant and I don't think that
426:35 - the sleep of these angles is
426:37 - needed uh let's do 10 times let's copy
426:39 - the whole she Bank inside of here let's
426:41 - paste it in
426:45 - here yeah uh so what we're going to do
426:48 - here is uh we're going to send it and
426:50 - then we're going to do a Time sleep
426:52 - because if we not sleep you cannot
426:55 - there's there's no use case it's going
426:57 - to send so fast this is going to send as
427:00 - fast as a CPU can which which no other
427:03 - note will ever do it's impossible there
427:05 - is some kind of a round trip in HTTP so
427:07 - we need to sleep otherwise it will it
427:09 - will us up uh it's going to be uh
427:12 - time sleep and we're going to say uh for
427:16 - example I think maybe
427:20 - five uh time I think millisecond is even
427:23 - is even enough five millisecond is is
427:27 - fine uh and then here we wait 5
427:31 - milliseconds to send I don't think it it
427:32 - doesn't matter wait it's the same thing
427:34 - what the hell is going on where do we
427:36 - sleep oh yeah it's in server yeah yeah
427:38 - yeah I see I see I see uh here here here
427:40 - this 3 second we don't need this but I
427:42 - think we need to sleep a little bit uh
427:44 - and this is all normal behavior I think
427:47 - uh because
427:50 - millisecond uh millisecond I don't know
427:53 - uh five or something no clue we can test
427:55 - that out and make it even better like I
427:57 - said we're just going to make it work
427:59 - we're already downgrading from three
428:01 - from three seconds right uh make so
428:04 - let's see let's see hopefully we don't
428:06 - have any encoder decoder uh problems and
428:10 - and a not quite sure what's going on
428:12 - here uh I think just one more thing I
428:14 - want to do real quick is actually uh in
428:19 - server uh something we forgot is
428:21 - basically open up our quit Channel
428:28 - no it's not TCB transport by the way
428:32 - transport um like now we don't have a
428:34 - buffer Channel we have a unbuffered
428:36 - channel which is not good we're going to
428:37 - say
428:38 - a24 is going to be
428:40 - good
428:42 - um let me quickly see what's going on
428:44 - normally normally everything should be
428:45 - fine I guess but we're never
428:50 - sure yeah that's ourselves um is this
428:57 - actually doing what it needs to do I
428:59 - don't think so to be honest
429:03 - it
429:04 - isn't what is going on so we sleep five
429:06 - time
429:09 - millisecs I'm going to make it a little
429:12 - bit bigger here and a server
429:22 - also
429:24 - yeah uh I don't know maybe 500 which is
429:26 - actually let me see right let me see
429:28 - we're going to build things up right
429:29 - we're going to make things better for
429:30 - sure for sure
429:33 - sure all right this is this weight group
429:35 - negative weight cont yes yes yes I see
429:38 - uh the question is why is this happening
429:43 - um did we miss
429:48 - something did we miss
430:00 - something um this is our main this is
430:07 - fine so received and written bites to
430:09 - dis that's all fine I don't know
430:11 - maybe
430:13 - um let's make a thousand let's see
430:16 - what's going on
430:27 - here something something um is is
430:34 - still something is still not quite right
430:44 - um right so we
430:48 - we we sent this you say is it going to
430:51 - be a stream yeah that's fine then we
430:57 - do I think that's
430:59 - fine do we need to sleep his seconds I
431:02 - don't
431:04 - think is that a
431:06 - thing I don't think
431:15 - so so incoming stream waiting see so
431:18 - there something is is um it's not
431:21 - closing let me quickly uh do one real
431:24 - quick to see what's going on
431:26 - here uh because with one it's actually
431:28 - working or did we did we make a mistake
431:30 - uh in in between that could
431:38 - be this is
431:41 - fine
431:50 - so we
431:52 - add we wait and then we continue let's
431:55 - go back here that's fine did we miss
431:58 - something in encoding
432:02 - the stream we say it's the stream and um
432:04 - we return right so it's going to be we
432:07 - Peak it here yeah yeah yeah did we I'm
432:09 - thinking what's going on here real
432:22 - quick oh maybe we are actually this is
432:24 - get right we don't care about
432:26 - get we don't care about get where a
432:29 - store wait the bro is fine right so our
432:33 - broadcast
432:37 - um we don't care about the stream
432:39 - message broadcast is here
432:43 - right make a new bites
432:45 - buffer and then we first of all send
432:48 - this to
432:49 - our uh it's going to be an incoming
432:51 - message yeah yeah yeah so we can read
432:53 - that and then we send bites it's fine
432:54 - it's fine it's fine it's fine I don't
432:55 - know what's going
432:57 - on we sent the incoming stream
433:14 - this is good file we don't care about
433:15 - that it's a store file here so we check
433:16 - the pach and up uh at the end we unlock
433:22 - that wait first of all let us
433:27 - um do this real quick let's make some
433:30 - some nice stuff and you're going to say
433:32 - written percent D bites to dis which is
433:34 - fine and it's going to
433:36 - be uh there's no way to check actually
433:39 - uh what address we have let's open up
433:41 - transport uh TCP transport real
433:44 - quick uh let's open up transport itself
433:47 - uh what I want to do in this transport
433:49 - is basically expose an add uh in thingy
433:53 - which will return a
433:55 - string or it could actually even no I
433:58 - want to say add which is which is going
434:00 - to return a string and then in TCP
434:03 - transport um we going
434:07 - to say
434:09 - funk ttcp
434:13 - transport yeah adders and Adder is going
434:17 - to
434:18 - return what's going on here uh it's
434:21 - going to return a string and we are just
434:22 - going to return return the listen do we
434:26 - have a listen add
434:31 - what's going on
434:36 - here oh it's because maybe I it
434:38 - up here going to be a the listen add
434:40 - yeah yeah yeah okay cool that's fine we
434:42 - could say that Adder
434:44 - implements uh the
434:47 - transport
434:49 - interface
434:51 - returning the
434:53 - address the
434:56 - transport is accept
435:05 - connections right cool and then we can
435:07 - do actually here uh we could say S
435:10 - transport other and that's
435:13 - fine all right
435:16 - um if you make run should be all
435:25 - fine received and written bites to dis
435:28 - 22 uh and then we say we written 22
435:31 - bytes to dis and then we close stream
435:33 - closed resuming read Loop that's what we
435:36 - want to see the problem is in main that
435:39 - we still if we do this uh for example
435:41 - for four times or even 10 it shouldn't
435:43 - matter that should also work and I don't
435:46 - know quite uh an idea what's going on
436:03 - you see it's an waiting but I think we
436:05 - are blocking
436:08 - here and I don't not not quite sure why
436:11 - that
436:15 - is right I think we're blocking heat so
436:18 - we cannot release
436:25 - heat are we sending it too fast I don't
436:28 - think it can right
436:37 - that's that's impossible right
436:43 - um I think we made a a mistake to be
436:46 - honest but where is it right where is
436:50 - it let's do it 5 Seconds that that
436:53 - that's actually enough right that's it's
436:54 - so much time for everything to to figure
436:56 - out what needs to
436:58 - do right we close the Stream
437:03 - incoming
437:05 - stream received wa you see that's a
437:07 - problem because we don't uh something is
437:13 - wrong we made a
437:20 - mistake we
437:42 - I think maybe I think I know what it is
437:43 - guys I think I know what it
437:46 - is I don't know I don't know is this is
437:50 - this
437:51 - it is this what
437:57 - happened nah
438:04 - 5 seconds it's too long yeah you see
438:06 - what's going on it's this right so yeah
438:10 - man this is you see this nasty even this
438:13 - can
438:15 - happen you see you you will you will
438:17 - encounter these stuff and that's why I'm
438:20 - why I'm why I'm doing this stuff real
438:22 - life without pre record with a screen
438:27 - next to me so I can see the solution so
438:29 - it all looks fluently and you think you
438:31 - learned something which actually will be
438:34 - but you can see that seeing myself
438:37 - making these mistakes will will you make
438:40 - more aware and even myself right so
438:42 - making this mistake the next time I'm
438:44 - going to do something like that I'm
438:45 - going to pay attention to these things
438:48 - right it's a stupid mistake
438:53 - but it's so important and I cannot
438:55 - emphasize this enough it's so important
438:57 - for you guys to
438:59 - understand some something is not quite
439:01 - right what is going on but you see that
439:04 - I looking I'm looking at certain places
439:08 - where this can happen and at a certain
439:10 - point of
439:11 - time you can see that I that I figured
439:14 - out that it should be something with
439:15 - this because de said okay we set the
439:18 - stream to
439:19 - true but we returning we continuing I
439:22 - was thinking at this
439:24 - continue but this will be true so it
439:27 - will keep thinking it's a stream which
439:28 - is not and then you know what I mean uh
439:32 - I hope it's this right you're not 100%
439:34 - sure we not 100% sure I think I think it
439:36 - is because uh so this time second guys
439:39 - this is actually this is way too much
439:41 - right such an application we cannot
439:42 - write so but we need to sleep uh so uh
439:45 - we need to sleep here uh for just a
439:47 - little bit of time because you cannot
439:49 - nobody can can process this at the speed
439:51 - of CPU right that is not U real life
439:54 - stuff so let's just do a five time
439:57 - millisecond that I think that should be
439:58 - good um
440:01 - what's this here millisecond right
440:03 - that's fine and then do we have a Time
440:06 - sleep here also uh it's 2 seconds that's
440:08 - already way way way way too much you're
440:10 - going to say
440:12 - um milliseconds uh I think five
440:14 - milliseconds is fine I think even one uh
440:17 - millisecond is good enough let's please
440:19 - let's um make run this and see if it
440:23 - finally can work um so we
440:25 - can continue
440:28 - Al yeah I think it did right you look at
440:31 - this uh it's nice right incoming stream
440:33 - right to bites stream closed incoming
440:35 - stream
440:39 - um the the the only way to test is
440:42 - basically to
440:44 - um open up these folders here uh
440:46 - actually I'm going to uh delete these
440:48 - guys delete permanently like this and
440:51 - then what I'm going to do here is
440:52 - instead of making this Kei uh we could
440:54 - do something like um something like an
440:58 - fmt I'm not seeing that I'm not going in
441:00 - my in my window here uh at the
441:03 - top um I think an S print right an S
441:07 - print F and we're going to say my
441:09 - private data uh underscore percentage
441:14 - D and then we're going to say why all
441:17 - right so it's going to have a different
441:19 - uh key so it's going to write all these
441:21 - file 10 10 times hopefully 10 folders uh
441:24 - make run let's see if something happens
441:35 - uh yeah yeah of course of course I was
441:36 - thinking why are there are two followers
441:37 - but it is is because the the root right
441:40 - so uh yeah you can see 1 two three four
441:42 - 5 6 S 8 nine 10 that's good and here
441:45 - also not quite sure if there's something
441:47 - in Big Data file that's fine yes yes I
441:50 - think it's working guys I think it's
441:51 - working here yes big data file and of
441:53 - course in our in our thingy e
441:56 - yay wo yes it's it sounds silly that I'm
442:00 - so happy but it's it was nasty books uh
442:03 - and I was thinking I I'm going to be
442:05 - honest I was trying this uh for a bit
442:08 - because it was a very nasty thing we
442:09 - need to solve with
442:11 - this with this prefixed bite what we
442:13 - needed to do and I was testing this and
442:15 - how can we do this because
442:17 - uh some I cannot figure these things out
442:20 - at at hook right uh although this is not
442:23 - scripted but I I still need to need to U
442:26 - pre-think up front how a potential in my
442:29 - head it's not not not on not on uh on
442:32 - file not on my keyboard but in my head I
442:34 - was thinking how can I do this this this
442:36 - and it took me some time to to think
442:38 - about that and to figure out what we
442:39 - needed to do right that's something um
442:42 - that I do right is thinking up front uh
442:45 - before I actually make a video because
442:46 - otherwise
442:48 - uh it wouldn't be fun for you guys that
442:50 - I'm sitting here for 10 minutes just
442:51 - thinking in in silence right okay cool
442:54 - so I think uh what we going to do
442:57 - here uh let me quickly check uh so I
443:00 - think everything is set up
443:05 - fine uh what we could
443:08 - do is uh what we could do to make it a
443:10 - little bit better is and transport this
443:12 - spe let's let's let's call this a
443:14 - function uh and why why you see here um
443:18 - TCP right there is
443:21 - no uh TCP yes here right we see PP we C
443:26 - this to a TCP P to lock uh to close to
443:29 - set down so basically the the read Loop
443:31 - can continue so what we're going to do
443:33 - is basically say
443:39 - um we say close close
443:43 - streaming uh close
443:45 - stream yeah and that's not going to do
443:48 - anything but close stream will close the
443:51 - stream something we need and then in TCP
443:53 - P what we could do is basically uh make
443:56 - this EG public uh private
444:00 - my bad going to make this VG private so
444:04 - it's going to be VG like this and then
444:06 - we are going to make a function Funk
444:10 - uh it's going to be uh TCP
444:13 - P I think it's close
444:16 - stream yeah like this and then we're
444:19 - going to say here p w done we're going
444:23 - to call done on the
444:26 - w and then I think we have these uh
444:29 - capital vgs at the bottom we going to
444:33 - make them
444:34 - um RW RW why is this what's going on RW
444:39 - yeah I think that's fine and then
444:41 - instead of calling this spe here we
444:42 - could say peer uh close stream like this
444:47 - and hopefully that's uh going to
444:49 - be the same outcome and then we have a
444:52 - little a dynamic implementation without
444:54 - hardcoding Shenanigans yeah I think it's
444:56 - working perfectly fine yes I'm happy I'm
444:58 - happy because this is actually never did
444:59 - this before
445:00 - and for me this is
445:02 - also a nice project to do because like I
445:05 - said guys I'm not doing I never did this
445:07 - before well I experimented with these
445:09 - things but this is the first time I did
445:11 - this in in in a bigger scale all right
445:14 - uh this looking good man this is looking
445:16 - so good um yeah and I think for the next
445:19 - episode because we're already at 3 uh 33
445:21 - minutes the next uh episode um we are
445:24 - going to handle our get because right
445:25 - now we have a nice and clean way to
445:27 - handle streams so now we can get the
445:29 - file uh if we have we're going to fetch
445:30 - it from our local disc and everything is
445:32 - fine if we don't find it up on our local
445:34 - disk we're going to get it from our
445:36 - other peers uh which is the power of our
445:39 - decentralization right and I think then
445:42 - what we need to do still is um our
445:45 - encryption and I think then we are
445:47 - coming close to the end in the previous
445:49 - episode we let me make run real quick we
445:53 - fixed our uh DCP transport to enable to
445:57 - support streams right for big files and
446:00 - as you can see um we are writing a lot
446:04 - of uh a lot of files to the network
446:07 - which we have uh node 3,000 and node
446:10 - 4,000 and they have all the files we
446:12 - need to distribute which is good but now
446:15 - um that's fine working fine the next
446:17 - thing we're going to do is basically
446:18 - open up a server and maybe on the other
446:20 - side we're going to open up uh I don't
446:23 - know maybe nothing actually this time
446:26 - this time nothing
446:29 - so we have let me put out this this
446:32 - cursor here um we need to fix our get
446:34 - right so let me search for that real
446:37 - quick get here right so basically um we
446:41 - can store that's fine but what we also
446:43 - need to do and we already did that but
446:45 - it was uh a little bit scuffed because
446:48 - we need to fix our our streaming uh
446:50 - option first our streaming support first
446:52 - right so what we're going to do is we're
446:53 - going to fetch a file wait let me open
446:56 - up main to show you better right so we
446:57 - have main here and what we're going to
447:00 - do is uh we're going to make one file
447:02 - we're going to store one file real
447:05 - quick um let's do this we're going to
447:08 - say um
447:11 - cool uh picture maybe cool
447:15 - picture. GP like this and we're going to
447:18 - store data right that's what we're going
447:21 - to do let me quickly delete these
447:23 - folders whe uh fast delete permanently
447:26 - he's gone get him out of here all right
447:29 - so let's do a make run so we just store
447:32 - one
447:36 - file uh like this of course stream close
447:39 - res zooming Rel loop I think we also
447:40 - need to fix one more thing uh because
447:42 - we're hanging and that's not good oh
447:43 - yeah let the select here I see I see I
447:45 - see that's uh no big of a deal so if we
447:48 - open up our folders right now we don't
447:51 - see anything is that
447:55 - okay uh I think it's a vs code book to
447:58 - be honest
448:02 - it's a vs code book because if I LS in
448:05 - the folder here uh we see the the the
448:08 - 3,000 and 4,000 Network so what I'm
448:09 - going to do is I'm going to
448:12 - remove uh the wait we are sending this
448:15 - from 4,000 right yeah so I'm going to
448:17 - remove the 4,000 Network like
448:20 - this not quite sure why vs is not
448:22 - showing this but anyway a little Buck
448:25 - why
448:26 - not so that's fine I'm going to comment
448:28 - this uh
448:30 - out and then we are going to comment
448:32 - this in back back in and we're going to
448:34 - say we don't want to get the private
448:36 - data uh we want to get the file and it's
448:39 - going to be cool
448:42 - picture cool picture uh. gpeg what's
448:46 - going on here geg right that's what we
448:48 - want to fetch so basically we're going
448:50 - to try to fetch this and um we're going
448:52 - to check first of all we're going to
448:53 - check our local disk right and if we
448:56 - have it on our local dis we're going to
448:57 - serve it from our local file from our
448:59 - local server from our local dis but if
449:01 - we don't find it then we're going to
449:03 - grab the network and try to fetch it
449:06 - from one of our
449:08 - peers that's the main goal
449:10 - right um so we're going to get
449:13 - here the first thing I'm going to do is
449:15 - make some uh because now we have support
449:17 - for uh our added right so it's very nice
449:20 - to prefix this with the added of the
449:22 - server so we're going to say uh S
449:23 - transport other and then this is going
449:26 - to be the key right like that let me
449:30 - close this because
449:33 - yes so we're going to get it uh what we
449:36 - could do is basically say here if we
449:37 - have the file I'm going to
449:41 - say let's delete all this
449:44 - junk
449:48 - um serving
449:52 - file from local
449:55 - disk yeah and it's going to be the file
449:58 - which is the key
450:01 - yeah fine fine
450:04 - fine and if we don't find a file then
450:06 - we're going to grab it from the network
450:08 - do that
450:12 - stuff that's all
450:16 - good we broadcast this so we're going to
450:18 - prefix that with a message uh bite
450:23 - that's
450:24 - good receiving stream from P I don't
450:26 - think we need this
450:30 - [Music]
450:33 - um maybe we going to do a little time
450:36 - sleep
450:37 - here not quite sure we need to check
450:39 - these sleeps
450:41 - um time millisecond
450:46 - maybe
450:48 - Millie second what's going on
450:50 - here I'm going to say 500 maybe
450:53 - something like
450:57 - that what am I doing what am I doing
451:01 - still sleepy time millisecond times 5
451:03 - 500 that's fine we're going to range to
451:06 - the Pierce uh then we're going to say
451:08 - here uh maybe a print F
451:10 - actually uh we're going to do this
451:13 - percentage s
451:16 - received uh this amount of bytes over
451:19 - the network which is going to be a
451:20 - percentage D in a format over the
451:23 - network and maybe we could
451:26 - do from
451:30 - it's going to be S transport addage uh
451:32 - it's going to be n and then this is
451:34 - going to be P remote adders right that's
451:39 - fine then we can we can print a buffer
451:41 - here but we don't need a buffer actually
451:43 - right we don't need a buffer because we
451:44 - need to store it to our disk but let's
451:46 - try it first like this and we don't need
451:49 - to forget that we need to send um a
451:51 - stream message to this
451:53 - Speer wait so we're going to say get
451:56 - this here
452:02 - um so we're going to receive it here
452:05 - right that B that basically means that
452:06 - we're going to say p uh close
452:15 - stream something like that let's see if
452:17 - this actually going to
452:22 - work yeah let's try this real quick no
452:24 - no no we need we need to send
452:28 - um is looping stuff handle message
452:31 - handle message get
452:35 - file we're going to do the same thing
452:37 - here need to serve file but does not
452:39 - exist on
452:40 - disk so we're going to say percentage s
452:43 - which is going to be S um transport
452:49 - Adder serving file over the
452:52 - network I do the same thing
452:58 - here as transport add yeah yeah yeah
453:01 - let's make it
453:02 - clean we're going to read from store
453:04 - we're going
453:05 - to check our
453:07 - peer and then we're going to copy here
453:09 - right so the first thing we're going to
453:11 - do is peer send we're going to send this
453:14 - um peer-to-peer uh incoming stream
453:21 - thing like that and then we're going to
453:24 - say here yeah we need to do a lot of
453:27 - uh Clean login stuff
453:30 - this amount of bytes over the
453:33 - network to this guy that's fine and
453:36 - we're going to say it's going to be
453:37 - again as transport
453:40 - others I'm going to return no
453:45 - right okay let's see let's see where we
453:47 - at uh let's see where we at I'm going to
453:49 - make run real quick and see what's going
453:55 - on all right so we don't have the file
453:59 - we serving the file we written uh over
454:02 - the network we have a stream we receive
454:06 - the bytes and then we say
454:09 - um and you can see that we that we
454:11 - fetched it right you see it here of
454:14 - course it's not going to be um in our
454:17 - yeah these these not quite sure what
454:19 - this is what's up with these folders by
454:21 - the way uh if you do an LS uh all we can
454:24 - see we don't have 4,000 because we don't
454:26 - store it yet uh onto our disc so we need
454:28 - to fix it
454:31 - some coffee never
454:36 - hurt gold of the world it is
454:39 - coffee okay so what we need to do I
454:41 - think actually it works pretty fine now
454:43 - that we have the streaming support it it
454:45 - it walks like a
454:46 - breeze um what we going to do
454:50 - is this one
454:54 - right so received what we're going to do
454:56 - is we're going to try to receive from
454:58 - every P that's not the best option
454:59 - because we need to check the first P
455:01 - sending or something I don't know but
455:02 - that's for later on it's F to receive it
455:05 - from HP doesn't matter uh and we can
455:07 - actually do use goroam for this also if
455:09 - you
455:10 - want so we don't need a file buffer and
455:13 - we don't need to copy what we're going
455:14 - to do with s is do something like if um
455:17 - n is going to be s store
455:21 - um
455:23 - right it's going to be the key I guess
455:26 - and we going to use the p
455:30 - yeah and if the error is not
455:33 - n we're going to return an error or what
455:36 - do we return here actually uh a file a
455:39 - reader actually we're going to say null
455:40 - F
455:42 - right uh we don't need the
455:46 - shenans so n is working that's
455:49 - fine we cannot do that we need to do
455:53 - this if R right like this then we have
455:56 - the F this file buffer we don't need
455:58 - this we're going to close the Stream
456:00 - and we're going to stop doing
456:03 - this and then what you could do is
456:07 - return we could actually pipe this into
456:10 - into a t or something so we can write to
456:12 - dis and then return it but the problem
456:13 - is that we are in this Loop so I think a
456:16 - good option is to just return once we're
456:18 - done with this reading is basically just
456:20 - return as store
456:24 - um I think read the key something like
456:27 - that
456:32 - so we can actually fetch that in our
456:37 - mean so we can fetch that he
456:41 - right and actually do we need to select
456:43 - we don't need to
456:48 - select let us see what's going on
456:52 - is let me see what's going on
457:02 - so we don't block here so why are we
457:08 - hanging we are we are hanging let me see
457:12 - but we have the
457:15 - file we have the file in the network
457:17 - which is
457:22 - good
457:26 - um I see I see what's going on uh of of
457:29 - course of course of course remember
457:31 - remember in
457:33 - um wait where is our limit
457:35 - reader you see remember this limit
457:37 - reader where we need to tell uh if we
457:39 - write into the store how much we're
457:41 - going to read from uh from this
457:42 - connection that's the exact same thing
457:44 - we need to do the problem actually
457:48 - is uh the problem that that we have is
457:51 - basically that we don't know the file
457:53 - size yet
458:00 - where are we
458:02 - copying here
458:10 - right so what we need to do uh if we
458:13 - write here we need to make this an IO uh
458:15 - limit
458:17 - reader like this and then we going to
458:19 - say let's say 22 bytes here right you
458:22 - know what I mean because we know it's 22
458:26 - bytes but of course we cannot pref we
458:29 - can cannot hardcode that I know I know
458:31 - we're going to fix that we're going to
458:32 - say make uh run to see if now everything
458:34 - is working fine let me
458:40 - see it's working fine look at this but
458:43 - we have it we have it we're going to say
458:44 - Adam uh because we serving file from
458:47 - local disc yeah that's good andf we're
458:50 - going to say
458:51 - [Music]
458:53 - um
458:54 - actually can we
458:58 - do uh
459:01 - S2 can we remove something from this
459:04 - let's make that real quick to be
459:08 - honest s file
459:10 - server uh
459:13 - remove yeah this remove thing should
459:15 - also remove from the from the
459:19 - yeah that's yeah I see uh what we going
459:25 - to let's let's just do an uh an ad
459:28 - because we also need to remove from from
459:29 - from from all the peers then so that's
459:32 - uh it's going to take some longer than
459:34 - just a couple couple lines so we're
459:35 - going to say RM RF uh going to be 4,000
459:38 - right because we're sending we don't
459:39 - need this fine let's make let's
459:53 - see received
460:00 - uh receive B of the network what I was
460:03 - testing
460:03 - actually totally
460:10 - forgot yeah yeah yeah you see that's a
460:12 - 20 that's why why I prefix it to 22 so
460:14 - we're going to fix that um there's
460:17 - basically I don't think a
460:21 - way to know the file size if you want to
460:25 - send that
460:27 - right so what we going to do is we're
460:29 - going to send the file size
460:31 - over right here so what we're going to
460:34 - do is we're going to
460:37 - send I'm going to say first
460:39 - sent
460:49 - um first send the uh
460:55 - incoming uh incoming stream bite
460:59 - to
461:01 - theat
461:11 - um first incoming stream to the to the p
461:15 - in uh and then uh we can send the
461:20 - file
461:22 - size yeah I'm we can s the file size and
461:25 - it's going to be
461:32 - uh as an
461:38 - N64 okay so we're going to send a
461:42 - stream and then we're going to say
461:48 - um what is the file size
461:52 - actually we read it
461:56 - here yeah
461:59 - let's let's hardcode it let's send it
462:01 - hardcode it over and then uh remove the
462:03 - hard code here right piece by piece
462:06 - piece by piece so we're going to say uh
462:07 - for example VAR file
462:11 - size uh which is going to be an
462:14 - N64 is going to be 22 right then we
462:17 - going to say uh
462:19 - binary actually yeah we going to say
462:22 - binary do
462:24 - write and we're going to write to the P
462:27 - we're going to say it's going to be a
462:28 - binary a little
462:31 - Indian and we're going to write this
462:34 - file
462:36 - size like
462:38 - that so we're going to write that as
462:41 - binary and then we're going to copy that
462:43 - right so now we need to fetch it on the
462:45 - other side let me find for
462:48 - 22 here uh so the first thing we're
462:51 - going to do is
462:56 - um need the file size
463:01 - so we can uh limit the amount of bytes
463:07 - that we read from the connection
463:13 - so it will not
463:16 - keep reading or
463:21 - hanging right that's what you're going
463:22 - to
463:24 - do so we're going to say v file
463:27 - size uh which is going to be an INT
463:32 - 64 like
463:34 - that I'm going to say binary can we read
463:37 - that yeah binary
463:39 - read did be a binary read we need to do
463:41 - a binary
463:51 - right did we did we do this correctly
463:54 - yeah B righted okay okay okay okay okay
463:56 - okay fine fine fine fine fine fine you
463:59 - did it like
464:00 - it okay here so we're going to say
464:03 - binary read we're going to read from the
464:04 - pis connection we're going to say it's
464:06 - going to be a
464:08 - binary uh
464:11 - little
464:15 - andian and we're going to take uh the
464:17 - file
464:18 - size like
464:22 - this and then we're going to say here uh
464:24 - file
464:26 - size right so we removed the the the
464:30 - hardcoded stuff
464:37 - here
464:43 - yeah
464:46 - okay let's delete this
464:49 - again um minus RF 4,000 not 3,000
464:54 - because yes like this and make run and
464:56 - see
465:02 - all right all right right right
465:04 - right looks good looks
465:07 - good Okay cool so let's open up 22 here
465:10 - so the problem at this 22 is that we
465:11 - need to have the file size to send it
465:13 - over the problem is the only thing we
465:15 - get from read is basically a reader so
465:18 - you could say yeah why don't we read it
465:20 - into a buffer and
465:25 - um get the file size but I don't think
465:27 - it's a good idea
465:30 - because I need to read it into a buffer
465:32 - and and it's just
465:33 - nasty so I think I'm going to open up
465:35 - store
465:38 - here and I'm going to open up uh the
465:41 - read uh stream do we have
465:46 - that guest transform Funk read stream is
465:50 - this
465:52 - one where is R
465:55 - stream damn it just open
466:03 - right stream read
466:16 - stream
466:22 - um is this actually a good way
466:30 - because
466:35 - we this is
466:51 - actually I think we are reading this
466:53 - into memory to be honest
467:00 - instead of piping this directly to we
467:02 - need to fix that
467:04 - [Music]
467:12 - um I'm going to say uh instead
467:35 - we first
467:36 - copy this
467:38 - in to a
467:43 - buffer maybe just return
467:51 - the file from the r
467:57 - stream yes so we have this here right
467:59 - and
468:01 - then we have this this this read closer
468:04 - which is also a reader and then we copy
468:06 - it first so why don't
468:14 - we why don't we directly why don't we
468:16 - remove this
468:18 - right we could remove
468:21 - this I think that's an important aspect
468:23 - we're going to we're going to fix that
468:24 - we're going to fix that it's good that
468:25 - we have this uh this to do here um maybe
468:28 - fix me
468:32 - actually all right so what what what we
468:34 - going to do here is um we we have this n
468:37 - right we have this n so we can return
468:39 - the amount of bytes we we have but the
468:41 - problem
468:43 - is the problem is that
468:47 - we if we not going to use this later on
468:51 - then we don't have this n so we don't
468:53 - have we cannot return a file size so
468:54 - what we could
468:55 - do is in this read stream
469:02 - we do an OS open here on this full pad
469:05 - can we do an OS
469:11 - stat uh full
469:13 - Pat with a
469:21 - root and if yeah is not n we going to
469:23 - return
469:25 - n what's Fe do we have an S size or
469:27 - something
469:29 - we have that's amazing all right so what
469:31 - we're going to return here in a read
469:33 - stream we're going to change this a
469:34 - little bit up we're going to return uh a
469:36 - size which is going to be an
469:39 - N64 uh an iio read closer and an
469:47 - eror I'm going to do this and I'm going
469:50 - to say that the
469:52 - file uh erors going to be this can we do
469:56 - file size
470:02 - wait let me have let me do
470:15 - this
470:18 - um or does it return
470:40 - uh we're going to return here zero nil
470:45 - s it's actually a little bit nasty
470:47 - you're going to say Fe add is going to
470:49 - be stat you're going to stat a file uh
470:53 - not not quite sure why there is an error
470:54 - if if you already open up a file and
470:56 - then you st it by uh
470:59 - uh it's going to return an arrow to be
471:01 - honest so we're going to say return the
471:03 - same thing 0 nil Ed right uh and I'm we
471:06 - going to
471:07 - return uh Fe
471:12 - size file
471:14 - no that Mak
471:17 - sense of course our test are going to be
471:19 - broken I know I know I
471:21 - know of course this read is going to
471:24 - give us some issues because that's going
471:25 - to be n
471:28 - and we're going to return also an uh N64
471:31 - here
471:32 - right uh we could do n here that's fine
471:36 - fine
471:42 - fine this is crazy uh let's let's fix
471:45 - this I don't like
471:47 - this we're going to say
471:50 - n uh n a store read right and then we
471:53 - have already an
471:55 - N
471:57 - uh let's make it
472:02 - size or file size maybe maybe that's
472:05 - even better file size we're going to
472:07 - delete this we're going to copy the file
472:09 - size
472:11 - here
472:15 - yes uh something is wrong in Ser of it
472:18 - not quite sure what it
472:21 - is let me do a make real quick
472:28 - uh
472:38 - 89 I need to
472:42 - sneeze I'm so
472:44 - sorry live on video live on video my bad
472:48 - I'm not going to cut it man I'm not
472:50 - going to cut it hey like I said this is
472:52 - the live off you know what I mean this
472:54 - is the real deal it's
472:59 - that's the real
473:02 - deal I love you
473:04 - guys all right so are we go I don't
473:07 - think we're going to return this uh what
473:08 - we're going to do we is basically uh do
473:11 - this read a and then we're going to
473:14 - return at uh read it at right something
473:16 - like
473:21 - that maybe maybe maybe we return the
473:24 - file size I don't know I don't
473:25 - know could be could be
473:29 - uh
473:30 - 122 the same thing right what is
473:33 - this get yeah yeah yeah I see I'm going
473:35 - to return store
473:37 - here um and store read is going to
473:39 - return us this thing a no uh reader a
473:43 - and we going to return add reader right
473:45 - something like
473:48 - that um so I think now everything should
473:51 - be not
473:54 - hardcoded from local disc I see I'm
473:56 - going to add them
473:59 - RF
474:01 - 4,000
474:02 - yes make
474:04 - run see if we get it from uh the
474:09 - network yeah yeah yeah man this is
474:14 - insane this is insane so that's fine so
474:16 - what I want to do with this binary read
474:19 - stuff uh actually I was thinking maybe
474:21 - we should abstract that but to be
474:26 - honest I think it's pretty fine I mean a
474:29 - little bit of
474:30 - logic is is fine uh multi
474:34 - writer we need to fix that it's a TOD do
474:37 - or to fix
474:43 - me let us see in our test real quick um
474:46 - do we have a store test yeah yeah here
474:48 - right stream
474:53 - right s read is going to return us n
475:01 - what is Right stream do we
475:04 - need what's it going on with
475:07 - this I cannot initialize one variable
475:09 - with
475:11 - two oh yeah that's returning in
475:14 - um an add
475:19 - also yes test are working fine that's
475:21 - already taken care of all right the next
475:23 - thing I want to do is um is this I'm not
475:26 - happy with this read stream
475:30 - because we do this file yeah yeah that's
475:32 - fine but this is is bad this
475:35 - read
475:37 - uh you copy it here why do we do this
475:40 - actually why don't we just
475:43 - return right we could actually just
475:45 - return this because we don't close the
475:47 - file it doesn't
475:51 - matter right we could just do this
475:54 - right look we could actually just do
475:56 - this and actually get rid of one of
475:58 - these functions we could just return as
476:00 - readstream
476:01 - uh the key like this the question
476:13 - is are we going
476:21 - to this should be better actually
476:29 - that works perfectly
476:31 - fine now it's going to fetch from from
476:39 - local I hope you see what what the
476:41 - problem was right so let's let's revert
476:43 - this real quick you see so we get it
476:45 - from the so we we do R stream right so
476:47 - do we do our Shenanigans we get our file
476:49 - and then what we do is uh we basically
476:51 - say yo I copy everything into a buffer
476:53 - but can you imagine that's a 10 gab file
476:56 - then we fetch it from the store then
476:58 - we're going to read that into a buffer
476:59 - and then we're going to copy that buffer
477:01 - that's not
477:02 - good uh that's not what we want right so
477:06 - I
477:07 - think uh I know it's a little bit weird
477:10 - so we're going
477:11 - to just return the ream here right
477:13 - that's fine so we can remove this fix me
477:17 - already uh of course you see this
477:18 - function has no nothing in it it just
477:21 - returns this so we
477:25 - can maybe if you have a GH right we
477:28 - let's let's keep it for for now let's
477:30 - keep it like that the thing is what I
477:33 - want to do is uh I'm going
477:37 - to search for store
477:40 - read Because this is going
477:45 - to we return
477:54 - that so we return basically
478:00 - that stuff here so in main it's a read
478:04 - so we cannot close
478:09 - it that's why we did it
478:17 - right uh I see that's why we did that so
478:20 - we could close it first
478:33 - eat this one right this
478:35 - Edge so we should actually do like a
478:38 - defer uh a close but we can't what we
478:41 - could do is um can we do
478:47 - this I should be a pointer to a read
478:50 - closing Maybe
479:24 - can we do something like this
479:38 - maybe
479:51 - it that's nice
480:10 - uh yeah I'm going to explain actually I
480:11 - was thinking to to hard so basic what we
480:13 - do is we check if the the thing we
480:16 - fetched uh the the reader we check if
480:19 - it's a read closer if it's a read closer
480:21 - we going to say defer RC close we're
480:24 - going to close
480:25 - it and I want to
480:31 - let me quickly see if we can test that
480:33 - uh make
480:36 - run and we can and we can assert this
480:39 - I'm going to explain real quick closing
480:41 - reos it's fine that's cool so what you
480:43 - could do in go is basically you could
480:45 - assert if certain uh implementations are
480:49 - true right you could say um the read
480:52 - closer a
480:53 - Boolean equals the reader is that a read
480:57 - closer ER if it's read Clos it it's okay
480:59 - will be true if it's not then it will be
481:01 - false and then we don't
481:06 - care the thing is this
481:14 - RC I think I should do it like this
481:25 - if that
481:28 - something like that of course now we're
481:30 - going to fetch it from local so it
481:31 - doesn't actually matter I think yeah
481:33 - yeah it's fine it's fine it's fine all
481:35 - right so uh I think that's good very
481:39 - very very good I think it's actually
481:41 - perfectly working so what we also to do
481:43 - is delete thingy that's so we can remove
481:46 - files we need to do our
481:50 - encryption and maybe uh a
481:53 - separate thing where we do some cleanup
481:55 - and then uh I guess we have our we have
481:57 - our thing of of course you can like I
481:58 - said before you can make this as complex
482:02 - as you want right you can do so many
482:03 - cool features but I think that's a very
482:05 - very uh good practice for you guys on
482:09 - the other side of the camera and where
482:11 - you can have this working thing but you
482:14 - can extend it with with some with some
482:16 - cool functionality you should you think
482:18 - it should have right because like I said
482:20 - we can keep developing this for months
482:22 - and make it better and better and better
482:23 - and better but the question is where
482:25 - does it end right so we're going to do a
482:26 - couple things more so it's it's it's
482:28 - going to be good and robust and uh after
482:32 - that we can
482:33 - close that series and we can start
482:35 - another Series so the previous episodes
482:38 - we can store files we can retrieve the
482:40 - files we can retrieve them we can store
482:42 - them dist uh in in a decentralized
482:44 - distributed way we can retrieve them um
482:47 - from our peers if we don't have the file
482:48 - locally it's all good we have stream
482:50 - support now for our TCP uh Library uh
482:53 - peer-to-peer Library by the
482:55 - way and I think it's a good time to
482:58 - implement encryption right because um as
483:02 - you know if we going to if we going to
483:04 - store the file and we're going to store
483:06 - the file in on other peers in the
483:08 - network we don't want to store the plain
483:09 - bites we want to encrypt it with an
483:11 - encryption key that we and only we have
483:14 - so um if you want to retrieve the file
483:16 - we can decrypt it back and we can see
483:18 - the contents of it right so um of course
483:21 - you could say are we going to encrypt
483:23 - the files if we store it on or
483:25 - disk you could you could and maybe you
483:27 - should uh not quite sure if you're going
483:29 - to do that uh but we are going to make
483:32 - sure they are um
483:36 - encrypted uh that they are stored
483:39 - encrypted on our PS of course they want
483:40 - they don't want to see our nudes right
483:42 - so um so what we going to do is
483:44 - basically and I'm going to I'm going to
483:45 - look up some documentation for that uh
483:47 - while I code it because uh it's
483:51 - it's you don't do this any every day
483:53 - right so you cannot know this uh on the
483:55 - top of your head the first thing we
483:57 - going to do is actually let's delete
483:59 - these to bad
484:02 - boys and then we create a new file we're
484:05 - going to make this uh crypto go then
484:09 - what the hell is this what am I doing uh
484:13 - crypto go like this let's close
484:16 - it yes we're going to say package Main
484:20 - and then we going to call this as you
484:21 - can see in our storage right I think we
484:23 - also have something like iio copy uh
484:25 - like this right
484:27 - so we're going to make something like
484:29 - that a streaming a streaming way so uh
484:31 - the very important aspect is we are not
484:33 - going to encrypt them in into memory
484:35 - because like I mentioned before we are
484:37 - supporting streaming that basically
484:39 - means that we don't need to uh read
484:41 - every single bite that is being
484:43 - transferred into memory with only a
484:45 - portion and I think if you want to know
484:47 - how much that's going to be you can see
484:49 - copy here we do copy buffer uh and copy
484:52 - buffer basically here here here here so
484:55 - you see that the size is going to be 32
484:56 - times uh 10 24 right that's basically
485:00 - the buffer that's the maximum amount we
485:01 - are going to read into
485:03 - memory and we're going to do something
485:04 - similar uh with our function and I think
485:07 - we're going to call this um copy
485:12 - encrypt encrypt like this we're going to
485:15 - take an key which is going to be our
485:16 - encryption key it's going to be a bite
485:18 - we're going to take in uh a source which
485:20 - is an IO
485:21 - reader and we also going to take in uh a
485:24 - destination which is going to be an IO
485:26 - writer like this and I think we're going
485:28 - to return the amount of bytes that being
485:31 - written and very important this normally
485:33 - you should say we're going to read and
485:34 - and then we're going to encrypt and
485:35 - write but we're not going to uh have the
485:38 - same bytes written as wrote it as wrote
485:41 - write and read I don't know what the the
485:44 - correct verbs are but we are going to
485:47 - write more buys and we read because
485:48 - we're going to preent or IV which is a a
485:53 - cipher thingy we need that for our
485:55 - encryption right uh so going to say it's
485:57 - going to be an INT and an error like
486:00 - this right okay cool so I'm going to I'm
486:03 - going to a little cheese a little bit uh
486:05 - I need to look things up so I have some
486:06 - documentation here and I will link the
486:08 - documentation in um in the description
486:11 - on of course right so the first thing
486:14 - we're going to do is I think we need a
486:16 - block uh R which is going to be AES
486:20 - we're going to you a we're going to use
486:21 - AES encryption and it's going to be AES
486:24 - rather you're going to say new Cipher is
486:30 - that yeah new Cipher and that's going to
486:33 - be uh we're going to give our key that
486:36 - will return as a block a cipher block
486:38 - first of all we're going to say if the
486:39 - error is not nil we're going to
486:43 - return actually could be ah let's let's
486:46 - return zero and an add
486:49 - here just like that now we have a block
486:52 - let me quickly see if I'm actually
486:53 - recording it's not the first time I'm
486:54 - doing uh these crazy shenanigans
486:57 - it's all fine then we have a block here
487:00 - and we're going to need that block
487:01 - because we're going to create an IV
487:03 - which is going to
487:04 - be and that's the thing we're going to
487:06 - store actually we're going to say make a
487:11 - slice of bite which going to be a block
487:15 - block size and I think this is going to
487:17 - be 16 bytes uh not sure
487:22 - 16 not quite sure if that's true we will
487:25 - see we will see
487:28 - so we have this IV the next thing we
487:30 - going to do is um fill it up with random
487:33 - bytes we're going to say if underscore R
487:35 - is going to to be IO read full right and
487:38 - we going to pass in a reader which going
487:39 - to be a random reader right like this
487:41 - and then we going to say
487:43 - IV uh and if the
487:46 - error is not
487:48 - nil then we're going to return zero
487:50 - because we didn't wrote anything uh and
487:53 - the error here that's fine
487:57 - let me scroll a little bit down to see
487:59 - what what the next thing we need to do
488:01 - uh right we need to make a buffet and a
488:02 - for Loop so we're going to for Loop here
488:05 - right but first of all we're going to
488:07 - make a buffer and a buffer is going to
488:09 - be uh make me a slice of
488:12 - bite and that's going to be 32 * 10 uh
488:16 - 24 which is basically this thing here
488:19 - right that's going to be the buff that's
488:22 - the maximum amount we're going to copy
488:23 - in memory and I think I think I think we
488:26 - also need a stream which is going to be
488:28 - a s is
488:32 - that
488:34 - um we're going to be a cipher
488:38 - actually new CTR okay not quite sure
488:42 - what it all is uh but we
488:45 - need a block and the IV here so we can
488:49 - we can have a
488:50 - stream and actually you could do a
488:52 - VAR to make it a little bit
488:55 - cleaner like this
488:59 - all right so now we can start reading
489:00 - from our uh from our source right we're
489:02 - going to
489:03 - say not got sure if you need the N first
489:06 - of all let's do n yeah we need to n we
489:08 - need to n for some checks actually the
489:11 - amount we read we need that we're going
489:13 - to say
489:14 - here it's going to be Source
489:18 - read we're going to read everything into
489:21 - the buffet
489:26 - right yeah if there is an error I don't
489:28 - think we're going to check the error yet
489:29 - we're going to say if m is bigger than
489:31 - zero that's important and then we're
489:33 - going to say
489:35 - stream uh exor stream that's what we
489:37 - want and we need the buffer and then we
489:40 - also going to say uh the buffer and the
489:42 - buff with the amount of bytes it's going
489:45 - to be yes this right the amount of bytes
489:49 - written uh R actually amount of B red
489:52 - and I'm going to say that the uh
489:55 - destination we're going to
489:58 - write the buff
490:06 - and
490:09 - yeah yes yes yes yes we're going to
490:11 - write everything this stream is going to
490:13 - write everything into this
490:22 - buffer let me quickly see what
490:25 - uh uh
490:28 - bite each bite yeah that's what he wants
490:30 - each bite yes yes yes it's going to each
490:32 - B each bite it's red I'm going to place
490:35 - it back um and and then and then we
490:38 - write uh the thing the encrypted stuff
490:40 - into our destination yes of course we're
490:42 - going to check this uh with an error and
490:45 - if the error is not n uh then we're
490:47 - going to basically return zero and the A
490:50 - and we going to do the amount of btes
490:52 - written later on to be honest what is
490:55 - this this is going to be perfectly fine
490:58 - and this error is here so you're going
490:59 - to say first if the error equals an IO
491:04 - end of file then we're going to break
491:07 - right we're going to break then we are
491:09 - we're done
491:10 - reading and then we're going to check
491:12 - the error so if the S um is not M then
491:16 - we going to return the Ed right
491:21 - yes okay and then here we're going to
491:23 - actually return we need to return some
491:25 - some value we're not going to do that uh
491:26 - quite yet we need to return the amounts
491:28 - we
491:30 - wrote and the thing is that
491:35 - um we also this IV is very important
491:38 - right this thing this IV needs to be in
491:41 - the file because we need that for
491:42 - decryption so what we're going to do we
491:44 - we we could do two things we can either
491:45 - store it and we can append it to the
491:47 - bites or we can prepend it and I think
491:48 - I'm going to prepend
491:50 - it so enable to preent we could say
491:54 - preent uh preent di
492:00 - IV to the
492:03 - file so we're going to say if underscore
492:06 - add is going to be the destination so
492:09 - we're going to write the IV just plain
492:12 - by so we can write it like this and if
492:13 - the eror is not n then basically we
492:15 - going
492:16 - to
492:18 - return zero and the F
492:21 - right and then we're going to start
492:23 - reading yes yes we're going to start
492:24 - writing to the file after the IV is uh
492:27 - inserted Okay
492:29 - cool so let us open up um actually let's
492:33 - make a test right that's going to be a
492:34 - good thing I'm going to say Crypt
492:38 - test. go package Main and we could say
492:42 - test wait
492:44 - Funk test uh
492:48 - encrypt test
492:50 - copy
492:52 - encrypt
492:54 - the uh testing do
492:57 - T what's going on here guys yes save it
493:02 - cool so what we could do is basically
493:03 - say uh we're going to have a a source
493:06 - right and that's going to be uh a b new
493:11 - reader uh new reader like this and we're
493:15 - going to say it's going to be bites and
493:17 - we are going
493:19 - to encrypt um f not bar something like
493:24 - that and actually yeah it's fine and I'm
493:26 - going to say out or a t actually a t and
493:30 - that's going to be a new bytes buffer
493:34 - like that and then we going to say
493:38 - um we could say
493:42 - NF is going to be a
493:45 - copy encrypt I'm going to say I think we
493:48 - need a key actually yeah we need a key
493:50 - that's a problem we don't have a key
493:53 - let's make
493:54 - one let's make a key we're going to say
493:56 - funk and new encryption
493:59 - key uh encryption key and it's going to
494:03 - return as a slice of
494:06 - bytes uh we're going to say how we going
494:08 - to do this I think we can say that the
494:10 - buffer is going to
494:11 - [Music]
494:13 - be key
494:16 - buff going to be make me a slice of
494:19 - bytes it's going to be 32 or something
494:22 - uh and then we going to say um I read
494:26 - for full
494:29 - rant
494:33 - reader into the
494:36 - keyb and then we can actually return the
494:38 - key buff
494:40 - bytes we don't need to we can actually
494:42 - just return it like that so then we have
494:45 - a key buff
494:58 - do we is this a capitalized no it isn't
495:01 - uh new encryption
495:03 - key like that then we're going to say
495:05 - the key is going to be here we're going
495:07 - to say the source is this and then the
495:09 - destination is that file and then we're
495:11 - going to check if
495:13 - F uh is not nil you're going to T
495:18 - error the error the F this this n is
495:22 - going to be zero anyway so we're going
495:23 - to skip that for
495:25 - now and what could do is basically fmt
495:28 - uh print Ln and we're going to say that
495:31 - the
495:31 - destination uh bytes we're going to
495:33 - print the bytes out and let's run this
495:36 - test real quick
495:37 - here all right so we have these
495:39 - encrypted
495:41 - Shenanigans which is
495:44 - cool uh one more thing I actually want
495:46 - to test is basically this one uh Funk
495:50 - Test new encryption key t
495:57 - testing l t and we going to say key is
496:00 - going to be new encryption key and we
496:03 - going to
496:05 - say uh
496:09 - for the length of the
496:12 - key first of all we
496:15 - could uh F key y equals can we do this
496:29 - is that a thing not quite sure if you
496:30 - could do that um zero
496:34 - bytes not quite
496:37 - [Music]
496:49 - sure oh we have it
496:55 - now the question is I think these keys
496:57 - are fine to be honest but I don't I I
496:59 - cannot check it with zero btes
497:01 - right because I could actually do
497:10 - fmt
497:13 - wait I could print out a
497:16 - key uh all the
497:20 - time of course there will be a zero bite
497:23 - right you see
497:28 - I think this key is fine to be honest um
497:31 - I don't think we need to test it it's
497:33 - fine because there will be zero bytes
497:36 - doesn't
497:38 - matter okay so test copy and crypt
497:40 - actually what we're going to do is copy
497:41 - uh test copy and crypt
497:44 - decrypt uh like this right so the next
497:47 - thing we going to do is copy decrypt
497:49 - that's the next uh function we're going
497:51 - to make we're going to say actually let
497:53 - make it at top that's be better for you
497:54 - guys to follow along we're going to say
497:56 - copy
497:58 - decrypt uh we need a key for sure it's
498:00 - going to be bite and then we going to
498:02 - say that the source is again it's going
498:04 - to be an IO
498:06 - reader and the destination is going to
498:08 - be an iio
498:10 - Rider and then U we going to return an
498:13 - INT of course again and an error and we
498:15 - need to fix these inss uh these bytes
498:17 - written and red soon all right not quite
498:19 - sure what we're going to do here do we
498:20 - need a block again let me quickly speak
498:22 - and Peak my um my thingy
498:28 - uh I think we need to block again right
498:29 - so we're going to copy this we make it
498:31 - the block with the key that's what we
498:33 - need now we need to R
498:45 - IV VI IV from the given uh IO
498:51 - reader
498:53 - uh which in our case uh should
498:57 - [Music]
499:10 - be all right so RV from the given I
499:13 - reader which in our case should be the
499:15 - block
499:17 - size bytes we
499:21 - read
499:24 - yeah uh how we going to do this so I
499:27 - think
499:32 - um so we're going to say something like
499:34 - this IV is going to be make me again a
499:38 - slice of
499:39 - bytes which is going to be a block uh
499:43 - block size like this right and I'm going
499:45 - to say if underscore R is going to be
499:49 - the source read me this
499:52 - IV
499:54 - um at not n
499:58 - then we going to return what's going on
500:00 - here uh zero R now we have an IV all
500:04 - right and I think we need to for loop
500:08 - again
500:18 - um now we need again this block right is
500:21 - this stream once
500:23 - again and it's buffer also so I'm going
500:26 - to copy this this I'm going to paste it
500:27 - in here buff stream that's all fine then
500:31 - we're going to do the same thing right
500:33 - we're going to say
500:36 - um n s is going to
500:39 - be
500:41 - Source read into the buff if there is an
500:46 - if n is bigger than
500:49 - zero we going to stream. sour stream I
500:53 - guess
500:57 - again the BFF and the buff um
501:03 - n and then we're going to write the
501:05 - encrypted things the the bites we
501:08 - encrypted back to
501:10 - D we're going to say d
501:13 - right if uh it's going to be NR d right
501:18 - the buffer but we write the buffer what
501:20 - we are what we have read actually
501:23 - encrypted and if the error is not nil
501:26 - then we're going to um caping caping
501:29 - locking we going to
501:31 - return zero R right and then the same
501:37 - thing if add equals
501:40 - IO end of file break if
501:50 - as the thing is could we actually not
501:53 - reuse this
502:01 - wait a
502:04 - minute no we can't right because we need
502:06 - to R the IV in this
502:10 - case some stuff we can actually uh split
502:13 - out because we're copying we copying too
502:14 - much uh uh stuff
502:18 - here but the problem is that a lot of
502:21 - things going to change because we're not
502:22 - going to we will see we will see uh not
502:26 - the end of the world not the end of the
502:28 - world right so what we're going to do
502:30 - here is basically we're going to say let
502:32 - me open up back my OBS so I can see
502:34 - what's going on
502:36 - here
502:38 - uh yeah yeah yeah we're good we're good
502:40 - we're good okay so what I'm going to do
502:42 - here is basically
502:50 - um so we have this this is destination
502:52 - we have our key we encrypted here then
502:54 - we can say
503:00 - out it's going to
503:05 - be make a new Buffet
503:09 - right and I'm we going to say that uh if
503:12 - underscore R
503:18 - is could be
503:20 - decrypt T no what am I saying with T
503:24 - it's going to be the key
503:27 - Source no it's going to be the
503:29 - destination right it's going to be the
503:30 - destination right this destination is
503:33 - going to be the encrypted file and the
503:35 - source is going to be well the new
503:37 - destination is going to be
503:39 - out if that makes
503:46 - sense Arrow out and then we're going to
503:48 - say out and let's make a string here so
503:51 - we maybe we can see what we because our
503:53 - our our encrypted stuff is basically F
503:55 - not bar right and maybe we should also
503:57 - print
503:58 - out the encrypted heat right and the
504:00 - encrypted heat in this case is going to
504:02 - be the
504:03 - destination uh destination string and
504:06 - then the actual string the decrypted
504:08 - string I hope it's going to we need to
504:10 - test actually can we do this let's just
504:13 - test
504:14 - here yes so you see it's working right
504:17 - so we we encrypt it and then we decrypt
504:19 - it and we have F not part which is good
504:21 - it's
504:22 - working and our tests are pausing
504:24 - actually uh what actually passing we
504:27 - need to say if
504:32 - um
504:35 - out
504:38 - string uh is not equal to
504:49 - actually it's going to be F not B
504:55 - right B payload now we can check it
504:58 - actually out string should be the
505:02 - payload
505:04 - T error
505:06 - F
505:07 - expected um encryption field I I don't
505:10 - care I'm going to say encryption field
505:15 - actually decryption field
505:24 - actually all right it's going to that
505:26 - should actually work all fine so we're
505:27 - going to do make test real quick boom
505:29 - everything is fine let me test this here
505:32 - boom uh pass yes yes yes good good good
505:35 - uh so we're going to delete these
505:38 - things uh wait like this
505:41 - yes okay encryption Done Right nice eses
505:45 - encryption uh copy streaming support and
505:48 - I was looking for some coffee but I
505:50 - don't think I have one maybe a little
505:55 - bit it is what it is a little bit
506:00 - caffeine okay so what there's a little
506:02 - problem right so I'm going to I'm going
506:04 - to tell you what's the problem going to
506:05 - be because if you go to server right and
506:07 - this
506:08 - copy
506:12 - um I think what we are doing wait I
506:15 - think also in the limit read there is
506:16 - going to be a problem yes so it's a
506:18 - message size
506:20 - right but the message the me the message
506:23 - is size like this right for we have this
506:26 - is basically 1 2 3 4 5 6 7 8 9 10 11
506:31 - right uh it's going to be 11
506:34 - bytes the problem is that the
506:36 - destination file the encrypted file is
506:39 - not going to be 11 bytes it's going to
506:41 - be 11 plus 16 bytes because um we put
506:46 - our IV right we we we we placed our IV
506:48 - into the file the first 16 bytes
506:51 - normally
506:53 - right so
507:03 - how we going to do
507:06 - this if you go to crypto real
507:13 - quick because if you check this
507:16 - n wait let me let me test something so
507:18 - we're going to do this copy and crypt
507:19 - you're going to say uh
507:21 - fmt you going to say
507:24 - print right and going to say print L
507:30 - Len uh payload
507:37 - right so if you send it's it's not it's
507:39 - not going to be boom it's going to be 11
507:42 - right so it's 11 bytes that's fine but
507:46 - if we print the Len uh this Len out
507:52 - string wait that's basically the same
507:54 - thing wait I'm still stupid I'm stupid
507:56 - you're going to say print alen the
507:59 - destination right the destination is
508:01 - basically the destination of the
508:02 - encrypted stuff wait we cannot do it
508:05 - like here we need to do it here boom you
508:06 - see it's 27 right because that basically
508:09 - means if we do 11 minus 27 have 16 right
508:12 - so the IV is 16 and we can test this by
508:15 - doing um
508:17 - Len block block size
508:21 - right what cannot do l
508:27 - uh print without the fmt why
508:34 - not wait we don't make we need to we
508:37 - have this tested
508:39 - actually boom you see 16
508:42 - right so that's
508:45 - fine so how we going to make sure we
508:48 - return uh how we return the same thing
509:00 - we're going to only check what we
509:03 - wrote so we're going to make an NW n
509:06 - written is basically zero
509:08 - right it's going to be uh it's going to
509:11 - be
509:13 - block block
509:15 - size all right and then each time we're
509:19 - going to write here it's going to be an
509:21 - NW h
509:29 - I don't like this to be honest because
509:31 - we have an N already we have an NW
509:34 - already so uh we going to
509:40 - say this is hard how are we going to
509:42 - call this this variable NN or something
509:44 - I don't
509:45 - know uh going to be NN and here we did
509:48 - our
509:51 - best because we wrote here right it's
509:54 - fine and and so we're going to save that
509:56 - n w plus s
509:59 - NN um what's going on block size in
510:03 - 64 uh and what is this
510:11 - ell is going
510:16 - on oh yeah see I'm I'm stupid
510:22 - um and we going to return and dou you
510:27 - right but that's only in in in uh copy
510:32 - decrypt
510:35 - right uh so we could say
510:46 - this and this is going to be 16 we going
510:49 - to quickly test right we're going to say
510:50 - 16 times basically it's going to be l
510:56 - uh
510:57 - out string we can actually say Outland
511:05 - right yeah but that basically
511:10 - means I'm going to say l payload to make
511:14 - it
511:17 - sure can I say t fail or something like
511:20 - this man I it I mean um all right
511:24 - so that's working fine right
511:28 - I know it's it's it's a bit nasty that
511:29 - we doing this
511:36 - thing because it's important that we
511:38 - return these bites because we're going
511:40 - to need them to send it over
511:47 - right we going to need time to send it
511:49 - over because if we using uh server right
511:54 - let me say it's store
512:04 - you want to say we store a file then we
512:06 - have a then we have basically here
512:07 - because this is locally right this is
512:09 - locally so this size is going to be in
512:11 - this case uh 11 right but then we're
512:14 - going to broadcast y y y and then we're
512:16 - going to say here uh there going to be a
512:18 - stream and we need to REM we need
512:24 - to can we just copy this
512:26 - this because we're sending that it's
512:28 - going to be size it's going to be
512:33 - encrypted so we need to say here plus 16
512:38 - right what's going on
512:43 - here I'm losing my
512:47 - slipper I'm losing my slipper um so
512:50 - we're going to say plus 16 and I don't
512:51 - like the way this is happening
512:58 - because it's a hardcore thing so maybe
512:59 - we
513:01 - should and we don't can unless this size
513:04 - is going to be 11 right so uh
513:11 - 16 it's going to be fine I
513:20 - guess and this needs to be a copy
513:22 - encrypt right so we're going to re we
513:24 - going to first first of all first of all
513:27 - we're going to say our server file
513:29 - server file server options actually and
513:32 - we're going to say that the an key which
513:34 - is going to be a slice of bytes
513:38 - right uh yeah slice of btes like this
513:41 - and then we going to
513:42 - say yeah okay okay okay so we have an
513:51 - Angy and then
513:58 - where is
514:02 - store here what we're going to do then
514:05 - is
514:05 - basically we're going
514:08 - to not use this but we're going to say n
514:11 - r is going to
514:13 - be copy encrypt right and it's going to
514:16 - be the s n key it's going to be the
514:20 - destination The Source what's going to
514:21 - be the source the source is going to be
514:27 - where is that file
514:31 - buffer this is the file buffer
514:34 - here this is our T reader we
514:37 - use for teing here which will then write
514:40 - in file
514:44 - buffer so the source is in the source is
514:47 - the file
514:49 - Buffet yeah and then the p is going to
514:53 - be our destination yes yes yes it's a
514:55 - little bit
514:57 - different then copy works because copy
514:59 - takes in uh the destination as first as
515:02 - first argument in the function right so
515:05 - we can return F in this case and then we
515:08 - can say receive B is this going to work
515:10 - I have no
515:13 - clue let's see let's see uh make run I
515:17 - guess wait wait wait first of all first
515:18 - of all guys very important we need to
515:21 - have an N key in file server options
515:23 - we're going to say um the encryption key
515:25 - it's going to be
515:27 - new encryption
515:32 - key uh let me close up this thing and
515:34 - make run and see if we get encrypted
515:36 - files
515:37 - please let it all work just
515:44 - fine oh yeah yeah of course we are our
515:47 - main is basically we are fetching stuff
515:49 - but we we cannot fetch anything because
515:51 - we don't have anything right so we're
515:53 - going to just do this make a cool
515:55 - picture thingy sleep 5 Seconds no idea
515:57 - why we do that make run and see if he
516:00 - can store that
516:05 - file you see that
516:08 - we received and written by dis is
516:17 - zero
516:21 - Z
516:24 - okay and actually guys I found something
516:26 - like remember in previous episode we had
516:28 - this issue with these folders but you
516:29 - can just click
516:31 - refresh um so we were 4,000 right so do
516:34 - we have our file in plain text yes we
516:36 - have our file in plain text but do we
516:38 - have our file distributed
516:41 - encrypted yes it's
516:44 - encrypted hey that's good right um
516:47 - that's a very very very very goody
517:00 - okay
517:02 - um that's all good that's all good but
517:05 - we had one issue and I think it's
517:06 - basically because we let's open up
517:08 - Krypto I will open up
517:12 - here bytes written to
517:17 - disk because if we decrypt you're going
517:20 - to tell how much we
517:23 - decrypted wait why I'm I'm in the wrong
517:26 - crypto no I am in the right crypto it's
517:28 - fine it's in copy and cryp right that's
517:31 - what we
517:37 - use I think we can we can do the same
517:40 - thing we could say uh this is going to
517:44 - be block and I think we we can make this
517:47 - function even
517:48 - better what's going on oh we cannot do
517:51 - this block size
517:59 - what did we do here
518:05 - NW and then it's actually the same
518:08 - actually the same code we need to be
518:10 - we're going to split that out uh we're
518:11 - going to write to the to the Tangy we're
518:13 - going to say NW is going to
518:16 - be plus equals nn
518:27 - and in this case we're going to
518:28 - basically return uh and W right so
518:32 - basically um we're going to store it
518:35 - right now we should have the correct
518:39 - output that we received and written 38
518:42 - to the dis that's actually not
518:45 - true because we're not encrypting it
518:48 - maybe we should encrypt it locally
519:01 - [Music]
519:08 - um because we're going to
519:21 - write you're going to
519:28 - if we copy and crypt right what do we
519:30 - mean by by this int that means that how
519:32 - many bites that we copied and
519:39 - encrypted right so in this case copy and
519:43 - encrypt it how many why is it we copy
519:44 - and encrypted that's
519:53 - basically H it's it's it's difficult
519:55 - because this block size we actually have
519:57 - the the IV in the file so but we copied
520:01 - [Music]
520:08 - only the file size yeah that's something
520:11 - we need to think about uh we're going to
520:12 - see that because in the next uh I'm
520:14 - going to cut the video out here me if
520:16 - I'm wrong but I think if I do a get lock
520:18 - the previous episodes we did encryption
520:20 - and decryption of our files and I
520:23 - think that we basically
520:26 - yes we could store things and um let us
520:29 - actually rerun this real quick um let's
520:32 - delete these two bad
520:34 - boys H and then we can just say a make a
520:38 - run and see what's going
520:41 - on normally I think it should be
520:43 - distributed and uh let me refresh these
520:45 - folders here we could we going to have
520:47 - 3,000 which
520:49 - is going to have
520:53 - nothing uh and this guy what is going on
521:02 - here we have a little
521:04 - issue is that what is going on here what
521:08 - a nice what a nice way to start isn't it
521:10 - a it
521:13 - um is that a
521:16 - thing what do we have
521:19 - here
521:23 - nothing all right no worries no no
521:25 - worries make run let's see what's going
521:26 - on no Panic we don't we don't
521:30 - choke uh stream closed resume resume
521:33 - that's a
521:37 - thing that's a thing so 3,000 doesn't
521:40 - have the files it it has it has what
521:42 - what's going on uh let us delete these
521:44 - two guys once
521:45 - again delete permanently maybe it was
521:48 - just I don't
521:52 - know so basically right now we don't
521:54 - have any file
521:56 - right no folders no not then that's fine
521:58 - uh let's make run and normally
522:00 - everything should
522:01 - be distributed
522:04 - right M run let's see let's see what's
522:07 - going on let's see what's
522:10 - popping all right received received this
522:13 - this is better
522:14 - right this looks better so we have this
522:17 - guy which is encrypted and then we have
522:19 - this guy which is Al which is not encryp
522:22 - because it's our local dis okay cool not
522:25 - quite sure what happened there I think
522:27 - um I don't know
522:29 - maybe we have no clue let's not worry
522:31 - about it right let's not worry about it
522:33 - okay so the next thing we need to do is
522:35 - basically find a way to retrieve these
522:36 - guys right um and if we open up server
522:39 - on this side and maybe main the other
522:43 - side then we're going to see that
522:46 - um I think it's handle get
522:49 - file is that a
522:53 - thing get get handle get file here this
523:03 - one uh we do a copy
523:06 - here but this is sending right so we are
523:09 - sending the file that's
523:16 - fine right if you get a f yeah yeah yeah
523:19 - I think yeah it's it's get right if we
523:20 - ask for a get here right and we cannot
523:23 - find this on local disk then we need to
523:29 - basically fetch everything from um store
523:33 - right that's a thing right so we going
523:35 - to fetch the files we're going to write
523:37 - but the problem is we're going
523:38 - to we're going to fetch these files in
523:40 - in an encrypted way so store right is
523:43 - not going to work here right so we need
523:44 - to open up
523:47 - store and we need to uh search for
523:52 - right this guy right and right is
523:55 - calling right
523:57 - stream uh but right stream basically
523:59 - just copies here right you see this this
524:00 - IO copy it basically just copies what it
524:02 - gets and that's not good because it's
524:05 - it's encrypted we need to decrypt this
524:07 - so we should replace this with decrypt
524:09 - uh copy
524:11 - decrypt uh the thing is maybe I want to
524:14 - do something
524:16 - like Funk um s let you see that I'm not
524:21 - coding in my uh window we're going to
524:23 - say right
524:28 - decrypt uh which will take an eny uh
524:31 - there going to be a slice of bytes it's
524:33 - going to take in a key which is a string
524:36 - and of course an IO
524:41 - reader uh which will return an N64 and
524:44 - an
524:46 - eror just like this and to be honest
524:50 - everything is the same right you could
524:51 - uh copy the whole ship bang it's only
524:53 - this uh of course we need to make this a
524:57 - little bit
524:58 - better because just copying this is uh
525:00 - maybe not the right idea and this is
525:04 - going to
525:05 - be I think copy
525:09 - decrypt uh but with uh ank key and we
525:13 - need to be careful let me open up
525:16 - crypto copy decrypt takes in a source
525:18 - and a
525:20 - dust the source is uh R and the d f is a
525:23 - little bit different than IO
525:27 - copy and of course I think this F this
525:31 - n is going to be an N than
525:39 - N64 uh which basically means we could do
525:41 - something
525:43 - like
525:45 - this in 64n and then of course the error
525:48 - if there is one so we could check that
525:58 - yeah I'm going to we're going to
525:59 - refactor this real soon but because
526:00 - there's a lot of duplication going on
526:04 - here you see it's the same thing here
526:06 - you could actually just delete this
526:07 - right and just return uh these
526:11 - things actually can we not just return
526:14 - the whole
526:18 - thing look at this it's basically the
526:20 - top part that needs to be refactored
526:28 - yeah okay so how we going to call this
526:30 - right is we have this right
526:37 - Crypt uh so what we could do is
526:39 - basically say something for let's let's
526:41 - let's just test this real quick and then
526:42 - we refected this right so let's do a
526:45 - right CP let's make it public right I'm
526:47 - going to make it public so instead of
526:49 - saying um what is this this crypto we
526:52 - don't need this instead of saying this
526:55 - store right we're going to say n r is
526:57 - going to be
526:58 - s store right decrypt right it's going
527:02 - to be the
527:07 - eny S eny and then we need um the key
527:11 - itself and I'm going to say an iio limit
527:14 - reader and it's spe and of course the
527:16 - file
527:19 - size like this I think you can delete
527:22 - this
527:24 - just the top part actually and now we
527:26 - have the same thing
527:34 - right I think that should be good is
527:37 - that
527:50 - true do we have all the files here yes
527:52 - we have this encrypted sting uh uh so
527:55 - what you could do is
527:56 - delete 4,000 right now we going to
528:00 - comment this
528:02 - out and then
528:07 - this let's see what's going on if we
528:09 - make
528:15 - run ah so it's it's it's yeah I see I
528:18 - see we get we get some stuff we get some
528:21 - stuff but we get encrypted stuff and I
528:24 - think the problem
528:27 - is the problem is
528:30 - actually the problem is this yeah it's
528:34 - this thing it's this new encryption key
528:36 - that's the problem
528:38 - because uh each time we boot up this
528:41 - make run we're going to make a new
528:44 - encryption uh key which basically means
528:46 - that if we have stored something with
528:47 - another encryption key it's not going to
528:49 - it's not going to work out fine for
528:52 - us because it's going to end it's going
528:55 - to decrypt it with a different key
529:00 - right uh so what we could do is
529:02 - basically we could say
529:06 - um let's store this
529:10 - right and once it's stored we're going
529:13 - to say if R is going to be S2
529:17 - store
529:21 - delete um
529:29 - we're going to we're going to copy this
529:30 - everything inside of these
529:32 - brackets of course we need
529:35 - to we're going to say that that is the
529:37 - key we're going to delete it here we're
529:38 - going to say key here and then we got to
529:40 - say get the key not not get the key yeah
529:42 - we're going to get the key but we're
529:44 - also going to delete the key but only on
529:46 - the S2 um
529:49 - server and if the error uh is not n we
529:52 - can um
529:55 - what's going on here I'm going to lock
529:58 - fatal I
530:00 - guess like
530:04 - this right so we're going to we're going
530:07 - to store it we're going to delete it at
530:09 - on on our side and then we're going to
530:11 - fetch it
530:13 - again so it should be uh coming from
530:16 - [Music]
530:19 - um the network so let's delete
530:25 - these two
530:27 - guys now let us see what's going on
530:32 - it let's make and see what's going on I
530:35 - have no clue normally it should
530:40 - work I think it's working right if you
530:42 - get it yeah it works perfectly fine
530:46 - what's going on this is
530:47 - insane uh this is encrypted yes yes yes
530:50 - and this is uh my big data file so
530:52 - that's good
530:54 - it's all working perfectly fine the
530:56 - question rather is can we
530:59 - do all right that's good that's good
531:03 - um all right so there a couple things we
531:05 - need to do we also have something in
531:07 - server we need to fix I think we have a
531:08 - to-do here yes use a multiwriter which
531:11 - is a little bit
531:14 - um
531:17 - better and then we have this thing right
531:19 - so we need to
531:21 - check uh what's going on we have righty
531:23 - Crypt and then we have a right
531:25 - [Music]
531:34 - stream
531:51 - um wait what is this uh we could say s
531:59 - store open
532:12 - file file writing yeah why not you're
532:14 - going to say key do we need the key yeah
532:15 - we need the key it's going to be a
532:17 - string do we need the iio
532:21 - readers I don't think so and it's going
532:23 - to return I think it's OS
532:25 - file as a pointer I guess and maybe an
532:30 - error and I think it could do this right
532:32 - we could uh yo actually delete
532:35 - this paste them
532:39 - here um which we actually then just
532:42 - could return
532:46 - this all right and then we could say f
532:50 - is going to be S open file for writeen
532:53 - uh we need the key
532:55 - right if Ed is not
532:58 - null you can
533:00 - return zero and the errors right and
533:04 - then we're going to return iio copy with
533:05 - this thing which is
533:06 - fine what is
533:10 - this uh we could say
533:13 - n all right and with right decrypt you
533:17 - could do the same thing right we have
533:18 - this copy decrypt this is the complete
533:20 - file we could delete all the sh bang
533:23 - here I could just say FF is going to
533:27 - be open file for writing is going to be
533:30 - the
533:35 - key that's fine uh return zero
533:41 - Ed and then we can do this thing is this
533:43 - going to work perfect I think I think it
533:47 - is this this basically uh eliminate some
533:49 - some some code duplication which is fine
533:55 - my big data file here this is going to
533:56 - be exactly what it
534:05 - is yeah yeah yeah okay cool that's fine
534:08 - taking care of that so right will go
534:11 - right
534:13 - stream
534:14 - um one more thing I want to actually
534:17 - change is basically this
534:21 - right we could do an eny in this
534:29 - we have right and then we have right
534:30 - decrypt I think it's fine write and
534:32 - right decrypt let me copy this real
534:34 - quick uh right stream I'm going to copy
534:36 - these guys and I'm going to paste them
534:39 - below this right because I think that
534:41 - makes a little bit more sense we can
534:42 - call right we can call right
534:45 - decrypt um and it's working perfectly
534:47 - fine so the next thing we going to do is
534:48 - fix this to-do so basically what we
534:50 - could say is that the Pierce is going to
534:53 - be uh
534:55 - a slice of iio writer right and then we
534:59 - going to say 4ore p in range as Pierce
535:03 - and then we going to say that Pierce is
535:04 - going to be a pent uh Pierce
535:10 - Pier like this right and then we could
535:14 - do something like
535:16 - um I'm we going to say that the
535:18 - multiwriter is going to be an
535:20 - IO new is it multiwriter
535:23 - well
535:24 - mul writer I'm we going to say yo all
535:28 - the peers
535:30 - here like
535:33 - that and then we're going to copy this
535:36 - um but we're going to say it's
535:37 - multiwriter and we're going to write
535:40 - this bite right this incoming stream so
535:42 - we can notify every single writer that
535:44 - we are basically
535:47 - um sending a stream by notifying them
535:55 - and then we could do this right we're
535:56 - going to copy this copy
535:58 - encrypt we're going to yada yada file
536:01 - buffer and instead of this pier we're
536:02 - going to say all the peers
536:05 - right uh so we're going to delete
536:08 - this and then we're going to print out
536:10 - that we receive to dis maybe we going to
536:12 - do a print F do a percentage s here and
536:15 - then say
536:18 - uh maybe a new line here received and
536:22 - written you could do this percent D
536:24 - bites to disk and then we're going to
536:27 - say um S transport other like
536:34 - this multireader it's fine millisecond
536:37 - also
536:38 - good let's see if this is going to work
536:41 - uh make
536:48 - run works perfectly
536:51 - fine also fixed uh the next thing I want
536:54 - to do is basically instead of doing
536:58 - um let us let us test how far we can get
537:01 - this thing let's let's do uh maybe 20 or
537:04 - something uh let's paste that in
537:08 - here the key is not going to be this
537:10 - cool picture we're going to say that the
537:11 - key is going to be an
537:13 - fmts uh print
537:16 - F and it's going to
537:18 - be let's do
537:20 - picture underscore percentage d
537:24 - which is going to be the
537:33 - Y do we want
537:36 - jpeg BNG it doesn't matter uh 20 times
537:45 - um all right I think that's good
538:00 - so we're writing 20 times over
538:03 - the okay okay uh now I want to see
538:05 - what's going on here in our
538:08 - folders uh a I see some
538:14 - issues what's going on
538:19 - here this is UN kept it that's fine wait
538:22 - do we need to ah ah that was a l
538:26 - refreshing look at this we have all
538:29 - these files here because we are creating
538:31 - 20 30
538:32 - files
538:34 - um yeah let me see what what's in here
538:37 - all right so we this file cannot be
538:39 - displayed uh yeah it's
538:41 - fine we cannot see what's in there
538:44 - that's
538:49 - crazy yeah I see some encrypted files
538:52 - right yeah cannot open it Y is because
538:56 - uh maybe if there's some character in it
538:59 - a special character that vs code
539:02 - cannot
539:10 - grasp and then of course and these
539:12 - things should be should all be the same
539:14 - thing my big data file right and all
539:16 - these
539:17 - things right
539:24 - yeah it works it seems that it works for
539:26 - me
539:29 - um that sounds pretty good uh let me
539:31 - quickly
539:38 - see all right so can we do some
539:40 - optimizations right that's the
539:43 - thing not make run I want to go to
539:45 - server right
539:56 - something I really want to test
539:59 - um actually what I want to test is if we
540:02 - go to main. goo right why don't we add
540:05 - another server right we could say
540:07 - another server is going to be
540:09 - S3 it's going to be make me a server and
540:12 - that's going to be a port
540:14 - 5,000 and we're going to connect with
540:20 - 3,000 uh of course
540:22 - the what want to say is that we need to
540:26 - have there's not really a way to uh
540:28 - automatically connect to all the peers I
540:30 - know I know normally you should have
540:33 - some peer-to-peer
540:34 - um protocol where you ask for the other
540:37 - peers so you
540:38 - could um do peer Discovery and once you
540:42 - get one peer it sends its peer list and
540:44 - everybody is connected right just like I
540:46 - doing in the poker game um on stream
540:50 - right that that thing poker game has
540:52 - that um that's something we also could
540:55 - do the question is do we need to do
540:57 - maybe we should maybe we don't could be
541:00 - a good exercise for you guys to
541:02 - implement this
541:17 - um because if we really want to make
541:19 - this distributed we need to do some some
541:20 - extra stuff right and then we need to
541:22 - broadcast
541:24 - uh we're going to broadcast is that's
541:34 - true
541:39 - um so we have S3 right so what are we
541:41 - doing
541:43 - here we start as
541:49 - one let's start S two
541:57 - let's start S3 S3 is connected with
542:00 - everyone
542:04 - right let's just test
542:09 - that uh first of all what I want to do
542:12 - is
542:13 - um let's get rid of these folders real
542:17 - quick let's delete
542:19 - them I'm not quite sure what's going to
542:22 - happen here so we have all these folders
542:23 - uh be bu up as three at Port 5,000 we
542:26 - connect with three and
542:29 - four so this can be interesting this can
542:31 - be interesting I'm going to run it and
542:33 - see what's going on just
542:38 - YOLO of course it's going it's yeah I
542:40 - see
543:01 - that's
543:07 - because uh that's because we need to
543:09 - wait here a little
543:10 - bit maybe one second I have no clue if
543:13 - that's going to work
543:26 - question refused who is this guy dialing
543:28 - 4,000 who's dialing 4 oh it's this
543:41 - guy uh what's going on what's going on
543:43 - what's going
543:48 - on wait do I have a yeah I see I'm doing
543:51 - this this should be as three
543:58 - S3
544:03 - S3 that's going to
544:12 - work stuff is
544:16 - happening so that's
544:19 - good I'm curious what's going to happen
544:22 - actually uh let us refresh this boom we
544:25 - have three
544:27 - folders and we have three folders We
544:29 - have this 3,000 we have 4,000 has
544:32 - nothing in it because he has some issues
544:34 - and 5,000 is is doing its thing 5,000
544:36 - should have the files and 3,000 should
544:39 - have the encrypted stuff which is very
544:41 - good the problem is this 4,000 guy
544:43 - what's going on why cannot why why does
544:46 - he why cannot can he not play with
544:49 - us so we make a server right what's
544:52 - going on with make server actually let
544:53 - see next server transport options y y
544:57 - and then we're going to dial probably
544:59 - but we're going to
545:11 - dial we wait a second then this guy and
545:17 - then three is starting
545:21 - here uh is this is this not enough I
545:23 - should be
545:25 - enough I should be enough why can I not
545:32 - connect collection refused who's dialing
545:40 - actually why is it
545:51 - refused why is it refused what's going
545:53 - on
545:55 - my neck hurts I don't know what's going
545:57 - on um they are dialing it's the
546:06 - transport where do we do
546:10 - this the stream thing can can can
546:13 - actually be remove we don't need this
546:14 - anymore good that we see
546:18 - this so we have a new file server we
546:20 - have broadcast get I think it's
546:24 - somewhere at the bottom onp
546:27 - Loop handle
546:37 - message boot up Network so we're going
546:40 - to boot up all the
546:47 - networks what we could do here is
546:48 - actually uh do a print F and make this a
546:50 - little bit better we're going to say
546:51 - percentage s uh so we know who's who's
546:54 - who's doing who's doing stuff uh
546:56 - attempting to connect with
547:00 - remote uh it's going to be percentage s
547:02 - and of course we're going to do a new
547:04 - line and it's going to be S transport
547:07 - other and it's going to be the
547:10 - edit just like that let me quickly see
547:14 - who's calling
547:19 - who uh wait wait wait wait it's the only
547:21 - stuff I know
547:24 - yeah so 5,000 is attempting to connect
547:26 - with
547:28 - 4,000 and attempting to connect with
547:30 - 3,000 that's fine
547:53 - it's it's
547:55 - um it it feels like
548:03 - um 4,000 is not starting on a
548:07 - port we have this uh listen to 3,000
548:10 - listen to 5,000 why is 4,000 not booting
548:40 - so for some reason 4,000 is not booting
548:49 - up although we do it why we say as to
548:52 - start
548:54 - we don't care about this
548:57 - right we care because S2 is going to
549:01 - connect uh it's going to connect with
549:03 - one so we need to sleep a little bit uh
549:06 - yeah times uh I think millisec
549:10 - millisecond is fine to be honest unique
549:13 - millisecond
549:15 - yeah no what am I doing actually what
549:17 - the hell is going
549:18 - on uh 500 or something s to start
549:25 - we do listen and accept and boot out the
549:28 - N the network
549:31 - right I don't understand why it's not
549:33 - booting
549:35 - up you
549:37 - see the TCP transport listening on Port
549:41 - it's not
549:48 - working what am I missing
549:58 - let's do 8,000 or something I don't
550:02 - know no not 8,000 8,000 is a is a is a
550:05 - nasty
550:06 - Port
550:09 - um
550:21 - seven it's not call it it's so weird
550:24 - what's going on TCP transport listening
550:27 - TCP transport listening but 7 of course
550:29 - we cannot connect with remote 7,000
550:30 - because it doesn't boot
550:34 - up okay this is crazy let me open up
550:43 - server fmt uh I'm going to say print F
550:47 - right we're going to say this guy
550:49 - percentage s starting
550:54 - file
550:57 - server on
551:00 - Port actually we don't care because
551:02 - that's support right starting file
551:04 - server maybe a new line S transport
551:13 - other let's make run and see what's
551:15 - going on
551:26 - starting file server listening starting
551:29 - file
551:30 - server listening
552:07 - what do I miss
552:19 - something do I miss something
552:32 - yeah of course I see I don't want to let
552:35 - us quickly do uh let's return here right
552:38 - let's do a return here so we don't
552:41 - interfere maybe it's just coming too
552:43 - late to the party I don't know I I can't
552:44 - really see it maybe you guys already saw
552:50 - it let let let me also select here
552:54 - uh select this is a nasty one not going
552:58 - to
553:07 - lie you see it doesn't want to
553:09 - start what's going
553:17 - on am I missing something S2 S3 S1 S2
553:32 - ah of course of course we blocking oh
553:38 - no oh
553:41 - no a I'm Legit Garbage
553:44 - Guys
553:46 - Ah that's the cool stuff that I'm uh of
553:49 - live recording like you can see how many
553:51 - stupid mistakes do you guys already see
553:53 - me man I'm actually I'm a fraud what the
553:56 -  going on oh so it's so stupid
554:00 - it's so stupid it's funny the problem is
554:02 - we do like this this this is what we had
554:05 - right the problem is this S1 start is
554:07 - basically blocking right this is
554:10 - blocking
554:18 - um is this blocking right so I still
554:21 - cannot start because this is guy is
554:23 - blocking so what you could do is
554:25 - basically do something like this right
554:27 - um can I do go lock
554:30 - fatal then we going to sleep and then we
554:32 - going to say uh go this one I'm not sure
554:34 - if it's going to work probably it
554:35 - is and then we going to go start the
554:38 - third one and if you make run this and
554:41 - you're going to see that they all
554:42 - booting
554:51 - up um what's going
554:58 - on can thing is can we do this that's
555:01 - the question do I not need to
555:02 - [Music]
555:07 - do let's do this and do
555:10 - S2 not quite
555:14 - sure okay cool that's that's what we
555:16 - want to see now we have five right so
555:18 - everybody's connected that's cool yeah
555:20 - yeah yeah okay cool that's what we need
555:23 - uh we finally
555:28 - have so now we have a 7,000 actually
555:30 - what we going to do is um delete all the
555:33 - folders here right how do I do this
555:36 - select this one this one and then delete
555:38 - permanently boom let's get him out of
555:41 - here all right let's do a make
555:44 - run let's going to see what's going on
555:46 - so everybody's connecting 3,000 7,000 4
555:48 - 5,000 yes let's go uh then they serving
555:57 - yes the serving Shenanigans pictures the
556:00 - whole
556:02 - shebang uh let us see let's see what's
556:04 - going on
556:05 - because we're not sure so we have 3,000
556:08 - not quite sure where's this guy
556:10 - encrypted stuff five not quite sure if
556:12 - 5,000 has something uh to be
556:15 - honest yeah he has file seven I
556:18 - don't I the stuff
556:23 - we did it we did
556:25 - it of course of course of course I
556:28 - understand if you're really really going
556:29 - to dig deeper um there is no peer uh
556:34 - peer automatic peer Discovery hey I know
556:37 - there's no automatic PE Discovery um but
556:41 - but but he it doesn't need to be it does
556:43 - it does it does need but for the sake of
556:45 - this tutorial to discourse this
556:48 - series uh I don't think it needs to be
556:51 - because we can take this so far and then
556:55 - within four months we are still
556:57 - developing this
556:58 - stuff
557:00 - right
557:03 - so I'm happy it's working perfectly fine
557:06 - it's distributed we can get files um
557:09 - it's
557:10 - encrypted because we are S2 on our disk
557:13 - it's not encrypted and all the other uh
557:15 - notes and Network have this distributed
557:17 - encrypted so it's all good it's all fine
557:20 - uh I'm very happy we are reaching the
557:21 - end ladies and gentlemen it is what it
557:23 - is sometimes um we cannot keep going
557:26 - forever but uh a couple things we want
557:29 - to do I want to put the dots on the why
557:32 - you know what I mean
557:34 - so um yes yes yes yes yes let us see let
557:37 - us see let us
557:39 - see Okay cool so first things first
557:41 - let's go
557:42 - to uh crypto right this uh what is this
557:46 - new encryption key copy decrypt and all
557:48 - that good stuff right so what what we
557:51 - see here is basically um
557:54 - we have this for Loop right it's
557:55 - basically a copy Loop and this copy Loop
557:57 - is basically exactly the same as this uh
558:01 - copy Loop right so we should refactor
558:04 - that a little bit because uh duplicated
558:06 - code is not sometimes it can be good but
558:09 - sometimes it's bad news so what we could
558:12 - do is basically make a function why I
558:14 - have two copies here uh let open up
558:16 - server it's
558:18 - fine so what you could do here is
558:19 - basically say um I don't know maybe copy
558:22 - stream or something copy stream and then
558:25 - we're going to have
558:30 - um we're going to have a good question I
558:32 - think we have a stream which is going to
558:34 - be is it a
558:38 - cipher Cipher stream yes it's a cipher.
558:42 - stream I don't think it's a pointer we
558:44 - need a a source file which would be an
558:46 - IO reader and we also need a destination
558:49 - which going to be an IO writer we're
558:52 - going to return Le an INT and an
558:55 - error and I think we also need a block
558:59 - size uh we're going to say block
559:05 - size which is going to be an integer I
559:07 - guess something like this
559:09 - right and what we can then do is
559:11 - basically copy uh this uh bad boy right
559:15 - here and paste it in and we going to
559:18 - read the buffer oh wait we need to copy
559:20 - the buffer also I think
559:23 - uh this block
559:26 - size actually I'm going to copy this
559:27 - whole
559:29 - thingy and paste it in here the stream
559:32 - we don't
559:37 - need and this can be the block
559:43 - size and then we can actually
559:46 - return what's going on we can return
559:49 - this NW which is uh n wrote and write
559:54 - it and probably nil here right and then
559:58 - we have this nice copy
560:04 - stream yes yes yes and then we could do
560:07 - something
560:09 - like let's comment this out before we
560:11 - going to delete
560:14 - this I think we can actually return that
560:17 - stuff you can say
560:19 - copy stream which is going to have a
560:22 - stream
560:23 - name a block size a
560:26 - source and a
560:29 - destination and this buffer can be
560:35 - deleted we don't need this actually we
560:37 - could
560:41 - do just that return delete
560:47 - this yes and we could actually do the
560:49 - same thing we can um
560:52 - copy this we can do the same thing with
560:56 - encrypt return this delete the whole She
560:59 - Bang
561:02 - here something like
561:04 - that or something like this I think that
561:07 - should be fine is this going to work uh
561:10 - let us test real quick make run and see
561:12 - what's going
561:14 - on and in the meanwhile I'm going to sip
561:16 - my
561:20 - coffee all looks fine
561:23 - based on the the the log the loggings in
561:26 - the
561:27 - terminal I think it's
561:29 - fine so we want to delete
561:32 - this boom
561:35 - boom all right so that's being fixed now
561:39 - we have this nice copy stream which
561:40 - basically um prevents us from
561:42 - duplicating this copy code which if we
561:44 - need to adjust something uh we only need
561:46 - to adjust it at
561:48 - one place all right the next thing I
561:51 - want to basically tackle
561:53 - is um if we store a file right if we
561:56 - store a file uh we need to provide a key
561:59 - and if we store this on our
562:01 - own um storage local storage local
562:04 - server local
562:06 - machine it's fine that we say hey store
562:09 - for example
562:11 - um mind n. gpeg but if we basically
562:15 - going to distribute that we already
562:18 - encrypt a file which is which is fine
562:21 - nobody needs to see NES right but the
562:23 - problem is it still can see we still put
562:27 - the the key the name of the file the key
562:30 - in plain text so they can see what it is
562:32 - and that's also not uh a good uh
562:36 - practice right so we're going to fix
562:39 - that and how we going to fix that is I
562:42 - think we could
562:44 - do maybe we can do it in crypto by the
562:47 - way in this file new encryption key we
562:50 - could say funk for example uh
562:53 - um hash
562:55 - key key
562:58 - string returns a string for
563:00 - example and we could do we could do any
563:03 - hashing function we want we could even
563:05 - make this an
563:06 - interface we could say for example the
563:08 - hash is going to
563:10 - be maybe an
563:12 - md5 sum of the
563:16 - key it needs to be bytes
563:19 - right so let's make it a bite slice
563:25 - what's going on here my cap lock is
563:28 - turned on and then we can actually
563:30 - return a
563:31 - hex uh and go to string of the
563:35 - hash and do it like this so we have a
563:37 - nice
563:39 - slice there's basically a simple
563:41 - function which will hash the key in an
563:42 - md5 which a oneway a oneway hash
563:44 - function right so there is no way they
563:46 - can
563:47 - [Music]
563:48 - um you can even make it a sha 256
563:51 - whatever uh but there's no way that they
563:54 - can see what's inside of um of that
563:57 - hash only we know that so we could do uh
564:01 - if we going to
564:02 - store right and we going to
564:06 - say if you want to distribute this
564:08 - message right this thing here we could
564:10 - say uh instead of the key we could say
564:12 - hash
564:13 - key uh put in the
564:18 - key and if you want to retrieve that
564:28 - all right if you come from local storage
564:30 - can be the key the plain text but if we
564:32 - uh want to fet this then we need to
564:34 - basically hash it again so we're going
564:35 - to say hash
564:37 - key like
564:39 - this make a run and that should actually
564:42 - be the same
564:44 - thing although it's going to have
564:46 - another
564:50 - pattern but that doesn't matter because
564:52 - it's is going to fetch it anyway
564:56 - right yes yes yes uh Clos and all that
565:00 - stuff Big Data file is coming out
565:01 - everything is working as intended so
565:04 - that's
565:06 - fine
565:08 - um all right the next thing what we need
565:11 - to do is we have we have actually a
565:12 - problem and I was not quite sure if we
565:14 - should should support it but I think
565:15 - it's a good way um I'm going to show you
565:18 - how to do is basically um for example
565:21 - what we doing now is if we don't have
565:23 - the file locally right we
565:26 - just going
565:28 - [Music]
565:30 - to send a message yo give me this file
565:34 - name the problem is that what happens if
565:38 - we don't know that file name right
565:41 - because some maybe our house is exploded
565:43 - or something I don't know and we
565:45 - actually don't know what files we had in
565:47 - our storage then how are we going to
565:50 - sync right because if we don't know the
565:53 - key we cannot fetch it we cannot ask for
565:55 - the key so how we can solve that is by
565:57 - um and I said like I mentioned before
565:59 - you can make this as complex as you want
566:02 - you could even do it with the public key
566:04 - private key and then sign your your your
566:06 - things and sign your messages and then
566:08 - we could validate and all that stuff so
566:11 - only you can store to your
566:14 - um ID which is what we're going to
566:16 - create so uh enable to fix this is
566:19 - um what we do now let me open up store
566:22 - actually I'm going to open up the other
566:24 - side by the way uh if you have store
566:26 - here for example let's go at the top
566:28 - what we do now is basically we create uh
566:31 - a pad right we create a pad and that pad
566:33 - is basically based on a
566:34 - transform
566:36 - um on a transform Funk based on the key
566:39 - we give it right and the key is for
566:42 - example it could be a file name and the
566:45 - file name could be
566:47 - um clown. gpeg right we're going to tr
566:52 - transform this file
566:54 - name right and that's going to return as
566:56 - a
566:57 - key um which is going to be a pad
566:59 - actually it's going to be a pad right
567:02 - and then we have a
567:03 - root we have the root of the of the
567:05 - folder right and we're going to have a
567:07 - pad right so what we're going to do is
567:10 - basically is we could do we can store it
567:13 - in a root because that's where we're
567:14 - going to store everything right files
567:16 - from from from everybody that that want
567:19 - to distribute his files and or files but
567:22 - we could actually do something in
567:24 - between and it's going to be a root and
567:26 - then an ID right and it could be a PB
567:30 - key uh if you want that could be uh some
567:33 - kind of a random ID or a random string
567:37 - uh if you know what I mean so basically
567:40 - if we then need to sync the only thing
567:41 - we could do is ask for a sync and give
567:44 - it um this random string right which
567:48 - basically is a random identifier of our
567:51 - storage of or server whatever note
567:54 - whatever you want to call it and then we
567:55 - can actually fetch all the files inside
567:57 - of it and send it over right so how can
568:00 - we Implement something like that
568:04 - um without doing too much
568:08 - refactor and it's basically something
568:11 - like
568:18 - um that's actually a good
568:20 - question we could do
568:27 - um if you go to crypto right we could do
568:29 - something like uh not quite sure if
568:32 - crypto is a good thing to do a good
568:34 - place to do it you could do it in a util
568:35 - function or something but hey um but you
568:38 - could to be honest it would be nice to
568:40 - have a public
568:41 - key uh enabl to to that to do some stuff
568:44 - with it but I'm going to use a simple ID
568:47 - right you're going to
568:48 - say generate ID which will return a
568:54 - string uh like this we could say for
568:58 - example uh it's just for to give you
569:00 - guys some ideas right because for you it
569:02 - would be nice to um extend this um
569:07 - forever store extend this distributed
569:08 - file storage with some of your own
569:10 - functionality to um to learn navigate
569:14 - through the codebase and to implement
569:17 - your own IDs right that's that's the
569:19 - best thing you could do but you could
569:20 - you could watch this series forever
569:22 - it's very important it's a very big
569:24 - mistake I also made in my uh career is
569:28 - what a lot of people or mistakes a lot
569:30 - of people making and it's not only with
569:31 - coding it's with everything they watch a
569:34 - lot of videos which is good which is
569:37 - very good right but they keep
569:40 - watching they keep watching but they
569:43 - don't do it's good that you watch but
569:46 - it's also very important that you do
569:49 - stuff and figure things out it's it's
569:51 - also very
569:53 - important so we're going to say uh let's
569:55 - say we're going to make a buffer which
569:57 - is going to be make me a slice let's
570:00 - call it
570:01 - buffer make me um a slice of bite let's
570:06 - make it 32 right and then we're going to
570:08 - say IO read
570:11 - all or read full I think it's read
570:15 - all is that I think it's read full and
570:19 - then we going to say IO um it's not it's
570:22 - not that it's going to be a Rand reader
570:24 - right I'm going to read above right and
570:26 - I'm going to say return
570:29 - hex and go to Str one of my favorite
570:31 - functions by the way X and go to string
570:32 - we're going to and goe this the buffer
570:34 - right that thing and now we have a nice
570:37 - uh ID right and you can already see it
570:39 - coming with this 32 you could you could
570:40 - use a PB key and then you could actually
570:43 - uh enhance this file server so every uh
570:47 - message we sent is going to be signed
570:50 - with the PB key and then uh you could
570:52 - store everything at the PB key location
570:54 - and you could check if the message is
570:56 - coming um is exactly from from the guy
570:59 - that wants to store and retrieve stuff
571:01 - to make it even more uh cryptographical
571:04 - secure
571:06 - right
571:09 - um generate idea Okay cool so what we
571:11 - could do is basically in server no in
571:14 - main or in server actually or maybe in
571:18 - rops store that's what we need and did I
571:21 - code into let me open up crypto did I
571:23 - code into my screen no I need
571:28 - to make sure that's not happening so
571:30 - let's open up store here yes what we're
571:31 - going to do is we have this
571:35 - um store UPS Store up so we have this
571:38 - root let's give it an identifier which
571:40 - is going to be a string
571:42 - right
571:46 - um ID of the
571:49 - owner uh of the storage
571:57 - storage uh
571:59 - which will be used to
572:05 - store all files at that
572:10 - location
572:15 - so we can
572:17 - sync all the
572:19 - files if needed something like that
572:25 - right what's going on everybody sending
572:27 - me
572:29 - messages um yes yes yes yes yes we have
572:33 - this
572:34 - ID if you're going to make a new
572:38 - store are we going to make an
572:42 - ID we could do that right you could say
572:44 - if L Ops ID is zero then we're going to
572:49 - make one
572:52 - right if somebody forgot I'm going to
572:55 - say op uh ID is going to
572:58 - be generate an ID just like that I
573:01 - cannot do this is fine so now we have an
573:05 - ID and then we could say in
573:08 - storage is basically if
573:11 - we open file for writing is that what we
573:15 - need yes so you can
573:18 - see we do a root which is this one and
573:21 - then we do the pad key right and we
573:23 - could do something in between and that's
573:26 - going to be the
573:28 - ID something like
573:42 - that uh what is
573:48 - this s root pad key I think we need to
573:51 - provide here the ID
573:55 - also just like
574:02 - that and now we need to do the same
574:05 - thing with the read stream right so the
574:06 - read stream is getting the root and we
574:08 - also need the
574:13 - ID like that as root then we going to
574:16 - say S
574:19 - ID like this
574:22 - hands are
574:24 - cold tell me something new
574:27 - hey all right so I think
574:30 - um if you open up store test
574:38 - actually not quite sure if this already
574:40 - going
574:48 - to expect to have keu we have some
574:51 - issues in our tests
574:57 - actually expected
574:59 - to have
575:01 - key this
575:03 - one expected to have key y y
575:06 - y uh but
575:10 - got I we don't have it
575:22 - ah I think it's has that's a problem um
575:25 - the problem we have with has we need to
575:26 - yes yes that's what I was thinking so of
575:28 - course we have the root and we also need
575:30 - to provide the ID here um as ID and
575:35 - maybe that's going to work a little bit
575:37 - better make test
575:39 - actually all right expect it to not have
575:43 - key uh I think a problem is that it's
575:45 - not deleted yet
575:49 - right uh let me
575:52 - delete these files real
575:55 - quick man this Windows this Windows
575:58 - signing B is crazy blowing up my ears uh
576:02 - I think we don't delete this where is
576:05 - delete right ex ex exactly right so we
576:07 - have again uh we need to refactor this
576:10 - that we have the ID of the
576:12 - storage like that
576:16 - right make Test please boom yes yes yes
576:20 - yes that's fine
576:22 - so let's us hope that make run is going
576:24 - to work perfectly
576:34 - fine and I think it is good good time to
576:38 - set the
576:41 - coffee uh
576:43 - yes all right all right right let's see
576:45 - let's see let's see yes we have these
576:46 - nice
576:47 - falters uh of course you can see that I
576:50 - think we do it with
576:53 - um 5ou I don't know I don't know who the
576:56 - guy is but you can see that these
576:57 - folders right um these
577:00 - pads are basically not the same as this
577:03 - 5,000
577:05 - pads um you can see but these are the
577:07 - same right so this one these pads right
577:10 - these folder pads are the same as the
577:13 - 7,000 one but they not the same as the
577:16 - 50001 right and that's because the 50001
577:18 - is the guy that is uh storing stuff and
577:21 - and and make it distributed so the two
577:23 - other servers uh in the network they
577:25 - will have the encrypt the hashed version
577:28 - of the key which will translate into a
577:30 - different pad right uh so they don't
577:33 - know the contents of the file because
577:36 - it's encrypted but all they don't also
577:38 - do not know the contents of the key
577:39 - which is amazing super secure well super
577:43 - private um like
577:46 - this uh and I think it should work right
577:48 - so if we man yeah encrypted stuff that's
577:51 - fine
577:52 - and then 5,000 should have the that my
577:55 - big data file is see these things come
577:57 - together is so nice um yeah and you can
578:00 - see what happens right so you you can
578:02 - see that this is the ID
578:05 - right this is the uh e77 A6 right uh
578:11 - this is a
578:18 - problem we we made a big mistake by the
578:21 - way
578:23 - we made a big mistake because they're
578:24 - storing these files inside of
578:29 - um it's good that we have an ID that's a
578:32 - that's a fact but
578:33 - [Music]
578:39 - um I was just thinking about I made a
578:41 - mistake guys you can
578:43 - see uh I also make mistakes um but we
578:46 - identified it which is good so basically
578:48 - the problem is that if we retrieve a
578:49 - file it's going to retrieve from the ID
578:50 - from the storage uh so it works all fine
578:53 - but it's it it's not working like
578:55 - intended um so what happens if somebody
578:58 - is storing it needs to store at a
579:00 - certain ID so instead of
579:10 - um anony anony anony so instead of
579:13 - storing at our own ID uh let open up
579:16 - server it's fine server is on the other
579:18 - side
579:22 - yeah so I
579:25 - think to be honest let's refactor
579:31 - this sometimes it's funny uh but I wait
579:35 - where is this this this thing this ID
579:36 - thing let me find
579:39 - this uh ID soorry yes I think we need to
579:42 - move the ID to the
579:46 - server yeah we're going to delete the ID
579:48 - guys we're going to delete the ID guys
579:50 - and girls and if I say guys it means
579:53 - guys and girls you know what I mean it
579:54 - means everybody I
579:56 - know uh we're going to delete this
580:03 - right
580:10 - okay damn damn damn
580:14 - damn no we going to I'm going to we're
580:16 - going to do it like
580:18 - um it's a mistake
580:21 - and we're going to we're going to we're
580:22 - going to take the pain we're going to
580:24 - take our mistake and we're going to
580:25 - refactor it that's sometimes what it is
580:28 - uh we can go the easy
580:30 - route and re-record the video but I'm
580:33 - I'm not that guy and you guys know that
580:36 - um that's engineering and I want to see
580:38 - engineering at its
580:39 - finest and um if you make a mistake you
580:43 - need to take it as a man you know what I
580:46 - mean and that's what we're going to do
580:48 - I'm going to take it as a man
580:51 - so we're going to delete this and I hope
580:53 - you understand what what's the problem
580:54 - right so because we storing it at our
580:55 - own ID which basically has the same
580:57 - problem we already had before I think we
580:59 - need to um refactor the code a little
581:02 - bit if if we write and read we need to
581:04 - specify the ID of uh the location where
581:07 - it's get um the ID of the other note it
581:11 - could be our ID but could also be an
581:12 - other ID it's very important and that's
581:14 - the only way we can sync uh if we don't
581:18 - know we can basically sync the whole
581:20 - folder to a server right if you really
581:22 - want to implement that later on if you
581:24 - know what I
581:26 - mean okay so I think we are back these
581:28 - folders are pretty are are back at the
581:31 - state they need to be which is
581:34 - good
581:37 - um luckily we didn't refector that too
581:45 - much yeah I think it's fine to be honest
581:47 - I think we can we can make test and it's
581:49 - going to be all good yes
581:52 - all right right right right it it's nice
581:54 - it was good it was good it could be it
581:55 - could be much worse
582:00 - so how we going to fix this um we are
582:03 - going to say we're going to server here
582:06 - and we're going to say server Ops I'm
582:08 - going to give it an ID it's going to be
582:10 - a
582:12 - string uh we could do we need
582:15 - to it is fine it is fine
582:21 - uh what we could do is
582:26 - basically we could do like this right so
582:28 - if
582:31 - Ops uh ID wait we could say
582:34 - Len that's how I check if variables uh
582:37 - strings are
582:39 - empty could do it whatever you want
582:41 - we're going to say if L op ID is empty
582:43 - we're going to say Ops um ID is going to
582:47 - be generate ID so that's going to be
582:50 - always fine so we don't need to specify
582:51 - it it will generate an ID for us if you
582:54 - don't specify it and if you specify it
582:56 - it will use that
583:07 - ID yes so what we're going to
583:14 - do
583:17 - man we could say get the the key as a
583:20 - stream you could also say from from
583:22 - which ID we want to
583:24 - read
583:40 - right wait I'm thinking wait wait wait
583:42 - this is already in server
583:45 - um we don't need it here
583:53 - no no no because we could send yeah yeah
583:55 - wait wait let me open up store first
583:56 - store is the most important thing right
583:59 - now
584:02 - um right so we could do something like
584:05 - this
584:07 - um I'm thinking is this going to work
584:09 - with with with read and
584:11 - write let's open keyf write
584:15 - then okay so it's going to be it's going
584:18 - to be some nasty and maybe we should uh
584:20 - introduce uh um another episode for this
584:24 - or I could actually do it in
584:26 - one we could actually complete it here
584:28 - maybe so we're going to say
584:31 - um we need to prefix this with an ID
584:34 - it's very important we're going to say
584:41 - string and then we going to say
584:43 - percentage
584:46 - s going to be the ID right open file for
584:50 - wren
585:02 - ID
585:08 - um yeah the same thing here ID is going
585:11 - to be a
585:12 - string uh it's going to be the ID that's
585:14 - fine reading is going to be the same
585:16 - thing right we're going to say ID
585:19 - string ID here
585:21 - it's going to be a problem in uh read in
585:24 - read stream right I'm going to say ID
585:27 - string uh this going to be a percentage
585:30 - s it's going to be the ID right just
585:34 - like that all
585:36 - fine um write
585:40 - decrypt ID
585:46 - string
585:48 - ID key
585:53 - fine
585:55 - write we need an
585:57 - ID an ID string which is going to be
586:02 - ID uh no it's going to be ID
586:08 - key delete the same
586:15 - thing percentage s is going to be an ID
586:30 - yes and has is the same thing it's going
586:33 - to be an uh
586:35 - ID string you could you could see an ID
586:38 - as an extra key right
586:41 - um as an extra key where it's stored so
586:45 - we can actually do do some advanced
586:47 - stuff with it uh the question is what's
586:48 - going on here did we actually have have
586:50 - everything 10
586:57 - ID key yeah yeah yeah file yeah right
587:00 - the Crypt
587:02 - ID
587:03 - yes write
587:06 - yes delete
587:09 - yes has also I think we're good of
587:14 - course now we have trouble uh in our
587:16 - storage here
587:25 - uh so we're going to say new store and
587:27 - maybe we need to make an
587:34 - ID and put this ID
587:39 - here and ID here it's a little bit of uh
587:42 - tedious uh operations I I
587:46 - know I'm going to make test
587:51 - okay server is complaining I know I know
587:54 - I know I
587:55 - know
587:59 - right if you want to get a
588:02 - file you're going to say it's going to
588:03 - be as ID right and then the
588:13 - key so then we don't have it locally
588:16 - right then we need to actually uh
588:18 - upgrade this uh payload message
588:21 - we need to we need to specify an ID
588:23 - which is going to be as
588:24 - ID we need to send our ID over right
588:27 - that's very important uh where is this
588:33 - message I have no
588:36 - clue let me quickly GD into this message
588:39 - right you're going to say the ID it's
588:41 - going to be a string
588:42 - actually this guy this guy it's going to
588:45 - be string size fine but we also need an
588:47 - ID actually we can do it at top uh and
588:50 - and that's going to be a
588:53 - string but i' also think we need this in
588:56 - get
588:57 - file all right that's
589:08 - fine so we specify an ID here let's put
589:11 - it at top it doesn't really matter it's
589:13 - just an
589:15 - OCD um and then we're going to read our
589:17 - key based on our ID
589:21 - like this and then if we
589:23 - store we need to specify an ID actually
589:26 - is it yes it's or
589:29 - ID the key then we're going to
589:32 - send that we need that this guy needs to
589:35 - store this uh at R
589:39 - ID all
589:47 - right handle message get read if store
589:50 - has
589:52 - uh it's going to be from this
589:56 - guy message ID we're going to read this
590:04 - guy wait I get wait so first of all need
590:07 - to
590:15 - Surf um
590:22 - wait because this is handle get
590:27 - file we first going to check if we have
590:41 - it I think it's going to be the message
590:44 - um ID not quite sure
591:07 - and then we have this one handle store
591:11 - file from this
591:18 - beer so I think we need to store this
591:22 - on the message uh ID
591:27 - right let me see if make test is
591:30 - working we still have not enough in Main
591:34 - and in servers
591:37 - 112 yeah righty cryp the I see
591:54 - yeah so we broadcast our ID this is
591:55 - going to be as ID this going to be R
592:02 - ID uh which is basically after this
592:05 - encrypt if this is going to work from
592:06 - the first time I'm going to
592:08 - be uh it's going to be this one and I
592:11 - think we still have some issues in our
592:16 - test here here here in right stream
592:28 - make test real quick um it's a problem
592:31 - in main that's
592:36 - fine so we want to delete
592:40 - um
592:44 - S3 it's going to be S3 ID right so
592:46 - that's going to be fine let's make
592:48 - test yes okay test is working
592:51 - uh okay I'm not quite sure if if if our
592:53 - thing our Serv is going to work um could
592:57 - be that you made a little mistake but
593:07 - hey okay it seems
593:14 - good it seems good seems good so how can
593:17 - we make sure that that is going to I'm
593:18 - going to refresh these folders because
593:20 - let me close all these guys here what's
593:22 - going on right let's refresh okay so we
593:25 - have these three uh three people in the
593:27 - network and I think it's 5,000 is going
593:30 - to be the guy we need yes 5,000 is the
593:32 - guy we need so he
593:35 - has uh two thingies I
593:39 - think some relics from from the past
593:42 - right um wait let me let me delete these
593:45 - folders and run again because it's going
593:46 - to be confusing as
593:49 - hell it's going delete the whole sh bang
593:51 - and then we're going to run again and
593:52 - then we're going to see if these um ID
593:54 - folders are are correct make uh a
593:58 - run and if so we are in a good spot
594:09 - right yada yada
594:12 - yada yes okay cool uh let's see what's
594:15 - going
594:16 - on so we have
594:21 - yeah I think this is fine right because
594:22 - we have this ID from
594:25 - 5,000 and they all have this ID and they
594:29 - store everything uh or files at this ID
594:33 - right at this uh thing which is
594:35 - perfectly fine which is was it intended
594:37 - so now our server works like a complete
594:40 - works like a dist like a distributed
594:41 - file server and if we um for example if
594:46 - 5000 doesn't have this folder
594:49 - anymore uh he he can either sync the
594:52 - whole folder
594:53 - right he can sync the whole folder or he
594:57 - or he can um ask for a specific file if
594:59 - he wants and people will exactly know
595:01 - where to find it because it's his ID um
595:04 - it's in his
595:06 - ID subfolder if that makes sense right
595:10 - so uh I think this was it for the um for
595:14 - the distributed decentralized file
595:17 - server file storage and um something I
595:21 - want to give uh I want to give an
595:22 - assessment for the people that are
595:23 - watching these series something that you
595:26 - can do it it's not mandatory of course
595:28 - it's what what you want um and what I'm
595:31 - going to what I'm going to give you
595:33 - is if you can see we have get right and
595:36 - we also have um store right we have
595:40 - these
595:41 - two uh apis we can use for our storage
595:45 - but what we don't have is delete right
595:47 - we have delete in our store but we don't
595:49 - have delete in our server so the the
595:51 - assessment I want to give you guys is
595:53 - Implement delete right that basically
595:55 - means it needs to delete the file on or
596:00 - on
596:01 - our local machine but it also needs to
596:04 - delete it needs to send a message to all
596:06 - of our peers we're connected to so it
596:08 - can also delete a certain file on their
596:13 - machine right that's the assessment I'm
596:16 - going to give you not too hard not too
596:19 - simple uh I think it's a very nice
596:21 - assessment and I'm going to uh when it's
596:24 - done you can DM me on patreon or
596:26 - whatever you know where to find me and
596:29 - uh I'm going to review that and give you
596:30 - some feedback on your implementation
596:33 - right that's what I'm going to do
596:37 - cool um yeah cool thanks for being a
596:42 - part thanks for um being in the
596:44 - community or whatsoever for the support
596:47 - and I see you on Discord on a video or
596:50 - on live stream thanks for watching
596:52 - bye-bye

Cleaned transcript:

learn how to build a decentralized fully distributed content addressable file storage system using go that can handle and stream very large files starting from scratch you'll learn how to create a peertopeer TCP library and go this course covers system design lowlevel programming and network protocols all while building a highly practical and scalable application Anthony GG developed this course ladies and gentlemen this is it this is going to be the 10hour plus video a full project where we are going to build a decentralized and fully distributed content addressable file storage that can handle very large files right that can stream very large files we going to build this completely from scratch we're going to build our own uh peertopeer TCP Library uh all from a blank page in goang I wish you the best of Lu guys because if you can complete this and you understand what's going on which you probably will you are going to be a goang maniac trust good luck and see you soon first of all first of all let's start with the basics we're going to make a main goal file I'm going to say package main what's going on here like this and let me say funk main so we can actually test things man I need to warm up not going to lie uh Funk main you're going to say fmt print Ln you're going to say we go Gucci like this and then we also what is this mmt doing whatever it is what it is sometimes a compiler cannot follow we're going to say a new folder actually maybe we should make a make file first right uh make file we going to say go I'm going to say build uh output is going to be bin FS maybe forever store like this then we're going to say run which always will do a build and then we're going to say do SL bin fs and maybe of course testing and that's going to be go test the whole sh bang uh and maybe minus for boss right you could also do dash dash race here but I don't know um cool okay is this working make run uh what's going on here go build go mod oh yeah I see maybe we should do go mod init can we do this GitHub um com andm forever store uh we Gucci okay and I'm going to do this um going to place ATS so we don't have these uh outputs in our um terminale make run we guci all right so we ready to get this party started so I think we're going to make our peertopeer lip first or maybe we switch things up and then we can go over to our disk uh storage which is basically what what what I think is going to happen is we just um going to send a file we're going to Hash that file uh just a hash a simple hash so we can have a nice key we're going to use the hash as a key then we going to add some kind of an in face Funk to transform uh the key to transform the the hashed file name yeah and then uh we're going to make these subfolders just like get does we're going to make these sub folders uh maybe in pairs of two store the actual encrypted data somewhere there and then we can have a nice way to uh do versioning of this files maybe we I don't know versioning um and all that good stuff right that's what we're going to do so we're going to do a lot of uh working with readers writers uh read closers and all that that goodu we even going to make a cash and an index system and all that beautiful stuff man it's it's insane um but first but first but first things first of course uh let's close this file and maybe let's close main we are going to make we have this bin we're going to make a new folder that's going to be peer topeer all right and iner to Pier I'm going to make a new file maybe I can call this transport port. goo package peerto peer because we're going to make things very uh generic right um like it was a real Library so I think uh maybe we should first do TCP and then we can actually see what kind of things we need to do for our interface not quite sure or maybe we can do something like type uh Pier which is going to be an interface uh like this of course and then we could have something like a type transport interface all right I could say uh transport is anything that um is anything that handles the communication communication uh between remote between notes between the notes uh in the network yeah and for for document uh if you're writing documentation on your functions you should always start with um this word should be the first word here right and then we could say something like Pier is Pier represents actually Pier is anything of no Pier is an interface that represents the remote node right that's what a p is right A lot of people don't know but appear is basically just the remote node it's a representation of the remote node of the remote connection of the the dude or the girl that is dialing us or the dude or the girl we are connecting to so of course these interfaces are actually um empty for now uh so basically uh T is is anything that handles the communication between no and the network this uh can be of the form TCP UDP web sockets right going to make some documentation maybe we'll make it better I don't know um it is what it is but I'm teaching you best practices right okay so what I'm going to do is real quick start with the TCP because I think if we have the TCP right we can uh derive what kind of uh interfaces functions we need to have we need to implement and um yeah yeah uh it's going to be TCP wait it should be TCP and then transport right and you see where where it is going right you could make your UDP transport and whatever transport you want right uh in separate files uh as long as they implement the transport interface and actually maybe transporter interface should be better but I don't think it makes sense uh in goang they want you to make interfaces right but I mean why interface not interfacer then hey anyway uh we're going to say type can you please close this yes it's going to be type TCP transport going to be a strict uh I thing is that we need to be very careful so we can actually have something that we can Implement in all our other projects so we need to we need to engineer this like a boss right TCP transport um man that's a good good idea a good thing what what are we going to I think we need to have a listen add actually no I'm going to start I thought was I thought making some configuration for this uh configuration uh listen address and that's going to be a string maybe you want a listener and that should be a net listener which is an interface like listen listener yeah and I think the transport should be responsible for holding its Pierce right so we could do actually this listener I don't like that it's I'm going to make everything private for now and we will see if we need to make something public we will check how uh but I think starting with everything private makes a lot of sense uh Pierce is going to be a map of uh Pier right it's an interface no not Pier it's going to be a map of string and maybe we should make our own type for this um we could use a net other like this actually that makes a lot of sense to be honest to use this um that makes a lot of sense and we will see but it's not going to be the address I'm trying to think out loud right uh I think you B that's good that will benefit you more than just copy pasting stuff uh let's start with a net Adder we will see we will see uh because a net Adder if you open this it's basically nothing more than Network and string right it's it's it's a super easy interface to use and it makes a lot of sense so uh GD right you need to do GD and you're here if you use the Vim plugin um P map adder and then we're going to say it's going to be a pier right and if we open up our uh normal transport thingy we see Pi is going to be an interface that represents the remote note right so it's going to be this and we need to have um an AMU right and a mutex and I think you could call it am but maybe a PE lock actually we're going to call it a it doesn't really matter you will see because if you have different m texes how you going to handle that right uh that's going to be a sync uh RW mutex right and you see how you need to group things right because we have this map and we have this mutex right and this basically means it's a common practice in goaling that you do this uh that you put your mutex above the thing you want to protect it so we can see oh this mutex will protect the Pierce right um that's good then you're going to say funk new TCP transport uh it's going to be l n like this going to be a string should it be a net adder or we going to create one H good question and that's going to return we we have a couple options we could return a TCP transport like this right and then say return um TCP transport and say that the listen address is basically the listen address we give it like this right uh but we can also say we can also make this actually a little bit more convenient and say hey this is going to be a transport right of course if you're testing this if you make a test right let's say you have a test here Funk test test things uh the problem is of course that if you want to test this thing and you say for example uh t transport T is going to be a new TCP transport like this right and you give this an address like I don't know could be anything the problem is you cannot say t listener right you see it doesn't work because yeah even though you need to cost this to uh a TCP transport like this and then it's going to work right except you see decisions you need to be make that need to be made and I want to show you this kind of stuff because um yeah it's a little bit Advanced and like I said patreons you're going to learn indepth stuff right very important stuff that will make the difference between a decent engineer and basically you know what I mean um you are the double weight you are the double the double Champion or your the double Division champion right Conor McGregor you know what I mean the best of the best that's what I'm going to teach you so that's a thing um in my opinion I'm going to try to keep the TCP transport like this um because it doesn't matter in my opinion I just want to show you these things CU sometimes people are returning the the interface right cool so uh we have this then I think we need to have some then um you know what let's let's uh try to do this in um in a TCP transport TCP transport test something like this and let's open up let's let's open up uh test here and then the transport DCP here so we can do stuff right going to say package uh peerto peer I'm going to say funk test TCP transport just to do stuff uh T is GNA be testing T right so let's save this real quick yeah so we're going to say for example um TR is going to be a new TCP transport and I'm going to say the address is going to be for example we could say that the uh listen add is going to be uh 3,000 or 4,000 I'm going to say okay listen address and then we could do something like um wait let me first to go we're going to use this for our tests go get get up.com I think it's stretcher and then testy and can I do something like assert equal TTR listen address listen address no we can't because if you're designing libraries and such or you're making production systems that's actually what what we're going to do we're going to make this as if this was a production system for one of your clients that are going to pay you a lot of money to build this so I need to teach you exactly how to make this quality code right quality it's going to take a little bit longer but hey it is what it is um so we're going to say uh get up I'm going to check if we imported this package actually uh get up come stretcher not quite sure of this stretcher and then test defy and I think assert man what's going on yes it's working I used this package so so many times in my life that I know it on the top of my head uh all right and now we can actually run this test like this and then everything is passing of course right but just want to make a point so we could do something like if we have a transport we should say a start function or an accept function depends on how a server is willing to use this so let's say we have um for example this is our server right uh how would we use this we're going to say for example TR accept or or it's accept already called by saying TR start right some things we need to to we need to take in consideration so let's say um so what what does a transport always do a transport always listens and accepts right it list listen and accept that's why uh I think maybe a function transport TCP transport you could say listen and accept something like this and then we could say or listener error is going to be net listen TCP T listen address what the hell is going on here vs code a little bit too enthusiastic uh T listener it's not going to be it's going to be T Liston address so we already know that we have have an error read right so we're going to say if the error uh is not nil we need to return this so I think listen and accept should return an error at all cases so we can actually return this error and then we could say tln equals listener lessener equals Ln like this or you could do for example say VAR uh like this and say add error and then um yeah or actually because it's only one and then could say something like T listener man this listen address man T listener R and then relieve the column that could actually also work depends all right so we have this listen and accept which is uhan and then we need to start up uh an accept Loop but yes this is going to return the error so we could say maybe a private function TCP to make it cleaner TCP transport uh we could say something like accept Loop like this and say for T listener it's going to be this it's con accept right so we need to listen wait this is a connection error is going to be T accept if there is an error in the accept we actually don't want to do anything for now you could say fmt uh print f I could say TCP trans TC TCP transport or actually TCP maybe TCP error accept error like this and then uh we could do a percentage percentage s a new line of course and then say the errors right and now we have a connection uh what are we going to do with this connection we're going to handle the con I think and then we could say accept Loop go accept loop I think we should say go start accept Loop and then we could say here go t start accept start accept Loop and then we could say return no here right now we have a con now we could say make other private function and I'm going to make handle come here it's very important if you're writing production code or very high quality code that you organize all your public functions at the top and your private functions at the bottom and always organize them based on how somebody would read it or based on the importance of a function right so if a function is more important put it more above and if it's just a simple helper function uh demote it to the the bottom right that makes a lot of sense because I don't want to scroll to a couple of string operation functions that basically makes no sense uh for me to read so and I think here you could say something like uh ttcp transports we could say handle con which is going to be a con net con and handle con because we know that we're going to call handle Con in a go routine so I don't think calling the turning in ER makes a lot of sense unless you're going to do some maybe a Channel or something but hey um so and now you could say we have a connection here and then you could say go T handle come come and call it a DAT right and then it can keep looping and keep listening and uh nice and tight nice and tight function and then here we could do for now we could say fmt print f um percentage plus v maybe a new line the connection and we could say for example um new incoming connection right cool so yes yes so basically how it's going to work is we have our transport which is a new TCP transport here and then we can say um Dr we don't have anything to start this listen and accept listen listen and accept all right uh so we could actually make test listen accept um this we're going to return an error so we could say assert uh assert nil T right that should give us no error right um let's run this test so it's working fine and we could also do something like for example if you do this and we run the test then it's going to return an error because this is not a valid um thing so so hey all good okay so thing we already know no matter what kind of Transport we have I think calling listen and accept is always something that can work so we can go to transport and we could say in our transport interface we could say listen uh and accept and basically does not then it returns an error that's the only thing it needs to do we don't care how or what this function is going to do it just need to be listen and accept because um that's something we are going to call in our server right and depending on what kind of Transport we're going to have we're always going to call listen and accept if it's UDP it needs to listen and accept UDP if it's websits it needs to do that if it's a local transport I don't even care what kind of transport it is it could be even a grpc listen and accept could be make could make sense here here right all right uh TCP transports are we going to see test okay so what we also going to do is if we are handling the connection um we need to basically the question rather is so are we good going to decode encode are we on or encoder and decoder is going to be an interface also but where are we going to call this is that something that's on the serice side or on the transport side or something in between right that's a thing um I think we're going to make a p we have this TCP transport that's here let's make I'm going to for now I'm going to make it here TCP P it's going to be a strict we're going to have a connection we're going to say TCP Pier represents represents the REM the remote noes over uh TCP established uh can we do connection yeah yeah yeah yeah yeah yeah what's going on Lost in Salvation uh TCP represents the remote nodee over TCP esta connection yeah con is going to be a net con um I think because we learned our lessons in all our protocols in the poker engine and in the and and and in the blockchain shenanigans you're going to say if this is an outbound Beach uh which is a boo right what is an B if we if we say uh TCP transport dial right and we dial to a pich that's going to be an outbound pich if we if you make connection with that Pier it's going to be an an an outbound but if so if we accept and and make a peer of the connection that's going to be um an inbound Peach right it makes a lot of sense like this for example um Let's do let's let's make documentation so basically um dial if we dial and accept wait a minute if we dial if we dial a connection outbound but if we accept and retrieve a connection e is this correct accept if we accept and retrieve a connection it's going to be outbound false well right because that's going to be an inbounded P I hope that makes sense um you could say con is the underlying connection of is the under connection of the P yeah um all right all right all right next thing we're going to do is basically maybe make a Constructor Funk new TCP P which going to be a TCP Pi or a pier doesn't even matter you're going to say return and TCP Pier of course if we make a new TCP we're going to say a connection which is going to be a net com and we're also going to say uh if if this is an outbound spe and then we can say come and outbound like this of course uh I prefer to do this although they have the same names still uh as for bothos as possible is always a good thing because I I think if you if you follow the blockchain from scratch we already had some nasty issue by not um providing the names in a more verbose Way new TCP P so we're going to make this P right we also going to need to have some way to add peers the question is are we going to do this with a channel I don't think so um but we're going to have a channel to communicate right because every kind of Transport is going to have a channel to communicate and we're going to call that as a as um as an interface function um handle connection do we actually I think we're going to need a pier here handle Pier uh that that's the thing the question is where are we going to H um and on I thought maybe we should do something like let's create a p right you could say that the PE is going to be in our case a new TCP Pier I'm going to say the com right and then if you accept it's going to be an outbound Pier so it's going to be true or you could make the peer here not quite sure uh probably going to change this actually we're going to make a new pier new incoming connection and let's do the spear and let's see if this actually works the question out is we cannot block uh for now actually we can we could do select like this and then um or we should call this in main could say that the transport is going to be a peertopeer new TCP transport forever store uh SL P2P I guess for some reason Vis Visual Studio code don't want to implement these things uh 3,000 like this now we going to say TR uh is going to be let's say log fatal start and accept question what's going on here listen and accept yeah listen and accept and uh of course we're going to we need to block here right real quick let's make run this uh nil what's going on of course because it's not uh yeah yeah yeah I see I see um let's do it like the traditional way right Edge clear make it all right so we are doing this thing let me quickly do uh tet uh talet Local Host 3000 all right so you see we are connecting and we say a new incoming connection so we already have easy we already doing TCP dopam mean dopam Meine you see this gives me dopamine and it should give you two uh okay cool listen accept is working so we have a new pier that's fine um uh now we need to make a very important decision because I want to make a handshake Funk which is going to be look uh what we're going to do uh I think because handshakes do we uh some some libraries need a handshake like our poker and what what's a handshake a handshake basically means U you connect to me or I connect to you it doesn't not really matter we connect and first of all before we are going to accept you as a new peer we're going to shake hands and if this handshake is not good we're going to drop the connection and Say Goodbye right um so that's why I think in TCP we're going to have something like what I call a handshaker or a TCP actually the handshaker doesn't even it it can no no I have an idea it could be any handshaker the handshaker could work over uh um a handshaker is going to be a handshaker and we could do something like this new file for example we could say this hand shake handshake Dogo we could say package peertopeer type uh hand hand Shaker interface uh and that could be something like is this correct my spelling hand yeah you could say handshake or or maybe shake hands nah handshake and the question is we're going to return an error doesn't really even matter it's going to be hard this handshaker because we're going to think about this but the thing is um because I'm not quite sure you see you could do like a handshaker right here um let's go to handshake and let's say type default hand uh handshaker man my spelling default handshaker is going to be a strict do we need to make this a strict does it actually make sense because we could do something like uh ah doesn't matter we're going to make this we could also do something like a type handshake Funk which is going to be a funk of type error something like this and I think that makes more sense because are we going to add stuff to this handshaker are we going to have things inside of this structure that's a good question I don't think so I can I think we can do something like this and make it even better and say the handshake Funk right and maybe we could do something like any could take an any I don't know to compare or something I have no clue and then in TCP transport wait handshake and we could say yeah yeah yeah yeah I have a good idea uh we could say transport and this is going to be the handshake funk handshake Funk right and this is going to be um handshake Funk right and if we going to construct this we're going to say the handshake Funk uh the handshake Funk is going to be a funk you could actually make this funk somewhere else but for now we're going to make a not funk it's going to be Funk any errors and say return n right so it's basically doing nothing so we could do could also do something like this right like like I said I'm going to teach you a lot of stuff so it's it could be a little bit slower but I hope you you have something about it and let me know poke me uh let me know what you think about these things should I go faster or should I explain these things you could also something do like this like a knp uh a NP handshake Funk which takes in an any we don't care and an errors and we say turn n right and then we could say instead of doing this here we could say yo this is a not handshake Funk we don't care right and and if you really want to be cool you can do in the handshake you could say hey I'm going to provide my users with an up handshake Funk right so if they don't need a handshake they could say yo oh man I need to sneeze oh no and I'm not going to cut this out I'm not going to go in this video to cut these things out that's not my style man everybody needs to sneeze and this big light is shining in my eyes make it it even worse uh so you could say handshake Funk handshake Funk is I don't know I don't know how to explain this because we need to uh probably make this handshake fun a little bit better and we going to see how this going to work so let's say we have the connection we have a pier which is good and then we could do I have an idea this handshake Funk is going to be look we're going to say something like this if R equals uh T handshake Funk with the connection and if the error is not nil actually I'm so sorry but I'm I'm going to be a perfectionist uh shake hands shake hands is going going to be a handshake Funk so we're going to say t shake hands with a connection and if it's an error we're going to say because we're going to here do go handle connection so we can actually start a read Loop right here uh we could say here con no not con uh um NR or decoder man I have so so many good itas this is insane oh man what you going to do guys listen oh we only at 44 minutes and I want to show so much stuff man we're going to make this is going to be oh my goodness I'm so excited I have so much dopamine you see I did this maybe 1,000 times in my life and I'm still getting so excited by making these these programs as cool to use it's crazy what is this what why do I have an eror unnown field yeah I know hey man let me let me be happy is it is it possible compiler uh handshake Funk we're also going to say um a a decoder a decoder is going to be uh should we call this decoder it's going to be a decoder or is this or is this too generic right and then we could make look what we going to do guys it's going to be insane uh new file we're going to say um encoding maybe we're going to call this encoding go and we going to call um peer to package peer to peer basically what I was saying uh this decoder thing right so um let's let's get back because maybe you guys uh had a longer break than I so we have the shake hands right um which we actually need to handle um what are we doing this is going to be our read um our message read Loop so we're going to read from the connection and actually if you want to read you need to do something like this let's say we make a buffer which is a a new bites buffer right and then you could say n r uh is going to be uh is it Con read the buffer right con read the buffer like this and then let's just eliminate eliminate the error for now man what's going on uh and then we could say something like um the message is basically debuff n right that's that's that's a message but I want to have something uh better we're going to make uh we the file this encoding file we're going to say type um we don't need an encoder but we need a decoder but I want to keep these files in the same uh keep these TR interfaces in the same thingy in the same file so we could say um decoder it's going to be an interface and that's going to be decode and addos the question is how we going to do this um you could say decode any no it's it's not it's going to be decode me a slice of btes no you're going to say decode me and IO readers that's what we're going to do decode me and IO readers and um an any uh ah I'm I'm thinking we could actually make this um we could do so many things is this what we need I think so because we could do something like this right instead of doing all the shenanigans we're going to delete this and we're going to say uh read Loop and actually could we could boot up a new one but it is what it is we're going to do it here and we're going to say actually the decoder is going to be a decoder that's good so we're going to say uh in this case we're going to say t decoder decode uh the connection into whatever type you want for example let's we are doing so many things at once it's crazy uh we're going to say type uh this going to be a placeholder temp it's going to be a temp is going to be a strict uh there's nothing in temp because we don't care and we're going to say here in this case we're going to say message uh wait what's going on message is going to be uh and temp and I'm going to say decote me the message right uh that's good and that's going to be an error if the man I'm thinking so hard that I cannot type if R is going to be this uh man yes no that is not nil because my my brain is already uh at the handshake because it's red it gives me an error uh and I'm going to say we cannot actually log here right we cannot return are we going to are we going to do a um Parma that are we going to do a perad that connection where if he sends us something we cannot decode we going to drop him I don't think so uh maybe we could do it could do cool stuff we could say for example um something like a l decode error right that's going to be zero and each time we have an error we're going to each time we have an error we going to say l de code error Plus+ and if uh the L de code error equals five times or something then we going to drop the connection hey spam protection something like this I don't know I'm not sure I just came up with this to be honest I just came up with this Shenanigans uh it could be a good idea actually um man I'm I'm so today it's my creative day not going to lie I'm creative today I need to abuse it so we're going to say fmt print uh F we're going to say percentage we're going to say actually it's TCP right uh we could say TCP TCP error once again and then we going to say s new line Eros continue like this right there's no PE do we actually care could be connection I don't care maybe we need to delete this this login I don't know so we have this spe we're shaking hands with connection maybe maybe we want a PE maybe maybe you want a peach handshake what's going on here handshake handshake funk handshake with a man what's going on here crumbles on my keyboard I hate it so hard I'm going to lie TSH hands why why is this uh giving us issues we don't have this function did we what's going on here did we not rename this what's going on oh man I forgot something let me quickly do get inet yeah sorry guys I missed actually um committing the first episode but I'm going to do it right now uh get commit uh if1 peer to peer uh peer to peer to peer lip something like that right and then it's going to be a couple more things in it but hey it's it's it's in the patreon community right it's in the patreon community you guys understand um so we have the shake hands that's good that's good everybody's happy Okay cool so we're going to shake hands if there is an error in Shake Hands we actually need to drop this connection so we're going to see actually we should start a b loop with the we should do we actually want already appear I'm not sure yeah maybe we going to set something in the peer we never know like get joining joining the the YouTube Studio which is basically my living room um wait we need to do some many design decision decisions uh new peer Shake hand let's shake hands with the peer we don't care right we will see if this n we going to say con close and actually return return this this this thing uh man why why so many lag in in in in this this vs code uh ver uh ER invalid handshake equals errors new invalid hand shake and always make your errors low caps why is it not working it is working um could say addage hand is returned if the handshake between the local and remote noes could not be established EST that bled man all right so we're going to say return at invalid handshake like this we couldn't of course we can't we are literally damn here ah it was such a nice thing the problem is of course we have this start accept Loop and then we have this uh no man we cannot have this because it's all just return and we're going to we're going to just log this out like this actually let's tight it up I'm going to say TCP erors TCP handshake erors like this very important that we first shake hands before we are going to decode here right because in this handshake it could be that we in the handshake function are actually reading from a connection so we need to be very careful with this um all right so yeah um let us actually open up main so we don't do we have a decoder we don't have a decoder right that's a problem uh so we're going to say TCP transport we need to have options right because otherwise we need to have we need to have some options to be honest um type DCP transport Ops going to be a strict and we actually going to say the listen man we need to do a lot of stuff not going to lie this going to take a lot of time we're going to say that the listen adders going to be a string we're going to have um handshake Funk hand Shake fun is going to be uh a hand shake Funk we need the decoder which is going to be decoder I'll make options like this this maybe I don't know or Ops or com I don't know how do I need to call this TCP transport Ops that's that's what it going to be um and then we're going to say instead of the chaning we're going to say give us give us the Ops which is going to be the TCP transport Ops and we're going to say shake hands we don't need all of this again Shenanigans we're going to say that the Ops I mean the TCB transport Ops is going to be the Ops like this and then instead of we can make this public listen add yeah that's fine it's all fine of course T shake hands that's going to be t uh handshake Funk right and then of course uh it's going to be T decoder right T decoder uh decode yeah yeah yeah yeah yeah like this so if not if you go to main um we're going to say that the Ops TCP Ops right is going to be peer top uh TCP transport Ops like this we going to say that the lesson Adder is going to be 3,000 uh decoder that's a good question I don't know and the handshake going to be a default not handshake Funk not handshake Funk because we're going to we're going to do no handshake because it's always going to be okay so yeah you could also Al say that the handshake Frank is going to return a Boolean if it's going to handshake yes or no but if it's return an arrow you can have a better logging uh thingy the problem is we don't have this uh TCP Ops we don't have this um decoder right so if you go to decoder encoding I mean could say type go go why am I laughing a lot of people maybe don't uh is going to going to going to understand this but we are using GOP so many times and I don't like GOP I actually like it but it's not yeah it is what it is man uh GOP decoder strict is that a strict yeah why not actually we don't need this right so we could say funk um deck which is going to be a Gob decoder help do we need a pointer probably not right I mean well we could do that because then we could check if it's n and anyway we're going to try without uh it's going to be a hub decoder we're going to say decode we going to decode um the io AR is going to be an IO reader and we going to have V is going to be an any I'm going to return an error right so how we're going to do this actually very easy we're going to say return can we return yeah we can we can say uh Hop new decoder we're going to say the reader and we're going to decode V hey hey I cannot do it it's that easy I mean it's plug and play right now we going to go to main and then we're going to say yo the decoder in our case you can make any decoder you want you could decode it in in and I don't know you're the b Ras if you want to extend this with your own decoder man go ahead and send me the code so I don't need to do it decoder is going to be aop a peer toe goop decoder easy that's what we're going to do yes all right so now we can actually do some cool stuff right we can we can uh we can test all right so we have this handshake yes yes yes decoder uh what's going to happen we have this me this is not true first of all we need to make something that we can actually use in some kind of uh Channel a message if you want to send something over the wire I'm thinking actually how we going to do this maybe we could do nah that doesn't make any sense we could make a new file I know it's a lot of files but uh message go we could say uh package peer top we can actually Defector this and and and do whatever we want right uh I'm going to say type message RPC is it not RPC is it RPC actually I'm going to make this even even just more genetic or just message right it's going to be a strict and uh a message is going to be or we make it like this btp message actually why because it's already in full P message um it's going to hold a payload which is going to be a slice of bites actually it could be any is that uh payload do we need to know from W comes we actually always no right or not I mean uh message represents uh any arbitrary message any arbitrary data message holds any arbitrary data that is being sent over uh over the over each transport uh between two notes the network and then we could say something like this message is going to be a message we're going to decode this stuff and after this we're going to say fmt print F uh percentage V new line the message and we could say um message we're going to change this right but just for testing to see if this works actually actually actually actually H it doesn't does it make sense to make what do we actually let's do make run all right that that's running that's running so we're going to use uh or Shenanigans uh Local Host 3000 all right so we have new incoming connection hello there are we hand yeah we hand can I actually de code this in a message because we're not sending a message right because the message is always going to be unless we have something uh it cannot it Gob cannot encode this uh that's the thing why am why are we decoding by the way yeah decode decode right decode encoding decoding uh the problem is look if if you do this real quick uh damn this was such a good idea not going to lie we could do like a buff it's going to be a new bites buffer then we could say n is going to be con read uh the buff right uh if add of course is not n we going to the OT and then we going to say uh like here we going to say buff M can we do this okay so this this is basically something else right so we say uh tell net Local Host uh 3,000 now see that that's working right so we have this um these messages and the reason why a normal message not work is because it's go and coding but hey of course it's not going to work because tet does not send any go encoding so how do we fix this how do we fix this well well then we write our own encoder that works for uh for normal connections isn't it I'm going to comment this out make this message yes that's what we're going to do we are actually insane trust me we're going to go to encoding and we're going to say funk not P coding just plain bites yeah that's that's a good idea you're going to make a type uh KN KN decoder which basically not going to decode anything right and I think always uh providing something for Library like KN this KN that KN KN everything it's interesting because users can just use this directly for their test and and and all that stuff uh so we're going to say funk actually I'm going to copy this whole sh bang real quick so I don't need to type that much I'm going to say this is going to be a KN decoder decode is all the same thing and we're going to say basically we're going to say uh actually I'm going to make a new buff going to make a new bites um buffer like this and I'm going to say buff read can I do this is that a thing I probably it's probably no it's different right it's or read buff is that a thing ah we can't it needs to read bites um doesn't matter you're going to say that the buffer is going to be uh 28 or something I'm going to read the B going to be n like this if add turn add and otherwise you're going to say of course this any is of course well is is is a problem right iaka um I'm thinking actually because do we want to do the encoding in in because we are in our in we are in our transport right we are here in our transport so making this is already hardcoded isn't it because this could work like this but I think we we we I mean how you decode everything into a message right into into into a message instead of this any type uh we could say it's going to be a message and we're going to use this as a communication at all times but what's the payload going to be that's that's generic that's depending on the platform that's what you're going to that's that's what you're going to decode with with with whatever we don't know we actually don't know we we need to give the user the option ourselves the option because maybe depends on what we are going to build um so we could then we could actually do something like this yo uh the message is going to be this is actually this is this this this this this uh need a pointer right because I'm we going to say the message payload that's going to be the buffers uh with this right and then we could uh actually delete all the shenanigans always make it a message oh I think my my cap lock is on right and then we have this message uh which is going to be the message and uh yeah do we wait wait wait we need to make sure it's a knob or default default coder yeah yeah yeah yeah yeah and then we're going to say uh basically in main we can just configurate this we're going to say this decoder is not going to be it's going to be the default decoder right like this what's going on here yeah yeah yeah I see I see I see it's not going to be any got be a message make run V again what's going on with V where is V all right so let's say uh tet Local Host Lo Local Host 3,000 hello ah you see now it's working right so we could give some messages some random stuff and then we can see that we are actually having a message with a payload yeah and then what we could do before we going to pipe this into a channel we are going to go to what's going on with TCP transport test yeah that's broken I guess uh but we could go into TCP transport and in what we could do is uh if we take message we could say we're going to have a from so we always know uh it should be an ADD and now we could say something like uh we have this message decod it and then we going to say message from it's going to be become remote remote edit and that's not going to work uh that's going to be a problem because like we mentioned in the poker engine it's not because the the if we dial somebody and his remote address is going to be the address he's listening to and actually I want to have his listen address because uh so we can actually send back much more easy but uh that being said that being said actually for now it's good enough right we could say make run and then we can say here go run oh go run down Local Host uh 3,000 and can say hello right and then we have this message and it's coming from this other guy here and that's the payload right and then we're going to send that into a channel just a generic Channel with a message right and everybody that's using the library we for the most part um we can then say okay it's a channel we have this here and we're going to handle it in the server and that's going to be decoded the p is going to be decoded could be an N it's could be an any uh we going to see you're going to see because now it's it's it's it's a default encoding which is basically plain bytes but it could be that it's that even those two messages are going to be sent over go up encoding over Proto buffer and then how we handle the inner bites could be another encoding decoding I don't know we're going to see how this going to work um I think this is good for this video uh I think the next video we are going to actually finish this up we're going to finish this this complete up so we can actually start uh with our key with our dis dis storage thing make a server use our own uh library to connect and everything is going to be nice nice nice or maybe we actually going to do our be Discovery and stuff also in this Library not quite sure we're going to see so let me do make run okay I think we started with this uh peertopeer package right we are implementing our own peertopeer package let me see uh the main yes and then I think TCP transport all right we have these things so I think what we're going to do next is basically we are doing this message decoding here and it's not the decoding of our payload but it's the decoding of the RPC actually the RPC between between two peers and I think we what is the stamp actually what the hell I think remove the stamp so I'm really so I'm left over relix uh let me do settings real quick first and make this uh 18 for the blind homies I think what we're going to do is open up message and I think we're going to rename this to RPC an RPC strict that makes more sense RPC and maybe we should rename the package to RPC but a um message so we're going to say this is an RPC we're going to say RPC this should be an RPC and this is going to be an RPC and of course this is going to be an RPC RPC all the things uh what is going on here this should be a small caps RPC by the way and let me open up um I think we Gucci actually and I think we have some the test is is actually broken uh yeah that that's because we basically have uh or transport options right instead of making this so we should do like Ops it's going to be transport DCP transport Ops like this and I'm we going to say that the listen address is going to be uh let's do 3,000 3,000 please we need the handshake right we did those handshake funk that's going to be a knob handshake Funk we're going to for now we're not going to implement any handshake Funk so you see that we have the ability to create a handshake Funk but we don't going to use it and then we need a decoder and of course we provided the default decoder uh so we can just use that and then put in opts what going on here op inside here and then we want to assert the listen Adder is that's going to be the listen Adder listen Adder like this uh and that's going to be we could do something like this right to test it like this make test real quick undefined message encoding yeah we need to change this it's going to be um an RPC do we actually want a pointer not quite sure not quite sure make test I think we're blocking in a test by the way yeah the select statement this should be good let's make test real quick uh and everything is working fine that's good then let's go to main uh let's do a make run that's working let's open up uh talet my microphone is is is doing crazy stuff uh talet is going to be Local Host 3,000 uh now we're going to actually send some messages by the way we're going to say um hello you and then see what's going on yeah so it's all working fine we have uh from from who is this is this Comming and the payload which is sending which is fine working all good um let's open up transport real quick the P interface I think the first method we're going to have in our p is close very important uh close like this so we can close the p is connection and if we open up TCP transport or transport itself uh enable to read these messages we need to have some function which is called a consume which will return a Channel of RPC and now we need to make sure that it's going to work so we're going to say uh TCP transport uh and that's going to be let me quickly think about this you're going to say an RPC Chen which is going to be a chen of RPC a Channel of RPC and then I'm going to say here that the RPC channel is going to be make me a chen of RPC easy then we need to in in in uh Implement our uh interface we're going to say t TCP transport we're going to say consume and that's going to return a Channel of RPC and you see this this syntax right this basically means if you watched the concurrency for beginners this basically means we can only read from the channel and we cannot send to the channel right very important and we're just going to return T RPC Channel like this and then we could say consume implements the transport interface just like that you could say uh which will return a read only Channel uh for reading the incoming messages sent from received from another P actually received from uh another P another p in the network yes that's good all right so now we need to let's do this cursor out of the way now we need to find a way to actually put that uh into our into our channel right so right now we're just printing this channel but we going to say something like that the the RPC channel is going to be the RPC it's going to be an RPC it's going to be the RPC right what's going on that's a pointer we don't want that although we need the address here for the coding so that's good yeah this is is is failing because uh P does not implement the the the close interface right the peer interface so we're going to say uh P TCP P by the way we're going to say close going to return an errors and we're just going to say return P come close and then we can say close M uh implements the P interface just like that all right I think that's good um let's test that out right how we going to do this we're going to say uh listen and accept maybe we going to boot up a new go routine here quick to test this real uh real fast we're going to say for TR consume is going to be the message I think it's something like that uh print Al Lan message or we could say print F what's going on here print F and then say percentage plus fee uh maybe a new line something like that is it going to work uh I have no clue let's let's run this uh running is going it's working you could say Tet Local Host 3000 hello yeah it's working fine right although we have this Relic this slend Relic for some reason yeah we don't have a a bad new line uh it's crazy why is this wrong oh yeah of course this is not a this is a new line I see make run we could say tet uh Loc host 3,000 and then do it again yes perfectly fine so now we can consume it's very important because if we uh attach or transport to a server or something in some way then we need to have we need to call consume on any kind of transport and the TCP transport will return his channel but for example any other transport will also return it his uh respective Channel which he communicates over over the wire and in our case it's TCP but it could be anything right we need to make it generic so that's fine um it's it's actually capturing output what's going on here let's close that in my OBS I hope it's fine all right so we have that the next thing we going to do is um we need to find a way because let's open up real real quick PP transport I'm going to show you yeah so this spe map I don't think we going to we going to keep them we not need a spear map because I think the transport is not going to be responsible to keeping the peers because peer is an interface so we could um I think the server is responsible to maintaining a list of his peers which could be a peer interface which could be any peer right it could hold uh peers that are connected with ECP it could hold Speers that connected with a local transport it could even hold Spears connected with grpc it does not really matter a p is an interface and our server could hold any kind of peer any kind of connection with his Respec uh respective transport that is the beauty of this genetic implementation but we need to have a function we need to have a way to notify the server that there is a new peer that the server can do with a new peer whatever he wants so I think to do that is to do something in TCP and we could say something we have decoder we have H fun we could say that the perer fun or onp is going to be a function of a P with an error right and then we could say that if this function returns an error we are not we're going to drop the P um how we going to do this um first of all I think I'm going to do something like this I'm going to say a defer fun here I'm going to call it or not how does it work it's like this right and then we going to say um actually do it here and then maybe say V error add error then yoink paste it in here and then we could say uh something like uh dropping p connection read Loop yeah uh dropping peer connection and then we could say an error which is going to be the error here on top then we're going to say con close so we could not do doing anything here we could just return here this can be good and here we could say if error first of all we're going to say if T onp right if that's not nil if somebody provided this function then we're going to call it if somebody does not provide this function then we're not going to call it but if somebody has uh provided us this function then we going to call it then we going to say uh if R is T on P and we going to say p no it's going to be the pier yeah we just made and if the error is not nil then we're going to say these erors needs to be can new erors actually we're going to just return yeah something like that so basically what happens is we're going to do our handshake if that's okay then we're going to do the on peer if that fails we're going to drop if that continues then we're going to start our read Loop right um yeah I think that's fine so if you go to main we could say here uh onp let's let's try this without let's try this without first uh make run so that should be normal right you could say uh tnet Local Host 3,000 hello you see everything is working fine we got these messages uh but if we say something like uh onp right and we're going to say that's a function of uh p eror and then we going to say something like um return fmt error F failed the onp funk uh there should be a peerto peer peer like this and we run this again right and then we connect in Local Host 3000 right wait let me do this right it it it instantly drops a connection right so we connect it and and and suddenly tet just exits out and that's because here right dropping p connection filthy on P Funk which is nice because that means that our logic is is working and of course uh we could say here right we could say um let me do we could say onp or something we don't need to specify it in the in uh directly into the transport options right you could say on PE is going to be onp here it's going to work perfectly fine as long as it has the correct signature right um that's fine now we return an error but we could also just return nil right so it's going to work so we could return nil here and then we could say fmt uh print Ln and we could say uh doing some logic with the appear outside of TCP transport and let's boot tet up and then we could say hello we can send messages and then uh we're going to say doing some logic with the p transport so it's all working fine if we have a new peer um we are actually in a good spot that's nice all right let's close it up yes I think it's good so um yeah yeah yeah yeah yeah yeah I think we're in a good spot it's going to be a short episode this one because I think right now we have everything we need to have uh or maybe wait we can actually not I want to test something because on pier we could say this is the pier right and I want to test something what happens if we do be close that's a good question what happens if you do that I'm going to I'm going to check it out it's a very important thing because that's going to basically um drop the Pier from from whatever yeah so we see that's good that we have this eror now we have this Loop right use of closed network connection and it's in the read um how are we going to fix this let's open up p real quick which is in transport right close it's in TCP transport actually it's here right uh if you have an error we keep looping uh let me see so what happens is that we we have a we have an error here in this decode what are we going to do are we going to drop the connection or we going to check the errors good question do uh let me can we do net at closed so I think we could do something like this because I think if if if somebody sends us a wrong payload I don't think we need to punish it I don't think we need to punish him and say yo you're out because you sent a wrong payload but of course uh we could say something like this right R is going to be this and then we could say uh if f is going to be net a con closed then we going to say uh return and we could do it like this and otherwise we're going to say the TCP read error is that something that's going to work let's try it out uh talet uh Local Host 3,000 use to close network connection it's it's not working oh it's return yeah I think it's fine Clos it it is I CL turn my is already closed yeah I think that's good right because can we can we can we Panic the air to see what kind of a this is it's a very important thing we need to get uh uh working let's not make run it's going to be tet right yeah you see it's it's a use of of of Clos Network connection the question is is is um let us see reflect uh type of as it's a net up error H that's um can we not do this damn okay I think we need to investigate this I think enable to make this um let's return let's return for now let's see let's just return right and now it works right now we have dropping a PE uh because we have a use of closed network connection I think there should be a way so we can assert this specific error so we only drop the beer if it's that error instead of just a normal error actually uh another error for example a code error or something right but hey uh I think we need to figure it out uh soon I will check it out how we can do this maybe it's it's I don't know we can we can see we're going to make it work it's not a big big of a deal for now um I think we have a good portion of our peertopeer lip then we're going to make the storage then we're going to make a server Implement that storage into the server and then we can do some um Shenanigans let me see uh what do we have main um I think we're going to make a new file we're going to call this uh storage go I think or store doesn't really matter uh package main I'm going to say type storage or store maybe store maybe store is good uh it's going to be a structure and then let me quickly find a good spot here and um I do we need something maybe store options or something type uh store Ops it's going to be a strict also and we going to we're going to have some some some stuff uh I'm going to I'm going to keep this here for now let's let's do let's go now with this cursor store test what is this I'm going to do the first function so if you want to write to dis right so basically what we're going to do is some kind of a Content addressable storage where we can save anything in a deep nested folder based on the transformation of the key you will see uh so I'm going to say something like Funk s store uh right stream because I'm want to stream it or try at least we're going to say key is going to be a string and then we're going to say an r i your reader right what's going on here uh a read it like this we're going to return an errors uh yes let's save it real quick and then so something like this right so the path name we could do it maybe this the path name is going to going to be some kind of a transformation of the key right so we could say something like um transform Funk or maybe bad transform Funk which is going to be a type of a bad transform Funk right and I'm going to say it's going to be a function we're going to say of the string of the key and it will return a string it's easy as that and then you could say the stups that the pad transform fun is going to be a pad transform Funk right need to be that signature yes and then we could say here that the store Ops we could just embed it and we could say a funk new store I'm going to give this uh opts which are store opts and we going to return a pointer to a store maybe an error not quite sure I'm going to return uh pointer to the store and I'm going to say that the store Ops are going to be the Ops right something like that of course if you make a test file uh I'm going to make the store test actually store test go right and I'm going to rename this real quick to store yes uh let's close this and let's make another file what's going on here let's open up store on this side and of course test on this side we're going to say package main Funk test store t uh it's going to be testing T and then I'm going to say for example uh that the S is going to be a new store we need options and options going to be store options yeah and the transform Funk uh let's make a default one for Now default pad transform Funk going to be a funk of key string to a string and we going to return actually let's let's make it let's make it clean what's going on let's make it clean we're going to say return the key very simple uh thing that's going to be a v yeah and you could say default pad transform Funk which is all good and we going to say the Ops here and then we have a stor what going on here all right yes so we have this Pat name and then we could say something like s uh pad transform Funk dis key right and then we have a pad name let's return no let's bring it up higher and then we going to say something like um the file and the error is going to be OS actually we need to make um if s is going to be OS mad and I think we need to do all especially uh for our content addressable Shenanigans we're going to mcut all the key no the pat name like this you're going to say if add is not n I'm going to return the Eros what does madol do a file name I think it's I'm not quite sure with this file name is file permissions We Will We Will um figure that out I think it's more the perm not quite sure so we're going to make all the folders We we are needed and you will see you will see why uh and then we're going to say now we need a file name actually and the file name for now is going to be the key we can't let's say it's some file name uh we don't care for now we're going to fix this because we're going to use uh some tricks we're going to make a hash of the contents right we're going to make a hash and that's going to be the file name inside of that Pat name folder that's pretty neat you will see thought about this last night then we going to actually say here um f is going to be OS uh open you're going to open the file I think it's the PAAD name plus slash uh the file name like this and I'm going to say if there is an error we're going to return the errors then we have a file and then we're going to say if I think it's n n add is going to be IO copy for streaming for streaming copy right because IO copy let me quick I will show you um you're going to stream this right you're going to not you will see I I copy we're going to say copy the file with the reader and if there is an error we going to say return the F maybe we should do an fmt or maybe a lock uh print F I'm going to say uh written per D bytes to dis like this and that should be good M we could do something like this right um you're going to say Pat and file name is going to be it's going to be the bat name plus it's going to be this this thing that we did and then the file name right and then we could say bad and file name that's not true this one Pat and file name did I make a mistake bad n what's OS open actually just a name right oh yeah let's see what's going on here like this I could do something like percentage s and maybe do the pattern file name all right um yes let's test this real quick so we're going to say and now we're going to make our transform F and make it beautiful so we have this s is going to be a new store Ops yes we going to say um let's say we want to store something right let's say we want to store s right stream let's make a key uh let's say it's going to be my special picture right could be a special picture and I'm going to say this need to be a reader right let's let's say data is going to be bytes new reader and we going to say uh bytes some GP some GP bytes right it's it doesn't matter it's bytes but right so we're going to say it's going to be some gpeg right uh and then we're going to say data and then we're going to say if actually we should use uh testify to be honest but hey we're going to say t eror and then the add like this and then yeah I think that's good enough uh to test can I do make test real quick no such file or directory um what are we making we need to make create file maybe we need to do us create that could also be a case hey make test yes so you can see written 14 bytes to dis and this is our uh location right my special picture some file name let's open up B I mean b let's open up you see it's my special picture the folder and now we have our file name right which is good uh can let's keep it there of course we're also going to do a configuration where we can set the root of the of the file system and blah blah blah blah blah yada y y right so all right so let's make a let's make a nice uh transform function uh we we're going to test this real quick here we're going to say funk test uh pad transform Funk I'm going to say t uh testing T and we going to make this let's make it at the top I know we're going to split things out as usual right we're going to we're going to make things beautiful as as later on uh let's make it how can I call this let's make it C uh C control add ible bat transform Funk and we're going to take in a a key which is a string we're going to return a string all right and this is the magic you will see this is going to be so cool uh so we're going to say fun funk all right so we're going to take a sha one or an nd5 it doesn't matter I'm going to take a sh one because we will have more bites uh we're going to have a longer a longer a longer thing because I think md5 let me open up md5 md5 um Su yeah what's md5 size we don't know I think it's 20 or 16 I don't know I forgot so guess controlable pad transform funk how we going to do this um first of all let's let's let's hash this thing so we're going to say that the hash is going to be sha one sum of the key right can we not do this we need to have byes right uh bites of the key then we have a hash then we're going to say that the hash string is going to be hex because now we have bytes right you're going to say hex and code to string to string and it's going to be the hash right uh what what's going on oh this will what does it return hash I think hash returns a 20 yes 20 by and of course uh and go to string a slice so we can convert this to slice by doing this a very neat trick by the way guys uh if you want to convert a fixed uh let's say you have a a 20 byte right and you want to convert this to a slice then you need to do this right easy trick because a lot of people are still using these Loops to uh convert it to to a slice which is okay but it's it's unnecessary right it's unnecessary performance waste of CPU U so we have this hash string and now we going to say something like the block size and that's going to be so we have 20 right let's say a or a pad block size let's say a block size of five and I'm going to say that the slice length and that's going to be I have no clue I think it's Len uh the hash string divided by the block size and then we going to say that the PS wait now I need to think this is going to be on the top of my head not um that's is going to be is it slice length yeah yeah yeah yeah it's this it's this it's slice length yeah yeah so pads wait so we could do yeah yeah yeah uh Pats is going to be make me a slice of uh slice of bytes I guess or even a slice of string actually and we going to say the slice L I'm going to premake it oh yeah and then we going to say Forge and I'm going to Loop through L pads I guess or even even you could say slice Len it doesn't really matter slice L is actually it's already a number right so what am I doing here uh like this now we going to say from to is going to be uh it's going to be I times block size I times block size plus block size and I'm going to say they're going to say Pat y equals the hash string look at this the hash string from two right and then we going to now we have this Pat and then we could say return strings join man this is is actually insane uh strings join uh strings join strings join strings join the the the the the pads can we do this actually we can't because we can we can we can strings joins pads and then we're going to join it with the slash right for the pad thingy yes let's try this let's try this we're going to say that um the pad the pat name from our key right so we're going to let's say we have a key right we're going to store for example um a bite it's going to be a string actually so we're going to say mom's best pictures mom best picture right and the pth name of that uh thing is going to be so we're going to each key is going to be transformed to a certain pad on disk mom's best picture and the pad name is going to be uh C pad transform we're going to give that key and then we're going to basically I don't know what it's going to be so so let's let's print it out uh fmt print Ln the pad name let let us run this you see this is our pad name right so we're going to make a folder this folder then inside this folder we're going to make this folder and inside this folder this this this so we're going to go in depth right so we're going to have a nice nice nice uh depth of folders for every 10 and uh yeah so we can store these things on disk that way and we could we we we we can change this up right it could be that we only have two depth or or a three depth or whatever but now we have a five depth which is good nice the question is how how are we going to test this um actually what we could do is um run this again I have no clue man I'm going to just copy this and I'm going to say uh if bad name it's not the best thing to do but hey if bad name uh is not this let me going to say t erors let say actually expected expected pad name you're going to say something like this let's let's yink it and paste it in here expected bad name I'm going to say Dem eror f t have this want this Bad Name expected bad name and we don't need to do this D by the way all right something like that something like that all right so we're going to say that the pad name is going to be transform Funk so we could do it's not going to be the default transform Funk we're going to say it's the gas pad transform fun and you can make your own transform funks and and and we can extend it with with whatever ever you want to you want to do you could do a git gtit type thing uh it doesn't matter right all right so the next thing we need to do is this file name this file name is not okay we want to have uh an md5 hash or something even a sha hash it doesn't really matter it needs to be hashed so and of course things are going to be encrypted I know but for now I think the problem is we have this reader right this reader so what we could do enable to Hash the contents of the reader the bytes of the reader right we need to read but we also need to read to to copy it to the file right we have the file we have our reader and we need to copy the reader into the file which will read and once the reader has been read it's it's done so enable to do that I think you're going to first Le into a buffer so we're going to say buffer is going to be a new byes buffer right it's very interesting actually because we do a lot of this uh networking stuff and now we are doing these these these um file reading Shenanigans which is nice right and now we going to say I'm going to say IO copy and we going to copy this reader into a buffer and then we going to say something like that the file name itself the file name bytes is going to be md5 the sum of the buff um bytes like this now going to say that the file name it's going to be a hex and code to string of the file name bytes then we can do this patn file name thingy then we're going to create it and of course this reader is already already uh we can do anything with it so we're going to say can we do buff that would be nice that would be nice is it going to work yes look at this so so now we're going to see right let's open up our folder so we're going to say this one and inside this folder we have this structure this structure this structure 1 2 3 4 5 6 7 why do we have so much yeah it's it's normally it's because yeah yeah is it yeah so we have these nested folders right I think it's okay let me it's D and this one this one this one this one and then we have this file which is jumz so we are storing this on dis already it's nice nice look at these folders I like it I like it and if we want to read it's the same principle we we know exactly we transform the key we want to read and it will be wait wait we have a trouble we cannot we can we cannot transform it like that because how do we read something if we read it we need to no no no we can't we can't we made a mistake uh let's close this up we cannot do this file invites I think uh that's not true because right now we are storing let's let's make um I think we need you you know what I'm going right because if we want to read a key and we have our key but we don't know what's inside most of the time so if we want to have the full pth we need to have the bites of the thing we want to read the the content of the data so we can hatch to know its file name but that's that's impossible right to get something so let's I have an idea I have an idea we're going to say something like something like a type uh a pad key going to be a strict and a pad key is going to hold the pad the pth name which is going to be a string but also the original is it the thing original key Maybe original original is good so the spad transform Funk could return a pad key why we going to return a pad key and I'm we going to say that the um we could say return me a pad key and the pad key is going to have the um the pad name and the pad name is Going to Be Strings it's I'm going to just going to type it out again uh strings join this thing that we did right we're going to say pad and then we're going to join it with this and then we're going to say that the original is going to be the hash string right like this uh expected Pat name and I'm going to say expected Pat expected original or Ori key uh and that's going to maybe the pad key but without these things right I'm making so or G no man I cannot type original so then we going to say bad key here now we going to say the pad key uh Pat name is going to be this right and then we could actually copy this again paste it then I'm going to say pad key original should be the expected pad name it's going to be Pat name original what's going on with your original key no it's going to be expected original key yes is this going to work work yeah of course we have some issues I understand so we're going to say that the pad key can I make this like this or this I don't care and then we going to say make everything it's going to be the pad key Bad Name Bad Name wait we don't need this we can we don't need to copy this actually we can uh I think I think we Pat and file is going to be the pad key uh this and then we going to say actually what we could do look at this let's do it like this I don't know what what I'm doing actually uh bad name yeah of course we have some issues in our test uh like this and then we going to see what's going on here what's going on oh it's the yeah it's true what's going on unnown field pad name and we going to we can make a function right we can say uh Funk uh we could say pad key and let's say file name yes file name is going to return a string and we could just return uh like this we could say return and we can make it clean we could say fmt s Sprints s and we could say it's going to be percentage s/ percentage s and that's it and I'm going to say ppad name p original s print what's going on F yes that's the file name so we're going to make the pad name the patn file name only thing we need actually we could do it that's going to be pad key file name right and instead of copying this BFF we can copy the add right I think that's going to going to be some uh there going to be something I think we are at a good track Let's test the storage yes so we are written to dis this whole shebang right so now you can see that we make these folders right and the file name is going to be the path name but then laid out so then we can find it but then we can retrieve it right all right so what I want to test um is basically uh reading so let's make something like Funk s store let me let me move it up here Funk s store I'm we going to say uh read stream a key which is a string and it's going to return us that's a good question are you reader it it it's sounds weird but and an error maybe uh because we're going to W these functions right so now read stream right stream is going to be internal functions but we're going to wrap them with read right and and and easy easy API to use um right so we're going to say that the pad key we're going to say the same thing right the pad key is going to be Asad transform fun of the key right and we going to say that the file name or the full PAAD actually maybe uh the full PAAD is going to be actually can we I think we're going to say OS open and we're going to say it's going to be an f file and an error it's OS open and I think you're going to say the pad key uh file name no it's file name it's I don't like this file name thing because where is Pat key file name the pat name the original I don't like original uh this is going to be file name we're going to refector this uh and I'm going to say this is going to be the full pad the pat P name and this the file name will give us the full pad is that is that correct uh leave some comments if you think I'm I'm wrong if if you think we can do this better because hey so the full pad is going to be the pad name with the file name because this is the file name right I mean it's clear as that of course that's we're going to bat name original is going to be the file name yes full pad of course we have some issues here uh and here let's make it full pad and of course here also uh going to be full pad yes and then we're going to say here pad key full pad that's we're going to that's we're going to open if there is an error we're going to return can we return n as a yeah we can we're going to return no Ed then we have a file the question is we can we can um what do we want to return if we want to do a read stream that's a good question I think file is is a reader right file as a reader H but I think we need to this read stream because we're going to do decryption and stuff decryption needs to happen on the client side I think which happens right well I mean we're going to get um this is a hard one is file reader that's a question let me I think so right yeah yeah it needs to be yeah we can of course we need to close these files right that's a thing so the problem is with we reading we're reading a file from this but we need to make sure we close this so I don't think it's going to be a reader but a read closer which basically means we can just do this return the whole sh bang but that doesn't make any sense but then we can wrap this in a function and we could say for example s store and uh just read read the key is a string and then what we could do here is um H we could bites or a reader not quite sure guys what we need to do here there are a lot of options uh to be honest so we could say for example Del stream this Str this key we return n n right and then we could say uh we going make a buffer new bites buffer h you're going to say I copy F buff no buff F and I'm going to say f close and then we're going to return the buff no actually what you could do is let's do this let's going on what did I do let defered heat F close should I do it like this actually I think it's fine uh I think it's fine we can say defer I'm we going to say add and then we going to return add right doesn't does it huh what what what happens here written add right oh yeah new new variables yeah I see um yeah yeah it's fine it's fine is that a thing Let's test this right so let's let's put it up higher so we're going to say here data we're going to read uh what is this my special picture let's make a key I'm going to say the key uh what's going on there going to be mom specials you're going to read the key these are the bytes these are the data right this is a new store like we're going to write this and then we're going to read this right then we're going to say uh that the s s is going to be S read uh we're going to read the key we going to say if s is not nil the error right T eror um now we have this reader right and and I think it's important to return a read because then you are then you are flexible then then we are flexible if you just return the btes I think it was important to to close the file so we don't need to do that the users well we don't need to do that later on but a reader is important to have so we're going to say uh R is going to be we're going to say that the B going to be IO till read all R uh if R is do we need this and we're going to say um wait what you could do is instead of doing we're going to say this is going to be bites like this and we're going to say this is going to be a bite uh new reader here my mic is constantly doing stuff it doesn't need to do hey anyway it is what it is um yes we're going to do it like this because then we're going to read this bites and then we could say if uh B is not equal to the data right that we that we put in you're going to say t add F you're going to say want this can we do s I think so have uh this we want data we have B what's going on what B is not data damn it's it's I see well what you could do is this right you could say string B string data is that a thing yeah look at this it just work it just working so because we could say fmt print uh print Ln and we could say string uh B right so you could see what we readed right some geg bites it's fine it's working yay all right so help me what's going on here we can read of course I think we need to do some more stuff in here but hey it's fine for now um and I'm thinking my special picture so we have these cool St oh we have what the hell is going on here the of course if you store the same file again this is weird Behavior well so it's going to Hash but why is it the same pad and not the same thing ah see yeah of course it's it's hashing the same pad uh we do an md5 no we don't anyway uh doesn't matter we will fix that uh we will see what what is this uh how how that happens it doesn't really matter because it's the same file the question about the is what what do we need to do when we are storing the same file once again so we we're going to fix that all later on uh the basics first actually we should we should um let's make a delete function so we can actually clean up our test otherwise if we run the test we will have these folders sitting around right um we have read here let's make a delete if you really want to delete something right uh we're going to say delete we're going to delete a key we're going to return an error and the first thing we're going to do like usual is make our pad key that's going to be S transform Funk with the key and I think we need to do H let's do F actually do we need to stat this to be honest because can we not do something like OS remove removes the name the named file or empty that Dory if there is an error and what's remove all removes remove all removes pad and children contains it removes everything it can but Returns the first okay see maybe I think I remove all and it's going to be the pad key full pad like this uh let's return the OS of course this we can actually just return this unless we want to lock and even then uh even then but we like I said this is very very early I think we're going to add much more to this later on in these things right especially if you want to work with a cach and everything so I'm going to Implement a cach and if you want to work with a cache we need to bust the cach and if you delete and blah blah blah and all that good stuff right so that's why this function will be bigger we can actually make a deferred funk I could say something like this right or or this uh it's going to be pad key full pad maybe actually file name maybe right this is going to work no idea um can make this test right you could say funk test delete going to be a t testing. t um could copy this let's write it let's write Mom special key uh and let's then say uh if s is as delete key the error F not not error F uh let's make another function actually has key we need to make this pad Keys all the time right we need to make this transform funks uh all the time let's going on I think it could do something like um file information is OS stat uh the key no not the key the pad uh full pad what am I doing here with this capital P full pad uh we're going to do with this AR has do we care about this look look at this what we're going to do is if add not n going to return false is that a thing actually should we do this so let's say if we have and we and we are trying to stat something and we get an error in stating I'm going to turn false you know what I mean it's it's uh then we going to say um how can stat actually turn n anyway wait maybe let me let me see what stat does stat Returns the file info describing the the file name if there is an error it will be bad error it's a bad AR right because we don't get this file info right uh is not exist buting whenever the is know report directly exit Cod should use FS uh FS a not exist is that a thing I don't exist man this is this is crazy huh if F what is this should use return R is not equal resist instead of if why because if the error is the file not exist then we return files right because we don't have the file then I don't understand am I am I stupid maybe baby man let me clean up these folders real quick actually do we have we have no Shenanigans right so basically what I'm going to do is I'm going to test store delete key I'm going to store this key and I'm going to delete this key so I'm going to run this test and then is see delete it from disk but the problem is this they're still here but the file is gone the file is gone the file is gone but the the folder is still there oh man so what do we do do we remove these folders also or or what is this I thought I thought remove all I really I really I really thought remov all would remove the whole shebang not going to lie what what happens if you do remove all the pad key and we say we're going to remove the pad key pad name what's going to happen then if you do this again as the this boom that's that's that's that's crazy it's deleting that's for sure remove removes the named file remove remove bad and any children it contains oh but ah man why is it not working the bat name Pat that's crazy that's crazy uh I was really really really assuming that o REM move off would delete the whole She Bang but apparently it isn't uh let me think then we could do two times right we could do but that doesn't make any sense oh oh but that's it's full pet full pet yeah full pad right so we're deleting the full pad so I don't know I don't know I don't know why this is not going to work to be honest why does vs code not yes boom so we deleted this file name yeah I understand it's gone I completely agree H weird Behavior Uh so let's do something like I'm not quite sure if this the right approach to be honest but hey now return we're going to say patk full Pat Uh we're going to say yeah no not the full pad this is going to be then the the the the pad name right pad name it should delete everything it is what it is I don't understand um let's let's open up let's remove this folder once again now right and let's do this again all right now now everything's no what's going on you know what you you you know what we're going to do what is this man is is this window Shenanigans what we going to do is um we're going to say pad key make a new function you're going to say p bad key first pad name and that's going to be it's going to return a string and we're going to say um return strings split thep pad name and we going to split it with this and we're going to return the first all right and we're going to say we're going to double check because we are doing a ray so let's do pads like this uh we're going to say let's make it actually good right because um people going to roast me so we're going to say this this is going to be the pads right I'm going to say if Len uh pads if if if l p is zero right I'm we going to say um we could Panic here because if we want a first pet name and it's zero but let's return nothing it doesn't matter I mean you could say yeah Pat name needs to return a string and an error but you could man if you could yeah yeah I know but still I'm not I'm not I'm very I'm a big fan of errors and handling errors very important but these things if you are trying to get the first Pat name but the you cannot make a pat name something is terribly wrong in your system in my opinion something to think about you could say return now we're going to return the pads zero right the first one right so instead of doing this where is M remove delete here let me try something real quick let me comment this out we're going to say remove everything but we're going to say pad key the first pad name okay delete Perman do it again hey you see now it's working ha so can we actually do the complete test actually uh let's let's do it test Le key yeah yeah yeah so we're going to do do our test here read everything and we're going to test this and then we're going to basically just say um as delete key yes it's working yeah baby uh yes of course we also want to basically for our test if you want to do a complete tear down where we delete everything we just stored we need to uh implement the root of the storage we need to know where the root of the storage is and um once we know that then then we can just delete the the delete the complete roote uh basically so we could actually say should we make a function clear not quite sure but anyway um let's open up store and store test real quick and uh what we already can do is save things we're going to make these folders uh based on the key right based on the key we're going to transform that key and then we are going to create some some pad to the file right uh content addressable but the problem is there is no way to specify a root right we cannot just store that randomly on disk we need to have a root that contains the whole shebang so how we want to do this uh is basically a couple things actually because I was I was uh inspecting this code base and um we made a a mistake well not a mistake we forgot something so we have this let me put out of the way this uh cursor so we have this default Pat transform fun which is basically the default uh and we have no way to basically uh add default values right so we could do something like here new store and we could say like if the Ops uh the pad transform Funk is nil then we could actually say that the Ops pad transform Funk is the default pad transform fun but that's not going to work because we changed this interface uh let's go up top we changed where where is the thing this pad transform fun is basically takes a string and and returns a pad key but we are returning a string still in this transform fun so we need to say it's going to be a pad key and that's going to be that's going to return uh that's going to return a pad key and I think because it's the default function we can say that the pad name is going to be the key and then the file name can also be the key why not right so that's going to that's going to work perfectly fine the next thing I want to do is basically add a root in the store UPS which is going to be a string it's going to be uh root we can say root is the uh folder name of the root of the root containing containing all the files maybe folders uh files of the system like this and then we could say something here right we could say if the op actually we could say uh let's let's make a constant we're going to say default uh root folder name or something I don't know and we could say it's going to be GG wait my my keys my it's still it's back to International and it needs to be us keyboard layout otherwise uh my quotes are up we're going to say GG Network like this and then we could say something here if opt root actually we could say if the length of the Ops root equals zero that's how I that's basically how I check if strings are zero you could to basically like this right is the same thing if Ops root equals uh this right but I don't like it for some reason I don't like it so I'm always doing if Len of the string is zero then we could say that the op root is going to be the default uh default root folder name of course now the whole system is is broken right because we have um what is this we can delete it I guess because if we want to write uh so we're going to say Pat key and then we going to M the bang right the the pad name of the pad key the problem is we need to append I not append preent we need to preent the root name to this so actually it could be something like uh s Roots like this but that's that's a nasty way to do that I know right is I just want to test this real quick let me open up my folders and let's uh run test here right it's not going to work um why why is it panicking actually I don't understand now basically it's it's tried to open uh it's try to open that shenan it's a right stream it's maybe because we're also doing read streams here let's let's uh Delete so we're going to WR stream here we already have these uh these complete folders here that's fine so something is working all right let let us test uh just writing right that's going to fail uh that's going to fail it's the full pad yeah yeah yeah I see I see what's going on so we basically do this m all with the root and then we making a full pad and then we are going to create but the full pad also needs to be the root uh plus the full pad right let me delete this folder once again and let's run this again right now it's it's going to work perfectly fine so we have our root and then we have our file here which is some gpeg bytes so that's already a good start um okay so how can we make this cleaner with this root thingy let me close this bites thingy I'm tired it's still early and I'm trying to do this as raw as possible right no no no no prerecorded Shenanigans so wait what is this pad name and then we have the full pad with which is basically the pad with the file name and this is going to be uh the pad key pth name which is going to be the pth without the file name what we could do is make a transform fun with the root do we want that I don't think so or we could do something like pad key uh something like pad key root or something and then say that's going to be the S root but I don't like it I don't like that so what we could do is basically you can keep it like this I'm also thinking maybe should do a pad transform fun with the key and the root or something like this but that's then it's not a separation of concerns right I want to have this function as pure as possible uh so what we could do to make it a little bit cleaner is basically uh it's going to be the pad name with root and that's going to be an fmt S print F yeah as print uh F yeah like this we're going to say percentage s/ percentage s and then we're going to say it's going to be the S root and the pad key uh is going to be the pth name I guess bad name yeah like this right it's already a little bit cleaner we're going to say pad name with root then we have this full pad and then we we could say the same thing like full pad with the root right and let's just uh let us copy this bad boy but that's not going to be the pad key pad name it's going to be the full pad right actually yeah then we can say full pad with root full pad with root and then this is going to be we written to B we written to the dis and it's going to be the full pad with the root is that a thing I don't know let's delete this and let's run it again it's all working as expected that's perfectly Gucci so let's Del it again I think what I'm going to do is make the delete function uh right now because then we don't need to do it manually but let's make this test work first right so then we're going to read we're going to read the key we're going to read the key actually so that basically means we need to fix it what's what's what's going on with right stream test it doesn't detect it's telling me probably that it's not getting used although we're using it in our test but a and this thing uh this can be different we could do if erors uh is s o not exist is the same thing right so if if if it's not existing then we return false otherwise return true uh read read read read read where is read what's going on here like this should be fine uh where is read here so we're going to do a read stream is this one we're going to say that the pad key is uh transform fun with the key and then we're going to say read me the full pad that's not true we're going to say that the pad key uh with root is going to be an fmts actually what we could do is um it's fine I mean we could we could make these things like I said in an application you can keep making things even better and better and easier to to use but hey uh percentage s/ percentage s and it's going to be the S root and then with the bad key like this and then we could say open me the pad key with root right is that I think it's going to be the full p with root to be honest it's going to be a reading that should actually work I think it isn't I see what's going on what's it doing here oh yeah I do the key that's crazy uh full Pat right yeah so we have written um 14 bytes to dis that's fine the question is why don't we do we print that out we don't we could we could try right you could try if if you're actually reading this thing uh print f yeah it's gonna it's it's it's working fine because we say want F so that's fine right but hey if you want to see it on the screen we could do string B uh and run this thing again what's going on here print F you could CH print alen uh and do this boom some gpeg bite working working as intended that's good and then we're going to say delete key the question is is is this going to work probably not we we need to do some changes so let's open up delete it's above here so we're going to say uh pad key pad key the file name but we're going to remove the first pad name that's actually that's fine right so we could say first pad name uh with root which is going to be an fmts print uh F same Shenanigans percent s/ percent s and it's going to be the S root and the pad key uh first pad let's just type it out instead of typ hint then and then we're going to delete uh everything inside this we're going to say the first bad name and let's type it out again with root sometimes it's fine to not rely on your typ hinting I'm so sorry spell Rusty and I'm going to delete this the question is what what what is it going to delete it's going to delete the whole shebang uh let's see right so we have this thing I'm going to do run test it's hey look at this it's working perfectly fine yes that's already a good start sometimes things go like it should be that's great that's clean that's clean that's clean Let's uh do we need to have something else we have delete has has has has has has key where is Hy a hasy h uh we're going to do this uh transform Funk we're going to see if the stat to the full pad uh I need to say full pad with root right uh full pad with root and that's going to be again again I know I know uh s print F uh percentage s/ percentage s is going to be S uh roots and the pad key uh it's going to be the full pad I guess yeah so a function actually is it yeah yeah yeah and I'm going to say that the full pad with root is going to be this how do we test this has thingy that's delete um well let's just test everything in uh let's do it here right you could say um if okay s has uh the key and it's okay it's not okay actually what we uh what we're going to do is this right actually no if it's not okay it should have it right so we could say if not okay and we could say the errors F uh you could say expect it to have key key noise man sometimes and like I said this chair I need a new chair it's my back hurts everything hurts it's just a simple uh living living room chair you know where you just eat and and dip and dip them but I'm sitting here for for hours and hours it's it's crazy and I'm an old man and I need to have a I don't know so yeah uh this is this is nice what I'm going to do is real quick I'm going to say get at and then I'm going to do a get uh command M uh added roots to the store maybe going to say added root option to maybe store Ops like this Gucci Gucci and once again for the people that are uh patreons thank you for the support of course like usual thank you thank you very much if you're not in the Discord uh DM me or or DM me on patreon or something and I will give you the correct role in Discord right you get a better role so we have our private you can join the private channels uh where I'm basically continue continue helping people out right um so do that let me know if you are not if you don't have the correct uh role yet and I will happy to give you an exclusive status the stat of the status of the high value engineer software engineer which you are or you're going to become yes so that's fine what do we need more actually what I want to do in these um in these tests actually is make maybe make a tier down or maybe make uh some helper functions for example uh we could say new actually new store we're going to say testing do we need a testing I don't think we need actually um yeah we going to we going to some helper functions for us test it it will it will make uh our life easier what's going on here a store uh we could say return actually let's do this copy this do we want a root we don't want to I think GG is fine G G network is fine the default one so we're going to make our cast uh transform thingy and then we can actually just uh return this new store let's make a function uh it's going to be tear down and what do we want with tear down actually H um do we want testing T I think testing T and maybe the store itself not quite sure actually wait in a we need to delete everything do I have coffee actually yes lucky well this is basically a once in a lifetime opportunity that I have coffee available when I when I didn't expect it so we're going to do a tear down function how can we actually remove uh the whole She Bang uh I think we could do something like if R is going to be OS where do we do this uh remove all actually we should make a function like uh for example F store and then the store one then I think the store is basically complete we can store things we maybe need to come back to add or cash and everything but hey the next thing is to couple this on a on a on our Network so we can store things and then distributed that's that's the that's where the magic is going to happen uh but this needs to happen also right so we're going to a clear function right not quite sure what it's going to do will probably return an error uh we're going to say remove all and I think we could do something like s root uh and actually do return isn't that amazing is that a thing uh if add is going to be as clear and the error is not n and we going to actually D error s is that a thing let's let's try this real quick um so we don't need the stuff what we could say here is basically say s is going to be a new store like this and we going to say defer as tear down clear clear clear no tear down tear down help tear down DS is that a thing I'm not sure let's try yes you see now GG network is completely gone and now we can keep running these tests right okay of course it's it's it's getting cashed right it's getting cashed uh maybe we going to make a new key Fu and bar uh it's getting cached so let's change this so the cach can be busted here you see and everything is working perfectly fine and we don't have any relics in our folders uh from the test which is nice uh and the reason why we pass tear down in test uh where we pass testing. TNT damage basically so because clear can return an eror and then we can assert it and uh it's all fine and to be honest we could move these the shenanigans completely at the bottom of the file and because they're just helpers right so how do we need to test actually a little bit better this uh test store what we could do is um we could do we could do this right we could make a for Loop and we place everything in this for Loop right oh I'm I'm I'm itching what is this Fu and bar thingy wait wait wait wait I made a mistake I guess uh so this is a for Loop for Loop for Loop we're writing these btes where is our key we don't have a key what the hell is going on okay key is gone but it's no problem uh because we're going to make a new key we're going to say that the key is going to be fmts uh print F and that's going to be let's make this Fu underscore uh d which is going to be the Y right so we have count was count how many times we going to do this you can test this uh 50 times right then we're going to make some data we're going to say some geg bytes we could make some function for random bites but hey doesn't really matters uh I'm going to make a new key does it matter actually that we have a different file size I don't think so so now we can actually do this uh completely the same time you're going to write to dis 50 times and um with different Keys you see and it's it's it's all different keys right here 14 bytes I know what's going on here stop vs code yeah fine and we have no relics in our folder which is fine so we're basically testing uh writing we're testing has we're testing read and we're testing delete at the same time but if we delete um we need to assert we need to make our test pinpoint precise right pinpoint perfect we're going to say uh a not nil and we going to T error uh this error that we returning and then we need to say to make this actually perfectly fine then we need to try to see if we have a key um and then we're going to say if it's okay right if we have the key expect it to not have that key right because we just deleted every 10 right uh and we're going to do this 50 times so that basically means we're testing every 10 uh we have so we don't need to test this delete because we already testing this and we don't need yeah that's fine test store a new store tear down I think this is perfectly fine we're testing in one test we're testing the whole She Bang 50 times with different keys so we could do make test is going to fail because we have um an error in in in our uh TCP at somewhere so test that's failing boom right and I think the tests are are perfectly working yes Gucci do we have in our make file actually we have verbos on I'm going to delete verbos in make file so if we test make test right then we don't oh yeah it's printing anyway my ask see why it's make R yeah I see I see uh make t actually anyway uh why why actually why is it failing it's uh in peer top what what's going on uh TCP transport test or something what's going on help help yeah what's going on here uh don't test this it's going to that's working fine who why do we have tests we have transport test handshake store test why is it failing that's that's insane make test what's going on fail ah it's the pad transform thing that's feeling that's weird that's weird um that's that's weird store test this this is failing you see uh we want this who this is the exact same thing what's going on here um wait if the pat name and file name is not the expected uh file name wait wait wait wait wait wait wait what's going on here what's going on here half wait let in N vs code we can actually hover my mouse is broken you see if you hover this then you see on the other side that it's basically mimicking the same you see it's the same thing so we have this but we want this but it's the same thing so store test is going to be why why are we doing this not equal it's 19 line number 19 what's going on it's this one uh if the pat name file name the pad key file name is not the expected file name but they are the exacted file name wait this is not correct right because they expected the pat key file name that's not this one right the file name is the expected original key this is expected file name this is the expected file name and this is the expected path name right so this should be equal and the file name should be uh the expected um file name right and I'm going to say here uh expected uh file name that should be right all right I remember that we that we changed some stuff up so that could that could be the issue uh okay yeah I think I think this is fine so we can write stuff we can read stuff we can delete stuff we can clear the whole shebang we can test if we have a key I think this is uh a very good start to swap back to our um server this SW back to our server and then we can attach this storage there store a file and then we going to basically replicate it to to to all our other uh notes in the network and we're going to do some encryption and we're going to see uh what what we need to do so hey we at a good part somebody from the community uh noticed something um not quite sure if you remember but we had this uh weird warning on uh eror is somewhere I think in has in the has key yeah here uh although the warning is is is uh already fixed uh I think we can make this even better right instead of doing error is and check if it's false blah blah blah we can actually uh do this and return this directly what's going on like this right uh actually return this like this and that should work perfectly fine let's do make run test actually yes perfectly fine the next thing I also want to do is make uh an exposure of uh the right stream because we have this right stream here and I want to expose this as a private uh function so we're going to say instead of making this uh because I think we're gonna we're gonna do some more stuff in it uh later on but for now I'm going to expose it as a simple right uh store we're going to just say write which will take in a key which is a string and also take in an IO reader we will return an error and then we can actually just say uh return me as right stream with the key what's going on here key and R like this and it will all work fine the next thing I want to do is start creating our server uh new file we could call it file server or server I don't think it really matters um let's call it server package main rather we're going to say a type server which is going to be a structure we're going to have uh wait let's make some options right server options it's going to be a strict also we need a listen Adder uh for our transport right uh because we need to embed our peer topeer lip into the server thingy so we going to say let's call it file server file server UPS let's now there's going to be a string we also need a pack uh a storage rout Right Storage root it's going to be a string also and of course some uh we also need a private key and and all that stuff um not quite sure we need to implement that because we going to encrypt right we're going to encrypt uh probably uh some some stuff or maybe an encryption key doesn't need to be a private key we will see we will see storage root uh file server um h we can say file server opt right here new file server it's going to return a file server we could actually say something like uh return and file server I we need a store that's that's what we need a store which is going to be a pointer to this thing store we just created right and then we going to say that the store is going to be I think a new store if I remember correctly it's going to be the file server Ops and then we could say here that it's going to be the opt storage route what's going on in new store actually what's going on uh store pad transform fun that's the thing uh are we goingon to yeah yeah yeah I see I see see see see see so what a I think we should it's going to be a pad transform thing to be honest because we need to we need to pipe in we need to aggregate all these options I think uh yeah yeah we can no no no I see I see what's going on I see what is going on uh I think this going to be the store Ops we need to make the store Ops right it's going to be a store Ops like this and then we're going to say at the storage route is going to be Ops storage route and the bad transform fun is going to be the Ops bad transform fun right it's not going to be it's going to be the root here I that I think yeah yeah yeah and then we're going to inject these stor Ops into this uh new St stingy that's fine and of course we're going to the file server Ops going to be the Ops here and then we need something like a function run uh it's going to be we could say FS but uh s is fine I'm going to say file server Ops it's going to be a run or maybe start actually don't like run let's put it higher on the screen I think we also need a uh TCP transport which is going to be a transport I think it's going to be an interface we could say transport going to be a peertopeer transport is that in the configuration all right so how do we run this transport by the way um right we only have this interface only to listen and accept um where is listen and accept it returns an error so we already know that start can return this error and we could say that uh if R is going to be S transport uh listen and accept and the error is not going to be nil here then we going to return the errors right away is this blocking it isn't so it's going to start this accept Loop which is fine which is perfectly fine uh let's let's do quickly return null let's go to main to see how we can uh make this work all right so we have this TCP transport Ops right the question rather is are we going to pipe everything into file server options probably we do because we're going to configure this complete server which then will spread out this configuration to the other ones I think that's the way to go so we're going to have a transport uh or maybe we can just say that the transport options it's TCP transport options that's nasty because Yik uh TCP transport Ops uh transport Ops like this right um yes this be transport UPS that's a f wa I'm thinking right so then we need to specify actually no no no no no no no no no no no no no no no no we're not going to do this uh we're going to say transport and we're going to yeah I see look what we're going to do uh let's clear everything here on peer let's let's that's what we need we need an on PE but we're going to say like this we're going to say that the fs no let's say s because otherwise we can um it's going to be a new server file server by the way uh we need to take options we're going to say the F uh s file server options it's going to be it's going to be a file server options right what do we need we need a listen address which is going to be let's say the classic one 3,000 one of my favorite ports at all times uh the storage route we're going to say storage root is going to be it's pretty important because we're going to say 3,000 of files the reason or Network I don't know man uh the reason why we're going to do this because we're going to boot up multiple notes right to see if they are um replicating their their their state right because everybody needs to have that that uh that thing everybody needs to have the storage the same the terministic storage uh so we can make 3,000 Network 4,000 Network and all that stuff so we can see that otherwise it will store everything on our on our disc right if it makes a lot of sense uh then we're going to say the pad transform fun we're going to say it's just going to be a gas a default one we can make as much as we want but we already have a cast and I like it you can Implement whatever you want it does not need to be exactly that uh content addressable storage uh and then we're going to say transport right so the transport is going to be a TCP transport and we can make it like this we could say TCP transport is going to be a peertopeer new a TCP transport like this and we need to give it up so we're going to say TCP transport actually well man it's fine we're going to say TCP transport Ops and it's going to be a peertopeer TCP Ops what do we need let me open up TCP the other side real quick for the options uh transport Ops we need handshake Funk decoder and on P I don't like to specify all that Shenanigans I think we need to have some defaults do we have that do we check that decoder decode um damn damn damn damn damn do we have decoding and coding I hope the yeah I see a c uh not quite sure let's say uh listen add is actually so we don't need a listen address here man this is going to be nasty listen we don't need this back to TCP transport options we need a handshake Funk we can we do no uh peer to peer I saw it already Yes a not handshake fun because we for now we don't need one and then we going to say the Cod you see how how cool it is that we can actually control all these things uh of course we only need to specify it once but it's nice to have these interfaces and these functions so we can make our program uh much more generic and testable although this decoder is also an interface but we're going to say this is going to be a p to Pi we oh we have a default decoder look at this man man man we are literally gods look at this we have a default decoder and then an onp function we need that onp function but not for now uh we could say to do uh oner Funk like this and then we can say it's going to be the TCP transport Ops that's our TCP transport and then we can say in our transport which is going to be an interface but TCP transport implements that we could do this then we say file server opts and then we say s start going to return an error so we could say if uh f is going to be this starty thingy and the error is not nil uh we can actually uh I let's just look fail out here because it's just testing you're just architecting stuff uh of course if you make run I think uh the problem is with make run that that we will We let's block here real quick uh like this okay the problem is we don't see anything happening so I think we should have some default and the birds are basically eating breadcrumbs outside it's nice to see but they are distracting me because they're with a lot uh so some logging I think in transport uh wouldn't be too bad right here we're going to say go accept and we could here do a simple login actually maybe a log or something uh print Ln or NF actually you could say um uh TCP server actually transport maybe DCP transport listening actually listen uh listening on Port and then we could say uh percent s and then maybe a new line actually and then we're going to say here uh T listen add listen listen add yeah uh because this is uh yeah yeah it's fine M you see so TCP transport listening on Port 3000 all good all set up um and I wish I could this this terminal on Windows basically you see that the difference between my fonts size and uh this terminal uh font size is is is different and I already looked it up and I I have this uh settings zoom level where is zoom level Zoom I think it's in in my other settings uh but I I'm going to plan re remake my config and actually uh Drive vs code to the Limit because you can you can basically do everything in vs code right you can hook into everything I'm goingon to make it completely uh myself completely minimalistic even more um performant as it is uh on my side so I will share that just just a side just a side I know this is forever store but hey I have no friends let me talk to you I cannot explain this to my girlfriend because she doesn't understand so talking to you you understand what I mean so that's nice all right let's go so yeah everything is running uh I want to uh that's our server so it's all fine wait I'm thinking uh we could do a couple things we could make this with with an HTTP which is fine but I'm going to make this as a terminal app right so we have our terminal and then we can basically um run it and then we can ex uh execute commands or something with it right we can execute commands with it and we can add files to the terminal and and replicate it store FM I don't know uh we can do a couple things but I'm thinking what the next step is do we need the Pierce we probably need them um let me quickly think about this to be honest how are we going to do this I think we should actually find a way to encrypt these files which is going to be a simple encryption that's going to be fine that's uh for another episode uh let's go to servers real quick so how are we going to use this we have our file server which basically will boot up and now we need to find a way to command this ST which could be directly no we can't the thing is file server right now and bet store but do we want to store a bet file server we don't so actually we give commands to the server right so we could say which does not mean that it needs to be over HTTP it could be we could say f file server uh file server you're going to say store or something store file I think store is good key string uh what how do we want to do this do we want to store bytes let me do this uh return s store right and we going to say key with the reader the thing is what we could do is basically have a channel for this thing a Channel with a reader and I probably should uh think thought about this a little bit more before I started this video I'm going to do this because otherwise we are losing a lot of time so just to to share my my thinking process here we have a storage which is just a simple thing that can store files on disk based on a transform fun and everything right then we're going to have a server and this is basically the server that will be running as a demon right and it will um receive me it it will receive messages it will um be in a distributed beer top Network so each if it's yeah I I I know I know I know I know I know what the next step is we need to have some um some messages to be honest instead of doing this store I know I know what the next step is my bad my bad so what we need to do is uh this server needs to have a loop going to be S uh file server was this file server up start this is not uh we're going to make a loop you're going to make a for select Lo by the way let's make it uh a quit Channel real quick quit channel is going to be a chen uh with only actually going to be a Channel of an empty strict like this I'm going to make a channel is that no we don't need to do this uh that's only when we actually want to close that and of course we're going to say case and I think we could do S transport don't we have that it's this right transport DCP transport what's going on transport yeah it's transport it's as transport uh it's consume I think that's the thing can we do this let's print the L real quick this message we made an error what's going on with this message expect it we we made a little mistake I guess and I cannot find where it is what's going on unexpected default unexpected case uh 36 oh yeah we need is it case man hey what am I doing what am I doing wake up uh FM fmt wake up my man yeah yeah it's yeah I know I know but we also going to have a case quitch and everything we going to say uh like this right I'm going to say Cas s you could return here whatever we could break here I like to break uh maybe we can do some defer functions here right defer so if we return that we can execute that defer functions or we can use um another loop and then we can break this other loop and then do do do our Shenanigans here or logic everything is fine nothing is wrong um it's it's what you what you want right how you how you want to do it it's going on why yes so we have the squit CH I think some some something what I'm always doing is uh make this squid function here uh wait this is Loop we can say funk as uh file server uh quit or stop I don't know maybe stop or something uh and then we could do something like um we could do this close s quitchen right all right uh so we have this Loop where are we going to loop I think at run right start you could say go actually we can block right we can block at start or we don't block at start that's a question are we going to I think it's always a good idea to block and then give the opportunity to the user to call this in a go routine because then he will have a quit Channel if he wants he can quit it if he wants uh yeah maybe yeah let's let's let's block for now not quite sure right and then we can do this right yeah so it's all fine it's Block in uh that's good that's good that's good and actually we could do um we can start it here and we can say go Funk like this and then we could say uh time sleep time second times I don't know 3 seconds or let's say three seconds and then we could say uh s quit like this stop actually what the hell s stop right is that a thing like this right not quite is going to work perfectly fine I think so yeah you see uh it stopped right because we we we closed our quit Channel um but there is we can actually do it like here and see that's why maybe let's let's do something different let's let's make it a defer fun here uh for that shenanigans uh user create action I don't know um files stop due to user quit action the the thing is because sometimes it can stop for for another reason I don't know maybe we can just uh do this do we need to close something I think we could we could clean something up uh maybe the transport I don't think we have a close thingy right in our transport you see we have uh listen accept and consume maybe what we need to have is something uh in our TCP actually let me open up TCP transport because it could be that we need to stop something right we have a listener right you see we have a listener so I think a good thing to have in our transport interface is a close right let's return an error because uh close and an error is always good and then we can go to TCP transport because we don't implement this we could say uh Funk D DCP transport close and we could say uh return T listener close do we need something else to close list listen what am I doing listener right transport interface look at this boys girls we are doing good stuff right so that's what I was saying in the beginning like okay we have this transport interface but we don't know yet what types of functions is going to be exposed what is going to be what's going to be needed although I don't want to have a a a whole complete Chang list of of uh interf uh functions on that interface because that's not a good practice then we can uh do do some uh composability uh if we want but I think what do we have now uh let let's open up transport real quick to check I think three functions I think three or four is the maximum I think maybe may I don't know three four five Max right uh so we can do we close stop we we and then here we do quit and then we have our defer fun we could say S transport close right like this and maybe we need to do more cleanup and ntcb transport like the p and everything that we will see make run and let's see if everything is going to be fine no errors or something okay we have because we say use of close network connection um that's fine we can fix that new incom connection yeah it's because we close that stuff we're going to say TCP transport because this is this keeps running right this keeps raining so that's bad so what we're going to do is uh we're going to accept here so if it's closed it's fine ah I see yeah yeah yeah so we're going to close it here right and then we say this and then we're going to handle yeah yeah yeah I see what's going on uh I think we need to do something like this right if we because we're closing it this listener I think it's fine but we're going to say here uh if errors once again uh if errors is is R is going to be I think it's um net R closed yeah you're going to return this function right that should that should actually fix fix your thing I think right so then then everything is nice and and and tidy cleaned up file serice stop to user interaction that's fine you see we don't have any errors it's uh The Listener is is being cleaned up we we uh fetch the error because yeah I think it's everything is fine uh what we need to do later is to see if we have if we have peers or something what how we going to clean that up right um because each Pier is a con connection and and right it's going to be he right uh so we need to check that later on if we have connections how we going to fix that yeah so I think uh I think in the next episode what we're going to do is basically try to connect and exchange messages so we can uh if if one stores we're going to try to connect with each other and then if one is storing uh we're going to have a list of bootstrap notes right that's always important that you have a list of bootp notes so we can connect to two or three people and then these people are going to give us their peers and and at the certain point of time we're going to connect to whatever uh maximum connections of 20 different notes or maybe 100 whatever we can configure um so they basically gossip and do peerc Discovery right but to make it simple in the beginning we're just going to have a simple list of of pred find boep noes we're going to connect to them and if we store a file uh we're going to broadcast that file to everybody else right uh that's what we we going to achieve in the next thingies then we're going to do some encryption and we're going to make it better and better and better right all right all right let's continue uh what I think is going to be episode eight of um forever store and um the previous episode I think uh well I think I'm pretty sure because I just made it uh we basically created or our file server uh and now we need to I want to connect a couple servers together uh or at least two and I think uh what we need in uh the file server Ops is basically a list of bootstrap nodes right uh boot TR noes which going to be a slice of string and what we're going to do then is basically if we start we could do a listen and accept and then um we could make a function actually you could say uh like this is going to be the file server bootstrap Network I think it's going to be a thir eror because uh it could be and then we could save 4 S not quite sure what it's going to be I think it's uh adder in s bootstrap noes range actually what is that let me quickly see uh y string okay cool sometimes I I I switch these guys up with uh with each other uh and then we need to do something like S transport dial right that's what we need to do uh and we don't have a dial right let's return n here real quick uh what we're going to do in our TCP transport actually here I'm going to make a dial function and then we're going to dial an address actually a string going to return an error right so if you go to TCP transport we can make this dial function we have consume close yada yada yada let's make it here it doesn't really matter uh T it's going to be TCP p no transport dial add string error and we could say that the connection uh and an arrow is basically net dial which is going to be be TCP the added man my hands are itchy what's going on random random stuff if there is an error of course we're going to return uh return null now we have a connection so what we need to do is actually create a peer I guess because right here in uh start Loop handle come we can do handle come is it uh we can do handle con but we see that it's outbound so we could say in handle con uh we could say is this outbound like this here right and this is start accept Loop so this basically outbound is going to be what that be true we're accepting so it's not an outbound right going to be false and I think we could do here uh go T handle con which is going to be the connection and this is going to be true right this going to be an outbound comp because we're going to dial and we're going to return null here does it make sense uh I think so dial uh implements the transport interace always I'm always after all these years I'm not sure do we need to do a punctuation after our comments yes or no I have no clue right because some people do it and some people don't and the question is what is the correct thing is there a correct thing what do you think let me know let me know in the comments I'm I'm curious um although this is basically nothing we need to discuss to be honest because it's basically it doesn't really matter but still sometimes that question raise UPS uh in my mind so let me know what you think about it right let me know and it's up to you you can choose it's all fine for me uh what is going on with this I'm going to mute my output volume of the of my audio captured yeah that's uh not quite sure if the volume if the volume guys let me also know if the volume is fine I have no clue what's going on let me know uh if the volume is good or bad right uh all right so we have this dial right can we do this so we're going to say here if a is going to be actually we can dial them uh in a go way we can say go frun here right uh like this uh and I think we need to do we need to do other string we will see what what the what the thing is telling us uh vs code what Al is going to tell us uh S transport you're going to dial the address uh this is just for logging purposes because um actually it's a good a good question to be honest are we basically going to this is returning an error although we cannot return because we're doing it in a go routine uh let's just print this right let's let's just print is out why not okay you see this is basically already the the error we have here right uh the warning so it need to be an add switch is a string and then me say Adder all right that's what we're going to do we're going to bootstrap the whole sh bang and we're going to do that in start right um I'm thinking uh we are looping but we're also put uping the network I have no clue let us see let us experiment yeah we're closing the server here yada y yada uh so transport options is here we're going to say that the bootstrap do we have this in transport no it's not in transport options actually are we do no I don't think transport is going to be responsible for for dialing um well it's responsible for dialing but not responsible to to do Shenanigans with the with the with the bootstrap thing that's something we we need to take care of ourselves uh it's going to be here bootp notes and we're going to make a list of a of a string and I think uh what we're going to do here is basically um let's do 4,000 although we are not connected right I'm going to see what eror is it throwing at us yeah nothing what's going on here are we calling this yeah right let me quickly do this how's it going on what is going on we don't do anything here um what's it going on here going to say uh bootstrapping not work man what's going on I'm I'm confused because I'm thinking already uh a step further and I cannot do two things at the same time what uping the N that's fine right it should return as a n or at least Panic though what's going on here who's network it's all fine I think the problem is that we don't have any of these um yeah you're going to say attempting attempting to C connect with this guy uh and then we're going to say transport dial the address and if they we're going to panic so it's probably something in TCP transport then so there is no error uh that's crazy um what the hell is this what is going on here are recalling start yeah recall start right uh and why is this uh maybe we stopped maybe it's basically it's trying to dial and dialing timeout as basically uh longer than three seconds that could be that could be nasty if it's so we're going to stop quitting the server we're going to just wait what's going on look at this I see uh maybe no no we can't do that right we can do that we could do Local Host but this is going to be fine we don't get any erors what is going on H connection fuse right so returning an error right if ER is not n return an error we dial this here because start is maybe what is going on see we don't get any eror not no Panic I time to connect with the remote banic heat who who what maybe I made some stupid mistake and you guys already can see it but I cannot see it after the panic man I'm I'm literally confused I'm not going to lie I'm I'm I'm totally stuck here um it's not executing Hispanic if a is transport dial the adders and the add is not nil wait turnill oh my goodness oh my goodness oh I could easily it's 15 minutes in I could easily remake this video right that's 15 minutes I just delete my code get reset hard and go back and and do it if everything is fine that I'm basically a God and don't make mistakes with this I'm going to leave this in I'm not going to redo it it uh oh man look at this oh and I didn't see it and you guys probably saw this oh man I'm I'm going to leave this in this is this is actually too too too funny uh to delete oh man oh it's actually smiling because it's it's I thought what the hell is going on this makes no sense uh okay cool uh man man man man man after the Panic everything okay what's going on it's still not doing anything okay that's because um wait uh so we dial this thing and if the error is not nail we're going to return the error and dial here uh which actually should Panic what is this it's anel Anthony please can you can you stop doing the shenanigans for once in your life all right what the hell I'm going to leave this in uh it's it's just too ridiculous okay cool this is fine uh so we're going to print this error here and we can actually return this uh yeah let's let's let's do not go routine this so we can actually have an but do we care if we don't want to actually guys I don't think it actually matters here uh I think we're going to I think we're going to break no continue actually if this guy is not uh dialing and then what we're going to say is basically do the G Funk anyway here I'm going to do the gunk anyway okay we cannot continue why not oh yeah see I see of course we cannot it's another thing it's fine it's fine oh guys what is this uh we're going to print this thing yeah now we need to sh we block are we blocking are we blocking I think we blocking make Run Okay so uh the connection refused that's fine no big of a deal it's good right uh so what we're going to do is oh man it's too funny uh what you want to do is make a function here actually I'm going to make it a top make uh a server uh I think you're going to set the listen adders here real quick listen Adder which is going to be a string and actually what I'm going to do is also the root which is going to be a string here and it's going to return as a file server and maybe an error I don't know this is actually just a convenient function uh to to testing right uh so we're going to do all the shenanigans here uh copy the whole She Bang paste it in here right and then we're going to say that we're going to take the Liston address here uh all the same all the same all the same uh we could do something nasty uh we could say listen addage plus uh this right uh bootstrap notes is going to be we cannot do this actually uh we're going to say uh string root and then notes it's going to be a slice of string right uh yeah like this actually I'm going to do it like this uh string wait it's going to be this right can I do this actually probably we can it's fine now we have the server and we can actually return a new file server here do we yeah why not return a new file server and then we can say something like uh that leaded this this whole thingy and we could say um S1 is going to be make server actually uh make server he going to listen at 3,000 uh what's this the root is going to be actually we do the root itself so we don't need to root yeah it's fine uh now we going to say boot step notes uh that's going to be 4,000 the problem is um actually it's not going to have one doesn't matter because if there are none we're not going to connect which is fine then we going to say s one start maybe an error actually could we do we can't because we need to run this in a in a separate thing like this right and maybe we could do is it going to is it not going to format this for me what's going on uh the reason why I want to do this in a function is because then we can actually catch we can do this right lock uh fatal this is that a thing I think it is yeah it's fine uh we're also going to make a server two which is going to be this guy 4,000 right and then we're going to say that the bootp note is going to be 3,000 right which is easy and then we're going to say here as to start like here it's going on and that will actually uh boot up these two notes I think I think not quite sure yeah it's working the only thing we need to fix is uh transport listening yeah yeah yeah attempting to connect with remote 3000 uh TB trans listening on Port 3000 attempting to connect with remote that's because we have no bootp noes what we could do is basically uh if uh can are we going to do this here I think we could do it here right you could say uh if the length of um s bootstrap notes is zero and maybe we have an empty string maybe we have an empty string that could also be the case to be honest yeah it's an empty string that's nasty probably because we do it like that uh um although the check is good what we could do here is basically uh if L Adder equals zero uh we could say continue actually see perfectly fine uh so we do this stings it's fine we have a logging do we actually want that date I'm not sure maybe we going to make a prefix uh in some sense we could that later um TP transport listening yes yes yes we have a new incoming connection that's fine uh new incom atcp transport I guess new incoming connection I don't like the way it doesn't tell us anything okay uh that's all good all good so what we going to do do we have a sent in the spear wait let let's first things first let's make our server uh it's going to be a map string uh as going to be appear appear to P like this uh I want to have a sync mutex wait let me do uh P lock is a Sy mutex right uh p is going to be make me a map string uh point no no no pointers PE like this is fine it's going to be a peerto peer peer yes yes yes um we could also do some some mechanic where we add peers and delete peers based on a channel but um yeah I don't want to over engineer channels you know it's it's I did I did this in my blockchain series I did this in I think in the ex I did this everywhere this ADP with his channels I'm not going to do it this time because why not why not a mutex it's not going to do anything it's not that it's a performant action adding a pis is just I don't know it doesn't matter it doesn't matter now we need to add P Funk right uh Funk file server on peer it's actually nice to test our own peertopeer lip uh maybe we should actually make one uh but actually open source one but a good one and I think for now it's it's working fine we have on peer uh which is basically where is dial list and accept close uh no on P is basically just um where is on coming from it's just a TCP transport thing right on PE doesn't matter the thing is should this be should that be in an interface where the transport needs to call on pier each time it has a peer actually actually maybe this needs to be in our um of course it needs to be because uh no because it's TCP transport Ops Next Level right or not next level or complete garbage it's either one of two it's binary right there either an Next Level move or it's either just complete dog there is no in between and the weird part is that I have no clue what it is um because you know what you could say yeah but transport needs on peer right because uh each transport will have a Pier which is an interface and each time it's connected the transport can call on peer which then everybody in everybody has that transport interface can call on p on it and and Y yada that's not true I think this is the best option uh where where we have just have an onp which is a generic function which is also generic right it's not something that's hard it's genetic function um this actually crazy because TCP transport Ops and we do on peer which in my opinion should not take a peer but a TCP Pier to be honest uh yeah I think that's the thing maybe we going to change that let me know what you think about this uh I think it's fine because now what we can do I think is uh where is our uh onp thingy and that's what I love to do the most man is the making these things it's it's insane I like it uh and once we have a good lip a good P2P lip we can use it in all of our projects right it's a lot of boiler plate all the time uh so we have on peer which will basically takes a p which is going to be a TCP Pier but that's nasty actually we could say p it doesn't matter uh so this G be compatible with everything later on something we need to think about and an error right because uh this takes an appear oh wait actually I think I'm going to keep it uh this way because I'm going to keep it PE because why because um this will make it compartible for other transports this onp because we have this P yeah yeah yeah yeah yeah yeah yeah because then we can call on p on each trans because now it's only TCP transport but it could be that we have uh web soet transport uh UDP uh whatever you want to grpc whatever so and every and and and and that's why we have this genetic peer thingy right this could be this could be a peer over over uh TCP could be a peer over UDP so this all peer can work on everything if we decided to if you or me me or whatever is going to use this decided to add other transports right okay so this debate is done the debate is closed and hey guys listen um if you have remarks or things you think hey why don't we do this or let's collaborate right I hey I'm open for everything I'm open for everything this is how I should do it but it's not this not this do not this does not mean that this is the best way it is a way it works for me but maybe something is better right we don't know and actually to know that we need to use it right that's why I'm I'm I'm going further and further and further because by using different stuff we know ah damn actually or a function we just implemented is not going to work after a couple days or something right uh and that's why you can make things better and better uh on P what we going to do with on P we're going to say s uh we're going to PE lock lock this thing and then we're going to say defer uh as per lock uh unlock unlock or boy and I'm we going to say as beers with uh how are we going to store this that's a good question it doesn't actually matter we could say p uh we cannot store this guy we need to have some more function in our in our uh interface speed interface right we only have P I think we need to have like um address or maybe we can make it compatible with uh with goine and we say remote adders uh which is going to return a string right and then DCP P close and I'm going to say funk P TCP p and then we could say remote adders string return BC remote adders Network we don't care ah I see it's uh it's uh are we going to do a net Adder why not let's make it compatible I mean if we make this uh more compatible with the go thing I think it's going to be uh I think it's going to be good right especially if you want to open source this peer to peer lip returning a net Adder think a lot of people appreciate that because to be honest uh let me go back to uh TCP P TCP TCP it's in in transport yeah uh and another thing is basically yeah why is TCP p in in in TCP transport and not in TCP package uh TCP file it doesn't matter right um I like to group things a lot of people like to split things out and make TCP the file with only 20 lines or something I think it doesn't make any sense uh but that's also a personal preference I don't matter I don't care I like to group things in one file because yeah I don't scroll through the files that much I just try to search for things and uh um I don't care if a file is 1 million lines or something 1 million is too much but hey you get the point right uh so remote Adder is basically let's say remote Adder uh implements implment the P interface and uh will return the remote actually and we'll return remote address of the uh underlying connection of the pier of it's underlying connection maybe of it's underlying connection all right that's fine so now back to here we could say s B and then say uh we could say remote Adder uh but we are using strings we could actually use uh remote adders ourself but we're going to say string like this right uh and then we're going to say it's going to be P right that's it and then I'm going to return all so yeah that's this and maybe going to we're going to do uh FM log or something I don't know log print Ln or f um connected with peer wait connected to it can we say addit p to the P map something connected to it uh remote which is going to be this and we can actually do B we can actually do something nice right because p is just a p i don't think we have a Stringer yeah we could Implement string yeah we're not going to do that we're not going to do that we can say a remote Adder because a remote Adder will uh it has a Stringer interface which is cool because I think if you go to remote Adder uh it's going to be a net Adder right you see see this implements a string do we want that to be implemented in our P I don't think so right I don't think so uh connected with the remote right let's see what's going on here uh are we doing wait wait wait first of all we have our on peer but of course we need to implement this into rtcp transport where are we where are we making this a you see the problem already let's go to main because we need to implement this this on PE we need to inject the pointer of this function into TCP transport right this onp you see it's going to be onp here uh so that basically means that we need to have our server first a uh can we do let me see what I can fix uh so the server is going to be this guy you're going to return the server here and then we're going to say that the onp transport onp is going to be the server onp uh so yeah is that going to work make run yeah so we have a new incoming connection from our TCP transport I don't think uh TCP we actually want that what's this new in connection yeah we don't want that actually that's loging connected with remote connect with remote so they both connected uh it's pretty fine actually maybe I um I was thinking maybe we want a string I don't know or maybe we don't so we can connect with each other that's fine the next thing we need to do is uh I think P has a scent function TCP P it's going to be a longer episode a little bit doesn't matter uh yeah so TCP P has this Con no no wait where is transport yeah P remote add close we also need a sent right we going to sent which will take in uh a slice of bytes and it's will returning an error that's what we're going to do uh very important and we're going to go to TCP TCP transport new TCP remote that close and all that stuff if we're going to write which is basically a very simple function uh we're going to say TCP pach uh sent uh bytes uh like this we're going to return an error yes and the only thing we're going to say is underscore R is going to be P com uh right right like this we're going to say B write the bytes and then we're going to return the eror um we could also just start this thing but I don't want to do that we are handling the read functions here which is fine yeah yeah yeah so and the next thing we're going to do basically is now that we have the scent function for our Pierce is um each time we want to store we're going to send that to to the other one is going to get that message a store message and then he's going to he's going to also replicate it so that's for the next it's going to be amazing I'm I'm actually thrilled to continue the previous episode I think we created our server right we created our server um which basically I think we also had something in main yes we created our server we have uh connected uh server one with server two let's uh make run real quick what's going on make run yeah so they're basically connected with each other uh which basically means that we can start sending files right uh of course we need to encrypt and all that stuff uh and another um major important thing is that we cannot for privacy reasons I don't think we can store uh wait I I will explain I will explain because we're also storing a key and it could be that our key would be for example uh my NES my NES which basically we don't want that that it's that key is being stored on uh on remote uh servers right so we want to basically store directly the the hash of the of the pad of the keypad of the pad key right uh but that's for later on um today we're going to do I think some some interesting stuff because we need to stream large files uh over over the network right so let's let's get started um yeah so let's open up main that's already here right uh let's let me put that a little bit higher so what we're going to do for example is uh let's say we have S server two is is being started right so what we could do is basically say something like S2 and we could say store file right something like this store file uh at a given uh key and then we're going to say um I don't know we could say that uh the contents the data it could be an I/O uh it's going to be a new reader actually not IO it's bytes right going to say it's going to be bytes new reader and it's going to be for example um my uh Big Data file here like this right and then we going to store this data here that's that's the thing and what's going to happen is uh let us go over to server um bootstrap Network yeah let's do it here right so we could say for example this going to be S uh it's is a file server right and we're going to say store data or store file uh anything right could be it could be legit anything it's a forever anything store right uh that's going to be we're going to store this at a certain key which is going to be a string right and we going to say uh it's going to be an R which is an iio reader and we going to error uh an error right that's the thing like this let's return n for now right so the first thing we need to do is basically first of all uh store this file to disk right then we need to basically broadcast um this file to the network right that's that's the thing to all peers actually uh store this file to all known peers in in the network right because it could be that we only know two peers but these P are going to broadcast it back so everybody uh is going to get that file that's the the the main goal of this and of course we need to encrypt that stuff right that's uh that's for sure that's for sure uh so how we going to do this is basically let's make a a simple broadcast function right so we can we can try to scolding this out let's say it's going to be broadcast uh and we want to broadcast a p now we want to broadcast a p which is going to be a payload and we're going to say error right so this payload uh is going to be a type is going to be a strict and this payload is going to have a key right because we we're going to send this file but the people need to know uh the receivers need to know the peers need to know which key is going to be stored of course for now we're going to just store the key like we it's going to be uh let's say uh let's go back to to main it's going to be the key for example uh my private data right that's going to be my key of course we don't want to store my private data as a key as plain text uh it could be we know that but the others cannot know that right of course it's not that big of a deal because everything is being encrypted but still right still privacy first that's very important so but for now we're going to just store it like this we're going to send it over like that and then later on we're going to we're going to just uh put the hash so actually maybe we should already put a hash anyway we will see so there's going to be a key which is going to be a string that's what we know right and then we're going to have um I don't know maybe the data and that's going to be a bite uh like this right it's going to be a bunch of bites so but we want to stream right we want to stream that bites because of course we need to copy this once but we don't want to copy this to uh you know what I mean we we want to stream this to all the peers because if we it's very important lesson actually uh if you go to PE TCP no um yeah TCP is fine right we have this sand function right you see here con right so it basically takes these bytes all the time uh they want to do that we want to basically stream uh the whole Shenanigans over the connections to all the peers at once some coffee so en able to do that we we going to refactor PE a little bit uh let me return nil here right so what we're gonna do is what I want to do here let's um make this more clear so in broadcast we could say for example 4ore Pier uh in Range s peers right then we could say for example uh let's read the btes here it's going to be for example uh B is going to be I uh read all and we going to actually the p is already bit right yeah yeah yeah no no no no what you could do is basically do make a buffer or something we going to be a new bites buffer like this and then we could say if at um it's going to be Hop new encoding new encoder and we're going to say uh the buffer because that's a writer and I'm we going to say encode the payload right and if the ER is not nil we can return the a right return the arrow here something like that uh what's going on with peach no no no it's not it's going to be yeah this is the buffer yeah yeah yeah and then what we could do uh so everything is in the buffer right now and then we could say for example uh P sent uh buff bites what's going on here uh buff bites like this right that's something we could do but I don't like that so what I want to do is basically delete this whole thing what I want to do is basically this I want to return um hop or actually any encoder we can make an interface for that uh new encoder and I want to basically encode directly to the Pier's connection but we don't have access to the peer connection and then we could say uh and code the payload right but then and then we can Loop to all the peers and do the same with one Pier if that makes sense so let's let's let's make this uh you're going to make this clean listen this going to be insanely good so in able to do this what I want to do is uh if you open up um transport right this Speer interface we have remote adder and all that stuff and we could say so we need the con here right we need the con of the PE to make this work right but uh it's a private variable so what we could say is make a function right like this make a function and say come here right which is going to be turn a NETCOM because a NETCOM uh is basically a reader and writer right that's what you could do uh why is it not working uh yeah of course because ccpp does not implement this but why are we doing this right what it can it can be even simpler so instead of doing this we can do interface embedding right uh we could say send can be here we could just do this right we could say net con just like that and then instead of saying con here we could just do Pier because p is already uh will have all these functions attached to it right so if you go to TCP peer uh instead of doing this remote added close stuff right we can delete all of this and it will it will be perfectly fine I guess because um yeah the only thing we need to do here is and instead of making this Con a variable we could just say uh net con here right just a NETCOM you could actually say uh that this is going to be uh the underlying uh connection of the p uh which in this case is a TCP connection right and instead of doing this we can as a private variable uh we could do this make come uh public right so what happens now is that the TCP P will instantly implement the as a netc it will be a netc it it implements all these functions so that means uh that we can use this directly as um as a as a as a as a as a writer or a reader right directly into this encoder of course p is payload here so not going to work but we could do for example this right uh for range p and uh S Pierce like this right uh we could do this we cannot return because it's going to be an issue you're going to say go new encoded P directly you see that works perfectly fine and then we could say if r y y uh is not n if the add is not then we can return the error right and in this case we're going to return n this will work fine but still what we could do is even uh something better and let's basically say that we're going to make uh Pierce and Pierce is going to be I want to stream this directly to all the peers like a streaming service so what we could do is say uh p is going to be a slice of Pier right any Pier uh is going to be a peer to PE peer actually peer to peer peer like this right then we going to Loop uh for actually this going to be Pierce yeah uh let's let's delete every 10 and then we're going to say Pierce is going to be append Pi Pier like this so we have a slice of Pi and then what we could do is um say that we have a multiwriter multi writer is going to be an IO multi writer actually and we're going to say it's going to be Pierce uh I think it's going to be this actually it's not going to work because uh multiwriter wants um you're going to say it's going to be IO writers right and that's going to work perfectly fine so this is very important to understand right so our P or TCP p or even p uh in general is an interface but P embeds the neton interface which basically um also implements the writer reader interfaces right this is this is a this is the peak of goang engineering I swear to God this is the peak of goang engineering so uh netcon also implements reader writer so what we could do is basically tell us that the slize of P can be as slice of iio writers which we can just append peers into it so we can then make a multiwriter of all the peers and then we could just return uh goop uh new encoder which is going to be the multiwriter and code me the whole payload and we're done that's nasty that's that's not nasty this basically insane I'm not going to lie um yeah I did this before um using the multiwriter and and we going to do some some some some cool stuff um yeah yeah yeah so that's it right that's cool what's going on in Mage yeah store file yeah yeah yeah we don't have store file right store data actually what's going on right my private data so it's now we already heing store data so this is It's is interesting because what's going to happen is that um we need to make this payload thing let me quickly delete this and paste it in here and we of course going to split things out so what you going to see is that the payload you're going to make a payload uh so the first thing we going to do is basically store this on disk and you can see that we're going to have some problems so we're going to say if f it's going to be s store uh write the file the key the reader if there is an error we going to return the error right so first of all we're going to store it to our own disk which basically means we're going to read from the reader but at this case here after we read the reader is empty right because there is already being red it's completely empty so what we need to do because we need to read it because we need to uh also send it back over the network right so what we're going to do is I think we're going to make a buffer which is going to be a new uh bytes and actually I can show you first let's let's let's do some demonstration what's going on so let's say um let's make the buffer yeah let's make the buffer we're gonna say it's going to be a bites buffer actually new buffer maybe it's going to be a new bites buffer right and then we're going to say IO copy we could say uh we don't care of this we're going to say the error is going to be IO copy which will basically do a streaming copy of reader and writer destination and source so we're going to say uh wait what's going on I think copy uh the first thing is the destination what's going on I cannot man nasty uh copy is destination right so the destination is going to be the buff right and the source is going to be the reader right uh I'm going to say if the error is not n you're going to return the error here right and then we going to say fmt print and print me The Buff uh bytes right so if we going to say here yeah if we run this wait of course we basically block here right so we cannot do anything here so we're going to say go and let's time sleep here so it it has time to boot up uh we going to say time sleep um let's say two seconds right maybe one actually yeah right so we're going to go start this thing right so we written to disk right that's fine we written to 22 bytes to dis but then we see that the buff even though we copied from the reader the buff is empty so if you want to send that buff because we're going to make a payload right we're going to say here this is going to be the the P which is going to be a payload and actually what I want uh this should be appointed to a payload because I don't want to copy the shenanigans into a function right because if you have large files so we're going to point to to the to the payload and then we're going to say that the key is going to be okay we need to have the pad key so we don't so we are sure we we don't expose the the the plain bytes of the key but yeah that's for later on so we're going to say it's going to be the key and then we going to say that the p uh the data right the data could be the both bites right that's what we're going to do both bites right and then we could say here um return as broadcast we're going to broadcast the payload that's what we're going to do right and then we're Gucci but the problem is that it's going to broadcast nothing right you can see this uh I think if you do make a run uh actually let's block here so we can see what um what the other site is going to receive uh make run you see it's getting it's getting this uh garbage thingy right wait let me let us let us make this real quick this is actually interesting guys this is so interesting you probably need to watch this a couple times to completely understand but this if you know this you're literally a God what's go if you can do this guys I swear to God uh this is years years years of experience and years of of figuring things out how things work this is nasty so this is transport print consume right so we're going to print out this message but what we're going to do is basically say that we're going to decode this into a payload so we're going to say uh p is going to be uh uh a payload or actually make it better p uh is going to be a payload right and then we're going to say if is going to be uh hop uh what's going on Hop new decoder right we going to decoder hands so called uh what are we going to decode uh we're going to make B new reader p no MSG payload actually we could make this into a reader directly from the T where are so so many things we can do not going to lie and I'm going to say uh decode me this uh thing into a payload can we make this a pointer I don't think it's going to work yeah it is uh if the is not n then we're going to basically log fatal out for now uh this error because actually we we we should not fatal out we could Loop right right this is what going to happen right let's let's make run wait uh what's going on spads I think it's just um uh wait fmt print LM let's say we're going to receive let's see if if if receive receive refuse going on uh yeah I think we need to who is dialing maybe we need to sleep here give this guys time to boot up before they connect yeah so we receive a message uh yeah yeah yeah yeah we receive a message cool cool cool cool yeah I forgot we need to do this I'm going to say print F right and uh we're going to say uh it's going to be a percentage plus v like this we're going to make a new line and we're going to say it's going to be the payload right uh so make let's make run this again you see so it's it's telling us the key so that's the first problem we have so this is this is being received on the other side right so we store to dis and we broadcast and this this this this uh this output is basically on the outer note of the network right and we already see it's my private data which is not good but hey we're going to fix that but you can see that the data is empty right that's a problem and that's because we already read from the reader can I not close this yeah so how we're going to fix this is we're going to do some nasty Nifty mechanics of course because we are the club of the high value Engineers high value software Engineers so what we're going to do is um here so what we're going to do is we're going to make this buff but we're not going to copy right what we're going to do is what's going on we're going to make this buffer then we're going to make uh a t which is going to be iot reader is it a new T reader no it's iot reader and um it writes it from yeah yeah yeah it writes so we're going to make the BFF Heat and the r e is that correct so we're going to read from um wait am I confusing this yes yeah yeah it's this it's going to read and it's going to write to buffer that's cool but we need to do this before we write this to the store right make the buffer here and then we have this t reader right so what we're going to do is we're going to read we're going to write a t reader and then we have the B bites boom We written to dis and we broadcasted it to everyone that's what we did so because uh if you don't believe me we going to see um B can we do B string actually uh B string is here yeah yeah what we're going to do is on the other side we're going to say story that we're going to we're going to we going to going to say this one um P let's do a string of P data and then make run let's go going on here unexpected end of file you see okay I think there there so much it's basically the sleep we need to make sure uh that it's okay because they are we will see so you see my big data file that's what we receive on the other site which is perfectly fine uh I see sometimes we have an issue I guess let me make run we will debug this yeah I think it's something to do with this connection with the time sleeps maybe second is not enough we will see we will see uh yes okay so the thing is uh this consume we're not going to make our our logic here right that's not that's not the best uh approach what we're going to do is basically um we're going to make a function we're going to say here s file server because we know we also need to store it on the on this right on the other side we're going to say handle message I guess uh handle message uh or handle payLo is may be a better thing it's going to be a p which is going to be a pointer to a payload like this and we going to say an error um I think the payloads wait I have an idea I think it's going to be handle message which needs to be a message actually how we can make this even better I'm thinking uh so we have a payload key string uh we could also make a message which is going to be sent over the wire uh so it's going to be a structure and we going to say that the uh man this is nasty uh maybe you should say from going to be a string and then we going to say uh that the payload of the message that could be any I think something like that because then we can actually uh and this is a payload I don't think it's going to be could make it as a data message which is going to be a key data uh so this is going to be going to be a data message right but then we need to make this into a message so we're going to say we going to broadcast we cannot we need to broadcast a message so we're going to say here a message and we're going to encode the message here right and then we're going to say uh broadcast uh a message and we need to make a Constructor we're going to do that later on and it's going to be from is going to be and we don't know the listen address that's crazy we don't have that that's maybe interesting what we need is the listen of the transport let's go to transport real quick dial listen and accept consume actually do we need that listen adds I think we need to be honest listen Adder which is just going to return the listen adders of the transport I think is that a thing because we make a new um file server but we don't Store The Liston address because we sto a transport here I see yeah so I think listen add is pretty fine for the transport interface TCP transport Let's uh make this real quick we're going to say funk uh P that's a p do a p we don't need that transport here here here here here Funk D let's put it higher it's going to be a TCP transport listen Adder it's going to return a string uh we're going to say a return the listen added we don't have this it's private I guess we don't what's going on what's going on here ah it's I see what's going on it's the same thing each how how we going to fix this um because we make the the transport uh the problem is in main you can see we make the transport we make the transport here and then we put that into uh yeah wait we going to fix that later on uh we're going to fix that later on where is where is uh transport interface because I don't like to have a listen address here to be honest so we're going to just uh do something nasty and we going to say from need to be too and we going to say that the data no it's going to be the payload of the message I guess yeah the payload is going to be B it's this data message here yeah and this is going to be done then we're going to say it's going to be a message all right and we're going to encode into a message instead of a payload uh because we can send other messages also right a message here oh it's the same that's nasty uh let's say m uh payload like this it's any we need to switch this we need to switch this and then here we're going to say handle message which is going to be uh a message which is going to be a message we're going to return this actually we could check the error if R is going to be S handle the message which going to be the m n m n M and if the Eros uh is not nil we can uh lock yeah we need to print land these things actually uh right and then we we we call this function and what you're going to say here is basically uh switch MSG payload uh type going to be a v actually do this and we're going to say case if it's um if it's a data message right then we could say print actually can do it like this right we can actually say print is it print F we don't have that that's nasty let's do fmt print F I'm going to say received data uh plus V new line V uh let's return n is is going to work all right we we still have this unexpected end of file we need to fix out why figure out why this is happening we will see we will see normally it's going to work perfectly fine no it isn't uh wait wait wait wait wait wait wait what's going on what's going on what's going on so this data message is going to be the payload you're going to broadcast that message yeah uh key B and bites and then we going to say this from uh I don't think we need the from by the way but hey the end of file why do we have that um is it B bites and the message in broadcast and broadcast will actually uh basically hop and code the message I think it should work but I think we have let me quickly check what's going on here uh do we need to sleep longer I have no clue to be honest I don't think it's a problem to be honest guys but hey we can try we can try okay so we we Rite it that's the thing right so that's cool so if if you open up our thing that that's fine still have some issues I think you make a mistake uh my big data file here so that's perfectly fine in the 4,000 Network which is basically server two all working all working like intended uh just one more thing I want to what is this um as you can see the camera is at top right and I have the lunar Vim shenan go going on um I think it has a better terminal uh bigger fonts and everything so that's fine uh so let's make run and so we can continue where we left off right and I'm going to say the next couple of episodes going to be super super important we're going to do advanced stuff uh and I can swear to God that if you know these Concepts very well um you're going to be you're going to know more than everybody else I can swear if you if you get if you grab 10,000 go developers uh I think only handful will know how these things going to work so we see that we have disc corrupted data uh here right so basically uh that's because uh if you go to our decoder right you can see our decoder which is basically let's open up thisp I'm going to show you real quick normally you guys should know if you follow along uh the decoder is basically the staying in the read Loop where we decode a message right and uh what we do is we decode the prefixed set of bytes a preallocated slice of 1028 bytes and you can already imagine that this is perfectly for or normal messages but it's not suited for big files 4 GB 8 GB 10 GB that's that's impossible um it's already too small and uh upping the size will basically uh make every computer crash because most of the computers don't have so much RAM to work with so what we're going to do is we're going to stream uh we're going to stream data directly to a file right so we need to do some some changes for that so we have our server here the first thing we're going to do is we're going to we're going to delete some stuff test some stuff and then make it better so basically this data message we're going to delete this real quick uh this message is perfectly fine I'm going to everything in here I'm going to basically comment out um and the next thing we're going to do is basically Let's test something let's test something real quick I'm going to say um foror p in Range s p is going to be this we're going to say uh if R is going to be Pier sent uh some bytes which we don't have yet and then we're going to say um add not nil we're going to return the error here then uh let's let's make a simple message um going to say this is a message uh this is from are we actually going to use this I don't think we're going to use this message for by the way uh we're going to say that the payload is going to be a slice of bytes just to test this is just a test to give you a concept uh what's going on and why we need to do this it's very important to understand uh this is really really really important trust me um so we're going to say here for example uh um it's going to be the storage key for example we going to send the storage key simple thing then we going to actually encode this with G encoding going to say if R uh is uh uh new encoder and we going to say we need a buffer actually let's make a buffer real quick going to say buff is going to be a new byes buffer which is basically just exactly what it is buffer and we're going to encode that in the buffer because a buffer is a writer and a reader and then we're going to say encode and we're going to encode the message uh I don't know do we need a poter I don't think so and then we're going to say R is not n and we're going to return the r uh let me find the plus sign here what's going on like this perfectly fine so we're going to have a message we're going to send that over to all peers and then we're going to return n here real quick we're going to clean everything up trust trust trust and then we're going to see where we're going to fetch the message on the other side of the network on other notes right where do we do this it's here right so we're going to handle this message we're going to comment this out uh we're going to comment this out we're going to call this we're going to delete this this is going to be an RPC this is going to be an MSG we're going to say RPC is going to be RPC payloads we're going to decode the MSG like this and then we're going to say fmt uh print Ln or maybe print F actually I'm going to say receive um percentage s and we're going to make a string out of the MSG payloads and we're going to cost that to a slice of B Because payload is a um and we're going to make better messages this is just for testing a payload is an any type and we are sending bytes on the other side remember we made this um storage pad B thingy so we're going to cost that and we're going to print that out uh so let me quickly make a run this to see what's going on uh of course in the spear uh scent yes we need to put in the buff bytes just like that and we're going to say make run and see data message okay we have some relics uh left over message I'm going to search for these guys here one and then we have I think that's it let's zo make Run Okay so the the the thing is running that's fine okay so we received storage key so everything is working like intended right so but that's what we're going to do we are going to send a message type a specific message type it could be hey uh a message type store store file which will basically means uh we'll hold the key and um so we know oh the next thing we need to do is open up a stream because we're going to receive a file and we need to store it right that's what we're going to do with all complications that uh probably will arise so how we going to do this right so we're going to mimic a stream we're going to mimic a stream uh we're going to mock one here right so basically this one uh so we we sending this right what we're going to do is we're going to make a simple payload right and we're going to say this a SLI of bytes and we're going to say this large file right this is going to represent a large file which is clearly not but hey um what we're going to do then is we're going to again loop loop again to all the p and we're going to make this better it's just for for demonstration right so the first thing we do is we send the message describing what we're going to do storing retrieving blah blah blah so and then we're going to send a big file that's what we're going to mimic here so we sent the message and then we sent the big file which need to be streamed right uh um but you're not going to send the above bites we're going to send the payload right yes right that's what we're going to do so if we test this right you're going to get some issues uh and that's normally fine that's because um let's open up servers we are in by the way right um I think we already received this first right yeah it's this unexpected Shenanigans um so we received the storage key already which is fine but then something happens right uh so we're going to fix this real quick and actually what I want to do here is a new line right so what I want to do is in this case I basically want to read right so we first read a message and then we're g to open up the the file for the stream right so what we're going to do is um I'm going to make a buffer no we don't need to wait the first thing we going to do is we we cannot read here right it's very important and it can be some confusing I'm not going to lie uh but hey you can always jump in the Discord and ask questions so what you could do here is basically um we cannot read here right so well we are reading here but we always transferring this RPC message to the to our server that's the way we communicate but we need a way here to read from from the pier if that makes sense and the way we're going to do this is to fetch the peer first so we're going to say that the pier okay is and that's why we need to have this from address in in the RPC method right so we're going to say p okay is going to be S Pier RPC from right and we going to say f not okay and maybe I I'm going to quickly can we return another no let's Panic here because that's very important we have a p it's going to say no peer uh in PE map actually P not found maybe uh peer not found in the peer map right uh then we have a p here let let let us see if we if we can find a p if that if that's working fine uh let's say just be it's probably not going to format but it doesn't matter just for testing purposes real quick right uh RPC from we don't have that right so uh I think we have a problem in this message real quick yes we're going to delete this net address we're going to make it just a plain string and then we're going to open up um TCP here and we're going to say instead of a remote address we're going to make it a string which is fine let's this this mouse is in the way uh then we going to make run just like that and see what's going on see if we get the pH okay so we still have this interface uh conversion what's going on here real quick um stop to use quit action that's nice uh server 143 actually what's going on here yeah it's this one I know I know I know know so what we're going to do we have the p is working that's that's that's good news right so what we're going to do is we're going to say we could say per read but we can't right and we're going to fix everything but first of all I want to I want to show you something right I want to I want to make things uh work so what you're going to say this is uh this is a TCP right so what we could do to access the read function of the connection of the underlying connection right actually I think um now we can't uh um is that we can we can read that's amazing that's amazing uh so we're going to say p read let's make a simple buffer now I'm going to say make a slice of btes Let's Make A th000 and we're going to read B and we going to say underscore R is going to be period so we know that something is wrong maybe we going to do this uh this need some that did need need some effector that's for sure but just to make things clear uh let's Panic here on this error because normally it won't happen I think all right the problem is right now that we are stuck at reading right so we basically are stuck uh at reading here from the connection um I think let's Panic here and if the Panic is not getting triggered we know that we are stuck I think we are stuck yes we are stuck right the problem is guys the the big problem is that in this TCP we have a read Loop here and it's the same read loop from this connection right this connection is the same connection sitting in this peer here in this peer right so the problem that's going to happen is that they going to read at the same time from this connection which is not the problem why we are hanging it's the problem that maybe after hanging we're going to have inconsistent results because W is going to read first and and and so on so we need to find a way to communicate between this gou team or this threat or whatever and this read Loop because if this message is going to be a message stream a store message or something then we know we need to add uh a weight group or something and that's exactly what we're going to do so I'm going to install a weight group and I'm going to say uh it's going to be a sync uh weight group like that and we're going to say uh wi is going to be a sync weight group just like this right and what we're going to do is and of course we need to check the message and we're going to all do all that stuff uh you will see first of all I want to make I want to test things if this actually going to work what I was thinking to do so uh what we're going to do is we're going to decode this is all fine uh let's say we going to uh we do p VG it's going to be IG adds and we're going to say add one then we're going to say print fmt uh print L waiting uh till stream is done right that mean we're going to copy this here we're going to wait the weit group is going to wait here right and then we're going to say here um stream Dum continuing normal read Loop that's what's going to happen all right so let's let's try it out okay so we are waiting till the stream is done right so that's cool that's that that's very important aspect so the thing is if we are waiting here we cannot continue the read Loop right we cannot continue this for Loop which basically means that this decod or decode will not get triggered so it will not read or read stream and will interfere with the stream we are actually going to read here if that makes sense that's the thing and I think it's pretty nice of course we have some issues uh because this reading Shenanigans is not going to work for some reason um although we sending this file to allps though um yeah I think I know what's going on um yeah um we need to sleep here I guess because it's going to send so fast after each other that we are going to decode this into one message I think that could be the problem not going to sure not quite sure I'm going to sleep for the um to be to be sure actually uh it's going to be let's let's sleep three seconds or something and uh the reason we are going to fix this later on is again a fix we need to make is to uh fix our um or or a default decoder that's not enough wait so we received the storage key which is nice that's the first bunch of bites we need to receive is this one that's fine oh what are we doing no no no it's fine we sending storage key here uh and then we are going to send back a payload over these Pierce yeah pier and payLo which is this large file that should be fine so why don't we receive it here um wait I'm a little bit confused now so we make this bite we read and we we cannot Panic here for some reason it's not going to trigger no we need to wait this seconds before the stream will arrive yes oh we Panic DDD that's fine that's fine fine fine fine fine um yeah yeah I see of course we're doing this we are so bad we are so bad we don't need to print this here right we're going to wait wait wait wait man man man man we're going to print here right that's the first thing we're going to do we're going to print our first message the storage key then we're going to grabb the peer then we're going to read from it and then we're going to print um again but we're going to receive Big Data wait we're going to just do nothing we're going to say um wait this going to be this it's going to be a string of the buffer I think that's fine let's see what's going on boom then we have a large file that's perfectly fine this is what we see so I hope you guys see what's going on so the storage key is getting fetched from here which will then be piped into W group uh which will then be piped into this RPC message which will be consumed here we decode the message here and we print it out here right here is where we print out the message the storage pad then we're going to fetch the p from who did we received it we're going to fetch that PE in our peer map we're going to make a bite and we're going to read the next incoming which basically should be the stream that's incoming right because this is not going to read because we block with this group right and the next thing we need to do here is basically after we um received our big file what we're going to do here is just say p VG and we going to call it uh d right like this and then uh we can make run a PG undef find yes of course uh the reason why we cannot do that is because uh p is basically um transport here right p p is an interface and we only have net and scent and net and sent right so what we could do is we could give it actually another interface and we're going to do that but another neat trick is to basically cost this to a TCP perer um but I wouldn't do that uh because then it basically abstracts completely the way um it will not abstract the way why we made the speed Dynamic uh and and generic right so we're not going to do that we're going to fix that later on uh we're going to make run and to see if this works so normally what we should see is a complete round trip of a complete streaming uh Shenanigans right we're going to receive you see we received the large the large file here and then it said stream done continuing normal read Loop and everything is Gucci okay but now we need to refactor this into something that's actually usable because this is spaghetti wety right this is arms are heavy and knees weak at the same time so first of all it's good that we have this right um yeah yeah so what we're going to do is first of all uh we're going to have a message which is a payload any right then we're going to make actually we should actually uh we should split these messages out but let's do it here for now we're going to say type it's going to be a message store file the question rather is um yeah why not I'm taking because message store file uh a pad key is somebody receive a I'm sending a bad key to you that means that I want to retrieve it no it's going to be store file you're going to say the key and the key is going to be a string maybe it's going to be a pad key to be honest or a pad name the pad actually the key let's make it key that's that's better so we're going to store a file based on a key so what we're going to do if you want to store data uh we're going to make a payload uh and that's going to be not this one it's going to be the um it's going to be a message store file yes and we going to say that the key is this uh a low small case actually I'm going to say that the key is going to be the key we give it right there at store data that's fine that's fine then we're going to uncode a complete message we're going to send that to all the peers that's fine right let's let's keep it like this we're not going to hassle with these things right now uh so we're going to comment these guys out and the next thing we going to do let me oh my back hurts once again man the next thing we going to do is basically see if we can fetch this thing on the other side which is basically here um what is this a t reader yeah that's because you're going to yeah yeah see that's that's for later on here um this is going to be the message I think this is not going to work right this Bel bite it's going to be nasty uh what we going to do here is quickly actually what we're going to do is let's print it out in a in a dirty way in a print fway going to say percentage plus v uh new line which then we're going to say message and maybe uh let's only print the payload let's see uh what we get nothing um we're going to decode the RPC yeah this should be a message what's going on here what is going on so we make a new by buffer we encode that into the buffer we range over all the peers and then we going to send the buffer bites to all the peers yes so why don't we receive anything um we don't have any OT even what's going on here I'm confused real quick don't we get any messages anymore what did I do what is going on wait no nothing is happening it's main it's main broken I'm going to store data which is basically um this private key my private data yes yes yes but we don't consume anymore uh why is that we're going to add one that's fine what's going on am I still sleeping no that's possible we we we don't consume anymore why is that um are we actually calling this what the hell's going on we panic in DDD that's fine because we call store data right so that's good uh we're going to encode this we range this uh let's Panic here maybe to see if it's uh being being being sent of course of I think so there's no reason to wait did we made a mistake uh we are blocking at Pierce we are blocking uh before we s p is going to block I think it's the Hop en coder it's the Hop encoder for some reason that blocks yeah you can see that we are basically blocking here but not here has probably to do with these messages I think ah I know what it is uh I think we have a book I think it's uh I know what it is it's um look at this guys and we need to fix uh this thing it's going to be a go register actually um go register it's going to be which is the thing um message store file that's that's the interface type you need to register right is anything that we are placing in the any anything that we are placing any kind of type we are we are embedding in this any type let me open up message a message here you see this payload uh all types we we place in there needs to be registered with the Goen coder otherwise it cannot register an interface that's the problem that's I hope that that's the problem not quite sure um that's why it's it up uh no it's DDD is the same thing let's DD I'm going to delete this right so now now it's working right let's make run yes uh payload is key my PR data that's perfectly fine so we have the key we know it's a storage we know that the message type is a stream a a store file so we now um can open up the connection for streaming open up a file and pipe these two together and make that happen and that's what we're going to do and refector that stuff in the previous episode basically let me comment this out we basically did um some Shenanigans where we could uh store where we could actually send a message type store file and if we receive it on the other side on a note we can uh we know it's it's a store file so we need to open up a connection a streaming connection right and uh we get this large file right here so now it's actually time to store that into a file right to store it into a file and to clean things up um yes so let's get started so basically we make this message here of course um let me quickly think we're going to encode this stuff and then we're going to send that to our peers we're going to sleep here that we need to fix later on all right so let's let's go to here right because here is where we're going to read from the P right here is where we actually need to store that stuff so why don't we clean this a little bit uh up to be honest so we have this handle message here wait uh let me see we decode the message yes yes yes okay cool uh what you could do here is basically let's comment this out so we're going to handle a message which is going to be a type of message which is fine we don't have a data message we're going to say case uh probably the message uh store file yeah like this uh let's make uh another function going to say file server uh handle message store file which is going to be what going on and that's going to be I think do we need a from we probably need that right from it's going to be a string and then we going to have the message I think it's going to be yeah a store file message I guess message store file maybe an eror here right and let's uh what we're going to do is um return null here and see if we actually can can make that work we're going to say uh print F we do a percent fee P Fe new line and then we say the message here we going to say return s handle message uh store file need to warm up not going to lie and we going to say V and from we don't have that um I think we're going to do here in handle message we are going to get a from which is going to be a string pass it in here so we're doing all that shans let's comment this out we're going to decode it so we're going to decode this message and then we're going to say if it's going to be S handle message RPC we could actually handle the decoding there and handle message instead of this uh thingy but it doesn't really matter uh so we going to say message I think it's going to be the message payload right yeah if the DAT is not nil we going to uh maybe a print a l here uh like this the error and then maybe return or continue not quite sure what you're going to do um that's going to be the message then what's going on and handle message wait let me quickly see it's going to take a message itself yeah I see what's going on uh we need the message here and then we need a pointer which is this which is fine all right let's see if this con um is going to work let's see make run wait uh or we receiving this let me quickly check uh received store file NSG like this right should work delicious coffee yes receive file private data is the key that's fine um okay okay okay okay okay okay we we can clean things up right so we don't to do we're going to fetch the p and all that stuff yeah yeah yeah yeah so that's what we need because we're going to open up a connection right so what we're going to say is um the same thing I'm going to say p uh okay is going to be ASP from right uh if we don't have okay we're going to say fmt error f p and then percent s in the P map we could save from some nice error then we have a p here here that's fine let me open up a server on the other side so we can actually um see much better what's going on and I'm getting a little bit of a cold or something I'm not quite sure what's going on and that's my own fault because I'm basically uh walking outside without any um jacket or something you know just bare naked almost I think this is good it's he it's he it's so we have the p and then yeah Okay cool so what we're going to do then is basically we know that's a file so we could say as uh as store Write we're going to write um the key we're going to write the key and then we need a reader which is basically the peer right we're going to read from from the spear and if the error is not nil from the storage we're going to return the error from here actually we could return right um we could just return this H are we going to return this or are we going to do it like this maybe maybe they need to be some logic here later on not quite sure well let's just return it let's just return it and we're going to see what's going on here uh okay taking a comfortable position yes what's going on here so we have this payload that's my mic CD kicking in right again once again so we're going to handle the message then we're going to do la la la la la and the speed and done and all that stuff we going to basically do delete this um and then we are going so what we're going to do here is basically uh again assert this to a TCP P do we have this Weg it's going to be a peerto peer TCP I'm going to call done on this we need to fix that um let's delete this folder because we're going to see if we're going to store something let's see what's going on right let's see what is actually going on okay I think we okay we have this folder but we don't have any contents in it okay okay and I also saw that we have two uh read streams which is not um what we want of course we are a legit trash right look at this of course of course not going to work uh what we need to do is this and if the error is not nil we are going to return the error here and then we need to uh call dumb and then we can say return no let's see wa the stream is done uh okay we are blocking and I think I know why but still I think we should have some file yes that's already been done so we can already um call store on a server it will broadcast this and then the other server will just store it but we're blocking and I know why I will I will explain I will explain exactly what's going on so basically uh what's this let's kill this so what is going on is uh let me open up store uh real quick here so if you open up store let's go to right uh stream it's actually small caps right right stream here so right stream is basically going to uh copy right and we tested this and it's all working fine we don't block here but you see I'm going to do a panic here so you know here with some exclamation marks you will see that we are blocking and that we don't hit that Panic although in our test it's working perfectly f as because we're using a bytes uh we make a new reader out of a slice of bytes which basically will return end of file um if we had the last bite written right you see stream is done and we don't panic out so the problem is that if you read from a connection right a connection will always will not return in the file so that's why basically our storage keeps waiting for new stuff to write in in in that reader so what we need to do is um a couple things we could do we could say copy n and then say we only want to copy 10 bytes or or n and and certain bytes right that's how we can fix it but we also can fix it by using some kind of a limit reader uh but where are we going to do this limit there where are we where are we yes so we basically sent this file of course this needs to be a file that's for later on let's first fix where are we doing that stuff man here we store right so we need to have a way to find out uh how many how many bytes this this is going to be because we could make this into an IO uh it's going to be a limit reader limit reader like this and let's say we want to read how many bytes is this thing let me open up um I don't know let's say we want to read 10 bu or something right and we're going to make run then normally it should um you see now now we Panic right but the problem is we only uh because the limit reader basically will say yo this is a reader but uh only read the amount of bytes you specify if you know open up this file you will see that this large right we only have written 10 bytes so it's actually an easy fix right so we need to find a way to get uh to get the size of of that thing we need to let uh the other side know what's coming in uh so what we could do is basically open up our message this one uh message store file we could say actually the size that could be an INT right so that's what we're going to do and in this case uh large file is basically this large file is 15 right uh and you will see we're going to specify the correct size uh not hardcoded in a in a in a in a bit of time so we're going to send that over so basically that means that if we handle this message um handle message store file this is here right right so we can see a limit readed and we going to say it's going to be um what's going on here it's going to be p and MSG size what's going on here yes like this what going on here an N64 okay okay okay okay okay uh it's all fine we going to we're going to change this hey all good my man and let's make run real quick and see what's going on what's going on everybody's sending me messages man it's legit crazy boom everything is working like intended we got this Panic uh and let us see boom this larg file so now we have a way to actually completely uh unblock here and we are fine right so we're going to close this um that's fine fine fine fine fine uh okay okay but now we are sending this large file which is basically not what we want to send right um what is this reader uh that's going to be the reader we give it so that's fine so let's delete um let's delete pent and let's do something like um IO copy which is going to be a streaming copy right we're going to say IO copy and we're going to copy to the peer and the reader is going to be the reader we give it or we could say by let's just try it with this uh by new reader payload and we're going to say maybe we going to say NF this and then say if the error is not nil we can return no we cannot return can we yes we can I'm going to return the error here and then we could say here fmt print received and written percent D we can't to disk we need to do it like this and just for logging purposes and let's see if that's going to work yes 15 bytes with dis all good all good but now we're basically doing still this are we doing this large file yeah we're doing this large file right let me quickly see if it's working double check yes yes yes all fine so what we're going to do now is actually take this reader right that's what we're going to do the reader we actually give it and store data in our main right you see in our main uh we are calling here uh bu new reader my big data file here and I'm going to store this at my prev data key and it's going to be the data we give it right so instead of making the spay load here we're going to say we don't need to make a byes new reader because it's already a reader Let's test that out make run okay unexpected an a file how is this possible we going to from AR which is this thing here right I see what's going on or not no I don't see what's going on I thought it was something to do with this with the file size maybe it is is it we can't right I think it is by the way it's stting at the same key um yeah I think the problem is that we don't know going be 15 uh 22 just counter cter bites manually is that the problem yeah that's problem now it's working fine right all right so we need to find a way to get actually uh the size of the file um so if you want to make this reader right the first thing we need to do is actually store it right we're going to say s uh it's going to be s store uh and we could say no not store s store right the key uh is going to be the all right and then you're going to say here as not n we could return an arrow here right just like that but the thing is uh that we need to do our let me open up server real quick T do we have a t t t t why can I not type what's going on T here man what is it doing yeah so we need the ster that's what we need we're going to copy this hop hop do it here let's delete this uh we can do this right we make a buffer we make a t reader we're going to store the file um this buffer can we reuse that buffer no I don't think so let's make it the message BFF then let's make it a message buff what can we do with this T we can't T can only read right T can only read so we have um we store it to our own disk then we're going to send that to the network to broadcast this it's actually in here all right uh let's delete this function okay okay okay so what I want to do actually in store is find a way to return if you do right stream what I'm going to do is actually return this and it's going to I'm going to return an in so we don't uh restore nothing we written nothing uh 0 n actually no that's not true it's going to be n that's an we're going to do it an uh an N64 for some reason it's an N64 like that and of course our test will be broken it's going to be right we're going to do the same thing it's going to be in N64 which is the file size yeah so now we could say uh this we could say um it's going to be T you could say n or actually size maybe uh yeah if add is not nil and then we pipe the size well pipe we're going to assign the size to the size is good very nice and then I think we're good let's uh let's open up this thingy let's delete this what's going on Windows man all right so uh all folders are gone let's make run let's see what's going on I store right that's basically in server 160 I yeah see it's a he right uh let's do this because we don't need this make aun yeah I think we uh up or t reader not quite sure this is T B bites it's this B oh yeah yeah yeah of course I think uh we made a mistake here this needs to be the message bth I guess is that true received and written zero bytes to dis e um of course we we got these two files right and we got nothing here right but we got Big Data file here so it's it's who is sending this yeah it's it's two right so we store the data so we store it at our own uh disk is fine right we stored it at our own disc but broadcasting is uh in problem or not what's going on yeah yeah yeah yeah so broadcasting is a problem wait wait wait wait wait uh oh yeah we do R that's not true of course we made a mistake this needs to be the buffer wait we need to be careful right because uh these file namings are basically blocking us um yay oh we did it we did it I think it's going to work so we have 3,000 here file here file there yes we distributed our storage man amazing all right but hey we are still not there because it's garbage right it's garbage code let me quickly do my um the serious position the position where we where we yeah if I'm in this position it means it means uh things are got to get serious right all right so we do these things I have this this this Micro CD man it's crazy what's going on why am I why why why do I have that okay so I want to change some names because this is the buffer this is a message buffer message buffer buffer that's fine that's fine that's fine how you going to name this um let's make this a file buffer right let's make it a file buffer and then we're going to say here that that makes more sense uh file buffer that makes more sense that is fine H H hop cool cool cool I think the store data is is kind of good maybe we should do this to make it even more cleaner right that's fine I like it MSG is this one I like it then we do we decode a message here here that's fine that's fine okay cool that's that that seems that seems good that seems clean where is this one and then this message thingy handle message what we do here is basically this one I don't like we need to fix that we store it here what I'm going to do store is actually um delete this thing so we can actually do it here and we're going to say n uh like this and then we could say here uh fmt written uh bytes to disk new line of course what's going on here what's going on here and then we're going to say uh it's going to be n then we're going to call P done but still we need to fix some stuff because there are a lot of things not okay because right now we do this here in TCP transport right you could see we are hardcoding this stuff uh because it could be that we are just sending a oneoff message then we don't need to lck the stream so we need to have functionality for that that's what we need to do uh what also we need to do is try to uh retrieve files uh if we can uh store a file if you can retrieve a file that's fine we need to do the encryption clean stuff up make some tests and I think then we're almost done with this of course you can expand upon this uh much further and further further but I think if we all have these things in place we have a very nice project that we made um which you guys could use uh to get a I don't know a higher pay job or something this basically if you show this guys be honest um they they they don't know what's going to happen uh in the previous uh episode if I'm correct me if I'm wrong uh we could actually uh distribute our files so if we store a file uh on a certain key we can actually uh distribute that between all the connected nodes which is perfectly fine which is actually the intention right so basically it means that if our uh computer blows up uh our file is safely stored somewhere else which we should able to retrieve if we don't have it right so that's what we're going to do now um yes that's what we going to do now so let's open up uh this thing first of all I think we need to do is basically um inore data right what we do here is this a bunch of thing right this this whole shebang what this does is it basically encodes the message and then it's going to send to all the peers uh and I think we should have a broadcast message do we have that yes broadcast here I think we're going to rename this to stream and uh actually uh make a new one we're going to say file server uh broadcast and we going to broadcast a message it's going to be a pointer to a message uh which will return an error like this right let's delete uh let's clear the highlights uh and then we can actually copy uh this thing so let's copy the buffer Boom place this in broadcast and uh instead of we could say just buff here uh like this just say buffer and I'm going to say buff bites and return n here I guess um so this is going to basically encode it and broadcast this to all the peers and now we can uh here say if the eror is going to be as broadcast uh point it to the message if the error is not nil just going to we can return uh return R which is fine now we going to sleep and we going to fix this sleep uh very soon very soon then we going to copy the whole sh bang and I think think we should do a multi writer uh here soon I'm going to say to do and let me do a high comment uh gfg is going to be green like this fine uh to do uh at uh NDM use uh a multiwriter here like this myty a myy a multiwriter yes um so that's fine for now is this going to work let me quickly test make run to see if this all working perfectly like intended yes right uh we have written two times which is basically one on 4,000 and one on the 3,000 server good good good so the next thing we going to do is um store data actually what I'm going to do I'm going to I'm going to rename this to store actually um it's not going to work so we're going to say store perfectly fine everything is out we're going to call this store and I'm going to say funk s file server and we're going to call this get which is going to be a key string and that will return I think it's going to return an IO reader right and an error like this right so if we want to do a get is basically the first thing we're going to do if we're going to say um if s store has if we have the key then we can retrieve it locally right then we can say return as uh store read key right but if we don't have the key right then we can actually say um going to return n here actually let's let's just Panic right uh don't have actually yeah you could do don't have file locally right that's what we're going to say here uh which then because I think we already have these files so we can comment this out and I'm going to say um or error is going to be S2 get and let me get some uh Fu which we don't have and if the error is not nil we're going to uh log fatal the errors right and otherwise we could say that the B uh R is going to be IO it read all the the reader here if let's copy this real quick like this and then we can say fmt print Ln the string of the bytes right let's make run real quick it's going to panic out right because we don't have this Fu thingy right don't have file locally which is fine but if we say uh that the key is going to be my private data right and we do make run then it's going to what's going on let's read all what am I doing private data like this that normally we should we should get a file Big Data file here right that's actually uh you can see big data file here that's that's what we stored in these files right so it's good it's working like intended right so if we don't have the file locally we're going to actually search for this file in the network right so we're going to say type uh message type get no message type message get file it's going to be a structure right and we're going to say I think we only need a key for now right and then we could say something like the message is going to be uh a message the payload is going to be a message get file and we're going to say that the key is going to be the key we want like this and I'm equal to if f is going to be as broadcast I'm going to broadcast this message and if the error is not nil uh we're going to return the error like this and uh instead of saying Panic we could to a print uh F don't have file locally key right don't have file locally uh we could say fetching from Network like this and then we're going to broadcast that stuff and uh that should be handled on the other side of the network hey so we're going to handle a a message here so we're going to say case message get file we're going to say return s handle message get file from V we don't have that so we're going to say funk as file server handle uh message get file what's going on like this and that's going to be from string and of course a message get file is it a pointer we don't need a pointer because we didn't do it in the other side we going to return an error um yes let's n and say fmt print Ln okay we need to get a file from this and send it over the wire uh let's see if this is going to work actually what we need to do is um block real quick on get otherwise it's not going to work we're going to broadcast this and I'm going to say select real quick to test it out uh what's going on clear make run um yeah yeah yeah of course we just copied some stuff actually a handle did we uh 79 that's not going to work uh and then 89 yeah of course we we we we turn yeah uh yes of course cannot use message as message and broadcast okay okay okay fair enough my friend you're right and if you're right you're right so we're going to do this Shenanigans my big data file here yeah okay good that's because we actually um we have this key right so we're going to see um a new key we don't have that's something we don't have in our in our storage right so normally uh it should now send message okay so we can see don't have file uh blah blah blah locally fetching from the network that's fine but we also need to make sure we can send our new message over the network is this thing we want to what's going on actually what did I do copy this paste it in and then we're going to say message store file we also going to say message get file right so remember for the go and coding we need to everything that's basically could be an interface in an any type anything that could be in there we should register that to the go and coder so that's what we do and then we could make run to see uh cannot use blah blah blah again I think we made a mistake it's because uh like this my bad my apologizes so normally right now we should have um yes so need to get a file from disk and send it over the wire right that's uh a thing wait until the stream is done why is that it's because we lock it yes yes yes we need to fix that because it's an a dirty thing so we sent that over the wire that's fine completely Gucci um here so what we're going to do here is first of all we need to uh make sure that we uh what are we going to do here maybe you could do ifs has because it could be that our remote doesn't has it right you're going to ask for all the peers hey yo give me a file but if he doesn't has it he doesn't have it uh and I think we should to respond with something I not sure what we're going to do here I think you're going to say if has uh MSG key if we don't have it uh I don't think we going to we just going to print something out we going to say print Ln of print or print F rather um uh cannot fetch cannot read file from disk uh actually file does not on disk all right that's that and if we have the file we need to basically fetch the file uh we need to fetch the file it's going to say that the um it's going to be a reader and an error right and that's going to be s store read we're going to read uh MSG key right and if there is an error of course then we're going to return an error and now we have a read here right so we have our reader here that's what we're going to send over the wire so we need to open up uh a stream actually with the connection and that's basically the p uh okay is going to be as peer from right and if not okay which basically mean this spe does not exist so we could to return an fmt error f p not in map whatever like this then we have a peer so what we could do then is basically copying uh files from this guy to the peer uh we could do that with um n r is going to be IO copy very important uh thingy and the destination is going to be the peer and what we are going to copy is basically the reader we just fetched from our dis and that's why we're using readers right you could say yeah but why are you using readers in in our storage and and people always use bites bites stop using bites right stop using btes you should use readers because it's compatible with the whole universe you know what I mean reader is so compatible you see why we're using read is because we need them it's Plug and Play It's Plug and Play boys and girls and everything else uh then we going to say if there is an error of course we're going to return an error all right and then we could we could actually log this out I could say parent uh f um row this is root a thing and I'm we going to say written n bites over the network to from and I made a mistake us that's fine now let me quickly see I don't think it's going to work but hey let's test it out listening to the transport uh of course we not we we're not going to have that file right so we're going to say does not exist on disk uh no such file directory open that's cool that's cool why is this uh we are opening stuff oh yeah yeah of course what what are we doing fmt print F we could return an error we need to return this as an error actually I we don't need a new line here uh is this so right so this going to be much more cleaner so uh like this right so it's it's telling me need to serf server file uh but it does not exist on the dis right that's cool uh just this little typo here like this and then we're going to say f uh file server stop du to server action quit uh not quite sure why that is is it probably for um handle get file here is here we going to handle a get message oh yeah we return heat yeah I see can we continue here I'm not going to do anything actually because these these errors causing um need to Sur F but I think that's better yeah uh and this error is basically not not that good um file server stopped due to error or user qued action something like that it Mak more sense each time we return here this function is going to get T first right uh and go and I think we're going to do the same thing here to be honest don't want to quit we just want to print out the error right and uh we could actually say uh decoding errors uh like this copy this paste in heat and we going to say heat handle message error much more cleaner eh all right intense intense not going to lie it's intense boys but it's nice it's cool I like it I love it and I hope you love it too I just want to make sure you guys are absolute animals on the keyboard with go and it doesn't even matter if it's with go this is basically uh programming this is about programming right this is go okay but you can do it in every single language out there it's just knowing how to do things is just knowing how connections work how how it is what it is if you you can literally give me any language and I will make the same thing literally just rust I don't care uh rust python even in JavaScript call me a language and I will make it happen although goang is my best language because I know a lot of things in the top of my head and in rest I don't but it doesn't care because all the things I don't know I know where to find them you know what I mean it's it's all it's all the mindset it's all knowing how to do things and if you know how to make these decentralized distribute storages you literally can make so much because you know these Concepts that's the most important thing to know uh and and even though these Concepts maybe you don't don't want to build a decentralized uh content addressable storage knowing these stuff can help you build other things you want to build right it's it's it's just knowing these principles this mechanics all right so okay cool what we're going to do is uh we are 4,000 right so what we could do is uh we are 4,000 which we're going to delete the whole folder of 3,000 uh 4,000 yeah what's going on here still is this a filter real real what's going on anyway it doesn't matter so we don't have um or folders so we're going to get the my private data which then basically will um well this this this we will have this right so we're going to actually can we can make a log line we could say ft print F real quick here and we're going to say got file percentage s serving over the network actually serving file over the network new line m g key like that uh make ritten real quick yes so we serving file my priv private data over the network and then it sets written 22 bytes over the network to that guy wait until the stream is done and then we have a decoding error yada yada yada so we copy this right that's good that this copy is working it's perfectly fine because that's reader we sering that over the network and of course we get this decoding error because right now the file is being uh decoded in the TCP Loop uh in in the transport in the TCP trans the file is being decoded here right here this thing we got it here right but that's not because we don't uh basically I'm happy with the result already but the the problem is that we um is's a multiwriter here right so we do a broadcast but then here we need to actually um open up a stream looking for my words so are we going to do this to open up a stream is basically we need to broadcast this to um read from every P that's what we need to do and we need to find a better way soon but hey going to be range as PE we need to do a copy we're going to say n r is going to be IO copy and we need to make a file buffer actually we need to make a file buffer for everyone because we actually don't know uh if you have a file maybe we should first ask there are a lot of mechanics we could do make this better guys we could first we instead of assuming they're going to serve it we could first ask if they have it and if they have it then we open up uh so we could say hey do you have this file he responds yes I have it okay I open up a stream or you could say uh what we're going to do right now is basically yo do you have this file I'm waiting for you actually not good so we we need to fix it we need to fix it uh but hey we built this up don't be too greedy in your over engineering because because that will basically kill your dopamine levels so we're going to Loop through the spe we're going to make a file buffer which is actually not true uh we going to make a file buffer which is going to be a new bytes buffer then we going to say uh who is the destination the file buffer is a destination and the p is going to be the reader and we going to say if there is an error of course we are going to return that error actually we should not do this because U but yeah we're going to actually we're going to fix this later on because if we return here an error uh this get is going to basically return and it could be that just this an invalid peer right it could be that the first p is going to turn n while the next p is going to serve or the file perfectly fine so we cannot do this but uh for now it will be fine and then we could say that we are receiving uh fmt print Ln uh received I think something is wrong with my um let me quickly check is it Windows Intel once again no it's us hey hey so I have basically I don't know why I have two keyboards one is us one one is international and I don't need International I don't know why Windows keep doing that should probably delet it uh but hey deleting in Windows is a pain in the ass not quite sure why that is um can we actually print out this buffer actually we could do buff string right is is going to work I assume not uh buff of course not how many BS do we have where is BFF okay let's uh one 109 let's let's let's open up this line real quick did we not save this what hell's going on just not saved it my bad all right so we're going to do those Shenanigans um what's going on uh so we waiting till the stream is done I think that may be a problem with till stream is done these vs in our in our Peach um we need to fix that soon so don't that file locally fetching it from the network then we wait till the stream is done not quite sure who that is serving file my private data over the network that's uh the remote we then going to write 22 bytes over the network which is fine uh but for some reason I think this uh I'm thinking for a good a good thing receiving stream from Pier and we could do this and then say b um remote data or something like that uh I think it's blocking there because we already read it from our other loop which is not closed wait until right receiving stream from a pach I think it's the same issue once again where we need to make sure that we time sleep here because um ah we need to fix that guys I'm going to lie we need to fix this stuff uh because otherwise otherwise we're going to read the whole shebang into the buffer into this in in this the code function you see so we have this uh 10,28 so basically because we broadcasting here and then we instantly uh trying to receive is it not quite sure I I think I'm wrong I think I'm wrong to be honest I think I'm wrong sometimes I can be wrong it's decoding out which come from an unexpected kind of file ah I see I see I see we need to be careful because um it's this copy thing uh the copy thing is a problem uh yes wait two problems two problems arise it's a copy thing is first because it's a connection which will not uh stop uh yeah yeah yeah yeah yeah yeah yeah uh don't file from the network that's fine receiving from the PE um wait tell the stream is done it's still not done he's sending 22 bytes right um so the problem is basically that we uh in our TCP transport that we read here first once again um so so it's going to be some juggling around with these weight groups and I think it's going to be a very good way a very good start to do this because uh we cannot leave it like this uh we can't we just can't it's bad it like I said it works it worked till it was good till now right some things you implement things to make things work but for for at a certain point of time things cannot work anymore you know what I mean and then you you fix them and that's how you come to a complete solution so the good thing is that we um have a way that that we actually can can can uh request files from the network we are copying them but we uh have a problem receiving them so we need to do some couple fixes and I think it's going to be an excellent episode to do these fixes in the next one so let's continue with our forever store and uh let me quickly do a make run to see where we start where we stopped so I think we um started with retrieving a file but the problem is if we don't have the file then we need to fetch it from uh all our other peers of at least from one Pier right the problem is we we we going to we're going to run into issues and um the reason is if you go to this transport right um this transport we we have this this p w ad and and and weij weight it basically means that um we hardcore this right because why do we need to wait is because we're going to receive a message like a plain message which we go up and code right and decode on the other side but the problem is that we need to find a way to close that we're doing that in in um in our server somewhere but the problem is the way we are doing it right now will is causing issues right so everything was fine until it lasted right until today so we need to do some some creation handing to to fix that right to support it in our in our lip so what we're going to do is we're going to support stream in our library super important right but the first thing I'm going to do is um I'm going to open up main real quick and uh instead of doing this uh get thingy which did not work yet right uh we're going to test it with data um with our with our store with this this this function basically works perfectly fine right if we delete uh these two bad guys here if we delete these permanently right uh and we then do a make run here and normally it should uh basically work like this and everything is fine right so we have this network here 3,000 with a file uh Big Data all good and then we have 4,000 with the file Big Data all good right so uh the best thing is that we test there a very common practice is that you always if you want to do a effector you test this with um things that already working instead of things that are broken right okay so how we going to do this very very important episode I'm not going to lie this is um how do you say that the cream on the on the pie or something I don't know yes the first thing we're going to do is we are going to open up and coding encoding here right because what we do right now is we read this uh 1,28 uh stuff and uh I already mentioned this in the previous episode that's causing issues so what we're going to do is I was thinking about this and uh I'm not going to lie I was thinking about this for a long time um but I figured I figured something something neat I figured something out which I'm going to teach you what we going to do actually G I think it's going it's it's it's implemented in a lot of other uh stuff also um what we're going to do is we are going to uh make a peak buff right a peak buff and that's going to be make me uh a slice of bites slice of bites and we're going to make a one bite so we're going to Peak the first bite right and we're going to say uh first of all we're going to do something like if R is going to be nothing because that is the bites written right this is R because we're going to read from the reader right I'm going to say R read me the end to the peak buff and if the error is not nil then we are going to what's going on here please V code yes then we're going to return the error like usual what did I do here if what's going on all right so if uh we're going to read the the shenanigans here and then we going to say that uh first of all what I'm going to do is going to open up message right and we're going to add some support for streaming in our RPC we're going to say stream which is a Boolean right because then we're going to know that we are streaming and if you are streaming we know exactly what we need to do we need to lock our stuff and then we need to have a way to unlock it when the streaming is done so we don't receive other messages in that read Loop right that's important and I'm going to I'm going to show it once again right this is the read Loop this thing is our read Loop which will basically each time there's a connection this read Loop will run in other go routine reading from that P reading from that connection but if we need to uh so each time there's a message being sent over the connection we're going to read it here decode it into an RPC pipe that uh into our Channel and we can read it in our server but if we are streaming we need to lck this read Loop because otherwise we're going to have problems right so we cannot open up two two streams of reading two two read Loops it's impossible so we're going to lock the main read Loop uh we're going to say hey log this because I'm receiving a stream so we can fetch the stream directly in our server that's what we going to do I think it's a very very very nice uh option we're going to add to our lip right so message here we're going to have a a config an option A support for streaming in our lab so we're going to say here that uh stream is going to be the peak buff the first bite right because we it's only one right uh and that's going to be equal to for example I'm going to say uh 0x2 right and actually what we could do is um maybe we could do in uh we going to do this in message we could say for example um how we going to how we going to call this this this variable that's a good thing uh if the pig buff is uh streaming type I don't know man uh maybe stream type or something it's going to be 0x2 actually what is it the type you could say const con stream type is going to be Z X2 and then um message type is going to be 0x one or something right and actually why I do that I can do this do this delete this and this something like that right so we go to uh peerto peer uh stream type what going on here Shenanigans we are in we are in we are in P yeah it's my it's my bad so if it's going to be um if the peak buffer is a stream type actually sorry guys I'm going to incoming message and I'm going to say incoming Stream So if the peak buffer is an incoming stream yes right now we're going to say if stream right so if if this if it's a stream then we're going to say that the RP the message which is our why do we call this actually message anyway doesn't matter we're going to say the message stream right is going to be true right otherwise it's going to be false and we're going to return here right we're going to return there is no need to decode right there's no need to call this right um could say in this case in case of a stream we are not decoding what is uh being sent uh over the network why am I actually searching for w like this is better we are just setting um Stream True so we can handle that in our logic or something I don't know uh it is what it is all right so we're going to say stream through and uh it's fine then then then then then we need to go to TCP transport right so for our TCP transport what we're going to say is um I'm going to decode this right and then we're going to say first thing we're going to do is if RPC stream right uh then we going to actually we can do this uh this RPC from can be can be on top that's all good the OU add if it's a stream we going to add uh the OU and we're also going to wait for the VG for the weight group right that make sense so if it's a if it's a stream we're going to wait so we're going to say um fmt print F and we could say uh this we could say the address of the thing um um how we going to call this incoming incoming stream waiting I don't know something like that and then we going to say here actually a new line maybe and then we're going to say here it's going to be um do we have the com com remote Adder so we know who is saying that now we're going to say here um resuming stream closed uh resuming Rel Loop like that that's cool and then we going to here we going to say continue right because there's no way because we're streaming which basically means we we fetched everything we need to have on the other side on our server or something or somewhere else so there's no need to to pipe an RPC into it with basically hold no bytes right so we're going to say Ouiji add we're going to say Ouiji weight right that's the first thing we're going to do all right so you can already imagine if we run this right now that that we're going to have uh big troubles right we're going to have inconsistent data because we are basically sending an U we we are peing the first bite and then the rest is basically completely broken right so what we're going to do is um in our server right in our server uh and I think it's broadcast we need to have broadcast it's actually I need to search for broadcast here yeah like this uh so here what we're doing here is basically we are sending a just a normal message right broadcast is just sending a plain message it's sending give me a file store a file with a file uh with a file name and all that stuff and a file size uh but it's not doing any streaming Shenanigans right it's not sending us that bytes over the network those file large file bytes so what we're going to say here is instead of we going to say p we're going to send um we are going to send the the the streaming incoming streaming type right this this bite we're going to say pent we're going to send a slice of bytes and uh it's going to be a peertopeer uh incoming message right you're going to say incoming message bite I don't know uh not not quite happy with the naming yet right so we're going to send an incoming message so we know that if we are here right if we are in um encoding here right so we Peak so we know that this is the first bite this is the first bite we are sending is going to be the peak buff which going to determine if it's an incoming stream or just a normal message right the next thing we need to do is find out where we are uh sending that stream over uh this is get receiving stream from P this is a receiver that doesn't matter uh handle message handle message get file store file you see here are we closing right here are we closing the the weight group is because the stream is done right so what we need to do is where are we sending this it's all right so we need to somewhere we need to copy copy copy copy here right so what we do here is we broadcast a message we're going to receive that somebody is willing to store a file so we have the file name and the file size we then prepare on the other side we prepare we open we open a file on disk which basically our storage right right stream and then after 3 seconds this guy is going to send the Stream So the first thing he needs to do is basically say peer sent right each spe we need to send uh a bite and that bite is going to be uh your body guessed it it's a peertopeer uh incoming stream just like that right and normally and I said only normally they should actually work perfectly fine not quite sure let's see what's goinging on yes yes I think it just worked perfectly fine incoming stream we wait in then we receive the stream we are written 22 bytes to dis and then we close the stream and we resume the read Loop right so to make this even more test we actually happy because it was um it's Advanced guys this is Advanced I if you know the stuff it's it's insane um let's open up main because I want to basically let's open up main here so I'm definitely not coding in this window uh I'm going to make this like a four because I want to make it a little bit more performant and I don't think that the sleep of these angles is needed uh let's do 10 times let's copy the whole she Bank inside of here let's paste it in here yeah uh so what we're going to do here is uh we're going to send it and then we're going to do a Time sleep because if we not sleep you cannot there's there's no use case it's going to send so fast this is going to send as fast as a CPU can which which no other note will ever do it's impossible there is some kind of a round trip in HTTP so we need to sleep otherwise it will it will us up uh it's going to be uh time sleep and we're going to say uh for example I think maybe five uh time I think millisecond is even is even enough five millisecond is is fine uh and then here we wait 5 milliseconds to send I don't think it it doesn't matter wait it's the same thing what the hell is going on where do we sleep oh yeah it's in server yeah yeah yeah I see I see I see uh here here here this 3 second we don't need this but I think we need to sleep a little bit uh and this is all normal behavior I think uh because millisecond uh millisecond I don't know uh five or something no clue we can test that out and make it even better like I said we're just going to make it work we're already downgrading from three from three seconds right uh make so let's see let's see hopefully we don't have any encoder decoder uh problems and and a not quite sure what's going on here uh I think just one more thing I want to do real quick is actually uh in server uh something we forgot is basically open up our quit Channel no it's not TCB transport by the way transport um like now we don't have a buffer Channel we have a unbuffered channel which is not good we're going to say a24 is going to be good um let me quickly see what's going on normally normally everything should be fine I guess but we're never sure yeah that's ourselves um is this actually doing what it needs to do I don't think so to be honest it isn't what is going on so we sleep five time millisecs I'm going to make it a little bit bigger here and a server also yeah uh I don't know maybe 500 which is actually let me see right let me see we're going to build things up right we're going to make things better for sure for sure sure all right this is this weight group negative weight cont yes yes yes I see uh the question is why is this happening um did we miss something did we miss something um this is our main this is fine so received and written bites to dis that's all fine I don't know maybe um let's make a thousand let's see what's going on here something something um is is still something is still not quite right um right so we we we sent this you say is it going to be a stream yeah that's fine then we do I think that's fine do we need to sleep his seconds I don't think is that a thing I don't think so so incoming stream waiting see so there something is is um it's not closing let me quickly uh do one real quick to see what's going on here uh because with one it's actually working or did we did we make a mistake uh in in between that could be this is fine so we add we wait and then we continue let's go back here that's fine did we miss something in encoding the stream we say it's the stream and um we return right so it's going to be we Peak it here yeah yeah yeah did we I'm thinking what's going on here real quick oh maybe we are actually this is get right we don't care about get we don't care about get where a store wait the bro is fine right so our broadcast um we don't care about the stream message broadcast is here right make a new bites buffer and then we first of all send this to our uh it's going to be an incoming message yeah yeah yeah so we can read that and then we send bites it's fine it's fine it's fine it's fine I don't know what's going on we sent the incoming stream this is good file we don't care about that it's a store file here so we check the pach and up uh at the end we unlock that wait first of all let us um do this real quick let's make some some nice stuff and you're going to say written percent D bites to dis which is fine and it's going to be uh there's no way to check actually uh what address we have let's open up transport uh TCP transport real quick uh let's open up transport itself uh what I want to do in this transport is basically expose an add uh in thingy which will return a string or it could actually even no I want to say add which is which is going to return a string and then in TCP transport um we going to say funk ttcp transport yeah adders and Adder is going to return what's going on here uh it's going to return a string and we are just going to return return the listen do we have a listen add what's going on here oh it's because maybe I it up here going to be a the listen add yeah yeah yeah okay cool that's fine we could say that Adder implements uh the transport interface returning the address the transport is accept connections right cool and then we can do actually here uh we could say S transport other and that's fine all right um if you make run should be all fine received and written bites to dis 22 uh and then we say we written 22 bytes to dis and then we close stream closed resuming read Loop that's what we want to see the problem is in main that we still if we do this uh for example for four times or even 10 it shouldn't matter that should also work and I don't know quite uh an idea what's going on you see it's an waiting but I think we are blocking here and I don't not not quite sure why that is right I think we're blocking heat so we cannot release heat are we sending it too fast I don't think it can right that's that's impossible right um I think we made a a mistake to be honest but where is it right where is it let's do it 5 Seconds that that that's actually enough right that's it's so much time for everything to to figure out what needs to do right we close the Stream incoming stream received wa you see that's a problem because we don't uh something is wrong we made a mistake we I think maybe I think I know what it is guys I think I know what it is I don't know I don't know is this is this it is this what happened nah 5 seconds it's too long yeah you see what's going on it's this right so yeah man this is you see this nasty even this can happen you see you you will you will encounter these stuff and that's why I'm why I'm why I'm doing this stuff real life without pre record with a screen next to me so I can see the solution so it all looks fluently and you think you learned something which actually will be but you can see that seeing myself making these mistakes will will you make more aware and even myself right so making this mistake the next time I'm going to do something like that I'm going to pay attention to these things right it's a stupid mistake but it's so important and I cannot emphasize this enough it's so important for you guys to understand some something is not quite right what is going on but you see that I looking I'm looking at certain places where this can happen and at a certain point of time you can see that I that I figured out that it should be something with this because de said okay we set the stream to true but we returning we continuing I was thinking at this continue but this will be true so it will keep thinking it's a stream which is not and then you know what I mean uh I hope it's this right you're not 100% sure we not 100% sure I think I think it is because uh so this time second guys this is actually this is way too much right such an application we cannot write so but we need to sleep uh so uh we need to sleep here uh for just a little bit of time because you cannot nobody can can process this at the speed of CPU right that is not U real life stuff so let's just do a five time millisecond that I think that should be good um what's this here millisecond right that's fine and then do we have a Time sleep here also uh it's 2 seconds that's already way way way way too much you're going to say um milliseconds uh I think five milliseconds is fine I think even one uh millisecond is good enough let's please let's um make run this and see if it finally can work um so we can continue Al yeah I think it did right you look at this uh it's nice right incoming stream right to bites stream closed incoming stream um the the the only way to test is basically to um open up these folders here uh actually I'm going to uh delete these guys delete permanently like this and then what I'm going to do here is instead of making this Kei uh we could do something like um something like an fmt I'm not seeing that I'm not going in my in my window here uh at the top um I think an S print right an S print F and we're going to say my private data uh underscore percentage D and then we're going to say why all right so it's going to have a different uh key so it's going to write all these file 10 10 times hopefully 10 folders uh make run let's see if something happens uh yeah yeah of course of course I was thinking why are there are two followers but it is is because the the root right so uh yeah you can see 1 two three four 5 6 S 8 nine 10 that's good and here also not quite sure if there's something in Big Data file that's fine yes yes I think it's working guys I think it's working here yes big data file and of course in our in our thingy e yay wo yes it's it sounds silly that I'm so happy but it's it was nasty books uh and I was thinking I I'm going to be honest I was trying this uh for a bit because it was a very nasty thing we need to solve with this with this prefixed bite what we needed to do and I was testing this and how can we do this because uh some I cannot figure these things out at at hook right uh although this is not scripted but I I still need to need to U prethink up front how a potential in my head it's not not not on not on uh on file not on my keyboard but in my head I was thinking how can I do this this this and it took me some time to to think about that and to figure out what we needed to do right that's something um that I do right is thinking up front uh before I actually make a video because otherwise uh it wouldn't be fun for you guys that I'm sitting here for 10 minutes just thinking in in silence right okay cool so I think uh what we going to do here uh let me quickly check uh so I think everything is set up fine uh what we could do is uh what we could do to make it a little bit better is and transport this spe let's let's let's call this a function uh and why why you see here um TCP right there is no uh TCP yes here right we see PP we C this to a TCP P to lock uh to close to set down so basically the the read Loop can continue so what we're going to do is basically say um we say close close streaming uh close stream yeah and that's not going to do anything but close stream will close the stream something we need and then in TCP P what we could do is basically uh make this EG public uh private my bad going to make this VG private so it's going to be VG like this and then we are going to make a function Funk uh it's going to be uh TCP P I think it's close stream yeah like this and then we're going to say here p w done we're going to call done on the w and then I think we have these uh capital vgs at the bottom we going to make them um RW RW why is this what's going on RW yeah I think that's fine and then instead of calling this spe here we could say peer uh close stream like this and hopefully that's uh going to be the same outcome and then we have a little a dynamic implementation without hardcoding Shenanigans yeah I think it's working perfectly fine yes I'm happy I'm happy because this is actually never did this before and for me this is also a nice project to do because like I said guys I'm not doing I never did this before well I experimented with these things but this is the first time I did this in in in a bigger scale all right uh this looking good man this is looking so good um yeah and I think for the next episode because we're already at 3 uh 33 minutes the next uh episode um we are going to handle our get because right now we have a nice and clean way to handle streams so now we can get the file uh if we have we're going to fetch it from our local disc and everything is fine if we don't find it up on our local disk we're going to get it from our other peers uh which is the power of our decentralization right and I think then what we need to do still is um our encryption and I think then we are coming close to the end in the previous episode we let me make run real quick we fixed our uh DCP transport to enable to support streams right for big files and as you can see um we are writing a lot of uh a lot of files to the network which we have uh node 3,000 and node 4,000 and they have all the files we need to distribute which is good but now um that's fine working fine the next thing we're going to do is basically open up a server and maybe on the other side we're going to open up uh I don't know maybe nothing actually this time this time nothing so we have let me put out this this cursor here um we need to fix our get right so let me search for that real quick get here right so basically um we can store that's fine but what we also need to do and we already did that but it was uh a little bit scuffed because we need to fix our our streaming uh option first our streaming support first right so what we're going to do is we're going to fetch a file wait let me open up main to show you better right so we have main here and what we're going to do is uh we're going to make one file we're going to store one file real quick um let's do this we're going to say um cool uh picture maybe cool picture. GP like this and we're going to store data right that's what we're going to do let me quickly delete these folders whe uh fast delete permanently he's gone get him out of here all right so let's do a make run so we just store one file uh like this of course stream close res zooming Rel loop I think we also need to fix one more thing uh because we're hanging and that's not good oh yeah let the select here I see I see I see that's uh no big of a deal so if we open up our folders right now we don't see anything is that okay uh I think it's a vs code book to be honest it's a vs code book because if I LS in the folder here uh we see the the the 3,000 and 4,000 Network so what I'm going to do is I'm going to remove uh the wait we are sending this from 4,000 right yeah so I'm going to remove the 4,000 Network like this not quite sure why vs is not showing this but anyway a little Buck why not so that's fine I'm going to comment this uh out and then we are going to comment this in back back in and we're going to say we don't want to get the private data uh we want to get the file and it's going to be cool picture cool picture uh. gpeg what's going on here geg right that's what we want to fetch so basically we're going to try to fetch this and um we're going to check first of all we're going to check our local disk right and if we have it on our local dis we're going to serve it from our local file from our local server from our local dis but if we don't find it then we're going to grab the network and try to fetch it from one of our peers that's the main goal right um so we're going to get here the first thing I'm going to do is make some uh because now we have support for uh our added right so it's very nice to prefix this with the added of the server so we're going to say uh S transport other and then this is going to be the key right like that let me close this because yes so we're going to get it uh what we could do is basically say here if we have the file I'm going to say let's delete all this junk um serving file from local disk yeah and it's going to be the file which is the key yeah fine fine fine and if we don't find a file then we're going to grab it from the network do that stuff that's all good we broadcast this so we're going to prefix that with a message uh bite that's good receiving stream from P I don't think we need this um maybe we going to do a little time sleep here not quite sure we need to check these sleeps um time millisecond maybe Millie second what's going on here I'm going to say 500 maybe something like that what am I doing what am I doing still sleepy time millisecond times 5 500 that's fine we're going to range to the Pierce uh then we're going to say here uh maybe a print F actually uh we're going to do this percentage s received uh this amount of bytes over the network which is going to be a percentage D in a format over the network and maybe we could do from it's going to be S transport addage uh it's going to be n and then this is going to be P remote adders right that's fine then we can we can print a buffer here but we don't need a buffer actually right we don't need a buffer because we need to store it to our disk but let's try it first like this and we don't need to forget that we need to send um a stream message to this Speer wait so we're going to say get this here um so we're going to receive it here right that B that basically means that we're going to say p uh close stream something like that let's see if this actually going to work yeah let's try this real quick no no no we need we need to send um is looping stuff handle message handle message get file we're going to do the same thing here need to serve file but does not exist on disk so we're going to say percentage s which is going to be S um transport Adder serving file over the network I do the same thing here as transport add yeah yeah yeah let's make it clean we're going to read from store we're going to check our peer and then we're going to copy here right so the first thing we're going to do is peer send we're going to send this um peertopeer uh incoming stream thing like that and then we're going to say here yeah we need to do a lot of uh Clean login stuff this amount of bytes over the network to this guy that's fine and we're going to say it's going to be again as transport others I'm going to return no right okay let's see let's see where we at uh let's see where we at I'm going to make run real quick and see what's going on all right so we don't have the file we serving the file we written uh over the network we have a stream we receive the bytes and then we say um and you can see that we that we fetched it right you see it here of course it's not going to be um in our yeah these these not quite sure what this is what's up with these folders by the way uh if you do an LS uh all we can see we don't have 4,000 because we don't store it yet uh onto our disc so we need to fix it some coffee never hurt gold of the world it is coffee okay so what we need to do I think actually it works pretty fine now that we have the streaming support it it it walks like a breeze um what we going to do is this one right so received what we're going to do is we're going to try to receive from every P that's not the best option because we need to check the first P sending or something I don't know but that's for later on it's F to receive it from HP doesn't matter uh and we can actually do use goroam for this also if you want so we don't need a file buffer and we don't need to copy what we're going to do with s is do something like if um n is going to be s store um right it's going to be the key I guess and we going to use the p yeah and if the error is not n we're going to return an error or what do we return here actually uh a file a reader actually we're going to say null F right uh we don't need the shenans so n is working that's fine we cannot do that we need to do this if R right like this then we have the F this file buffer we don't need this we're going to close the Stream and we're going to stop doing this and then what you could do is return we could actually pipe this into into a t or something so we can write to dis and then return it but the problem is that we are in this Loop so I think a good option is to just return once we're done with this reading is basically just return as store um I think read the key something like that so we can actually fetch that in our mean so we can fetch that he right and actually do we need to select we don't need to select let us see what's going on is let me see what's going on so we don't block here so why are we hanging we are we are hanging let me see but we have the file we have the file in the network which is good um I see I see what's going on uh of of course of course of course remember remember in um wait where is our limit reader you see remember this limit reader where we need to tell uh if we write into the store how much we're going to read from uh from this connection that's the exact same thing we need to do the problem actually is uh the problem that that we have is basically that we don't know the file size yet where are we copying here right so what we need to do uh if we write here we need to make this an IO uh limit reader like this and then we going to say let's say 22 bytes here right you know what I mean because we know it's 22 bytes but of course we cannot pref we can cannot hardcode that I know I know we're going to fix that we're going to say make uh run to see if now everything is working fine let me see it's working fine look at this but we have it we have it we're going to say Adam uh because we serving file from local disc yeah that's good andf we're going to say um actually can we do uh S2 can we remove something from this let's make that real quick to be honest s file server uh remove yeah this remove thing should also remove from the from the yeah that's yeah I see uh what we going to let's let's just do an uh an ad because we also need to remove from from from from all the peers then so that's uh it's going to take some longer than just a couple couple lines so we're going to say RM RF uh going to be 4,000 right because we're sending we don't need this fine let's make let's see received uh receive B of the network what I was testing actually totally forgot yeah yeah yeah you see that's a 20 that's why why I prefix it to 22 so we're going to fix that um there's basically I don't think a way to know the file size if you want to send that right so what we going to do is we're going to send the file size over right here so what we're going to do is we're going to send I'm going to say first sent um first send the uh incoming uh incoming stream bite to theat um first incoming stream to the to the p in uh and then uh we can send the file size yeah I'm we can s the file size and it's going to be uh as an N64 okay so we're going to send a stream and then we're going to say um what is the file size actually we read it here yeah let's let's hardcode it let's send it hardcode it over and then uh remove the hard code here right piece by piece piece by piece so we're going to say uh for example VAR file size uh which is going to be an N64 is going to be 22 right then we going to say uh binary actually yeah we going to say binary do write and we're going to write to the P we're going to say it's going to be a binary a little Indian and we're going to write this file size like that so we're going to write that as binary and then we're going to copy that right so now we need to fetch it on the other side let me find for 22 here uh so the first thing we're going to do is um need the file size so we can uh limit the amount of bytes that we read from the connection so it will not keep reading or hanging right that's what you're going to do so we're going to say v file size uh which is going to be an INT 64 like that I'm going to say binary can we read that yeah binary read did be a binary read we need to do a binary right did we did we do this correctly yeah B righted okay okay okay okay okay okay fine fine fine fine fine fine you did it like it okay here so we're going to say binary read we're going to read from the pis connection we're going to say it's going to be a binary uh little andian and we're going to take uh the file size like this and then we're going to say here uh file size right so we removed the the the hardcoded stuff here yeah okay let's delete this again um minus RF 4,000 not 3,000 because yes like this and make run and see all right all right right right right looks good looks good Okay cool so let's open up 22 here so the problem at this 22 is that we need to have the file size to send it over the problem is the only thing we get from read is basically a reader so you could say yeah why don't we read it into a buffer and um get the file size but I don't think it's a good idea because I need to read it into a buffer and and it's just nasty so I think I'm going to open up store here and I'm going to open up uh the read uh stream do we have that guest transform Funk read stream is this one where is R stream damn it just open right stream read stream um is this actually a good way because we this is actually I think we are reading this into memory to be honest instead of piping this directly to we need to fix that um I'm going to say uh instead we first copy this in to a buffer maybe just return the file from the r stream yes so we have this here right and then we have this this this read closer which is also a reader and then we copy it first so why don't we why don't we directly why don't we remove this right we could remove this I think that's an important aspect we're going to we're going to fix that we're going to fix that it's good that we have this uh this to do here um maybe fix me actually all right so what what what we going to do here is um we we have this n right we have this n so we can return the amount of bytes we we have but the problem is the problem is that we if we not going to use this later on then we don't have this n so we don't have we cannot return a file size so what we could do is in this read stream we do an OS open here on this full pad can we do an OS stat uh full Pat with a root and if yeah is not n we going to return n what's Fe do we have an S size or something we have that's amazing all right so what we're going to return here in a read stream we're going to change this a little bit up we're going to return uh a size which is going to be an N64 uh an iio read closer and an eror I'm going to do this and I'm going to say that the file uh erors going to be this can we do file size wait let me have let me do this um or does it return uh we're going to return here zero nil s it's actually a little bit nasty you're going to say Fe add is going to be stat you're going to stat a file uh not not quite sure why there is an error if if you already open up a file and then you st it by uh uh it's going to return an arrow to be honest so we're going to say return the same thing 0 nil Ed right uh and I'm we going to return uh Fe size file no that Mak sense of course our test are going to be broken I know I know I know of course this read is going to give us some issues because that's going to be n and we're going to return also an uh N64 here right uh we could do n here that's fine fine fine this is crazy uh let's let's fix this I don't like this we're going to say n uh n a store read right and then we have already an N uh let's make it size or file size maybe maybe that's even better file size we're going to delete this we're going to copy the file size here yes uh something is wrong in Ser of it not quite sure what it is let me do a make real quick uh 89 I need to sneeze I'm so sorry live on video live on video my bad I'm not going to cut it man I'm not going to cut it hey like I said this is the live off you know what I mean this is the real deal it's that's the real deal I love you guys all right so are we go I don't think we're going to return this uh what we're going to do we is basically uh do this read a and then we're going to return at uh read it at right something like that maybe maybe maybe we return the file size I don't know I don't know could be could be uh 122 the same thing right what is this get yeah yeah yeah I see I'm going to return store here um and store read is going to return us this thing a no uh reader a and we going to return add reader right something like that um so I think now everything should be not hardcoded from local disc I see I'm going to add them RF 4,000 yes make run see if we get it from uh the network yeah yeah yeah man this is insane this is insane so that's fine so what I want to do with this binary read stuff uh actually I was thinking maybe we should abstract that but to be honest I think it's pretty fine I mean a little bit of logic is is fine uh multi writer we need to fix that it's a TOD do or to fix me let us see in our test real quick um do we have a store test yeah yeah here right stream right s read is going to return us n what is Right stream do we need what's it going on with this I cannot initialize one variable with two oh yeah that's returning in um an add also yes test are working fine that's already taken care of all right the next thing I want to do is um is this I'm not happy with this read stream because we do this file yeah yeah that's fine but this is is bad this read uh you copy it here why do we do this actually why don't we just return right we could actually just return this because we don't close the file it doesn't matter right we could just do this right look we could actually just do this and actually get rid of one of these functions we could just return as readstream uh the key like this the question is are we going to this should be better actually that works perfectly fine now it's going to fetch from from local I hope you see what what the problem was right so let's let's revert this real quick you see so we get it from the so we we do R stream right so do we do our Shenanigans we get our file and then what we do is uh we basically say yo I copy everything into a buffer but can you imagine that's a 10 gab file then we fetch it from the store then we're going to read that into a buffer and then we're going to copy that buffer that's not good uh that's not what we want right so I think uh I know it's a little bit weird so we're going to just return the ream here right that's fine so we can remove this fix me already uh of course you see this function has no nothing in it it just returns this so we can maybe if you have a GH right we let's let's keep it for for now let's keep it like that the thing is what I want to do is uh I'm going to search for store read Because this is going to we return that so we return basically that stuff here so in main it's a read so we cannot close it that's why we did it right uh I see that's why we did that so we could close it first eat this one right this Edge so we should actually do like a defer uh a close but we can't what we could do is um can we do this I should be a pointer to a read closing Maybe can we do something like this maybe it that's nice uh yeah I'm going to explain actually I was thinking to to hard so basic what we do is we check if the the thing we fetched uh the the reader we check if it's a read closer if it's a read closer we going to say defer RC close we're going to close it and I want to let me quickly see if we can test that uh make run and we can and we can assert this I'm going to explain real quick closing reos it's fine that's cool so what you could do in go is basically you could assert if certain uh implementations are true right you could say um the read closer a Boolean equals the reader is that a read closer ER if it's read Clos it it's okay will be true if it's not then it will be false and then we don't care the thing is this RC I think I should do it like this if that something like that of course now we're going to fetch it from local so it doesn't actually matter I think yeah yeah it's fine it's fine it's fine all right so uh I think that's good very very very good I think it's actually perfectly working so what we also to do is delete thingy that's so we can remove files we need to do our encryption and maybe uh a separate thing where we do some cleanup and then uh I guess we have our we have our thing of of course you can like I said before you can make this as complex as you want right you can do so many cool features but I think that's a very very uh good practice for you guys on the other side of the camera and where you can have this working thing but you can extend it with with some with some cool functionality you should you think it should have right because like I said we can keep developing this for months and make it better and better and better and better but the question is where does it end right so we're going to do a couple things more so it's it's it's going to be good and robust and uh after that we can close that series and we can start another Series so the previous episodes we can store files we can retrieve the files we can retrieve them we can store them dist uh in in a decentralized distributed way we can retrieve them um from our peers if we don't have the file locally it's all good we have stream support now for our TCP uh Library uh peertopeer Library by the way and I think it's a good time to implement encryption right because um as you know if we going to if we going to store the file and we're going to store the file in on other peers in the network we don't want to store the plain bites we want to encrypt it with an encryption key that we and only we have so um if you want to retrieve the file we can decrypt it back and we can see the contents of it right so um of course you could say are we going to encrypt the files if we store it on or disk you could you could and maybe you should uh not quite sure if you're going to do that uh but we are going to make sure they are um encrypted uh that they are stored encrypted on our PS of course they want they don't want to see our nudes right so um so what we going to do is basically and I'm going to I'm going to look up some documentation for that uh while I code it because uh it's it's you don't do this any every day right so you cannot know this uh on the top of your head the first thing we going to do is actually let's delete these to bad boys and then we create a new file we're going to make this uh crypto go then what the hell is this what am I doing uh crypto go like this let's close it yes we're going to say package Main and then we going to call this as you can see in our storage right I think we also have something like iio copy uh like this right so we're going to make something like that a streaming a streaming way so uh the very important aspect is we are not going to encrypt them in into memory because like I mentioned before we are supporting streaming that basically means that we don't need to uh read every single bite that is being transferred into memory with only a portion and I think if you want to know how much that's going to be you can see copy here we do copy buffer uh and copy buffer basically here here here here so you see that the size is going to be 32 times uh 10 24 right that's basically the buffer that's the maximum amount we are going to read into memory and we're going to do something similar uh with our function and I think we're going to call this um copy encrypt encrypt like this we're going to take an key which is going to be our encryption key it's going to be a bite we're going to take in uh a source which is an IO reader and we also going to take in uh a destination which is going to be an IO writer like this and I think we're going to return the amount of bytes that being written and very important this normally you should say we're going to read and and then we're going to encrypt and write but we're not going to uh have the same bytes written as wrote it as wrote write and read I don't know what the the correct verbs are but we are going to write more buys and we read because we're going to preent or IV which is a a cipher thingy we need that for our encryption right uh so going to say it's going to be an INT and an error like this right okay cool so I'm going to I'm going to a little cheese a little bit uh I need to look things up so I have some documentation here and I will link the documentation in um in the description on of course right so the first thing we're going to do is I think we need a block uh R which is going to be AES we're going to you a we're going to use AES encryption and it's going to be AES rather you're going to say new Cipher is that yeah new Cipher and that's going to be uh we're going to give our key that will return as a block a cipher block first of all we're going to say if the error is not nil we're going to return actually could be ah let's let's return zero and an add here just like that now we have a block let me quickly see if I'm actually recording it's not the first time I'm doing uh these crazy shenanigans it's all fine then we have a block here and we're going to need that block because we're going to create an IV which is going to be and that's the thing we're going to store actually we're going to say make a slice of bite which going to be a block block size and I think this is going to be 16 bytes uh not sure 16 not quite sure if that's true we will see we will see so we have this IV the next thing we going to do is um fill it up with random bytes we're going to say if underscore R is going to to be IO read full right and we going to pass in a reader which going to be a random reader right like this and then we going to say IV uh and if the error is not nil then we're going to return zero because we didn't wrote anything uh and the error here that's fine let me scroll a little bit down to see what what the next thing we need to do uh right we need to make a buffet and a for Loop so we're going to for Loop here right but first of all we're going to make a buffer and a buffer is going to be uh make me a slice of bite and that's going to be 32 * 10 uh 24 which is basically this thing here right that's going to be the buff that's the maximum amount we're going to copy in memory and I think I think I think we also need a stream which is going to be a s is that um we're going to be a cipher actually new CTR okay not quite sure what it all is uh but we need a block and the IV here so we can we can have a stream and actually you could do a VAR to make it a little bit cleaner like this all right so now we can start reading from our uh from our source right we're going to say not got sure if you need the N first of all let's do n yeah we need to n we need to n for some checks actually the amount we read we need that we're going to say here it's going to be Source read we're going to read everything into the buffet right yeah if there is an error I don't think we're going to check the error yet we're going to say if m is bigger than zero that's important and then we're going to say stream uh exor stream that's what we want and we need the buffer and then we also going to say uh the buffer and the buff with the amount of bytes it's going to be yes this right the amount of bytes written uh R actually amount of B red and I'm going to say that the uh destination we're going to write the buff and yeah yes yes yes yes we're going to write everything this stream is going to write everything into this buffer let me quickly see what uh uh bite each bite yeah that's what he wants each bite yes yes yes it's going to each B each bite it's red I'm going to place it back um and and then and then we write uh the thing the encrypted stuff into our destination yes of course we're going to check this uh with an error and if the error is not n uh then we're going to basically return zero and the A and we going to do the amount of btes written later on to be honest what is this this is going to be perfectly fine and this error is here so you're going to say first if the error equals an IO end of file then we're going to break right we're going to break then we are we're done reading and then we're going to check the error so if the S um is not M then we going to return the Ed right yes okay and then here we're going to actually return we need to return some some value we're not going to do that uh quite yet we need to return the amounts we wrote and the thing is that um we also this IV is very important right this thing this IV needs to be in the file because we need that for decryption so what we're going to do we we we could do two things we can either store it and we can append it to the bites or we can prepend it and I think I'm going to prepend it so enable to preent we could say preent uh preent di IV to the file so we're going to say if underscore add is going to be the destination so we're going to write the IV just plain by so we can write it like this and if the eror is not n then basically we going to return zero and the F right and then we're going to start reading yes yes we're going to start writing to the file after the IV is uh inserted Okay cool so let us open up um actually let's make a test right that's going to be a good thing I'm going to say Crypt test. go package Main and we could say test wait Funk test uh encrypt test copy encrypt the uh testing do T what's going on here guys yes save it cool so what we could do is basically say uh we're going to have a a source right and that's going to be uh a b new reader uh new reader like this and we're going to say it's going to be bites and we are going to encrypt um f not bar something like that and actually yeah it's fine and I'm going to say out or a t actually a t and that's going to be a new bytes buffer like that and then we going to say um we could say NF is going to be a copy encrypt I'm going to say I think we need a key actually yeah we need a key that's a problem we don't have a key let's make one let's make a key we're going to say funk and new encryption key uh encryption key and it's going to return as a slice of bytes uh we're going to say how we going to do this I think we can say that the buffer is going to be key buff going to be make me a slice of bytes it's going to be 32 or something uh and then we going to say um I read for full rant reader into the keyb and then we can actually return the key buff bytes we don't need to we can actually just return it like that so then we have a key buff do we is this a capitalized no it isn't uh new encryption key like that then we're going to say the key is going to be here we're going to say the source is this and then the destination is that file and then we're going to check if F uh is not nil you're going to T error the error the F this this n is going to be zero anyway so we're going to skip that for now and what could do is basically fmt uh print Ln and we're going to say that the destination uh bytes we're going to print the bytes out and let's run this test real quick here all right so we have these encrypted Shenanigans which is cool uh one more thing I actually want to test is basically this one uh Funk Test new encryption key t testing l t and we going to say key is going to be new encryption key and we going to say uh for the length of the key first of all we could uh F key y equals can we do this is that a thing not quite sure if you could do that um zero bytes not quite sure oh we have it now the question is I think these keys are fine to be honest but I don't I I cannot check it with zero btes right because I could actually do fmt wait I could print out a key uh all the time of course there will be a zero bite right you see I think this key is fine to be honest um I don't think we need to test it it's fine because there will be zero bytes doesn't matter okay so test copy and crypt actually what we're going to do is copy uh test copy and crypt decrypt uh like this right so the next thing we going to do is copy decrypt that's the next uh function we're going to make we're going to say actually let make it at top that's be better for you guys to follow along we're going to say copy decrypt uh we need a key for sure it's going to be bite and then we going to say that the source is again it's going to be an IO reader and the destination is going to be an iio Rider and then U we going to return an INT of course again and an error and we need to fix these inss uh these bytes written and red soon all right not quite sure what we're going to do here do we need a block again let me quickly speak and Peak my um my thingy uh I think we need to block again right so we're going to copy this we make it the block with the key that's what we need now we need to R IV VI IV from the given uh IO reader uh which in our case uh should be all right so RV from the given I reader which in our case should be the block size bytes we read yeah uh how we going to do this so I think um so we're going to say something like this IV is going to be make me again a slice of bytes which is going to be a block uh block size like this right and I'm going to say if underscore R is going to be the source read me this IV um at not n then we going to return what's going on here uh zero R now we have an IV all right and I think we need to for loop again um now we need again this block right is this stream once again and it's buffer also so I'm going to copy this this I'm going to paste it in here buff stream that's all fine then we're going to do the same thing right we're going to say um n s is going to be Source read into the buff if there is an if n is bigger than zero we going to stream. sour stream I guess again the BFF and the buff um n and then we're going to write the encrypted things the the bites we encrypted back to D we're going to say d right if uh it's going to be NR d right the buffer but we write the buffer what we are what we have read actually encrypted and if the error is not nil then we're going to um caping caping locking we going to return zero R right and then the same thing if add equals IO end of file break if as the thing is could we actually not reuse this wait a minute no we can't right because we need to R the IV in this case some stuff we can actually uh split out because we're copying we copying too much uh uh stuff here but the problem is that a lot of things going to change because we're not going to we will see we will see uh not the end of the world not the end of the world right so what we're going to do here is basically we're going to say let me open up back my OBS so I can see what's going on here uh yeah yeah yeah we're good we're good we're good okay so what I'm going to do here is basically um so we have this this is destination we have our key we encrypted here then we can say out it's going to be make a new Buffet right and I'm we going to say that uh if underscore R is could be decrypt T no what am I saying with T it's going to be the key Source no it's going to be the destination right it's going to be the destination right this destination is going to be the encrypted file and the source is going to be well the new destination is going to be out if that makes sense Arrow out and then we're going to say out and let's make a string here so we maybe we can see what we because our our our encrypted stuff is basically F not bar right and maybe we should also print out the encrypted heat right and the encrypted heat in this case is going to be the destination uh destination string and then the actual string the decrypted string I hope it's going to we need to test actually can we do this let's just test here yes so you see it's working right so we we encrypt it and then we decrypt it and we have F not part which is good it's working and our tests are pausing actually uh what actually passing we need to say if um out string uh is not equal to actually it's going to be F not B right B payload now we can check it actually out string should be the payload T error F expected um encryption field I I don't care I'm going to say encryption field actually decryption field actually all right it's going to that should actually work all fine so we're going to do make test real quick boom everything is fine let me test this here boom uh pass yes yes yes good good good uh so we're going to delete these things uh wait like this yes okay encryption Done Right nice eses encryption uh copy streaming support and I was looking for some coffee but I don't think I have one maybe a little bit it is what it is a little bit caffeine okay so what there's a little problem right so I'm going to I'm going to tell you what's the problem going to be because if you go to server right and this copy um I think what we are doing wait I think also in the limit read there is going to be a problem yes so it's a message size right but the message the me the message is size like this right for we have this is basically 1 2 3 4 5 6 7 8 9 10 11 right uh it's going to be 11 bytes the problem is that the destination file the encrypted file is not going to be 11 bytes it's going to be 11 plus 16 bytes because um we put our IV right we we we we placed our IV into the file the first 16 bytes normally right so how we going to do this if you go to crypto real quick because if you check this n wait let me let me test something so we're going to do this copy and crypt you're going to say uh fmt you going to say print right and going to say print L Len uh payload right so if you send it's it's not it's not going to be boom it's going to be 11 right so it's 11 bytes that's fine but if we print the Len uh this Len out string wait that's basically the same thing wait I'm still stupid I'm stupid you're going to say print alen the destination right the destination is basically the destination of the encrypted stuff wait we cannot do it like here we need to do it here boom you see it's 27 right because that basically means if we do 11 minus 27 have 16 right so the IV is 16 and we can test this by doing um Len block block size right what cannot do l uh print without the fmt why not wait we don't make we need to we have this tested actually boom you see 16 right so that's fine so how we going to make sure we return uh how we return the same thing we're going to only check what we wrote so we're going to make an NW n written is basically zero right it's going to be uh it's going to be block block size all right and then each time we're going to write here it's going to be an NW h I don't like this to be honest because we have an N already we have an NW already so uh we going to say this is hard how are we going to call this this variable NN or something I don't know uh going to be NN and here we did our best because we wrote here right it's fine and and so we're going to save that n w plus s NN um what's going on block size in 64 uh and what is this ell is going on oh yeah see I'm I'm stupid um and we going to return and dou you right but that's only in in in uh copy decrypt right uh so we could say this and this is going to be 16 we going to quickly test right we're going to say 16 times basically it's going to be l uh out string we can actually say Outland right yeah but that basically means I'm going to say l payload to make it sure can I say t fail or something like this man I it I mean um all right so that's working fine right I know it's it's it's a bit nasty that we doing this thing because it's important that we return these bites because we're going to need them to send it over right we going to need time to send it over because if we using uh server right let me say it's store you want to say we store a file then we have a then we have basically here because this is locally right this is locally so this size is going to be in this case uh 11 right but then we're going to broadcast y y y and then we're going to say here uh there going to be a stream and we need to REM we need to can we just copy this this because we're sending that it's going to be size it's going to be encrypted so we need to say here plus 16 right what's going on here I'm losing my slipper I'm losing my slipper um so we're going to say plus 16 and I don't like the way this is happening because it's a hardcore thing so maybe we should and we don't can unless this size is going to be 11 right so uh 16 it's going to be fine I guess and this needs to be a copy encrypt right so we're going to re we going to first first of all first of all we're going to say our server file server file server options actually and we're going to say that the an key which is going to be a slice of bytes right uh yeah slice of btes like this and then we going to say yeah okay okay okay so we have an Angy and then where is store here what we're going to do then is basically we're going to not use this but we're going to say n r is going to be copy encrypt right and it's going to be the s n key it's going to be the destination The Source what's going to be the source the source is going to be where is that file buffer this is the file buffer here this is our T reader we use for teing here which will then write in file buffer so the source is in the source is the file Buffet yeah and then the p is going to be our destination yes yes yes it's a little bit different then copy works because copy takes in uh the destination as first as first argument in the function right so we can return F in this case and then we can say receive B is this going to work I have no clue let's see let's see uh make run I guess wait wait wait first of all first of all guys very important we need to have an N key in file server options we're going to say um the encryption key it's going to be new encryption key uh let me close up this thing and make run and see if we get encrypted files please let it all work just fine oh yeah yeah of course we are our main is basically we are fetching stuff but we we cannot fetch anything because we don't have anything right so we're going to just do this make a cool picture thingy sleep 5 Seconds no idea why we do that make run and see if he can store that file you see that we received and written by dis is zero Z okay and actually guys I found something like remember in previous episode we had this issue with these folders but you can just click refresh um so we were 4,000 right so do we have our file in plain text yes we have our file in plain text but do we have our file distributed encrypted yes it's encrypted hey that's good right um that's a very very very very goody okay um that's all good that's all good but we had one issue and I think it's basically because we let's open up Krypto I will open up here bytes written to disk because if we decrypt you're going to tell how much we decrypted wait why I'm I'm in the wrong crypto no I am in the right crypto it's fine it's in copy and cryp right that's what we use I think we can we can do the same thing we could say uh this is going to be block and I think we we can make this function even better what's going on oh we cannot do this block size what did we do here NW and then it's actually the same actually the same code we need to be we're going to split that out uh we're going to write to the to the Tangy we're going to say NW is going to be plus equals nn and in this case we're going to basically return uh and W right so basically um we're going to store it right now we should have the correct output that we received and written 38 to the dis that's actually not true because we're not encrypting it maybe we should encrypt it locally um because we're going to write you're going to if we copy and crypt right what do we mean by by this int that means that how many bites that we copied and encrypted right so in this case copy and encrypt it how many why is it we copy and encrypted that's basically H it's it's it's difficult because this block size we actually have the the IV in the file so but we copied only the file size yeah that's something we need to think about uh we're going to see that because in the next uh I'm going to cut the video out here me if I'm wrong but I think if I do a get lock the previous episodes we did encryption and decryption of our files and I think that we basically yes we could store things and um let us actually rerun this real quick um let's delete these two bad boys H and then we can just say a make a run and see what's going on normally I think it should be distributed and uh let me refresh these folders here we could we going to have 3,000 which is going to have nothing uh and this guy what is going on here we have a little issue is that what is going on here what a nice what a nice way to start isn't it a it um is that a thing what do we have here nothing all right no worries no no worries make run let's see what's going on no Panic we don't we don't choke uh stream closed resume resume that's a thing that's a thing so 3,000 doesn't have the files it it has it has what what's going on uh let us delete these two guys once again delete permanently maybe it was just I don't know so basically right now we don't have any file right no folders no not then that's fine uh let's make run and normally everything should be distributed right M run let's see let's see what's going on let's see what's popping all right received received this this is better right this looks better so we have this guy which is encrypted and then we have this guy which is Al which is not encryp because it's our local dis okay cool not quite sure what happened there I think um I don't know maybe we have no clue let's not worry about it right let's not worry about it okay so the next thing we need to do is basically find a way to retrieve these guys right um and if we open up server on this side and maybe main the other side then we're going to see that um I think it's handle get file is that a thing get get handle get file here this one uh we do a copy here but this is sending right so we are sending the file that's fine right if you get a f yeah yeah yeah I think yeah it's it's get right if we ask for a get here right and we cannot find this on local disk then we need to basically fetch everything from um store right that's a thing right so we going to fetch the files we're going to write but the problem is we're going to we're going to fetch these files in in an encrypted way so store right is not going to work here right so we need to open up store and we need to uh search for right this guy right and right is calling right stream uh but right stream basically just copies here right you see this this IO copy it basically just copies what it gets and that's not good because it's it's encrypted we need to decrypt this so we should replace this with decrypt uh copy decrypt uh the thing is maybe I want to do something like Funk um s let you see that I'm not coding in my uh window we're going to say right decrypt uh which will take an eny uh there going to be a slice of bytes it's going to take in a key which is a string and of course an IO reader uh which will return an N64 and an eror just like this and to be honest everything is the same right you could uh copy the whole ship bang it's only this uh of course we need to make this a little bit better because just copying this is uh maybe not the right idea and this is going to be I think copy decrypt uh but with uh ank key and we need to be careful let me open up crypto copy decrypt takes in a source and a dust the source is uh R and the d f is a little bit different than IO copy and of course I think this F this n is going to be an N than N64 uh which basically means we could do something like this in 64n and then of course the error if there is one so we could check that yeah I'm going to we're going to refactor this real soon but because there's a lot of duplication going on here you see it's the same thing here you could actually just delete this right and just return uh these things actually can we not just return the whole thing look at this it's basically the top part that needs to be refactored yeah okay so how we going to call this right is we have this right Crypt uh so what we could do is basically say something for let's let's let's just test this real quick and then we refected this right so let's do a right CP let's make it public right I'm going to make it public so instead of saying um what is this this crypto we don't need this instead of saying this store right we're going to say n r is going to be s store right decrypt right it's going to be the eny S eny and then we need um the key itself and I'm going to say an iio limit reader and it's spe and of course the file size like this I think you can delete this just the top part actually and now we have the same thing right I think that should be good is that true do we have all the files here yes we have this encrypted sting uh uh so what you could do is delete 4,000 right now we going to comment this out and then this let's see what's going on if we make run ah so it's it's it's yeah I see I see we get we get some stuff we get some stuff but we get encrypted stuff and I think the problem is the problem is actually the problem is this yeah it's this thing it's this new encryption key that's the problem because uh each time we boot up this make run we're going to make a new encryption uh key which basically means that if we have stored something with another encryption key it's not going to it's not going to work out fine for us because it's going to end it's going to decrypt it with a different key right uh so what we could do is basically we could say um let's store this right and once it's stored we're going to say if R is going to be S2 store delete um we're going to we're going to copy this everything inside of these brackets of course we need to we're going to say that that is the key we're going to delete it here we're going to say key here and then we got to say get the key not not get the key yeah we're going to get the key but we're also going to delete the key but only on the S2 um server and if the error uh is not n we can um what's going on here I'm going to lock fatal I guess like this right so we're going to we're going to store it we're going to delete it at on on our side and then we're going to fetch it again so it should be uh coming from um the network so let's delete these two guys now let us see what's going on it let's make and see what's going on I have no clue normally it should work I think it's working right if you get it yeah it works perfectly fine what's going on this is insane uh this is encrypted yes yes yes and this is uh my big data file so that's good it's all working perfectly fine the question rather is can we do all right that's good that's good um all right so there a couple things we need to do we also have something in server we need to fix I think we have a todo here yes use a multiwriter which is a little bit um better and then we have this thing right so we need to check uh what's going on we have righty Crypt and then we have a right stream um wait what is this uh we could say s store open file file writing yeah why not you're going to say key do we need the key yeah we need the key it's going to be a string do we need the iio readers I don't think so and it's going to return I think it's OS file as a pointer I guess and maybe an error and I think it could do this right we could uh yo actually delete this paste them here um which we actually then just could return this all right and then we could say f is going to be S open file for writeen uh we need the key right if Ed is not null you can return zero and the errors right and then we're going to return iio copy with this thing which is fine what is this uh we could say n all right and with right decrypt you could do the same thing right we have this copy decrypt this is the complete file we could delete all the sh bang here I could just say FF is going to be open file for writing is going to be the key that's fine uh return zero Ed and then we can do this thing is this going to work perfect I think I think it is this this basically uh eliminate some some some code duplication which is fine my big data file here this is going to be exactly what it is yeah yeah yeah okay cool that's fine taking care of that so right will go right stream um one more thing I want to actually change is basically this right we could do an eny in this we have right and then we have right decrypt I think it's fine write and right decrypt let me copy this real quick uh right stream I'm going to copy these guys and I'm going to paste them below this right because I think that makes a little bit more sense we can call right we can call right decrypt um and it's working perfectly fine so the next thing we going to do is fix this todo so basically what we could say is that the Pierce is going to be uh a slice of iio writer right and then we going to say 4ore p in range as Pierce and then we going to say that Pierce is going to be a pent uh Pierce Pier like this right and then we could do something like um I'm we going to say that the multiwriter is going to be an IO new is it multiwriter well mul writer I'm we going to say yo all the peers here like that and then we're going to copy this um but we're going to say it's multiwriter and we're going to write this bite right this incoming stream so we can notify every single writer that we are basically um sending a stream by notifying them and then we could do this right we're going to copy this copy encrypt we're going to yada yada file buffer and instead of this pier we're going to say all the peers right uh so we're going to delete this and then we're going to print out that we receive to dis maybe we going to do a print F do a percentage s here and then say uh maybe a new line here received and written you could do this percent D bites to disk and then we're going to say um S transport other like this multireader it's fine millisecond also good let's see if this is going to work uh make run works perfectly fine also fixed uh the next thing I want to do is basically instead of doing um let us let us test how far we can get this thing let's let's do uh maybe 20 or something uh let's paste that in here the key is not going to be this cool picture we're going to say that the key is going to be an fmts uh print F and it's going to be let's do picture underscore percentage d which is going to be the Y do we want jpeg BNG it doesn't matter uh 20 times um all right I think that's good so we're writing 20 times over the okay okay uh now I want to see what's going on here in our folders uh a I see some issues what's going on here this is UN kept it that's fine wait do we need to ah ah that was a l refreshing look at this we have all these files here because we are creating 20 30 files um yeah let me see what what's in here all right so we this file cannot be displayed uh yeah it's fine we cannot see what's in there that's crazy yeah I see some encrypted files right yeah cannot open it Y is because uh maybe if there's some character in it a special character that vs code cannot grasp and then of course and these things should be should all be the same thing my big data file right and all these things right yeah it works it seems that it works for me um that sounds pretty good uh let me quickly see all right so can we do some optimizations right that's the thing not make run I want to go to server right something I really want to test um actually what I want to test is if we go to main. goo right why don't we add another server right we could say another server is going to be S3 it's going to be make me a server and that's going to be a port 5,000 and we're going to connect with 3,000 uh of course the what want to say is that we need to have there's not really a way to uh automatically connect to all the peers I know I know normally you should have some peertopeer um protocol where you ask for the other peers so you could um do peer Discovery and once you get one peer it sends its peer list and everybody is connected right just like I doing in the poker game um on stream right that that thing poker game has that um that's something we also could do the question is do we need to do maybe we should maybe we don't could be a good exercise for you guys to implement this um because if we really want to make this distributed we need to do some some extra stuff right and then we need to broadcast uh we're going to broadcast is that's true um so we have S3 right so what are we doing here we start as one let's start S two let's start S3 S3 is connected with everyone right let's just test that uh first of all what I want to do is um let's get rid of these folders real quick let's delete them I'm not quite sure what's going to happen here so we have all these folders uh be bu up as three at Port 5,000 we connect with three and four so this can be interesting this can be interesting I'm going to run it and see what's going on just YOLO of course it's going it's yeah I see that's because uh that's because we need to wait here a little bit maybe one second I have no clue if that's going to work question refused who is this guy dialing 4,000 who's dialing 4 oh it's this guy uh what's going on what's going on what's going on wait do I have a yeah I see I'm doing this this should be as three S3 S3 that's going to work stuff is happening so that's good I'm curious what's going to happen actually uh let us refresh this boom we have three folders and we have three folders We have this 3,000 we have 4,000 has nothing in it because he has some issues and 5,000 is is doing its thing 5,000 should have the files and 3,000 should have the encrypted stuff which is very good the problem is this 4,000 guy what's going on why cannot why why does he why cannot can he not play with us so we make a server right what's going on with make server actually let see next server transport options y y and then we're going to dial probably but we're going to dial we wait a second then this guy and then three is starting here uh is this is this not enough I should be enough I should be enough why can I not connect collection refused who's dialing actually why is it refused why is it refused what's going on my neck hurts I don't know what's going on um they are dialing it's the transport where do we do this the stream thing can can can actually be remove we don't need this anymore good that we see this so we have a new file server we have broadcast get I think it's somewhere at the bottom onp Loop handle message boot up Network so we're going to boot up all the networks what we could do here is actually uh do a print F and make this a little bit better we're going to say percentage s uh so we know who's who's who's doing who's doing stuff uh attempting to connect with remote uh it's going to be percentage s and of course we're going to do a new line and it's going to be S transport other and it's going to be the edit just like that let me quickly see who's calling who uh wait wait wait wait it's the only stuff I know yeah so 5,000 is attempting to connect with 4,000 and attempting to connect with 3,000 that's fine it's it's um it it feels like um 4,000 is not starting on a port we have this uh listen to 3,000 listen to 5,000 why is 4,000 not booting so for some reason 4,000 is not booting up although we do it why we say as to start we don't care about this right we care because S2 is going to connect uh it's going to connect with one so we need to sleep a little bit uh yeah times uh I think millisec millisecond is fine to be honest unique millisecond yeah no what am I doing actually what the hell is going on uh 500 or something s to start we do listen and accept and boot out the N the network right I don't understand why it's not booting up you see the TCP transport listening on Port it's not working what am I missing let's do 8,000 or something I don't know no not 8,000 8,000 is a is a is a nasty Port um seven it's not call it it's so weird what's going on TCP transport listening TCP transport listening but 7 of course we cannot connect with remote 7,000 because it doesn't boot up okay this is crazy let me open up server fmt uh I'm going to say print F right we're going to say this guy percentage s starting file server on Port actually we don't care because that's support right starting file server maybe a new line S transport other let's make run and see what's going on starting file server listening starting file server listening what do I miss something do I miss something yeah of course I see I don't want to let us quickly do uh let's return here right let's do a return here so we don't interfere maybe it's just coming too late to the party I don't know I I can't really see it maybe you guys already saw it let let let me also select here uh select this is a nasty one not going to lie you see it doesn't want to start what's going on am I missing something S2 S3 S1 S2 ah of course of course we blocking oh no oh no a I'm Legit Garbage Guys Ah that's the cool stuff that I'm uh of live recording like you can see how many stupid mistakes do you guys already see me man I'm actually I'm a fraud what the going on oh so it's so stupid it's so stupid it's funny the problem is we do like this this this is what we had right the problem is this S1 start is basically blocking right this is blocking um is this blocking right so I still cannot start because this is guy is blocking so what you could do is basically do something like this right um can I do go lock fatal then we going to sleep and then we going to say uh go this one I'm not sure if it's going to work probably it is and then we going to go start the third one and if you make run this and you're going to see that they all booting up um what's going on can thing is can we do this that's the question do I not need to do let's do this and do S2 not quite sure okay cool that's that's what we want to see now we have five right so everybody's connected that's cool yeah yeah yeah okay cool that's what we need uh we finally have so now we have a 7,000 actually what we going to do is um delete all the folders here right how do I do this select this one this one and then delete permanently boom let's get him out of here all right let's do a make run let's going to see what's going on so everybody's connecting 3,000 7,000 4 5,000 yes let's go uh then they serving yes the serving Shenanigans pictures the whole shebang uh let us see let's see what's going on because we're not sure so we have 3,000 not quite sure where's this guy encrypted stuff five not quite sure if 5,000 has something uh to be honest yeah he has file seven I don't I the stuff we did it we did it of course of course of course I understand if you're really really going to dig deeper um there is no peer uh peer automatic peer Discovery hey I know there's no automatic PE Discovery um but but but he it doesn't need to be it does it does it does need but for the sake of this tutorial to discourse this series uh I don't think it needs to be because we can take this so far and then within four months we are still developing this stuff right so I'm happy it's working perfectly fine it's distributed we can get files um it's encrypted because we are S2 on our disk it's not encrypted and all the other uh notes and Network have this distributed encrypted so it's all good it's all fine uh I'm very happy we are reaching the end ladies and gentlemen it is what it is sometimes um we cannot keep going forever but uh a couple things we want to do I want to put the dots on the why you know what I mean so um yes yes yes yes yes let us see let us see let us see Okay cool so first things first let's go to uh crypto right this uh what is this new encryption key copy decrypt and all that good stuff right so what what we see here is basically um we have this for Loop right it's basically a copy Loop and this copy Loop is basically exactly the same as this uh copy Loop right so we should refactor that a little bit because uh duplicated code is not sometimes it can be good but sometimes it's bad news so what we could do is basically make a function why I have two copies here uh let open up server it's fine so what you could do here is basically say um I don't know maybe copy stream or something copy stream and then we're going to have um we're going to have a good question I think we have a stream which is going to be is it a cipher Cipher stream yes it's a cipher. stream I don't think it's a pointer we need a a source file which would be an IO reader and we also need a destination which going to be an IO writer we're going to return Le an INT and an error and I think we also need a block size uh we're going to say block size which is going to be an integer I guess something like this right and what we can then do is basically copy uh this uh bad boy right here and paste it in and we going to read the buffer oh wait we need to copy the buffer also I think uh this block size actually I'm going to copy this whole thingy and paste it in here the stream we don't need and this can be the block size and then we can actually return what's going on we can return this NW which is uh n wrote and write it and probably nil here right and then we have this nice copy stream yes yes yes and then we could do something like let's comment this out before we going to delete this I think we can actually return that stuff you can say copy stream which is going to have a stream name a block size a source and a destination and this buffer can be deleted we don't need this actually we could do just that return delete this yes and we could actually do the same thing we can um copy this we can do the same thing with encrypt return this delete the whole She Bang here something like that or something like this I think that should be fine is this going to work uh let us test real quick make run and see what's going on and in the meanwhile I'm going to sip my coffee all looks fine based on the the the log the loggings in the terminal I think it's fine so we want to delete this boom boom all right so that's being fixed now we have this nice copy stream which basically um prevents us from duplicating this copy code which if we need to adjust something uh we only need to adjust it at one place all right the next thing I want to basically tackle is um if we store a file right if we store a file uh we need to provide a key and if we store this on our own um storage local storage local server local machine it's fine that we say hey store for example um mind n. gpeg but if we basically going to distribute that we already encrypt a file which is which is fine nobody needs to see NES right but the problem is it still can see we still put the the key the name of the file the key in plain text so they can see what it is and that's also not uh a good uh practice right so we're going to fix that and how we going to fix that is I think we could do maybe we can do it in crypto by the way in this file new encryption key we could say funk for example uh um hash key key string returns a string for example and we could do we could do any hashing function we want we could even make this an interface we could say for example the hash is going to be maybe an md5 sum of the key it needs to be bytes right so let's make it a bite slice what's going on here my cap lock is turned on and then we can actually return a hex uh and go to string of the hash and do it like this so we have a nice slice there's basically a simple function which will hash the key in an md5 which a oneway a oneway hash function right so there is no way they can um you can even make it a sha 256 whatever uh but there's no way that they can see what's inside of um of that hash only we know that so we could do uh if we going to store right and we going to say if you want to distribute this message right this thing here we could say uh instead of the key we could say hash key uh put in the key and if you want to retrieve that all right if you come from local storage can be the key the plain text but if we uh want to fet this then we need to basically hash it again so we're going to say hash key like this make a run and that should actually be the same thing although it's going to have another pattern but that doesn't matter because it's is going to fetch it anyway right yes yes yes uh Clos and all that stuff Big Data file is coming out everything is working as intended so that's fine um all right the next thing what we need to do is we have we have actually a problem and I was not quite sure if we should should support it but I think it's a good way um I'm going to show you how to do is basically um for example what we doing now is if we don't have the file locally right we just going to send a message yo give me this file name the problem is that what happens if we don't know that file name right because some maybe our house is exploded or something I don't know and we actually don't know what files we had in our storage then how are we going to sync right because if we don't know the key we cannot fetch it we cannot ask for the key so how we can solve that is by um and I said like I mentioned before you can make this as complex as you want you could even do it with the public key private key and then sign your your your things and sign your messages and then we could validate and all that stuff so only you can store to your um ID which is what we're going to create so uh enable to fix this is um what we do now let me open up store actually I'm going to open up the other side by the way uh if you have store here for example let's go at the top what we do now is basically we create uh a pad right we create a pad and that pad is basically based on a transform um on a transform Funk based on the key we give it right and the key is for example it could be a file name and the file name could be um clown. gpeg right we're going to tr transform this file name right and that's going to return as a key um which is going to be a pad actually it's going to be a pad right and then we have a root we have the root of the of the folder right and we're going to have a pad right so what we're going to do is basically is we could do we can store it in a root because that's where we're going to store everything right files from from from everybody that that want to distribute his files and or files but we could actually do something in between and it's going to be a root and then an ID right and it could be a PB key uh if you want that could be uh some kind of a random ID or a random string uh if you know what I mean so basically if we then need to sync the only thing we could do is ask for a sync and give it um this random string right which basically is a random identifier of our storage of or server whatever note whatever you want to call it and then we can actually fetch all the files inside of it and send it over right so how can we Implement something like that um without doing too much refactor and it's basically something like um that's actually a good question we could do um if you go to crypto right we could do something like uh not quite sure if crypto is a good thing to do a good place to do it you could do it in a util function or something but hey um but you could to be honest it would be nice to have a public key uh enabl to to that to do some stuff with it but I'm going to use a simple ID right you're going to say generate ID which will return a string uh like this we could say for example uh it's just for to give you guys some ideas right because for you it would be nice to um extend this um forever store extend this distributed file storage with some of your own functionality to um to learn navigate through the codebase and to implement your own IDs right that's that's the best thing you could do but you could you could watch this series forever it's very important it's a very big mistake I also made in my uh career is what a lot of people or mistakes a lot of people making and it's not only with coding it's with everything they watch a lot of videos which is good which is very good right but they keep watching they keep watching but they don't do it's good that you watch but it's also very important that you do stuff and figure things out it's it's also very important so we're going to say uh let's say we're going to make a buffer which is going to be make me a slice let's call it buffer make me um a slice of bite let's make it 32 right and then we're going to say IO read all or read full I think it's read all is that I think it's read full and then we going to say IO um it's not it's not that it's going to be a Rand reader right I'm going to read above right and I'm going to say return hex and go to Str one of my favorite functions by the way X and go to string we're going to and goe this the buffer right that thing and now we have a nice uh ID right and you can already see it coming with this 32 you could you could use a PB key and then you could actually uh enhance this file server so every uh message we sent is going to be signed with the PB key and then uh you could store everything at the PB key location and you could check if the message is coming um is exactly from from the guy that wants to store and retrieve stuff to make it even more uh cryptographical secure right um generate idea Okay cool so what we could do is basically in server no in main or in server actually or maybe in rops store that's what we need and did I code into let me open up crypto did I code into my screen no I need to make sure that's not happening so let's open up store here yes what we're going to do is we have this um store UPS Store up so we have this root let's give it an identifier which is going to be a string right um ID of the owner uh of the storage storage uh which will be used to store all files at that location so we can sync all the files if needed something like that right what's going on everybody sending me messages um yes yes yes yes yes we have this ID if you're going to make a new store are we going to make an ID we could do that right you could say if L Ops ID is zero then we're going to make one right if somebody forgot I'm going to say op uh ID is going to be generate an ID just like that I cannot do this is fine so now we have an ID and then we could say in storage is basically if we open file for writing is that what we need yes so you can see we do a root which is this one and then we do the pad key right and we could do something in between and that's going to be the ID something like that uh what is this s root pad key I think we need to provide here the ID also just like that and now we need to do the same thing with the read stream right so the read stream is getting the root and we also need the ID like that as root then we going to say S ID like this hands are cold tell me something new hey all right so I think um if you open up store test actually not quite sure if this already going to expect to have keu we have some issues in our tests actually expected to have key this one expected to have key y y y uh but got I we don't have it ah I think it's has that's a problem um the problem we have with has we need to yes yes that's what I was thinking so of course we have the root and we also need to provide the ID here um as ID and maybe that's going to work a little bit better make test actually all right expect it to not have key uh I think a problem is that it's not deleted yet right uh let me delete these files real quick man this Windows this Windows signing B is crazy blowing up my ears uh I think we don't delete this where is delete right ex ex exactly right so we have again uh we need to refactor this that we have the ID of the storage like that right make Test please boom yes yes yes yes that's fine so let's us hope that make run is going to work perfectly fine and I think it is good good time to set the coffee uh yes all right all right right let's see let's see let's see yes we have these nice falters uh of course you can see that I think we do it with um 5ou I don't know I don't know who the guy is but you can see that these folders right um these pads are basically not the same as this 5,000 pads um you can see but these are the same right so this one these pads right these folder pads are the same as the 7,000 one but they not the same as the 50001 right and that's because the 50001 is the guy that is uh storing stuff and and and make it distributed so the two other servers uh in the network they will have the encrypt the hashed version of the key which will translate into a different pad right uh so they don't know the contents of the file because it's encrypted but all they don't also do not know the contents of the key which is amazing super secure well super private um like this uh and I think it should work right so if we man yeah encrypted stuff that's fine and then 5,000 should have the that my big data file is see these things come together is so nice um yeah and you can see what happens right so you you can see that this is the ID right this is the uh e77 A6 right uh this is a problem we we made a big mistake by the way we made a big mistake because they're storing these files inside of um it's good that we have an ID that's a that's a fact but um I was just thinking about I made a mistake guys you can see uh I also make mistakes um but we identified it which is good so basically the problem is that if we retrieve a file it's going to retrieve from the ID from the storage uh so it works all fine but it's it it's not working like intended um so what happens if somebody is storing it needs to store at a certain ID so instead of um anony anony anony so instead of storing at our own ID uh let open up server it's fine server is on the other side yeah so I think to be honest let's refactor this sometimes it's funny uh but I wait where is this this this thing this ID thing let me find this uh ID soorry yes I think we need to move the ID to the server yeah we're going to delete the ID guys we're going to delete the ID guys and girls and if I say guys it means guys and girls you know what I mean it means everybody I know uh we're going to delete this right okay damn damn damn damn no we going to I'm going to we're going to do it like um it's a mistake and we're going to we're going to we're going to take the pain we're going to take our mistake and we're going to refactor it that's sometimes what it is uh we can go the easy route and rerecord the video but I'm I'm not that guy and you guys know that um that's engineering and I want to see engineering at its finest and um if you make a mistake you need to take it as a man you know what I mean and that's what we're going to do I'm going to take it as a man so we're going to delete this and I hope you understand what what's the problem right so because we storing it at our own ID which basically has the same problem we already had before I think we need to um refactor the code a little bit if if we write and read we need to specify the ID of uh the location where it's get um the ID of the other note it could be our ID but could also be an other ID it's very important and that's the only way we can sync uh if we don't know we can basically sync the whole folder to a server right if you really want to implement that later on if you know what I mean okay so I think we are back these folders are pretty are are back at the state they need to be which is good um luckily we didn't refector that too much yeah I think it's fine to be honest I think we can we can make test and it's going to be all good yes all right right right right it it's nice it was good it was good it could be it could be much worse so how we going to fix this um we are going to say we're going to server here and we're going to say server Ops I'm going to give it an ID it's going to be a string uh we could do we need to it is fine it is fine uh what we could do is basically we could do like this right so if Ops uh ID wait we could say Len that's how I check if variables uh strings are empty could do it whatever you want we're going to say if L op ID is empty we're going to say Ops um ID is going to be generate ID so that's going to be always fine so we don't need to specify it it will generate an ID for us if you don't specify it and if you specify it it will use that ID yes so what we're going to do man we could say get the the key as a stream you could also say from from which ID we want to read right wait I'm thinking wait wait wait this is already in server um we don't need it here no no no because we could send yeah yeah wait wait let me open up store first store is the most important thing right now um right so we could do something like this um I'm thinking is this going to work with with with read and write let's open keyf write then okay so it's going to be it's going to be some nasty and maybe we should uh introduce uh um another episode for this or I could actually do it in one we could actually complete it here maybe so we're going to say um we need to prefix this with an ID it's very important we're going to say string and then we going to say percentage s going to be the ID right open file for wren ID um yeah the same thing here ID is going to be a string uh it's going to be the ID that's fine reading is going to be the same thing right we're going to say ID string ID here it's going to be a problem in uh read in read stream right I'm going to say ID string uh this going to be a percentage s it's going to be the ID right just like that all fine um write decrypt ID string ID key fine write we need an ID an ID string which is going to be ID uh no it's going to be ID key delete the same thing percentage s is going to be an ID yes and has is the same thing it's going to be an uh ID string you could you could see an ID as an extra key right um as an extra key where it's stored so we can actually do do some advanced stuff with it uh the question is what's going on here did we actually have have everything 10 ID key yeah yeah yeah file yeah right the Crypt ID yes write yes delete yes has also I think we're good of course now we have trouble uh in our storage here uh so we're going to say new store and maybe we need to make an ID and put this ID here and ID here it's a little bit of uh tedious uh operations I I know I'm going to make test okay server is complaining I know I know I know I know right if you want to get a file you're going to say it's going to be as ID right and then the key so then we don't have it locally right then we need to actually uh upgrade this uh payload message we need to we need to specify an ID which is going to be as ID we need to send our ID over right that's very important uh where is this message I have no clue let me quickly GD into this message right you're going to say the ID it's going to be a string actually this guy this guy it's going to be string size fine but we also need an ID actually we can do it at top uh and and that's going to be a string but i' also think we need this in get file all right that's fine so we specify an ID here let's put it at top it doesn't really matter it's just an OCD um and then we're going to read our key based on our ID like this and then if we store we need to specify an ID actually is it yes it's or ID the key then we're going to send that we need that this guy needs to store this uh at R ID all right handle message get read if store has uh it's going to be from this guy message ID we're going to read this guy wait I get wait so first of all need to Surf um wait because this is handle get file we first going to check if we have it I think it's going to be the message um ID not quite sure and then we have this one handle store file from this beer so I think we need to store this on the message uh ID right let me see if make test is working we still have not enough in Main and in servers 112 yeah righty cryp the I see yeah so we broadcast our ID this is going to be as ID this going to be R ID uh which is basically after this encrypt if this is going to work from the first time I'm going to be uh it's going to be this one and I think we still have some issues in our test here here here in right stream make test real quick um it's a problem in main that's fine so we want to delete um S3 it's going to be S3 ID right so that's going to be fine let's make test yes okay test is working uh okay I'm not quite sure if if if our thing our Serv is going to work um could be that you made a little mistake but hey okay it seems good it seems good seems good so how can we make sure that that is going to I'm going to refresh these folders because let me close all these guys here what's going on right let's refresh okay so we have these three uh three people in the network and I think it's 5,000 is going to be the guy we need yes 5,000 is the guy we need so he has uh two thingies I think some relics from from the past right um wait let me let me delete these folders and run again because it's going to be confusing as hell it's going delete the whole sh bang and then we're going to run again and then we're going to see if these um ID folders are are correct make uh a run and if so we are in a good spot right yada yada yada yes okay cool uh let's see what's going on so we have yeah I think this is fine right because we have this ID from 5,000 and they all have this ID and they store everything uh or files at this ID right at this uh thing which is perfectly fine which is was it intended so now our server works like a complete works like a dist like a distributed file server and if we um for example if 5000 doesn't have this folder anymore uh he he can either sync the whole folder right he can sync the whole folder or he or he can um ask for a specific file if he wants and people will exactly know where to find it because it's his ID um it's in his ID subfolder if that makes sense right so uh I think this was it for the um for the distributed decentralized file server file storage and um something I want to give uh I want to give an assessment for the people that are watching these series something that you can do it it's not mandatory of course it's what what you want um and what I'm going to what I'm going to give you is if you can see we have get right and we also have um store right we have these two uh apis we can use for our storage but what we don't have is delete right we have delete in our store but we don't have delete in our server so the the assessment I want to give you guys is Implement delete right that basically means it needs to delete the file on or on our local machine but it also needs to delete it needs to send a message to all of our peers we're connected to so it can also delete a certain file on their machine right that's the assessment I'm going to give you not too hard not too simple uh I think it's a very nice assessment and I'm going to uh when it's done you can DM me on patreon or whatever you know where to find me and uh I'm going to review that and give you some feedback on your implementation right that's what I'm going to do cool um yeah cool thanks for being a part thanks for um being in the community or whatsoever for the support and I see you on Discord on a video or on live stream thanks for watching byebye
