With timestamps:

00:00 - learn all about react native in this
00:02 - complete beginner's course from Emma
00:04 - Williams she is a software engineer who
00:06 - specializes in react native Emma will
00:09 - teach you everything you need to know to
00:11 - start developing cross-platform native
00:13 - mobile apps using JavaScript app
00:17 - downloads continue to increase year on
00:19 - year creating some big Revenue
00:22 - learning how to create mobile apps is
00:24 - also a lot of fun
00:26 - in this course I'll be introducing you
00:29 - to react native and together we'll build
00:31 - a weather application you're welcome to
00:33 - just watch the video or follow along
00:36 - the only prerequisite for the course is
00:39 - that you have a text editor set up I'll
00:41 - be using atom but you're welcome to use
00:43 - whichever one you prefer before we go
00:45 - any further if you're planning to follow
00:47 - along with this tutorial I'm going to
00:49 - start by showing you how to register for
00:50 - an API key which will be needed for the
00:53 - application it can take some time for
00:55 - the API key to activate which is why I'm
00:57 - suggesting starting by registering the
00:59 - key now
01:01 - the API key we'll use for the
01:03 - application is called the open Weather
01:04 - API and can be found here
01:10 - so you'll need to start by registering
01:12 - and then creating an API key
01:15 - we will be using the five-day forecast
01:16 - which is free and can be found here
01:21 - we'll return back to this later in the
01:23 - tutorial so what is react native
01:26 - well react native is a framework which
01:28 - was created by Facebook and was
01:30 - initially released in 2015.
01:33 - react native lets you create mobile apps
01:36 - for IOS and Android by using JavaScript
01:40 - in the land of mobile apps we have two
01:42 - types of apps native and hybrid apps
01:45 - when you create a mobile app you have
01:47 - two choices
01:49 - create a hybrid app or create a native
01:51 - app when you create a native app you
01:54 - write two separate applications one will
01:56 - use Swift or objective c and is an app
01:59 - for the iOS platform
02:01 - the other uses kotlin or Java and is an
02:04 - application for the Android platform
02:07 - creating a native application gives you
02:09 - opportunities for fantastic user
02:11 - experiences but the trade-off is that it
02:14 - means you need to do the work twice in
02:16 - order to create one application once for
02:18 - iOS and one for Android and often this
02:21 - means you need two development teams the
02:23 - alternative is to create a hybrid app so
02:26 - hybrid apps have one code base and can
02:28 - run on multiple platforms and examples
02:31 - of these include Cordova and ionic so
02:33 - you could have one code base and the app
02:35 - can run on both IOS and Android
02:39 - the benefit with hybrid apps is that you
02:41 - don't need two code bases or knowledge
02:43 - of multiple languages
02:45 - the issue with a traditional hybrid app
02:47 - though is that you're essentially
02:49 - creating a web app that runs on a phone
02:52 - so you have a container which renders
02:54 - web views
02:56 - a webview essentially vendors a website
02:58 - inside of the application
03:01 - when you do this the user experience is
03:03 - restricted
03:04 - so this is where react native comes in
03:07 - whilst technically react native is a
03:09 - hybrid platform because you only have
03:11 - one code base the app renders using real
03:14 - native UI components as opposed to
03:17 - webviews react native takes our
03:19 - JavaScript code and makes a bridge
03:21 - between our app and our Target platform
03:23 - so our components get rendered natively
03:26 - without using web views and we can use
03:28 - platform specific apis and components
03:33 - consequently we have a more performant
03:35 - app with a much better user experience
03:38 - you're also able to extend the code and
03:40 - create custom native components if
03:42 - required so you might have heard of Expo
03:44 - already but what is Expo
03:47 - well Expo is an external platform which
03:50 - makes our lives easier when we're
03:51 - developing building and deploying react
03:54 - native applications
03:56 - it is not compulsory to use Expo but if
03:58 - you're just getting started it is much
04:00 - quicker
04:02 - if you don't use Expo you have to go
04:04 - through the various steps of installing
04:06 - Android studio and xcode and then making
04:08 - sure you have simulators and emulators
04:10 - running when we use Expo we can just run
04:13 - the app easily on our device by simply
04:15 - scanning a QR code for this course we'll
04:18 - be using Expo
04:20 - so let's go ahead and get our
04:21 - environment set up so firstly we need to
04:24 - make sure we have a recent version of
04:25 - node installed
04:27 - next we need to go ahead and install the
04:30 - XPO CLI which will help us to create our
04:33 - project
04:34 - to do this we just type npm install Dash
04:38 - G because we want it installed globally
04:41 - Expo CLI
04:45 - now we need to navigate to the directory
04:48 - where we would like to create our
04:49 - project
04:53 - and then we can just go ahead and create
04:55 - it we do this by typing npx create Expo
04:59 - app
05:00 - weather app
05:05 - now all we have left to do is to run the
05:08 - project
05:11 - so we change directories into where we
05:13 - want the project to run by typing CD
05:15 - weather app
05:17 - and now we just type npm start
05:21 - you can also type Expo start or yarn
05:23 - start here if you have yarn installed
05:25 - and that is your preferred package
05:27 - manager
05:30 - lastly we can Now preview the app on our
05:33 - phones
05:34 - you have to make sure your phone is on
05:36 - the same internet connection as your
05:38 - computer
05:40 - then you can install the client for Expo
05:42 - from the app store or the Google Play
05:44 - Store
05:45 - you can find this by searching for Expo
05:47 - and the app is free
05:50 - once this is installed you can scan the
05:52 - QR code onto the camera if you're using
05:55 - an iOS device or from the app if you're
05:58 - using an Android device
06:00 - at this point you should see the app
06:02 - running
06:06 - for the purposes of teaching this course
06:08 - I'll be running the app on a simulator
06:10 - so I'll briefly go ahead in the next
06:12 - video and show you how to set this up
06:14 - but feel free to skip this section if
06:17 - you're happy to run the app on your own
06:19 - device so now we've looked at setting up
06:21 - a react native application using Expo
06:23 - I'm going to show you how to set the app
06:25 - up using the react native CLI
06:28 - you don't need to watch this section or
06:30 - do the setup if you're happy to run the
06:32 - app using Expo on your own device but
06:34 - I'm going to show you how to complete
06:35 - the setup using this approach so you're
06:37 - aware of it because as I mentioned
06:39 - earlier if you want to build an
06:41 - application using custom native code
06:43 - then you need to use this approach
06:46 - so we'll start by looking at iOS
06:48 - for this you need to have a Mac if you
06:51 - don't have a Mac you can still watch or
06:53 - you can skip to the section where I set
06:55 - up an application and then move on to
06:57 - Android
06:58 - so we'll start by following the
07:00 - documentation on the react native
07:01 - website
07:03 - we need to make sure we have node and
07:05 - Watchman installed
07:06 - if you want to work with multiple
07:08 - versions of node I highly suggest using
07:10 - NVM and the setup for this can be found
07:13 - here
07:17 - for those of you who aren't familiar
07:18 - with Watchman Watchman detects when the
07:21 - source code has changed so it can
07:22 - rebuild the bundle automatically next
07:25 - you need to make sure you have the
07:27 - correct version of Ruby installed
07:29 - on your machine you can type Ruby dash
07:32 - dash version to check which version you
07:34 - have installed
07:36 - if it doesn't match the version react
07:38 - native uses we can find more information
07:40 - about that here
07:42 - and then you need to install this
07:44 - version too
07:46 - you can do this by using a ruby package
07:48 - manager such as rvm
07:52 - so now we're ready to install xcode and
07:55 - we do this via the App Store
07:57 - this will install the various tools and
07:59 - simulators for us to run the application
08:03 - this installation can take some time so
08:06 - you may want to pause the video here and
08:07 - let this download if you're following
08:09 - along
08:13 - so now we need to make sure we have
08:15 - cocoapods installed if you have never
08:17 - used poker pods it's a dependency
08:19 - manager a little bit like npm but for
08:22 - iOS
08:24 - so now we have everything installed we
08:26 - can go ahead and create the application
08:28 - it's worth noting the warning provided
08:30 - on the website which says if we have
08:32 - previously installed the react native
08:34 - CLI we should remove it to avoid
08:36 - unexpected issues so we'll do that now
08:39 - by typing npm uninstall Dash G react
08:43 - native CLI
08:46 - and at react native Community CLI
08:52 - so now let's navigate to where we want
08:54 - to create the project and we'll do this
08:56 - by saying MPX react native init awesome
08:59 - project
09:02 - for those of you who are not familiar
09:03 - MPX is part of the npm tool chain which
09:07 - lets you run commands without installing
09:09 - things globally
09:12 - at this point our project should be set
09:14 - up so we can navigate into it by typing
09:16 - CD awesome project
09:18 - and now we're ready to start the
09:20 - application
09:21 - we need to use two commands for this so
09:23 - it's useful to have two separate windows
09:25 - open in your terminal
09:28 - First Command we use is MPX react native
09:31 - start this command will start running
09:34 - Metro which is the bundler that react
09:36 - native uses
09:37 - we could also run yarnstart here if you
09:40 - prefer to use yarn as your package
09:42 - manager or even npm run start
09:46 - finally we're ready to start the
09:48 - application and we do this by typing MPX
09:50 - react native run iOS
09:53 - now you should see the application
09:55 - launch inside a simulator
10:01 - as a side note if you're more
10:03 - comfortable working with xcode you can
10:04 - launch the application from there you
10:07 - will need to open the XC workspace
10:09 - ensure you're running Metro with react
10:11 - native start and then you can manually
10:13 - run a simulator
10:15 - in the next section we'll move on to
10:17 - launching the application via Android
10:19 - in the last section we looked at running
10:21 - the application using xcode and iOS
10:24 - this time we'll look at running the
10:25 - application with Android Studio
10:28 - the first thing you'll need to do is to
10:30 - make sure you have Android Studio
10:31 - downloaded and installed
10:34 - the link to download this can be found
10:35 - here
10:36 - once Android Studio is installed we need
10:39 - to make sure we have an emulator set up
10:42 - to do this we simply open Android Studio
10:45 - and select configure
10:50 - we then create our device
10:53 - when you are running the application on
10:54 - Android you need to make sure the
10:56 - emulator is launched before you do
10:58 - anything else
10:59 - we can simply double click the device
11:01 - here to launch it if you want to launch
11:03 - the emulator from your command line you
11:06 - type emulator Dash avd and then type the
11:09 - name
11:10 - so now we can close Android studio and
11:12 - type npx react native run Android and we
11:16 - should see our application launch in the
11:18 - emulator
11:21 - if you prefer to use your own device
11:23 - here you can simply plug the device into
11:25 - your computer and you should see it
11:27 - automatically detected if you've run
11:29 - into any issues make sure you have
11:32 - enabled USB debugging on the device
11:35 - finally if you run into any other issues
11:37 - which says could not connect to the
11:39 - development server You may wish to run a
11:41 - command which says ADB reverse TCP colon
11:45 - 8081 TCP colon 8081
11:50 - doing this will set the port of your
11:52 - Android device to the port of your
11:54 - computer
11:57 - so now we have everything set up let's
12:00 - go ahead and explore the application in
12:02 - its current state
12:03 - I'm going to revert back to my project
12:05 - set up with Expo
12:07 - depending on how you set the application
12:09 - up you should be presented with a basic
12:11 - folder structure inside of your text
12:12 - editor if the project was created using
12:15 - the react native CLI you'll see a
12:17 - directory with iOS and another directory
12:19 - with Android
12:20 - inside of these directories are native
12:22 - entry points to the application we also
12:25 - have our node modules and Babel setup
12:28 - additionally if you set the application
12:30 - up with the react native CLI you'll also
12:32 - see prettier and we should also have a
12:35 - file called app.js
12:37 - so to make our lives easier we're going
12:39 - to add a linter for working with our
12:41 - project
12:42 - for those of you who use the react
12:44 - native CLI you should have a link to
12:46 - pre-installed
12:48 - but if you set the application up using
12:50 - Expo you will not have this
12:52 - depending on whether you're using yarn
12:54 - or npm you'll need to run the following
12:56 - which will install eslint as a
12:58 - development dependency npm install
13:01 - eslint dash dash save Dash Dev
13:11 - now we can initialize eslint and we do
13:14 - this by typing npx eslint dash dash init
13:42 - after this is done we should have an
13:45 - eslint RC file created with some setup
13:48 - and we can modify this
13:52 - we're also going to install the react
13:54 - native Community eslint config
13:56 - so we say npm install
13:59 - at react native Community slash eslint
14:03 - Dash config
14:04 - dash dash save Dash Dev
14:20 - I'm going to add a couple of extra rules
14:22 - but you're welcome to customize this to
14:24 - your own preference
14:33 - so now we'll also need to install
14:35 - prettier for helping us with our code
14:37 - formatting
14:38 - to do this we type npm install dash dash
14:41 - save Dash Dev
14:45 - dash dash save exact prettier
14:49 - and now we also need to create a file
14:51 - for our config so we'll type
14:53 - touch.pritia.js
14:57 - and we'll add the following
15:36 - you can find out more about setting
15:39 - config for any of these files here and
15:42 - here
15:45 - it's also worth adding eslint to your
15:47 - text editor depending on what text
15:49 - editor you have
15:52 - if you're using atom you can navigate to
15:54 - preferences
15:55 - install
15:57 - int
15:59 - or if you're using vs code then you can
16:02 - go to preferences
16:04 - extensions eslint
16:07 - if you've run into any issues you may
16:09 - need to try restarting your text editor
16:12 - lastly we can add a script for running
16:14 - eslint inside of our package.json
16:18 - so we'll call it lint
16:20 - and we'll set the value to eslint Dot
16:24 - to run this now all you need to do is
16:26 - type npm run lint or yarn lint so when
16:30 - you're working on an application it's
16:32 - really useful to know how to debug the
16:33 - code
16:34 - in order to fix any errors that you may
16:36 - create or run into
16:38 - in react native we have the ability to
16:41 - access what is called a debug menu
16:44 - with the various ways to run the
16:46 - application we have slightly different
16:48 - ways to access the debug menu
16:50 - if you're running the application on a
16:52 - physical device you can shape the device
16:54 - to access the debug menu if you're
16:56 - running the application on an iOS
16:58 - simulator then you can type command d
17:01 - and on an Android emulator command m
17:04 - if you're on a Mac or control M if
17:07 - you're on a Windows
17:09 - so now we should all be able to see the
17:10 - debug menu and we can see the options
17:13 - which are available to us
17:15 - the first one is reload
17:17 - whilst these days react native has hot
17:20 - reloading available it's still useful to
17:22 - know this option is here
17:24 - you're also able to type command R so
17:27 - you can do this without launching the
17:29 - debug menu the next option is debug
17:32 - selecting this will open the react
17:34 - native debugger and once this is open
17:37 - you can access the JavaScript console
17:39 - just like when you're working with a
17:40 - website
17:42 - so you can do this in Chrome by
17:43 - selecting view developer JavaScript
17:46 - console
17:47 - or you can type command option in j
17:51 - this means we can use console logs
17:53 - inside of our application and inspect
17:55 - them
17:56 - so let's navigate our application.js
17:59 - file
18:00 - I'm going to add a console log
18:05 - now let's go back to Chrome
18:08 - everyone can see our console log is
18:10 - printed out to us
18:14 - so when you're working with mobile apps
18:16 - each platform has a set of native
18:18 - components
18:19 - whilst the names of these differ
18:20 - depending on the platform the outcome is
18:23 - the same they help you lay out the UI of
18:25 - the application
18:27 - so for example on iOS if you're working
18:29 - with images you could use a UI image
18:32 - View
18:32 - whereas on Android you would use an
18:35 - image View
18:36 - on iOS this may be contained within a UI
18:39 - view whereas on Android this may be
18:42 - contained within a View group with react
18:44 - native we use JavaScript in our
18:46 - components and when the app runs react
18:48 - native will then create the correct UI
18:51 - for the different IOS and Android
18:53 - platforms so in order for us to create
18:55 - our UI react native has some core
18:58 - components which we can use
19:00 - if you're familiar with react you can
19:02 - think of this a bit like how you use
19:04 - divs and spans or P tags for your layout
19:07 - here are some of the core components
19:09 - that react native provides so we may
19:11 - wrap our layout inside of a view and
19:14 - then inside of this we may want to
19:16 - display some text using the text core
19:18 - component or a button using the button
19:22 - component
19:23 - so in our app.js file let's go ahead and
19:26 - use the core text component to add some
19:29 - text which we will wrap inside a view
19:32 - you can think of a view a bit like div
19:34 - so unless we apply styling to it the
19:37 - view won't be visible
19:38 - so we'll create a view and give it a
19:40 - height and a width of 100.
19:54 - and a background color of orange
19:57 - inside of the view we'll use the text
20:00 - core component and print out some text
20:02 - that says hello world
20:05 - now let's run this on our device
20:09 - we can see The View with the orange
20:10 - background which also contains our text
20:13 - so you may be wondering what the syntax
20:16 - is with all these tags it looks a bit
20:18 - like JavaScript and HTML and it's called
20:21 - jsx
20:23 - jsx is an extension of JavaScript
20:27 - and it stands for JavaScript and XML
20:31 - so we use jsx when we're creating
20:33 - elements and because it is Javascript
20:36 - we're also able to use JavaScript with
20:38 - it
20:39 - so we could change our text to use a
20:41 - variable instead
20:43 - let's give this a go
20:46 - so before the return statement we'll
20:48 - create a variable called message
20:55 - and when assigned to this our string
20:57 - which says hello
20:59 - now because we're going to be evaluating
21:01 - a JavaScript expression when the element
21:03 - is rendered we need to use a set of
21:06 - curly braces
21:07 - [Music]
21:09 - inside of these curly braces we place
21:12 - our variable so we use the message
21:14 - variable here
21:16 - now let's return to our simulator
21:19 - nothing has changed visually but we just
21:21 - used a variable to render the text
21:23 - so before we start building our
21:25 - application there's a few other things
21:27 - we need to be aware of when we're
21:28 - working with components
21:30 - you need to import react and then you
21:32 - need to import any of the core
21:34 - components that you wish to use
21:37 - your component is a constant function so
21:40 - it starts with const and any jsx must be
21:44 - returned
21:47 - lastly you need to export the function
21:49 - components and we do this using export
21:51 - default
21:55 - so we've come across the term component
21:57 - a few times in this section
22:00 - we have the core components which we
22:02 - import such as View and text
22:04 - but we also referred to everything in
22:06 - the file as a component
22:08 - we use the term element to describe what
22:11 - we see on the screen
22:12 - but this is contained within what we
22:15 - call a component
22:19 - one of the best things about react and
22:21 - react native is how it makes you the
22:23 - developer break down what you're
22:25 - building
22:26 - [Music]
22:27 - the UI is separated into different
22:29 - pieces
22:31 - if we take a look at the open weather
22:32 - map website we can see we have a
22:35 - navigation bar with various links
22:38 - foreign
22:39 - we have a search text input we have a
22:43 - map and some diagrams
22:45 - and also some City details all of these
22:48 - pieces can be broken down into separate
22:50 - components before they are rendered on
22:52 - the screen
22:54 - this makes working with code a lot of
22:56 - fun
22:57 - but it also makes it very extensible and
23:00 - clear so now we have a basic
23:02 - understanding of how react native Works
23:04 - let's go ahead and create our first
23:06 - component
23:07 - so now we have a basic understanding of
23:09 - how react native Works let's go ahead
23:12 - and create our first component
23:16 - so in the app.js file let's delete
23:19 - everything
23:24 - the first thing you need to do when you
23:26 - create a component is to import react
23:28 - so let's go ahead and do that now
23:31 - we say import
23:34 - react
23:38 - from
23:40 - react
23:44 - next we'll import the core components
23:46 - that we are going to use
23:48 - in our case we'll just use View
23:51 - and text
23:55 - so we say import
23:58 - and then we use a set of curly braces
24:02 - inside the curly braces we say View
24:07 - and text
24:10 - outside of the curly braces we say from
24:15 - react native
24:20 - there are a few different ways to create
24:21 - components but we're going to use the
24:24 - constant function approach described in
24:26 - the last section
24:27 - and we can look at these other
24:28 - approaches a bit more later
24:32 - we're going to call this component app
24:35 - so we say const
24:39 - app
24:42 - followed by an equal sign
24:45 - a set of parentheses
24:48 - an arrow
24:51 - and a set of curly braces
24:55 - lastly we need to export the component
24:58 - so we say export
25:01 - default
25:03 - app
25:07 - our component does not render anything
25:09 - but this is the basic setup for the
25:12 - components to achieved
25:13 - now we can add the jsx to return some UI
25:18 - we start by using the return keyword
25:21 - followed by a set of parentheses
25:25 - we'll start by adding The View
25:31 - and then we'll also add the text
25:36 - for our text we say current
25:40 - weather
25:43 - so let's take a look at the simulator
25:47 - it's very hard to see the text
25:50 - the layout of the text will vary
25:52 - slightly depending on which simulator or
25:54 - emulator you're using
25:56 - this is a bit like a layout on a website
25:58 - varying depending on the size of the
26:00 - computer screen or the different browser
26:03 - for this reason just adding padding or
26:05 - margins to fix the layout is not a great
26:07 - approach because you might fix the
26:09 - layout on one screen but it won't be
26:11 - guaranteed to look better on a different
26:13 - screen size or device
26:15 - and you also want to be mindful that
26:16 - people might be using your application
26:18 - on an iPad or tablet too
26:22 - so with this in mind react native
26:24 - provides another core component which
26:26 - can help solve this problem
26:28 - it's called a safe area View
26:31 - let's update our code to use this
26:35 - so we start by adding it to the import
26:40 - and then we'll wrap the whole element
26:41 - inside of a safe area View
26:52 - now if we check the simulator again we
26:55 - can see the content has been rendered
26:56 - just below the status bar of the device
27:02 - so now we made our first component let's
27:04 - move on to discussing styling
27:07 - in react native we don't have access to
27:10 - standard CSS
27:12 - instead we use a JavaScript object
27:16 - the naming of the properties is usually
27:18 - the same as with standard CSS
27:21 - except that we use camel casing instead
27:24 - so font size becomes font size for
27:28 - example
27:29 - there are a few different ways to apply
27:31 - the Styles but we're going to start by
27:34 - using inline styles
27:36 - when we use inline Styles the styles are
27:39 - applied as we create the component
27:42 - so we're going to start by applying a
27:44 - background color of pink to our view
27:48 - we'll talk about props shortly but for
27:50 - now just think of them like properties
27:52 - like when you add key value pairs to an
27:54 - object
27:56 - so we set a style prop on our view
27:59 - we say Style
28:01 - equals
28:04 - and then a set of curly braces
28:07 - inside the curly braces because we are
28:10 - using inline Styles we add a second set
28:12 - of curly braces
28:16 - and then we say background color
28:20 - a colon
28:23 - and then a string with the value pink
28:27 - let's save this and view it in the
28:29 - simulator
28:31 - we can see our screen with our pink
28:33 - background color applied
28:38 - so whilst this works as our code becomes
28:40 - more complicated applying inline Styles
28:43 - in this way can get quite messy
28:46 - so as it's always good to focus on
28:48 - writing quality code we're going to use
28:50 - another approach and this is called
28:52 - stylesheet.create
28:55 - so we can Define our Styles all in one
28:57 - place
28:59 - to do this we need to import style sheet
29:01 - from the react native API
29:04 - the list of the apis we can use with
29:06 - react native can be found here
29:11 - so we go ahead and we create a style
29:13 - object
29:14 - usually it's best to do this before you
29:17 - export the component
29:19 - so we say const styles
29:23 - equals
29:25 - style sheet
29:27 - Dot create
29:30 - we follow this by a set of parentheses
29:34 - and then a set of curly braces
29:36 - because we're passing it an object
29:40 - we can then go ahead and add our styles
29:43 - so we're going to call this attribute
29:45 - the container
29:48 - and now we can add background color
29:56 - now we need to add this to our component
30:01 - we can remove the second set of curly
30:03 - braces
30:07 - and then say styles
30:09 - Dot
30:11 - container let's save this and view the
30:14 - simulator
30:17 - nothing has changed visually but we have
30:19 - moved away from inline Styles and
30:21 - started using stylesheet.create instead
30:27 - when you're applying styles to your
30:28 - component it can be useful to refer to
30:31 - the documentation as these props vary
30:34 - slightly depending on what core
30:35 - component you're applying the styles to
30:38 - you can find out more about these here
30:43 - so we've just applied the background
30:45 - color
30:46 - but we only have the background color
30:48 - around the text not the whole screen
30:51 - so let's add a few other things here
30:54 - we'll add a style to the safe area view
30:57 - called wrapper
30:59 - and apply Flex one
31:03 - we'll also add Flex 1 to the container
31:16 - Flex is part of the layout props
31:18 - when we're building react native
31:20 - applications positioning and layout is
31:23 - done using flexbox and the reason for
31:25 - this is that it lets us build our
31:27 - layouts for the various different screen
31:29 - sizes that we will encounter
31:31 - so unlike with the web you don't have to
31:34 - say display Flex for those of you who
31:36 - aren't familiar
31:37 - Flex will Define how much of the screen
31:39 - The View should fill and you provide a
31:41 - value from zero upwards
31:44 - so we're saying Flex of one
31:46 - and this is the equivalent of saying the
31:49 - view should fill the entire screen
31:50 - because we're only using one View group
31:54 - when you want to start to split the view
31:56 - into different areas you may need to
31:58 - start to consider the different values
31:59 - depending on how much space you want
32:01 - each part of the screen to fill
32:05 - so if you're using Flex one then all the
32:07 - components up the tree must also use
32:09 - flex one
32:10 - which is why we also apply it to the
32:13 - outer safe area View
32:15 - let's also make our title display in the
32:17 - center of the screen
32:19 - we can do this by saying align items
32:22 - Center
32:24 - so this centers the text horizontally
32:27 - if we wanted to display the text in the
32:29 - center vertically we would just use
32:32 - justify content
32:34 - we want our text to just be centered
32:36 - horizontally
32:39 - so the goal for this screen is to show
32:41 - the user the current weather
32:44 - we want to display the actual
32:45 - temperature what the temperature feels
32:48 - like
32:48 - the high and low values
32:51 - and then we want to display a
32:52 - description and some additional text
32:54 - about the weather
32:56 - lastly we also want to display an icon
32:58 - and a background color
33:01 - eventually we want this screen to be
33:03 - dynamic so the icon background color and
33:06 - message that we provide change depending
33:09 - on the weather
33:10 - for now though let's just hard code
33:12 - everything in so that we can get our
33:14 - basic layout and once we have looked at
33:16 - getting the data from the API we can
33:18 - update this so it works dynamically
33:22 - so let's start by adding our text for
33:24 - the first value that we want to add
33:26 - which will be the temperature
33:27 - and for now we'll just add six for the
33:30 - value
33:35 - we'll add another text for the fields
33:43 - so we'll say fields
33:46 - like
33:47 - five
33:50 - let's add the high and low in another
33:53 - text
33:57 - so we say hi
34:00 - colon
34:02 - eight
34:06 - and low
34:07 - colon
34:09 - six
34:13 - so let's start by adding the layout
34:15 - styles for these
34:17 - we'll start with the temperature and
34:19 - we'll call this temp
34:27 - we'll give this a color of black
34:33 - and a font size
34:35 - of 48.
34:39 - you don't use units just the numbers for
34:41 - the Styles and react native
34:44 - all dimensions in react native are
34:46 - unitless and represent density
34:48 - independent pixels
34:51 - so this is an absolute unit of
34:52 - measurement for the device
34:56 - for the feels like text We'll add some
34:59 - Styles called feels
35:05 - foreign
35:07 - and this will have a font size
35:10 - of 30
35:12 - and a color
35:15 - of black
35:17 - we also don't now need our title so
35:20 - let's delete that
35:24 - let's also add some styles for the high
35:26 - and low text
35:28 - we'll apply this to both pieces of the
35:30 - text and we'll call it styles
35:33 - Dot
35:34 - high low
35:40 - we will give this a color of black
35:47 - and a font size
35:50 - of 20.
35:57 - let's view the simulator and see what
35:59 - we've done so far
36:03 - we want the text for the high value and
36:05 - the text for the low value to appear on
36:07 - the same line
36:09 - to do this we can set the flex direction
36:11 - to use row
36:14 - we'll start by making a container for
36:16 - these pieces of text and then set the
36:19 - flex Direction on the container so that
36:21 - it applies to the children which is the
36:24 - high and low text
36:26 - so we start by wrapping both pieces of
36:28 - text in a view
36:54 - and we'll call the styles for this Hi-Lo
36:57 - wrapper
37:06 - we'll then say Flex Direction
37:10 - right
37:16 - now if we check on the device again we
37:19 - can see the high and low text both
37:21 - appear on the same line
37:24 - on the bottom of the screen we want to
37:26 - add some more details about the current
37:27 - weather conditions so we'll create
37:29 - another view
37:33 - and inside this we'll place two pieces
37:35 - of text
37:40 - inside the first text we'll say it's
37:43 - sunny
37:47 - and inside the second we'll say it's
37:51 - perfect t-shirt weather
37:57 - we want this text to show at the bottom
37:59 - of the screen so let's apply some styles
38:04 - we'll call the attribute body wrapper
38:16 - and set justify content to flex end
38:25 - this is so that it displays on the
38:26 - bottom of the screen
38:28 - let's also add align items
38:31 - with flex start
38:34 - so that the text displays on the far
38:36 - left of the screen
38:39 - we're also going to change our container
38:40 - so that it only wraps the items we want
38:42 - to display on the top portion of the
38:44 - screen
38:48 - so we'll move the closing brace for this
38:51 - view to be just before the view of the
38:53 - body wrapper attributes
39:03 - now let's also apply some styles to the
39:05 - text with the weather description
39:09 - we'll call the first one description
39:16 - and we'll call the second one
39:18 - message
39:24 - inside description let's add a font size
39:26 - of 48.
39:31 - and let's make the message a bit smaller
39:33 - so this one will have a font size
39:36 - of 30.
39:40 - now let's check the simulator
39:44 - we have our basic layout set up
39:46 - but it doesn't really look very pretty
39:49 - nor is it very dynamic
39:52 - we also see that our background color
39:53 - does not apply to the whole screen
39:56 - this is because we changed the container
39:58 - to only wrap the items at the top of the
40:00 - screen
40:01 - we can fix this by moving the background
40:03 - color into the safe area view wrapper
40:06 - let's do this now
40:12 - let's check the simulator again
40:17 - and we can see everything now looks as
40:19 - we expect
40:22 - in the next section we'll look at adding
40:24 - an image to the screen
40:26 - so we want to display an icon that
40:28 - represents the weather to the user
40:31 - there are a few ways we could do this
40:33 - but I'm going to use a library which is
40:35 - installed by default when we use create
40:37 - Expo app
40:39 - if you did not create the app using Expo
40:41 - you can manually install it now
40:44 - it's called react native Vector icons
40:47 - and it provides us with a variety of
40:49 - icons that we can use within our project
40:52 - the library Expo installs is built on
40:55 - top of the react native Vector icons one
40:59 - to explore the Expo items you can see
41:02 - them here
41:05 - for now we just want to use an icon that
41:07 - represents sunshine so let's search for
41:09 - this
41:12 - when we click on the icon it provides us
41:14 - with the details we need to use the icon
41:17 - so to start we need to import the icon
41:19 - family
41:23 - next we need to add the icon to our
41:25 - component
41:29 - we're going to show the icon at the top
41:30 - of the screen
41:32 - let's also change the size to be 100 so
41:35 - it's a bit bigger
41:37 - let's have a quick look on the simulator
41:39 - and see how this looks now so we can see
41:41 - the icon has been successfully added to
41:43 - our screen
41:45 - the top part of the screen is starting
41:47 - to look quite busy so let's Center all
41:49 - of this content by adding justify
41:51 - content Center to the container
41:59 - let's also add some left padding to the
42:01 - text at the bottom of the screen
42:04 - so I'll add padding left
42:07 - with the value of 25.
42:11 - and a margin bottom of 40.
42:16 - so in react native when we're adding
42:18 - things like margins and padding we can
42:20 - either provide a single value to the
42:22 - padding or margin which will affect the
42:24 - top right bottom and left alternatively
42:28 - we can apply separate values to the
42:30 - different areas like we're doing
42:33 - now we have our first component so we
42:36 - can look and moving on to using it with
42:38 - real data
42:39 - we're going to start by moving our
42:41 - current weather component into another
42:43 - component
42:45 - there are a few different approaches you
42:47 - can use in terms of structuring your app
42:49 - and these often vary depending on the
42:52 - complexity of the application
42:54 - we're going to start by creating a
42:56 - directory called SRC
43:01 - inside of this we're going to create
43:02 - another directory called components
43:08 - inside of the components directory let's
43:11 - create a file called current weather
43:14 - dot Js
43:19 - so let's paste everything from the app
43:21 - file into the current weather component
43:31 - let's also rename the component from app
43:33 - to current weather
43:41 - we also need to make sure it's exported
43:48 - now inside the app file let's delete
43:51 - everything
43:56 - let's redefine our component again
43:59 - so we say const
44:02 - app
44:05 - equals
44:08 - and then we use an arrow function
44:11 - with parentheses
44:14 - at the bottom of the file we say export
44:18 - default
44:20 - app
44:22 - inside the body let's add return
44:25 - with some parentheses
44:29 - we'll also import react
44:35 - and let's also import View
44:38 - from react native
44:42 - lastly we'll also import stylesheet
44:49 - let's set up the styles
44:52 - so we say const
44:55 - styles
44:58 - equals
45:00 - style sheet
45:03 - Dot
45:04 - create
45:07 - and we'll set an attribute called
45:08 - container
45:11 - we'll give this a flex of one
45:18 - let's now add the view to our component
45:23 - and we can apply the styles
45:29 - we also want to use our current weather
45:30 - component so we'll import this to start
45:33 - with
45:34 - we say import
45:37 - and say current weather
45:39 - and then we need to provide the path
45:41 - that we want to get the file from
45:46 - now all we have left to do is to render
45:48 - this inside of the component
45:53 - let's save this and check everything
45:55 - worked in the simulator
45:58 - everything looks good
46:01 - so before we go any further let's take a
46:04 - step back and review what we have just
46:06 - learned
46:07 - so far we have learned how to set up an
46:10 - app with Expo
46:12 - we have looked at how to create and
46:14 - import a component
46:16 - and we've also looked at basic styling
46:18 - for our components
46:22 - a component is a function that returns
46:24 - some amount of jsx
46:26 - the jsx is the syntax we use to make our
46:30 - lives easier for readability purposes
46:33 - but under the hood jsx gets turned into
46:36 - JavaScript by using babble
46:40 - and you can see more about the
46:41 - conversion here
46:45 - inside of our components we show
46:48 - or render something to show the user
46:51 - we can then export the component and use
46:54 - it elsewhere in our application
46:56 - when it comes to importing a component
46:58 - into another component we use the
47:01 - keyword import and relative path
47:04 - so we don't have to append the dot Js
47:09 - when we work with react native we are
47:12 - working with a framework that promotes
47:13 - lots of component reuse because it's a
47:16 - component-based framework
47:18 - so in our application we'll usually have
47:21 - a root component which in our case is
47:23 - the app.js file and this acts as the
47:26 - entry point for the application
47:28 - but then we'll usually have multiple
47:30 - other components which are usually
47:32 - stored inside of a directory called
47:34 - components
47:36 - inside these components we may then
47:38 - import additional components
47:41 - so for example we may create a custom
47:43 - button and reuse it throughout our
47:45 - application as opposed to redefining it
47:47 - in multiple places
47:50 - as a side note you're able to have more
47:53 - than one component in a file but just
47:55 - having the one makes the code much
47:57 - easier to work with and this is very
47:59 - important especially when there's more
48:01 - than one developer working on a project
48:03 - so this component-based architecture not
48:06 - only helps with debugging and easier
48:08 - testing
48:09 - but there's also a convention encoding
48:11 - called dry which stands for don't repeat
48:13 - yourself
48:15 - it's good to have this at the back of
48:16 - your mind when you're working with a
48:18 - component-based framework
48:20 - so our app is going to have two
48:22 - additional screens
48:24 - one which will show the upcoming weather
48:26 - and one which will show some details
48:28 - about the local city to the user
48:31 - as we're still getting familiar with
48:33 - react native we're going to move on to
48:35 - implementing the initial layout for
48:36 - these screens first
48:38 - after we've done this we'll have a look
48:40 - at how to make them Dynamic by fetching
48:42 - data from the open Weather API
48:44 - and then we'll look at how we can wire
48:46 - up all these screens together with
48:48 - navigation
48:50 - so we're going to start by creating the
48:52 - component to show the upcoming weather
48:54 - we'll call this component upcoming
48:56 - weather
48:57 - so we can create a file inside of our
48:59 - components directory
49:08 - let's also create the boilerplate for
49:10 - our component
49:12 - so we say const
49:14 - upcoming weather
49:21 - equals and then we use a set of
49:23 - parentheses an arrow function
49:27 - and a set of curly braces
49:31 - we'll also make sure to export the
49:33 - component so we say export default
49:36 - upcoming weather
49:39 - we need to import react from react
49:46 - foreign
49:51 - safe area View
49:54 - from react native
49:57 - inside of the component we'll say return
50:01 - and we'll add a set of parentheses
50:05 - inside of the parentheses We'll add the
50:08 - tags for the safe area View
50:12 - let's also set up our styles
50:16 - so we add style sheet to the react
50:18 - native import
50:21 - then before our component is exported we
50:24 - say const styles
50:26 - equals
50:28 - stylesheet
50:29 - dot create
50:32 - we add some parentheses
50:35 - and curly braces
50:38 - we'll also create a container and we'll
50:40 - add this to the safe area View
50:52 - we'll give this Flex of one
50:57 - let's also add some text
50:59 - so we need to import this
51:03 - and now we can create the text
51:06 - we'll give this the message upcoming
51:09 - weather
51:13 - in order to check we've set up the
51:15 - component correctly we can view it in
51:17 - the simulator
51:18 - before we do this though we'll need to
51:20 - add the component to our app.js file
51:24 - so at the top of the file just like we
51:26 - did with current weather
51:28 - let's import the file now
51:33 - then in the render let's remove current
51:35 - weather
51:38 - and add the upcoming weather
51:42 - let's check the simulator
51:45 - we can see our component has been set up
51:47 - correctly
51:48 - and we get to see the upcoming weather
51:50 - text we added
51:52 - so what are our goals for this component
51:55 - well we want to be able to show the user
51:57 - a list and in the list we want to show
52:00 - the user the date and time
52:03 - an icon
52:04 - and what the weather will be at that
52:06 - time
52:07 - before we do this we need to have a look
52:10 - at how lists work in react native as
52:12 - showing lists to a user is a core part
52:15 - of working with mobile apps and it's
52:17 - something you're likely to come across
52:18 - very often
52:20 - so rendering lists inside of mobile apps
52:23 - is a common task you may find yourself
52:25 - presented with
52:26 - take a look at your favorite social
52:28 - media app
52:30 - or have a look at a news app
52:32 - because of the often limited screen size
52:34 - we have on a mobile device
52:36 - very often the information is displayed
52:39 - to us in the form of a list
52:41 - and we have to think carefully about how
52:43 - we go about using it in order to make
52:45 - the best of the screen space we have
52:47 - available to us
52:48 - so in react native when we work with
52:51 - lists we have a choice of a few core
52:53 - components that we can use
52:55 - primarily these are called Flat list and
52:58 - section list
53:00 - additionally we have virtualized lists
53:03 - but it's better to try and use the flat
53:05 - list or section list components because
53:08 - virtualized list is essentially a
53:10 - diluted version of these and unless you
53:13 - need a heavy amount of flexibility you
53:15 - should be able to fulfill your needs
53:16 - with the flat list or section list
53:18 - components
53:22 - so what's the difference between flat
53:24 - list and section list
53:26 - there are a few differences in the way
53:28 - you implement the two which we'll look
53:30 - at shortly
53:31 - but in terms of the end result if you
53:33 - simply have a list that you want to
53:35 - display to the user then you can use
53:37 - flat list
53:39 - we can take a look at the example on the
53:41 - react native website
53:44 - so we see three items in the list here
53:48 - if I try to scroll
53:50 - well not a lot happens
53:52 - however if I add a few more items to the
53:56 - list we can see what happens when the
53:58 - list is bigger
54:00 - I'll add three more items
54:07 - and just amend the title and ID
54:09 - properties slightly
54:19 - so now we see our longer list and we can
54:22 - scroll through the list here like so
54:32 - let's also have a quick look at section
54:34 - list
54:37 - so here we can see the list
54:39 - but we can also see how it's broken up
54:41 - into sections and each section has its
54:44 - own items
54:46 - so we have main dishes
54:48 - sides
54:50 - drinks and so on
54:54 - so the outcome here is that if you have
54:56 - a collection of data that you need to
54:58 - display to the user which needs to be
55:00 - broken into sections then you should use
55:02 - section list
55:04 - otherwise flat list will suffice
55:08 - so let's move on to looking at how these
55:10 - lists are implemented
55:12 - on the right hand side here I can see
55:14 - all the properties that are available to
55:16 - us to use
55:18 - however there are two of these props
55:20 - with a red dot next to them
55:23 - if we scroll down the documentation a
55:25 - bit we can see that these are marked as
55:27 - required
55:29 - so all the other props are optional but
55:31 - render item and sections are compulsory
55:37 - equally if we go ahead and look back at
55:40 - flat list we can see there are again a
55:43 - lot of props available to us but this
55:45 - time we have two marked with a red dot
55:47 - render item and data
55:50 - so the takeaway here is that both lists
55:53 - are heavily customizable but both have
55:56 - two things that you need to provide in
55:58 - order to implement them
56:00 - we are going to be using flat list in
56:02 - our app so let's start with looking more
56:04 - deeply at this one
56:07 - the first one of the required props is
56:09 - data and for this we need to pass an
56:12 - array
56:13 - inside of the array we have the data
56:16 - that we want to be displayed on the
56:17 - screen
56:19 - so if your list was showing a list of
56:21 - cars then you may have an array
56:22 - containing names of cars
56:25 - if your list was displaying a list of
56:26 - students test results then perhaps you
56:29 - would have an array containing the
56:30 - students names and their test scores
56:34 - with flat list you're able to Simply
56:36 - pass in an array let me update the code
56:38 - here to show this
56:41 - I'm going to remove all the objects
56:56 - and then I'll simply pass in the titles
56:58 - to the array
57:00 - so I'll also remove the title keys
57:08 - in the item function I'll also remove
57:11 - the reference to title
57:14 - and simply refer to the item itself
57:19 - so now when the list renders I can see
57:22 - the three items from the data array
57:25 - it's worth pointing out here that this
57:28 - is one of the differences between flat
57:29 - list and section list
57:31 - in that with Section list you must pass
57:34 - in an array of objects because of the
57:36 - fact the list is broken up into sections
57:39 - in reality when you're working with flat
57:42 - list
57:43 - because quite often you're rendering
57:44 - Dynamic data such as that from an API
57:47 - you're probably more likely to end up
57:49 - also passing in an array containing
57:51 - objects too
57:53 - so now we understand the required data
57:55 - property let's have a look at the second
57:58 - required property which was called
58:00 - render item
58:02 - the render item prop gets past a
58:04 - function and this will get called on
58:07 - every array element
58:09 - its job is to decide how that element
58:12 - then gets displayed to the user
58:14 - so you can think of it a bit like the
58:17 - List's own render function
58:20 - if the function for rendering the item
58:22 - is very simple we can place it directly
58:24 - in the definition for the flat list
58:28 - quite often though we end up passing it
58:30 - a reference to a function as we may want
58:33 - to render out quite a few things for our
58:34 - list element we pass a single argument
58:37 - to the function which is an object
58:39 - and this is the item you are rendering
58:43 - so if I refresh the screen and go back
58:46 - to the original example here we can see
58:48 - it renders the title from each item in
58:51 - the data array
58:53 - so if I added another property to the
58:55 - items in the data array let's say amount
59:03 - and then I pass that into the render
59:04 - item
59:13 - and render an additional piece of text
59:15 - to render the amount
59:26 - we then get to see that each item in the
59:28 - list renders this value too
59:31 - if you're working with Section list then
59:34 - render item Works in a similar way
59:38 - so before we move on and look at
59:39 - implementing a list in our app let's
59:42 - recap everything we've just looked at
59:44 - with lists
59:46 - we've learned that in react native we
59:48 - have two main core components that we
59:50 - can use when we're working with lists
59:53 - flat list and section list
59:56 - we know that flat list is more of a
59:58 - standard list
60:00 - but we can use section list if our data
60:02 - needs to be displayed in sections
60:06 - we then looked at what we need to do to
60:08 - get our list up and running
60:11 - we've seen that we must pass in some
60:13 - data which must be an array
60:15 - and if we're using section list then
60:18 - this must also be an array containing
60:20 - objects
60:21 - we've also seen that we must
60:23 - additionally use a prop called render
60:25 - item and we use this to display the list
60:28 - element to the user
60:30 - so let's now move back to our code and
60:32 - figure out how we're going to use a list
60:35 - so back in our upcoming weather
60:38 - component let's start by importing the
60:40 - flat list core component
60:43 - so inside the react native Imports we
60:46 - just say flat list
60:49 - now under our upcoming weather text
60:52 - let's use this
60:55 - so we start by typing flat list
60:59 - we know we need the required data and
61:02 - render item props so let's add these two
61:14 - obviously at the moment we have not yet
61:16 - set up our app to fetch any data so for
61:19 - now let's write this out by hand
61:22 - we'll start by declaring the variable
61:24 - for data outside of our component and we
61:28 - say const
61:30 - data
61:32 - and will assigned this the required
61:34 - array
61:37 - inside the array I'm going to just Place
61:39 - three objects as for now this will be
61:42 - enough before we wire up our app to use
61:44 - the real data later
61:47 - if we have a look at the open Weather
61:49 - API documentation we can see some
61:51 - examples of the data sent back to us
61:55 - there is obviously a lot we can work
61:57 - with here but for our list we're just
62:00 - going to be sharing the weather at three
62:01 - hour intervals and we only need a few
62:04 - bits of data from the response
62:06 - we'll want to use DT text for the
62:09 - current time
62:10 - the Min and Max temperature
62:13 - and a description of the weather
62:16 - so I'm just going to paste in some
62:18 - example code here and you can pause the
62:20 - video now if you're following along
62:29 - so now we have our data we can pass this
62:32 - into the flat list
62:35 - so we should have our data prop defined
62:38 - we use an equal sign and a curly brace
62:41 - and then pass in the data
62:44 - the next required prop we need to add is
62:46 - render item
62:49 - we're going to create a function to pass
62:51 - into this which will render what we want
62:53 - to show to the user
62:55 - in our case we're going to create a
62:57 - separate component for the item so we
63:00 - want render item to render the component
63:02 - that we'll be creating
63:04 - let's start by creating the component
63:06 - for the item
63:08 - I mentioned earlier that it's best to
63:10 - keep components in their own files but
63:12 - whilst we're setting up our list I'm
63:14 - going to create it in this file and then
63:16 - when we do some refactoring we can move
63:18 - it later
63:21 - so we're going to call this component
63:22 - item
63:24 - so we Define it just like we have with
63:26 - all our other components
63:28 - we say const
63:30 - then the component name which is item an
63:33 - equal sign an arrow and some curly
63:35 - braces we then say return with some
63:38 - parentheses
63:41 - we're going to be rendering the DT text
63:43 - min
63:45 - and Max weather
63:47 - and then the weather condition
63:50 - let's add these props now
63:53 - I'm going to Define props in the
63:55 - parameter
63:56 - and then using destructuring I'll pull
63:58 - these out
63:59 - so I say const
64:02 - a set of curly braces
64:04 - an equal sign
64:06 - and props
64:09 - this is a convenient and clean way to
64:11 - access props inside of your components
64:14 - inside the curly braces I'll add DT text
64:19 - men
64:22 - Max
64:24 - and condition
64:26 - now inside the return let's start by
64:29 - adding a wrapper or container
64:32 - so I'll add a view here
64:38 - inside the view I'll add three pieces of
64:41 - text
64:50 - in the first piece of text We'll add the
64:53 - DT text prop
64:54 - so I need to use curly braces because
64:57 - we're using a prop
65:03 - in the second I'll add min
65:08 - and in the third I'll add Max
65:15 - I'm also going to add an icon which will
65:17 - go above all the pieces of text
65:21 - I'm going to do this using Expo icons
65:23 - again so we need to import this
65:27 - under our react native Imports let's say
65:30 - import
65:32 - then we have our curly braces
65:35 - and inside this we say feather
65:42 - then we say from
65:44 - at explo
65:47 - slash Vector icons
65:51 - we're going to be dynamically using
65:52 - different icons based on the weather
65:54 - condition
65:55 - but for now let's just add one to the
65:57 - name Sun as we're going to need to
66:00 - create a file which handles some of the
66:02 - configuration for us later in order to
66:04 - correctly map the feather icon names
66:06 - with the open weather map weather
66:08 - descriptions
66:11 - so I add feather at the top of the view
66:14 - I then set a name prop which is equal to
66:17 - Sun
66:20 - we set the size to be 50.
66:23 - because we're using a list and we don't
66:25 - want the icon to be too huge
66:28 - and then we set the color to white
66:33 - so now we have our list item component
66:35 - let's create the render item function
66:37 - inside of the upcoming weather component
66:41 - so before the return keyword we say
66:43 - const
66:45 - render item
66:47 - and then we set this up like an arrow
66:49 - function
66:50 - so we use an equal sign
66:53 - parentheses
66:55 - an arrow
66:57 - and because we want to render something
66:58 - we'll use another set of parentheses
67:02 - for the parameter we want to pass in the
67:04 - item so we use a set of curly braces and
67:07 - pass in the item
67:10 - we need to pass the required props to
67:13 - the item component
67:15 - so we say condition
67:17 - and set this equal to be item
67:23 - Dot
67:25 - weather
67:28 - we use square brackets to get the
67:30 - element at the position of zero
67:33 - then Dot
67:35 - Main
67:39 - we set the DT text
67:43 - and this is equal to item
67:46 - Dot
67:49 - DT text
67:52 - we then set them in which is equal to
67:55 - item
67:59 - Dot
68:02 - Main
68:04 - Dot
68:06 - temp min
68:10 - and then Max which is equal to item
68:16 - Dot
68:18 - Main
68:20 - Dot
68:22 - temp Max
68:25 - now in our flat list all we need to do
68:27 - is pass in this function
68:29 - so we say render item and pass in render
68:32 - item
68:35 - let's save this and run the app in the
68:38 - simulator to see where everything is at
68:41 - so in the simulator we see the upcoming
68:44 - weather text but then we see the three
68:47 - items from the data that we passed into
68:49 - the flat list rendered on the screen
68:52 - obviously it doesn't look very pleasing
68:54 - but we can address that in a moment
68:57 - before we do that though there's one
68:59 - other thing we need to add to our flat
69:01 - list
69:03 - if we take a look back at the docs on
69:04 - the website we can see the example also
69:07 - include something called a key extractor
69:10 - what is this
69:12 - well let's read through the description
69:17 - it says it is used to extract a unique
69:20 - key for a given item at a specified
69:23 - index
69:24 - key is used for caching and as the react
69:27 - key to track the item reordering
69:30 - the default extractor checks item dot
69:33 - key then item.id
69:35 - and then falls back to using the index
69:38 - like reactors
69:40 - so to summarize when you're working with
69:42 - lists you need to provide a unique key
69:44 - to each element in the data
69:47 - the reason behind this is largely
69:49 - Performance Based and it means that
69:51 - under the hood react native is able to
69:54 - keep track of each item in the list
69:57 - imagine you're working with a really
69:58 - long list
70:00 - say one with over 100 pieces of data
70:03 - when something in the list changes
70:06 - for example if an element was deleted
70:09 - then because of the way react native
70:11 - works when the re-rendering happens
70:13 - everything would get rebuilt from
70:16 - scratch
70:17 - by providing the key it means the
70:19 - different item changes this is not
70:22 - necessary and instead the list can be
70:25 - recalculated
70:26 - and as such that this can be updated
70:29 - rather than rebuilt
70:32 - the requirements for the key are that it
70:35 - must be a string and each element must
70:38 - have its own unique ID
70:41 - we can either add a key to each element
70:43 - in our data
70:45 - or we can use key extractor to add the
70:48 - key for us
70:50 - in our data we could go ahead and add
70:52 - keys to each item
70:54 - but because each item has its own DT
70:56 - text key and value which because it's
70:59 - based on a timestamp is unique for each
71:01 - item we're going to use that for the key
71:05 - so let's start by adding the key
71:06 - extractor to the flat list
71:10 - so all we have to do inside curly braces
71:12 - now is say item
71:16 - Arrow
71:17 - and item.dt text
71:23 - as a side note if you ever see this
71:26 - warning then it's essentially telling
71:28 - you that this is what you need to do to
71:29 - fix it
71:32 - before we move on to making our list
71:34 - look a bit better let's just have a
71:36 - quick look at some of the other props
71:37 - which are available to us to use on the
71:39 - list if we wanted
71:42 - so we have item separator component
71:44 - which is something that gets rendered
71:46 - between each item in the list this would
71:49 - be good for visual purposes if you
71:50 - wanted to add something that distinctly
71:53 - separates each item in the list
71:55 - let's try it out
71:58 - so I type item
72:01 - separator
72:03 - component
72:10 - an equal sign
72:13 - and then I'm going to add an inline
72:15 - function
72:18 - I'll add a view
72:23 - and now I'll add some Styles here
72:26 - so I say background color
72:33 - red
72:36 - and height
72:39 - two
72:41 - so now in the list I can see this is
72:44 - rendered between each item
72:47 - let's refresh the screen
72:51 - list empty component is another useful
72:54 - prop to know about
72:55 - it means that if the list is empty it
72:58 - will automatically display some other
73:00 - content to the user which is a great
73:03 - consideration if you are depending on
73:05 - data fetching
73:07 - so I start by creating a component
73:09 - called empty
73:21 - I'll give this a view
73:33 - and I'll add some text
73:40 - and for the text I'll just say empty
73:43 - now in the list I Define the list empty
73:46 - component prop
73:50 - and I pass in my empty component
73:55 - so now if I update the data array so
73:58 - it's empty
73:59 - we get to see this in action
74:03 - and I see the empty component instead
74:05 - displayed on the screen
74:07 - there's also a list header and list
74:09 - footer which means we could display
74:10 - either a header or footer in our list
74:14 - there's obviously a lot you can do with
74:15 - your lists and it's good to spend some
74:17 - time getting familiar with the
74:19 - documentation here and playing about
74:20 - with everything
74:22 - the main things you must remember though
74:24 - are that you need to provide the render
74:26 - item and data to the flat list and you
74:29 - need to provide a key of some sort to
74:31 - the data
74:32 - you don't need to worry too deeply about
74:34 - performance especially if you aren't
74:36 - working with a very large list because
74:38 - flat list only gets re-rendered if the
74:40 - data changes and only renders the items
74:42 - currently displaying on the screen not
74:44 - everything at once
74:46 - but as you start to build bigger and
74:48 - bigger lists it's important to have
74:50 - performance at the back of your mind
74:51 - when you're building out the list
74:55 - so let's go back to our code and see
74:57 - what we can do to make everything a bit
74:59 - more visually pleasing
75:01 - the first thing you may have noticed
75:03 - when we check the simulator was that you
75:05 - could not see the icon
75:08 - the reason for this is that the icon
75:10 - color is white and we have not added any
75:12 - background color to our screen
75:14 - so this is currently defaulting as white
75:16 - 2.
75:18 - so let's start by updating the style
75:20 - attributes in our container
75:22 - I'm going to start by importing status
75:24 - bar to our react native Imports
75:34 - and inside the style sheet I'll add
75:36 - margin top
75:40 - and I'll set this equal to status bar
75:44 - Dot
75:47 - current height
75:51 - or
75:53 - zero
75:57 - this is basically a constant from the
75:59 - status bar component which means we're
76:01 - taking into account both platforms and
76:04 - saying to initialize with the current
76:05 - height of the status bar for Android or
76:08 - use xero
76:10 - next I'm going to set a background color
76:15 - to red
76:19 - now I'm going to set the view of the
76:21 - item
76:23 - to be Style
76:26 - equals
76:28 - styles
76:30 - Dot
76:32 - item
76:34 - I'll add this to the style sheet
76:37 - I'm going to set padding
76:40 - to be 20.
76:44 - margin vertical
76:47 - to be eight margin horizontal
76:52 - to be 16.
76:56 - I'm going to set a flex Direction
76:59 - of rho
77:02 - and justify content
77:05 - to be spaced around
77:09 - this is so the items in the row are
77:12 - evenly distributed
77:14 - I'll set align items
77:18 - to be Center
77:22 - border width
77:25 - to be five
77:29 - and also a background color
77:32 - to be pink
77:37 - next I'm going to set Style
77:40 - equals
77:42 - styles
77:44 - Dot
77:45 - temp
77:48 - on both the min
77:49 - and Max temperatures I'll add this to
77:53 - the style sheet
77:57 - I'll give this a color
78:01 - of white
78:05 - and a font size of 20.
78:14 - lastly our set Style
78:17 - equals
78:19 - styles
78:20 - Dot
78:21 - date
78:23 - onto the DT text
78:25 - and in the style sheet we'll add this
78:29 - we'll set color
78:34 - to be white
78:37 - and font size
78:40 - to be 15.
78:46 - let's save this and view it in the
78:48 - simulator
78:53 - we can now see everything and the list
78:55 - items are much more distinct we
78:57 - obviously have some way to go with this
78:59 - still but it's a good start
79:01 - the next two things that we're going to
79:03 - do are add an image to this component
79:06 - which will let us discuss how to use
79:08 - images in react native and then distract
79:10 - out the item component into its own
79:12 - component which will let us do a bit of
79:14 - refactoring and also talk a bit more
79:16 - deeply about props in react native but
79:19 - let's start by looking at how we go
79:20 - about using images in react native
79:23 - so in react native we have a few
79:26 - different options available for when it
79:28 - comes to working with images for example
79:31 - local or network images
79:34 - on the example on the react native
79:36 - website we can see both of these
79:38 - approaches in action
79:42 - so we can see the image core component
79:45 - imported and then used
79:48 - we can see that a source prop is set in
79:50 - the first image so this differs slightly
79:53 - from the web where you may use SRC and
79:56 - now we have the full word source
79:59 - a require statement is then placed
80:01 - followed by the path to the image
80:05 - the other way to load the image is by
80:07 - using a network image and this means we
80:10 - load the image from a URL instead
80:13 - this is more standard practice when
80:15 - you're working with API requests
80:17 - so we can see here we use the source
80:20 - prop again but this time we pass in an
80:22 - object with a URI key and the URL is set
80:26 - as the value
80:29 - there are a few other caveats worth
80:30 - pointing out when you're working with
80:32 - images
80:33 - if you're using a network image you need
80:36 - to explicitly State a height for the
80:37 - image
80:39 - you should also be aware of the
80:40 - supported types of images in react
80:42 - native
80:45 - additionally when you're sizing the
80:47 - images in general you can give the image
80:49 - a fixed height and width or you can use
80:52 - aspect ratio with height and or the
80:55 - width to size the image
80:57 - lastly it's worth being mindful of image
81:00 - storage sizes when you're using static
81:03 - images so not the network images
81:05 - as these will get bundled when you ship
81:07 - your application and if you have a lot
81:09 - of images that you can start to eat up
81:11 - memory
81:14 - if you've seen file names with 2X and 3X
81:16 - for images it's because it's standard
81:19 - practice to provide the same image in
81:21 - three sizes in order to account for the
81:23 - different screen resolutions
81:25 - so we're going to get an image to use
81:27 - for our app from website which provides
81:30 - royalty-free stock images it's called
81:32 - pixabay
81:36 - if you navigate to the pixabay website
81:38 - and then search for clouds
81:40 - whilst you're welcome to use any of
81:42 - these images I'm going to use this one
81:44 - here
81:46 - so I'll select the image
81:49 - and then I'll select to download the
81:51 - image
82:01 - back in our app I store the image in the
82:04 - assets directory which is where we store
82:06 - static content
82:10 - so we could actually add another folder
82:12 - here for the images but I'm just going
82:14 - to add it straight into the directory
82:20 - so now we are ready to use the image at
82:22 - our upcoming weather component
82:25 - we need to start by importing the core
82:27 - image component inside of our react
82:30 - native Imports
82:33 - now inside the render under the text I'm
82:36 - going to add the image
82:38 - so I add image
82:40 - and the self-closing tags
82:46 - I then type source
82:49 - an equal sign
82:52 - and some curly braces
82:56 - inside the curly braces I say require
83:02 - and a set of parentheses
83:06 - and then I type the path to the image
83:18 - I'm also going to set some Styles so I
83:21 - say Style
83:24 - equals
83:26 - styles
83:28 - Dot
83:30 - image
83:31 - I then set this inside of the style
83:33 - sheet so I say image here too
83:36 - I'll give this a height of 100 and a
83:40 - width
83:41 - of also 100. let's save this and view it
83:44 - in the simulator
83:48 - so we can see our image has rendered
83:50 - successfully
83:52 - the problem with this approach for us is
83:54 - that we're going to want to display the
83:55 - image as the background to the screen
83:58 - and we can't give children to the image
84:00 - component
84:02 - in cases like this there is another core
84:04 - component that we can use instead and
84:07 - this is called image background
84:11 - image background works much like image
84:14 - as the documentation here says you can
84:16 - add whatever children to it that you
84:18 - would like to layer on top of it
84:20 - that's the perfect behavior that we're
84:22 - looking for
84:23 - so let's go back to our code and we'll
84:25 - add in image background
84:29 - so back in our upcoming weather
84:31 - component let's change the import from
84:34 - image to the image background
84:44 - now inside the safe area view just
84:46 - before the text let's move our image
84:49 - here
84:50 - and we'll change it to be image
84:52 - background
85:10 - because this is now going to accept
85:11 - children we want to change it not to use
85:14 - self-closing tags
85:17 - so we'll add a closing tag before the
85:19 - closing tag of the safe area View
85:25 - we're also going to change the styles to
85:28 - use flex of one
85:37 - lastly let's also change the background
85:40 - color in the safe area view to be
85:42 - something that blends in better with our
85:43 - image
85:45 - so we'll use royal blue here
85:50 - as a side note you can see all the
85:52 - colors available to use with react
85:53 - native here
85:57 - so we can see now we have our image
85:59 - background applied and our safe area
86:01 - view Blends in with the image much
86:03 - better
86:05 - so earlier in the course I mentioned we
86:07 - would take some time to understand what
86:09 - props are in react native
86:11 - if you've worked with react before then
86:14 - they're the same in react native
86:16 - for those of you who are new to react
86:18 - and react native it's important to
86:20 - understand props as they are a key
86:22 - feature of react native
86:25 - so what are props
86:28 - the term prop is just short for property
86:32 - so when you create an object in
86:34 - JavaScript you add properties to the
86:36 - object and you give the properties a
86:39 - value
86:40 - so for example if you created a dog
86:42 - object as dogs have legs then legs could
86:46 - be added to the dog object as a property
86:48 - and then given a value which most of the
86:51 - time would probably be for
86:54 - in react native we can think of props in
86:57 - a similar fashion
86:58 - they adjust properties which are given a
87:00 - value of some sort
87:02 - but they're used as way to pass our data
87:05 - down from the parent to a child
87:08 - so to visualize this a bit more clearly
87:10 - imagine we had a house component
87:13 - and this would be the parent
87:15 - we want the house component to render a
87:18 - room component
87:19 - this will be our child
87:21 - and we want this to render four times
87:23 - because our house is going to have four
87:25 - rooms
87:28 - when the room component gets rendered we
87:30 - want to be able to pass down the name of
87:32 - the person whose room it is
87:34 - so to implement this we would have the
87:36 - house component and every time you
87:38 - render the room
87:40 - we would set a room owner as a prop
87:44 - inside of the room component we would be
87:47 - able to access the Ramona prop and use
87:49 - this in some way
87:51 - so for example we could set a piece of
87:53 - text which would display the value of
87:54 - the Ramona
87:56 - so instead of creating four separate
87:58 - room components we just have the one and
88:02 - each time it's customized to our
88:03 - requirements
88:06 - so now hopefully we better understand
88:07 - that we can use props to customize our
88:09 - components
88:11 - when we added the image background core
88:13 - component to our upcoming weather
88:14 - component we used a prop called Source
88:17 - in order to set the image
88:19 - which would be displayed to the user
88:22 - core components inside react native
88:24 - usually come with props which can be
88:26 - used
88:27 - if I take a look at the text core
88:29 - component I can see the list of props
88:32 - available to us
88:33 - so for example I could set the Ellipsis
88:35 - mode or disabled
88:38 - the same was true when we worked with
88:40 - flat list and we had to set the data and
88:42 - render item props
88:45 - just like with the core components in
88:46 - react native we can use props in our own
88:49 - components and by doing so we can
88:52 - customize a component
88:53 - but it also means that we're able to
88:55 - make the component more reusable and
88:57 - component reusability is a key concept
88:59 - when you're working with react or react
89:01 - native
89:03 - so back in our app let's look at a
89:05 - little demo of this in action
89:07 - we won't use this in our final code but
89:10 - I'm going to create a file called our
89:12 - child
89:13 - dot Js
89:19 - we'll set this up like a basic component
89:22 - so I start by importing react
89:25 - from react
89:27 - I'll then import View
89:31 - and text
89:34 - from react native
89:48 - once the component is set up and
89:50 - exported I'll say return and then I'm
89:52 - going to use a set of parentheses I'll
89:54 - then render a view and also some text
90:00 - I'm going to use inline Styles here as
90:02 - this is just a demo so I'll give this a
90:04 - height
90:06 - of 200.
90:11 - and a width
90:13 - of also 200.
90:17 - and I'll also set a background color
90:20 - of red
90:24 - inside the text I'm going to want to set
90:27 - some text to display
90:30 - so this is where we're going to display
90:31 - a prop the prop will be sent down from
90:34 - the parent
90:35 - which in our case for this example will
90:37 - be the app.js file
90:41 - the name of the prop
90:43 - will be message
90:45 - so to display the value of the prop we
90:47 - need to use curly braces
90:50 - so I typed the curly braces
90:52 - and then the prop name which is message
90:57 - we also need to set the prop as an
90:59 - argument into the component itself and
91:01 - we do this inside of curly braces here
91:07 - alternatively we can just say props here
91:09 - and then destructure the value
91:13 - so now let's go back to our app.js file
91:17 - and here we can render the archile
91:19 - component
91:21 - for this example I'm going to remove the
91:23 - upcoming weather component temporarily
91:27 - so we need to start by importing the r
91:30 - child component
91:35 - and then we're going to want to use this
91:36 - three times
91:44 - each time we want to use a different
91:46 - value for the message prop
91:48 - so we start by adding the prop
91:51 - and then we use an equal sign
91:54 - and some curly braces
91:58 - inside the curly braces we can set the
92:00 - value
92:03 - the first one will say hello
92:07 - the second one will say greetings
92:10 - and the third one will say goodbye
92:23 - let's save this and view it in the
92:25 - simulator
92:28 - when the app runs we can see our child
92:30 - component is rendered three times
92:33 - and each time through the use of props
92:36 - the message is displayed with its
92:38 - different values
92:40 - before we review what we've just learned
92:42 - let's revert the app.js file back to
92:44 - what we need for our app
92:47 - so we'll delete the references to the r
92:49 - child component
92:53 - we will also put back the upcoming
92:55 - weather component
93:01 - lastly let's go ahead and delete the r
93:03 - child component
93:05 - just before I do this I want to point
93:07 - out one other thing with regards to file
93:09 - and folder structure
93:10 - we'll come back to this later but it's
93:13 - better practice once you start using
93:14 - components to have a directory structure
93:17 - where you have a folder for your screens
93:19 - in the app
93:20 - and then a component folder where you
93:22 - store your components
93:24 - so the screens are like the screen as
93:25 - the user will visually see so for
93:28 - example upcoming weather would be a
93:30 - screen
93:31 - but then we have a component folder
93:32 - where you store your components which
93:35 - are reusable components and the code for
93:37 - things like UI such as buttons and
93:39 - perhaps alerts or Footers
93:44 - so now let's delete the r child
93:46 - component
93:51 - before we move on let's just recap what
93:53 - we've just looked at
93:55 - we have just looked at what props are
93:57 - and how they let you pass in data from a
93:59 - parent to a child in order to promote
94:01 - component reuse in react native
94:05 - we've also looked at props with core
94:07 - react native components and also with
94:09 - custom components
94:11 - there are a few more points to consider
94:13 - when you're working with props and these
94:15 - are really really important to have at
94:17 - the back of your mind firstly props are
94:20 - immutable
94:21 - this means that they can't be changed
94:23 - once the component is created
94:26 - we pass the props from the parent to the
94:28 - child as we've just discussed
94:31 - we use unidirectional data flow when
94:34 - we're working with react and react
94:35 - native
94:36 - essentially this means that data is only
94:39 - able to move in one direction from the
94:41 - parent to the child
94:43 - the outcome of this is that our lives
94:46 - are much easier
94:48 - imagine if you're driving on a road
94:51 - and cars could drive in both directions
94:55 - you'd have a collision pretty quickly
94:59 - this would be the same scenario with our
95:01 - data so unidirectional data flow keeps
95:04 - things straightforward
95:07 - so now we are all much more familiar
95:10 - with how props work and we should
95:13 - hopefully now be becoming more familiar
95:14 - with react native itself
95:16 - let's take a bit of a pause and do some
95:18 - refactoring to the current state of our
95:20 - application
95:22 - in the last section I mentioned that one
95:25 - approach to structuring code is to split
95:27 - the code into components and screens
95:31 - and then I discussed the benefits around
95:32 - doing this as you start to use more
95:34 - components within your screens
95:38 - in this section we're going to do this
95:41 - then we're going to move the item
95:43 - component for the upcoming weather flat
95:46 - list into its own file inside the
95:48 - components directory
95:52 - we'll also do some other General
95:54 - refactoring so our code is a bit easier
95:56 - to work with moving forwards
95:58 - so to start
96:00 - in our SRC directory
96:02 - let's create another directory called
96:05 - screens
96:15 - now let's move the current weather
96:18 - and the upcoming weather components into
96:21 - this directory
96:27 - these components are core screens for
96:29 - our application so it makes sense this
96:32 - is where they are stored
96:34 - now we need to go through these files
96:37 - and check there are no Imports we need
96:39 - to update
96:43 - and then we also need to check the same
96:45 - thing in the other place these files are
96:47 - used which is in the app.js file
96:53 - it's important to follow this process
96:54 - every time you extract some code
96:56 - otherwise when you run the app you'll
96:58 - run into errors so let's try running the
97:00 - app in the simulator now to check that
97:02 - nothing has broken
97:04 - great
97:05 - everything looks okay
97:08 - the next thing we're going to want to do
97:09 - is to create a file for the item
97:11 - component which is rendered by our flat
97:14 - list inside the upcoming weather screen
97:18 - so inside of the components directory
97:20 - I'm going to create a file
97:22 - and for the sake of being a bit more
97:24 - descriptive I'm going to call this list
97:26 - item
97:30 - next I'll copy and paste the code from
97:34 - the upcoming weather component
97:38 - into the list item component
97:44 - I'll also need to update the Imports so
97:48 - I say import
97:51 - react
97:53 - from
97:55 - react
97:57 - and then I'll also import
98:00 - View
98:02 - and text
98:04 - from react native
98:10 - additionally I need to import feather
98:14 - inside curly braces
98:17 - from at Expo
98:19 - slash
98:21 - Vector icons
98:27 - then we also need to make sure the
98:28 - component is exported so it can be used
98:30 - within the upcoming weather screen
98:33 - so I say export
98:35 - default
98:37 - list item
98:43 - the next thing we need to do is import
98:45 - stylesheet into our react native Imports
98:52 - and then we need to set up the styles
98:55 - so before the component is exported I
98:58 - say const
99:01 - styles
99:04 - equals
99:07 - stylesheet
99:09 - Dot
99:10 - create
99:13 - then I need to use a set of parentheses
99:17 - and a set of curly braces
99:21 - so we're going to need to bring the
99:22 - Styles over from the upcoming weather
99:24 - component but obviously we only need to
99:26 - use the relevant Styles here
99:28 - so I'll need the item date and temp
99:32 - styles
99:34 - I'll grab these now
99:41 - and then I can also delete these in the
99:43 - upcoming weather component
99:47 - additionally I can now delete item in
99:50 - the upcoming weather component
99:55 - and then I need to change the render
99:56 - item to return the list item component
99:59 - as opposed to item
100:05 - we're already setting the props for the
100:07 - component here but let's check this is
100:09 - all properly set up in our list item
100:11 - component too
100:15 - everything looks good
100:17 - I see prop set as the parameter
100:20 - and we already have the destructuring
100:22 - for the props in place
100:26 - so now the last thing I need to do is
100:28 - import list item into the upcoming
100:30 - weather component
100:32 - so I say import
100:35 - list item
100:39 - from
100:41 - and then I add the path which is
100:43 - components
100:45 - slash list item
100:50 - I'll also remove the view from the react
100:52 - native Imports here as this is no longer
100:54 - needed
100:57 - for the sake of making our code as clean
100:59 - as possible we can also destructure our
101:01 - styles
101:02 - so before the return
101:05 - I say const
101:08 - then I use a set of curly braces
101:11 - and then I say equals
101:14 - styles
101:17 - inside the curly braces I'll Place
101:19 - container
101:21 - and image
101:25 - inside the render I can then remove the
101:27 - Styles and the dot for these attributes
101:32 - I'll do the same in the list item
101:34 - component
101:37 - so before the return I say const
101:41 - I use a set of curly braces
101:44 - and say equals
101:47 - styles
101:50 - inside the curly braces I place item
101:57 - date
102:00 - and temp
102:03 - inside the return I can then remove the
102:05 - Styles and the dot for these attributes
102:15 - let's save this and check everything has
102:17 - worked in the simulator
102:21 - so visually nothing has changed but
102:24 - we're now using the list item component
102:26 - from inside of its own file when we use
102:28 - render item inside the flat list
102:32 - before we move on to looking at how to
102:34 - wire up our screens with navigation
102:36 - there is one other screen we're going to
102:38 - implement
102:39 - this screen will show some details about
102:42 - the current weather location
102:44 - so let's set up the boilerplate for this
102:46 - screen now and then we'll look at what
102:48 - will be shown on the screen
102:50 - this component will be called City
102:54 - so inside of our screens directory we
102:56 - can create a new file and call it City
103:01 - dot Js
103:05 - inside the file we do our standard setup
103:08 - so we import
103:11 - react
103:13 - from
103:14 - react
103:17 - and then we'll import safe area View
103:22 - text
103:24 - and style sheet
103:27 - from react native
103:30 - then we'll set up our component
103:33 - so I say const
103:36 - City
103:38 - equals
103:42 - then I use a set of parentheses
103:45 - an arrow
103:47 - and some curly braces
103:51 - next I'll export the component
103:54 - so at the bottom of the file I say
103:56 - export
103:57 - default
103:59 - City
104:01 - inside of the curly braces
104:04 - I say return
104:06 - and then use some parentheses
104:10 - for now I'll just add the safe area View
104:17 - and inside this some text
104:22 - fill the text
104:24 - for now we'll just say City
104:28 - let's add some basic Styles here to get
104:30 - this set up
104:32 - so before the component is exported I'll
104:34 - say const
104:37 - styles
104:39 - equals
104:42 - style sheet
104:45 - Dot
104:46 - create
104:50 - I'll then add a set of parentheses
104:54 - and some curly braces
104:59 - next I'm going to add an attribute
105:01 - called container
105:06 - and I'll give this Flex of one
105:10 - lastly I'll add this to the safe area
105:13 - view so I say Style
105:16 - equals
105:18 - and some curly braces
105:21 - and then I just add styles
105:23 - Dot
105:25 - container
105:27 - now let's add this screen to our app.js
105:30 - file to check everything is rendering
105:32 - correctly
105:34 - so back in our app.js file I start by
105:36 - adding the import
105:41 - and then for now I'll remove upcoming
105:43 - weather
105:44 - and change this to show the city screen
105:47 - instead
105:49 - let's save this and check the simulator
105:54 - on the simulator now we can see that our
105:56 - new screen is rendering correctly
105:59 - so what do we want this screen to do
106:03 - well the city screen will be quite a
106:05 - simple screen
106:07 - it'll have an image background which
106:09 - will be City related
106:11 - and then it will show the name and the
106:13 - country of the city
106:16 - it will show the population of the city
106:19 - and also the time that the sun rises and
106:21 - the sun sets
106:25 - let's start by finding the image which
106:27 - we'll use for the screen's background
106:28 - image
106:33 - and then search for City
106:36 - just like with the upcoming weather
106:38 - screen you can use any image you want
106:40 - here but I'm going to use this one here
106:44 - so I'll select the image
106:48 - and then select to download the image
106:58 - once the image is downloaded I'll move
107:00 - it into my assets directory for
107:03 - Simplicity I'll also rename this to city
107:05 - background
107:15 - now let's go back to our city component
107:18 - we're going to start by adding image
107:20 - background to our react native Imports
107:27 - then inside the save area view let's
107:30 - remove the text
107:34 - we'll then need to add image background
107:40 - we know for the image background we need
107:42 - to add the source prop
107:44 - so let's do that now
107:48 - we say source
107:50 - equals
107:53 - and then some curly braces
107:57 - inside of the curly braces we say
107:59 - require and then add the path to our
108:02 - image
108:09 - we also know that we're probably going
108:11 - to want to add some styles for this so
108:13 - let's do that now too
108:16 - we say style equals
108:20 - and then we'll call this image layout
108:23 - so we say Styles dot image layout inside
108:27 - of our style sheet let's also add image
108:30 - layout here
108:32 - and we'll give this Flex
108:34 - of one
108:37 - whilst we're here let's also update the
108:40 - margin top of the status bar for Android
108:42 - just like we did in the upcoming weather
108:44 - component so we say margin top and then
108:47 - we give this the value of status bar dot
108:50 - current height or
108:52 - zero and then we need to add status bar
108:56 - to our react native Imports
108:59 - when we discuss this component I said
109:02 - we'll need the city name and Country
109:04 - and then we'll also add the population
109:06 - and then the sunrise and sunset times
109:09 - so let's start by adding two pieces of
109:11 - text for the city name and Country
109:24 - will hard coding these values for now
109:26 - so for the name I'll say London
109:29 - and for the country
109:31 - I'll say UK
109:36 - let's also add some styles for these
109:41 - for the city name we'll call the
109:43 - attribute city name
109:46 - and for the country
109:48 - we'll call the attribute country name
109:52 - let's add these to our style sheet
109:56 - so for the city name
109:59 - I'm going to say justify content of
110:01 - Center
110:04 - aligned self
110:07 - of Center
110:10 - font size
110:12 - of 40
110:15 - font weight
110:18 - of bold
110:21 - and color
110:23 - of white
110:27 - next with the country name
110:30 - I'll say justify content
110:33 - of Center
110:36 - Airline self
110:39 - of Center
110:41 - font size
110:43 - of 30
110:46 - color
110:48 - of white
110:51 - and font weight
110:53 - of bold
110:56 - before we go any further let's just stop
110:58 - for a moment and take a look at the
111:00 - styles for the city name and country
111:02 - name
111:05 - apart from the font size all these
111:07 - styles are the same
111:09 - we like to try and keep our code as
111:11 - clean and tidy as possible and when we
111:14 - start to see duplication it's a sign
111:16 - that it's possible that we could be
111:17 - doing something a bit better
111:20 - in react native we're able to pass in
111:23 - multiple styles to the style prop by
111:26 - using array notation
111:28 - so if you're working on the web you
111:30 - might use multiple class names
111:32 - but in react native we pass the array of
111:36 - the styles to the style prop
111:38 - and these will get merged into one
111:40 - object
111:42 - if you have any duplication in these
111:44 - Styles it will be the last definition
111:46 - that is used
111:49 - this approach is very useful if we have
111:51 - a theme and then we want to use that
111:53 - theme in multiple places
111:55 - but then we also have some additional
111:56 - unique styles to apply to
111:59 - so in the style sheet I'm going to
112:01 - create a new attribute called City text
112:06 - and I'm going to move everything inside
112:07 - of this
112:10 - I'll then remove font size
112:14 - as this is the value that will be unique
112:16 - for each bit of text
112:22 - inside country name and city name
112:26 - I'll remove everything except the font
112:28 - size
112:35 - now back in the render
112:38 - inside of the style prop for both of
112:40 - these pieces of text we need to add an
112:43 - array
112:49 - inside of the array We'll add City text
112:57 - but then we're also going to make sure
112:58 - that the city name and the country name
113:00 - also remain as this is where the font
113:02 - sizes come from
113:07 - so the next thing we want to add to our
113:08 - screen is the population
113:11 - for this we're going to show an icon of
113:13 - a person and some text
113:16 - because we want to be rendering both of
113:17 - these elements and also that we want
113:19 - them to show on a row we're going to
113:21 - wrap these inside of a container
113:24 - so I'm going to start by adding a view
113:26 - to the react native Imports
113:29 - and whilst I'm here I'm also going to
113:31 - import feather again
113:33 - so I say import
113:36 - then I use curly braces
113:39 - and inside the curly braces
113:42 - I say feather
113:44 - from
113:46 - at Expo slash Vector icons
113:52 - then I'll go back to the render
113:54 - and I'll start by adding The View
113:58 - inside the view I'll add feather
114:01 - and also some text
114:04 - so let's go and look for an icon that we
114:06 - can use with this component on the Expo
114:08 - icon site I'll search for a user icon
114:11 - and then I'll select this one here
114:15 - I can copy the details into the
114:17 - component
114:21 - I'm going to amend the size to be 50.
114:26 - and change the color to be red
114:31 - now in the text
114:32 - let's add another hard-coded value
114:36 - obviously this is way off for the
114:38 - population size for London but I'm just
114:40 - going to say 8 000 for now
114:42 - so to make sure these elements render in
114:44 - a row and to make the text look a bit
114:46 - better let's add some styles
114:49 - I'll set a style for the view called
114:51 - population wrapper
114:57 - and I'll set the style for the text to
114:59 - be population text
115:03 - let's add these to the style sheet
115:06 - so I'll start with population wrapper
115:10 - I'll say Flex direction of row
115:14 - align items of Center
115:17 - justify content of Center
115:21 - and margin top
115:23 - of 30.
115:28 - for the population text I'll say font
115:31 - size
115:32 - of 25.
115:36 - foreign
115:38 - left
115:43 - of seven
115:45 - point five
115:49 - I'll set color
115:51 - to be red
115:55 - and font weight
115:57 - to be bold
116:02 - the last details we need to add to this
116:04 - screen are the sunrise and the sunset
116:06 - again these are going to want to be
116:09 - rendered in a row
116:10 - and I'm going to want to use icons and
116:13 - text for both of these I'll start by
116:15 - adding a view
116:18 - and then I'll add feather
116:20 - and also some text
116:24 - and then I'll repeat this again
116:26 - so I'll add feather
116:29 - and also some text
116:33 - so let's start by going back to the Expo
116:35 - icon site and look for a sunrise icon
116:41 - this one looks perfect so I'll copy the
116:44 - details
116:45 - and I'll add it to the component
116:51 - let's also do the same for sunset
116:54 - so I'll navigate back to the Expo site
116:57 - and our search for sunset
117:01 - and then I can copy and add the details
117:03 - to the component
117:09 - for both icons I'm going to update the
117:11 - size
117:12 - to be 50.
117:16 - and I'll also update the color
117:18 - to be white
117:23 - I'm now just going to hard code in some
117:25 - values for the sunrise and the sunset
117:28 - times
117:30 - for Sunrise I'll say 10 colon
117:34 - 46 colon
117:37 - 58
117:39 - am
117:41 - for the sunset
117:44 - I'll say 17
117:47 - colon
117:50 - 28
117:53 - colon
117:55 - 15.
117:59 - P.M
118:02 - now let's add some Styles here
118:04 - I'm going to add a rise set wrapper
118:07 - to the view container for these elements
118:16 - then I'll add Rye set text both pieces
118:19 - of text
118:33 - let's navigate back to our style sheet
118:35 - and we'll add in these attributes
118:40 - so I'll start with the Rye set wrapper
118:47 - I'll give this a flex direction of row
118:54 - I'll say align items
118:57 - of Center
119:02 - justify content
119:05 - space around
119:07 - and margin top
119:10 - of 30.
119:16 - let's also add the rise set text
119:20 - and this will have a font size
119:22 - of 20.
119:26 - a color
119:28 - of white
119:31 - and a font weight
119:33 - of bold
119:37 - let's save this and see where things are
119:40 - at in the simulator
119:43 - so when our app runs we're now able to
119:45 - see the city screen with the
119:47 - requirements we Define for the screen
119:50 - we have our image background and the
119:53 - city name and location
119:56 - we also have an icon for the population
120:00 - and some text for the population
120:03 - and then we have our sunrise and sunset
120:05 - images and text
120:08 - I keep going on about how we'll shortly
120:10 - look at navigation to wire up our
120:12 - screens and I promise we'll get there
120:13 - shortly I have a few last bits of
120:16 - refactoring I want to do to the current
120:17 - state of our application before we move
120:19 - on
120:21 - so firstly if we navigate back to our
120:24 - city screen and take a look at our
120:26 - component
120:27 - there are three places in the render
120:29 - part of this component where we use a
120:31 - feather icon and then a piece of text
120:35 - this is a great example of when we could
120:37 - extract out something to be a component
120:42 - we don't have any need to be writing
120:44 - this out three times
120:45 - instead we can have a component that
120:47 - renders this and accepts props for the
120:50 - image type and the text which we need to
120:52 - show
120:54 - so let's go ahead and do this now
120:57 - we'll start by creating a file in our
121:00 - components directory called icon text
121:07 - once this is created we can navigate to
121:09 - the component and set up our boilerplate
121:13 - so we say import
121:15 - react
121:18 - from
121:20 - react
121:23 - we know we need to show some text in
121:25 - this component and we also want to wrap
121:27 - this in a view
121:29 - so next let's import View
121:32 - and text
121:34 - from
121:36 - react native
121:40 - we also know this component is going to
121:42 - need some Styles so we can add style
121:43 - sheet to the Imports as well
121:48 - lastly let's add feather from at Expo
121:54 - slash
121:56 - Vector icons
122:00 - now we can Define our component so we
122:03 - say const
122:06 - eye context
122:09 - equals
122:12 - then we have a set of parentheses
122:15 - an arrow
122:17 - and some curly braces
122:21 - outside of this we need to export the
122:23 - component so we say export
122:27 - default
122:28 - icon text
122:34 - let's also set up our Styles before we
122:36 - export the component
122:38 - so we say const
122:41 - styles
122:43 - equals
122:46 - style sheet
122:49 - Dot
122:51 - create
122:55 - we then use some parentheses
122:58 - and some curly braces
123:03 - inside of the component let's say return
123:08 - and we'll add some parentheses
123:14 - next we'll add The View
123:19 - so let's go back to our city component
123:29 - we can copy the first instance of where
123:31 - the feather icon and the text is used
123:33 - together
123:35 - so where feather and text are used
123:37 - inside of the population wrapper
123:39 - I'll copy the icon
123:41 - and also the text
123:45 - next I'll go back to the icon text
123:48 - component
123:49 - and paste this in here
123:56 - so what props are going to need to be
123:57 - defined for this component
124:03 - I know I'm going to need to define the
124:05 - icon name
124:06 - and the color
124:08 - and also the text
124:11 - so we can set these props up now
124:15 - I'll change the name inside the feather
124:17 - element to use curly braces
124:22 - and then I'll pass in icon name
124:28 - I'll do the same with the color
124:34 - and then I'll pass in icon color
124:39 - then in the text also inside curly
124:42 - braces
124:43 - I'll say body
124:44 - text
124:49 - now inside the components parameters
124:51 - let's add props
124:56 - then at the top of the file we can
124:58 - anticipate these and use some
125:00 - destructuring
125:02 - so we'll say const
125:06 - then some curly braces
125:09 - equals
125:12 - props
125:15 - inside of the curly braces
125:18 - I'll add icon name
125:23 - icon color
125:27 - and body text
125:32 - now let's go back to our city component
125:34 - again
125:36 - if we take a look at the styles used for
125:38 - population text and write set text we
125:42 - can see these Styles differ a bit
125:48 - both use a font weight of bold but
125:50 - everything else is different
125:54 - so how are we going to go about handling
125:55 - this
125:56 - we can actually just pass these in as a
125:58 - prop as well
126:01 - so let's start with the commonality and
126:03 - handle the Bold font weight first
126:06 - so back in the icon text component in
126:09 - the text
126:10 - we'll say Style
126:14 - equals
126:17 - styles
126:20 - Dot
126:23 - text theme
126:28 - then inside the style sheet we can add
126:30 - the text theme attribute
126:36 - we'll say font weight
126:39 - of bold
126:43 - now if we go back to our city component
126:45 - we can remove the font weight of bold
126:47 - from the population text
126:50 - and then also the rise set text
126:55 - the remaining styles for these pieces of
126:57 - text will pass down to the child in a
127:00 - prop called body text styles
127:03 - so let's add this prop to the icon text
127:05 - component
127:08 - in the destructuring of the component
127:10 - I'll add body text styles
127:16 - now in the text
127:18 - I'll change the style here to accept an
127:21 - array
127:22 - as we're going to be passing in multiple
127:24 - Styles here
127:27 - inside the array I'll then add body text
127:30 - styles
127:33 - great
127:34 - so now we should all be set up to use
127:36 - this component inside of the city
127:38 - component
127:39 - so let's start by updating the
127:41 - population text section
127:44 - so inside of the view I'll add the icon
127:47 - text component
127:52 - next our set icon name
127:58 - and I'll set this to user
128:03 - then I'll add icon color
128:08 - and set this to red
128:13 - I'll set body text
128:17 - to be eight thousand
128:22 - and then body text styles
128:26 - to be styles
128:28 - Dot
128:30 - population text
128:33 - so now I can delete the feather and text
128:35 - elements here
128:38 - we need to repeat these steps for the
128:40 - sunrise and the sunset
128:42 - so I start by adding the icon text
128:45 - component at the top of the sunrise
128:49 - I set icon name
128:52 - to Sunrise
128:55 - icon color
128:58 - to White
129:02 - and body text
129:05 - to 10.
129:08 - 46.
129:11 - 58
129:13 - am
129:15 - then I'll set the body text styles to be
129:18 - styles
129:20 - Dot
129:22 - write set text
129:27 - so now I can remove the feather and text
129:29 - elements for the sunrise
129:32 - let's do this again for the sunset
129:37 - so I add the icon text component again
129:42 - I set the icon name to Sunset
129:48 - icon color to white
129:53 - and body text to 17.
129:57 - 28
130:01 - 15
130:03 - P.M
130:07 - then I'll set body textiles
130:09 - to be styles
130:12 - Dot
130:14 - rise set text
130:18 - now I can remove the feather and text
130:20 - elements for the sunset again
130:34 - let's save this and see where things are
130:36 - at in the simulator
130:41 - so when the simulator runs the app we
130:43 - see our city screen with the same
130:45 - components as before
130:46 - this time though we have a shared
130:48 - component for the icon and text so we
130:51 - have less duplication in our code
130:53 - it's really good to pay attention to
130:55 - detail when you're working with your
130:56 - code the layout for the text does not
130:58 - look centered under the icon so we
131:01 - should fix that let's go back to our
131:02 - code
131:03 - next
131:05 - let's go back to the icon text component
131:07 - we'll add a style attribute to the view
131:09 - so we can make sure the items contained
131:12 - within the view are aligned correctly so
131:14 - I'll say Style
131:17 - equals
131:20 - styles
131:23 - Dot
131:25 - container
131:28 - then I'll add this to the style sheet
131:34 - inside of the Styles I'll say align
131:36 - items
131:38 - of Center
131:41 - now if I go back to the city screen I'm
131:44 - going to create some shared styles for
131:46 - the population wrapper and the rise set
131:48 - wrapper
131:50 - in the style sheet I'll call this row
131:53 - layout
131:57 - inside of this I'll add Flex Direction
132:01 - of row
132:04 - and align items
132:08 - of Center
132:11 - I'll then remove these from the
132:13 - population wrapper and also the Rye set
132:16 - wrapper
132:22 - next I'll add a raise to both of the
132:25 - style props in the view elements
132:35 - and then I can add in the row layout for
132:38 - these
132:49 - in the inputs of the component let's
132:51 - remove the reference to feather as this
132:53 - is now no longer needed
132:55 - then let's do some destructuring for the
132:57 - styles
132:59 - so before the return in the component
133:01 - I'll say const
133:03 - then I use some curly braces
133:06 - and then I'll say equals
133:09 - styles
133:12 - inside of the curly braces I'll add
133:15 - container city name
133:21 - City text
133:26 - country name
133:31 - population wrapper
133:35 - population text
133:39 - rice set wrapper
133:44 - and Rise set text
133:49 - and then I'll go ahead and remove all
133:51 - the Styles and dots inside the render
133:52 - where these are used
134:34 - so now if we go back to the icon text
134:37 - component I'll also do the same thing
134:39 - here so before the return I'll say const
134:42 - then I'll use some curly braces and then
134:44 - I'll say equals Styles inside the curly
134:48 - braces I'll add container and text theme
134:53 - and then I'll also remove the Styles and
134:55 - the dots where these were used inside of
134:57 - the render
135:05 - so now let's save this and view this
135:07 - again in the simulator
135:11 - everything now looks good
135:14 - so the only screen we haven't yet looked
135:16 - at in terms of refactoring is the
135:18 - current weather screen
135:20 - if we take a look at this component now
135:24 - we can see there's a couple of instances
135:26 - where there's a view which wraps two
135:29 - pieces of text
135:31 - I'm also going to extract these to be
135:34 - their own component
135:35 - and I'm going to call this component row
135:37 - text
135:39 - so inside of the components directory
135:41 - let's start by creating the Rotex
135:44 - component
135:52 - once this is created we can navigate to
135:54 - the component and set up our Imports
135:59 - so I start by saying import
136:02 - react
136:05 - from
136:08 - react
136:10 - this component is going to need to use
136:12 - View and text
136:14 - so I'll say import
136:17 - View
136:18 - [Music]
136:20 - text
136:22 - from react native
136:25 - we're also going to need to add some
136:27 - Styles so I'll add the style sheet
136:29 - inside of the Imports
136:33 - now we can go ahead and Define the
136:35 - component
136:37 - so I say const
136:41 - bro text
136:45 - then I use an equal sign
136:49 - some parentheses
136:53 - an arrow
136:56 - and some curly braces
137:00 - outside of the curly braces I'll say
137:02 - export
137:06 - default
137:10 - bro text
137:15 - before the export I'll also set up the
137:17 - styles
137:18 - so I say const styles
137:22 - equals
137:24 - style sheet
137:27 - Dot
137:28 - create
137:32 - I'll use a set of parentheses
137:34 - and some curly braces
137:38 - now inside of the components curly
137:39 - braces I'll say return
137:43 - and I'll use a set of parentheses
137:47 - let's go back to the current weather and
137:49 - select the first instance of what we
137:50 - want to use in this component
137:53 - so I'll select The View with the high
137:55 - low wrapper and then also the text
137:57 - contained inside of it
138:00 - I'll go back to the Rotex component and
138:02 - I'll paste this in
138:05 - so I know I'm going to need two props
138:07 - for each bit of text
138:09 - so inside the first text
138:11 - I'll remove the text that says hi
138:15 - and then I use curly braces
138:18 - and I'll add a prop called message one
138:23 - inside the second bit of text I'll do
138:25 - the same thing again
138:27 - but this time I call this message too
138:33 - I'm going to want to pass in props for
138:36 - the styles for The View
138:37 - and also for both pieces of text in The
138:39 - View
138:41 - so I'll say Styles equals and then I'll
138:43 - add container styles
138:48 - in the first text I'll say Style
138:53 - equals message one styles
139:01 - and in the second bit of text I'll say
139:03 - Style
139:05 - equals
139:07 - message to styles
139:12 - let's update the component parameters to
139:14 - include props
139:17 - and then we can also add our
139:19 - destructuring to anticipate these props
139:21 - so at the top of the component I say
139:23 - const
139:25 - then I use some curly braces
139:27 - and then I say equals
139:30 - styles
139:33 - inside of the curly braces I'll add
139:35 - message one
139:40 - message to
139:46 - container styles
139:51 - message one styles
139:55 - and message two styles
140:01 - now let's go back to the current weather
140:03 - component and update this to use our
140:05 - Rotex component
140:08 - so I'll start by adding row text just
140:10 - before the view with the Hilo wrapper
140:15 - next I'll set up our props
140:17 - so I'll say message one
140:22 - and I'll set this to high
140:26 - colon
140:28 - 8.
140:31 - next I'll say message two
140:37 - and I'll set this equal to low
140:40 - colon
140:43 - six
140:47 - our set container styles
140:49 - to styles
140:52 - Dot
140:54 - high low wrapper
141:00 - and then I'll set message one styles
141:03 - to styles
141:06 - Dot
141:11 - Hilo
141:15 - and message two styles
141:18 - to styles
141:21 - Dot
141:24 - high low
141:27 - now I can go ahead and delete the
141:30 - existing View and text here
141:34 - next Above The View with the body
141:36 - wrapper I can follow these steps again
141:39 - so I add the row text
141:42 - and then I set up my props
141:46 - so I say message one
141:49 - and set this to it's sunny
141:54 - next
141:55 - I sent message two
141:59 - and I set this to it's
142:02 - perfect
142:04 - t-shirt
142:07 - weather
142:11 - I then set container styles
142:15 - and set this to be styles
142:19 - Dot
142:21 - body wrapper
142:26 - and then I set message one styles
142:29 - to styles
142:31 - Dot
142:34 - description
142:37 - and message two styles
142:40 - to styles
142:42 - Dot
142:44 - message
142:48 - now I can go ahead and delete the
142:49 - existing View and text here too
142:56 - we need to make sure the Rotex component
142:58 - has been imported at the top of the file
143:00 - vs code has done this automatically for
143:03 - me when I started using the component
143:06 - next let's go back to our app.js file
143:10 - and in the render let's update this to
143:12 - show the current weather component now
143:14 - let's run the app in the simulator and
143:16 - see how everything looks
143:18 - when the app runs in the simulator it
143:21 - looks like something's broken
143:23 - debugging errors is a really important
143:25 - process to get to grips with when you're
143:27 - working with your code
143:29 - sometimes it's just figuring out how to
143:31 - approach a problem as opposed to
143:33 - panicking
143:35 - so how do we know what the problem is
143:37 - here
143:39 - well we know the only components we have
143:41 - changed are the city and Road tax
143:43 - components
143:45 - it's the Rotex component which is not
143:47 - showing on our screen so let's take a
143:50 - look at that first
143:52 - the render looks okay
143:55 - but when we destructured our props I set
143:57 - this to Styles not props
144:00 - so this looks like it'll be the cause of
144:01 - our problems here
144:04 - I'll change this from styles to props
144:08 - also we aren't setting anything in our
144:10 - style sheet so let's clean this up too
144:13 - I'll remove the style declaration
144:16 - and I'll also remove stylesheet from the
144:18 - Imports as it turned out we didn't need
144:20 - this after all
144:22 - let's save this and view the app in the
144:24 - simulator
144:25 - everything now looks good
144:28 - let's wrap up our refactoring by just
144:31 - doing one last bit of Cleanup in the
144:33 - current weather component
144:36 - for consistency I'm going to add
144:38 - destructuring to the styles used here
144:40 - so I'll say const
144:44 - then I use some curly braces
144:47 - and then I'll say equals
144:50 - styles
144:58 - inside the curly braces I'll say wrapper
145:00 - container
145:05 - temp
145:10 - fails
145:13 - Hilo wrapper
145:18 - high low
145:21 - body wrapper
145:25 - description
145:29 - and message
145:32 - then I'll go ahead and remove the Styles
145:35 - and dots inside of the render function
146:07 - let's save this and run the app in the
146:10 - simulator again
146:13 - now everything looks good and we have
146:15 - fixed the issue with the row layout not
146:16 - displaying
146:18 - so now we're ready to go ahead and look
146:20 - at wiring up our app with navigation
146:25 - when you're building web apps you can
146:27 - use anchor tags to link between the
146:29 - different pages
146:31 - if a user clicks on a link or a button
146:33 - to navigate to a new page then that URL
146:36 - gets pushed onto a stack which is
146:39 - essentially a data structure and in this
146:42 - case it will be called the browser
146:43 - history stack
146:45 - later when the user wants to navigate
146:47 - back then the URL gets popped off the
146:50 - stack and they're able to go back to the
146:52 - prior page where they'd come from
146:55 - when you use a mobile app it's quite
146:57 - unusual these days that it will only
146:59 - have one screen as they usually have
147:01 - more information to show a user
147:04 - however we can't use navigation in the
147:06 - way that we do on the web so we need
147:08 - some way to navigate between the
147:10 - different screens in our application
147:13 - in our app we have already built three
147:15 - different screens we have a screen to
147:17 - show the current weather
147:19 - a screen to show the upcoming weather
147:22 - and a screen to show the city details
147:25 - in order to navigate between the screens
147:27 - we need to use a navigator
147:31 - you might have noticed this before but
147:33 - the other consideration with navigation
147:35 - is how the navigation between the
147:37 - screens occurs
147:38 - so by this I mean the transition
147:41 - when you click something in an app to
147:43 - load another screen does the next screen
147:45 - then slide in from the right to the left
147:47 - or does it perhaps drop down from the
147:49 - top to the bottom
147:52 - as well as all of this there's then the
147:54 - different types of navigation to
147:55 - consider because perhaps we want to use
147:57 - tabs in the app to let the user navigate
147:59 - around
148:02 - in react native there's no built-in
148:05 - navigation so you have to use a library
148:07 - to add navigation to your app
148:09 - the two most popular libraries are react
148:12 - navigation
148:13 - and react native navigation
148:17 - while both of these libraries have the
148:18 - same end goal the implementation of the
148:21 - two differs
148:24 - the other consideration between the two
148:25 - libraries is that react navigation is
148:28 - built into Expo
148:30 - so if you created your app with Expo you
148:32 - can use it just fine
148:34 - however if you want to use react native
148:36 - navigation you would have to eject your
148:39 - app from Expo
148:40 - or you would have had to create your app
148:42 - without using Expo and I showed you how
148:45 - to do this at the start of the course
148:48 - so in our app we're going to be using
148:50 - react navigation and our goal is to
148:53 - implement tabs for the user to navigate
148:55 - between our different screens
148:58 - so let's start by installing react
149:00 - navigation to do this in the terminal we
149:04 - need to type npm
149:07 - install
149:10 - at
149:12 - react
149:15 - Dash
149:18 - navigation
149:21 - slash
149:23 - native
149:35 - next because we're using Expo we have
149:38 - some additional dependencies we need to
149:40 - install to get everything up and running
149:43 - if you're not using Expo you can see the
149:45 - additional installation steps required
149:47 - to get up and running with react
149:48 - navigation here
149:54 - so for Expo we need to run npx
149:59 - Vo
150:01 - install
150:06 - react
150:09 - Dash
150:10 - native
150:13 - Dash
150:15 - screens
150:18 - react
150:21 - Dash
150:23 - native
150:25 - Dash
150:28 - safe
150:32 - Dash
150:34 - area
150:37 - Dash
150:39 - context
150:49 - so once everything is installed we need
150:51 - to set up a navigation container
150:54 - this will wrap the entire application
150:57 - and usually we'd only do this once in
150:59 - the application and we do it at the root
151:01 - of our project
151:03 - so we're going to add this to the app.js
151:05 - file
151:07 - so
151:08 - we start at the top of the file and we
151:11 - say import
151:15 - next we use curly braces
151:19 - and we need to make sure we use a
151:20 - capital N
151:22 - and we say navigation container
151:27 - and this is imported from at
151:30 - react
151:33 - Dash navigation
151:37 - slash native
151:41 - next inside the render at the top we
151:44 - need to place a navigation container
151:52 - then we close this at the very bottom of
151:55 - the render so that it contains
151:56 - everything
152:03 - at the start of this section I discussed
152:05 - how on the web we push and pop items off
152:08 - of the stack
152:09 - with react navigation we follow a
152:11 - similar idea except that we do this via
152:14 - a navigator
152:15 - so the screens can get pushed and popped
152:18 - off of the Navigator
152:20 - there are two types of Navigators we can
152:22 - use and this depends on our requirements
152:25 - essentially if we don't want the user to
152:28 - navigate to a screen using a tab then
152:30 - probably we'll want to use the stack
152:32 - Navigator
152:33 - so let's look at some examples to show
152:34 - this a bit more clearly if I load this
152:37 - example on snack from the react
152:39 - navigation website
152:41 - I see a settings screen
152:45 - if I click the button that says go to
152:47 - profile
152:49 - and then navigated to the profile screen
152:53 - next
152:55 - if I then click the back icon
152:57 - the profile screen is popped off of the
153:00 - navigation stack
153:02 - and I'm back on the settings screen
153:07 - for this kind of navigation you would
153:08 - want to use a stack Navigator
153:12 - at the bottom of the screen there are
153:14 - also some tabs
153:16 - when I select one of these the screen
153:17 - the user sees changes
153:20 - and this is the behavior I want for our
153:22 - application
153:24 - if you want to explore more deeply all
153:26 - the kinds of navigation available to use
153:28 - with react navigation then you can visit
153:30 - this GitHub repository
153:33 - and then you can navigate to the example
153:35 - section
153:36 - if you load this then you can play about
153:39 - with everything
153:42 - so for our app as I said we want to use
153:44 - tabs to let the user navigate between
153:46 - the different screens
153:48 - it's up to you when you create your app
153:50 - to decide where you want the tabs to
153:52 - show as you can show them on the bottom
153:54 - of the screen or the top of the screen
153:57 - there are some platform considerations
153:59 - to bear in mind here too as often on
154:01 - Android you have tabs at the top of the
154:03 - screen
154:04 - and on iOS you have them at the bottom
154:07 - in our app we're going to display the
154:09 - tabs at the bottom of the screen
154:11 - but if you wanted to show this on the
154:12 - top for Android and the bottom for iOS
154:15 - you would need to set up material top
154:17 - tabs and then decide which to display
154:19 - based on the platform
154:22 - you can access the platform the user is
154:24 - using by using the platform API from
154:27 - react native
154:29 - and then you can use the OS property
154:33 - so back to our tabs
154:36 - we need to start by installing the
154:37 - bottom tabs so we say npm install
154:44 - at react navigation
154:50 - slash
154:52 - bottom tabs
155:03 - once this is done if we go back to our
155:05 - app.js file we can import this
155:09 - so underneath the import for the
155:10 - navigation container we say import
155:15 - then we use curly braces
155:18 - and inside the curly braces we say
155:20 - create bottom tab Navigator
155:26 - and then we say from
155:28 - at react navigation
155:31 - slash bottom tabs
155:36 - next before the component is defined we
155:39 - need to say const
155:41 - then using a capital T
155:44 - we say tab
155:47 - equals
155:49 - and then we say create bottom
155:54 - tab Navigator
155:57 - and follow this with parentheses
156:01 - by doing this we're initializing the tab
156:04 - object so that we can use it
156:08 - next we want to wrap all our components
156:10 - inside of the tab Navigator
156:13 - so inside the navigation container
156:15 - we say tab
156:19 - Dot
156:21 - Navigator
156:26 - and then we close this just before the
156:28 - closing navigation container
156:36 - so next we're ready to go ahead and add
156:38 - our screens
156:41 - so I say tab
156:45 - Dot
156:48 - screen
156:52 - and then I set the component name
156:55 - so I say name
156:59 - equals
157:02 - and as a string I add the component name
157:05 - and so the first one for us will be
157:07 - current
157:12 - and next I add the component
157:15 - so I say component
157:19 - equals
157:22 - and then I set this to current weather
157:28 - then I repeat this again for the other
157:30 - two screens
157:31 - so I say tab
157:35 - Dot
157:38 - screen
157:42 - and then I set the component name which
157:44 - is upcoming
157:48 - and I set the component
157:50 - to upcoming weather
157:55 - lastly
157:57 - I say tab
157:59 - dot screen
158:04 - and this time I set the name to be City
158:11 - and I also set the component to be City
158:25 - so now we should have just set up the
158:27 - three screens for our app
158:29 - let's save this and see what things are
158:32 - looking like in the simulator
158:36 - when the simulator runs the app we see a
158:38 - screen with an error
158:40 - the error says a screen can only contain
158:43 - screen group or react fragment as its
158:48 - direct children
158:50 - so clearly we made an error here
158:53 - the only file we've changed directly is
158:55 - the app.js file so let's go back to that
158:57 - file and take a look
159:01 - so when we set up our tabs we did not
159:03 - remove the view container
159:06 - this is neither a screen group or react
159:09 - fragment
159:10 - so let's remove that
159:14 - I'll remove the view
159:20 - then in order to keep things tidy I'll
159:23 - remove the view from the react native
159:24 - Imports
159:26 - I can also remove the styles that were
159:28 - used for this
159:30 - there are no other styles set now so
159:32 - let's also remove the stylesheet
159:34 - Declaration
159:37 - and then also the import for style sheet
159:42 - let's save this and run the app in the
159:44 - simulator again
159:46 - this time the app loads and I can see
159:49 - the three tabs set up when I click
159:51 - through the tabs I'm able to navigate to
159:53 - the different screens on our app
159:56 - it doesn't look very pretty though so
159:58 - we'll go ahead and start looking at how
159:59 - to make this look a bit better
160:01 - so there's lots of configuration options
160:03 - available to us with react navigation
160:06 - as we can see here in the documentation
160:08 - we can set a tab bar icon
160:12 - if we look a bit more deeply into the
160:14 - documentation you can see there's a
160:16 - wealth of other things available too
160:18 - so we can set labels and positions and
160:21 - so on
160:24 - in our app we already have the name
160:26 - showing on the tabs for the different
160:27 - screens but we're going to customize
160:30 - things a bit further
160:31 - we're going to set an active and an
160:34 - inactive color for the tab bar
160:37 - then we're also going to set icons for
160:39 - each of the tab bar items
160:42 - as we can see in the documentation we
160:45 - set the active and inactive tint colors
160:48 - on the Navigator
160:50 - and then we set the icons in the tab
160:54 - so back in our code in the tab Navigator
160:56 - we're going to say screen options
161:06 - then we'll use an equal sign
161:09 - and some curly braces
161:13 - inside the curly braces we use another
161:16 - set of curly bracers
161:19 - and then we say tab bar active
161:22 - tint color
161:26 - we're going to set this to the string
161:27 - tomato
161:29 - next we'll say tab bar inactive tint
161:34 - color
161:39 - and we'll set this to be Gray
161:55 - for the tab icons we're going to use
161:57 - some icons again from feather and Expo
161:59 - icons
162:00 - so we'll start by importing this at the
162:02 - top of our file
162:04 - we say import
162:08 - then we use some curly braces
162:13 - and inside the curly braces we say
162:16 - feather
162:19 - then we say from at Expo
162:22 - slash Vector icons
162:31 - so to set the Taber icon we can use the
162:34 - tab bar icon property
162:36 - as it says in the documentation we can
162:39 - use it on our screen components in the
162:40 - options prop
162:42 - although for their example they've
162:44 - placed it in the screen options prop of
162:45 - the tab Navigator
162:48 - in our implementation we'll be using it
162:50 - in the screen components options
162:53 - so in the first screen I say options
162:58 - then I use an equal sign
163:01 - and then I use two curly braces
163:05 - next I say tab bar icon
163:11 - and for the parameter I'm going to pass
163:14 - in focused
163:17 - this is because we're going to want to
163:19 - set a different color for the icon
163:20 - depending on whether the tab bar icon is
163:23 - or is not selected
163:26 - next
163:28 - I use an arrow
163:30 - and then some parentheses
163:33 - inside the parentheses I'll render the
163:36 - feather icon
163:37 - so I just say feather
163:41 - I've already selected the icons for the
163:43 - tabs here so I'll say name
163:48 - equals
163:51 - and inside curly braces I'll set this to
163:54 - be droplets
163:59 - our set size
164:02 - to 25
164:06 - and inside color
164:08 - if the icon is focused we want to return
164:10 - tomato
164:15 - otherwise we want to return black
164:28 - now we need to repeat these steps again
164:30 - for our other two screens
164:33 - so in the screen of the upcoming weather
164:34 - I say options
164:37 - then an equal sign
164:40 - and two curly braces
164:45 - next I say tab bar icon
164:50 - and for the parameter I pass in focused
164:55 - then I use an arrow
164:58 - and some parentheses
165:04 - next I set up the feather icon
165:10 - this time for name
165:12 - I set it to be clock
165:18 - I'll set size to 25
165:23 - and for the color
165:27 - I'll say if focused
165:33 - then show tomato
165:37 - otherwise
165:39 - show black
165:43 - then for the city screen we do this
165:45 - again
165:55 - so I say options
165:59 - and I use the two curly braces
166:02 - inside of the curly braces I then set
166:04 - the feather icon up
166:14 - I set name
166:16 - to home
166:20 - size
166:21 - to 25 and for the color I say if it's
166:25 - focused
166:27 - use tomato
166:30 - otherwise
166:32 - use black
166:36 - so now the tab icons and styling should
166:38 - be set up
166:39 - let's save everything and see where
166:41 - things are at in the simulator
167:01 - so back in the simulator we see all of
167:03 - our tabs set up with the tabs and the
167:06 - icons
167:08 - everything should now be running
167:10 - correctly
167:11 - in order to make our code a bit easier
167:13 - to follow I'm going to extract the tabs
167:15 - into their own component and then I'll
167:18 - import this into the app.js file
167:22 - so inside the components directory we'll
167:25 - create a file called tabs.js
167:33 - next back in the app.js component I'm
167:37 - going to copy all the Imports and the
167:39 - initialization of the tabs
167:42 - then I'll paste this into the tabs file
167:48 - now I can go ahead and create the
167:50 - component
167:51 - so I say const tabs
167:55 - equals
167:58 - then a set of parentheses
168:01 - an arrow
168:04 - and some curly braces
168:07 - inside the curly braces I'll say return
168:12 - and I'll use some parentheses
168:15 - outside of the component I'll say export
168:18 - default tabs
168:21 - now I'll go back to the app.js file and
168:25 - I'll copy everything related to the tabs
168:30 - next I'll paste this into the tabs.js
168:32 - file
168:38 - back in the app.js file we can now
168:40 - delete all the code related to the tabs
168:45 - now if I go back to the tabs component
168:49 - I need to update all the Imports for my
168:51 - screens as we're now inside of a
168:53 - directory and not at the root of the
168:54 - project
169:12 - back in the app.js file I can then
169:14 - delete all the Imports which are now not
169:16 - needed
169:26 - lastly in the render I can just pass in
169:29 - the tabs component
169:36 - so now everything's much more readable
169:38 - let's save this and view it in the
169:40 - simulator
169:45 - thing looks good and we see the tabs in
169:47 - the simulator still
169:49 - when I click on a tab it changes color
169:52 - and our tab code is extracted into its
169:54 - own component so everything is nice and
169:56 - tidy
169:58 - if we go back to the code for the tabs
170:00 - component you may see an eslint warning
170:04 - I'm going to just disable this warning
170:05 - for this file as we need to follow the
170:07 - react navigation requirements and set up
170:09 - our tabs in this way
170:12 - so before we move on let's add a few
170:14 - more customization details to our
170:16 - navigation
170:18 - in the header bar I get the same name as
170:20 - I do for the tab name so we don't need
170:22 - to change this but I'm going to set the
170:24 - background color of the tab bar and also
170:27 - the background color of the header bar
170:30 - after that I'll go ahead and add some
170:32 - more styles to the font used in the
170:34 - header bar
170:36 - so in my screen options for the tab
170:38 - Navigator
170:39 - I'll say tab bar Style
170:45 - and then I'll use an object
170:49 - inside of this I'll say background color
170:55 - and I'll set this to light blue
170:59 - this is all one word and all lowercase
171:04 - next I'll set another property called
171:07 - header Style
171:09 - and I'll also use an object here
171:14 - I'll set the background color
171:16 - also to light blue
171:22 - then I'll set a property called header
171:25 - title Style
171:27 - and I'll also use an object for this
171:33 - inside of this object I'll say font
171:35 - weight
171:38 - of bold
171:42 - font size
171:45 - of 25
171:49 - and color
171:51 - to be tomato let's save this and check
171:54 - things out in the simulator
171:57 - so now we can see our tab bar and header
172:00 - bar
172:01 - both have a matching background color
172:04 - the font in the header bar is a bit
172:06 - larger and bolder and the color of the
172:09 - selected tab matches the color of the
172:11 - header bar title
172:13 - there's a ton of customization options
172:15 - available to you with react navigation
172:17 - so I strongly advise you spend some time
172:19 - getting familiar with the documentation
172:22 - you can see a bit more about the header
172:24 - bars here
172:28 - so we're shortly going to move on and
172:30 - look at State and then data fetching in
172:32 - our app
172:33 - after that we'll look at using the real
172:35 - data in our components
172:37 - in order to prepare ourselves for this
172:39 - though there's one more file I'd like to
172:41 - implement
172:43 - in our current weather component we
172:45 - currently have an icon and a message
172:47 - description set for when the weather is
172:49 - sunny
172:51 - in the completed app we're going to show
172:53 - a different icon and a different message
172:55 - based on the weather
172:58 - additionally we're going to change the
173:00 - background color of the screen to
173:02 - represent the different weather
173:04 - we'll base these different states on the
173:06 - weather conditions provided by the open
173:08 - weather map API
173:12 - so we're going to create a file which
173:13 - contains these conditions and then the
173:16 - icons message and background color which
173:19 - should be shown for these conditions
173:24 - so we'll start by creating a directory
173:26 - to store this which will be called
173:27 - utilities
173:29 - so let's do that now
173:31 - in the SRC directory we'll create a new
173:34 - directory called utilities
173:42 - then we'll call the file which will
173:45 - store these properties and values
173:46 - weather type
173:54 - inside the file we need to create an
173:57 - object
173:58 - so we say export const
174:01 - weather type
174:05 - and then we set that equal to an object
174:11 - because of the data provided by the API
174:13 - we need to capitalize the weather types
174:17 - we'll start by creating the objects for
174:19 - each of the weather types
174:21 - the first one is called thunderstorm
174:28 - the next is drizzle
174:35 - then we set rain
174:41 - next we'll set snow
174:47 - then clear
174:52 - clouds
174:56 - Haze
175:00 - and mist
175:06 - so let's start by setting up the
175:08 - thunderstorm type
175:11 - we'll set an icon
175:15 - and give this the value of the string
175:17 - zap
175:21 - next we'll set a message
175:25 - and we'll set this to the string
175:27 - it could
175:30 - get
175:33 - noisy
175:37 - and then we'll set a background color
175:39 - to the black hex color value of zero
175:42 - zero zero
175:44 - zero zero zero
175:47 - note that this is passed in as a string
175:52 - so the next one is drizzle
175:55 - this one will have an icon
175:59 - of cloud
176:02 - Dash
176:04 - brain
176:09 - then for the message we'll say it might
176:15 - rain
176:17 - a little
176:24 - then we set the background color
176:26 - to 364
176:29 - 54
176:31 - f
176:37 - for rain we'll set the icon to Umbrella
176:45 - and then for the message we'll say you
176:47 - will need
176:50 - an umbrella
176:54 - and the background color will be zero
176:57 - zero zero
176:59 - 0 f f
177:03 - for snow we'll set the icon to Cloud
177:09 - Dash
177:11 - snow
177:15 - for the message we'll say let's build
177:21 - a
177:22 - Snowman
177:26 - and the background color will be set to
177:29 - 7 F6
177:32 - zero six five
177:37 - next for Clear we'll set the icon
177:42 - to Sun
177:45 - and we'll set the message to
177:48 - it is
177:51 - perfect
177:53 - t-shirt
177:56 - weather
177:59 - and the background color will be set to
178:01 - e47
178:04 - two
178:05 - zero zero
178:10 - now for clouds we'll set the icon
178:15 - to Cloud
178:20 - we'll set the message
178:24 - to you could
178:29 - live in
178:32 - the clouds
178:36 - and then the background color will be
178:38 - set to 363
178:42 - 636
178:46 - now for haze
178:50 - we'll set the icon
178:54 - to wind
178:58 - and the message will say
179:00 - it might be
179:04 - a bit damp
179:09 - and then for the background color
179:13 - we'll set this to 585
179:18 - 8 6 e
179:23 - and then lastly for mist
179:26 - we'll set the icon
179:29 - to align
179:32 - Dash
179:34 - ify
179:39 - the message will be set to
179:42 - it might
179:45 - be hard
179:48 - to see
179:53 - and then the background color will be
179:55 - set to 3e3
179:59 - e37
180:01 - [Music]
180:04 - right that was a lot of typing
180:07 - but now we can try this out even though
180:09 - we don't have any real data yet being
180:10 - used
180:13 - if we go back to the current weather
180:14 - component we can start by importing this
180:17 - file
180:18 - as we're not importing a component but
180:21 - we're importing an exported object we
180:23 - need to use curly braces
180:25 - so we say import
180:28 - and then we use curly braces
180:33 - inside the curly braces we say weather
180:36 - type
180:40 - and then we import this from utilities
180:46 - weather type
180:50 - so let's test this out on the weather
180:52 - condition message
180:54 - so inside the last row text component
180:57 - inside the message to prop
180:59 - we can just say weather type
181:04 - and then use square brackets
181:09 - and let's try out the message for the
181:10 - Thunder weather condition
181:13 - so as we're using square bracket
181:14 - notation here we pass in the string
181:22 - let's save this and see what things look
181:24 - like in the simulator
181:27 - so now we're going to move on to some of
181:29 - the more deeper topics in react native
181:30 - and we're going to take a step back from
181:32 - our app just for a bit in order to take
181:35 - the time to learn some of the details
181:37 - required to successfully make our app
181:39 - more dynamic
181:41 - Dynamic is the key word here
181:44 - so far in our application everything has
181:47 - been static
181:48 - this means that we have all our screens
181:50 - and all of these are now wired up with
181:52 - navigation
181:54 - but nothing in our app really does
181:55 - anything except display values to the
181:57 - user which we have hard-coded in
181:59 - ourselves
182:01 - if this is all you wanted to do then you
182:03 - only need to use props just like we have
182:06 - and you can pass your data around from
182:08 - parent to child components
182:11 - but isn't the real excitement of making
182:12 - applications these days how interactive
182:15 - we can make them and how fun we can make
182:17 - the experience for the user
182:19 - when was the last time you enjoyed using
182:21 - an application either on the web or on
182:23 - mobile that only functioned in this way
182:27 - with react native and react we're able
182:30 - to make the user experience super
182:31 - interactive and update and respond to
182:34 - users input
182:36 - so given this intention props are only
182:38 - half of the story
182:40 - the other half is state
182:43 - is what I'm going to introduce you to
182:45 - now
182:47 - so what is state
182:50 - to put it simply state is an object and
182:53 - this object contains data about the
182:56 - component that for some reason we decide
182:58 - we need to keep track of within our
183:00 - application
183:01 - in the object we Define key value Pairs
183:04 - and these key value pairs are the way in
183:07 - which we track a single piece of data
183:08 - that over time is going to change
183:11 - let's visualize this a bit more
183:14 - if we go back to the house example from
183:17 - when we looked at props
183:19 - using the props we pass data down to
183:21 - each of the rooms in the house
183:23 - using State though we can be inside a
183:26 - room and keep track of something that is
183:28 - going to change in the room
183:31 - so perhaps we want to keep track of the
183:33 - messy state
183:36 - or maybe we want to keep track of
183:38 - whether the room was dark so we could
183:40 - track the value dark as true or false
183:45 - or maybe we know a massive storm is
183:48 - incoming so we want to keep track of
183:50 - whether or not the room is wet
183:54 - the benefit of state within a react
183:56 - native or react application is that it
183:58 - means things can change
184:00 - they can be added
184:03 - modified
184:05 - and removed
184:07 - and we as the developer can work with
184:09 - this more easily and update our internal
184:12 - data and Trigger UI updates based on
184:14 - these changes
184:16 - there is one very key point to be aware
184:18 - of here though
184:19 - when the data in our component changes
184:21 - the component will re-render
184:25 - so to emphasize this point when a
184:28 - component first renders on the screen to
184:30 - the user we have what is called an
184:32 - initial render
184:34 - if we're using State and some of this
184:37 - state changes
184:38 - then the component will re-render itself
184:43 - so let's look at this through our room
184:44 - example when the storm is possibly
184:46 - incoming
184:48 - our room component renders on the screen
184:50 - when it first loads
184:52 - we have a wet State and this is set to
184:55 - force
184:57 - later the storm happens
185:01 - our room gets flooded
185:03 - this causes the wet state to get set to
185:05 - true
185:07 - consequently the room component then
185:10 - re-renders
185:12 - in the world of coding this sort of
185:14 - change might be more likely to occur
185:15 - based on a user event such as a button
185:18 - press or perhaps some sort of user input
185:20 - such as typing something into an input
185:22 - field
185:24 - it's totally fine if this all seems a
185:26 - bit overwhelming or confusing right now
185:28 - it can be a lot of information to
185:30 - process
185:31 - let's stop for a moment and summarize
185:33 - what we have just learned
185:36 - we have learned the state as an object
185:38 - that is used to keep track of data about
185:40 - a component
185:42 - we've learned that by using State we can
185:45 - add remove or modify things in our
185:48 - component more easily
185:49 - and then we can trigger UI updates based
185:52 - on these changes
185:54 - additionally we've also learned that
185:56 - when State changes it causes the
185:58 - component to re-render
186:02 - so let's just be very clear now on the
186:04 - difference between props and State
186:07 - props let us pass data between the
186:09 - components where a state lets us
186:12 - internally manage the data within a
186:14 - component
186:16 - you therefore can't modify the state of
186:18 - the component outside of the component
186:21 - in this sense it's a bit like when
186:23 - you're working with local scope in
186:24 - JavaScript
186:26 - of course with vanilla JavaScript you
186:28 - can make things Dynamic but the benefit
186:30 - of working with react native and react
186:32 - is that a lot of the hard work is done
186:34 - for you
186:35 - and you just have to provide initial
186:37 - values and then consider how you would
186:39 - like this value to update and then also
186:41 - be displayed to the user
186:44 - if and when your state grows you need
186:46 - this to be at an application Level then
186:48 - you can also access libraries to help
186:50 - you manage this such as Redux
186:53 - but that is out of the scope of this
186:54 - course so we're going to continue our
186:57 - journey with state by creating a simple
186:59 - counter component which won't be in our
187:01 - final app but will hopefully solidify
187:03 - our understanding a bit more here
187:06 - we'll start by creating the component
187:08 - without using state so hopefully we can
187:11 - better see why we need State and then
187:13 - we'll add state to the component
187:16 - so inside the SRC directory I'm going to
187:19 - create a new directory called
187:20 - demonstration
187:22 - you're welcome to keep the code in this
187:23 - directory for reference purposes or
187:26 - delete it in the final project at the
187:27 - end of the course
187:29 - but it saves us from having to create a
187:30 - new app for any demonstration code which
187:32 - we'll make during the rest of the course
187:35 - so in the SRC folder let's create this
187:38 - new folder called demonstration
187:44 - now inside of this folder I'm going to
187:47 - create a component called counter.js
187:54 - we'll set this up just like we have with
187:56 - our other components
187:57 - so we'll start by importing react from
188:00 - react
188:06 - next we'll import View
188:13 - text
188:16 - button
188:20 - and style sheet
188:23 - and we'll import these from react native
188:28 - now let's go ahead and create the
188:29 - component
188:31 - hopefully you're getting used to doing
188:32 - this now
188:33 - but we'll start by saying const
188:37 - counter
188:40 - and we'll follow this by an equal sign
188:44 - some parentheses
188:47 - an arrow
188:50 - and some curly braces
188:54 - outside of the curly braces we'll export
188:56 - the component
188:58 - so we say export default
189:01 - counter
189:03 - inside of the curly braces
189:06 - will say return
189:09 - and we'll use a set of parentheses
189:14 - then before the export we'll create our
189:16 - style sheet so we say const styles
189:21 - equals
189:23 - style sheet dot create
189:29 - and then we use some parentheses
189:31 - and some curly braces
189:36 - so let's set up our component
189:39 - before the return I'm going to create a
189:41 - variable which will store the value of
189:43 - count
189:44 - so I say let count
189:46 - and I set this equal to zero
189:51 - now inside of the return we can create a
189:53 - view
189:57 - then we'll also create some text
190:03 - inside of the text we're going to use a
190:05 - template literal and interpolate in the
190:07 - count value
190:08 - so we use curly braces
190:12 - and then some backticks
190:14 - we say count
190:16 - and a colon
190:18 - then we pass in the count variable
190:21 - next we'll add two buttons
190:30 - for the first button
190:32 - will set color
190:35 - to red
190:38 - for the title
190:40 - will say increase the count
190:46 - and then we set on press
190:50 - for this we use an array function so we
190:53 - use some parentheses
190:55 - and an arrow
190:57 - for the first one I'm actually going to
190:59 - use curly braces because there's a
191:01 - little bit more I want to do here
191:03 - so firstly I'll increment the count
191:06 - so I say count plus plus
191:10 - and then I also want to add a console
191:11 - log to print out the value of the count
191:13 - variable
191:20 - for the second button we'll set the
191:23 - color to Green
191:28 - for the title we'll say decrease the
191:30 - count
191:35 - and for onpress I'll just pass in an
191:37 - arrow function
191:38 - which will decrement the count
191:44 - let's add a couple of styles
191:47 - on The View we'll set a container so I
191:50 - say style equals Styles Dot
191:55 - container
191:58 - and for the text I'll set some Styles
192:00 - called title
192:02 - so I say styles
192:04 - equals
192:06 - styles
192:08 - Dot
192:10 - title
192:13 - in the style sheet I'll set the
192:15 - container
192:16 - I'll give this Flex of one
192:21 - and background color
192:23 - of Orange
192:25 - next I'll set the title
192:29 - I'll give this a line south of Center
192:33 - and font size of 25.
192:38 - and then I'm going to set a margin top
192:41 - of 25.
192:46 - we also need to be able to see this
192:48 - component on the screen of our app
192:51 - so let's go back to our app.js file
192:56 - I'm going to start by importing the
192:58 - counter
193:00 - and I'll do this from dot slash
193:03 - SRC
193:05 - slash demonstration
193:08 - slash
193:10 - counter
193:13 - temporarily I'm going to remove the tabs
193:15 - from the render in the component and
193:17 - replace this with the counter
193:22 - now let's load the simulator
193:27 - we now see our counter component on the
193:29 - screen
193:30 - we see the two buttons
193:32 - and also the text which displays the
193:34 - counter value
193:36 - great
193:39 - so let's now click the button to
193:41 - increment the counter
193:44 - so it looks like the button was pressed
193:46 - successfully but the count value has not
193:48 - updated on the screen
193:51 - let's dig into this bit more and we'll
193:53 - check the Contour log we added
193:57 - so it looks like this did increment
194:01 - I'll press the increase button again
194:05 - we now see two
194:07 - so the counter value is definitely
194:08 - increasing
194:09 - but the text that displays the count on
194:11 - the screen is not showing the correct
194:13 - count
194:16 - so the reason for this is that react
194:18 - does not re-render a component when the
194:20 - value of a variable changes
194:23 - if this happened we would end up with
194:25 - re-renders happening all over the place
194:27 - and it would result in a really bad user
194:29 - experience
194:32 - I mentioned when we looked at state that
194:34 - when we use State and the state changes
194:37 - the component re-renders
194:39 - so this is a great example of a use case
194:42 - for state
194:44 - we'll look more deeply at hooks in a bit
194:46 - but we're going to use a hook provided
194:48 - by react called you state in order to
194:51 - fix our problems here
194:53 - for now you can think of a hook as
194:56 - functions that we can use inside of our
194:58 - function components
195:00 - all of the components we have made
195:02 - throughout this course have been
195:03 - function components
195:06 - so to start off we need to import the
195:08 - use date hook
195:10 - we do this when we import react
195:12 - so in the react import we add a comma
195:18 - and then some curly braces
195:21 - inside of the curly braces we say you
195:24 - state
195:28 - now when any values we use with the
195:31 - u-state hook are updated then react will
195:33 - ensure the component also gets updated
195:35 - to reflect these changes to the user
195:39 - so now we need to update the Declaration
195:41 - for our count variable and use the use
195:44 - State hook instead
195:47 - so let's delete the variable and we'll
195:49 - start again
195:53 - this time we use the hook
195:55 - so we say const
195:59 - and then we use square brackets
196:03 - and we say equals
196:05 - use state
196:11 - inside the square brackets I'll say
196:13 - count
196:17 - and then set count
196:21 - lastly inside the parentheses for the U
196:24 - state
196:25 - I'll set the value 0.
196:29 - so when we use the use date hook we're
196:31 - setting up some piece of State for our
196:33 - component
196:35 - when you state is set up we need to pass
196:37 - in the initial value for what the state
196:40 - should be
196:41 - so if we were implementing the flooded
196:43 - room example here we might have to set
196:45 - this up by saying is flooded
196:48 - and set is flooded
196:50 - and then in the parentheses we would
196:53 - have said false for the initial value
196:57 - we want the counter to start at zero
196:59 - which is why here we're passing in zero
197:01 - we can pass in any of the data types
197:03 - required for our needs though so this
197:05 - could also be a string or an object and
197:07 - so on
197:09 - the square brackets where we have added
197:10 - count and set count are simply using a
197:13 - ready structuring
197:15 - the first value in this is the count and
197:18 - this tracks the value for the count
197:21 - but we never directly change the value
197:23 - of count instead we use set count which
197:26 - is a function
197:27 - and into this we pass what we want the
197:30 - new value for count to be
197:33 - so let's go ahead and update our
197:34 - component to use this
197:37 - in the first button I'm going to remove
197:39 - the console log
197:41 - and also the incrementing of the old
197:43 - count variable
197:46 - then I will say set count
197:49 - and it will pass in count
197:52 - plus one
197:55 - so we aren't modifying count here we're
197:57 - just getting the value of count and then
197:59 - adding one to it
198:06 - in the second button I'll say set count
198:11 - and this time I'll pass in the value of
198:13 - count again
198:15 - and then minus one
198:18 - let's save this and go back to the
198:20 - simulator
198:21 - now let's press the increase button
198:25 - the count displayed on the screen
198:26 - updates to show our new count now let's
198:29 - press the button to decrement the value
198:32 - the value on the screen now decrements
198:36 - so now we have successfully worked with
198:38 - State for the first time
198:40 - let's recap what we have just learned
198:43 - when we want to use you state in a
198:46 - function component we can use a hook
198:48 - called you state
198:50 - we never directly change the value for
198:52 - the state but we can update it buyer a
198:54 - function that enables us to update the
198:57 - state
198:58 - we use array structuring for the u-state
199:01 - hook
199:02 - and inside this we have the value for
199:04 - the state and then the function we use
199:06 - to update the state and inside this we
199:09 - have the value for the state
199:11 - and then also a function that we can use
199:14 - to update the state
199:16 - inside the parentheses a view State we
199:19 - also set the initial or default value
199:21 - for the state
199:24 - before we move on in the last section I
199:27 - introduced you to Hooks and I want to go
199:29 - over these in a bit more detail
199:31 - and then I'm going to move on to showing
199:33 - you another hook which will help us with
199:35 - our data fetching
199:37 - back in the older days of using react
199:39 - and react native in the most part we had
199:43 - two types of components that we could
199:44 - use
199:46 - these were called stateful
199:48 - and state less
199:51 - if we wanted our component to use state
199:53 - in some way we would create a stateful
199:55 - component
199:58 - if we did not need to use state in our
200:00 - component then we could use a stateless
200:02 - component
200:04 - a stateful component was a class and the
200:07 - Syntax for a class component looks like
200:09 - this
200:14 - we can still create class components in
200:16 - react day so they're worth knowing about
200:18 - and you may very well come across an
200:20 - older code that uses them
200:23 - when you use class components you can
200:25 - access what are called lifecycle methods
200:28 - lifecycle methods are essentially events
200:31 - that occur during the life cycle of a
200:33 - component
200:36 - it's a little bit like key events that
200:38 - occur during the life of a human
200:40 - a human gets born
200:42 - they have an annual birthday
200:45 - and later in their life they pass away
200:49 - when a component is created it is
200:52 - mounted and the lifecycle method for
200:54 - this event is called component did Mount
200:58 - when the component updates another
201:01 - lifecycle method is called which is
201:03 - named should component update
201:05 - and this lets you control when the
201:07 - component should re-render
201:10 - just before the component is destroyed
201:12 - another lifecycle method is invoked core
201:14 - component will unmount
201:17 - when you're using a class you can tap
201:19 - into these methods and during these
201:21 - events you can add some additional
201:23 - functionality
201:26 - if you want to read more about lifecycle
201:28 - methods you can find some details here
201:33 - as react has evolved there's been a
201:36 - tendency to move away from using class
201:37 - components
201:39 - and these days function components are
201:41 - favored
201:42 - when components were either stateful or
201:45 - state less this wasn't very practical
201:48 - but in react 16.8 hooks were introduced
201:54 - hooks provide us with a way to use the
201:56 - features we depended on classes for like
201:58 - State and life cycle methods but from
202:01 - inside of our function components
202:05 - you can think of hooks like special
202:07 - functions or pieces of reusable logic
202:10 - which are separate from our component
202:12 - tree
202:13 - but that let us add functionality to our
202:16 - function components
202:19 - when we use hooks we can isolate all the
202:21 - logic from the component in a readable
202:23 - way
202:24 - but we can use them within our component
202:27 - you can read more about hooks here
202:31 - every hook in react starts with the word
202:34 - use
202:35 - and we've just seen an example of this
202:37 - when we looked at the use statehook
202:40 - there are a couple of rules you should
202:41 - be aware of when you're using hooks
202:43 - though
202:44 - firstly you can only call hooks from
202:47 - react functions like our functional
202:50 - components you can't just use them
202:52 - wherever inside normal JavaScript
202:54 - functions
202:56 - additionally hooks must be called at the
202:58 - top level of a component and before the
203:01 - return keyword is used
203:03 - we'll see more about this later but
203:06 - aside from react hooks you can also
203:08 - create your own hooks and these hooks
203:10 - can call other hooks
203:13 - we're going to move on now to
203:14 - introducing ourselves to another Hook
203:16 - from react could use effect
203:19 - after this we'll return back to our app
203:21 - and start looking at data fetching
203:24 - the use effect Hook is extremely
203:26 - powerful
203:27 - but it can also seem quite overwhelming
203:29 - when you're first looking at it
203:32 - if you can understand how to use the use
203:34 - effect hook properly then you can do all
203:36 - sorts of things with your application
203:39 - let's start by looking at the
203:40 - documentation
203:43 - so it says the effect hook lets you
203:45 - perform side effects in function
203:47 - components
203:48 - the example also goes on to state that
203:51 - it's similar to component did Mount and
203:53 - component did update
203:55 - let's break this down a bit
203:58 - to start with what is a side effect
204:02 - well it's when we use something not
204:04 - inside of react within our component so
204:07 - examples of these sorts of things are
204:09 - fetching data using timer functions and
204:12 - updating the Dom directly
204:15 - we also know that component did Mount
204:17 - happens when the component is first
204:18 - mounted
204:20 - and component did update is called after
204:22 - updating occurs
204:24 - so use effect essentially lets us
204:27 - replicate these lifecycle methods and it
204:30 - means we can perform side effects like
204:32 - fetching data
204:34 - from within our function components
204:37 - so let's go ahead and look at the basic
204:39 - Syntax for the use effect hook
204:42 - if we look carefully we can see that use
204:44 - effect takes in a function as an
204:46 - argument
204:48 - and it's inside of this that we can
204:49 - write our side effects
204:52 - let's add the use effect hook to our
204:54 - counter example so we can understand
204:56 - things a bit more deeply
204:59 - so inside the counter component next to
205:02 - the use date import we need to start by
205:04 - also importing use effect
205:11 - next under the u-state hook we can use
205:14 - use effect
205:16 - so we say use effect
205:20 - and then we pass in a function
205:25 - now inside the function let's add a
205:28 - console log for the count
205:32 - so I say Contour log
205:36 - and then inside this I'm going to use
205:37 - backticks
205:40 - and then I'll say our count value is
205:46 - and then I will interpolate in the value
205:48 - of count
205:53 - now let's see this in action in our
205:55 - simulator
205:58 - I'll start by reloading the screen
206:03 - so now in the console log I see the
206:05 - initial value of count printed to the
206:07 - screen
206:09 - every time I click one of the buttons as
206:12 - the component is re-rendering here I see
206:14 - the new value of count printed to the
206:16 - screen too
206:19 - so we could be doing anything in here
206:21 - that we want to happen as soon as the
206:23 - component first renders such as fetching
206:25 - some data
206:27 - right now we're also repeating the code
206:29 - inside of here every time that the
206:31 - component re-renders
206:34 - if we take a look at the react docs
206:36 - again we can see that use effect also
206:38 - takes one other parameter called
206:40 - dependencies
206:41 - which it compares to the lifecycle
206:43 - method component did update
206:47 - it says on the documentation that you
206:49 - can tell it to skip applying an effect
206:51 - if certain values have not changed
206:53 - between renders
206:55 - to do so you pass an array as an
206:57 - optional second argument to use effect
207:01 - so to summarize this a bit inside of
207:03 - this array we pass in all of the values
207:06 - that the side effect inside of use
207:09 - effect relies on
207:13 - in our example we're console logging
207:15 - based on the value of the count
207:18 - so we need to include count inside of
207:20 - the dependencies array
207:22 - this now means that the code inside of
207:25 - use effect will only run if that value
207:27 - has changed between renders
207:30 - if we do not pass in the dependencies
207:32 - array then the code inside of use effect
207:34 - will run after every render
207:38 - let's look at this in our demonstration
207:41 - I'm actually going to add two new
207:43 - buttons to the component
207:45 - I'll just copy and then paste the first
207:47 - two buttons
207:54 - next I'll create another count and set
207:56 - count with a new use date hook
208:00 - I'll call the state variable here new
208:03 - count
208:07 - and then for the function to update the
208:09 - state I'll call it set new count
208:19 - and then I'll update the on press inside
208:21 - of the new buttons to call set new count
208:35 - so now inside of the use effect I'm
208:38 - going to change the console log to just
208:40 - be count changed
208:46 - let's run this in the simulator
208:51 - when the screen loads I get count
208:53 - changed printed to the console every
208:56 - time I press any of the buttons I see
208:58 - the count change console log printed to
209:00 - the screen again so now let's go back to
209:02 - our code and we're going to pass in a
209:04 - dependency array inside of the
209:06 - dependency array I'm going to pass in
209:08 - count now let's run this again in the
209:10 - simulator
209:13 - so I get the console log printed to the
209:16 - console when the screen launches
209:19 - this time though
209:21 - I only see this printed of screen again
209:23 - when I click on any of the first two
209:24 - buttons which use count
209:28 - I don't however see it printed to the
209:30 - screen when I press any of the buttons
209:32 - that use new count
209:34 - so the effect only runs when count
209:36 - changes otherwise it just sits there and
209:39 - it doesn't do anything again
209:42 - the last thing you need to be aware of
209:44 - when you are using use effect relates to
209:47 - the component we'll unmount lifecycle
209:49 - method
209:51 - and it's called the cleanup function
209:54 - this cleanup function allows us to turn
209:56 - off or clean up our side effects
209:59 - so for example if you're using a counter
210:01 - we would need to use the clear interval
210:03 - function to stop the counter and this is
210:05 - where we would place that and by doing
210:07 - so we can avoid memory leaks
210:10 - to use a cleanup function we type return
210:14 - and then we use an arrow function
210:16 - followed by the cleanup we would like to
210:18 - perform
210:19 - we can see an example of this on the
210:21 - react documentation again
210:23 - as the documentation says react performs
210:26 - the cleanup when the component unmounts
210:28 - so we don't really have any cleanup we
210:30 - need to do in our example but I'm going
210:32 - to add a console log here to show how
210:34 - this works
210:36 - so back inside of our code and inside of
210:38 - the use effect
210:39 - I will say return and then I use some
210:42 - parentheses an arrow
210:44 - and some curly braces
210:47 - then I'll just Contour log a string
210:49 - which says use effect
210:52 - clean up
210:55 - let's save this and go back to the
210:57 - simulator
211:03 - now when I click one of the buttons
211:05 - which triggers a re-render I also get
211:07 - the console log for the cleanup log to
211:09 - the screen because the cleanup is called
211:11 - before the next use effect runs
211:14 - so before we move back to our app let's
211:16 - do a bit of recapping about everything
211:17 - we've just learned with use effect
211:20 - we have learned that use effect is a
211:22 - hook provided by react which lets us run
211:24 - code that has side effects
211:27 - we've seen that it takes a function with
211:29 - the code to run
211:31 - then we saw that you can also pass in a
211:33 - dependency array which lets you specify
211:35 - what data when changed that you would
211:38 - like to trigger a re-render
211:41 - lastly we looked at the cleanup function
211:43 - that we can use with use effect to run
211:46 - any cleanup and stop any of the side
211:48 - effects before use effect is called upon
211:50 - a new render and when the component is
211:52 - unmounted
211:53 - so now we have some understanding around
211:55 - Hooks and use State and use effect
211:59 - so we're ready to go back to our app and
212:01 - think about our next steps with our
212:03 - weather application
212:05 - so back in our app we have a few things
212:08 - that we're going to do now in order to
212:10 - make the app dynamic
212:12 - to start off inside the app.js file I'm
212:15 - going to reset the code to use the tabs
212:18 - inside the render
212:24 - and I'm also going to delete the import
212:25 - for the counter
212:29 - I'm going to break down the next steps
212:31 - we need to achieve
212:33 - the first thing we're going to do is
212:35 - Implement a loading state for when the
212:37 - app first launches and the data is being
212:39 - fetched this is so the user sees
212:41 - something during this process
212:44 - it's always good when you're making
212:46 - applications to consider all the various
212:48 - loading and error states that the user
212:49 - might encounter
212:52 - after this we're going to look at
212:54 - fetching the data from the open weather
212:55 - map API and this will be broken down
212:58 - into two parts
213:00 - getting the user's location and then
213:02 - fetching the data
213:04 - so let's start first with the loading
213:06 - state
213:09 - as I mentioned we want to start the app
213:11 - in the loading State until the data from
213:13 - the open weather map API is successfully
213:15 - fetched
213:17 - once it is fetched we'll set the loading
213:20 - state to false and navigate the user
213:22 - onto our weather related components
213:26 - for our loading State we want to display
213:28 - to the user a spinner
213:30 - instead of having to manually create
213:31 - this react native has a core component
213:34 - that does this for us it's called
213:36 - activity indicator
213:38 - let's have a look at the documentation
213:42 - so we can see the activity indicator
213:44 - displays a circular loading indicator to
213:46 - the user and we can customize the size
213:49 - and the color of the spinner
213:52 - on the documentation we can see a few of
213:54 - the activity indicators in action with
213:56 - the different sizes and colors set
214:00 - so let's go back to our app and we'll
214:02 - start to set this up
214:04 - so inside the app.js file we'll start by
214:07 - importing the activity indicator
214:10 - after the react import I'll say import
214:15 - then I'll use some curly braces
214:19 - and inside the curly braces I'll say
214:22 - Activity indicator
214:26 - and I'll import this from react native
214:30 - next in order to set the loading State
214:33 - we're going to use U state
214:35 - so in the react import I add a comma
214:40 - some curly braces
214:43 - and then inside the curly braces I say
214:45 - use state
214:48 - now this is imported we need to set up
214:50 - you state
214:52 - so before the return inside of the ACT
214:54 - component I say const
214:58 - I use some square brackets
215:02 - and then I say you state
215:06 - with some parentheses
215:09 - I'm going to call this piece of State
215:11 - loading
215:12 - so inside the square brackets I'll add
215:14 - loading
215:16 - I'm going to call the function to update
215:18 - the state set loading
215:21 - so I'll add this too
215:25 - then I'm going to set the initial state
215:27 - for our loading State as true
215:30 - this means when the app first launches
215:32 - the user will see the activity indicator
215:34 - then once the data is fetched we can set
215:37 - this to force and then they'll see the
215:39 - weather components
215:41 - so now in the render we need to have a
215:43 - way to say if the state is loading then
215:46 - show the activity indicator otherwise
215:48 - show the tabs
215:51 - there are a few ways we can Implement
215:52 - conditional rendering in react and react
215:54 - native
215:55 - knowing about if else statements ternary
215:58 - operators and also the logical and
216:00 - operator is useful when it comes to
216:02 - handling these scenarios and you can
216:04 - read more about these here
216:07 - in our case for now we're going to keep
216:09 - this very straightforward and just use
216:11 - an if statement which renders the
216:12 - activity indicator when the loading
216:14 - state is true
216:16 - if the loading state is not true then
216:18 - the navigation container and the tabs
216:20 - will be rendered
216:23 - so inside of our app component I'm going
216:25 - to say if loading
216:31 - then inside the parentheses here I'll
216:32 - say return
216:35 - and inside the return I'm going to add a
216:37 - view
216:40 - and then also the activity indicator
216:44 - so we're wrapping the activity indicator
216:46 - inside of a view here so we can better
216:48 - control the layout for it
216:50 - for our activity indicator we're going
216:52 - to say size equals
216:55 - and then we'll set this to the string
216:57 - large
216:59 - and we're also going to set the color
217:01 - so we say color equals
217:04 - and then we set this to the string blue
217:09 - we also want to set a couple of styles
217:11 - for the view just so we're sure we're
217:13 - setting the layout for the activity
217:14 - indicator to be in the center of the
217:16 - screen
217:17 - so in the view I say style equals
217:22 - styles
217:24 - Dot
217:25 - container
217:30 - now in the react native Imports we need
217:32 - to add the view and the style sheet
217:35 - before the component is exported let's
217:36 - set up the style sheet so I say const
217:39 - Styles equals stylesheet Dot
217:44 - create
217:47 - and then I pass in the object
217:51 - I'm going to set the container
217:56 - and for this I'm going to say justify
217:58 - content
218:01 - of Center
218:04 - and flex
218:07 - of one
218:10 - let's save this and see how it looks in
218:12 - the simulator
218:15 - when the simulator runs I see the
218:17 - loading spinner in the center of the
218:18 - screen
218:19 - if the loading state was set to false I
218:21 - would see the tabs and our weather
218:23 - screens
218:24 - so next we're finally ready to look at
218:26 - getting data from the API
218:30 - so in order to get data from the open
218:33 - weather map API we need to start by
218:35 - calling the API
218:37 - let's take a look back at the API
218:39 - documentation on the open weather map
218:41 - website
218:43 - for our app we want to display the
218:46 - current weather
218:47 - but also the upcoming weather
218:49 - so we're going to use the five day three
218:51 - hour forecast
218:54 - if I click on the API documentation here
218:56 - it shows us how to make the API cool
218:59 - as we can see there are a few things
219:01 - that are required to make this
219:03 - successfully
219:04 - we will need the latitude and the
219:06 - longitude which a geographical
219:08 - coordinates for where we want to display
219:10 - the data from
219:12 - and then we're also going to need our
219:13 - API key
219:15 - let's start by figuring out how we'll
219:17 - get the latitude and the longitude
219:20 - the technical term for finding
219:22 - Geographic data such as coordinates is
219:25 - geolocation
219:28 - if I search for react native geolocation
219:30 - we can see that this has been deprecated
219:33 - and we should use one of the community
219:34 - packages instead
219:37 - if I click on the link we can see that
219:39 - there are a variety of packages
219:41 - available
219:42 - so this is useful if you did not create
219:44 - the app with Expo and it's also
219:46 - something to know about in the future
219:48 - but as we created the app with Expo
219:50 - we're able to use a package called Expo
219:52 - location
219:54 - let's take a look at the documentation
219:55 - for this
219:58 - so as it says Expo location allows
220:01 - reading geolocation information from the
220:03 - device
220:04 - this sounds exactly what we're looking
220:06 - for
220:08 - let's start by installing it
220:11 - so in our terminal we need to say npx
220:16 - Expo
220:19 - install
220:21 - Expo
220:23 - Dash
220:25 - location
220:33 - now if we go back to the documentation
220:35 - we can see all the extra configuration
220:38 - and then there's also steps provided if
220:40 - you're installing the project in a bear
220:41 - react native project
220:43 - in the example provided we see that we
220:46 - have to complete two steps in order to
220:47 - get the user's location
220:51 - firstly we have to ask for permission to
220:53 - access their location
220:55 - and then we need to get their location
220:59 - once we have their location we need to
221:01 - store this
221:04 - we also need to be mindful of handling
221:06 - any errors in case we were not able to
221:08 - access the user's location
221:10 - so for implementing this successfully
221:12 - we're going to need to use you state in
221:14 - order to store the location and any
221:16 - errors and then we're also going to need
221:19 - use effect
221:21 - so back in our code let's start by
221:23 - importing use effect
221:29 - next we'll set up two pieces of State
221:32 - we'll do the location first
221:35 - so we say const
221:38 - then we use square brackets
221:42 - and we say equals
221:44 - use state
221:48 - inside the square brackets we'll say
221:50 - location
221:56 - and then set location
222:00 - we're going to initialize this with null
222:04 - now for the error we need to set up
222:06 - another piece of State
222:08 - so we say const then we use square
222:10 - brackets
222:12 - and we set this equal to U state
222:17 - this time in the square brackets we'll
222:19 - say error
222:21 - and set error and then we'll initialize
222:24 - this with null
222:27 - next let's set up the use effect
222:31 - so before the return we say use effect
222:34 - and then into this we need to pass a
222:37 - function
222:39 - we're going to pass in a function which
222:41 - needs to be immediately invoked so
222:43 - inside of the curly braces we use a set
222:45 - of parentheses
222:48 - next we say async
222:51 - this is so that JavaScript knows we're
222:53 - using an asynchronous function here
222:56 - then we can set this up as a function so
222:58 - we use parentheses
223:02 - an arrow and some curly braces
223:07 - inside the curly braces we say let then
223:09 - use curly braces
223:12 - and we set this equal to
223:15 - await
223:18 - location
223:21 - Dot
223:23 - request
223:27 - foreground
223:31 - permissions
223:34 - async
223:38 - make sure you capitalize the location
223:40 - here
223:41 - we want to access the status so inside
223:44 - the curly brackets we're going to place
223:46 - status
223:48 - next we handle the error using an if
223:51 - statement
223:52 - so we say if
223:56 - status
223:58 - does not strictly equal
224:01 - granted
224:05 - then we use our set error State function
224:10 - and we set this to the string
224:13 - permission
224:18 - to access location
224:24 - was denied
224:29 - and then we say return
224:33 - now outside of the if statement we can
224:36 - continue with the rest of the code for
224:38 - if the request for permissions were
224:39 - successful
224:41 - so we create a variable using let called
224:43 - location
224:47 - we assigned to this await
224:52 - location
224:56 - Dot
224:59 - get current position
225:03 - async
225:07 - into this we pass in an empty object
225:10 - lastly all we need to do is update the
225:13 - location
225:14 - so we say set location
225:18 - and into this we pass in the location
225:22 - then as we want to immediately invoke
225:25 - this at the end of the function we use a
225:27 - set of parentheses
225:29 - inside of the use effect we'll pass in
225:31 - an empty array for the dependencies
225:34 - this means there's no dependencies and
225:36 - that use effect will only run once when
225:38 - the component is first rendered
225:50 - in our component we're just going to add
225:52 - a console log for now
225:53 - and we'll say if location
226:00 - then console log location
226:07 - before we test this we need to ensure
226:09 - location is enabled on the simulator or
226:11 - emulator
226:14 - you can see more information about how
226:15 - to do this in the documentation here
226:19 - let's go ahead and test this out in the
226:21 - simulator
226:25 - when the simulator runs we see the
226:27 - permission request which we set up
226:30 - when I click on allow while using the
226:32 - app
226:33 - and then launch the console
226:35 - I then get to see the location data
226:37 - which includes the latitude and
226:39 - longitude which we were looking for
226:44 - it's worth knowing here as a side note
226:46 - that when you're using a simulator the
226:48 - location defaults to San Francisco as
226:50 - opposed to your real location
226:53 - so now we have this let's look at
226:55 - getting data from the API
226:57 - at this point it would be helpful if
226:59 - you're signed in on the open weather map
227:01 - API website
227:09 - thank you
227:11 - to start with I'm going to navigate back
227:13 - to the five day three hour forecast
227:16 - and then I'll open the documentation
227:18 - here
227:20 - next I'm going to copy and paste the URL
227:23 - for the API call
227:25 - that we're going to need as we're going
227:27 - to need that shortly
227:30 - for now I'll just paste this at the top
227:32 - of the app.js file
227:36 - so we need to think about how in the app
227:38 - we're going to store the API key
227:40 - it's always best practice and safer not
227:43 - to expose any secrets in your
227:44 - application and import them from an
227:46 - external place
227:48 - this is even more important if you're
227:49 - using Source control like GitHub because
227:51 - you don't want these keys to be visible
227:53 - to anyone
227:54 - there are a few ways you can go about
227:56 - doing this and there's some deeper
227:57 - documentation on the Expo site here if
227:59 - you would like to find out more about
228:00 - this
228:02 - for our example we're going to use a
228:04 - package called react native.enth
228:06 - this means we can use an environmental
228:08 - variable where the value is set from
228:11 - outside of the application
228:13 - so let's go ahead and set this up
228:15 - so we need to start by installing it
228:19 - back in our terminal we'll say npm
228:21 - install
228:23 - d
228:26 - react
228:28 - native
228:31 - dot ends
228:37 - once this is installed we need to go to
228:39 - our Babel config file and then add the
228:41 - plugin
228:43 - so after presets we need to add a comma
228:48 - and then for the key we say plugins
228:53 - and then we use an array
228:57 - inside of this as a string we say module
229:02 - colon
229:05 - react
229:08 - Dash
229:10 - native
229:13 - Dash
229:15 - dot end
229:19 - so now we can create the dot end file
229:22 - so at the root of the project I'm going
229:24 - to create a file called dot ends
229:28 - once this is done we can test this out
229:32 - I'm just going to use a dummy value for
229:33 - now using capitals which is the best
229:36 - convention
229:37 - so first I'll set the name of the key to
229:39 - be test
229:42 - underscore
229:44 - key
229:47 - then I'll say equals
229:49 - and for this I'll just say one two three
229:53 - now if I go back to the app.js file I
229:55 - can import this
229:58 - so in my input I say import
230:02 - then I use curly braces
230:05 - and I say from
230:08 - at NF
230:11 - inside the curly braces I place the name
230:13 - of my key
230:15 - which was test underscore
230:18 - key
230:19 - so now I'll just add a console log with
230:22 - this
230:29 - let's save this and run the app in the
230:30 - simulator
230:33 - when the simulator runs if I check the
230:35 - console I can see the value of the key
230:37 - printed successfully
230:39 - so we've proven the package was
230:40 - successfully set up let's go back to our
230:43 - app
230:45 - as I'm using git I want to make sure the
230:47 - dot end file is not pushed so inside the
230:49 - git ignore I will add the file name
230:53 - this means it will not be part of any
230:54 - committing and pushing to get that I do
230:57 - so next let's go back to the dot end
230:59 - file
231:00 - we'll delete the test key
231:03 - and we'll add our key for the open
231:04 - weather map API
231:07 - I'll call this key weather
231:11 - underscore API
231:15 - underscore
231:17 - key
231:19 - the next thing we're going to need to do
231:20 - is to get the API key
231:23 - so back on the open weather map website
231:25 - as long as you're signed in you can
231:27 - click on your user
231:29 - and then my API keys
231:32 - on this screen you can copy and paste
231:34 - the key if you have one
231:36 - otherwise you can generate one by
231:38 - selecting generate and then copy and
231:40 - paste it
231:42 - if you now go back to your Dot N file
231:44 - you can paste it in
231:47 - and then we should be good to go
231:49 - so the last bit of setup we need to do
231:51 - here if we go back to the app.js file we
231:54 - can change the import for the test key
231:56 - to be weather API key
232:03 - now we can look at how we're going to
232:04 - fetch the data
232:10 - so to fetch the data we're going to use
232:13 - the fetch API which is what react native
232:15 - provides us with to work with networking
232:18 - if you haven't used this before you can
232:20 - read more about it here
232:23 - and also here
232:27 - so back in our app.js file we're going
232:30 - to start by creating a new piece of
232:32 - state to store the weather data
232:34 - hopefully you're becoming more familiar
232:35 - with this now but we'll say const
232:41 - then we'll use a set of square brackets
232:45 - and we'll set this equal to use state
232:54 - we'll call this weather
232:56 - so let's add that into the square
232:58 - brackets
233:02 - then we'll call the function to update
233:03 - the state set weather
233:09 - we'll initialize this as an empty array
233:13 - so next we're going to encapsulate this
233:15 - data fetching inside of a new function
233:17 - which we'll call fetch weather data
233:21 - so before the use effect we'll say const
233:24 - fetch weather data
233:29 - and we'll use an equal sign
233:34 - and then async
233:36 - next we'll use some parentheses
233:39 - and arrow
233:41 - and some curly braces
233:43 - so now inside the curly braces we can
233:45 - then set the response
233:47 - so to start we declare a variable using
233:49 - const called res
233:54 - and to this we'll say await
233:57 - fetch
234:00 - and some parentheses
234:01 - inside the parentheses we can paste in
234:03 - the URL we want to fetch the data from
234:06 - so we're going to use backticks here as
234:08 - we're going to need to interpolate in
234:10 - our environment variable
234:12 - so we'll say http
234:15 - colon
234:17 - and two forward slashes
234:20 - next we can paste in the URL that we
234:22 - commented out earlier
234:24 - we'll update these values shortly
234:27 - so next we need to create another
234:28 - variable to get the Json data
234:31 - so we'll say const
234:34 - data
234:36 - and we'll assign to this await
234:40 - response
234:43 - Dot
234:46 - Json
234:50 - once we have this we can call our set
234:52 - weather State function
234:54 - so we say set weather
234:58 - and into this we pass data
235:03 - also once this is done we can set the
235:05 - loadings date to be false
235:07 - so we say set loading
235:10 - and pass in false
235:13 - then inside of the use effect after the
235:16 - location is set we can say
235:19 - await
235:22 - fetch weather data
235:28 - so let's now format the URL that we
235:30 - passed into fetch
235:33 - so inside curly braces we have the
235:35 - latitude and longitude and also the API
235:37 - key
235:39 - so to start with we need to get the
235:41 - latitude from our location piece of
235:43 - State
235:44 - so we say location
235:48 - Dot
235:51 - coords
235:55 - Dot
235:57 - latitude
236:02 - and then we can do the same for the
236:03 - longitude
236:05 - so we say location
236:08 - Dot
236:11 - coords
236:13 - Dot
236:15 - longitude
236:19 - now where the API key is we can pass in
236:22 - our weather API key
236:32 - we also need to make sure we're using
236:34 - interpolation here so we need to add
236:36 - dollar symbols before each of the curly
236:37 - braces
236:40 - foreign
236:43 - there's also some error handling we need
236:45 - to do here so if the response fails in
236:47 - some way we can set our error state
236:51 - to achieve this I'm going to wrap
236:52 - everything inside of a try catch
236:54 - statement
236:55 - so I say try
236:59 - then I use some curly braces
237:03 - and then I say catch
237:07 - and I place error inside of the
237:08 - parentheses
237:12 - then I use another set of curly braces
237:16 - so inside the try I will place
237:18 - everything we've written
237:22 - and then inside of the catch I'll say
237:24 - set error
237:27 - and then inside parentheses I'll use a
237:30 - string
237:31 - and for this I'll say could not
237:35 - fetch weather
237:39 - additionally I'm going to use finally
237:41 - here
237:43 - this is used to execute something after
237:45 - the try catch has been completed
237:48 - so I'll say finally
237:51 - and I use another set of curly braces
237:53 - here I'm going to move set loading from
237:56 - the try statement into here
237:59 - the reason I'm doing this is so that we
238:01 - have either the data or the error
238:04 - once either of these is set we can set
238:06 - loading to false and then we can
238:08 - navigate to the correct screen for this
238:10 - state of course this also means we're
238:12 - going to need to add a screen to show
238:13 - the user if there is an error but we'll
238:16 - add that a bit later
238:17 - so there's one last bit of refactoring I
238:19 - want to do now when we initially set up
238:21 - the location we set one piece of
238:23 - location and then pulled out the
238:24 - required values in the API call
238:27 - I'm going to update this so we have two
238:29 - separate pieces of State one for the
238:31 - latitude and one for the longitude so
238:34 - I'll start by creating these
238:36 - I say const
238:39 - and then I use some square brackets
238:42 - and then I say equals
238:44 - you state
238:47 - inside this I'll place an array
238:52 - I'll call this date lat
238:55 - and then the function to update the
238:57 - state set lat
239:00 - next I'll do the same for longitude
239:03 - so I say const
239:07 - then I use square brackets
239:12 - I initialize this with an empty array
239:13 - I'll call the state lawn
239:16 - and the function to update the state
239:18 - settled on next inside the use effect
239:20 - instead of saying set location I'll say
239:23 - set let
239:26 - and then location
239:29 - Dot
239:32 - coords
239:34 - Dot
239:37 - latitude
239:40 - then I'll do this again for the
239:41 - longitude
239:43 - so I'll say settlon
239:46 - and then I'll pass in location
239:50 - Dot
239:52 - coords
239:55 - Dot
239:57 - longitude
239:59 - then I can update the API call instead
240:01 - to use the lat and long pieces of State
240:09 - additionally I'm going to pass these in
240:11 - as dependencies inside of the user
240:13 - Factor array
240:15 - this means when these change the use
240:17 - effect will rerun
240:20 - let's also remove our initial location
240:22 - piece of State
240:30 - so now let's add a console log to see if
240:32 - we can view the weather data
240:34 - so we'll say if whether
240:39 - console log
240:41 - weather
240:45 - let's save this and see how things are
240:47 - in the simulator
240:51 - so now when we look in the console we
240:53 - can see the weather data has now been
240:55 - set up and is visible to us
240:59 - so now we have all the data we need
241:01 - coming down from the API
241:04 - next I'm going to do a bit of
241:05 - refactoring because our app component
241:07 - has quite a lot of logic inside of it at
241:09 - this point
241:10 - so I'm going to extract the current hook
241:12 - usage into an external file
241:14 - you can make custom Hooks and then
241:16 - import them just like when you use a
241:18 - react hook
241:19 - the benefit of this is that we can
241:21 - better encapsulate the logic
241:23 - in our case we're going to end up with
241:26 - quite a few things going on so doing
241:28 - this means our code is much easier to
241:29 - work with
241:30 - the only requirement when we do this is
241:32 - that we name it with something that
241:34 - starts with use just like when we use
241:36 - hooks which are from react so to start
241:38 - I'm going to create a new directory
241:39 - called hooks
241:45 - now inside here I'm going to create a
241:47 - file called use getweather.js
241:55 - I'll go to this file
241:57 - and I'll start by creating the function
241:59 - so I'll say export const
242:03 - use get weather
242:07 - as this is a function I need to use an
242:09 - equal sign
242:10 - some parentheses
242:13 - an arrow
242:15 - and some curly braces
242:17 - let's think about what we need to add in
242:19 - here
242:20 - we want all the data fetching logic from
242:22 - the app.js file so let's start by
242:24 - getting that and then we'll paste it
242:25 - inside of the function
242:33 - we're also going to need to get all of
242:34 - our state because this is dependent upon
242:37 - by the functionality inside of the hook
242:39 - so back in the app.js file I'll copy all
242:41 - the states set up
242:43 - then I'll go back to the custom hook
242:45 - file
242:47 - and I'll paste this at the top of the
242:48 - use get weather function
242:50 - lastly we're also going to need some of
242:52 - the Imports
242:54 - so let's grab everything from the app.js
242:57 - file
242:58 - and then we'll paste it at the top of
243:00 - the hook file
243:02 - so we can delete the react native and
243:04 - the navigation Imports here because
243:05 - they're not used
243:08 - lastly at the end of the hook we need to
243:11 - return inside of an array the pieces of
243:13 - state that will be needed by our app
243:15 - component so for us this is the loading
243:18 - State the error State and the weather
243:20 - data
243:21 - the app component itself does not need
243:23 - the latitude and longitude so we can
243:25 - keep these scoped only inside of this
243:27 - hook so at the end of the hook after the
243:29 - use effect we say return
243:32 - and then we use an array
243:34 - and we'll pass in loading
243:37 - error
243:38 - and weather
243:41 - at this point we could actually now use
243:43 - this hook inside any component we wanted
243:44 - so this is really helpful if you have
243:47 - some reusable code which is required by
243:48 - multiple components as it means you
243:50 - don't need to duplicate logic
243:52 - now we're ready to use the hook in our
243:54 - app component
243:55 - so if we navigate back to the file we
243:58 - can start by importing the hook I'm also
244:00 - going to delete all the unused code now
244:11 - so now we can use this and we simply
244:13 - just destructure the values so at the
244:15 - top of the app file we say const
244:18 - then we use square brackets
244:21 - and we set this equal to use getweather
244:24 - the values to place inside of the array
244:26 - are loading
244:28 - error
244:30 - and weather
244:32 - so now you can add a console log with
244:35 - loading
244:36 - error
244:38 - and weather
244:41 - let's save this and test this out in the
244:43 - simulator
244:45 - when the simulator runs I now get to see
244:47 - the loading error and weather data
244:50 - printed out in the console so we have
244:52 - proven this works and we now have all
244:54 - our logic scoped inside of its own hook
244:57 - so the next thing we're going to do now
244:59 - is look at wiring up each of our weather
245:01 - components with the real data
245:03 - so to start with we need to pass the
245:05 - weather data to the tabs and then we'll
245:07 - need to decide which pieces of data are
245:09 - required by which component
245:11 - so back in our app.js file let's set a
245:14 - prop on the tabs called weather
245:20 - and we'll set this to weather
245:24 - I'm also going to change the render
245:25 - order here so if the weather exists we
245:28 - render the tabs otherwise we'll show the
245:30 - activity indicator
245:32 - so I'll place the rendering for the tabs
245:34 - to be above the rendering for the
245:36 - activity indicator
245:39 - and then I'm going to enclose this
245:41 - inside of an if statement that says if
245:44 - whether
245:46 - and
245:47 - weather.list
245:50 - then return the navigation container
245:55 - then I'll remove the condition around
245:57 - the activity indicator
245:59 - and just return this
246:02 - so essentially here we're saying if the
246:04 - weather exists with the data we'll
246:06 - render the weather
246:08 - otherwise show the activity indicator
246:11 - we'll update this a bit more later to
246:12 - show an error screen if the error state
246:14 - is true
246:16 - so now let's go back to the tabs
246:18 - component
246:24 - now inside the tabs component we can
246:26 - start using this if we take a look at
246:29 - the data that we get back from the API
246:30 - we can have a think about what each
246:33 - component will need
246:35 - the current weather component only needs
246:37 - the current weather so we can pass it
246:39 - the first element of the list array for
246:41 - the upcoming weather we can pass
246:43 - everything from the list array
246:45 - then for the city we can just pass in
246:47 - the city data
246:50 - so we're going to do this process
246:52 - component by component and we'll start
246:54 - with the current weather component
246:57 - in order to pass the props to the
246:58 - component we need to render a callback
247:00 - to return the element to use for the
247:02 - screen instead of using the component
247:04 - prop
247:05 - so let's start by setting this up we'll
247:07 - remove the component prop and then we'll
247:09 - set up the tab screen to return a child
247:17 - now we can pass in the component so we
247:19 - use curly braces
247:22 - a set of parentheses
247:24 - an arrow
247:26 - and then the current weather component
247:31 - on the component we'll pass the props
247:34 - so we say weather data
247:37 - and we set this to whether
247:42 - dot list
247:46 - and then using square brackets we'll
247:48 - access the element at the position of
247:50 - zero
247:51 - so next we can go to the current weather
247:53 - component
247:54 - and we'll add the weather data prop
247:59 - let's add a console log for this and
248:01 - check everything is wired up correctly
248:03 - here
248:07 - so I'll run the app in the simulator
248:13 - now I'll check the console brilliant I
248:15 - now see the data in the console and
248:17 - we're good to go with wiring up this
248:18 - component to use this data now so let's
248:21 - open our current weather component
248:24 - now we can have a think about what we
248:26 - need to do in order to get this up and
248:27 - running properly
248:29 - the pieces of data I'm going to need for
248:31 - this component are the temp
248:34 - feels like
248:36 - temp Max temp min
248:38 - and weather
248:41 - so to start with I'm going to just
248:43 - structure these from the props so I
248:45 - start by saying cons
248:48 - and then I use the set of curly braces
248:52 - everything except the weather itself I
248:54 - need to get from Maine so I say Maine
249:03 - I say temp
249:07 - feels like
249:10 - temp Max
249:16 - and tent men
249:18 - outside of the curly braces I use a
249:20 - comma
249:22 - and I say weather
249:25 - then I set this equal to weather data
249:42 - next in order to access the correct
249:44 - weather type object I'm going to need
249:46 - access to the weather condition
249:48 - so I'm going to create a variable to
249:50 - store this I'll say const weather
249:53 - condition and I'll set this equal to
249:56 - weather square brackets 0 Dot
250:01 - Main
250:04 - the first thing we're going to do is
250:06 - update the background color for the
250:07 - screen so that it's set dynamically from
250:09 - the weather type utility file
250:12 - because we want to use a property based
250:14 - on the data we're going to need to do
250:15 - this in line so that we have access to
250:18 - everything we need
250:19 - so for the style on the safe area view
250:21 - we'll add in an array
250:24 - after the wrapper
250:25 - we'll add a comma
250:28 - then we'll use inline styles to set the
250:30 - background color
250:32 - so we use an object
250:34 - and inside this we'll set background
250:37 - color
250:41 - we'll set this to be weather type
250:46 - and then we need to pass in the weather
250:47 - condition so we'll use square brackets
250:51 - and then inside of the square brackets
250:53 - we'll Place weather condition
250:57 - outside of the square brackets we then
250:59 - want to access the value of the
251:00 - background color
251:02 - so we say dot
251:04 - background color
251:09 - next we can do a similar thing to
251:11 - dynamically set the icon
251:14 - so for the feather element name we'll
251:16 - add curly braces
251:19 - and then we'll say weather type
251:25 - and then we'll use square brackets
251:28 - inside the square brackets we'll say
251:30 - weather condition
251:33 - and then outside of the square brackets
251:35 - as we want to access the icon we'll say
251:37 - dot icon
251:40 - I'm also going to update the color to be
251:42 - white
251:46 - next we can update the temperature text
251:49 - to use the temp value
251:51 - so we need to add curly braces here as
251:53 - we're passing in a value
251:55 - and then inside the curly braces we can
251:57 - add temp
252:00 - for the feels like temp we also need to
252:02 - use curly braces
252:06 - here I'm going to use a template literal
252:08 - so inside the curly braces I'll add back
252:10 - ticks
252:13 - then I'll say feels like
252:18 - and I'll interpolate in the feels like
252:20 - value
252:24 - the first row text shows the high and
252:26 - low temperature so I need to update the
252:28 - message 1 and message two values
252:30 - I'm going to use template literals here
252:32 - again
252:34 - so for the message one I'll use
252:36 - backticks
252:38 - then I'll say hi
252:41 - then a colon
252:43 - and I'll interpolate in temp Max
252:48 - for message 2 I'll again use backticks
252:52 - and I'll say low
252:54 - colon
252:55 - and I'll interpolate in temp min
252:59 - for the next row text we want to show
253:01 - the weather description which comes from
253:02 - the data
253:04 - and then we also want to show the
253:05 - weather type message
253:07 - so for message one I'll say whether
253:11 - and as this is an array I need to use
253:13 - square brackets and pass in zero
253:16 - [Music]
253:18 - then I say dot
253:21 - description
253:26 - for the message too instead of passing
253:28 - in thunderstorm I can remove this string
253:30 - and instead just pass in the weather
253:32 - condition
253:34 - let's save this and see how things look
253:36 - in the simulator
253:38 - when the simulator runs I see the
253:39 - current weather component but we're now
253:41 - using the values from the weather type
253:43 - and everything is using the real data
253:46 - there is one thing though the units are
253:48 - currently in Kelvin
253:50 - on the open weather map documentation we
253:53 - can see this is the default
253:55 - on our app we want to use metric so we
253:57 - need to add this to the API call
254:00 - if we go back to the use get weather
254:01 - hook we can append this to the API call
254:08 - we use the and symbol
254:10 - and then we say units
254:13 - equals
254:15 - metric
254:17 - now if we reload the simulator we can
254:19 - see the new values
254:22 - this screen will now look different
254:24 - every time the weather type changes
254:26 - so that is our current weather component
254:28 - updated for now with the data next we
254:31 - can move on to updating the upcoming
254:32 - weather component let's go back to our
254:34 - tabs and set this up
254:39 - so back in the tabs component we'll
254:41 - remove the component prop and then set
254:43 - up the tab screen to return a child
254:54 - then we can pass in the component
254:57 - so we use curly braces
254:59 - and then a set of parentheses
255:02 - an arrow
255:04 - and then the upcoming weather component
255:07 - next on the component I'll say weather
255:09 - data
255:11 - and I'll pass in whether
255:15 - dot list
255:17 - this means we have access to all the
255:18 - upcoming data
255:27 - so next I'll go back to the upcoming
255:29 - weather component
255:30 - and I'll pass in weather data to the
255:32 - component
255:37 - I'm going to start by removing all the
255:39 - dummy data we added
255:43 - additionally I'm going to remove the
255:45 - title for the component
255:48 - so I can also now remove the text from
255:50 - the Imports
255:54 - next in the data proper the flat list
255:56 - I'll pass in weather data
256:02 - the values for the list item inside of
256:05 - render item are already set up from the
256:07 - dummy data so now we can go straight to
256:09 - the list component and see what we need
256:11 - to update
256:15 - in this component we also have all the
256:17 - props set up from the dummy data but we
256:19 - need to do some refinements here
256:21 - I'm going to start by updating the icon
256:23 - to use the icon from the weather type
256:25 - dynamically
256:27 - so to start I need to import the file
256:30 - so I say import
256:32 - then I use curly braces
256:35 - and inside the curly braces I add
256:37 - weather type
256:40 - and I'll import this from utilities
256:42 - slash weather type
256:47 - then for the feather icon name I'll
256:50 - remove the string some
256:53 - and I'll say weather type
256:56 - square brackets
256:59 - our passing condition into the square
257:01 - brackets
257:03 - and then I'll say dot icon
257:10 - because space is limited for the list
257:12 - item I'm then going to change the Min
257:14 - and Max temperature to be all in one
257:16 - line
257:17 - and I'm also going to round these values
257:20 - so to start I'll delete the text with
257:22 - Max
257:24 - then I'll use a template literal and
257:27 - interpolate in
257:28 - math
257:31 - Dot
257:32 - round
257:35 - and I'll pass in min
257:40 - then I'll interpolate in
257:42 - math
257:44 - Dot
257:46 - round
257:49 - and I'll pass in Max
257:52 - I'll separate these with a slash
257:55 - also we want to show the degree symbol
257:57 - on each of these values on a Mac I can
257:59 - do this with option shift 8.
258:02 - on a Windows this is Alt 0176
258:07 - next we'll look at formatting the date
258:09 - text and I'm going to use a library to
258:11 - help us with this called moment.js
258:15 - moment.js helps us pass and format any
258:17 - data related to time and dates
258:20 - it's a really useful library to know
258:21 - about because it provides a lot of
258:23 - options for how to display what can
258:25 - sometimes be quite complicated data to
258:27 - the user
258:28 - let's start by installing it
258:31 - in the terminal I need to type npm
258:34 - install
258:37 - ment dash dash save
258:43 - we're going to split the date text into
258:45 - two sections one that shows the day and
258:48 - one that shows the time
258:51 - so back in the component let's add
258:52 - another piece of text under the one that
258:54 - currently shows DT text
258:59 - also to display these we're going to
259:01 - want these to be split onto two lines
259:04 - so we'll wrap these inside of a view
259:17 - and then we'll set some Styles here
259:19 - we'll just call these date text wrapper
259:26 - inside the style sheet let's add this
259:34 - and then we can set Flex Direction
259:36 - to column
259:39 - NAD format value we need to start by
259:42 - importing moment
259:43 - so at the top of the file we say import
259:46 - moment from moment
260:01 - so let's have a quick look at the
260:03 - documentation
260:04 - on the first line we want to show the
260:06 - day so we can do this by passing in d d
260:11 - we then want to show the time on the
260:13 - next line and we can do this by passing
260:15 - in H
260:16 - double m
260:18 - double s
260:20 - let's go back to our component and set
260:22 - this up
260:24 - so for the piece of text we want to show
260:26 - the name inside of the curly braces we
260:28 - say moment and then pass in DT txt then
260:33 - we say dot format
260:36 - and we pass in the string
260:38 - DD
260:42 - in the second piece of text we say
260:44 - moment
260:47 - and again pass in DT txt
260:51 - then we say dot format
260:54 - and this time we pass in H
260:57 - colon
260:59 - mm
261:01 - colon
261:03 - SS
261:05 - and Then followed by a space followed by
261:08 - a
261:09 - so the a will show the AM or PM
261:12 - let's save all of this and see how this
261:14 - component now looks in the simulator
261:22 - when the simulator runs we now see all
261:24 - of our list data showing on the screen
261:26 - with the new layout improvements
261:29 - so next we need to go back to our tabs
261:31 - component and move on to wiring up our
261:33 - city screen
261:35 - so back in the tabs component we'll
261:37 - remove the component prop
261:39 - and then we'll set up the tab screen to
261:41 - return a child
261:45 - next we can pass in the component
261:48 - so we use curly braces
261:50 - a set of parentheses
261:52 - an arrow
261:53 - and then component
261:55 - now we can pass in the data
261:57 - so we say weather data
261:59 - and we pass in whether
262:01 - Dot
262:03 - City
262:05 - now let's go back to our component
262:09 - let's start by setting the prop in the
262:11 - parameters
262:14 - and then we can destructure out the
262:15 - values we're going to need so I say
262:17 - const
262:20 - then I use some curly braces
262:24 - and I set this equal to weather data
262:29 - inside the curly braces I'll add name
262:33 - country
262:36 - population
262:39 - sunrise
262:42 - and sunset
262:44 - the first value we're going to update is
262:47 - the city name
262:49 - so I can remove London
262:52 - and I'll add some curly braces
262:55 - inside the curly braces
262:57 - I'll add name
263:02 - I can now do the same for Country so I
263:04 - remove UK
263:06 - and then I add some curly braces
263:09 - inside the curly braces I'll add country
263:15 - next I can update the first icon text
263:18 - body text value
263:20 - I'm going to use a template literal here
263:23 - so I'll remove 8000
263:26 - then I'll use some back ticks
263:30 - then I'll say population
263:33 - colon
263:36 - and I'll interpolating population
263:40 - I can then move on to updating the
263:43 - second icon text
263:45 - I'm going to use moment again here to
263:47 - help us with our formatting
263:49 - so I'll import moment from moment at the
263:52 - top of the file
263:55 - now back in the body text I will say
263:57 - moment
264:00 - and I'll pass in Sunrise
264:04 - then I'll say dot
264:06 - format
264:09 - and pass in h colon mm
264:14 - colon SS
264:17 - and then a space
264:19 - and a
264:22 - then for the last icon text body text
264:24 - value I'm also going to use moment again
264:29 - so this time I say moment
264:32 - and I'll pass in Sunset
264:36 - then I use a DOT
264:39 - and I say format
264:42 - inside format I pass in H
264:46 - colon
264:48 - mm
264:50 - colon
264:52 - SS
264:54 - then a space
264:55 - and a
264:58 - let's save this and see how it looks in
265:00 - the simulator
265:02 - everything for the screen looks good and
265:04 - this has now also been updated to use
265:06 - the data from the API
265:09 - so that's all our existing screens set
265:11 - up to use the data
265:12 - there's just a couple of minor fixes I
265:14 - want to do
265:16 - I want to add the degree symbol to the
265:18 - current weather component
265:20 - so let's go back to that component now
265:23 - in the first two pieces of text I'll add
265:25 - the degree symbol here
265:33 - I also want to add a space between the
265:35 - high and low text
265:37 - so on the message one prop here I'm just
265:39 - going to add a space at the end
265:42 - so now we have these refinements done
265:44 - let's move on to creating an error
265:46 - screen for the application
265:48 - inside the components directory I'm
265:51 - going to create a component called error
265:53 - item
265:56 - now inside this component we can set it
265:59 - up just like a standard component
266:01 - so I'll import react from react
266:07 - then our import View
266:11 - text
266:14 - and style sheet
266:16 - from react native
266:19 - I'm also going to import feather
266:22 - from at Expo icons
266:34 - so now we can declare the component
266:37 - I say const
266:40 - error item
266:42 - equals
266:45 - then I use a set of parentheses
266:48 - an arrow
266:51 - and some curly braces
266:54 - I'll make sure the component is exported
266:57 - so at the bottom of the file I say
266:59 - export default
267:01 - error item
267:04 - before the export I also need to set up
267:06 - the style sheet
267:08 - so I say const styles
267:11 - equals
267:13 - stylesheet
267:16 - Dot
267:19 - create
267:22 - and I'll pass in an object here
267:26 - inside the component I'll save return
267:31 - and then I'll add a view
267:36 - and some text
267:40 - inside the text I'll pass in the message
267:42 - sorry something went wrong
267:53 - next I'm going to add a feather icon
267:57 - so I'll say feather
268:01 - and then I'll set name
268:04 - to frown
268:07 - size
268:10 - to 100
268:13 - and color
268:15 - to White
268:19 - so let's set up the styles
268:23 - on The View I'll say Style
268:27 - equals
268:29 - styles
268:32 - Dot
268:34 - container
268:38 - on the text I'll say Style
268:41 - equals
268:44 - styles
268:47 - Dot
268:49 - error message
268:54 - then inside the style sheet our set
268:56 - container
268:58 - and I'll say Flex
269:00 - of one
269:03 - background color
269:06 - of red
269:09 - justify content
269:12 - of Center
269:15 - and align items
269:18 - of Center
269:22 - and then for the text
269:24 - I'll say font size
269:31 - of 30
269:34 - color
269:36 - of white
269:38 - margin horizontal
269:42 - of 10
269:43 - and text align
269:46 - up Center
269:50 - now let's test this out
269:53 - in the app.js file we can start by
269:55 - importing error item from components
269:58 - error item
270:04 - next in the render with the activity
270:07 - indicator we can use a conditional and
270:09 - say if loading
270:12 - then return the activity indicator
270:15 - otherwise
270:17 - return the error item
270:22 - to test this I'm going to go to the use
270:25 - get weather hook
270:33 - at the bottom of the hook where we
270:35 - return the values I'll say true for the
270:38 - error
270:40 - and I'll add an empty array for the
270:43 - weather
270:44 - this just means we now have the state
270:46 - set up in order to test out our error
270:48 - item
270:50 - so let's save this and see how it looks
270:52 - in the simulator
270:55 - when the simulator runs I see the error
270:57 - screen that the user would see if
270:59 - something went wrong when the location
271:00 - and weather are being set
271:05 - let's go back to our hook file and
271:06 - revert the changes we just made so we
271:09 - set the error and weather back in the
271:11 - values returned by the hook
271:28 - so now let's go through our app screen
271:30 - by screen and check if there's any other
271:32 - refactoring we need to do
271:36 - when I look at the current weather
271:37 - screen I can see we need to add the
271:39 - degree symbol to the initial temperature
271:40 - value
271:41 - I also want to slightly decrease the
271:43 - font size in the description and message
271:46 - so let's do that now
271:48 - back in the component I'll add the
271:50 - degree symbol to the temperature
271:59 - then in the style sheet I'm going to
272:01 - remove the pink background color as this
272:03 - is now not needed
272:07 - then I'm going to set the description
272:08 - font size to be 43.
272:11 - and the message font size to be 25.
272:16 - I'm lastly going to add optional
272:18 - chaining in the places that we are
272:19 - accessing nested object properties this
272:22 - means undefined will be returned if one
272:24 - of the properties does not exist instead
272:25 - of an error
272:40 - next let's take a look at the upcoming
272:42 - weather screen
272:44 - as we're using white text I think the
272:46 - background color of the list items is
272:48 - slightly light so let's update that
272:51 - let's go back to the list item component
272:54 - I'm going to set item background color
272:57 - to the Indian red
272:58 - this is all one word and all lower case
273:02 - lastly I'll add optional chaining where
273:04 - we're using the weather type
273:07 - everything looks a bit better in the
273:09 - simulator now so let's take a look at
273:11 - the city screen
273:12 - everything on this screen now looks good
273:14 - to go
273:15 - so we're ready to move on to making the
273:17 - final touches to our application
273:20 - the last thing I want to do on our app
273:22 - is adjust the app component very
273:23 - slightly
273:25 - I want to change the conditional to show
273:27 - the error item if the error state is
273:29 - true and then otherwise show the loading
273:31 - screen
273:32 - this just ensures that the user really
273:34 - does only see the error screen when
273:35 - there is an error
273:36 - so I'll say if error
273:40 - then show error item
273:45 - otherwise
273:46 - show the activity indicator
273:58 - so that is everything done and our app
274:01 - is now complete
274:03 - before I wrap up this course there's a
274:05 - couple of last topics I'd like to
274:06 - introduce you to but you can consider
274:08 - this as bonus material
274:10 - the first one of these topics is the
274:12 - context API
274:14 - you may have noticed when I implemented
274:16 - the tab screens as children that the
274:18 - documentation said that it advised you
274:20 - use the context API
274:22 - the reason I did not do this is because
274:24 - we only have three core screens on the
274:26 - app
274:26 - however if you're in a position where
274:28 - you're passing the data around a lot of
274:30 - components who are very far away in the
274:32 - component tree and also perhaps that the
274:34 - state is complex then the context API is
274:37 - very handy to know about
274:39 - it's also really useful if you have some
274:41 - global data which is needed throughout
274:43 - the application such as a user's name or
274:46 - some theming for the application
274:48 - by using the context API all the logic
274:51 - can become centralized
274:53 - it's not specifically the right or wrong
274:54 - approach it very much depends on your
274:56 - use case and it becomes a slightly
274:58 - different way of handling your data
274:59 - instead of props so you can share
275:01 - anything through the context and once we
275:03 - share the data the component can ask the
275:05 - context for the bits of data it needs
275:07 - it's important not to overuse context
275:09 - and definitely don't think of it as a
275:11 - replacement props but it's an approach
275:13 - that it's worth knowing about for when
275:15 - you need to access specific pieces of
275:16 - global data throughout the application
275:19 - the documentation about context is here
275:22 - but essentially there are three steps to
275:24 - creating context
275:25 - you need to start by importing the
275:27 - context
275:28 - then you would Define your context so if
275:31 - you had a rim context you'd say const
275:33 - room context and you'd set this equal to
275:35 - create context
275:37 - then you wrap the context around your
275:39 - components and at this point your
275:41 - components can access the context
275:44 - the last couple of topics I wanted to
275:45 - cover are UI based topics
275:48 - we haven't had the need in our
275:49 - application to create a button although
275:51 - we have seen how the react native button
275:52 - component works
275:54 - did you notice how this didn't really
275:55 - look like a button that you might have
275:57 - expected another common task when you're
275:59 - developing applications that you may
276:01 - encounter is creating custom buttons
276:03 - react native has a set of touchable
276:06 - components which help us with this
276:08 - if we take a look at touchable opacity
276:10 - we can see that it's a wrapper for
276:12 - responding to touches
276:14 - alternatively we have touchable without
276:16 - feedback but this doesn't give us a
276:19 - visual response so this is likely not
276:21 - what you want to use when you're
276:22 - creating a button
276:23 - in the demonstration directory that I
276:25 - created earlier I'm going to go ahead
276:27 - and Implement a button just so that
276:29 - you're familiar with how to achieve this
276:30 - and then I'll start by setting up the
276:32 - component so I'll import react from
276:35 - react then I'll import View
276:41 - touchable opacity
276:45 - and text
276:47 - from react native
276:51 - next I'll set up the component
276:54 - so I say const
276:57 - R button
277:00 - equals
277:02 - and then a set of parentheses
277:05 - an arrow
277:07 - and some curly braces
277:12 - I'll then export the component
277:14 - so I just say export default
277:16 - R button
277:19 - next I'll set up the style sheet
277:22 - so I say const styles
277:25 - equals
277:27 - style sheet
277:29 - Dot
277:31 - create
277:34 - into this I pass in an object
277:38 - so next in the component I say return
277:42 - and then I'm going to use touchable
277:43 - opacity
277:46 - and inside this some text
277:51 - for the text I'll just say hello
277:58 - then on the TouchPal opacity we pass in
278:00 - on press
278:06 - and we'll set some Styles so we say
278:08 - style equals
278:10 - styles
278:12 - Dot
278:14 - container
278:17 - would also set some styles for the text
278:19 - so I say style equals
278:22 - styles
278:24 - Dot
278:25 - button text
278:28 - in the style sheet I'll add these Styles
278:30 - so I'll start with the container
278:34 - I set elevation
278:37 - to eight
278:39 - this sets the elevation of the item on
278:42 - Android only
278:44 - next I say background color
278:47 - of blue
278:51 - border radius
278:53 - 10
278:55 - and I'll set padding
278:58 - to five
279:01 - then for the button text I'll set font
279:03 - size
279:05 - to 15.
279:07 - color
279:09 - to White
279:12 - and align self
279:15 - to Center
279:18 - then on the touchable opacity we set an
279:20 - on-press prop so let's set this up
279:24 - we use this to Define what we want to
279:26 - happen when the user presses the button
279:28 - so I'll set up an arrow function called
279:30 - on press
279:32 - and inside this I'll add a contour log
279:35 - which just prints out press
279:40 - to test this out let's go to the app
279:42 - component
279:44 - I'll comment out the navigation
279:46 - container render
279:49 - and then I'm going to import the button
279:51 - so I say import R button
279:55 - from demonstration R button
279:59 - then I'll add this to the render before
280:01 - the activity indicator
280:04 - Let's test this out in the simulator
280:08 - when the simulator runs I get to see the
280:10 - button if I open the console I can see
280:12 - the Press is printed out every time that
280:14 - I press the button
280:17 - I strongly advise you spend some time
280:19 - playing about with all the core
280:20 - components in react native as there's a
280:22 - lot you can achieve you can look at
280:24 - modals for alerts text input for text
280:28 - input fields and the switch component
280:30 - acts like a toggle

Cleaned transcript:

learn all about react native in this complete beginner's course from Emma Williams she is a software engineer who specializes in react native Emma will teach you everything you need to know to start developing crossplatform native mobile apps using JavaScript app downloads continue to increase year on year creating some big Revenue learning how to create mobile apps is also a lot of fun in this course I'll be introducing you to react native and together we'll build a weather application you're welcome to just watch the video or follow along the only prerequisite for the course is that you have a text editor set up I'll be using atom but you're welcome to use whichever one you prefer before we go any further if you're planning to follow along with this tutorial I'm going to start by showing you how to register for an API key which will be needed for the application it can take some time for the API key to activate which is why I'm suggesting starting by registering the key now the API key we'll use for the application is called the open Weather API and can be found here so you'll need to start by registering and then creating an API key we will be using the fiveday forecast which is free and can be found here we'll return back to this later in the tutorial so what is react native well react native is a framework which was created by Facebook and was initially released in 2015. react native lets you create mobile apps for IOS and Android by using JavaScript in the land of mobile apps we have two types of apps native and hybrid apps when you create a mobile app you have two choices create a hybrid app or create a native app when you create a native app you write two separate applications one will use Swift or objective c and is an app for the iOS platform the other uses kotlin or Java and is an application for the Android platform creating a native application gives you opportunities for fantastic user experiences but the tradeoff is that it means you need to do the work twice in order to create one application once for iOS and one for Android and often this means you need two development teams the alternative is to create a hybrid app so hybrid apps have one code base and can run on multiple platforms and examples of these include Cordova and ionic so you could have one code base and the app can run on both IOS and Android the benefit with hybrid apps is that you don't need two code bases or knowledge of multiple languages the issue with a traditional hybrid app though is that you're essentially creating a web app that runs on a phone so you have a container which renders web views a webview essentially vendors a website inside of the application when you do this the user experience is restricted so this is where react native comes in whilst technically react native is a hybrid platform because you only have one code base the app renders using real native UI components as opposed to webviews react native takes our JavaScript code and makes a bridge between our app and our Target platform so our components get rendered natively without using web views and we can use platform specific apis and components consequently we have a more performant app with a much better user experience you're also able to extend the code and create custom native components if required so you might have heard of Expo already but what is Expo well Expo is an external platform which makes our lives easier when we're developing building and deploying react native applications it is not compulsory to use Expo but if you're just getting started it is much quicker if you don't use Expo you have to go through the various steps of installing Android studio and xcode and then making sure you have simulators and emulators running when we use Expo we can just run the app easily on our device by simply scanning a QR code for this course we'll be using Expo so let's go ahead and get our environment set up so firstly we need to make sure we have a recent version of node installed next we need to go ahead and install the XPO CLI which will help us to create our project to do this we just type npm install Dash G because we want it installed globally Expo CLI now we need to navigate to the directory where we would like to create our project and then we can just go ahead and create it we do this by typing npx create Expo app weather app now all we have left to do is to run the project so we change directories into where we want the project to run by typing CD weather app and now we just type npm start you can also type Expo start or yarn start here if you have yarn installed and that is your preferred package manager lastly we can Now preview the app on our phones you have to make sure your phone is on the same internet connection as your computer then you can install the client for Expo from the app store or the Google Play Store you can find this by searching for Expo and the app is free once this is installed you can scan the QR code onto the camera if you're using an iOS device or from the app if you're using an Android device at this point you should see the app running for the purposes of teaching this course I'll be running the app on a simulator so I'll briefly go ahead in the next video and show you how to set this up but feel free to skip this section if you're happy to run the app on your own device so now we've looked at setting up a react native application using Expo I'm going to show you how to set the app up using the react native CLI you don't need to watch this section or do the setup if you're happy to run the app using Expo on your own device but I'm going to show you how to complete the setup using this approach so you're aware of it because as I mentioned earlier if you want to build an application using custom native code then you need to use this approach so we'll start by looking at iOS for this you need to have a Mac if you don't have a Mac you can still watch or you can skip to the section where I set up an application and then move on to Android so we'll start by following the documentation on the react native website we need to make sure we have node and Watchman installed if you want to work with multiple versions of node I highly suggest using NVM and the setup for this can be found here for those of you who aren't familiar with Watchman Watchman detects when the source code has changed so it can rebuild the bundle automatically next you need to make sure you have the correct version of Ruby installed on your machine you can type Ruby dash dash version to check which version you have installed if it doesn't match the version react native uses we can find more information about that here and then you need to install this version too you can do this by using a ruby package manager such as rvm so now we're ready to install xcode and we do this via the App Store this will install the various tools and simulators for us to run the application this installation can take some time so you may want to pause the video here and let this download if you're following along so now we need to make sure we have cocoapods installed if you have never used poker pods it's a dependency manager a little bit like npm but for iOS so now we have everything installed we can go ahead and create the application it's worth noting the warning provided on the website which says if we have previously installed the react native CLI we should remove it to avoid unexpected issues so we'll do that now by typing npm uninstall Dash G react native CLI and at react native Community CLI so now let's navigate to where we want to create the project and we'll do this by saying MPX react native init awesome project for those of you who are not familiar MPX is part of the npm tool chain which lets you run commands without installing things globally at this point our project should be set up so we can navigate into it by typing CD awesome project and now we're ready to start the application we need to use two commands for this so it's useful to have two separate windows open in your terminal First Command we use is MPX react native start this command will start running Metro which is the bundler that react native uses we could also run yarnstart here if you prefer to use yarn as your package manager or even npm run start finally we're ready to start the application and we do this by typing MPX react native run iOS now you should see the application launch inside a simulator as a side note if you're more comfortable working with xcode you can launch the application from there you will need to open the XC workspace ensure you're running Metro with react native start and then you can manually run a simulator in the next section we'll move on to launching the application via Android in the last section we looked at running the application using xcode and iOS this time we'll look at running the application with Android Studio the first thing you'll need to do is to make sure you have Android Studio downloaded and installed the link to download this can be found here once Android Studio is installed we need to make sure we have an emulator set up to do this we simply open Android Studio and select configure we then create our device when you are running the application on Android you need to make sure the emulator is launched before you do anything else we can simply double click the device here to launch it if you want to launch the emulator from your command line you type emulator Dash avd and then type the name so now we can close Android studio and type npx react native run Android and we should see our application launch in the emulator if you prefer to use your own device here you can simply plug the device into your computer and you should see it automatically detected if you've run into any issues make sure you have enabled USB debugging on the device finally if you run into any other issues which says could not connect to the development server You may wish to run a command which says ADB reverse TCP colon 8081 TCP colon 8081 doing this will set the port of your Android device to the port of your computer so now we have everything set up let's go ahead and explore the application in its current state I'm going to revert back to my project set up with Expo depending on how you set the application up you should be presented with a basic folder structure inside of your text editor if the project was created using the react native CLI you'll see a directory with iOS and another directory with Android inside of these directories are native entry points to the application we also have our node modules and Babel setup additionally if you set the application up with the react native CLI you'll also see prettier and we should also have a file called app.js so to make our lives easier we're going to add a linter for working with our project for those of you who use the react native CLI you should have a link to preinstalled but if you set the application up using Expo you will not have this depending on whether you're using yarn or npm you'll need to run the following which will install eslint as a development dependency npm install eslint dash dash save Dash Dev now we can initialize eslint and we do this by typing npx eslint dash dash init after this is done we should have an eslint RC file created with some setup and we can modify this we're also going to install the react native Community eslint config so we say npm install at react native Community slash eslint Dash config dash dash save Dash Dev I'm going to add a couple of extra rules but you're welcome to customize this to your own preference so now we'll also need to install prettier for helping us with our code formatting to do this we type npm install dash dash save Dash Dev dash dash save exact prettier and now we also need to create a file for our config so we'll type touch.pritia.js and we'll add the following you can find out more about setting config for any of these files here and here it's also worth adding eslint to your text editor depending on what text editor you have if you're using atom you can navigate to preferences install int or if you're using vs code then you can go to preferences extensions eslint if you've run into any issues you may need to try restarting your text editor lastly we can add a script for running eslint inside of our package.json so we'll call it lint and we'll set the value to eslint Dot to run this now all you need to do is type npm run lint or yarn lint so when you're working on an application it's really useful to know how to debug the code in order to fix any errors that you may create or run into in react native we have the ability to access what is called a debug menu with the various ways to run the application we have slightly different ways to access the debug menu if you're running the application on a physical device you can shape the device to access the debug menu if you're running the application on an iOS simulator then you can type command d and on an Android emulator command m if you're on a Mac or control M if you're on a Windows so now we should all be able to see the debug menu and we can see the options which are available to us the first one is reload whilst these days react native has hot reloading available it's still useful to know this option is here you're also able to type command R so you can do this without launching the debug menu the next option is debug selecting this will open the react native debugger and once this is open you can access the JavaScript console just like when you're working with a website so you can do this in Chrome by selecting view developer JavaScript console or you can type command option in j this means we can use console logs inside of our application and inspect them so let's navigate our application.js file I'm going to add a console log now let's go back to Chrome everyone can see our console log is printed out to us so when you're working with mobile apps each platform has a set of native components whilst the names of these differ depending on the platform the outcome is the same they help you lay out the UI of the application so for example on iOS if you're working with images you could use a UI image View whereas on Android you would use an image View on iOS this may be contained within a UI view whereas on Android this may be contained within a View group with react native we use JavaScript in our components and when the app runs react native will then create the correct UI for the different IOS and Android platforms so in order for us to create our UI react native has some core components which we can use if you're familiar with react you can think of this a bit like how you use divs and spans or P tags for your layout here are some of the core components that react native provides so we may wrap our layout inside of a view and then inside of this we may want to display some text using the text core component or a button using the button component so in our app.js file let's go ahead and use the core text component to add some text which we will wrap inside a view you can think of a view a bit like div so unless we apply styling to it the view won't be visible so we'll create a view and give it a height and a width of 100. and a background color of orange inside of the view we'll use the text core component and print out some text that says hello world now let's run this on our device we can see The View with the orange background which also contains our text so you may be wondering what the syntax is with all these tags it looks a bit like JavaScript and HTML and it's called jsx jsx is an extension of JavaScript and it stands for JavaScript and XML so we use jsx when we're creating elements and because it is Javascript we're also able to use JavaScript with it so we could change our text to use a variable instead let's give this a go so before the return statement we'll create a variable called message and when assigned to this our string which says hello now because we're going to be evaluating a JavaScript expression when the element is rendered we need to use a set of curly braces inside of these curly braces we place our variable so we use the message variable here now let's return to our simulator nothing has changed visually but we just used a variable to render the text so before we start building our application there's a few other things we need to be aware of when we're working with components you need to import react and then you need to import any of the core components that you wish to use your component is a constant function so it starts with const and any jsx must be returned lastly you need to export the function components and we do this using export default so we've come across the term component a few times in this section we have the core components which we import such as View and text but we also referred to everything in the file as a component we use the term element to describe what we see on the screen but this is contained within what we call a component one of the best things about react and react native is how it makes you the developer break down what you're building the UI is separated into different pieces if we take a look at the open weather map website we can see we have a navigation bar with various links foreign we have a search text input we have a map and some diagrams and also some City details all of these pieces can be broken down into separate components before they are rendered on the screen this makes working with code a lot of fun but it also makes it very extensible and clear so now we have a basic understanding of how react native Works let's go ahead and create our first component so now we have a basic understanding of how react native Works let's go ahead and create our first component so in the app.js file let's delete everything the first thing you need to do when you create a component is to import react so let's go ahead and do that now we say import react from react next we'll import the core components that we are going to use in our case we'll just use View and text so we say import and then we use a set of curly braces inside the curly braces we say View and text outside of the curly braces we say from react native there are a few different ways to create components but we're going to use the constant function approach described in the last section and we can look at these other approaches a bit more later we're going to call this component app so we say const app followed by an equal sign a set of parentheses an arrow and a set of curly braces lastly we need to export the component so we say export default app our component does not render anything but this is the basic setup for the components to achieved now we can add the jsx to return some UI we start by using the return keyword followed by a set of parentheses we'll start by adding The View and then we'll also add the text for our text we say current weather so let's take a look at the simulator it's very hard to see the text the layout of the text will vary slightly depending on which simulator or emulator you're using this is a bit like a layout on a website varying depending on the size of the computer screen or the different browser for this reason just adding padding or margins to fix the layout is not a great approach because you might fix the layout on one screen but it won't be guaranteed to look better on a different screen size or device and you also want to be mindful that people might be using your application on an iPad or tablet too so with this in mind react native provides another core component which can help solve this problem it's called a safe area View let's update our code to use this so we start by adding it to the import and then we'll wrap the whole element inside of a safe area View now if we check the simulator again we can see the content has been rendered just below the status bar of the device so now we made our first component let's move on to discussing styling in react native we don't have access to standard CSS instead we use a JavaScript object the naming of the properties is usually the same as with standard CSS except that we use camel casing instead so font size becomes font size for example there are a few different ways to apply the Styles but we're going to start by using inline styles when we use inline Styles the styles are applied as we create the component so we're going to start by applying a background color of pink to our view we'll talk about props shortly but for now just think of them like properties like when you add key value pairs to an object so we set a style prop on our view we say Style equals and then a set of curly braces inside the curly braces because we are using inline Styles we add a second set of curly braces and then we say background color a colon and then a string with the value pink let's save this and view it in the simulator we can see our screen with our pink background color applied so whilst this works as our code becomes more complicated applying inline Styles in this way can get quite messy so as it's always good to focus on writing quality code we're going to use another approach and this is called stylesheet.create so we can Define our Styles all in one place to do this we need to import style sheet from the react native API the list of the apis we can use with react native can be found here so we go ahead and we create a style object usually it's best to do this before you export the component so we say const styles equals style sheet Dot create we follow this by a set of parentheses and then a set of curly braces because we're passing it an object we can then go ahead and add our styles so we're going to call this attribute the container and now we can add background color now we need to add this to our component we can remove the second set of curly braces and then say styles Dot container let's save this and view the simulator nothing has changed visually but we have moved away from inline Styles and started using stylesheet.create instead when you're applying styles to your component it can be useful to refer to the documentation as these props vary slightly depending on what core component you're applying the styles to you can find out more about these here so we've just applied the background color but we only have the background color around the text not the whole screen so let's add a few other things here we'll add a style to the safe area view called wrapper and apply Flex one we'll also add Flex 1 to the container Flex is part of the layout props when we're building react native applications positioning and layout is done using flexbox and the reason for this is that it lets us build our layouts for the various different screen sizes that we will encounter so unlike with the web you don't have to say display Flex for those of you who aren't familiar Flex will Define how much of the screen The View should fill and you provide a value from zero upwards so we're saying Flex of one and this is the equivalent of saying the view should fill the entire screen because we're only using one View group when you want to start to split the view into different areas you may need to start to consider the different values depending on how much space you want each part of the screen to fill so if you're using Flex one then all the components up the tree must also use flex one which is why we also apply it to the outer safe area View let's also make our title display in the center of the screen we can do this by saying align items Center so this centers the text horizontally if we wanted to display the text in the center vertically we would just use justify content we want our text to just be centered horizontally so the goal for this screen is to show the user the current weather we want to display the actual temperature what the temperature feels like the high and low values and then we want to display a description and some additional text about the weather lastly we also want to display an icon and a background color eventually we want this screen to be dynamic so the icon background color and message that we provide change depending on the weather for now though let's just hard code everything in so that we can get our basic layout and once we have looked at getting the data from the API we can update this so it works dynamically so let's start by adding our text for the first value that we want to add which will be the temperature and for now we'll just add six for the value we'll add another text for the fields so we'll say fields like five let's add the high and low in another text so we say hi colon eight and low colon six so let's start by adding the layout styles for these we'll start with the temperature and we'll call this temp we'll give this a color of black and a font size of 48. you don't use units just the numbers for the Styles and react native all dimensions in react native are unitless and represent density independent pixels so this is an absolute unit of measurement for the device for the feels like text We'll add some Styles called feels foreign and this will have a font size of 30 and a color of black we also don't now need our title so let's delete that let's also add some styles for the high and low text we'll apply this to both pieces of the text and we'll call it styles Dot high low we will give this a color of black and a font size of 20. let's view the simulator and see what we've done so far we want the text for the high value and the text for the low value to appear on the same line to do this we can set the flex direction to use row we'll start by making a container for these pieces of text and then set the flex Direction on the container so that it applies to the children which is the high and low text so we start by wrapping both pieces of text in a view and we'll call the styles for this HiLo wrapper we'll then say Flex Direction right now if we check on the device again we can see the high and low text both appear on the same line on the bottom of the screen we want to add some more details about the current weather conditions so we'll create another view and inside this we'll place two pieces of text inside the first text we'll say it's sunny and inside the second we'll say it's perfect tshirt weather we want this text to show at the bottom of the screen so let's apply some styles we'll call the attribute body wrapper and set justify content to flex end this is so that it displays on the bottom of the screen let's also add align items with flex start so that the text displays on the far left of the screen we're also going to change our container so that it only wraps the items we want to display on the top portion of the screen so we'll move the closing brace for this view to be just before the view of the body wrapper attributes now let's also apply some styles to the text with the weather description we'll call the first one description and we'll call the second one message inside description let's add a font size of 48. and let's make the message a bit smaller so this one will have a font size of 30. now let's check the simulator we have our basic layout set up but it doesn't really look very pretty nor is it very dynamic we also see that our background color does not apply to the whole screen this is because we changed the container to only wrap the items at the top of the screen we can fix this by moving the background color into the safe area view wrapper let's do this now let's check the simulator again and we can see everything now looks as we expect in the next section we'll look at adding an image to the screen so we want to display an icon that represents the weather to the user there are a few ways we could do this but I'm going to use a library which is installed by default when we use create Expo app if you did not create the app using Expo you can manually install it now it's called react native Vector icons and it provides us with a variety of icons that we can use within our project the library Expo installs is built on top of the react native Vector icons one to explore the Expo items you can see them here for now we just want to use an icon that represents sunshine so let's search for this when we click on the icon it provides us with the details we need to use the icon so to start we need to import the icon family next we need to add the icon to our component we're going to show the icon at the top of the screen let's also change the size to be 100 so it's a bit bigger let's have a quick look on the simulator and see how this looks now so we can see the icon has been successfully added to our screen the top part of the screen is starting to look quite busy so let's Center all of this content by adding justify content Center to the container let's also add some left padding to the text at the bottom of the screen so I'll add padding left with the value of 25. and a margin bottom of 40. so in react native when we're adding things like margins and padding we can either provide a single value to the padding or margin which will affect the top right bottom and left alternatively we can apply separate values to the different areas like we're doing now we have our first component so we can look and moving on to using it with real data we're going to start by moving our current weather component into another component there are a few different approaches you can use in terms of structuring your app and these often vary depending on the complexity of the application we're going to start by creating a directory called SRC inside of this we're going to create another directory called components inside of the components directory let's create a file called current weather dot Js so let's paste everything from the app file into the current weather component let's also rename the component from app to current weather we also need to make sure it's exported now inside the app file let's delete everything let's redefine our component again so we say const app equals and then we use an arrow function with parentheses at the bottom of the file we say export default app inside the body let's add return with some parentheses we'll also import react and let's also import View from react native lastly we'll also import stylesheet let's set up the styles so we say const styles equals style sheet Dot create and we'll set an attribute called container we'll give this a flex of one let's now add the view to our component and we can apply the styles we also want to use our current weather component so we'll import this to start with we say import and say current weather and then we need to provide the path that we want to get the file from now all we have left to do is to render this inside of the component let's save this and check everything worked in the simulator everything looks good so before we go any further let's take a step back and review what we have just learned so far we have learned how to set up an app with Expo we have looked at how to create and import a component and we've also looked at basic styling for our components a component is a function that returns some amount of jsx the jsx is the syntax we use to make our lives easier for readability purposes but under the hood jsx gets turned into JavaScript by using babble and you can see more about the conversion here inside of our components we show or render something to show the user we can then export the component and use it elsewhere in our application when it comes to importing a component into another component we use the keyword import and relative path so we don't have to append the dot Js when we work with react native we are working with a framework that promotes lots of component reuse because it's a componentbased framework so in our application we'll usually have a root component which in our case is the app.js file and this acts as the entry point for the application but then we'll usually have multiple other components which are usually stored inside of a directory called components inside these components we may then import additional components so for example we may create a custom button and reuse it throughout our application as opposed to redefining it in multiple places as a side note you're able to have more than one component in a file but just having the one makes the code much easier to work with and this is very important especially when there's more than one developer working on a project so this componentbased architecture not only helps with debugging and easier testing but there's also a convention encoding called dry which stands for don't repeat yourself it's good to have this at the back of your mind when you're working with a componentbased framework so our app is going to have two additional screens one which will show the upcoming weather and one which will show some details about the local city to the user as we're still getting familiar with react native we're going to move on to implementing the initial layout for these screens first after we've done this we'll have a look at how to make them Dynamic by fetching data from the open Weather API and then we'll look at how we can wire up all these screens together with navigation so we're going to start by creating the component to show the upcoming weather we'll call this component upcoming weather so we can create a file inside of our components directory let's also create the boilerplate for our component so we say const upcoming weather equals and then we use a set of parentheses an arrow function and a set of curly braces we'll also make sure to export the component so we say export default upcoming weather we need to import react from react foreign safe area View from react native inside of the component we'll say return and we'll add a set of parentheses inside of the parentheses We'll add the tags for the safe area View let's also set up our styles so we add style sheet to the react native import then before our component is exported we say const styles equals stylesheet dot create we add some parentheses and curly braces we'll also create a container and we'll add this to the safe area View we'll give this Flex of one let's also add some text so we need to import this and now we can create the text we'll give this the message upcoming weather in order to check we've set up the component correctly we can view it in the simulator before we do this though we'll need to add the component to our app.js file so at the top of the file just like we did with current weather let's import the file now then in the render let's remove current weather and add the upcoming weather let's check the simulator we can see our component has been set up correctly and we get to see the upcoming weather text we added so what are our goals for this component well we want to be able to show the user a list and in the list we want to show the user the date and time an icon and what the weather will be at that time before we do this we need to have a look at how lists work in react native as showing lists to a user is a core part of working with mobile apps and it's something you're likely to come across very often so rendering lists inside of mobile apps is a common task you may find yourself presented with take a look at your favorite social media app or have a look at a news app because of the often limited screen size we have on a mobile device very often the information is displayed to us in the form of a list and we have to think carefully about how we go about using it in order to make the best of the screen space we have available to us so in react native when we work with lists we have a choice of a few core components that we can use primarily these are called Flat list and section list additionally we have virtualized lists but it's better to try and use the flat list or section list components because virtualized list is essentially a diluted version of these and unless you need a heavy amount of flexibility you should be able to fulfill your needs with the flat list or section list components so what's the difference between flat list and section list there are a few differences in the way you implement the two which we'll look at shortly but in terms of the end result if you simply have a list that you want to display to the user then you can use flat list we can take a look at the example on the react native website so we see three items in the list here if I try to scroll well not a lot happens however if I add a few more items to the list we can see what happens when the list is bigger I'll add three more items and just amend the title and ID properties slightly so now we see our longer list and we can scroll through the list here like so let's also have a quick look at section list so here we can see the list but we can also see how it's broken up into sections and each section has its own items so we have main dishes sides drinks and so on so the outcome here is that if you have a collection of data that you need to display to the user which needs to be broken into sections then you should use section list otherwise flat list will suffice so let's move on to looking at how these lists are implemented on the right hand side here I can see all the properties that are available to us to use however there are two of these props with a red dot next to them if we scroll down the documentation a bit we can see that these are marked as required so all the other props are optional but render item and sections are compulsory equally if we go ahead and look back at flat list we can see there are again a lot of props available to us but this time we have two marked with a red dot render item and data so the takeaway here is that both lists are heavily customizable but both have two things that you need to provide in order to implement them we are going to be using flat list in our app so let's start with looking more deeply at this one the first one of the required props is data and for this we need to pass an array inside of the array we have the data that we want to be displayed on the screen so if your list was showing a list of cars then you may have an array containing names of cars if your list was displaying a list of students test results then perhaps you would have an array containing the students names and their test scores with flat list you're able to Simply pass in an array let me update the code here to show this I'm going to remove all the objects and then I'll simply pass in the titles to the array so I'll also remove the title keys in the item function I'll also remove the reference to title and simply refer to the item itself so now when the list renders I can see the three items from the data array it's worth pointing out here that this is one of the differences between flat list and section list in that with Section list you must pass in an array of objects because of the fact the list is broken up into sections in reality when you're working with flat list because quite often you're rendering Dynamic data such as that from an API you're probably more likely to end up also passing in an array containing objects too so now we understand the required data property let's have a look at the second required property which was called render item the render item prop gets past a function and this will get called on every array element its job is to decide how that element then gets displayed to the user so you can think of it a bit like the List's own render function if the function for rendering the item is very simple we can place it directly in the definition for the flat list quite often though we end up passing it a reference to a function as we may want to render out quite a few things for our list element we pass a single argument to the function which is an object and this is the item you are rendering so if I refresh the screen and go back to the original example here we can see it renders the title from each item in the data array so if I added another property to the items in the data array let's say amount and then I pass that into the render item and render an additional piece of text to render the amount we then get to see that each item in the list renders this value too if you're working with Section list then render item Works in a similar way so before we move on and look at implementing a list in our app let's recap everything we've just looked at with lists we've learned that in react native we have two main core components that we can use when we're working with lists flat list and section list we know that flat list is more of a standard list but we can use section list if our data needs to be displayed in sections we then looked at what we need to do to get our list up and running we've seen that we must pass in some data which must be an array and if we're using section list then this must also be an array containing objects we've also seen that we must additionally use a prop called render item and we use this to display the list element to the user so let's now move back to our code and figure out how we're going to use a list so back in our upcoming weather component let's start by importing the flat list core component so inside the react native Imports we just say flat list now under our upcoming weather text let's use this so we start by typing flat list we know we need the required data and render item props so let's add these two obviously at the moment we have not yet set up our app to fetch any data so for now let's write this out by hand we'll start by declaring the variable for data outside of our component and we say const data and will assigned this the required array inside the array I'm going to just Place three objects as for now this will be enough before we wire up our app to use the real data later if we have a look at the open Weather API documentation we can see some examples of the data sent back to us there is obviously a lot we can work with here but for our list we're just going to be sharing the weather at three hour intervals and we only need a few bits of data from the response we'll want to use DT text for the current time the Min and Max temperature and a description of the weather so I'm just going to paste in some example code here and you can pause the video now if you're following along so now we have our data we can pass this into the flat list so we should have our data prop defined we use an equal sign and a curly brace and then pass in the data the next required prop we need to add is render item we're going to create a function to pass into this which will render what we want to show to the user in our case we're going to create a separate component for the item so we want render item to render the component that we'll be creating let's start by creating the component for the item I mentioned earlier that it's best to keep components in their own files but whilst we're setting up our list I'm going to create it in this file and then when we do some refactoring we can move it later so we're going to call this component item so we Define it just like we have with all our other components we say const then the component name which is item an equal sign an arrow and some curly braces we then say return with some parentheses we're going to be rendering the DT text min and Max weather and then the weather condition let's add these props now I'm going to Define props in the parameter and then using destructuring I'll pull these out so I say const a set of curly braces an equal sign and props this is a convenient and clean way to access props inside of your components inside the curly braces I'll add DT text men Max and condition now inside the return let's start by adding a wrapper or container so I'll add a view here inside the view I'll add three pieces of text in the first piece of text We'll add the DT text prop so I need to use curly braces because we're using a prop in the second I'll add min and in the third I'll add Max I'm also going to add an icon which will go above all the pieces of text I'm going to do this using Expo icons again so we need to import this under our react native Imports let's say import then we have our curly braces and inside this we say feather then we say from at explo slash Vector icons we're going to be dynamically using different icons based on the weather condition but for now let's just add one to the name Sun as we're going to need to create a file which handles some of the configuration for us later in order to correctly map the feather icon names with the open weather map weather descriptions so I add feather at the top of the view I then set a name prop which is equal to Sun we set the size to be 50. because we're using a list and we don't want the icon to be too huge and then we set the color to white so now we have our list item component let's create the render item function inside of the upcoming weather component so before the return keyword we say const render item and then we set this up like an arrow function so we use an equal sign parentheses an arrow and because we want to render something we'll use another set of parentheses for the parameter we want to pass in the item so we use a set of curly braces and pass in the item we need to pass the required props to the item component so we say condition and set this equal to be item Dot weather we use square brackets to get the element at the position of zero then Dot Main we set the DT text and this is equal to item Dot DT text we then set them in which is equal to item Dot Main Dot temp min and then Max which is equal to item Dot Main Dot temp Max now in our flat list all we need to do is pass in this function so we say render item and pass in render item let's save this and run the app in the simulator to see where everything is at so in the simulator we see the upcoming weather text but then we see the three items from the data that we passed into the flat list rendered on the screen obviously it doesn't look very pleasing but we can address that in a moment before we do that though there's one other thing we need to add to our flat list if we take a look back at the docs on the website we can see the example also include something called a key extractor what is this well let's read through the description it says it is used to extract a unique key for a given item at a specified index key is used for caching and as the react key to track the item reordering the default extractor checks item dot key then item.id and then falls back to using the index like reactors so to summarize when you're working with lists you need to provide a unique key to each element in the data the reason behind this is largely Performance Based and it means that under the hood react native is able to keep track of each item in the list imagine you're working with a really long list say one with over 100 pieces of data when something in the list changes for example if an element was deleted then because of the way react native works when the rerendering happens everything would get rebuilt from scratch by providing the key it means the different item changes this is not necessary and instead the list can be recalculated and as such that this can be updated rather than rebuilt the requirements for the key are that it must be a string and each element must have its own unique ID we can either add a key to each element in our data or we can use key extractor to add the key for us in our data we could go ahead and add keys to each item but because each item has its own DT text key and value which because it's based on a timestamp is unique for each item we're going to use that for the key so let's start by adding the key extractor to the flat list so all we have to do inside curly braces now is say item Arrow and item.dt text as a side note if you ever see this warning then it's essentially telling you that this is what you need to do to fix it before we move on to making our list look a bit better let's just have a quick look at some of the other props which are available to us to use on the list if we wanted so we have item separator component which is something that gets rendered between each item in the list this would be good for visual purposes if you wanted to add something that distinctly separates each item in the list let's try it out so I type item separator component an equal sign and then I'm going to add an inline function I'll add a view and now I'll add some Styles here so I say background color red and height two so now in the list I can see this is rendered between each item let's refresh the screen list empty component is another useful prop to know about it means that if the list is empty it will automatically display some other content to the user which is a great consideration if you are depending on data fetching so I start by creating a component called empty I'll give this a view and I'll add some text and for the text I'll just say empty now in the list I Define the list empty component prop and I pass in my empty component so now if I update the data array so it's empty we get to see this in action and I see the empty component instead displayed on the screen there's also a list header and list footer which means we could display either a header or footer in our list there's obviously a lot you can do with your lists and it's good to spend some time getting familiar with the documentation here and playing about with everything the main things you must remember though are that you need to provide the render item and data to the flat list and you need to provide a key of some sort to the data you don't need to worry too deeply about performance especially if you aren't working with a very large list because flat list only gets rerendered if the data changes and only renders the items currently displaying on the screen not everything at once but as you start to build bigger and bigger lists it's important to have performance at the back of your mind when you're building out the list so let's go back to our code and see what we can do to make everything a bit more visually pleasing the first thing you may have noticed when we check the simulator was that you could not see the icon the reason for this is that the icon color is white and we have not added any background color to our screen so this is currently defaulting as white 2. so let's start by updating the style attributes in our container I'm going to start by importing status bar to our react native Imports and inside the style sheet I'll add margin top and I'll set this equal to status bar Dot current height or zero this is basically a constant from the status bar component which means we're taking into account both platforms and saying to initialize with the current height of the status bar for Android or use xero next I'm going to set a background color to red now I'm going to set the view of the item to be Style equals styles Dot item I'll add this to the style sheet I'm going to set padding to be 20. margin vertical to be eight margin horizontal to be 16. I'm going to set a flex Direction of rho and justify content to be spaced around this is so the items in the row are evenly distributed I'll set align items to be Center border width to be five and also a background color to be pink next I'm going to set Style equals styles Dot temp on both the min and Max temperatures I'll add this to the style sheet I'll give this a color of white and a font size of 20. lastly our set Style equals styles Dot date onto the DT text and in the style sheet we'll add this we'll set color to be white and font size to be 15. let's save this and view it in the simulator we can now see everything and the list items are much more distinct we obviously have some way to go with this still but it's a good start the next two things that we're going to do are add an image to this component which will let us discuss how to use images in react native and then distract out the item component into its own component which will let us do a bit of refactoring and also talk a bit more deeply about props in react native but let's start by looking at how we go about using images in react native so in react native we have a few different options available for when it comes to working with images for example local or network images on the example on the react native website we can see both of these approaches in action so we can see the image core component imported and then used we can see that a source prop is set in the first image so this differs slightly from the web where you may use SRC and now we have the full word source a require statement is then placed followed by the path to the image the other way to load the image is by using a network image and this means we load the image from a URL instead this is more standard practice when you're working with API requests so we can see here we use the source prop again but this time we pass in an object with a URI key and the URL is set as the value there are a few other caveats worth pointing out when you're working with images if you're using a network image you need to explicitly State a height for the image you should also be aware of the supported types of images in react native additionally when you're sizing the images in general you can give the image a fixed height and width or you can use aspect ratio with height and or the width to size the image lastly it's worth being mindful of image storage sizes when you're using static images so not the network images as these will get bundled when you ship your application and if you have a lot of images that you can start to eat up memory if you've seen file names with 2X and 3X for images it's because it's standard practice to provide the same image in three sizes in order to account for the different screen resolutions so we're going to get an image to use for our app from website which provides royaltyfree stock images it's called pixabay if you navigate to the pixabay website and then search for clouds whilst you're welcome to use any of these images I'm going to use this one here so I'll select the image and then I'll select to download the image back in our app I store the image in the assets directory which is where we store static content so we could actually add another folder here for the images but I'm just going to add it straight into the directory so now we are ready to use the image at our upcoming weather component we need to start by importing the core image component inside of our react native Imports now inside the render under the text I'm going to add the image so I add image and the selfclosing tags I then type source an equal sign and some curly braces inside the curly braces I say require and a set of parentheses and then I type the path to the image I'm also going to set some Styles so I say Style equals styles Dot image I then set this inside of the style sheet so I say image here too I'll give this a height of 100 and a width of also 100. let's save this and view it in the simulator so we can see our image has rendered successfully the problem with this approach for us is that we're going to want to display the image as the background to the screen and we can't give children to the image component in cases like this there is another core component that we can use instead and this is called image background image background works much like image as the documentation here says you can add whatever children to it that you would like to layer on top of it that's the perfect behavior that we're looking for so let's go back to our code and we'll add in image background so back in our upcoming weather component let's change the import from image to the image background now inside the safe area view just before the text let's move our image here and we'll change it to be image background because this is now going to accept children we want to change it not to use selfclosing tags so we'll add a closing tag before the closing tag of the safe area View we're also going to change the styles to use flex of one lastly let's also change the background color in the safe area view to be something that blends in better with our image so we'll use royal blue here as a side note you can see all the colors available to use with react native here so we can see now we have our image background applied and our safe area view Blends in with the image much better so earlier in the course I mentioned we would take some time to understand what props are in react native if you've worked with react before then they're the same in react native for those of you who are new to react and react native it's important to understand props as they are a key feature of react native so what are props the term prop is just short for property so when you create an object in JavaScript you add properties to the object and you give the properties a value so for example if you created a dog object as dogs have legs then legs could be added to the dog object as a property and then given a value which most of the time would probably be for in react native we can think of props in a similar fashion they adjust properties which are given a value of some sort but they're used as way to pass our data down from the parent to a child so to visualize this a bit more clearly imagine we had a house component and this would be the parent we want the house component to render a room component this will be our child and we want this to render four times because our house is going to have four rooms when the room component gets rendered we want to be able to pass down the name of the person whose room it is so to implement this we would have the house component and every time you render the room we would set a room owner as a prop inside of the room component we would be able to access the Ramona prop and use this in some way so for example we could set a piece of text which would display the value of the Ramona so instead of creating four separate room components we just have the one and each time it's customized to our requirements so now hopefully we better understand that we can use props to customize our components when we added the image background core component to our upcoming weather component we used a prop called Source in order to set the image which would be displayed to the user core components inside react native usually come with props which can be used if I take a look at the text core component I can see the list of props available to us so for example I could set the Ellipsis mode or disabled the same was true when we worked with flat list and we had to set the data and render item props just like with the core components in react native we can use props in our own components and by doing so we can customize a component but it also means that we're able to make the component more reusable and component reusability is a key concept when you're working with react or react native so back in our app let's look at a little demo of this in action we won't use this in our final code but I'm going to create a file called our child dot Js we'll set this up like a basic component so I start by importing react from react I'll then import View and text from react native once the component is set up and exported I'll say return and then I'm going to use a set of parentheses I'll then render a view and also some text I'm going to use inline Styles here as this is just a demo so I'll give this a height of 200. and a width of also 200. and I'll also set a background color of red inside the text I'm going to want to set some text to display so this is where we're going to display a prop the prop will be sent down from the parent which in our case for this example will be the app.js file the name of the prop will be message so to display the value of the prop we need to use curly braces so I typed the curly braces and then the prop name which is message we also need to set the prop as an argument into the component itself and we do this inside of curly braces here alternatively we can just say props here and then destructure the value so now let's go back to our app.js file and here we can render the archile component for this example I'm going to remove the upcoming weather component temporarily so we need to start by importing the r child component and then we're going to want to use this three times each time we want to use a different value for the message prop so we start by adding the prop and then we use an equal sign and some curly braces inside the curly braces we can set the value the first one will say hello the second one will say greetings and the third one will say goodbye let's save this and view it in the simulator when the app runs we can see our child component is rendered three times and each time through the use of props the message is displayed with its different values before we review what we've just learned let's revert the app.js file back to what we need for our app so we'll delete the references to the r child component we will also put back the upcoming weather component lastly let's go ahead and delete the r child component just before I do this I want to point out one other thing with regards to file and folder structure we'll come back to this later but it's better practice once you start using components to have a directory structure where you have a folder for your screens in the app and then a component folder where you store your components so the screens are like the screen as the user will visually see so for example upcoming weather would be a screen but then we have a component folder where you store your components which are reusable components and the code for things like UI such as buttons and perhaps alerts or Footers so now let's delete the r child component before we move on let's just recap what we've just looked at we have just looked at what props are and how they let you pass in data from a parent to a child in order to promote component reuse in react native we've also looked at props with core react native components and also with custom components there are a few more points to consider when you're working with props and these are really really important to have at the back of your mind firstly props are immutable this means that they can't be changed once the component is created we pass the props from the parent to the child as we've just discussed we use unidirectional data flow when we're working with react and react native essentially this means that data is only able to move in one direction from the parent to the child the outcome of this is that our lives are much easier imagine if you're driving on a road and cars could drive in both directions you'd have a collision pretty quickly this would be the same scenario with our data so unidirectional data flow keeps things straightforward so now we are all much more familiar with how props work and we should hopefully now be becoming more familiar with react native itself let's take a bit of a pause and do some refactoring to the current state of our application in the last section I mentioned that one approach to structuring code is to split the code into components and screens and then I discussed the benefits around doing this as you start to use more components within your screens in this section we're going to do this then we're going to move the item component for the upcoming weather flat list into its own file inside the components directory we'll also do some other General refactoring so our code is a bit easier to work with moving forwards so to start in our SRC directory let's create another directory called screens now let's move the current weather and the upcoming weather components into this directory these components are core screens for our application so it makes sense this is where they are stored now we need to go through these files and check there are no Imports we need to update and then we also need to check the same thing in the other place these files are used which is in the app.js file it's important to follow this process every time you extract some code otherwise when you run the app you'll run into errors so let's try running the app in the simulator now to check that nothing has broken great everything looks okay the next thing we're going to want to do is to create a file for the item component which is rendered by our flat list inside the upcoming weather screen so inside of the components directory I'm going to create a file and for the sake of being a bit more descriptive I'm going to call this list item next I'll copy and paste the code from the upcoming weather component into the list item component I'll also need to update the Imports so I say import react from react and then I'll also import View and text from react native additionally I need to import feather inside curly braces from at Expo slash Vector icons then we also need to make sure the component is exported so it can be used within the upcoming weather screen so I say export default list item the next thing we need to do is import stylesheet into our react native Imports and then we need to set up the styles so before the component is exported I say const styles equals stylesheet Dot create then I need to use a set of parentheses and a set of curly braces so we're going to need to bring the Styles over from the upcoming weather component but obviously we only need to use the relevant Styles here so I'll need the item date and temp styles I'll grab these now and then I can also delete these in the upcoming weather component additionally I can now delete item in the upcoming weather component and then I need to change the render item to return the list item component as opposed to item we're already setting the props for the component here but let's check this is all properly set up in our list item component too everything looks good I see prop set as the parameter and we already have the destructuring for the props in place so now the last thing I need to do is import list item into the upcoming weather component so I say import list item from and then I add the path which is components slash list item I'll also remove the view from the react native Imports here as this is no longer needed for the sake of making our code as clean as possible we can also destructure our styles so before the return I say const then I use a set of curly braces and then I say equals styles inside the curly braces I'll Place container and image inside the render I can then remove the Styles and the dot for these attributes I'll do the same in the list item component so before the return I say const I use a set of curly braces and say equals styles inside the curly braces I place item date and temp inside the return I can then remove the Styles and the dot for these attributes let's save this and check everything has worked in the simulator so visually nothing has changed but we're now using the list item component from inside of its own file when we use render item inside the flat list before we move on to looking at how to wire up our screens with navigation there is one other screen we're going to implement this screen will show some details about the current weather location so let's set up the boilerplate for this screen now and then we'll look at what will be shown on the screen this component will be called City so inside of our screens directory we can create a new file and call it City dot Js inside the file we do our standard setup so we import react from react and then we'll import safe area View text and style sheet from react native then we'll set up our component so I say const City equals then I use a set of parentheses an arrow and some curly braces next I'll export the component so at the bottom of the file I say export default City inside of the curly braces I say return and then use some parentheses for now I'll just add the safe area View and inside this some text fill the text for now we'll just say City let's add some basic Styles here to get this set up so before the component is exported I'll say const styles equals style sheet Dot create I'll then add a set of parentheses and some curly braces next I'm going to add an attribute called container and I'll give this Flex of one lastly I'll add this to the safe area view so I say Style equals and some curly braces and then I just add styles Dot container now let's add this screen to our app.js file to check everything is rendering correctly so back in our app.js file I start by adding the import and then for now I'll remove upcoming weather and change this to show the city screen instead let's save this and check the simulator on the simulator now we can see that our new screen is rendering correctly so what do we want this screen to do well the city screen will be quite a simple screen it'll have an image background which will be City related and then it will show the name and the country of the city it will show the population of the city and also the time that the sun rises and the sun sets let's start by finding the image which we'll use for the screen's background image and then search for City just like with the upcoming weather screen you can use any image you want here but I'm going to use this one here so I'll select the image and then select to download the image once the image is downloaded I'll move it into my assets directory for Simplicity I'll also rename this to city background now let's go back to our city component we're going to start by adding image background to our react native Imports then inside the save area view let's remove the text we'll then need to add image background we know for the image background we need to add the source prop so let's do that now we say source equals and then some curly braces inside of the curly braces we say require and then add the path to our image we also know that we're probably going to want to add some styles for this so let's do that now too we say style equals and then we'll call this image layout so we say Styles dot image layout inside of our style sheet let's also add image layout here and we'll give this Flex of one whilst we're here let's also update the margin top of the status bar for Android just like we did in the upcoming weather component so we say margin top and then we give this the value of status bar dot current height or zero and then we need to add status bar to our react native Imports when we discuss this component I said we'll need the city name and Country and then we'll also add the population and then the sunrise and sunset times so let's start by adding two pieces of text for the city name and Country will hard coding these values for now so for the name I'll say London and for the country I'll say UK let's also add some styles for these for the city name we'll call the attribute city name and for the country we'll call the attribute country name let's add these to our style sheet so for the city name I'm going to say justify content of Center aligned self of Center font size of 40 font weight of bold and color of white next with the country name I'll say justify content of Center Airline self of Center font size of 30 color of white and font weight of bold before we go any further let's just stop for a moment and take a look at the styles for the city name and country name apart from the font size all these styles are the same we like to try and keep our code as clean and tidy as possible and when we start to see duplication it's a sign that it's possible that we could be doing something a bit better in react native we're able to pass in multiple styles to the style prop by using array notation so if you're working on the web you might use multiple class names but in react native we pass the array of the styles to the style prop and these will get merged into one object if you have any duplication in these Styles it will be the last definition that is used this approach is very useful if we have a theme and then we want to use that theme in multiple places but then we also have some additional unique styles to apply to so in the style sheet I'm going to create a new attribute called City text and I'm going to move everything inside of this I'll then remove font size as this is the value that will be unique for each bit of text inside country name and city name I'll remove everything except the font size now back in the render inside of the style prop for both of these pieces of text we need to add an array inside of the array We'll add City text but then we're also going to make sure that the city name and the country name also remain as this is where the font sizes come from so the next thing we want to add to our screen is the population for this we're going to show an icon of a person and some text because we want to be rendering both of these elements and also that we want them to show on a row we're going to wrap these inside of a container so I'm going to start by adding a view to the react native Imports and whilst I'm here I'm also going to import feather again so I say import then I use curly braces and inside the curly braces I say feather from at Expo slash Vector icons then I'll go back to the render and I'll start by adding The View inside the view I'll add feather and also some text so let's go and look for an icon that we can use with this component on the Expo icon site I'll search for a user icon and then I'll select this one here I can copy the details into the component I'm going to amend the size to be 50. and change the color to be red now in the text let's add another hardcoded value obviously this is way off for the population size for London but I'm just going to say 8 000 for now so to make sure these elements render in a row and to make the text look a bit better let's add some styles I'll set a style for the view called population wrapper and I'll set the style for the text to be population text let's add these to the style sheet so I'll start with population wrapper I'll say Flex direction of row align items of Center justify content of Center and margin top of 30. for the population text I'll say font size of 25. foreign left of seven point five I'll set color to be red and font weight to be bold the last details we need to add to this screen are the sunrise and the sunset again these are going to want to be rendered in a row and I'm going to want to use icons and text for both of these I'll start by adding a view and then I'll add feather and also some text and then I'll repeat this again so I'll add feather and also some text so let's start by going back to the Expo icon site and look for a sunrise icon this one looks perfect so I'll copy the details and I'll add it to the component let's also do the same for sunset so I'll navigate back to the Expo site and our search for sunset and then I can copy and add the details to the component for both icons I'm going to update the size to be 50. and I'll also update the color to be white I'm now just going to hard code in some values for the sunrise and the sunset times for Sunrise I'll say 10 colon 46 colon 58 am for the sunset I'll say 17 colon 28 colon 15. P.M now let's add some Styles here I'm going to add a rise set wrapper to the view container for these elements then I'll add Rye set text both pieces of text let's navigate back to our style sheet and we'll add in these attributes so I'll start with the Rye set wrapper I'll give this a flex direction of row I'll say align items of Center justify content space around and margin top of 30. let's also add the rise set text and this will have a font size of 20. a color of white and a font weight of bold let's save this and see where things are at in the simulator so when our app runs we're now able to see the city screen with the requirements we Define for the screen we have our image background and the city name and location we also have an icon for the population and some text for the population and then we have our sunrise and sunset images and text I keep going on about how we'll shortly look at navigation to wire up our screens and I promise we'll get there shortly I have a few last bits of refactoring I want to do to the current state of our application before we move on so firstly if we navigate back to our city screen and take a look at our component there are three places in the render part of this component where we use a feather icon and then a piece of text this is a great example of when we could extract out something to be a component we don't have any need to be writing this out three times instead we can have a component that renders this and accepts props for the image type and the text which we need to show so let's go ahead and do this now we'll start by creating a file in our components directory called icon text once this is created we can navigate to the component and set up our boilerplate so we say import react from react we know we need to show some text in this component and we also want to wrap this in a view so next let's import View and text from react native we also know this component is going to need some Styles so we can add style sheet to the Imports as well lastly let's add feather from at Expo slash Vector icons now we can Define our component so we say const eye context equals then we have a set of parentheses an arrow and some curly braces outside of this we need to export the component so we say export default icon text let's also set up our Styles before we export the component so we say const styles equals style sheet Dot create we then use some parentheses and some curly braces inside of the component let's say return and we'll add some parentheses next we'll add The View so let's go back to our city component we can copy the first instance of where the feather icon and the text is used together so where feather and text are used inside of the population wrapper I'll copy the icon and also the text next I'll go back to the icon text component and paste this in here so what props are going to need to be defined for this component I know I'm going to need to define the icon name and the color and also the text so we can set these props up now I'll change the name inside the feather element to use curly braces and then I'll pass in icon name I'll do the same with the color and then I'll pass in icon color then in the text also inside curly braces I'll say body text now inside the components parameters let's add props then at the top of the file we can anticipate these and use some destructuring so we'll say const then some curly braces equals props inside of the curly braces I'll add icon name icon color and body text now let's go back to our city component again if we take a look at the styles used for population text and write set text we can see these Styles differ a bit both use a font weight of bold but everything else is different so how are we going to go about handling this we can actually just pass these in as a prop as well so let's start with the commonality and handle the Bold font weight first so back in the icon text component in the text we'll say Style equals styles Dot text theme then inside the style sheet we can add the text theme attribute we'll say font weight of bold now if we go back to our city component we can remove the font weight of bold from the population text and then also the rise set text the remaining styles for these pieces of text will pass down to the child in a prop called body text styles so let's add this prop to the icon text component in the destructuring of the component I'll add body text styles now in the text I'll change the style here to accept an array as we're going to be passing in multiple Styles here inside the array I'll then add body text styles great so now we should all be set up to use this component inside of the city component so let's start by updating the population text section so inside of the view I'll add the icon text component next our set icon name and I'll set this to user then I'll add icon color and set this to red I'll set body text to be eight thousand and then body text styles to be styles Dot population text so now I can delete the feather and text elements here we need to repeat these steps for the sunrise and the sunset so I start by adding the icon text component at the top of the sunrise I set icon name to Sunrise icon color to White and body text to 10. 46. 58 am then I'll set the body text styles to be styles Dot write set text so now I can remove the feather and text elements for the sunrise let's do this again for the sunset so I add the icon text component again I set the icon name to Sunset icon color to white and body text to 17. 28 15 P.M then I'll set body textiles to be styles Dot rise set text now I can remove the feather and text elements for the sunset again let's save this and see where things are at in the simulator so when the simulator runs the app we see our city screen with the same components as before this time though we have a shared component for the icon and text so we have less duplication in our code it's really good to pay attention to detail when you're working with your code the layout for the text does not look centered under the icon so we should fix that let's go back to our code next let's go back to the icon text component we'll add a style attribute to the view so we can make sure the items contained within the view are aligned correctly so I'll say Style equals styles Dot container then I'll add this to the style sheet inside of the Styles I'll say align items of Center now if I go back to the city screen I'm going to create some shared styles for the population wrapper and the rise set wrapper in the style sheet I'll call this row layout inside of this I'll add Flex Direction of row and align items of Center I'll then remove these from the population wrapper and also the Rye set wrapper next I'll add a raise to both of the style props in the view elements and then I can add in the row layout for these in the inputs of the component let's remove the reference to feather as this is now no longer needed then let's do some destructuring for the styles so before the return in the component I'll say const then I use some curly braces and then I'll say equals styles inside of the curly braces I'll add container city name City text country name population wrapper population text rice set wrapper and Rise set text and then I'll go ahead and remove all the Styles and dots inside the render where these are used so now if we go back to the icon text component I'll also do the same thing here so before the return I'll say const then I'll use some curly braces and then I'll say equals Styles inside the curly braces I'll add container and text theme and then I'll also remove the Styles and the dots where these were used inside of the render so now let's save this and view this again in the simulator everything now looks good so the only screen we haven't yet looked at in terms of refactoring is the current weather screen if we take a look at this component now we can see there's a couple of instances where there's a view which wraps two pieces of text I'm also going to extract these to be their own component and I'm going to call this component row text so inside of the components directory let's start by creating the Rotex component once this is created we can navigate to the component and set up our Imports so I start by saying import react from react this component is going to need to use View and text so I'll say import View text from react native we're also going to need to add some Styles so I'll add the style sheet inside of the Imports now we can go ahead and Define the component so I say const bro text then I use an equal sign some parentheses an arrow and some curly braces outside of the curly braces I'll say export default bro text before the export I'll also set up the styles so I say const styles equals style sheet Dot create I'll use a set of parentheses and some curly braces now inside of the components curly braces I'll say return and I'll use a set of parentheses let's go back to the current weather and select the first instance of what we want to use in this component so I'll select The View with the high low wrapper and then also the text contained inside of it I'll go back to the Rotex component and I'll paste this in so I know I'm going to need two props for each bit of text so inside the first text I'll remove the text that says hi and then I use curly braces and I'll add a prop called message one inside the second bit of text I'll do the same thing again but this time I call this message too I'm going to want to pass in props for the styles for The View and also for both pieces of text in The View so I'll say Styles equals and then I'll add container styles in the first text I'll say Style equals message one styles and in the second bit of text I'll say Style equals message to styles let's update the component parameters to include props and then we can also add our destructuring to anticipate these props so at the top of the component I say const then I use some curly braces and then I say equals styles inside of the curly braces I'll add message one message to container styles message one styles and message two styles now let's go back to the current weather component and update this to use our Rotex component so I'll start by adding row text just before the view with the Hilo wrapper next I'll set up our props so I'll say message one and I'll set this to high colon 8. next I'll say message two and I'll set this equal to low colon six our set container styles to styles Dot high low wrapper and then I'll set message one styles to styles Dot Hilo and message two styles to styles Dot high low now I can go ahead and delete the existing View and text here next Above The View with the body wrapper I can follow these steps again so I add the row text and then I set up my props so I say message one and set this to it's sunny next I sent message two and I set this to it's perfect tshirt weather I then set container styles and set this to be styles Dot body wrapper and then I set message one styles to styles Dot description and message two styles to styles Dot message now I can go ahead and delete the existing View and text here too we need to make sure the Rotex component has been imported at the top of the file vs code has done this automatically for me when I started using the component next let's go back to our app.js file and in the render let's update this to show the current weather component now let's run the app in the simulator and see how everything looks when the app runs in the simulator it looks like something's broken debugging errors is a really important process to get to grips with when you're working with your code sometimes it's just figuring out how to approach a problem as opposed to panicking so how do we know what the problem is here well we know the only components we have changed are the city and Road tax components it's the Rotex component which is not showing on our screen so let's take a look at that first the render looks okay but when we destructured our props I set this to Styles not props so this looks like it'll be the cause of our problems here I'll change this from styles to props also we aren't setting anything in our style sheet so let's clean this up too I'll remove the style declaration and I'll also remove stylesheet from the Imports as it turned out we didn't need this after all let's save this and view the app in the simulator everything now looks good let's wrap up our refactoring by just doing one last bit of Cleanup in the current weather component for consistency I'm going to add destructuring to the styles used here so I'll say const then I use some curly braces and then I'll say equals styles inside the curly braces I'll say wrapper container temp fails Hilo wrapper high low body wrapper description and message then I'll go ahead and remove the Styles and dots inside of the render function let's save this and run the app in the simulator again now everything looks good and we have fixed the issue with the row layout not displaying so now we're ready to go ahead and look at wiring up our app with navigation when you're building web apps you can use anchor tags to link between the different pages if a user clicks on a link or a button to navigate to a new page then that URL gets pushed onto a stack which is essentially a data structure and in this case it will be called the browser history stack later when the user wants to navigate back then the URL gets popped off the stack and they're able to go back to the prior page where they'd come from when you use a mobile app it's quite unusual these days that it will only have one screen as they usually have more information to show a user however we can't use navigation in the way that we do on the web so we need some way to navigate between the different screens in our application in our app we have already built three different screens we have a screen to show the current weather a screen to show the upcoming weather and a screen to show the city details in order to navigate between the screens we need to use a navigator you might have noticed this before but the other consideration with navigation is how the navigation between the screens occurs so by this I mean the transition when you click something in an app to load another screen does the next screen then slide in from the right to the left or does it perhaps drop down from the top to the bottom as well as all of this there's then the different types of navigation to consider because perhaps we want to use tabs in the app to let the user navigate around in react native there's no builtin navigation so you have to use a library to add navigation to your app the two most popular libraries are react navigation and react native navigation while both of these libraries have the same end goal the implementation of the two differs the other consideration between the two libraries is that react navigation is built into Expo so if you created your app with Expo you can use it just fine however if you want to use react native navigation you would have to eject your app from Expo or you would have had to create your app without using Expo and I showed you how to do this at the start of the course so in our app we're going to be using react navigation and our goal is to implement tabs for the user to navigate between our different screens so let's start by installing react navigation to do this in the terminal we need to type npm install at react Dash navigation slash native next because we're using Expo we have some additional dependencies we need to install to get everything up and running if you're not using Expo you can see the additional installation steps required to get up and running with react navigation here so for Expo we need to run npx Vo install react Dash native Dash screens react Dash native Dash safe Dash area Dash context so once everything is installed we need to set up a navigation container this will wrap the entire application and usually we'd only do this once in the application and we do it at the root of our project so we're going to add this to the app.js file so we start at the top of the file and we say import next we use curly braces and we need to make sure we use a capital N and we say navigation container and this is imported from at react Dash navigation slash native next inside the render at the top we need to place a navigation container then we close this at the very bottom of the render so that it contains everything at the start of this section I discussed how on the web we push and pop items off of the stack with react navigation we follow a similar idea except that we do this via a navigator so the screens can get pushed and popped off of the Navigator there are two types of Navigators we can use and this depends on our requirements essentially if we don't want the user to navigate to a screen using a tab then probably we'll want to use the stack Navigator so let's look at some examples to show this a bit more clearly if I load this example on snack from the react navigation website I see a settings screen if I click the button that says go to profile and then navigated to the profile screen next if I then click the back icon the profile screen is popped off of the navigation stack and I'm back on the settings screen for this kind of navigation you would want to use a stack Navigator at the bottom of the screen there are also some tabs when I select one of these the screen the user sees changes and this is the behavior I want for our application if you want to explore more deeply all the kinds of navigation available to use with react navigation then you can visit this GitHub repository and then you can navigate to the example section if you load this then you can play about with everything so for our app as I said we want to use tabs to let the user navigate between the different screens it's up to you when you create your app to decide where you want the tabs to show as you can show them on the bottom of the screen or the top of the screen there are some platform considerations to bear in mind here too as often on Android you have tabs at the top of the screen and on iOS you have them at the bottom in our app we're going to display the tabs at the bottom of the screen but if you wanted to show this on the top for Android and the bottom for iOS you would need to set up material top tabs and then decide which to display based on the platform you can access the platform the user is using by using the platform API from react native and then you can use the OS property so back to our tabs we need to start by installing the bottom tabs so we say npm install at react navigation slash bottom tabs once this is done if we go back to our app.js file we can import this so underneath the import for the navigation container we say import then we use curly braces and inside the curly braces we say create bottom tab Navigator and then we say from at react navigation slash bottom tabs next before the component is defined we need to say const then using a capital T we say tab equals and then we say create bottom tab Navigator and follow this with parentheses by doing this we're initializing the tab object so that we can use it next we want to wrap all our components inside of the tab Navigator so inside the navigation container we say tab Dot Navigator and then we close this just before the closing navigation container so next we're ready to go ahead and add our screens so I say tab Dot screen and then I set the component name so I say name equals and as a string I add the component name and so the first one for us will be current and next I add the component so I say component equals and then I set this to current weather then I repeat this again for the other two screens so I say tab Dot screen and then I set the component name which is upcoming and I set the component to upcoming weather lastly I say tab dot screen and this time I set the name to be City and I also set the component to be City so now we should have just set up the three screens for our app let's save this and see what things are looking like in the simulator when the simulator runs the app we see a screen with an error the error says a screen can only contain screen group or react fragment as its direct children so clearly we made an error here the only file we've changed directly is the app.js file so let's go back to that file and take a look so when we set up our tabs we did not remove the view container this is neither a screen group or react fragment so let's remove that I'll remove the view then in order to keep things tidy I'll remove the view from the react native Imports I can also remove the styles that were used for this there are no other styles set now so let's also remove the stylesheet Declaration and then also the import for style sheet let's save this and run the app in the simulator again this time the app loads and I can see the three tabs set up when I click through the tabs I'm able to navigate to the different screens on our app it doesn't look very pretty though so we'll go ahead and start looking at how to make this look a bit better so there's lots of configuration options available to us with react navigation as we can see here in the documentation we can set a tab bar icon if we look a bit more deeply into the documentation you can see there's a wealth of other things available too so we can set labels and positions and so on in our app we already have the name showing on the tabs for the different screens but we're going to customize things a bit further we're going to set an active and an inactive color for the tab bar then we're also going to set icons for each of the tab bar items as we can see in the documentation we set the active and inactive tint colors on the Navigator and then we set the icons in the tab so back in our code in the tab Navigator we're going to say screen options then we'll use an equal sign and some curly braces inside the curly braces we use another set of curly bracers and then we say tab bar active tint color we're going to set this to the string tomato next we'll say tab bar inactive tint color and we'll set this to be Gray for the tab icons we're going to use some icons again from feather and Expo icons so we'll start by importing this at the top of our file we say import then we use some curly braces and inside the curly braces we say feather then we say from at Expo slash Vector icons so to set the Taber icon we can use the tab bar icon property as it says in the documentation we can use it on our screen components in the options prop although for their example they've placed it in the screen options prop of the tab Navigator in our implementation we'll be using it in the screen components options so in the first screen I say options then I use an equal sign and then I use two curly braces next I say tab bar icon and for the parameter I'm going to pass in focused this is because we're going to want to set a different color for the icon depending on whether the tab bar icon is or is not selected next I use an arrow and then some parentheses inside the parentheses I'll render the feather icon so I just say feather I've already selected the icons for the tabs here so I'll say name equals and inside curly braces I'll set this to be droplets our set size to 25 and inside color if the icon is focused we want to return tomato otherwise we want to return black now we need to repeat these steps again for our other two screens so in the screen of the upcoming weather I say options then an equal sign and two curly braces next I say tab bar icon and for the parameter I pass in focused then I use an arrow and some parentheses next I set up the feather icon this time for name I set it to be clock I'll set size to 25 and for the color I'll say if focused then show tomato otherwise show black then for the city screen we do this again so I say options and I use the two curly braces inside of the curly braces I then set the feather icon up I set name to home size to 25 and for the color I say if it's focused use tomato otherwise use black so now the tab icons and styling should be set up let's save everything and see where things are at in the simulator so back in the simulator we see all of our tabs set up with the tabs and the icons everything should now be running correctly in order to make our code a bit easier to follow I'm going to extract the tabs into their own component and then I'll import this into the app.js file so inside the components directory we'll create a file called tabs.js next back in the app.js component I'm going to copy all the Imports and the initialization of the tabs then I'll paste this into the tabs file now I can go ahead and create the component so I say const tabs equals then a set of parentheses an arrow and some curly braces inside the curly braces I'll say return and I'll use some parentheses outside of the component I'll say export default tabs now I'll go back to the app.js file and I'll copy everything related to the tabs next I'll paste this into the tabs.js file back in the app.js file we can now delete all the code related to the tabs now if I go back to the tabs component I need to update all the Imports for my screens as we're now inside of a directory and not at the root of the project back in the app.js file I can then delete all the Imports which are now not needed lastly in the render I can just pass in the tabs component so now everything's much more readable let's save this and view it in the simulator thing looks good and we see the tabs in the simulator still when I click on a tab it changes color and our tab code is extracted into its own component so everything is nice and tidy if we go back to the code for the tabs component you may see an eslint warning I'm going to just disable this warning for this file as we need to follow the react navigation requirements and set up our tabs in this way so before we move on let's add a few more customization details to our navigation in the header bar I get the same name as I do for the tab name so we don't need to change this but I'm going to set the background color of the tab bar and also the background color of the header bar after that I'll go ahead and add some more styles to the font used in the header bar so in my screen options for the tab Navigator I'll say tab bar Style and then I'll use an object inside of this I'll say background color and I'll set this to light blue this is all one word and all lowercase next I'll set another property called header Style and I'll also use an object here I'll set the background color also to light blue then I'll set a property called header title Style and I'll also use an object for this inside of this object I'll say font weight of bold font size of 25 and color to be tomato let's save this and check things out in the simulator so now we can see our tab bar and header bar both have a matching background color the font in the header bar is a bit larger and bolder and the color of the selected tab matches the color of the header bar title there's a ton of customization options available to you with react navigation so I strongly advise you spend some time getting familiar with the documentation you can see a bit more about the header bars here so we're shortly going to move on and look at State and then data fetching in our app after that we'll look at using the real data in our components in order to prepare ourselves for this though there's one more file I'd like to implement in our current weather component we currently have an icon and a message description set for when the weather is sunny in the completed app we're going to show a different icon and a different message based on the weather additionally we're going to change the background color of the screen to represent the different weather we'll base these different states on the weather conditions provided by the open weather map API so we're going to create a file which contains these conditions and then the icons message and background color which should be shown for these conditions so we'll start by creating a directory to store this which will be called utilities so let's do that now in the SRC directory we'll create a new directory called utilities then we'll call the file which will store these properties and values weather type inside the file we need to create an object so we say export const weather type and then we set that equal to an object because of the data provided by the API we need to capitalize the weather types we'll start by creating the objects for each of the weather types the first one is called thunderstorm the next is drizzle then we set rain next we'll set snow then clear clouds Haze and mist so let's start by setting up the thunderstorm type we'll set an icon and give this the value of the string zap next we'll set a message and we'll set this to the string it could get noisy and then we'll set a background color to the black hex color value of zero zero zero zero zero zero note that this is passed in as a string so the next one is drizzle this one will have an icon of cloud Dash brain then for the message we'll say it might rain a little then we set the background color to 364 54 f for rain we'll set the icon to Umbrella and then for the message we'll say you will need an umbrella and the background color will be zero zero zero 0 f f for snow we'll set the icon to Cloud Dash snow for the message we'll say let's build a Snowman and the background color will be set to 7 F6 zero six five next for Clear we'll set the icon to Sun and we'll set the message to it is perfect tshirt weather and the background color will be set to e47 two zero zero now for clouds we'll set the icon to Cloud we'll set the message to you could live in the clouds and then the background color will be set to 363 636 now for haze we'll set the icon to wind and the message will say it might be a bit damp and then for the background color we'll set this to 585 8 6 e and then lastly for mist we'll set the icon to align Dash ify the message will be set to it might be hard to see and then the background color will be set to 3e3 e37 right that was a lot of typing but now we can try this out even though we don't have any real data yet being used if we go back to the current weather component we can start by importing this file as we're not importing a component but we're importing an exported object we need to use curly braces so we say import and then we use curly braces inside the curly braces we say weather type and then we import this from utilities weather type so let's test this out on the weather condition message so inside the last row text component inside the message to prop we can just say weather type and then use square brackets and let's try out the message for the Thunder weather condition so as we're using square bracket notation here we pass in the string let's save this and see what things look like in the simulator so now we're going to move on to some of the more deeper topics in react native and we're going to take a step back from our app just for a bit in order to take the time to learn some of the details required to successfully make our app more dynamic Dynamic is the key word here so far in our application everything has been static this means that we have all our screens and all of these are now wired up with navigation but nothing in our app really does anything except display values to the user which we have hardcoded in ourselves if this is all you wanted to do then you only need to use props just like we have and you can pass your data around from parent to child components but isn't the real excitement of making applications these days how interactive we can make them and how fun we can make the experience for the user when was the last time you enjoyed using an application either on the web or on mobile that only functioned in this way with react native and react we're able to make the user experience super interactive and update and respond to users input so given this intention props are only half of the story the other half is state is what I'm going to introduce you to now so what is state to put it simply state is an object and this object contains data about the component that for some reason we decide we need to keep track of within our application in the object we Define key value Pairs and these key value pairs are the way in which we track a single piece of data that over time is going to change let's visualize this a bit more if we go back to the house example from when we looked at props using the props we pass data down to each of the rooms in the house using State though we can be inside a room and keep track of something that is going to change in the room so perhaps we want to keep track of the messy state or maybe we want to keep track of whether the room was dark so we could track the value dark as true or false or maybe we know a massive storm is incoming so we want to keep track of whether or not the room is wet the benefit of state within a react native or react application is that it means things can change they can be added modified and removed and we as the developer can work with this more easily and update our internal data and Trigger UI updates based on these changes there is one very key point to be aware of here though when the data in our component changes the component will rerender so to emphasize this point when a component first renders on the screen to the user we have what is called an initial render if we're using State and some of this state changes then the component will rerender itself so let's look at this through our room example when the storm is possibly incoming our room component renders on the screen when it first loads we have a wet State and this is set to force later the storm happens our room gets flooded this causes the wet state to get set to true consequently the room component then rerenders in the world of coding this sort of change might be more likely to occur based on a user event such as a button press or perhaps some sort of user input such as typing something into an input field it's totally fine if this all seems a bit overwhelming or confusing right now it can be a lot of information to process let's stop for a moment and summarize what we have just learned we have learned the state as an object that is used to keep track of data about a component we've learned that by using State we can add remove or modify things in our component more easily and then we can trigger UI updates based on these changes additionally we've also learned that when State changes it causes the component to rerender so let's just be very clear now on the difference between props and State props let us pass data between the components where a state lets us internally manage the data within a component you therefore can't modify the state of the component outside of the component in this sense it's a bit like when you're working with local scope in JavaScript of course with vanilla JavaScript you can make things Dynamic but the benefit of working with react native and react is that a lot of the hard work is done for you and you just have to provide initial values and then consider how you would like this value to update and then also be displayed to the user if and when your state grows you need this to be at an application Level then you can also access libraries to help you manage this such as Redux but that is out of the scope of this course so we're going to continue our journey with state by creating a simple counter component which won't be in our final app but will hopefully solidify our understanding a bit more here we'll start by creating the component without using state so hopefully we can better see why we need State and then we'll add state to the component so inside the SRC directory I'm going to create a new directory called demonstration you're welcome to keep the code in this directory for reference purposes or delete it in the final project at the end of the course but it saves us from having to create a new app for any demonstration code which we'll make during the rest of the course so in the SRC folder let's create this new folder called demonstration now inside of this folder I'm going to create a component called counter.js we'll set this up just like we have with our other components so we'll start by importing react from react next we'll import View text button and style sheet and we'll import these from react native now let's go ahead and create the component hopefully you're getting used to doing this now but we'll start by saying const counter and we'll follow this by an equal sign some parentheses an arrow and some curly braces outside of the curly braces we'll export the component so we say export default counter inside of the curly braces will say return and we'll use a set of parentheses then before the export we'll create our style sheet so we say const styles equals style sheet dot create and then we use some parentheses and some curly braces so let's set up our component before the return I'm going to create a variable which will store the value of count so I say let count and I set this equal to zero now inside of the return we can create a view then we'll also create some text inside of the text we're going to use a template literal and interpolate in the count value so we use curly braces and then some backticks we say count and a colon then we pass in the count variable next we'll add two buttons for the first button will set color to red for the title will say increase the count and then we set on press for this we use an array function so we use some parentheses and an arrow for the first one I'm actually going to use curly braces because there's a little bit more I want to do here so firstly I'll increment the count so I say count plus plus and then I also want to add a console log to print out the value of the count variable for the second button we'll set the color to Green for the title we'll say decrease the count and for onpress I'll just pass in an arrow function which will decrement the count let's add a couple of styles on The View we'll set a container so I say style equals Styles Dot container and for the text I'll set some Styles called title so I say styles equals styles Dot title in the style sheet I'll set the container I'll give this Flex of one and background color of Orange next I'll set the title I'll give this a line south of Center and font size of 25. and then I'm going to set a margin top of 25. we also need to be able to see this component on the screen of our app so let's go back to our app.js file I'm going to start by importing the counter and I'll do this from dot slash SRC slash demonstration slash counter temporarily I'm going to remove the tabs from the render in the component and replace this with the counter now let's load the simulator we now see our counter component on the screen we see the two buttons and also the text which displays the counter value great so let's now click the button to increment the counter so it looks like the button was pressed successfully but the count value has not updated on the screen let's dig into this bit more and we'll check the Contour log we added so it looks like this did increment I'll press the increase button again we now see two so the counter value is definitely increasing but the text that displays the count on the screen is not showing the correct count so the reason for this is that react does not rerender a component when the value of a variable changes if this happened we would end up with rerenders happening all over the place and it would result in a really bad user experience I mentioned when we looked at state that when we use State and the state changes the component rerenders so this is a great example of a use case for state we'll look more deeply at hooks in a bit but we're going to use a hook provided by react called you state in order to fix our problems here for now you can think of a hook as functions that we can use inside of our function components all of the components we have made throughout this course have been function components so to start off we need to import the use date hook we do this when we import react so in the react import we add a comma and then some curly braces inside of the curly braces we say you state now when any values we use with the ustate hook are updated then react will ensure the component also gets updated to reflect these changes to the user so now we need to update the Declaration for our count variable and use the use State hook instead so let's delete the variable and we'll start again this time we use the hook so we say const and then we use square brackets and we say equals use state inside the square brackets I'll say count and then set count lastly inside the parentheses for the U state I'll set the value 0. so when we use the use date hook we're setting up some piece of State for our component when you state is set up we need to pass in the initial value for what the state should be so if we were implementing the flooded room example here we might have to set this up by saying is flooded and set is flooded and then in the parentheses we would have said false for the initial value we want the counter to start at zero which is why here we're passing in zero we can pass in any of the data types required for our needs though so this could also be a string or an object and so on the square brackets where we have added count and set count are simply using a ready structuring the first value in this is the count and this tracks the value for the count but we never directly change the value of count instead we use set count which is a function and into this we pass what we want the new value for count to be so let's go ahead and update our component to use this in the first button I'm going to remove the console log and also the incrementing of the old count variable then I will say set count and it will pass in count plus one so we aren't modifying count here we're just getting the value of count and then adding one to it in the second button I'll say set count and this time I'll pass in the value of count again and then minus one let's save this and go back to the simulator now let's press the increase button the count displayed on the screen updates to show our new count now let's press the button to decrement the value the value on the screen now decrements so now we have successfully worked with State for the first time let's recap what we have just learned when we want to use you state in a function component we can use a hook called you state we never directly change the value for the state but we can update it buyer a function that enables us to update the state we use array structuring for the ustate hook and inside this we have the value for the state and then the function we use to update the state and inside this we have the value for the state and then also a function that we can use to update the state inside the parentheses a view State we also set the initial or default value for the state before we move on in the last section I introduced you to Hooks and I want to go over these in a bit more detail and then I'm going to move on to showing you another hook which will help us with our data fetching back in the older days of using react and react native in the most part we had two types of components that we could use these were called stateful and state less if we wanted our component to use state in some way we would create a stateful component if we did not need to use state in our component then we could use a stateless component a stateful component was a class and the Syntax for a class component looks like this we can still create class components in react day so they're worth knowing about and you may very well come across an older code that uses them when you use class components you can access what are called lifecycle methods lifecycle methods are essentially events that occur during the life cycle of a component it's a little bit like key events that occur during the life of a human a human gets born they have an annual birthday and later in their life they pass away when a component is created it is mounted and the lifecycle method for this event is called component did Mount when the component updates another lifecycle method is called which is named should component update and this lets you control when the component should rerender just before the component is destroyed another lifecycle method is invoked core component will unmount when you're using a class you can tap into these methods and during these events you can add some additional functionality if you want to read more about lifecycle methods you can find some details here as react has evolved there's been a tendency to move away from using class components and these days function components are favored when components were either stateful or state less this wasn't very practical but in react 16.8 hooks were introduced hooks provide us with a way to use the features we depended on classes for like State and life cycle methods but from inside of our function components you can think of hooks like special functions or pieces of reusable logic which are separate from our component tree but that let us add functionality to our function components when we use hooks we can isolate all the logic from the component in a readable way but we can use them within our component you can read more about hooks here every hook in react starts with the word use and we've just seen an example of this when we looked at the use statehook there are a couple of rules you should be aware of when you're using hooks though firstly you can only call hooks from react functions like our functional components you can't just use them wherever inside normal JavaScript functions additionally hooks must be called at the top level of a component and before the return keyword is used we'll see more about this later but aside from react hooks you can also create your own hooks and these hooks can call other hooks we're going to move on now to introducing ourselves to another Hook from react could use effect after this we'll return back to our app and start looking at data fetching the use effect Hook is extremely powerful but it can also seem quite overwhelming when you're first looking at it if you can understand how to use the use effect hook properly then you can do all sorts of things with your application let's start by looking at the documentation so it says the effect hook lets you perform side effects in function components the example also goes on to state that it's similar to component did Mount and component did update let's break this down a bit to start with what is a side effect well it's when we use something not inside of react within our component so examples of these sorts of things are fetching data using timer functions and updating the Dom directly we also know that component did Mount happens when the component is first mounted and component did update is called after updating occurs so use effect essentially lets us replicate these lifecycle methods and it means we can perform side effects like fetching data from within our function components so let's go ahead and look at the basic Syntax for the use effect hook if we look carefully we can see that use effect takes in a function as an argument and it's inside of this that we can write our side effects let's add the use effect hook to our counter example so we can understand things a bit more deeply so inside the counter component next to the use date import we need to start by also importing use effect next under the ustate hook we can use use effect so we say use effect and then we pass in a function now inside the function let's add a console log for the count so I say Contour log and then inside this I'm going to use backticks and then I'll say our count value is and then I will interpolate in the value of count now let's see this in action in our simulator I'll start by reloading the screen so now in the console log I see the initial value of count printed to the screen every time I click one of the buttons as the component is rerendering here I see the new value of count printed to the screen too so we could be doing anything in here that we want to happen as soon as the component first renders such as fetching some data right now we're also repeating the code inside of here every time that the component rerenders if we take a look at the react docs again we can see that use effect also takes one other parameter called dependencies which it compares to the lifecycle method component did update it says on the documentation that you can tell it to skip applying an effect if certain values have not changed between renders to do so you pass an array as an optional second argument to use effect so to summarize this a bit inside of this array we pass in all of the values that the side effect inside of use effect relies on in our example we're console logging based on the value of the count so we need to include count inside of the dependencies array this now means that the code inside of use effect will only run if that value has changed between renders if we do not pass in the dependencies array then the code inside of use effect will run after every render let's look at this in our demonstration I'm actually going to add two new buttons to the component I'll just copy and then paste the first two buttons next I'll create another count and set count with a new use date hook I'll call the state variable here new count and then for the function to update the state I'll call it set new count and then I'll update the on press inside of the new buttons to call set new count so now inside of the use effect I'm going to change the console log to just be count changed let's run this in the simulator when the screen loads I get count changed printed to the console every time I press any of the buttons I see the count change console log printed to the screen again so now let's go back to our code and we're going to pass in a dependency array inside of the dependency array I'm going to pass in count now let's run this again in the simulator so I get the console log printed to the console when the screen launches this time though I only see this printed of screen again when I click on any of the first two buttons which use count I don't however see it printed to the screen when I press any of the buttons that use new count so the effect only runs when count changes otherwise it just sits there and it doesn't do anything again the last thing you need to be aware of when you are using use effect relates to the component we'll unmount lifecycle method and it's called the cleanup function this cleanup function allows us to turn off or clean up our side effects so for example if you're using a counter we would need to use the clear interval function to stop the counter and this is where we would place that and by doing so we can avoid memory leaks to use a cleanup function we type return and then we use an arrow function followed by the cleanup we would like to perform we can see an example of this on the react documentation again as the documentation says react performs the cleanup when the component unmounts so we don't really have any cleanup we need to do in our example but I'm going to add a console log here to show how this works so back inside of our code and inside of the use effect I will say return and then I use some parentheses an arrow and some curly braces then I'll just Contour log a string which says use effect clean up let's save this and go back to the simulator now when I click one of the buttons which triggers a rerender I also get the console log for the cleanup log to the screen because the cleanup is called before the next use effect runs so before we move back to our app let's do a bit of recapping about everything we've just learned with use effect we have learned that use effect is a hook provided by react which lets us run code that has side effects we've seen that it takes a function with the code to run then we saw that you can also pass in a dependency array which lets you specify what data when changed that you would like to trigger a rerender lastly we looked at the cleanup function that we can use with use effect to run any cleanup and stop any of the side effects before use effect is called upon a new render and when the component is unmounted so now we have some understanding around Hooks and use State and use effect so we're ready to go back to our app and think about our next steps with our weather application so back in our app we have a few things that we're going to do now in order to make the app dynamic to start off inside the app.js file I'm going to reset the code to use the tabs inside the render and I'm also going to delete the import for the counter I'm going to break down the next steps we need to achieve the first thing we're going to do is Implement a loading state for when the app first launches and the data is being fetched this is so the user sees something during this process it's always good when you're making applications to consider all the various loading and error states that the user might encounter after this we're going to look at fetching the data from the open weather map API and this will be broken down into two parts getting the user's location and then fetching the data so let's start first with the loading state as I mentioned we want to start the app in the loading State until the data from the open weather map API is successfully fetched once it is fetched we'll set the loading state to false and navigate the user onto our weather related components for our loading State we want to display to the user a spinner instead of having to manually create this react native has a core component that does this for us it's called activity indicator let's have a look at the documentation so we can see the activity indicator displays a circular loading indicator to the user and we can customize the size and the color of the spinner on the documentation we can see a few of the activity indicators in action with the different sizes and colors set so let's go back to our app and we'll start to set this up so inside the app.js file we'll start by importing the activity indicator after the react import I'll say import then I'll use some curly braces and inside the curly braces I'll say Activity indicator and I'll import this from react native next in order to set the loading State we're going to use U state so in the react import I add a comma some curly braces and then inside the curly braces I say use state now this is imported we need to set up you state so before the return inside of the ACT component I say const I use some square brackets and then I say you state with some parentheses I'm going to call this piece of State loading so inside the square brackets I'll add loading I'm going to call the function to update the state set loading so I'll add this too then I'm going to set the initial state for our loading State as true this means when the app first launches the user will see the activity indicator then once the data is fetched we can set this to force and then they'll see the weather components so now in the render we need to have a way to say if the state is loading then show the activity indicator otherwise show the tabs there are a few ways we can Implement conditional rendering in react and react native knowing about if else statements ternary operators and also the logical and operator is useful when it comes to handling these scenarios and you can read more about these here in our case for now we're going to keep this very straightforward and just use an if statement which renders the activity indicator when the loading state is true if the loading state is not true then the navigation container and the tabs will be rendered so inside of our app component I'm going to say if loading then inside the parentheses here I'll say return and inside the return I'm going to add a view and then also the activity indicator so we're wrapping the activity indicator inside of a view here so we can better control the layout for it for our activity indicator we're going to say size equals and then we'll set this to the string large and we're also going to set the color so we say color equals and then we set this to the string blue we also want to set a couple of styles for the view just so we're sure we're setting the layout for the activity indicator to be in the center of the screen so in the view I say style equals styles Dot container now in the react native Imports we need to add the view and the style sheet before the component is exported let's set up the style sheet so I say const Styles equals stylesheet Dot create and then I pass in the object I'm going to set the container and for this I'm going to say justify content of Center and flex of one let's save this and see how it looks in the simulator when the simulator runs I see the loading spinner in the center of the screen if the loading state was set to false I would see the tabs and our weather screens so next we're finally ready to look at getting data from the API so in order to get data from the open weather map API we need to start by calling the API let's take a look back at the API documentation on the open weather map website for our app we want to display the current weather but also the upcoming weather so we're going to use the five day three hour forecast if I click on the API documentation here it shows us how to make the API cool as we can see there are a few things that are required to make this successfully we will need the latitude and the longitude which a geographical coordinates for where we want to display the data from and then we're also going to need our API key let's start by figuring out how we'll get the latitude and the longitude the technical term for finding Geographic data such as coordinates is geolocation if I search for react native geolocation we can see that this has been deprecated and we should use one of the community packages instead if I click on the link we can see that there are a variety of packages available so this is useful if you did not create the app with Expo and it's also something to know about in the future but as we created the app with Expo we're able to use a package called Expo location let's take a look at the documentation for this so as it says Expo location allows reading geolocation information from the device this sounds exactly what we're looking for let's start by installing it so in our terminal we need to say npx Expo install Expo Dash location now if we go back to the documentation we can see all the extra configuration and then there's also steps provided if you're installing the project in a bear react native project in the example provided we see that we have to complete two steps in order to get the user's location firstly we have to ask for permission to access their location and then we need to get their location once we have their location we need to store this we also need to be mindful of handling any errors in case we were not able to access the user's location so for implementing this successfully we're going to need to use you state in order to store the location and any errors and then we're also going to need use effect so back in our code let's start by importing use effect next we'll set up two pieces of State we'll do the location first so we say const then we use square brackets and we say equals use state inside the square brackets we'll say location and then set location we're going to initialize this with null now for the error we need to set up another piece of State so we say const then we use square brackets and we set this equal to U state this time in the square brackets we'll say error and set error and then we'll initialize this with null next let's set up the use effect so before the return we say use effect and then into this we need to pass a function we're going to pass in a function which needs to be immediately invoked so inside of the curly braces we use a set of parentheses next we say async this is so that JavaScript knows we're using an asynchronous function here then we can set this up as a function so we use parentheses an arrow and some curly braces inside the curly braces we say let then use curly braces and we set this equal to await location Dot request foreground permissions async make sure you capitalize the location here we want to access the status so inside the curly brackets we're going to place status next we handle the error using an if statement so we say if status does not strictly equal granted then we use our set error State function and we set this to the string permission to access location was denied and then we say return now outside of the if statement we can continue with the rest of the code for if the request for permissions were successful so we create a variable using let called location we assigned to this await location Dot get current position async into this we pass in an empty object lastly all we need to do is update the location so we say set location and into this we pass in the location then as we want to immediately invoke this at the end of the function we use a set of parentheses inside of the use effect we'll pass in an empty array for the dependencies this means there's no dependencies and that use effect will only run once when the component is first rendered in our component we're just going to add a console log for now and we'll say if location then console log location before we test this we need to ensure location is enabled on the simulator or emulator you can see more information about how to do this in the documentation here let's go ahead and test this out in the simulator when the simulator runs we see the permission request which we set up when I click on allow while using the app and then launch the console I then get to see the location data which includes the latitude and longitude which we were looking for it's worth knowing here as a side note that when you're using a simulator the location defaults to San Francisco as opposed to your real location so now we have this let's look at getting data from the API at this point it would be helpful if you're signed in on the open weather map API website thank you to start with I'm going to navigate back to the five day three hour forecast and then I'll open the documentation here next I'm going to copy and paste the URL for the API call that we're going to need as we're going to need that shortly for now I'll just paste this at the top of the app.js file so we need to think about how in the app we're going to store the API key it's always best practice and safer not to expose any secrets in your application and import them from an external place this is even more important if you're using Source control like GitHub because you don't want these keys to be visible to anyone there are a few ways you can go about doing this and there's some deeper documentation on the Expo site here if you would like to find out more about this for our example we're going to use a package called react native.enth this means we can use an environmental variable where the value is set from outside of the application so let's go ahead and set this up so we need to start by installing it back in our terminal we'll say npm install d react native dot ends once this is installed we need to go to our Babel config file and then add the plugin so after presets we need to add a comma and then for the key we say plugins and then we use an array inside of this as a string we say module colon react Dash native Dash dot end so now we can create the dot end file so at the root of the project I'm going to create a file called dot ends once this is done we can test this out I'm just going to use a dummy value for now using capitals which is the best convention so first I'll set the name of the key to be test underscore key then I'll say equals and for this I'll just say one two three now if I go back to the app.js file I can import this so in my input I say import then I use curly braces and I say from at NF inside the curly braces I place the name of my key which was test underscore key so now I'll just add a console log with this let's save this and run the app in the simulator when the simulator runs if I check the console I can see the value of the key printed successfully so we've proven the package was successfully set up let's go back to our app as I'm using git I want to make sure the dot end file is not pushed so inside the git ignore I will add the file name this means it will not be part of any committing and pushing to get that I do so next let's go back to the dot end file we'll delete the test key and we'll add our key for the open weather map API I'll call this key weather underscore API underscore key the next thing we're going to need to do is to get the API key so back on the open weather map website as long as you're signed in you can click on your user and then my API keys on this screen you can copy and paste the key if you have one otherwise you can generate one by selecting generate and then copy and paste it if you now go back to your Dot N file you can paste it in and then we should be good to go so the last bit of setup we need to do here if we go back to the app.js file we can change the import for the test key to be weather API key now we can look at how we're going to fetch the data so to fetch the data we're going to use the fetch API which is what react native provides us with to work with networking if you haven't used this before you can read more about it here and also here so back in our app.js file we're going to start by creating a new piece of state to store the weather data hopefully you're becoming more familiar with this now but we'll say const then we'll use a set of square brackets and we'll set this equal to use state we'll call this weather so let's add that into the square brackets then we'll call the function to update the state set weather we'll initialize this as an empty array so next we're going to encapsulate this data fetching inside of a new function which we'll call fetch weather data so before the use effect we'll say const fetch weather data and we'll use an equal sign and then async next we'll use some parentheses and arrow and some curly braces so now inside the curly braces we can then set the response so to start we declare a variable using const called res and to this we'll say await fetch and some parentheses inside the parentheses we can paste in the URL we want to fetch the data from so we're going to use backticks here as we're going to need to interpolate in our environment variable so we'll say http colon and two forward slashes next we can paste in the URL that we commented out earlier we'll update these values shortly so next we need to create another variable to get the Json data so we'll say const data and we'll assign to this await response Dot Json once we have this we can call our set weather State function so we say set weather and into this we pass data also once this is done we can set the loadings date to be false so we say set loading and pass in false then inside of the use effect after the location is set we can say await fetch weather data so let's now format the URL that we passed into fetch so inside curly braces we have the latitude and longitude and also the API key so to start with we need to get the latitude from our location piece of State so we say location Dot coords Dot latitude and then we can do the same for the longitude so we say location Dot coords Dot longitude now where the API key is we can pass in our weather API key we also need to make sure we're using interpolation here so we need to add dollar symbols before each of the curly braces foreign there's also some error handling we need to do here so if the response fails in some way we can set our error state to achieve this I'm going to wrap everything inside of a try catch statement so I say try then I use some curly braces and then I say catch and I place error inside of the parentheses then I use another set of curly braces so inside the try I will place everything we've written and then inside of the catch I'll say set error and then inside parentheses I'll use a string and for this I'll say could not fetch weather additionally I'm going to use finally here this is used to execute something after the try catch has been completed so I'll say finally and I use another set of curly braces here I'm going to move set loading from the try statement into here the reason I'm doing this is so that we have either the data or the error once either of these is set we can set loading to false and then we can navigate to the correct screen for this state of course this also means we're going to need to add a screen to show the user if there is an error but we'll add that a bit later so there's one last bit of refactoring I want to do now when we initially set up the location we set one piece of location and then pulled out the required values in the API call I'm going to update this so we have two separate pieces of State one for the latitude and one for the longitude so I'll start by creating these I say const and then I use some square brackets and then I say equals you state inside this I'll place an array I'll call this date lat and then the function to update the state set lat next I'll do the same for longitude so I say const then I use square brackets I initialize this with an empty array I'll call the state lawn and the function to update the state settled on next inside the use effect instead of saying set location I'll say set let and then location Dot coords Dot latitude then I'll do this again for the longitude so I'll say settlon and then I'll pass in location Dot coords Dot longitude then I can update the API call instead to use the lat and long pieces of State additionally I'm going to pass these in as dependencies inside of the user Factor array this means when these change the use effect will rerun let's also remove our initial location piece of State so now let's add a console log to see if we can view the weather data so we'll say if whether console log weather let's save this and see how things are in the simulator so now when we look in the console we can see the weather data has now been set up and is visible to us so now we have all the data we need coming down from the API next I'm going to do a bit of refactoring because our app component has quite a lot of logic inside of it at this point so I'm going to extract the current hook usage into an external file you can make custom Hooks and then import them just like when you use a react hook the benefit of this is that we can better encapsulate the logic in our case we're going to end up with quite a few things going on so doing this means our code is much easier to work with the only requirement when we do this is that we name it with something that starts with use just like when we use hooks which are from react so to start I'm going to create a new directory called hooks now inside here I'm going to create a file called use getweather.js I'll go to this file and I'll start by creating the function so I'll say export const use get weather as this is a function I need to use an equal sign some parentheses an arrow and some curly braces let's think about what we need to add in here we want all the data fetching logic from the app.js file so let's start by getting that and then we'll paste it inside of the function we're also going to need to get all of our state because this is dependent upon by the functionality inside of the hook so back in the app.js file I'll copy all the states set up then I'll go back to the custom hook file and I'll paste this at the top of the use get weather function lastly we're also going to need some of the Imports so let's grab everything from the app.js file and then we'll paste it at the top of the hook file so we can delete the react native and the navigation Imports here because they're not used lastly at the end of the hook we need to return inside of an array the pieces of state that will be needed by our app component so for us this is the loading State the error State and the weather data the app component itself does not need the latitude and longitude so we can keep these scoped only inside of this hook so at the end of the hook after the use effect we say return and then we use an array and we'll pass in loading error and weather at this point we could actually now use this hook inside any component we wanted so this is really helpful if you have some reusable code which is required by multiple components as it means you don't need to duplicate logic now we're ready to use the hook in our app component so if we navigate back to the file we can start by importing the hook I'm also going to delete all the unused code now so now we can use this and we simply just destructure the values so at the top of the app file we say const then we use square brackets and we set this equal to use getweather the values to place inside of the array are loading error and weather so now you can add a console log with loading error and weather let's save this and test this out in the simulator when the simulator runs I now get to see the loading error and weather data printed out in the console so we have proven this works and we now have all our logic scoped inside of its own hook so the next thing we're going to do now is look at wiring up each of our weather components with the real data so to start with we need to pass the weather data to the tabs and then we'll need to decide which pieces of data are required by which component so back in our app.js file let's set a prop on the tabs called weather and we'll set this to weather I'm also going to change the render order here so if the weather exists we render the tabs otherwise we'll show the activity indicator so I'll place the rendering for the tabs to be above the rendering for the activity indicator and then I'm going to enclose this inside of an if statement that says if whether and weather.list then return the navigation container then I'll remove the condition around the activity indicator and just return this so essentially here we're saying if the weather exists with the data we'll render the weather otherwise show the activity indicator we'll update this a bit more later to show an error screen if the error state is true so now let's go back to the tabs component now inside the tabs component we can start using this if we take a look at the data that we get back from the API we can have a think about what each component will need the current weather component only needs the current weather so we can pass it the first element of the list array for the upcoming weather we can pass everything from the list array then for the city we can just pass in the city data so we're going to do this process component by component and we'll start with the current weather component in order to pass the props to the component we need to render a callback to return the element to use for the screen instead of using the component prop so let's start by setting this up we'll remove the component prop and then we'll set up the tab screen to return a child now we can pass in the component so we use curly braces a set of parentheses an arrow and then the current weather component on the component we'll pass the props so we say weather data and we set this to whether dot list and then using square brackets we'll access the element at the position of zero so next we can go to the current weather component and we'll add the weather data prop let's add a console log for this and check everything is wired up correctly here so I'll run the app in the simulator now I'll check the console brilliant I now see the data in the console and we're good to go with wiring up this component to use this data now so let's open our current weather component now we can have a think about what we need to do in order to get this up and running properly the pieces of data I'm going to need for this component are the temp feels like temp Max temp min and weather so to start with I'm going to just structure these from the props so I start by saying cons and then I use the set of curly braces everything except the weather itself I need to get from Maine so I say Maine I say temp feels like temp Max and tent men outside of the curly braces I use a comma and I say weather then I set this equal to weather data next in order to access the correct weather type object I'm going to need access to the weather condition so I'm going to create a variable to store this I'll say const weather condition and I'll set this equal to weather square brackets 0 Dot Main the first thing we're going to do is update the background color for the screen so that it's set dynamically from the weather type utility file because we want to use a property based on the data we're going to need to do this in line so that we have access to everything we need so for the style on the safe area view we'll add in an array after the wrapper we'll add a comma then we'll use inline styles to set the background color so we use an object and inside this we'll set background color we'll set this to be weather type and then we need to pass in the weather condition so we'll use square brackets and then inside of the square brackets we'll Place weather condition outside of the square brackets we then want to access the value of the background color so we say dot background color next we can do a similar thing to dynamically set the icon so for the feather element name we'll add curly braces and then we'll say weather type and then we'll use square brackets inside the square brackets we'll say weather condition and then outside of the square brackets as we want to access the icon we'll say dot icon I'm also going to update the color to be white next we can update the temperature text to use the temp value so we need to add curly braces here as we're passing in a value and then inside the curly braces we can add temp for the feels like temp we also need to use curly braces here I'm going to use a template literal so inside the curly braces I'll add back ticks then I'll say feels like and I'll interpolate in the feels like value the first row text shows the high and low temperature so I need to update the message 1 and message two values I'm going to use template literals here again so for the message one I'll use backticks then I'll say hi then a colon and I'll interpolate in temp Max for message 2 I'll again use backticks and I'll say low colon and I'll interpolate in temp min for the next row text we want to show the weather description which comes from the data and then we also want to show the weather type message so for message one I'll say whether and as this is an array I need to use square brackets and pass in zero then I say dot description for the message too instead of passing in thunderstorm I can remove this string and instead just pass in the weather condition let's save this and see how things look in the simulator when the simulator runs I see the current weather component but we're now using the values from the weather type and everything is using the real data there is one thing though the units are currently in Kelvin on the open weather map documentation we can see this is the default on our app we want to use metric so we need to add this to the API call if we go back to the use get weather hook we can append this to the API call we use the and symbol and then we say units equals metric now if we reload the simulator we can see the new values this screen will now look different every time the weather type changes so that is our current weather component updated for now with the data next we can move on to updating the upcoming weather component let's go back to our tabs and set this up so back in the tabs component we'll remove the component prop and then set up the tab screen to return a child then we can pass in the component so we use curly braces and then a set of parentheses an arrow and then the upcoming weather component next on the component I'll say weather data and I'll pass in whether dot list this means we have access to all the upcoming data so next I'll go back to the upcoming weather component and I'll pass in weather data to the component I'm going to start by removing all the dummy data we added additionally I'm going to remove the title for the component so I can also now remove the text from the Imports next in the data proper the flat list I'll pass in weather data the values for the list item inside of render item are already set up from the dummy data so now we can go straight to the list component and see what we need to update in this component we also have all the props set up from the dummy data but we need to do some refinements here I'm going to start by updating the icon to use the icon from the weather type dynamically so to start I need to import the file so I say import then I use curly braces and inside the curly braces I add weather type and I'll import this from utilities slash weather type then for the feather icon name I'll remove the string some and I'll say weather type square brackets our passing condition into the square brackets and then I'll say dot icon because space is limited for the list item I'm then going to change the Min and Max temperature to be all in one line and I'm also going to round these values so to start I'll delete the text with Max then I'll use a template literal and interpolate in math Dot round and I'll pass in min then I'll interpolate in math Dot round and I'll pass in Max I'll separate these with a slash also we want to show the degree symbol on each of these values on a Mac I can do this with option shift 8. on a Windows this is Alt 0176 next we'll look at formatting the date text and I'm going to use a library to help us with this called moment.js moment.js helps us pass and format any data related to time and dates it's a really useful library to know about because it provides a lot of options for how to display what can sometimes be quite complicated data to the user let's start by installing it in the terminal I need to type npm install ment dash dash save we're going to split the date text into two sections one that shows the day and one that shows the time so back in the component let's add another piece of text under the one that currently shows DT text also to display these we're going to want these to be split onto two lines so we'll wrap these inside of a view and then we'll set some Styles here we'll just call these date text wrapper inside the style sheet let's add this and then we can set Flex Direction to column NAD format value we need to start by importing moment so at the top of the file we say import moment from moment so let's have a quick look at the documentation on the first line we want to show the day so we can do this by passing in d d we then want to show the time on the next line and we can do this by passing in H double m double s let's go back to our component and set this up so for the piece of text we want to show the name inside of the curly braces we say moment and then pass in DT txt then we say dot format and we pass in the string DD in the second piece of text we say moment and again pass in DT txt then we say dot format and this time we pass in H colon mm colon SS and Then followed by a space followed by a so the a will show the AM or PM let's save all of this and see how this component now looks in the simulator when the simulator runs we now see all of our list data showing on the screen with the new layout improvements so next we need to go back to our tabs component and move on to wiring up our city screen so back in the tabs component we'll remove the component prop and then we'll set up the tab screen to return a child next we can pass in the component so we use curly braces a set of parentheses an arrow and then component now we can pass in the data so we say weather data and we pass in whether Dot City now let's go back to our component let's start by setting the prop in the parameters and then we can destructure out the values we're going to need so I say const then I use some curly braces and I set this equal to weather data inside the curly braces I'll add name country population sunrise and sunset the first value we're going to update is the city name so I can remove London and I'll add some curly braces inside the curly braces I'll add name I can now do the same for Country so I remove UK and then I add some curly braces inside the curly braces I'll add country next I can update the first icon text body text value I'm going to use a template literal here so I'll remove 8000 then I'll use some back ticks then I'll say population colon and I'll interpolating population I can then move on to updating the second icon text I'm going to use moment again here to help us with our formatting so I'll import moment from moment at the top of the file now back in the body text I will say moment and I'll pass in Sunrise then I'll say dot format and pass in h colon mm colon SS and then a space and a then for the last icon text body text value I'm also going to use moment again so this time I say moment and I'll pass in Sunset then I use a DOT and I say format inside format I pass in H colon mm colon SS then a space and a let's save this and see how it looks in the simulator everything for the screen looks good and this has now also been updated to use the data from the API so that's all our existing screens set up to use the data there's just a couple of minor fixes I want to do I want to add the degree symbol to the current weather component so let's go back to that component now in the first two pieces of text I'll add the degree symbol here I also want to add a space between the high and low text so on the message one prop here I'm just going to add a space at the end so now we have these refinements done let's move on to creating an error screen for the application inside the components directory I'm going to create a component called error item now inside this component we can set it up just like a standard component so I'll import react from react then our import View text and style sheet from react native I'm also going to import feather from at Expo icons so now we can declare the component I say const error item equals then I use a set of parentheses an arrow and some curly braces I'll make sure the component is exported so at the bottom of the file I say export default error item before the export I also need to set up the style sheet so I say const styles equals stylesheet Dot create and I'll pass in an object here inside the component I'll save return and then I'll add a view and some text inside the text I'll pass in the message sorry something went wrong next I'm going to add a feather icon so I'll say feather and then I'll set name to frown size to 100 and color to White so let's set up the styles on The View I'll say Style equals styles Dot container on the text I'll say Style equals styles Dot error message then inside the style sheet our set container and I'll say Flex of one background color of red justify content of Center and align items of Center and then for the text I'll say font size of 30 color of white margin horizontal of 10 and text align up Center now let's test this out in the app.js file we can start by importing error item from components error item next in the render with the activity indicator we can use a conditional and say if loading then return the activity indicator otherwise return the error item to test this I'm going to go to the use get weather hook at the bottom of the hook where we return the values I'll say true for the error and I'll add an empty array for the weather this just means we now have the state set up in order to test out our error item so let's save this and see how it looks in the simulator when the simulator runs I see the error screen that the user would see if something went wrong when the location and weather are being set let's go back to our hook file and revert the changes we just made so we set the error and weather back in the values returned by the hook so now let's go through our app screen by screen and check if there's any other refactoring we need to do when I look at the current weather screen I can see we need to add the degree symbol to the initial temperature value I also want to slightly decrease the font size in the description and message so let's do that now back in the component I'll add the degree symbol to the temperature then in the style sheet I'm going to remove the pink background color as this is now not needed then I'm going to set the description font size to be 43. and the message font size to be 25. I'm lastly going to add optional chaining in the places that we are accessing nested object properties this means undefined will be returned if one of the properties does not exist instead of an error next let's take a look at the upcoming weather screen as we're using white text I think the background color of the list items is slightly light so let's update that let's go back to the list item component I'm going to set item background color to the Indian red this is all one word and all lower case lastly I'll add optional chaining where we're using the weather type everything looks a bit better in the simulator now so let's take a look at the city screen everything on this screen now looks good to go so we're ready to move on to making the final touches to our application the last thing I want to do on our app is adjust the app component very slightly I want to change the conditional to show the error item if the error state is true and then otherwise show the loading screen this just ensures that the user really does only see the error screen when there is an error so I'll say if error then show error item otherwise show the activity indicator so that is everything done and our app is now complete before I wrap up this course there's a couple of last topics I'd like to introduce you to but you can consider this as bonus material the first one of these topics is the context API you may have noticed when I implemented the tab screens as children that the documentation said that it advised you use the context API the reason I did not do this is because we only have three core screens on the app however if you're in a position where you're passing the data around a lot of components who are very far away in the component tree and also perhaps that the state is complex then the context API is very handy to know about it's also really useful if you have some global data which is needed throughout the application such as a user's name or some theming for the application by using the context API all the logic can become centralized it's not specifically the right or wrong approach it very much depends on your use case and it becomes a slightly different way of handling your data instead of props so you can share anything through the context and once we share the data the component can ask the context for the bits of data it needs it's important not to overuse context and definitely don't think of it as a replacement props but it's an approach that it's worth knowing about for when you need to access specific pieces of global data throughout the application the documentation about context is here but essentially there are three steps to creating context you need to start by importing the context then you would Define your context so if you had a rim context you'd say const room context and you'd set this equal to create context then you wrap the context around your components and at this point your components can access the context the last couple of topics I wanted to cover are UI based topics we haven't had the need in our application to create a button although we have seen how the react native button component works did you notice how this didn't really look like a button that you might have expected another common task when you're developing applications that you may encounter is creating custom buttons react native has a set of touchable components which help us with this if we take a look at touchable opacity we can see that it's a wrapper for responding to touches alternatively we have touchable without feedback but this doesn't give us a visual response so this is likely not what you want to use when you're creating a button in the demonstration directory that I created earlier I'm going to go ahead and Implement a button just so that you're familiar with how to achieve this and then I'll start by setting up the component so I'll import react from react then I'll import View touchable opacity and text from react native next I'll set up the component so I say const R button equals and then a set of parentheses an arrow and some curly braces I'll then export the component so I just say export default R button next I'll set up the style sheet so I say const styles equals style sheet Dot create into this I pass in an object so next in the component I say return and then I'm going to use touchable opacity and inside this some text for the text I'll just say hello then on the TouchPal opacity we pass in on press and we'll set some Styles so we say style equals styles Dot container would also set some styles for the text so I say style equals styles Dot button text in the style sheet I'll add these Styles so I'll start with the container I set elevation to eight this sets the elevation of the item on Android only next I say background color of blue border radius 10 and I'll set padding to five then for the button text I'll set font size to 15. color to White and align self to Center then on the touchable opacity we set an onpress prop so let's set this up we use this to Define what we want to happen when the user presses the button so I'll set up an arrow function called on press and inside this I'll add a contour log which just prints out press to test this out let's go to the app component I'll comment out the navigation container render and then I'm going to import the button so I say import R button from demonstration R button then I'll add this to the render before the activity indicator Let's test this out in the simulator when the simulator runs I get to see the button if I open the console I can see the Press is printed out every time that I press the button I strongly advise you spend some time playing about with all the core components in react native as there's a lot you can achieve you can look at modals for alerts text input for text input fields and the switch component acts like a toggle
