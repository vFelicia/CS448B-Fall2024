With timestamps:

00:00 - hey guys my name is frank i'm starting a
00:02 - series on how to program a tile-based
00:03 - platforming game called rabbit trap it
00:05 - will feature tile-based collision
00:06 - detection and response scrolling maps
00:09 - loading levels sprite animation and
00:11 - interactive game objects in this first
00:13 - part of the series i'll be talking about
00:15 - how to build a strong foundation for the
00:16 - game the concepts i'm going to explain
00:19 - are strongly rooted in object-oriented
00:20 - programming and can be used in any
00:22 - program to improve organization and
00:24 - modularity this might seem boring but if
00:26 - you use this approach it can save you
00:28 - hours of editing and frustration and
00:30 - leave you more time to focus on fun
00:31 - stuff like level design and graphics so
00:33 - be sure to watch this video
00:40 - in this video i'm going to talk about
00:42 - the model view controller approach to
00:44 - organizing a program and how the
00:45 - different components of this example
00:47 - work together in the main js file
00:50 - then i'm going to talk about how this
00:51 - structure increases maintainability and
00:53 - modularity as always feel free to use
00:56 - the comments section and be sure to
00:57 - check out the links to the source code
00:58 - and working example in the video
01:00 - description and if you learned something
01:02 - give this video a like
01:06 - so basically what i have here is just an
01:09 - example of a model view controller
01:11 - architecture where you separate out your
01:13 - game logic from your display logic and
01:16 - you also separate out your controller
01:18 - logic so i have my game logic stored in
01:20 - the game class the display logic in the
01:22 - display class and the controller logic
01:24 - in the controller class
01:26 - and each one of these handles its own
01:28 - business and it's totally separate from
01:30 - the other so i'm not going to run into
01:32 - any issues with having
01:34 - references to the game logic inside of
01:36 - the display i'm not going to have the
01:38 - controller logic referenced inside of
01:40 - the game i'm going to have all these
01:42 - different components interact with each
01:43 - other through their public methods
01:45 - inside of the main js file context
01:50 - and by the way each one of these classes
01:51 - is defined in its own individual file
01:54 - you don't need to have your own
01:55 - individual files but it makes it a lot
01:57 - easier to just
01:58 - use these different things in other
02:00 - applications if i choose to for example
02:02 - the engine i might want to use this
02:04 - fixed time step engine inside of another
02:07 - application at some point so it's nice
02:08 - to just store it in its own file but
02:10 - anyway what all this code does
02:13 - for this example is basically the game
02:16 - class controls color value
02:19 - right here that's the color
02:21 - variable from the game class basically
02:23 - it just increments the different red
02:26 - green and blue channels inside of a
02:27 - color value to change these different
02:30 - colors that you're seeing on the screen
02:32 - and then it will talk to the display
02:34 - class which governs things like the
02:36 - canvas and resizing the canvas when the
02:38 - screen resizes and rendering and the
02:41 - game will hand a color value to the
02:44 - display and the display will render it
02:46 - on every frame
02:48 - and the engine takes care of frames as
02:50 - for the controller i didn't really have
02:52 - anything cool to do with the controller
02:53 - for this example so all it does is take
02:55 - user input from the keyboard and tell
02:57 - the user which key
02:59 - he or she pressed so for example i just
03:01 - press the a key that's key 65.
03:04 - so
03:05 - basically what i'm trying to say is i
03:07 - want to keep things as organized as
03:09 - possible for this rabbit trap game and i
03:11 - want you guys to kind of think about
03:14 - organization of code before you start
03:16 - developing a game because if you just
03:18 - jump into things and try to mesh all
03:20 - this together in one big file with
03:22 - references going between different
03:25 - components
03:26 - it's going to get very messy very fast
03:28 - and here's an example of that that i
03:29 - want to show you so i define all my
03:31 - components i define my engine it's going
03:33 - to run at 30 frames per second
03:35 - and i'm handing in the render and update
03:37 - function down at the bottom of my
03:39 - main.js file i'm going to start my
03:41 - engine and that's going to execute the
03:43 - render and update function 30 times per
03:45 - second until i stop my game engine
03:49 - so the render and update functions i
03:51 - define up here and these are them right
03:54 - here so the update function is just
03:56 - going to tell the game
03:57 - to change that color value and that's
03:59 - what the update function of the game
04:00 - does just increments this color value in
04:02 - a random direction gradually to change
04:05 - the color
04:06 - now the render function is also going to
04:08 - be called on every frame of my game loop
04:11 - and inside i'm actually going to be
04:12 - communicating the game's color value
04:16 - to the display and i'm going to have the
04:18 - display object draw that color value to
04:21 - the on-screen canvas
04:23 - so here is a great example of why this
04:25 - is so good
04:26 - so i could just as easily write object
04:29 - literals to govern my display logic and
04:31 - my game logic and you've seen that if
04:33 - you've you've watched my other tutorials
04:35 - i'm kind of sloppy i just throw stuff
04:37 - together with object literals here i'm
04:39 - not doing that if i had written object
04:42 - literals i could put a reference to
04:43 - game.color directly inside of the
04:46 - display's render color function or
04:49 - better yet i probably wouldn't have even
04:51 - had a render color function i would just
04:52 - have a render method that handled
04:54 - rendering the entire thing the reason i
04:56 - have two here is because render color
04:58 - draws a color to a buffer canvas and
05:00 - then display.render
05:02 - renders that buffer canvas to the final
05:04 - on-screen canvas that you see so the old
05:07 - version of how i wrote my code
05:09 - or just the sloppy way that i write my
05:10 - code would just be to put two object
05:12 - literals on the
05:14 - main js file and one would be display
05:16 - one would be game and i would have a
05:18 - reference to game.color inside of my
05:20 - render function and display would just
05:23 - draw that color
05:24 - directly to the canvas
05:26 - now the reason this is bad is because
05:28 - say i want to change the name of my
05:30 - color variable to hue
05:33 - if i go ahead and i have a reference to
05:35 - game.color inside of my display
05:37 - and i change the variable color to hue
05:40 - inside of my game object now all of a
05:42 - sudden i'm editing my game
05:44 - class or my game object to change that
05:47 - value to hue
05:48 - and i have to go into my display object
05:51 - and change all the references to
05:52 - game.color to game.hue
05:55 - now that's a pain i don't want to have
05:57 - to do that and it's unnecessary so i
05:59 - don't see why i do it anyway
06:01 - with this method the mvc approach you
06:04 - don't actually have to
06:06 - have any internal references to any
06:08 - other components the display only has
06:11 - references to itself inside of itself
06:14 - the game only has references to things
06:16 - that it controls
06:18 - so how do they communicate they
06:20 - communicate just like this they
06:22 - communicate through public methods so
06:24 - display can only communicate with other
06:27 - objects like game and controller through
06:30 - public methods that it has so if i come
06:32 - into the display object here and i take
06:34 - a look at render color you can see that
06:36 - just takes a color value and inside of
06:38 - it it does exactly what i said it just
06:40 - changes the buffer's fill style to the
06:42 - specified color and draws that color to
06:45 - the buffer canvas and then here's the
06:47 - render function and all this is going to
06:49 - do is draw
06:50 - the buffer canvas to the final display
06:53 - canvas
06:54 - i'm not going to get too much into
06:55 - detail on that but you get what's going
06:57 - on here now i could have just as easily
07:01 - gone like this inside of this function
07:03 - and said
07:04 - game.color had i made these object
07:07 - literals instead of classes
07:09 - but that's actually really bad practice
07:11 - because like i said if i change
07:12 - something inside a game it might break
07:15 - my display
07:16 - object and prevent it from working so
07:18 - that's twice the editing that i'm going
07:19 - to have to do because i'm going to have
07:20 - to change all the values in display as
07:23 - well as all the values in game
07:26 - so this is just a much cleaner way of
07:27 - doing things
07:30 - so basically this is how you want your
07:31 - different components to interact and
07:34 - just take a look at this main js file
07:37 - it's really short everything is super
07:39 - clean i just have my two
07:41 - functions here render and update that i
07:43 - hand into my
07:44 - game engine
07:45 - and here i'm defining everything this is
07:48 - super clean i don't have huge object
07:50 - literals to take care of just sprawling
07:52 - out across my my screen here in my
07:54 - editor and to instantiate everything
07:57 - it's real simple i just add my event
07:58 - listeners for the screen resize and the
08:01 - the keyboard inputs and i just resize my
08:04 - screen initially so my canvas fits the
08:06 - screen when i start up and i start my
08:08 - engine and everything runs the way i
08:10 - expect it to
08:11 - so using the mvc approach or just
08:14 - separating out the different components
08:15 - of your game into logical groups is a
08:17 - really great way to keep your code
08:19 - maintainable and modular and i'm going
08:21 - to get into why in the next part of this
08:23 - video
08:27 - so now i want to talk about how this
08:28 - approach makes things more modular and
08:31 - more easy to maintain so
08:33 - obviously right off the bat it's a lot
08:35 - more organized you can see that clearly
08:37 - i have my different
08:38 - components reference here and
08:40 - instantiated here in one single line
08:43 - each rather than having big sprawling
08:45 - object literals defined and by
08:47 - separating these things out into their
08:49 - own classes i have the option of putting
08:51 - them into their own files which makes
08:53 - things even more organized because i
08:55 - could have all of these different
08:57 - classes
08:58 - right on top of each other in one big
09:00 - file
09:01 - or i could separate them like i did into
09:03 - their own files and now if i want to
09:05 - edit the game logic i only have to deal
09:08 - with
09:09 - 42 lines of code apparently instead of
09:11 - having to search through one big file so
09:13 - that's obviously one way that this
09:15 - technique lends itself to easy
09:17 - maintainability then there's the other
09:19 - thing i mentioned where you don't have
09:20 - internal references to one component
09:23 - inside of another component and like i
09:26 - said then
09:27 - it's a lot easier to just work with
09:30 - public methods
09:31 - and have your components communicate via
09:33 - public methods kind of like is happening
09:36 - right here in the render function
09:38 - display is interacting with game through
09:40 - a public method called render color
09:42 - rather than having an internal reference
09:44 - to game.color which would be a lot
09:47 - harder to maintain because if i change
09:48 - game.color in the game object i'm going
09:51 - to have to go through display and edit
09:52 - all of those references to game.color so
09:55 - this is another way it lends itself to
09:57 - maintainability now what about
09:59 - modularity
10:00 - okay well i've got a
10:02 - engine class down here which is
10:04 - basically a fixed time step engine
10:07 - now i can use this engine in any
10:09 - application that i want to and it's very
10:11 - easy for me to do that because this is a
10:13 - totally self-contained class that i
10:16 - store in its own file now i don't have
10:18 - to store it in its own file but by
10:19 - storing it in its own file i can very
10:21 - easily just
10:23 - reference that single file in another
10:25 - application and then all of a sudden bam
10:27 - i have a perfectly good game engine for
10:31 - a whole nother game and i didn't even
10:33 - have to write code for it i already had
10:35 - it on hand
10:36 - but if i were to have that game engine
10:38 - integrated into all my other components
10:41 - it would be a lot harder for me to
10:43 - extract the the engine components from
10:46 - say the game logic and that just isn't
10:49 - very modular the way i have it set up
10:51 - now is very very modular and it will
10:53 - save me a lot of time in the future when
10:55 - i need a game engine object so
10:58 - sometimes i write my code this way for
11:00 - most of my tutorials i just throw stuff
11:01 - together in one file because i want
11:04 - everything to be there for you guys to
11:05 - see
11:06 - up front i don't want to have to bring
11:08 - things in from other applications but
11:10 - this is how i would go about writing a
11:13 - more structured application and that's
11:14 - what i'm trying to do i'm trying to
11:16 - write this game rabbit trap and i just
11:18 - want it to be very structured and i want
11:20 - everything to go smoothly so using the
11:22 - mvc approach and separating my game
11:25 - logic from my display logic and my
11:27 - controller logic is just going to make
11:29 - everything go super smooth throughout
11:31 - this whole process so anyway i hope this
11:34 - has been a good explanation of how
11:37 - everything is going to be for this
11:38 - rabbit trap thing and i hope you guys
11:40 - are interested in what's going to come
11:41 - because i expect it to be a really cool
11:43 - game
11:44 - before i wrap things up i want to talk
11:46 - about my html for this
11:49 - example so i actually am going to do a
11:51 - whole bunch of parts in this series and
11:54 - rather than having to upload the sprite
11:57 - sheet for this example a thousand times
11:59 - to my github page or however many parts
12:01 - i have i don't want to upload this
12:02 - multiple times my github page because i
12:04 - don't want to waste memory space so i'm
12:07 - just going to use the same
12:09 - graphics i'm going to use the same html
12:11 - file in css file and i'm just going to
12:14 - write new javascript files as need be so
12:17 - that's going to keep the memory
12:19 - footprint on my github page a little bit
12:20 - smaller for this whole
12:22 - series that i'm doing so anyway the way
12:24 - i'm going about that is inside of my
12:27 - html i'm dynamically
12:30 - determining which
12:32 - javascript files to load based on a url
12:36 - variable specifying the part number so
12:38 - when i come into my
12:41 - actual html page here
12:44 - and i look at my url to the
12:46 - rabbittrap.html file at the end of it
12:49 - there is a question mark and a one which
12:52 - is the part number for this example now
12:54 - if i wanted to get to part two i would
12:56 - just come in and type two
12:58 - i haven't actually made typed or part
13:00 - two yet
13:01 - but
13:03 - that's how you would access part two so
13:06 - i'm accessing these different parts with
13:09 - a url variable that is just the part
13:13 - and i have a default to where if you
13:15 - don't specify anything
13:17 - it just brings you to part one so that's
13:21 - what i'm doing and this big chunk of
13:23 - code in the middle the middle of my html
13:26 - file is taking care of that for me so it
13:28 - just it defines all the sources i'm
13:30 - gonna use and that's just these files
13:33 - here it gets the
13:35 - url variable or that part number from my
13:37 - url that 01 after the question mark and
13:41 - then it goes ahead it checks to see if
13:43 - it's a viable part
13:45 - if there is no part specified it just
13:47 - sets it to part one and then it just
13:49 - loops through and adds a script tag for
13:51 - every single javascript file
13:54 - in the
13:56 - application so i'm always going to have
13:57 - controller display engine game main and
14:00 - manifesto is just my script for the
14:01 - video
14:02 - and i'm just going to add a new script
14:04 - for each one of those and i'm going to
14:06 - edit i'm going to parse together the
14:10 - url or the source attribute
14:12 - to match whichever part i'm in
14:15 - so hopefully that was a good explanation
14:16 - of how i'm actually getting these things
14:19 - in and if you had any questions about
14:21 - why my html was weird like this
14:23 - that's the reason i'm just trying to
14:25 - save memory space on my github page so
14:27 - being cheap but i kind of figured out
14:30 - this cool little script to just import
14:33 - uh javascript files based on what part
14:35 - i'm in so anyway that is an explanation
14:37 - of that
14:39 - this part is going to be on adding a
14:40 - player object to the screen and
14:42 - controlling him with the keyboard this
14:44 - is a vital component of any game so stay
14:46 - tuned to find out how it's done
14:52 - in this video i'm going to talk about
14:53 - the example program what it does and how
14:55 - the program has changed since part one
14:58 - then i'm going to show you the specific
14:59 - code that handles creating the player
15:01 - controlling him and drawing everything
15:03 - to the screen finally i'm going to show
15:05 - you my implementation of a fixed
15:06 - timestep game loop and how it works if
15:08 - you have any comments or questions post
15:10 - them and if at any point while you're
15:12 - watching this video you get the
15:13 - sensation that you're learning be sure
15:15 - to support this video with a like
15:18 - first thing i want to talk about is what
15:20 - this example actually does and how this
15:22 - program has changed since part one so
15:25 - all this example does is allow me to
15:28 - place a square which represents my
15:29 - player on the screen and use the
15:31 - keyboard to make him jump up and down i
15:33 - also added some stuff in for collision
15:36 - detection and to make it look nice so he
15:38 - changes color on every jump
15:41 - and he leaves a trail the reason he's
15:43 - leaving a trail is just because i'm
15:45 - filling the background i'm redrawing the
15:48 - background on every frame of animation
15:49 - with a
15:51 - a slightly transparent
15:53 - background so that's the reason i'm
15:54 - getting that trail if i was drawing just
15:56 - a plain opaque black ground or opaque i
15:59 - guess some people pronounce it that way
16:00 - if i was doing that you wouldn't be able
16:02 - to see that trail behind them but i
16:03 - thought that was pretty cool and it kind
16:05 - of helps you visualize the what's going
16:07 - on in every frame of animation because
16:09 - each one of those squares that you see
16:10 - trailing behind him
16:12 - is drawn on one frame of animation
16:16 - all right so now that you know what the
16:17 - program does
16:19 - let's talk about what has changed since
16:21 - part one so in part one i had to find my
16:24 - three different classes my controller my
16:26 - display and my game i also had my engine
16:29 - class and my main js file so all these
16:33 - are updated for part two that's why the
16:35 - file name has a o2 after it the ones
16:38 - from part one like engine i haven't
16:39 - changed since part one that has a part
16:42 - one
16:43 - so that's my naming convention that i'm
16:44 - using really the only thing that i
16:46 - changed majorly besides the code that
16:48 - went into making the example work was i
16:50 - took the event listeners
16:52 - out of the display
16:54 - and the controller classes so the key
16:57 - down up actual event handler function i
17:00 - hand into the event ad event listener
17:03 - method in my main
17:04 - js file i'm actually defining those
17:07 - inside of my main file now so this would
17:10 - be one that i moved out the key down up
17:12 - event listener and the resize event
17:15 - listener or actually event handlers
17:17 - that's what these are so if i come all
17:19 - the way down to the bottom of my main js
17:21 - file you can see that i'm adding these
17:23 - event listeners
17:26 - to the window object and i'm just
17:28 - handing in
17:29 - the
17:30 - methods that i define inside of my
17:32 - main.js file into these event listeners
17:35 - so that's one of the changes i made i
17:37 - decided to make that change because
17:39 - i didn't think that my
17:42 - event handling system was really
17:45 - something i wanted to put inside of my
17:47 - individual
17:48 - classes or my individual components and
17:50 - the reason for that is a lot of times
17:53 - inside of these i'm going to have to do
17:55 - interactions with
17:57 - multiple components of my game so for
17:58 - example the resize component actually
18:01 - needs to handle two different components
18:03 - and have them interact it needs the
18:05 - display component which handles drawing
18:07 - everything to the screen and all my
18:08 - graphics and it also takes information
18:10 - from the game component which has
18:13 - information about my
18:15 - world's height and width and my player
18:17 - location and stuff like that
18:19 - so
18:20 - that's just a little bit about the
18:22 - example program and what it does and a
18:24 - few things that have changed since the
18:26 - last part of this series
18:31 - all right so now i'm going to talk about
18:32 - how i define the world and the game
18:36 - object and this is basically going to
18:38 - define
18:39 - the world that my little player square
18:41 - can run around it and jump in and it's
18:43 - going to define the player itself that's
18:44 - going to be just the rectangle that
18:46 - defines the player as well as the color
18:49 - and it's going to handle some collision
18:50 - detection stuff as you can see i can't
18:52 - fall through the floor and i can't jump
18:54 - or walk through the walls so all of this
18:57 - is going to be handled inside of my game
18:59 - logic so i'm going to come into the game
19:02 - part 2 file
19:04 - and take a look at my game class
19:07 - but i'm going to keep it expanded so we
19:09 - could actually look at the code all
19:10 - right so the first thing i'm defining in
19:12 - here is a
19:13 - object literal called world so inside of
19:16 - my game class
19:18 - i'm going to have access to this world
19:20 - object and inside of this i'm just going
19:22 - to have my background color
19:24 - and by the way this is that transparent
19:26 - color so if i come in here and i just uh
19:29 - change this to something like
19:31 - zero zero zero zero zero zero that's
19:33 - gonna be the color for black if i come
19:35 - in there and save it and then refresh my
19:37 - screen now i'm no longer going to have
19:39 - that trailing
19:41 - graphic
19:42 - behind my player whenever he jumps
19:46 - but if i come back in here and change it
19:47 - back ctrl z a bunch of times get rid of
19:51 - that and that and save and come back
19:53 - here
19:55 - now all of a sudden i get my trailing
19:59 - graphics behind my player whenever he
20:00 - jumps in it looks like he has just a
20:02 - cool trail of fading graphics behind him
20:04 - so that's pretty cool and it's really
20:06 - really easy to implement all you got to
20:07 - do is draw this
20:10 - semi-transparent background color
20:12 - to erase your canvas on each frame of
20:16 - animation so anyway
20:17 - to get back to the world object i just
20:19 - want to make a side note of this and how
20:21 - i did that color trailing feature the
20:23 - world is just going to have everything
20:25 - to do with the world so friction and
20:26 - gravity are going to be defined here the
20:28 - player is going to be defined here later
20:30 - on i'm going to define other objects
20:32 - that are going to be in-game objects
20:34 - they're going to be defined here the
20:35 - world boundaries so the height and width
20:38 - of our level are going to be defined
20:40 - here if i were to change this let's say
20:42 - i want to make the height something like
20:44 - 200 and have a really tall screen if i
20:46 - do that and come here and refresh the
20:47 - screen now you can see that
20:50 - i have a really really tall game world
20:52 - and
20:53 - that looks kind of stupid so
20:56 - we're going to change it back
20:58 - save refresh and now i'm back to my
21:00 - normal size but basically the world
21:02 - object just holds everything to do
21:05 - with the game world including stuff like
21:07 - collision so this collide object
21:09 - function is just going to take an object
21:11 - parameter and for now that's just going
21:13 - to be handled inside of our game loop on
21:15 - every update and i'm going to pass clyde
21:17 - object the player object that we're
21:20 - defining i'm going to get to that class
21:21 - later and basically it's just going to
21:23 - test c is the object
21:25 - to the left of zero so that's going to
21:27 - be the far left of our screen and is he
21:31 - beyond the right side of the screen is
21:32 - he
21:34 - above the top of the screen is he below
21:36 - the bottom of the screen it's just going
21:37 - to set him to where he needs to be and
21:38 - handle collision with the boundaries of
21:40 - our rectangular world here
21:42 - so pretty simple stuff everything in
21:45 - this example is actually really basic
21:47 - take a look at the source code i have it
21:48 - linked in the description
21:50 - here i have the update function
21:53 - now this is actually going to update
21:54 - everything to do with our world so the
21:56 - player is going to have gravity added to
21:58 - his y velocity on every frame this
22:01 - function is going to be called on every
22:02 - frame of animation inside of the game
22:04 - loop
22:05 - the player has his own update function
22:08 - and if i come down to the player object
22:10 - down here we could take a look at it
22:12 - see what we got here update it just adds
22:14 - his x and y velocity to his current x
22:17 - and y position
22:20 - go back up see what else we got here
22:23 - so we're going to update the player
22:24 - we're going to add some gravity to his y
22:26 - velocity we're going to add friction or
22:29 - we're going to reduce his x and y
22:31 - velocities by the amount we defined in
22:34 - friction which is up here
22:36 - 0.09 it's just a simple pseudo-physics
22:39 - way to
22:40 - employ friction in your game then we
22:43 - have this dot clyde object this stop
22:45 - player and this is referring to
22:48 - the world object
22:50 - that we are talking about
22:52 - so that's a really simple world object
22:54 - it just governs everything to do with
22:56 - the world the dimensions the player the
22:58 - colors that you're seeing in there
23:01 - and also in our game class we have added
23:04 - or i have added rather uh the player and
23:07 - it's a simple class it's
23:10 - uh using dot syntax to kind of add this
23:14 - player class to the game class and
23:16 - that's kind of just a way to keep things
23:17 - organized and almost like name space in
23:20 - there it's not real name spacing but
23:23 - by doing this i'm not going to have a
23:27 - a global class called player
23:30 - instead i'm going to have to reference
23:32 - it with game dot
23:34 - player like that so if i have a bunch of
23:37 - classes that i'm throwing into an
23:38 - external context say your game is going
23:40 - to run on another website and it's going
23:43 - to be part of the global scope of that
23:44 - website you don't want your classes and
23:47 - stuff to be just floating around with
23:49 - all the other variable names and class
23:51 - names that other developers have defined
23:53 - so it's good to try to abstract out your
23:56 - own class names and variable names and
23:58 - do stuff like put them into anonymous
24:00 - functions just to keep your code
24:03 - separated from everybody else's code out
24:05 - there on different websites
24:08 - but anyway that's besides the point we
24:10 - define our player class here he has a
24:12 - color he has a height he has a width he
24:14 - has x and y velocities he has a value
24:17 - for jumping to determine whether or not
24:18 - he's jumping and he's in the air if he's
24:20 - standing on the ground we also have his
24:23 - x and y position and since i'm just
24:25 - being lazy and i'm not loading him in
24:28 - from a level map i'm just going to
24:29 - define his
24:31 - values all right at the start here when
24:33 - the player object is instantiate
24:36 - instantiated with the new operator
24:38 - so
24:40 - now i go into the prototype and i have a
24:42 - couple different functions that govern
24:44 - govern how he moves i have the jump
24:46 - function
24:47 - uh basically just says if he's not
24:48 - jumping
24:50 - then we're gonna change the color and
24:52 - we're gonna make him jump down here so
24:54 - pretty simple this is the code to get a
24:56 - random color
24:58 - and i'm not really gonna go into that
24:59 - but basically it just makes his color
25:01 - change every time he jumps every time i
25:03 - press the up arrow on my keyboard
25:06 - the jump function is called on the
25:07 - player and this code runs pretty simple
25:11 - same thing for the move left and move
25:13 - right functions these functions are
25:15 - going to be called in my main javascript
25:16 - file i'm going to take a look at that in
25:17 - a second and all it does is just add
25:20 - half a pixel to his x and y or x
25:24 - velocity depending on which button you
25:26 - press if i press left i'm going to
25:27 - subtract 0.5 pixels from his x velocity
25:30 - if i
25:31 - press right on my keyboard i'm going to
25:33 - add 0.5 pixels to his x velocity and
25:35 - then finally that update function that's
25:37 - just going to add his x and y velocity
25:39 - to his x and y locations in the canvas
25:43 - respectively so now let's let's take a
25:45 - look inside of the main js file and
25:49 - see where all of these are being
25:50 - employed which is going to be inside of
25:52 - the update function
25:54 - so the reason i have my
25:56 - update functions all over the place i
25:58 - have one for my player i have one for my
26:00 - world and i have one in my main
26:01 - javascript file is because
26:04 - i'm doing different things inside of all
26:06 - of them and i want to keep all of my
26:07 - objects as self-contained as possible so
26:10 - for instance
26:11 - uh the
26:12 - player object his update function is
26:14 - really simple
26:16 - it just handles stuff that has to do
26:18 - with the player my world's update
26:20 - function only handles stuff to do with
26:22 - the world so
26:24 - this.world.update is going to be this
26:27 - function right here the world's update
26:28 - function only has to do with things
26:30 - inside of the world
26:32 - the main javascripts file
26:34 - javascript file has an update function
26:36 - that handles
26:38 - the controller
26:40 - as well as the game so i'm mixing these
26:42 - two major components of my game's logic
26:46 - inside of this one method inside of my
26:49 - main.js file and that's kind of where i
26:50 - want everything to communicate i don't
26:52 - want to have those internal references
26:54 - pointing to other components inside of
26:56 - my game i want all of my code to be
26:59 - very self-contained and when i have it
27:02 - interact with other components inside of
27:04 - my code i want it to be in a safe
27:06 - context kind of like the main js file
27:08 - that's where i'm going to do most of my
27:09 - editing
27:10 - so anyway
27:11 - i'm getting information from the
27:13 - controller i'm just saying is the
27:14 - controller being pressed are these keys
27:17 - active on the keyboard and if so i'm
27:19 - going to execute a corresponding
27:21 - function function on my player object
27:25 - finally i'm going to call game.update
27:27 - and game.update is going to go ahead and
27:30 - call
27:31 - world.update world.update is going to
27:33 - call all this stuff
27:35 - and that's going to give me these nice
27:37 - cool physics and take care of all my
27:39 - numbers and player position and velocity
27:42 - and whether or not he's colliding and
27:43 - that's going to take care of all of the
27:45 - physics logic in my game it's also going
27:47 - to change the player color
27:51 - alright so now i just talked about what
27:54 - actually makes the game logic work and
27:56 - that is of course the game class itself
27:58 - stored in the game o2 file so now i have
28:01 - to talk about how i'm getting
28:03 - keyboard input and relaying that to the
28:06 - game class so it can actually take that
28:08 - input and do something with it so i just
28:10 - showed you inside the main
28:12 - file here that i'm i'm conveying the
28:15 - keyboard's input via the controller
28:17 - object to
28:19 - the game object and telling the game
28:21 - object to do something with the player's
28:22 - position like move left move right or
28:24 - jump
28:25 - and that's all going to happen depending
28:27 - on what the controller object is doing
28:29 - so let's take a look at the controller
28:31 - class and see how that works
28:34 - so the controller class just has three
28:37 - objects here a left right and up object
28:39 - and those objects are going to be
28:41 - controller dot button input classes so
28:44 - let's take a look at the button input
28:45 - class and see what it is it's really
28:47 - really simple all it is is an object
28:49 - that has two
28:50 - boolean values inside of it one called
28:53 - active and one called down now active is
28:56 - gonna hold the virtual state of our
28:58 - button
28:59 - so
29:00 - i'll get into that in a little bit
29:01 - because it has to do with jumping and
29:03 - down is going to refer to the physical
29:06 - state of our button on the keyboard so
29:07 - if i physically press the up key down
29:11 - down is going to be true and if i hold
29:13 - that key down it's going to remain true
29:16 - the active value however is going to
29:18 - depend more on my actual game's logic so
29:22 - just remember keep in mind that down
29:23 - refers to the physical state of the
29:25 - button on my keyboard and that's what
29:26 - that is going to track and active is
29:28 - just going to track
29:30 - uh what that value is of my button
29:33 - object inside of my game's code or my
29:35 - game logic
29:37 - so now that you know what the button
29:39 - input class is
29:41 - these three objects are going to be
29:44 - button inputs and this key down up event
29:47 - handler function is going to be called
29:49 - every time i press a key on my keyboard
29:52 - whether i press it down or it comes back
29:54 - up this is going to be called it's going
29:55 - to check to see what the event type is
29:57 - key down or key up so when i press a key
30:00 - down on the keyboard
30:01 - the type's going to be key down when i
30:03 - release that key it's going to be key up
30:06 - and depending on which one it is it's
30:07 - either going to be true or false and
30:10 - then i'm just going to use the get input
30:12 - method of my button input class
30:15 - and hand in that
30:17 - down value which is either going to be
30:18 - true or false
30:19 - and that's going to look like this it's
30:22 - just going to say if
30:24 - the
30:24 - key
30:25 - tracker or the
30:27 - button input object
30:29 - if that currently is down the state is
30:32 - currently down
30:33 - or if the state is not equal to whatever
30:36 - we're handing in then we're going to set
30:38 - active equal to whatever we're handing
30:39 - in and we're just going to set down
30:41 - equal to whatever we're handing in
30:42 - because that's going to be the physical
30:44 - state of the button
30:46 - pretty
30:47 - simple maybe not so simple take a look
30:49 - at the source code and fiddle around
30:50 - with it because that's really the best
30:52 - way to get an idea i'm just here running
30:54 - over everything i'm trying to get it
30:55 - done quick because this video seems like
30:57 - it's going to go long i don't want it to
30:59 - go too long but basically this is a
31:00 - controller class just takes keyboard
31:03 - input and i'm adding the event listener
31:06 - for the controller
31:08 - component inside not my engine but
31:10 - inside of my main javascript file at the
31:13 - bottom if i come all the way to the
31:15 - bottom you can see i'm adding the key
31:16 - down and key up listener to the key down
31:19 - up
31:20 - function which i'm defining also inside
31:22 - of my main file and that is just going
31:24 - to call the controller's key down up
31:27 - method and hand in the event.type and
31:30 - the
31:31 - code which we use to determine
31:36 - what the type is whether it's a down
31:38 - press or an up press
31:40 - and the key code is just going to
31:42 - determine which key on the keyboard i'm
31:43 - pressing so 37 38 and 39 are the left up
31:47 - and right arrow keys on the keyboard
31:50 - so basically this controller class just
31:52 - gets keyboard input and then we relay
31:55 - that input to
31:57 - the
31:59 - game component right here in the main js
32:02 - file
32:03 - inside of its update function which is
32:04 - called on every frame of animation
32:07 - managed by our engine which i'm going to
32:09 - talk about later on in this video so
32:11 - really simply just checks to see if the
32:14 - left right and up keys are active
32:16 - and then it goes ahead and it calls a
32:19 - player movement function so move left
32:21 - move right or jump so where the active
32:24 - value comes into play here is when the
32:26 - player is jumping so
32:28 - notice that i'm actually setting the
32:30 - virtual state of the controller dot up
32:32 - button input
32:34 - to false i'm changing the active value
32:36 - to false so that's going to give me the
32:39 - ability to press my key once and hold it
32:41 - down and not have my player jump again
32:43 - if i were to come in and comment this
32:45 - line of code out like this
32:48 - and just go
32:50 - like this comment this guy out save my
32:53 - file come over here to my browser
32:54 - refresh
32:56 - now i'm just going to jump up and down
32:58 - continuously
32:59 - now this might be desirable for some
33:01 - people for some games this might be what
33:03 - you want but for other games you're not
33:05 - going to want to keep on jumping just
33:06 - because you have the key pressed down so
33:09 - if that's something you want in your
33:11 - game
33:12 - not having the player jump up and down
33:14 - continuously as your button is pressed
33:16 - in
33:17 - this controller class
33:19 - right here
33:20 - and these
33:22 - button input objects here with this dual
33:26 - virtual and physical uh button state
33:29 - tracker
33:31 - objects here these boolean values
33:33 - this is going to allow you to prevent
33:35 - your player from just jumping up and
33:36 - down continuously and you're going to
33:38 - get functionality that looks like this
33:40 - instead you're just going to be able to
33:41 - jump one time and
33:43 - only jump when you press the key rather
33:45 - than jumping just continuously if you
33:48 - have the key held
33:50 - down all right so now that you know how
33:53 - to define the player object and the
33:55 - world
33:57 - object in our game class and you know
34:00 - how to get user input to actually
34:01 - control this guy and move them around
34:03 - the screen
34:04 - the only thing left is how to draw this
34:06 - guy so how we're drawing the player
34:09 - object and the world itself to this
34:11 - canvas element is with the display class
34:13 - so inside of the display class i just
34:15 - define a buffer and a context of my
34:17 - canvas so these are two uh 2d rendering
34:21 - contexts canvas rendering context
34:25 - context is the rendering context of the
34:27 - on-screen canvas that you see on screen
34:29 - buffer is just an off-screen canvas that
34:32 - is going to be sized perfectly to match
34:35 - our world height and width so if we come
34:37 - back into our game and scroll down here
34:40 - the buffer canvas is going to be sized
34:43 - at 72 pixels high and 128 pixels wide
34:46 - and that is actually going to happen all
34:48 - the way at the bottom of our main.js
34:50 - file and the reason for that is just so
34:52 - everything scales the way it should so
34:54 - i'm setting that up right here in the
34:56 - initialization portion of my main.js
34:58 - file
35:00 - so let's get back into display and talk
35:02 - a little bit more about it
35:03 - so i've added a couple different
35:05 - functions i have the fill function or
35:07 - method all it does is take a color and
35:09 - draw it to the buffer which remembers
35:11 - the off-screen canvas which is then
35:13 - drawn by the render function to our
35:16 - on-screen canvas it draws this
35:18 - off-screen buffer canvas to the
35:20 - on-screen
35:22 - display canvas that you actually see in
35:23 - the browser window
35:25 - so the fill method just fills the buffer
35:27 - with color
35:28 - render renders that buffer to the screen
35:30 - draw a rectangle just draws this
35:33 - rectangle here that's what i'm handing
35:35 - in in terms of x y width and height and
35:38 - color
35:39 - and it just draws that to the buffer as
35:40 - well i'm actually rounding down the x
35:43 - and y positions of the rectangle that
35:45 - i'm handing in this way it doesn't
35:47 - render it on a half pixel so let's see
35:50 - what happens when i take this code out
35:52 - first let's uh take a look at what this
35:54 - guy actually looks like moving around
35:55 - the screen
35:56 - so pretty smooth
35:58 - nothing weird going on
36:00 - all the edges look pretty straight if i
36:02 - come in here and i just put in
36:05 - x and y though let's take a look and see
36:07 - if anything changes
36:12 - as you can see
36:14 - it looks a little bit funky i mean it's
36:16 - hard to tell because
36:20 - i have this background let's actually go
36:21 - in here and change the background color
36:23 - of my game to something else here let's
36:25 - uh let's make it
36:27 - black instead
36:29 - zero zero zero zero zero zero that's
36:31 - going to give me black i'm gonna come in
36:32 - here refresh my screen
36:34 - take a look at the player character you
36:36 - see how his edges are kind of messed up
36:38 - they're kind of wavering a little bit
36:41 - kind of looks like he's just fading
36:43 - around instead of just sitting on the
36:45 - exact pixel he's meant to sit on well
36:47 - that is actually because he's sitting on
36:50 - half pixels from time to time and you
36:52 - can fix that by rounding down the values
36:54 - you pass into your draw method so we can
36:57 - go from this which looks a little bit
36:59 - funky
37:00 - to
37:00 - this
37:02 - which now looks really sharp and
37:05 - not so funky at all it's basis basically
37:07 - the best we can get
37:09 - on a
37:10 - html5 canvas so now let me set back my
37:13 - background color to the way it was
37:15 - before so we could have that nice
37:18 - fading effect that follows the character
37:20 - around refresh my screen
37:23 - and so that's
37:24 - what i'm going to use to draw my
37:26 - rectangle to the screen and round him to
37:28 - the nearest
37:29 - full pixel location with math.floor so
37:32 - he doesn't get that weird blur around
37:33 - the edges now let's take a look at the
37:36 - main.js file and that's where all of
37:37 - these are going to be called actually i
37:39 - think inside of
37:41 - actually no i'm wrong let's just take a
37:42 - look at the main js file and see where
37:44 - these guys are called
37:46 - i think it's going to be inside of the
37:47 - render function i haven't looked at this
37:49 - code in a little bit
37:50 - so we have display.fill
37:52 - and by the way the render function is
37:54 - going to be called by our game engine
37:56 - which is our game loop on every frame of
37:58 - the animation so 30 times every second
38:02 - so we call display.fill that's going to
38:05 - fill our background color with this nice
38:07 - dark gray here we're going to call
38:10 - drawrectangle and hand in the
38:12 - game.world.player which is a rectangle
38:14 - we're going to hand in all those values
38:16 - as well as the color value
38:20 - and finally we're going to call
38:23 - display.render and that's going to draw
38:24 - the buffer that we just filled with the
38:26 - background color and drew the rectangle
38:28 - to and we're going to draw that that
38:30 - buffer to the final display canvas now
38:33 - one more thing i want to talk about here
38:35 - because this is pretty simple stuff is
38:37 - the resize functionality so the resize
38:40 - functionality is going to take care of
38:42 - scaling my on-screen canvas it's also
38:45 - going to take care of keeping the aspect
38:47 - ratio of the game world which you
38:49 - remember has the height and width
38:51 - coordinates
38:52 - it's going to keep that aspect ratio
38:54 - from the game world
38:55 - and the buffer to the final display
38:58 - canvas so we get a nice square rectangle
39:01 - every time so
39:03 - what's important about that well if we
39:04 - come down here i told you that we're
39:07 - going to set our buffers
39:08 - canvas height and width to the game
39:10 - world height and width now if i were to
39:12 - change this and say height times 0.5
39:16 - obviously that would warp our game a
39:17 - little bit so let's take a look at that
39:19 - and what that looks like
39:22 - oh
39:23 - kind of cut off half the world but you
39:25 - can see that when i jump up the player
39:27 - is actually a lot taller than he is wide
39:30 - by about twice as much
39:32 - so
39:33 - let's set back that that back to normal
39:35 - and
39:36 - go ahead and take a look at the resize
39:38 - function
39:40 - which i'm adding to the window that
39:42 - handles all of that stuff so resize is
39:44 - right here it's going to call
39:46 - display.resize and it's going to hand in
39:49 - document.documentelement.clientwith and
39:51 - klein height it's going to subtract 32
39:53 - pixels from both of those to give us
39:55 - this nice 16 pixel margin on either side
39:58 - of our display canvas which i have to
39:59 - refresh so it goes back to the way it's
40:01 - supposed to be so that's what that's
40:03 - doing those 32 pixels then it's going to
40:06 - hand in an aspect ratio of our game
40:08 - world which is going to be just the
40:10 - height divided by the width of our game
40:12 - world so now let's take a look inside of
40:14 - the display
40:16 - object's resize method and see what it's
40:18 - actually doing
40:21 - so here i am inside of the resize method
40:24 - and as you can see it's not super
40:25 - complicated it's actually pretty simple
40:27 - it's basically just going to say if the
40:30 - height and width ratio that we handed in
40:34 - from
40:36 - document.documentelement.com with
40:37 - incline height minus 32 pixels to give
40:39 - us that nice 16 pixel margin on each
40:41 - side it's going to say if that ratio is
40:43 - greater than the height width ratio of
40:46 - the world object
40:48 - the game world
40:50 - then if that height with if the screen's
40:52 - height width ratio is greater than the
40:53 - height width ratio of the world then
40:55 - we're going to set the canvas's height
40:57 - to the width times the ratio and we're
40:59 - going to set the canvas's width to the
41:01 - width of the screen so right now we have
41:03 - a max width scenario
41:05 - otherwise we don't have a max width
41:07 - scenario we have a max height scenario
41:09 - and it's going to set the canvas's
41:10 - height to the max height and it's going
41:12 - to set the width to the
41:15 - height divided by the height with ratio
41:17 - so this code is basically going to allow
41:19 - me to do
41:20 - this if i come in here
41:22 - and i change the scale of my window
41:26 - as you can see it's always going to keep
41:27 - it centered right now i have a max
41:29 - height situation and i have a shorter
41:31 - width in my game world but the aspect
41:33 - ratio remains the same
41:35 - and
41:36 - here i'm going to go back down somewhere
41:38 - around here i'm going to change over
41:40 - from a max height situation to a max
41:42 - width situation
41:43 - and now you can see my display canvas
41:46 - gradually getting smaller in height
41:49 - so that's pretty cool that's the display
41:51 - function takes care of resizing the
41:54 - canvas and maintaining that nice aspect
41:57 - ratio so our game can scale nicely
41:59 - across many different devices
42:04 - alright so now i'm going to do a brief
42:06 - run through of my fixed time step game
42:10 - engine and this is the game engine class
42:13 - it's in the engine file i haven't
42:14 - changed it since part one of this series
42:17 - it's exactly the same as it was although
42:19 - i did add in this accumulated time
42:22 - variable definition because it wasn't in
42:24 - here
42:25 - it was actually being added later right
42:27 - here so i just fixed that but it's
42:29 - basically exactly the same
42:31 - so
42:32 - what a fixed time step game loop does
42:35 - is it causes your game to update and
42:37 - draw
42:39 - at a fixed rate as time passes and it
42:42 - does that by taking a time step value
42:44 - which in this case is going to be 1000
42:47 - divided by 30 if i come over to my main
42:49 - js where i actually instantiate this
42:51 - i am
42:54 - passing 1000 divided by 30 which is
42:56 - roughly 33.3
42:59 - repeating forever and that is going to
43:01 - be the number of milliseconds that i'm
43:03 - going to call render and update on so
43:05 - every 33.33 milliseconds i'm gonna call
43:08 - render and update
43:10 - and the render and update functions are
43:12 - just right here
43:13 - you've seen them throughout this video
43:14 - and they're basically just going to
43:16 - update my game logic
43:18 - and render the changed game state to the
43:21 - screen
43:23 - let's hop back inside of the engine and
43:25 - talk about this game loop some more
43:27 - alright so we've got
43:30 - our time step and that's going to be in
43:32 - this case about 33.33 milliseconds and
43:36 - so every 33.33 milliseconds i'm going to
43:38 - call the update and render function i
43:40 - passed in they're going to be stored
43:41 - right here
43:42 - and i'm going to keep track of how much
43:45 - time has passed in the accumulated time
43:48 - variable
43:49 - so every time
43:51 - 33.33 milliseconds passes hopefully our
43:54 - our game is updating close to that but
43:56 - anything that overflows is going to be
43:59 - stored in accumulated time so let's say
44:01 - 33.33 is our minimum time step and
44:03 - that's exactly what it is but let's say
44:05 - uh request animation frame which is what
44:08 - we're using to update our game logic
44:10 - fires at 40 milliseconds now we're gonna
44:13 - have about what is that
44:15 - seven six something about six
44:18 - milliseconds left over and we're going
44:20 - to store that in accumulated time and
44:22 - when accumulated time reaches our time
44:25 - step or 33.33
44:27 - we're going to update or call update one
44:29 - more time so basically we're storing all
44:32 - the time that passes in accumulated time
44:34 - and we're just taking bites out of that
44:37 - accumulated time we're taking 33
44:39 - millisecond bytes out of our accumulated
44:42 - time
44:43 - the time value is just going to be the
44:45 - last time our run function executes and
44:49 - this is just going to be the looping
44:51 - function this is going to be the
44:52 - function that loops over and over again
44:54 - a lot of game engines will call this
44:56 - cycle
44:57 - some call it loop i'm just calling my
44:59 - run because
45:00 - engines run so this is going to be one
45:03 - run of the game loop so inside of the
45:05 - run function
45:07 - we're adding the current time stamp
45:09 - that's handed to us by request animation
45:11 - frame we're
45:13 - subtracting the current time or the last
45:16 - time our game executed from the current
45:18 - time and we're adding that to
45:19 - accumulated time
45:20 - so let's say that our the last time our
45:23 - game executed was at 100 milliseconds
45:26 - and we're just now getting in a new call
45:29 - to the run function from request
45:31 - animation frame and it's going to happen
45:32 - at
45:33 - 140 milliseconds so we're going to have
45:36 - 140 milliseconds minus 100 milliseconds
45:39 - and 40 milliseconds is going to go into
45:41 - accumulated time
45:43 - so
45:44 - now we have 40 milliseconds in
45:46 - accumulated time we're just going to set
45:48 - the the new
45:49 - most recent time value to the current
45:52 - time value but just remember 40
45:53 - milliseconds in accumulated time here is
45:56 - where the fixed time step game loop
45:57 - really shines because this well actually
46:00 - this is just a safety i'm not going to
46:02 - talk about but but this is where it
46:03 - really shines the while
46:05 - loop
46:06 - so remember we have 40 milliseconds of
46:08 - accumulated time
46:10 - and we have our 33
46:12 - i'm going to round that down to 33 or 33
46:14 - milliseconds in our time step
46:17 - so 40 is greater than 33 so while 40 or
46:20 - our accumulated time is greater than our
46:22 - time step we are going to reduce our
46:25 - accumulated time by the time step we're
46:27 - going to call update
46:29 - and we're going to set this updated flag
46:31 - to true but don't worry about that too
46:32 - much
46:33 - so then we're going to loop again and
46:35 - see if that's true again and we
46:38 - subtracted 33 from 40 so that's going to
46:40 - give us
46:41 - 7
46:42 - and 7 is no longer greater than our time
46:44 - step so we're not going to update again
46:46 - but let's say that accumulated time was
46:48 - equal to 70.
46:51 - okay so now we have 70. 70 is greater
46:54 - than 33 so we're going to call update
46:57 - then we're going to try to loop again
46:58 - well 70 minus 33 what is that
47:02 - 47 is that accurate anyway 47 is still
47:06 - going to be greater whatever it is it's
47:07 - still going to be greater than 33 so
47:09 - we're going to update again so even if
47:11 - we didn't have another request animation
47:15 - frame event fire and we didn't update
47:17 - the screen again we're still going to be
47:19 - updating twice on the next time request
47:22 - animation frame fires and gives us a new
47:27 - run command or we're going to call run
47:28 - again so we're going to be keeping up
47:31 - with time no matter what happens so even
47:34 - if our game runs really slow and laggy
47:37 - it's still going to keep up with time
47:39 - and it's going to run at the same
47:42 - rate basically on any device regardless
47:45 - of how slow it is unless the device is
47:46 - so slow that it just can't handle the
47:49 - game and then it will crash but that's
47:50 - that's not something you really should
47:52 - worry about uh unless your game is
47:54 - crashing all devices but if your game is
47:56 - just crashing the you know computers
47:59 - from
48:00 - 1995 then you shouldn't worry about it
48:04 - but basically the fixed time step game
48:06 - loop just says
48:07 - if too much time has passed or if a
48:09 - certain amount of time has passed we're
48:11 - going to update our game at whatever
48:13 - rate we want it to update until we have
48:16 - caught up with however much time has
48:17 - passed and that's a really great
48:18 - functionality of fixed time step game
48:21 - loops and it's a great reason to add
48:22 - them in to any game that you're writing
48:25 - so now down here we have the updated
48:27 - flag basically we turn that flag on we
48:30 - set it to true anytime we do an update
48:32 - and then if it is true if we have
48:35 - updated then we're going to call the
48:36 - render function and that's just going to
48:38 - draw our game
48:39 - so
48:40 - why is this good well let's say
48:45 - accumulated time only has 20
48:46 - milliseconds in it but we need 33
48:49 - milliseconds to justify an update
48:51 - otherwise we'd be going
48:53 - faster than we want to update well if
48:55 - that's the case then this never fires we
48:58 - never update our game and if we don't
49:00 - update our game nothing has changed and
49:03 - anything we draw is just going to be a
49:05 - waste of cpu or gpu so we don't want to
49:09 - draw anything that hasn't been updated
49:10 - or changed so if no update has occurred
49:13 - update updated stays false
49:16 - and we don't draw
49:18 - and finally inside of the run function
49:20 - we just make another call to the
49:22 - handlerun method and the handlerun
49:24 - method is just down here it's just an
49:26 - arrow function that calls uh the
49:29 - engine.run method now the reason i'm
49:31 - using an arrow function is because
49:33 - if you've worked with event listeners or
49:35 - request animation frame before the this
49:37 - keyword inside of
49:40 - whatever function you hand into
49:42 - your event listener as your event
49:45 - handler or request animation frame as
49:47 - your response to a request animation
49:50 - frame event firing is going to point to
49:52 - the object that you request the frame or
49:54 - add an event listener to so in this case
49:56 - it's the window so i don't want this to
49:58 - refer to window
50:00 - i want this to refer to my actual engine
50:02 - object so by using this arrow function
50:05 - i can actually make this refer to my
50:08 - engine object rather than the window so
50:10 - that's the only reason i have that kind
50:12 - of set up as an arrow function there to
50:14 - make sure that this keyword is referring
50:16 - to engine instead of window otherwise i
50:19 - would have to have
50:21 - a reference to
50:22 - engine
50:23 - inside of the engine and that just is
50:25 - really
50:27 - it just seems really sloppy to me so i
50:29 - set up the arrow function and that's
50:30 - what that does
50:32 - and anyway i hope that was a good
50:34 - explanation of a fixed time step
50:36 - engine
50:37 - and
50:39 - probably wasn't the best i was kind of
50:40 - going through it really fast it's really
50:42 - cold in this room where i'm recording
50:43 - and i'm kind of i'm like freezing to
50:45 - death so
50:46 - don't hold it against me i should turn
50:48 - up the heat but
50:50 - you know just i'm doing what i'm doing
50:52 - here so hopefully that was a good enough
50:53 - explanation of a fixed time step game
50:56 - loop and if not definitely take a look
50:58 - at the source code i commented
51:00 - everything in here so you guys can get a
51:01 - better understanding of the code as you
51:04 - read through it line by line
51:06 - in this video i showed you how to lay
51:08 - the groundwork for any platforming game
51:10 - so far i've implemented keyboard input
51:12 - simple platforming physics scaling for
51:14 - multiple devices and a fixed timestep
51:16 - game loop to handle updating your game
51:18 - at a consistent rate no matter what
51:19 - device it's on which is perhaps the most
51:22 - important thing you could take away from
51:23 - this video
51:25 - i'm going to show you how to draw a
51:27 - tiled background from a one-dimensional
51:28 - tile map i'm going to talk about the
51:30 - example program and what i've added
51:32 - since part two then i'm going to talk
51:34 - about how to load the tilesheet image
51:35 - and store in a tilesheet class finally
51:38 - i'll show you the tile map in the game
51:40 - class and how it's drawn
51:43 - alrighty guys let's take a look at what
51:45 - has changed since part two if i come
51:47 - over here in the browser first i'm gonna
51:49 - real quick i'm gonna go ahead and i'm
51:51 - gonna pull up part two so you guys can
51:53 - see it
51:54 - and that is right here i'm gonna press
51:56 - enter load up part two
51:58 - and
51:59 - this is part two so as you can see i
52:01 - have some jumping physics i get keyboard
52:03 - input but there's no tile background and
52:05 - to make this game i'm definitely going
52:06 - to need a cool tile background so let's
52:08 - go over to part three and check out what
52:11 - we've done there
52:12 - alright so this is part three
52:14 - and as you can see it's a lot better i
52:17 - still have the same
52:18 - game physics where my character jumps
52:20 - around and moves around same fluid
52:22 - physics exact same physics code the only
52:25 - difference now is the world is a
52:26 - different size and i have a tile map
52:28 - inside of it
52:30 - also the color of the character
52:32 - is just a solid white and gray the
52:34 - reason i did that was to more closely
52:36 - resemble the player sprite we're gonna
52:38 - be using which is this little rabbit
52:40 - dude and
52:41 - basically that's it that's all the
52:42 - changes that have happened in part three
52:44 - since part two the files where the
52:46 - changes occurred are display game and
52:49 - main
52:50 - everything else i'm using uh the
52:52 - controller class from part two
52:55 - if i come into my directory here i'm
52:57 - gonna be using the controller class from
52:59 - part two
53:00 - and i'm gonna be using that file and i'm
53:02 - also gonna be using the engine class
53:04 - from part one
53:06 - but this is part three and these are the
53:08 - only three files that you need to worry
53:10 - about if you've already watched part one
53:11 - and two so anyway on to the rest of the
53:14 - video
53:17 - so the first thing we need to worry
53:18 - about for this application is how we're
53:20 - going to get our sprite sheet png image
53:23 - into our javascript so we can actually
53:25 - do something with it and have it render
53:27 - over here on the screen and show up on
53:30 - the background of our canvas element so
53:32 - first we need to define some sort of
53:35 - container for our sprite sheet image and
53:38 - its different
53:40 - variables
53:41 - and we do that inside of the display
53:42 - class so here's my display class it's
53:45 - one of the files that has changed since
53:46 - part two and inside of it
53:49 - i define a
53:51 - class called tilesheet i come down to
53:53 - the bottom here here's my tile sheet
53:55 - class it's just a really simple object
53:57 - it has an image inside of it
53:59 - this image object is going to store our
54:02 - tile sheet or our sprite sheet
54:04 - and then it records the tile size and
54:07 - i'm just going to hand in 16 because
54:08 - each one of our tiles is 16 by 16 pixels
54:11 - and the number of columns in our tile
54:13 - sheet so i think that's eight off top of
54:15 - my head but if we come over here and we
54:16 - actually count them
54:18 - we're gonna have
54:19 - one two three four five six seven eight
54:24 - different tiles kind of hard to tell but
54:26 - there's eight tiles or eight columns
54:28 - in this map
54:30 - eight tiles across or eight columns not
54:32 - just eight tiles in the map obviously
54:33 - there's more but
54:35 - so we have to define this tilesheet
54:38 - class and it's just going to have an
54:40 - image which is going to be our image
54:41 - it's going to have the tile size and
54:42 - it's going to have the number of columns
54:44 - in our tilesheet image
54:46 - now that we have this we can actually go
54:48 - about loading this png image into our
54:51 - javascript so we can do something with
54:52 - it where that happens is the main js
54:56 - file for part three so if i come down to
54:58 - the bottom of my file here
55:00 - you can see that
55:02 - i am
55:03 - setting the image
55:05 - of my tilesheet object in the display
55:07 - class i'm setting the source of that
55:08 - image to
55:10 - the rabbittrap.png and that's going to
55:12 - start loading the rabbittrap png image
55:15 - here
55:16 - into the
55:19 - tilesheet objects image
55:21 - and when it's done loading it's going to
55:23 - fire this
55:25 - event listener for loaded so it's going
55:28 - to say okay my image just loaded i have
55:30 - an event listener for that let's call
55:32 - this function the event handler function
55:34 - for a load event there i'm going to
55:36 - resize the screen
55:38 - that's just going to resize the browser
55:40 - window or not the browser window but
55:42 - resize our canvas to fit the browser
55:44 - window rather and it's going to call
55:46 - engine.start that's going to start our
55:47 - game loop off and then we're actually
55:49 - going to be able to use that graphic
55:50 - because if we start our engine before
55:53 - the graphic is fully loaded we're going
55:55 - to try to draw graphics that just aren't
55:57 - loaded yet and that's a problem so make
55:59 - sure that your graphic is fully loaded
56:01 - with an event listener for load before
56:03 - you actually start your engine
56:06 - also down here this extra parameter once
56:09 - colon true that just tells this event
56:12 - listener to only fire once and after
56:14 - it's done it just
56:16 - junks it
56:17 - sends it to the trash sends it to
56:19 - garbage collection we don't have to
56:21 - worry about removing this event listener
56:23 - from our tile sheet image because this
56:26 - parameter here just takes care of it
56:30 - all right so now that we've loaded our
56:32 - tile sheet image into our javascript we
56:34 - actually have to get these individual
56:36 - images out of this sprite sheet or tile
56:39 - sheet we have to draw them to different
56:42 - locations on the canvas to create
56:44 - something of a tiled map like you see
56:46 - here
56:47 - so how do we do that well it starts out
56:49 - in the game class and i have a
56:53 - map inside of my game class inside of
56:55 - the world
56:56 - and basically it's just a big long array
56:59 - of values that point to different
57:01 - locations in the tile sheet so the best
57:03 - way i can explain this to you is by just
57:05 - giving you an example and i'm gonna look
57:07 - down here in the bottom right of my
57:09 - numeric tile map at these three values 1
57:13 - 43 and 10. now these values correspond
57:16 - to locations inside of my tile sheet
57:18 - graphic
57:19 - and they also correspond to these
57:21 - locations on the map so this is the one
57:25 - tile this here is going to be the 43
57:27 - tile and this
57:29 - over here is going to be the 10 tile and
57:31 - as you can see you can kind of make that
57:33 - connection those three tiles are going
57:35 - to be in this bottom right hand corner
57:38 - of the map so now let's take a look at
57:41 - these tiles inside of the sprite sheet
57:43 - itself
57:44 - we're going to have one so that's going
57:46 - to be for this example it's going to be
57:47 - at position one in our map normally i
57:50 - start at zero i start counting at zero
57:52 - but for this example i'm gonna start
57:53 - counting at one so
57:56 - tile one is just going to be this corner
57:58 - tile and as you can see right here in
57:59 - the map
58:00 - it is that corner tile
58:03 - these two tiles are the same so
58:05 - tile one is just gonna be this one right
58:07 - here and if you think about it makes
58:09 - sense because this is the first tile
58:11 - index in the map so just go 1 2 3 4 5 6
58:15 - 7 8 9
58:17 - 10
58:18 - and remember this is tile 10
58:21 - we have our 10 tile right here
58:23 - and it's just a plain clear brown tile
58:26 - and if i come back to my map you can see
58:29 - that that is in fact valued at tile 10.
58:33 - so now you kind of understand or
58:34 - hopefully you understand the correlation
58:36 - between these values in a
58:38 - one-dimensional tile map
58:41 - and
58:42 - the images on screen
58:43 - as well as the locations of those images
58:48 - in the tile sheet image itself but just
58:51 - because we have the map doesn't mean
58:52 - we're actually drawing this stuff to the
58:54 - screen we actually have to write a
58:55 - function for that and that function is
58:57 - going to be inside of the display class
58:59 - and it's a function called draw map
59:02 - and it's just going to take the map
59:04 - which is just that array of values so
59:05 - it's just going to be this i'm going to
59:07 - hand in
59:08 - and the number of columns in the map and
59:10 - we have 12 columns on our map i define
59:12 - that here 12 columns if you count i
59:14 - actually have 1 2 3 4 all the way to 12
59:16 - columns inside of my map if you look at
59:19 - the screen you can count 12 tiles across
59:22 - so this draw map function is just going
59:24 - to take the map and it's going to take
59:25 - the columns and it's going to loop
59:27 - through every single value in the map
59:30 - so it's going to loop through every
59:31 - single number right here
59:34 - and it's going to get the value there i
59:37 - subtract 1 from it and that's going to
59:40 - if i don't subtract 1 this is what
59:42 - happens
59:44 - if i just add 0 let's take a look real
59:46 - quick and see what happens and i'll show
59:48 - you a really simple way to remedy this
59:50 - which i didn't use because i used the
59:52 - tile map editor to make this because i
59:53 - have really complex tiles here but this
59:56 - is what it looks like it's because all
59:57 - of my tile values are offset by one
60:01 - now i set it back to negative one the
60:02 - reason for that is
60:04 - in my tile map these are all one higher
60:08 - than they should be so this should
60:09 - actually be 17
60:11 - this should be 48 this should be 49
60:14 - this should be 31.
60:16 - they're all offset by one that's just
60:18 - because the tilemap editor i use which
60:20 - is tiled exports the comma separated
60:23 - values
60:24 - uh starting at one instead of zero i
60:27 - didn't feel like going through and
60:28 - changing all these so hopefully this
60:29 - doesn't throw you guys off too much
60:31 - don't worry about it when you make your
60:32 - maps just make sure you have the right
60:34 - value starting at index zero in your
60:36 - tile sheet so basically instead of this
60:38 - being one it would be zero and you start
60:41 - counting from zero
60:43 - but if you want to use a map editor like
60:46 - tiled and you don't mind just having
60:48 - that offset
60:49 - it's really simple all you have to do is
60:50 - subtract one from the tile value and
60:52 - you're good to go so anyway that aside
60:55 - let's get into how i'm actually placing
60:57 - those images from the source onto the
60:59 - buffer and then drawing it on the screen
61:01 - so i get the different values or i get
61:04 - the value of the specific tile in the
61:05 - map that i'm looping over
61:08 - i get the source
61:09 - x and y position that i'm going to cut
61:11 - it out of the tile sheet at
61:13 - and that's what this code right here
61:15 - does
61:16 - it just takes the number of columns in
61:18 - the tile sheet takes the value
61:20 - that gets the column and then you
61:22 - multiply by the tile size
61:25 - to get the actual position to cut out of
61:27 - inside of the tile sheet image
61:30 - oh didn't mean to do that
61:32 - but that's basically just getting the x
61:33 - position to start cutting out of uh
61:36 - come back in here then we have the y
61:38 - value that's going to get the y position
61:40 - to start cutting out of and then
61:42 - when you get the source you're going to
61:44 - hand in the source x and y which is just
61:46 - these two values here and the tile
61:49 - height
61:50 - and tile width which i just have one of
61:52 - it's tile size and it's 16 pixels so
61:54 - source x and source y
61:57 - are going to get me to the appropriate
61:58 - tile say i am at tile
62:01 - 8
62:02 - that's going to put me right here
62:04 - it would actually be a value of 7 but
62:05 - that's going to put me right here
62:07 - and then i'm going to cut 16 pixels wide
62:10 - and 16 pixels high so the y value would
62:13 - be 0 the x value would be
62:17 - 128 minus 16 to get me right here to the
62:20 - left side of this tile and then because
62:22 - 120 is the width of my map and it's just
62:25 - going to cut this tile out
62:27 - so pretty simple
62:29 - come back here display look the rest of
62:30 - this destination it kind of looks like
62:32 - the same kind of mathematical formula
62:35 - i'm just using the number of columns in
62:37 - my game world which you remember is 12
62:39 - so that's the number of columns in this
62:40 - map
62:41 - and
62:42 - i'm multiplying that by 16 as well
62:47 - now i guess i should be using the
62:49 - game.world
62:51 - dot tile size but i'm just using 16 for
62:54 - both so i guess it doesn't really matter
62:56 - and then finally you're going to use
62:58 - this information to cut the appropriate
63:00 - image out of your tilesheet image and
63:03 - draw it into your buffer which is then
63:06 - going to be drawn to the final on-screen
63:09 - canvas so you're just going to say
63:11 - i want to draw an image to my buffer
63:14 - from the tile sheet image
63:17 - and i'm going to cut the image out of
63:18 - the tile sheet out at source x and
63:20 - source y
63:22 - and
63:23 - tile size width and tile size height i'm
63:26 - going to draw it to the buffer at
63:27 - destination x destination y at the
63:31 - 16
63:32 - by 16 width and height
63:34 - so that's all that does and then if i
63:35 - come out here into my main js file and i
63:39 - come down to the or up rather to the
63:42 - render function you can see that i'm
63:44 - calling the
63:45 - display.drawmap function i'm handing in
63:47 - the game.world.map
63:49 - and thegame.world.coms into that
63:51 - function and that is how
63:55 - you draw all those tiles to the game
63:58 - screen
63:59 - i talked about how to load a sprite
64:01 - sheet image into your javascript how to
64:03 - create a tile map array and how to draw
64:05 - tiles from the sprite sheet to to
64:07 - display canvas if you're worried that
64:09 - there was a lot of code i didn't cover
64:11 - don't all you need to know is how these
64:13 - basic components work together in order
64:15 - to build them yourself chances are your
64:17 - application structure will be different
64:18 - from mine so don't focus too much on
64:20 - what i didn't show you and instead try
64:21 - to build the components i'm talking
64:23 - about into your own application
64:25 - this stuff really works and if you need
64:26 - the source code you can find it on my
64:28 - github page
64:30 - i'm going to show you the aspiring game
64:32 - programmer how to add pixel perfect
64:34 - professional quality tile-based
64:36 - collision detection and response to a
64:38 - platforming game i'm going to talk about
64:40 - what's changed since part three then i'm
64:42 - going to go over the three main
64:44 - components of my collision system
64:46 - there's the broad phase the routing
64:47 - function and finally the narrow phase
64:50 - let's take a look at what's changed
64:52 - since part three so this is part four it
64:54 - looks just like part three for the most
64:56 - part except now i have collision
64:59 - detection and response between my player
65:01 - character and the game world so as you
65:03 - can see i'm i'm moving smoothly across
65:05 - the tops of the tiles i'm jumping up
65:07 - along the sides of the tiles i'm not
65:09 - getting hung up on any of the edges
65:11 - anywhere i can jump through the bottoms
65:13 - of these platform tiles basically i have
65:15 - pixel perfect tile based collision
65:17 - detection and response and everything
65:20 - looks and works the way you would expect
65:22 - it to in a tile-based platforming game
65:24 - so now that you know what the example is
65:26 - all about let's take a look at what's
65:28 - changed in the code so the only two
65:30 - files that have changed since part three
65:32 - are the game file which holds the game
65:33 - class and the display file which holds
65:36 - the display class
65:37 - display had a minor change since part
65:39 - three if you remember part three i had
65:41 - an issue with the export values for my
65:44 - tile map because i used the tile map
65:46 - editor and all the values were offset by
65:49 - one so i just changed this function and
65:52 - i changed my tile map values to what
65:54 - they're supposed to be so i got rid of
65:56 - the offset as you see i have the comment
65:58 - no longer subtracting one take a look at
66:00 - part three so you can see what i'm
66:01 - talking about also in here in the draw
66:03 - player class i change math.
66:06 - floor to math.round in this line and
66:08 - this line here and the reason is because
66:11 - it just rounds my player to the
66:13 - appropriate
66:14 - spot that he's going to be drawn in more
66:16 - smoothly so those are two really minor
66:19 - changes in the display
66:20 - file inside the game file a lot has
66:23 - changed i've added
66:25 - the
66:26 - collider function i've added my
66:29 - collision map which is this guy right
66:31 - here a collision map is different than
66:32 - the graphical map for the tiles
66:34 - themselves that you see on the screen
66:36 - these are for the collision shapes
66:38 - uh down here i've amended my collide
66:41 - object function inside of the world
66:42 - class
66:43 - to do the broad phase collision
66:45 - detection and response that are
66:47 - these functions right here
66:50 - then i've also added the collider class
66:53 - the collider class takes care of the
66:54 - routing function as well as all of the
66:57 - narrow phase collision methods like
66:59 - collide platform bottom so cloud
67:01 - platform bottom would be called whenever
67:03 - you
67:04 - physically clyde you're the top of the
67:06 - player with the bottom of a platform so
67:08 - i'm jumping up and clyde platform bottom
67:10 - is firing every time my player hits his
67:12 - head on the bottom of that tile there
67:15 - so
67:16 - that's what that does then i've also
67:18 - added a bass class for the player object
67:21 - called object and that's nested inside a
67:24 - game.world
67:25 - the object is basically just a simple
67:28 - rectangle class
67:29 - and i'm going to talk about x-old and
67:31 - wild and why we need those
67:33 - later on in a different part in this
67:35 - video
67:36 - but basically the object class is just
67:39 - the superclass of the player class now
67:42 - basically the player is going to inherit
67:44 - all of these values from object and it's
67:46 - going to get all of these neat little
67:47 - helper functions to get the different
67:49 - sides of his
67:51 - rectangle
67:53 - so that's all that does and then down
67:54 - here you can see i'm actually extending
67:57 - the object class inside of the player
67:59 - constructor
68:00 - and
68:01 - down here i'm actually extending the
68:05 - player prototype off of the object
68:07 - prototype with object.sine
68:10 - so those are all the changes in part
68:11 - four stay tuned for the rest of the
68:13 - video
68:15 - there are three main components to this
68:17 - approach to tile based collision
68:18 - detection response and those are the
68:20 - broad phase the routing function and the
68:24 - narrow phase and they're all centered
68:25 - around having a collision map full of
68:28 - collision tile values each value
68:30 - represents a different shape or
68:32 - collision shape so for instance if i hop
68:35 - over here i can jump through the bottom
68:36 - of this tile but not fall through the
68:38 - top of this tile here i can cloud with
68:40 - the bottom i can collide with the
68:42 - right side and i can collide with the
68:43 - top of that as well this tile over here
68:46 - these two i can collide with the left
68:47 - side so all of these tile values
68:49 - correspond to
68:51 - collision shapes
68:53 - that have different sides
68:55 - so the broad phase
68:56 - gets what tile my player character is
68:59 - standing on it determines what the value
69:02 - of that tile is that my player character
69:03 - is standing on gets that value from the
69:06 - collision map
69:07 - it then hands that value as well as the
69:10 - player object into the routing function
69:14 - the routing function checks the value in
69:16 - a switch statement and it says okay well
69:18 - let's check for instance i'm standing on
69:20 - top of tile one here
69:22 - this is tile one so the routing function
69:24 - would say okay you're colliding with
69:26 - tile type one
69:27 - and for tile type one i'm going to call
69:30 - a certain set of narrow phase collision
69:33 - detection and response methods so the
69:35 - broad phase determines what the tile
69:37 - value is the routing function determines
69:39 - which narrow phase functions to call and
69:41 - the narrow phase does the final
69:43 - collision detection and response
69:46 - and that's how the system works so stay
69:48 - tuned and i'm going to go into the code
69:49 - that makes that stuff work in detail
69:53 - all right so now i want to talk about
69:55 - the broad phase collision method and
69:57 - that is going to be the collide object
69:59 - function which is located inside of the
70:01 - game.world class so i'm going to come
70:04 - down here and show you what this broad
70:05 - phase does
70:07 - the whole function all it does is first
70:09 - it checks for collision with the
70:10 - outsides of the world and that's going
70:12 - to be this right here that's from part
70:14 - three that's pretty simple stuff and
70:16 - then the other thing it does is it
70:18 - checks all of the different corners all
70:20 - four corners of our player character so
70:22 - i have these four
70:24 - chunks of code i have one here for the
70:26 - top left i have one for the top right
70:28 - one for the bottom left one for the
70:30 - bottom right and that's the end of the
70:31 - function
70:32 - so this is the entire broad phase just
70:34 - these four chunks
70:35 - and this chunk up here which does
70:37 - collision with the boundaries of the
70:38 - world so let's take a look at the first
70:40 - chunk that tests
70:42 - for broad phase collision with the
70:44 - collision map
70:45 - with the top left corner of our player
70:47 - character so
70:49 - what these are are
70:51 - a row and a column value inside of our
70:54 - collision map so top is going to be the
70:56 - row that the top side of our player is
70:57 - in and left is going to be the column
71:00 - that the left side of our player is in
71:02 - so this is going to be the top of our
71:03 - player this is going to be the left side
71:04 - of our player and this is going to be
71:06 - the row that the top is in
71:08 - now if i move the player over here this
71:11 - is going to be the row that he's in and
71:13 - if i check the left side this is going
71:14 - to be the column that he's in if i move
71:16 - him over here now the left side of the
71:18 - player is in this column
71:20 - so pretty simple the math that we use to
71:22 - get the row and column and convert it
71:24 - from the physical
71:26 - xy position of the player to the
71:29 - one-dimensional index
71:31 - or of a row or column value
71:34 - it's not really one-dimensional it's
71:35 - two-dimensional just simplified
71:37 - basically you just get the top of the
71:39 - object which is the y position at the
71:40 - top of the object you divide by tile
71:42 - size that gives you the row of the top
71:45 - and then you do the same thing for the
71:48 - column you just get the left side of the
71:50 - object which is right here you divide it
71:52 - by tile size that's going to give you
71:54 - the column value
71:56 - and then you're going to go ahead and
71:58 - convert those
72:00 - the row and the column
72:02 - into a
72:03 - index inside of our map array or
72:06 - collision map array and you just do that
72:08 - by multiplying the row by the number of
72:10 - columns
72:11 - inside of the collision map ours was 12
72:14 - and then you add the column that the
72:16 - player is standing in so that's the row
72:19 - of the side of the player multiplied by
72:21 - the number of columns in the collision
72:23 - map plus the column of the side of the
72:26 - player
72:28 - pretty simple
72:29 - and then you go ahead and you hand in
72:31 - that value as well as the
72:34 - uh row and column positions of the tile
72:39 - multiplied by tile size to give you the
72:41 - actual x and y position of the tile so
72:44 - for instance if i was going to get the
72:45 - top left of my player that would be
72:47 - right here he's inside of this tile the
72:50 - top and left values multiplied by the
72:52 - tile size is going to give you this
72:54 - position right here which is going to be
72:56 - the x and y position of the tile so
72:58 - we're going to hand all that information
73:00 - into the colliders
73:02 - collide method and that's going to be
73:04 - the routing function you're going to
73:05 - hand in the value you're going to hand
73:06 - in the object you're going to hand in
73:08 - the left side of the tile and you're
73:10 - going to hand in the top side of the
73:11 - tile
73:12 - you're also going to hand in the
73:14 - tile size
73:16 - and then you just go ahead and you do
73:17 - this for every corner of the player
73:20 - so we just did the top left
73:23 - down here we're going to do the top
73:24 - right
73:25 - then we do the bottom left
73:28 - bottom left there we go and we do the
73:31 - bottom right
73:32 - and we just do that for all four corners
73:34 - now you might be thinking well you're
73:36 - redefining some values
73:38 - that you're reusing so
73:40 - why not just define for instance
73:43 - here we go let me find a good example
73:44 - here
73:45 - right so this is checking the top right
73:47 - corner right this right here and this is
73:50 - checking the bottom right corner well
73:52 - i'm defining right two times but
73:55 - why would i do that well the reason i'm
73:57 - doing that is because
73:58 - here i'm defining right and i'm checking
74:00 - for collision if i have a collision and
74:02 - i respond to it my player character is
74:04 - going to move and right as i defined it
74:07 - here might not be the same anymore so
74:10 - down here when i'm getting the right
74:11 - side of the player again i'm not going
74:13 - to want to use this old
74:15 - value for right i'm going to want to get
74:17 - the right side of my player again
74:19 - because it might be different than it
74:20 - was when i checked collision with the
74:22 - top right
74:23 - so i check collision with the top right
74:25 - if there is in fact a collision up here
74:26 - it's going to move my player
74:28 - and then i check oh this is the top
74:30 - right i keep getting confused there but
74:33 - then when i check the bottom right
74:35 - if i moved that value is going to have
74:37 - to be redefined to get the appropriate
74:40 - new location of the player's right side
74:42 - after he
74:44 - had collision resolved with the top
74:45 - right corner
74:47 - so
74:48 - this is the broad phase it's not as
74:50 - complicated as you think it's really
74:52 - simple the math is really simple you're
74:54 - just getting a value out of an array
74:56 - based on a player's column
74:59 - and row or
75:01 - row and column rather and then you're
75:03 - handing all that information into the
75:05 - routing function we're going to take a
75:06 - look at the routing function in the next
75:08 - part of the video now let's take a look
75:11 - at the routing function so i'm going to
75:13 - come down here to the routing function
75:15 - and that is going to be in the
75:17 - game.world.collider class and it's going
75:19 - to be called collide so the collide
75:22 - function is my routing function and all
75:24 - it does is it takes the tile value the
75:26 - object and tiles x and y position as
75:29 - well as the tile size which is the
75:30 - tile's width and height
75:32 - and it takes all that from broad phase
75:34 - and it hands in the value of the tile
75:37 - into a big switch statement which then
75:40 - routes you and that's why i call it a
75:41 - routing function it routes you to the
75:43 - appropriate narrow phase collision
75:44 - methods and it also does some tweaking
75:47 - to the tiles so
75:48 - for instance
75:50 - case one if i move my player down here
75:52 - i'm actually gonna be standing on a one
75:54 - tile i know for a fact this here is a
75:56 - one tile
75:57 - and
75:58 - it's gonna call collide platform top and
76:01 - it's gonna hand in the object so that's
76:03 - gonna be my player character it's going
76:05 - to hand in tile y not tile x because we
76:08 - don't need it in this case we just need
76:09 - to know what the top of the tile is
76:12 - going to be
76:12 - now if i want this to be a little bit
76:15 - lower say i want to make a half tile i'm
76:17 - just going to hack this right now but
76:19 - i'm going to put in
76:21 - plus 8 and i know for a fact that 8 is
76:24 - half of my tile height so that's going
76:27 - to be
76:27 - didn't mean to do that
76:29 - that's going to be my change that i made
76:31 - i saved my file i'm going to refresh my
76:32 - screen
76:33 - now as you can see all the one tiles
76:35 - that i'm colliding with are going to
76:37 - have half height
76:39 - so this tile right here i'm now going to
76:42 - be colliding with a value that's a
76:44 - little bit lower
76:46 - interesting so i can take my narrow
76:48 - phase functions and i can tweak them a
76:50 - little bit inside of my routing function
76:52 - and that's going to give me the ability
76:54 - to create a whole bunch of different
76:55 - tile types
76:57 - however i want so all the different
76:59 - shapes are going to be defined basically
77:01 - inside of the routing function
77:03 - and all it really does is gets the tile
77:05 - value and links it to
77:07 - a certain set of narrow face functions
77:09 - let's take a look at
77:11 - let's see what i got here let's take a
77:13 - look at something a little more complex
77:17 - first i'm going to have to see what
77:18 - tiles are what because i can't think
77:20 - right off the top of my head what those
77:21 - values actually stand for but if i look
77:23 - at my map
77:24 - i'm going to come over here to a 13 tile
77:26 - and that looks to be
77:28 - at the left side of this t right here so
77:31 - 13 is going to be oh wait i forgot to
77:33 - refresh my screen let's refresh and get
77:35 - functionality back to normal so 13 is
77:38 - going to be this tile right here that
77:39 - i'm standing on now
77:41 - so let's take a look in the routing
77:42 - function at
77:45 - the
77:45 - 13 tile
77:48 - all right here we go it's going to call
77:50 - the methods
77:52 - collide platform top clyde platform left
77:55 - and collide platform bottom and the
77:57 - reason for that is because i'm going to
77:59 - collide with the
78:02 - left side
78:04 - of this tile cloud with the left side
78:06 - maybe if i can actually hit it with the
78:08 - left side i'm going to cloud with the
78:09 - bottom and i'm also going to collide
78:11 - with the top so those are the three
78:13 - sides that i'm going to be able to
78:14 - collide with if i happen to meet a
78:16 - tile with a value of 13.
78:18 - now the reason i have some of these
78:20 - functions nested inside of if statements
78:22 - is because i can only collide with one
78:24 - of those sides of a tile at a time
78:26 - so i can only collide with the top and
78:28 - if i do i can't possibly be climbing
78:29 - with the left or the bottom certainly
78:31 - not the bottom if i'm coming from the
78:32 - top how would i cut with the bottom so
78:35 - i use these if statements to early out
78:39 - of my routing function and not have to
78:41 - execute checks for these other two
78:44 - functions which is great because for any
78:45 - given tile we're only checking
78:47 - collisions on sides until we actually do
78:50 - collision and then we just exit out we
78:52 - don't have to check the rest of the
78:54 - collision so
78:56 - clyde platform top is going to be in
78:58 - this if statement
78:59 - if i collide with platform top then i'm
79:02 - no longer going to have to check for
79:05 - colliding with the left side or
79:07 - colliding with the bottom side of the
79:08 - tile
79:10 - now inside of my narrow phase
79:12 - my function returns true if i do in fact
79:14 - have a collision and it is resolved and
79:16 - returns false if no collision was
79:18 - detected and nothing was resolved and if
79:20 - that's the case if it's false it'll just
79:22 - jump down to this next
79:24 - narrow phase collision method call that
79:26 - if there's no collision there it will
79:27 - jump finally to the last method in the
79:30 - case
79:31 - and call that and if that doesn't return
79:34 - true then there is no collision and
79:36 - nothing gets resolved
79:38 - so that's the routing function pretty
79:39 - simple that's how it works uh in
79:41 - previous tutorials on how to do this
79:44 - systems tile based collision system i
79:45 - used an array
79:47 - and i used um
79:49 - objects object references to get these
79:52 - but actually it's much much faster to
79:54 - use a switch statement
79:56 - so that's why i made the switch to a
79:57 - switch statement pun intended there so
80:00 - anyway next step onto the narrow phase
80:04 - now let's look at the narrow phase and
80:07 - that is going to be
80:10 - farther down inside of the collider
80:12 - classes
80:14 - prototype so inside the cladder classes
80:16 - prototype i have four functions and
80:18 - those are collide platform bottom
80:20 - cloud platform left
80:22 - clyde platform right and cloud platform
80:25 - top and
80:27 - awesomely enough with these four
80:29 - functions we can do collision detection
80:31 - and response with all of the different
80:34 - tile types basically any tile that has
80:37 - four sides we can take these four
80:38 - functions and combine them
80:41 - to get all kinds of different
80:43 - combinations up to 15 combinations which
80:45 - is as many combinations as you can have
80:47 - with a
80:49 - four-sided tile
80:50 - so
80:52 - let's take a look at let's see here
80:55 - clyde platform top where i think i was
80:57 - on alright let's take a look at cloud
80:58 - platform top and see how this actually
81:00 - works so from the routing function
81:02 - you're going to get the object and
81:04 - you're going to get the top side of the
81:05 - tile so top side of the tile is just
81:08 - going to be whatever the top of the tile
81:10 - is that you're standing on so right now
81:11 - i'm standing on this tile i have my
81:13 - object i have the top of my tile and
81:17 - we're just going to run an if statement
81:19 - that checks to see if the bottom of our
81:21 - player character is greater than the
81:23 - tile top and if it is
81:25 - then we run this code but wait there's
81:28 - more there's an and in here so we've got
81:30 - to see what that is too we're also going
81:32 - to check to see if
81:34 - the bottom
81:36 - of the player from the last frame of
81:38 - animation is above the tile top now if
81:41 - you didn't include this it would still
81:43 - work but
81:45 - it would not work as smoothly as you see
81:48 - here so let's go ahead and comment this
81:50 - out and see what happens when we don't
81:52 - use the old position
81:54 - from the last frame of the player
81:56 - character i'm going to comment that out
81:58 - i'm going to save i'm going to come in
81:59 - here i'm going to refresh and now let's
82:02 - see what we get
82:04 - everything might work perfectly but oh
82:06 - wait how about that i just jumped right
82:07 - through that tile now the reason for
82:09 - that is
82:11 - the when i jump up the top left and top
82:14 - right corners of my player are going to
82:16 - enter into this tile space the broad
82:19 - phase is going to detect that it's going
82:20 - to hand the information to the the
82:22 - routing function and the routing
82:24 - function is going to call
82:25 - collide platform top
82:27 - now cloud platform top
82:30 - without
82:31 - doing this check on the last position
82:33 - that the bottom of the player was in the
82:35 - last frame of animation without that
82:37 - it's just going to check to see is the
82:39 - bottom of the player greater than the
82:41 - tile top and if it is
82:43 - set it to
82:44 - the
82:45 - top of the tile so that's what's
82:47 - happening
82:48 - when i enter into the tile it detects
82:49 - that the player was
82:51 - below the top of the tile and it just
82:53 - sets it right to the top so that's the
82:55 - functionality you're gonna get
82:57 - without this
83:00 - when you add this in basically what's
83:02 - happening is it's saying
83:05 - hang on let me refresh real quick
83:06 - basically it's saying
83:08 - okay
83:10 - the
83:11 - bottom of my player may be inside of
83:13 - this tile but if on the last frame it
83:17 - wasn't up here and therefore entering
83:20 - into this tile between frames so on
83:22 - frame one he's going to be here on frame
83:23 - two with the force of gravity he's going
83:25 - to be down here inside the tile he's
83:27 - going to be entering in through the top
83:29 - and collide platform top is going to
83:31 - detect that inside of this if statement
83:33 - because the bottom on the current frame
83:35 - is going to be below the tile top
83:37 - and the bottom on the last frame is
83:39 - going to be above the tile top
83:42 - so
83:43 - that's going to be true and then we're
83:45 - going to get the appropriate response
83:46 - that we expect and we're no longer going
83:48 - to jump through the bottom of the tile
83:51 - and get that kind of glitchy looking
83:54 - collision response
83:55 - so
83:56 - now let's take a look at what happens
83:58 - after we do that after we collide with
84:00 - the top of the tile so i'm going to
84:01 - cloud the top of my tile here
84:03 - this is going to be true the bottom on
84:05 - the current frame is going to be
84:06 - slightly below the bottom on the
84:08 - previous frame is going to be above
84:10 - and
84:12 - what i'm going to do is i'm going to set
84:13 - the bottom of the object i'm going to
84:15 - set this bottom of the object to the
84:17 - tile top and i'm going to subtract this
84:19 - little value here i'm going to get into
84:21 - why i subtract that value in a minute
84:22 - i'm going to take a look at another
84:24 - function because that better explains
84:26 - why i do that i'm going to set y
84:28 - velocity to zero this way gravity
84:30 - doesn't keep increasing
84:32 - and eventually pull me through the tile
84:34 - altogether i'm going to set jumping to
84:36 - false so i can jump again
84:38 - and i'm going to return true so i can
84:39 - tell the routing function not to do any
84:42 - more narrow phase collision calls
84:45 - so now let's take a look at this little
84:47 - value and see what it does but i'm going
84:50 - to do it in the context of the
84:52 - collide platform left function because
84:54 - that also has a similar problem cloud
84:57 - platform write and cloud platform bottom
84:59 - don't have this problem and it has to do
85:01 - with rounding so let's just comment this
85:04 - out and see what happens but first i'm
85:06 - going to show you the desired
85:08 - functionality so right now i'm colliding
85:10 - with the left side of these two tiles
85:12 - and it's calling collide platform left
85:14 - to do that collision resolution
85:16 - so as you can see i can jump up and down
85:18 - and it's as you would expect i'm jumping
85:20 - up and falling down nothing is broken
85:22 - yet so let me comment this out and break
85:24 - the code i'm not really breaking the
85:26 - code it's all going to work the same
85:28 - it's just not going to have the desired
85:29 - effect i'm going to refresh my screen
85:31 - and i'm going to come over here and i'm
85:33 - going to do this again now when i jump
85:35 - i land on top of the tile and the reason
85:38 - for that is because when i'm falling
85:40 - down i'm actually going to be in this
85:42 - tile space with the right side of my
85:44 - player
85:45 - so the right side of my player when i'm
85:47 - falling down into this tile space is
85:50 - actually going to be in this tile space
85:52 - just looking at it with a naked eye it
85:53 - looks like he's fully inside of this
85:56 - column but really his right side is just
85:58 - barely inside of this column over here
86:01 - so unless we subtract
86:03 - that .01 or some tiny number doesn't
86:07 - have to be 0.01 it could probably be 0.1
86:09 - or 0.001 if you prefer
86:12 - because we subtract that
86:14 - we are pushing the player character out
86:16 - of this tile into this column and he's
86:19 - no longer touching this after he enters
86:21 - or exits collision with the left side of
86:23 - this tile space so let's refresh
86:25 - and see what that
86:26 - good functionality looks like now i'm
86:29 - colliding with the left side of this con
86:31 - this tile right here it's pushing me out
86:33 - of collision and it's actually pushing
86:35 - me out of the tile space entirely by .01
86:39 - pixels so when i jump
86:42 - i am fully inside of this column as you
86:44 - would expect and i'm no longer going to
86:46 - be colliding with these tiles unless i
86:48 - press right on my keyboard and move the
86:51 - player into them
86:52 - so that's why i have to subtract that
86:54 - little value now before i stop talking
86:57 - about the narrow phase collision let me
86:59 - just talk a little bit about
87:01 - object.getold right and how we actually
87:03 - do that so
87:05 - basically all we're doing is on every
87:06 - frame we are saving the
87:09 - last frames player position and we're
87:12 - getting the new frames
87:14 - new player position so
87:17 - where that happens is
87:20 - inside of the player object we actually
87:22 - come out here and
87:23 - look so we can actually see the code a
87:25 - little bit the player class now extends
87:27 - the object class and inside of the
87:29 - object class we have this is the
87:32 - object class right here
87:34 - inside of this we have some information
87:36 - to describe a rectangle
87:38 - and
87:39 - we're also going to have the x old and y
87:42 - old values
87:44 - so keep that in mind we have a x and y
87:47 - location we have the x and y location
87:49 - from the previous frame of animation so
87:50 - if i come down here to the
87:52 - player class
87:54 - and i come down here to his update
87:55 - function this is where we're going to be
87:57 - keeping track of this
87:58 - x old and y old are going to be updated
88:01 - on every frame of animation to equal
88:04 - that frame's current x and y position
88:08 - and then we're going to update x and y
88:10 - to be
88:11 - as fresh as possible in the new frame so
88:14 - we're basically just keeping track of
88:15 - the player's old x and y position from
88:17 - the last frame and his current x and y
88:20 - position from the current frame and that
88:22 - allows us to calculate his angle of
88:24 - trajectory and we can see
88:27 - based on that trajectory if he was above
88:30 - a tile before he entered into it
88:33 - and that will give us the ability to
88:36 - get rid of that broken functionality
88:38 - that you saw where i would jump up and
88:40 - just
88:41 - almost teleport through this tile and
88:43 - sit on top of it so that's why we have
88:45 - to keep track of this this is also great
88:47 - for interpolation which is something
88:50 - really useful for smooth animation but
88:51 - i'm not going to talk about that in this
88:53 - video anyway that is the narrow phase
88:55 - it's really simple the functions are all
88:58 - really really simple if you just take a
88:59 - look at the source code i urge you to go
89:01 - to the link in the video description and
89:03 - check that out on my github page
89:06 - and that's it
89:07 - i'm going to show you how i added sprite
89:09 - animation to the game so you can take my
89:11 - example and use it to put sprite
89:12 - animation into your own programs i'm
89:14 - going to talk about what's new in part
89:16 - 5. then i'll give you a very simple and
89:18 - brief refresher on how sprite animation
89:20 - works when using a sprite sheet and
89:22 - finally we'll take an in-depth look at
89:23 - the animator class and how it works with
89:25 - the player's movement to render the
89:26 - appropriate animations
89:28 - alrighty so the first thing i want to
89:30 - take a look at in part 5 is the example
89:32 - program and as you can see in this
89:34 - example program i no longer am working
89:36 - with the little white and gray square
89:39 - now i am working with this animated
89:41 - rabbit and he looks a lot better it's
89:43 - starting to look a lot more like a game
89:45 - that you can actually play just minus
89:47 - power-ups and items and stuff like that
89:49 - so
89:50 - basically not much has changed other
89:52 - than i've added an animator class that
89:54 - does the sprite animation and i've also
89:56 - tweaked his physics for jumping and
89:58 - stuff like that a little bit but that's
89:59 - pretty pretty common sense stuff
90:02 - kind of know how to do that if you're
90:03 - already to this point in the tutorial
90:04 - series so i'm not going to worry about
90:06 - the specific changes i made for this
90:08 - video instead i'm just going to worry
90:09 - about showing you guys how the animator
90:12 - class works to get this guy animated on
90:14 - the screen if you do want to see what
90:16 - has actually changed in the code since
90:18 - part four take a look at the source code
90:20 - that i've linked in the video
90:21 - description at the top of each file that
90:23 - has changed and for part five it's just
90:25 - these three the game the display and the
90:27 - main files for each file that has
90:30 - changes in it i've added a bulleted list
90:32 - in the comments at the top of each file
90:33 - that outlines what exactly has changed
90:36 - specifically in the code so if you want
90:38 - to find out what's changed take a look
90:39 - at the source code and take a look at
90:41 - these comments but in this video i'm
90:43 - just gonna focus on the animator class
90:45 - and how to get this dude animated on the
90:47 - screen so stay tuned and i'll show you
90:49 - how it's done now let's take a brief
90:51 - look at how sprite animation actually
90:53 - works when you're using a sprite sheet
90:55 - so this here is my sprite sheet images
90:57 - the png has all my tile graphics and it
91:00 - has my sprite images in it now each
91:02 - sprite animation is just a compilation
91:06 - of these different
91:07 - unique images so each image can be
91:11 - considered just a square that you would
91:13 - cut out of this bigger image and then
91:15 - put on the screen in quick succession to
91:17 - give yourself an animation so for
91:18 - instance right now my player character
91:20 - isn't doing anything he's just sitting
91:22 - still this frame is literally being cut
91:25 - from
91:26 - this position right here if you notice
91:28 - this and this are exactly the same image
91:32 - so currently he is displaying this frame
91:34 - of animation if i were to move him to
91:37 - the left now he's going to stand still
91:39 - he's going to be displaying this frame
91:42 - right here
91:43 - when he's walking it's going to give me
91:45 - an animation so i'm going to be playing
91:46 - those frames over and over again in
91:48 - quick succession
91:49 - it's kind of hard to tell because he's
91:51 - walking so fast but he's basically
91:53 - playing when i walk to the right he's
91:55 - playing this set of frames right here
91:56 - he's stepping through these four frames
91:59 - right here and that's going to give me
92:01 - my animation so what's happening is
92:04 - on every frame that i draw to the screen
92:06 - i'm going to see which
92:09 - frame that my player characters
92:11 - class is determining that he should show
92:14 - based on his movement pattern
92:16 - it's going to take that frame it's going
92:17 - to go into this tile sheet image is
92:20 - going to cut that specific frame out of
92:23 - the tile sheet it is then going to take
92:25 - that frame and draw it to the player's
92:27 - location on this
92:30 - display canvas this canvas element that
92:32 - i have in the browser window and you're
92:34 - going to see whatever frame that is
92:36 - supposed to be displayed and that's
92:37 - going to give you animation so that's
92:40 - basically how it works basically you're
92:41 - just cutting different images out of a
92:44 - bigger sprite sheet image and you're
92:45 - displaying those smaller images
92:48 - at the player's unique location on the
92:50 - screen now we're going to take an
92:52 - in-depth look at what makes the code
92:54 - actually work or i guess we're just
92:55 - going to take an in-depth look at the
92:56 - code because the code makes the code
92:58 - work so here i'm going to start with the
93:00 - frame class now the frame class is just
93:02 - going to define a rectangular region
93:04 - that we are going to cut our sprite
93:06 - images out of the tile sheet width so it
93:08 - has an x value y value width and a
93:10 - height and that's just going to be the
93:11 - source rectangle that defines the
93:15 - individual image inside of our sprite
93:17 - sheet so i'm going to use one of those
93:18 - frame classes to define each rectangular
93:21 - region
93:22 - for each one of these individual images
93:25 - so that's what the frame class is going
93:26 - to be for and just bear with me as i
93:29 - explain all these different classes and
93:31 - you'll see how they fit together at the
93:33 - end of this part of the video
93:34 - so don't worry about the offset x and y
93:37 - positions just yet i'll tell you about
93:39 - those later just keep in mind it's just
93:41 - a rectangular region for the moment
93:43 - now we're going to look at the tile set
93:46 - class and this used to be the tile sheet
93:47 - class inside of the display file but i
93:50 - moved it over to the game file basically
93:52 - the functionality is exactly the same i
93:53 - just renamed it and its location is
93:55 - different basically just keeps track of
93:56 - the number of columns and tile size of
93:59 - our rabbit trap sprite sheet image
94:02 - and
94:03 - that's it
94:04 - where animation comes in here is with
94:06 - the frames array so now we just talked
94:08 - about the frames class which is down
94:10 - there the frames class is just a
94:12 - rectangular region with an offset
94:14 - position
94:15 - each one of these values inside of this
94:17 - frames array is just going to be one of
94:19 - the rectangular regions that corresponds
94:21 - to a specific graphic for our animation
94:24 - so for example this frame is where the
94:26 - idle left graphic is inside of our
94:28 - sprite sheet
94:29 - this frame is where the jump left
94:31 - graphic is inside of our sprite sheet
94:34 - this group of frames is going to be
94:37 - where all of the individual graphics are
94:39 - for the walk left animation down here we
94:41 - got the walk right animation so
94:43 - basically all i'm doing is defining each
94:46 - rectangular region for every one of my
94:50 - sprite animation components or basically
94:52 - these individual images
94:55 - so now you know where the individual
94:58 - frames are going to be defined inside of
95:00 - the tile set class now we're actually
95:02 - going to have to define
95:05 - what those animations are so the
95:06 - animation itself is going to be defined
95:08 - by the object that's using it so the
95:11 - animation for this rabbit or for the
95:13 - player is going to live inside of the
95:16 - player class so every unique animation
95:18 - the idle
95:20 - frames the walking left and right frames
95:23 - the jump frames
95:25 - those are all going to be stored inside
95:27 - of the player class
95:30 - inside of its prototype so i'm just
95:31 - scrolling up to that here we have the
95:34 - player prototype and inside of it we
95:37 - have an object called frame sets
95:39 - and inside of frame sets we have all the
95:42 - different
95:44 - animations
95:45 - for the player we have as idle left jump
95:47 - left move left and then the right words
95:50 - motions for those different animations
95:52 - so each one of these values corresponds
95:55 - to a frame inside of our tile sets
95:57 - frames array so for example idle left
96:01 - is going to
96:02 - have a value of 0 in it and 0 is going
96:05 - to be the frame index or the index
96:07 - inside of our frames array where
96:10 - the
96:11 - rectangular region is defined to cut the
96:13 - image out of the sprite sheet for the
96:15 - idle left animation and that's just
96:17 - going to be here so this is index 0
96:19 - inside of our frames array it's idle
96:21 - left and that's what we're going to use
96:24 - for the idle left animation of our
96:26 - player
96:27 - and that's why that value is going to be
96:29 - a zero
96:30 - so as you can see each one of these
96:32 - values just corresponds to a different
96:34 - frame inside of the frame's array and
96:37 - what a frame is it's just a rectangular
96:38 - region that we use to cut out our sprite
96:40 - sheet images from the sprite sheet
96:43 - so how do we actually animate these
96:46 - that's going to be our next class that
96:48 - we look at and that's going to be the
96:49 - animator class so i'm going to scroll up
96:51 - to the animator class and i'm going to
96:52 - take a look at what this guy does
96:55 - so
96:56 - here's the animator class it's a
97:00 - frame rate dependent animation class so
97:02 - what that means is
97:05 - the rate of frames that you see for each
97:07 - animation is going to be totally
97:09 - dependent on the game engine's frame
97:11 - rate so if you don't want that kind of
97:12 - functionality this probably isn't for
97:14 - you but if you're just going to run your
97:16 - game consistently at 30 frames per
97:17 - second across all devices this is
97:19 - probably what you want to do and for
97:21 - html5 games that's a pretty good bet so
97:23 - this will probably work for you so
97:26 - i define a couple different values in
97:28 - here i have count delay frame set frame
97:31 - set is going to be
97:33 - those different frame sets or those
97:35 - different animation arrays that i define
97:36 - inside the player so for example frame
97:39 - set could be
97:41 - i'm going to scroll down here it could
97:43 - be
97:44 - any one of
97:45 - these animations it could be idle left
97:48 - it could be this array right here it
97:49 - could be move left
97:51 - which is that array right there could be
97:53 - any one of those and basically it's just
97:55 - going to use that information and loop
97:57 - through it
97:58 - when it does my animation
98:01 - think i went too far here we go so the
98:04 - frame set is just going to be one of
98:05 - those arrays with those values and those
98:07 - values of course correspond to our
98:08 - different frames that we use to cut the
98:10 - animation image out of the sprite sheet
98:13 - frame index is just going to be where we
98:15 - are or where the play head is so to
98:17 - speak inside of that frame set array
98:20 - frame value is going to be the value
98:23 - of whatever
98:24 - index we're in inside of our frame set
98:26 - so for idle left remember that was value
98:29 - zero the value was zero
98:31 - so for that particular animation it
98:33 - would be at index zero inside the frame
98:36 - set and the value would also be zero for
98:38 - the idle left image
98:41 - and then we have mode mode right now for
98:44 - this example
98:45 - there are only two modes we have pause
98:47 - and we have loop
98:49 - now pause and loop are just going to be
98:51 - the two types of playback that we want
98:53 - our animations to do
98:55 - so
98:56 - pretty simply i'm going to just explain
98:58 - that as we go i'm going to come down to
99:00 - the loop function
99:03 - all it does is
99:05 - it just changes the playhead position
99:08 - every so many frames that pass in our
99:10 - game loop so count is going to increase
99:12 - one time on every cycle of our game loop
99:15 - until
99:16 - it reaches the delay that we specify so
99:18 - for the walking left and right
99:21 - animations i've i've defined a delay of
99:24 - five
99:24 - inside of the player class
99:26 - so every five frames of our game loops
99:29 - animation
99:30 - or cycle
99:32 - we are going to
99:33 - run the code inside of this while loop
99:37 - so count we're just going to decrease
99:39 - that by delay and that makes us wait
99:41 - again
99:42 - frame index this is where we set the
99:44 - frame index or the playhead inside of
99:46 - our animation basically this we're just
99:48 - going to say is the frame index
99:50 - currently less than the frameset.length
99:53 - so let's take a visual look at what's
99:55 - going on here
99:57 - inside of our rabbit trap png so let's
100:01 - say the frame set that we're going to
100:02 - use has values that correspond to the
100:05 - walking right animation which is going
100:06 - to be these four frames right here
100:10 - so
100:11 - frame index at zero is going to yield a
100:14 - frame value of this image right here at
100:18 - frame index of one i'm going to move
100:19 - over one it's going to be a value that
100:22 - corresponds to this image right here
100:24 - when i move it over again it's going to
100:25 - correspond to this image right here so
100:27 - basically what the code inside of the
100:28 - loop function is doing
100:30 - is it's just increasing my frame index
100:32 - by 1 until it reaches the end of the
100:35 - frame set
100:36 - and when it reaches the end of the frame
100:38 - set the next time it goes to increase
100:40 - instead it just sets it back to zero so
100:42 - inside of my
100:44 - loop function
100:47 - all that we're going to do is just say
100:50 - set the frame index equal to
100:53 - the frame index plus one if it's not yet
100:56 - past the end of our frame set length and
100:59 - if it is past the end of the frame set
101:01 - length just set it to zero to restart
101:03 - the animation loop over again
101:05 - then finally what we do is we get the
101:07 - frame value that's just going to be
101:10 - the value that corresponds to the
101:12 - specific rectangular region that we
101:15 - store in the tile sets frames array that
101:17 - corresponds to the image that we're
101:18 - going to be cutting out of the sprite
101:19 - sheet so the frame value is just going
101:22 - to be set to whatever our frame set
101:24 - array is and we're going to hand in the
101:26 - index of
101:28 - the the playhead so whatever frame index
101:30 - is that's going to give us the value
101:32 - inside of our frame set that we're
101:34 - currently at in the animations loop
101:36 - cycle
101:38 - all right so that was a mouthful and
101:40 - hopefully i'm explaining everything
101:41 - quite well i think the next place we
101:44 - want to go is probably the render
101:46 - function but first i want to just touch
101:48 - on uh this functionality here the change
101:51 - frame set function inside of the
101:52 - animator class and basically what this
101:55 - does is it just changes what frame set
101:57 - we're using so whenever i press left on
102:00 - the keyboard i'm going to call change
102:01 - frame set it's just going to change the
102:03 - frame set to the left animation which is
102:06 - that array inside of the player class
102:07 - that defines which frames to use for the
102:09 - left animation
102:10 - uh when i press right it's going to call
102:13 - change frame set i'm going to hand in
102:14 - the player's right
102:16 - movement animation if i jump to the left
102:18 - i'm going to call change frame set i'm
102:20 - going to hand in the left animation you
102:22 - kind of get what i'm saying here then
102:24 - the only other function in here
102:26 - is going to be the animate function it
102:27 - just checks to see which mode we're in
102:29 - loop or pause
102:30 - pause is gonna be for
102:33 - no animation so pause is gonna be called
102:35 - on the idle animation so idle right
102:38 - and idle left pause is gonna be the play
102:41 - method that we use for the walking
102:42 - animations we're going to be using the
102:44 - loop method because we want to keep
102:46 - animating that cycle of frames over and
102:48 - over and over again and basically this
102:50 - is just called on every frame and it
102:51 - just calls the corresponding method it's
102:54 - pretty simple
102:55 - so now that we know how we're animating
102:57 - our frames let's actually take a look at
102:59 - the render function which lives inside
103:01 - of the main file and we're going to take
103:03 - a look at how we actually use that frame
103:06 - information to cut our image out of the
103:08 - sprite sheet itself
103:10 - so
103:11 - the first thing we do we're actually
103:13 - going to have to jump to another section
103:14 - of code real quick because i'm using an
103:16 - assets manager to load my tileset image
103:18 - so real quick i'm just going to jump up
103:20 - here check out the assets manager class
103:23 - all it is is an image
103:26 - and i'm going to load in an image with
103:30 - our
103:31 - rabbittrap.png image inside of it so
103:33 - really all that we're doing here is just
103:36 - using the assets manager to load our
103:38 - tilesheet
103:40 - really simple so
103:41 - that's all that is don't worry about it
103:43 - too much you could write your own code
103:45 - you don't need an assets manager all you
103:47 - need is to load up the tilesheet image
103:49 - to use it for drawing from that tile
103:51 - sheet image
103:52 - so
103:54 - here we go
103:56 - here's where we get the frame value so
103:58 - frame we're going to get the the frame
104:00 - remember is just that rectangular region
104:02 - but we're going to get to it
104:05 - through all those classes i just talked
104:07 - about so the animation class is going to
104:10 - give us a pointer to
104:12 - a frame value which lives inside of the
104:15 - frames
104:17 - array inside of the tile set class and
104:19 - then the tileset class is going to be
104:21 - using the frame class to define its
104:22 - rectangular regions to cut images out of
104:25 - the tilesheet image
104:26 - so
104:28 - how we get the frame is we just
104:30 - get the frames array from our games tile
104:33 - set
104:35 - then we go ahead and we hand in the
104:37 - player's current frame value which is
104:39 - kept up to date on every cycle of our
104:41 - game loop inside of the update function
104:43 - we're going to be calling player dot
104:45 - update animation and that's going to
104:47 - update our frame value
104:49 - inside of the
104:50 - loop function most likely of our
104:52 - animator class
104:54 - so
104:55 - draw object is going to take all this
104:57 - information and put it together to give
104:59 - us the appropriate image that we need to
105:02 - see to make our animation work on the
105:04 - screen so
105:06 - what we're going to do is we're going to
105:07 - hand in our source tile sheet image
105:09 - then we're going to hand in the actual
105:12 - source frames x and y position to cut
105:14 - from
105:15 - then this is going to look a little
105:17 - complex but it's really not we're going
105:18 - to hand in the players x location and y
105:21 - location
105:22 - and we're just going to add basically an
105:24 - offset where we want the frame to show
105:27 - up and be drawn to the screen so
105:30 - right now the player's frame is slightly
105:32 - offset from the player's real location
105:35 - and the reason i want that to happen is
105:37 - so when i stand on the edge of a tile i
105:39 - actually fall through and if you look
105:41 - his ears on the the frame are actually
105:44 - kind of moving through the tile if i go
105:46 - over here this the image itself is
105:48 - actually overlapping the tile i don't
105:50 - want it to be pixel perfect like that i
105:52 - want it to be
105:53 - functional i want the player to have fun
105:55 - i don't care about pixel perfect
105:57 - collision as much as i do the player
105:59 - having fun so
106:01 - this code basically what it does is it
106:03 - just repositions the frame a little bit
106:05 - to center it on the player's position so
106:07 - we can more easily move him around the
106:09 - screen without that
106:11 - pixel perfect collision that makes his
106:12 - hitbox seem a lot larger than it needs
106:15 - to be
106:16 - so all this does it gets his exposition
106:19 - it adds
106:20 - the
106:21 - center
106:22 - or it gets the center of where i want to
106:24 - draw that frame on top of the player by
106:26 - just getting half of his width
106:28 - subtracting half of the frame source
106:30 - frames with and then it just adds the
106:32 - frames offset x position
106:34 - if i don't add that offset x position
106:37 - and remember i was talking about that
106:38 - for the frame class if i come back into
106:40 - the frame class all the way at the
106:42 - bottom here
106:43 - we define the offset x and offset y and
106:46 - then when we actually instantiate each
106:48 - frame we're going to add
106:49 - negative 2 which is the going
106:52 - offset y position
106:54 - for this player if i don't add negative
106:56 - two
106:58 - this is what happens i just set it to
107:00 - zero i saved i'm going to come back in
107:02 - here as you can see now that was the y
107:04 - offset he's now two pixels deep into the
107:07 - ground and that does not look quite
107:09 - right so that's why i have that offset
107:11 - position all it does is add a slight
107:13 - offset
107:14 - when i draw the frame to the screen to
107:17 - make him appear in the appropriate
107:18 - location
107:20 - so that's it that's all that does you
107:21 - don't need this stuff like i said i i'm
107:24 - using a
107:25 - frame based approach you could easily
107:26 - use a tile based approach where you have
107:29 - all your graphics inside of one big grid
107:31 - kind of like the tiles are instead of
107:33 - having them all close together and
107:34 - cutting them out specifically the reason
107:36 - i do this is because if i were to add
107:39 - let's say my my rabbit has a sword and
107:41 - the sword comes out to here
107:43 - now my sprite is going to be different
107:45 - and it's not necessarily going to fit
107:46 - uniformly into a box or into a grid row
107:49 - and column cell with all the other
107:51 - sprites so i do it this way because
107:53 - sprites change they change in size they
107:56 - vary in size depending on what animation
107:58 - you're doing so this is just much more
108:00 - flexible for me so
108:02 - now let's get back into the rendering
108:04 - function went off on a little rant there
108:08 - so
108:09 - basically all the draw object function
108:11 - does of the display class is just draw
108:14 - from the tile set
108:15 - from the frame's x and y position
108:18 - and it draws to the screen whatever
108:21 - frame is currently in the animation in
108:24 - the player's animation draws that frame
108:26 - to the screen at a slight offset
108:27 - position
108:29 - then we call display.render and that
108:31 - draws everything to the screen including
108:32 - the tiles and whatever frame of
108:35 - animation our player is in
108:37 - alright so now let me just quickly see
108:39 - if i actually missed anything here i
108:41 - think i went over everything how
108:43 - everything works let me take a look
108:45 - inside of the
108:48 - player class itself and actually see how
108:50 - we're doing the players animation how
108:53 - we're actually deciding which frames to
108:55 - display and which frame sets to use
108:57 - this is going to be done inside of the
108:59 - update animation function
109:01 - so update animate animation is going to
109:03 - be called on every cycle of our game
109:05 - loop and it's basically just going to
109:07 - check to see what direction the player
109:09 - is facing and it's going to choose an
109:11 - animation based on that so the very
109:13 - first if statement inside of update
109:14 - animation is going to be
109:17 - is the player moving up which means is
109:19 - the player jumping up so if i press up
109:21 - on the keyboard the player is going to
109:22 - move up and if you look closely you can
109:24 - see that the up animation or the up
109:27 - frame is played briefly while he's
109:29 - moving up while he's moving down it
109:30 - switches back to
109:32 - idle
109:33 - left
109:34 - so
109:35 - if he is moving up and if his direction
109:38 - which is determined just by which
109:40 - direction he's facing so when i press
109:42 - the left key his direction is going to
109:44 - be negative one when i press the right
109:46 - key direction is going to be positive
109:48 - one
109:49 - so
109:50 - if his direction is negative one so if
109:52 - he's facing left i'm going to change his
109:54 - animation frame set to jump left
109:58 - if that's not the case and he's facing
110:00 - the right i'm going to change his
110:01 - animation frame set while he's jumping
110:03 - to jump right i'm going to do that in
110:05 - the pause position
110:07 - now for these other ones basically is he
110:10 - moving to the left if he is
110:12 - and his velocity is a certain
110:15 - amount
110:16 - then we're going to
110:18 - play the
110:19 - move left animation if the velocity is
110:22 - not a certain amount or less than that
110:24 - basically if he's basically stopped and
110:26 - his velocity is very small we're going
110:28 - to play idle left instead now this is
110:30 - cool because
110:32 - what this functionality allows us to do
110:34 - is it allows us to have our player
110:36 - gradually stop walking even though we're
110:38 - not pressing the walk key anymore so if
110:40 - i were to come in here and change this
110:42 - code to
110:44 - let's say this is the left walking
110:45 - animation
110:47 - what is this move left let's change this
110:49 - to
110:53 - two negative two
110:55 - and i saved i'm going to come up here
110:57 - refresh my screen
110:58 - now let's see what happens for the walk
111:00 - animation
111:02 - because i have to be moving at
111:06 - 2
111:07 - a velocity of 2 to the left the move
111:10 - animation doesn't actually run unless i
111:11 - hit that
111:13 - 2 pixels of movement velocity per frame
111:16 - so what this allows me to do is it
111:18 - allows me to create an effect where i
111:21 - gradually walk to a stop instead of just
111:24 - halting to a stop really hard like that
111:26 - so a better
111:28 - a better kind of example would be if i
111:30 - used one instead and i refresh the
111:32 - screen up here
111:34 - let's see what that looks like
111:36 - now i start walking right away because i
111:38 - hit a velocity of one to the left really
111:40 - quick but as soon as i stop
111:43 - i go into the idle animation and that's
111:45 - not really good because it looks like
111:46 - i'm sliding too much or maybe you do
111:48 - prefer that and that's the great thing
111:49 - about this code you can just do whatever
111:51 - you want i kind of like it where i'm
111:53 - just gonna gradually stop walking until
111:55 - i'm completely stopped i don't prefer to
111:57 - just automatically stop and slide on my
111:59 - feet like that so what i've done is i've
112:01 - just set a very small value
112:05 - for the
112:07 - velocity check and if he is moving
112:09 - slower than negative 0.1 pixels to the
112:13 - left
112:14 - then
112:15 - he's going to idle and if not he's going
112:17 - to continue walking until he just comes
112:19 - that gradual stop like that
112:21 - so that's pretty cool so basically the
112:23 - update animation function is fired on
112:25 - every frame after you do collision
112:26 - detection with the player in the world
112:28 - and
112:29 - it just determines what way he's moving
112:31 - and depending on what direction he's
112:33 - moving it runs a certain animation
112:35 - now this is actually really important
112:37 - it's more important than you think not
112:39 - necessarily for the player because you
112:41 - can
112:42 - have fine control over the player but
112:44 - for non-player characters who move on
112:46 - their own
112:47 - you have to determine their animation
112:49 - based on how they're moving because you
112:51 - don't control them you can't say play
112:53 - the run animation when i press the run
112:55 - key because you're not pressing a key
112:57 - for a non-player character for those
112:59 - non-player characters you have to keep
113:01 - track of
113:02 - what direction they're moving how
113:04 - they're moving and based on that you
113:06 - have to set their animation so that's
113:09 - what this code does
113:11 - it just automates the process of setting
113:12 - the animation it doesn't rely on key
113:15 - presses or user input it just sets the
113:17 - animation depending on what direction
113:19 - he's moving
113:21 - before i go any further with this series
113:23 - i want to address something called
113:25 - tunneling it presents major problems for
113:27 - any physics engine and tile based
113:28 - engines are no exception
113:30 - tunneling is sure to affect you
113:31 - particularly if you are writing your own
113:33 - physics engine so stay tuned while i
113:35 - talk about how to overcome this pesky
113:36 - glitch
113:38 - alright so let's take a look at what
113:39 - tunneling actually looks like so this is
113:41 - the part five example program and i
113:44 - haven't changed any of the code since
113:45 - part five
113:47 - but i just want to show you this one
113:49 - glitch that happens underneath this
113:51 - t-shaped structure of tiles when i am
113:53 - running into this tile from the right so
113:56 - i'm pressing down on the left key and i
113:57 - jump i actually pass into the tile
114:00 - now i can actually jump down below the
114:02 - tiles and walk around because of the
114:03 - nature of my tile-based collision code
114:05 - but obviously you don't want that to
114:07 - happen
114:08 - this actually isn't a problem with the
114:10 - collision code itself this is just a
114:12 - problem with tunneling and it seems to
114:14 - happen just in this one scenario so in
114:17 - order to show you guys better what's
114:19 - actually happening first i'm going to
114:20 - explain what tunneling is just using my
114:22 - mouse pointer as an example and then i'm
114:24 - going to show you in slow motion when i
114:26 - slow this game down i'm going to show
114:28 - you what's actually happening with the
114:29 - player and why tunneling is happening in
114:31 - this particular instance
114:33 - so tunneling is when the object moves
114:36 - too far in one frame to actually collide
114:39 - with a collision shape so
114:41 - let's say that
114:42 - this tile is going to be my collision
114:44 - shape and the mouse pointer is going to
114:46 - be my object so this is frame one on
114:49 - frame one my object is right here where
114:51 - the mouse pointer is and on frame two
114:54 - i'm going to move my object a little bit
114:57 - to the left so this is frame one this is
114:59 - frame two my object has moved about 16
115:02 - pixels to the left now this is okay
115:05 - because i'm not moving more than one
115:06 - tile space
115:08 - i'm actually going to be over top of
115:10 - this tile space it's going to detect
115:11 - that i'm colliding with it and it's
115:12 - going to move the mouse out of the
115:15 - collision and put it back into an empty
115:17 - tile space that's how it should work
115:20 - tunneling happens when the mouse moves
115:24 - much farther than
115:26 - one tile space or 16 pixels in this case
115:28 - over the course of one frame so if this
115:30 - is frame one and i move in frame two all
115:34 - the way to here
115:35 - what's happening is i'm jumping right
115:37 - from here all the way to here and i'm
115:39 - never detecting a collision with that
115:41 - tile because i'm never landing in it so
115:44 - tunneling is basically just moving a
115:46 - player object or any object too quickly
115:48 - to detect collision with a stationary
115:51 - collision object
115:53 - so
115:54 - now that you kind of understand what
115:55 - tunneling is let me slow this down and
115:57 - show you
115:58 - in action what the tunneling looks like
116:01 - with the player character so i'm going
116:03 - to save my code i'm going to set the
116:05 - frame rate to one frame per second
116:06 - that's going to slow things down a lot
116:08 - and i'm going to refresh now as you can
116:10 - see things are really really slow
116:13 - so
116:15 - i'm going to run over here into the
116:16 - corner and it's going to take a while so
116:18 - just bear with me but i'm going to show
116:20 - you this glitch in as slow motion as i
116:23 - think it should be i don't want to go
116:25 - any slower than this or would take
116:26 - forever
116:27 - so here i am i'm standing next to the
116:29 - tile i'm going to press
116:30 - up and i'm just going to jump straight
116:32 - up
116:34 - so i jumped up and immediately this tile
116:37 - up here resolves collision and throws me
116:39 - right back down below it
116:41 - but if i jump up while i'm pressing the
116:43 - left key
116:44 - i jump up
116:46 - and i move slightly to the left
116:48 - now
116:49 - that's when the tunneling occurs so the
116:51 - tunneling isn't actually happening on
116:53 - this tile right here it's actually
116:57 - it's kind of a special case but i'll
116:58 - show you why so i'm going to run back
117:00 - out here and i'm just going to jump up
117:02 - the tunneling is actually happening when
117:03 - i jump because the player character is
117:05 - moving about 20 pixels upwards
117:08 - as soon as i start jumping and you'll be
117:10 - able to see that
117:12 - when i jump here in a moment
117:15 - so
117:16 - i could actually get this thing to
117:18 - comply it's just moving so slowly
117:20 - all right so i'm gonna jump and just
117:22 - take note of where this player actually
117:24 - moves to when i jump
117:26 - so
117:27 - this is the
117:29 - top of the player right here this would
117:31 - be 16 pixels from the ground right here
117:34 - when i press the jump key
117:36 - immediately my player is above that 16
117:39 - pixels his feet were about right here
117:42 - and he clearly moves more than 16 pixels
117:44 - which is our tile space so if he can
117:46 - potentially move
117:49 - past one full tile space without
117:51 - stopping in it he can tunnel because
117:53 - tunneling is basically when on frame one
117:55 - we're out of collision on frame two we
117:57 - jump over
117:59 - a collision object and never touch it
118:01 - so what's happening here is when he
118:03 - jumps
118:05 - imagine what happens if he were standing
118:06 - right here he's going to jump up
118:09 - on the first frame
118:12 - his the top of his hitbox is actually
118:15 - going to be over top of this tile and
118:17 - the bottom of his hitbox is going to be
118:18 - inside of this tile so what's happening
118:20 - is when he jumps and he's standing here
118:22 - he's going to jump up he's not even
118:24 - going to have a chance to clyde with
118:25 - this tile because the top two corners
118:27 - that i'm checking out on his hitbox are
118:29 - over top of this tile even
118:32 - the only reason collision happens on
118:33 - this tile is because his two bottom feet
118:36 - or his two bottom corners are inside of
118:39 - this tile
118:40 - and he can still technically move to the
118:43 - left while he's in this tile because
118:45 - collision is only going to happen in
118:47 - this tile with the bottom side of the
118:49 - tile and it does when i'm standing
118:51 - underneath this tile
118:53 - it does do collision but just on the
118:56 - bottom side i can still move to the left
118:58 - so when i jump up underneath this tile
119:00 - i'm going to jump i'm going to hit my
119:01 - head on the bottom and it's going to
119:03 - send me right back down again
119:05 - but remember i'm jumping 20 pixels high
119:08 - so
119:09 - what's going to happen is just my feet
119:11 - are going to collide with this
119:14 - when i jump i'm actually going to move
119:15 - up here then it's going to place me back
119:16 - down there and i can still move over to
119:18 - the left so when i jump up and press
119:20 - left
119:21 - i'm actually going to be up here and i'm
119:23 - going to fall back down into this tile
119:26 - on the wrong side of the collision
119:27 - boundary
119:29 - so that's what tunneling is and there's
119:30 - a really easy way to fix it if i come in
119:32 - here and i set this back to
119:34 - let's see
119:36 - 30 frames a second
119:38 - that ought to do let's see what that
119:40 - looks like
119:41 - 30 frames a second things are back to
119:43 - normal what i'm actually going to do is
119:45 - i'm going to come out here and i'm going
119:46 - to change the
119:48 - speed at which he jumps and that's
119:49 - actually going to fix everything
119:52 - so if i can find where that is oh it's
119:54 - actually in the game object here
119:57 - jump i'm actually setting jump whenever
120:00 - he jumps i call this function and it
120:01 - moves him 20 pixels up it sets his y
120:04 - velocity at negative 20 pixels so what
120:06 - i'm going to do is i'm going to set it
120:07 - to negative
120:08 - 15 pixels and that's going to prevent
120:10 - him from ever moving
120:14 - more than one tile space
120:16 - and actually i'm going to set this back
120:18 - to one frame so you guys can see that in
120:20 - action as well let's go back to one
120:22 - frame
120:23 - per second refresh and now we're going
120:26 - to zoom in and take a closer look at
120:28 - this guy jumping so
120:30 - this is what 16 pixels looks like when
120:33 - he jumps
120:34 - as you can see his bottom feet are no
120:36 - longer way up here on that first frame
120:39 - on that first frame they're down here so
120:41 - he'll still end up colliding with this
120:43 - tile right here so when i move back into
120:45 - collision and i'm going to speed things
120:47 - up for this
120:50 - set it back to 30 frames a second save
120:52 - come over here refresh my page and
120:55 - now tunneling can no longer happen
120:58 - so collision is going to happen as i
121:00 - expect it to so that is the problem
121:04 - and i guess i kind of showed you how to
121:05 - fix it in the first part but i'll go
121:07 - into more detail on how to fix it in the
121:09 - next part
121:10 - okay so we just looked at part five's
121:12 - example program where we had this glitch
121:15 - where actually i fixed it but very fresh
121:17 - we had this glitch
121:20 - i'm gonna leave that in actually so if
121:21 - you ever check out part five that glitch
121:23 - is gonna be left in there but now i
121:25 - wanna show you a better way to fix it
121:27 - and this is a sneak peek if you will at
121:29 - part six where i actually did fix this
121:31 - problem so here's the same exact tile
121:33 - structure same scenario in part six
121:36 - without the glitch now how i did this
121:39 - was i basically just clamped his
121:41 - movement velocity to
121:44 - never exceed 16 pixels or one tile space
121:48 - now if you just reduce the amount of
121:51 - velocity that he jumps at
121:52 - it can cause problems so for instance
121:54 - here i'm going to take a look at part
121:56 - five again here's part five i can jump
121:59 - up above this tile if i have a a y
122:01 - velocity of negative 20 pixels per frame
122:05 - when i jump so obviously if i reduce
122:07 - this to
122:08 - 15 and i save
122:11 - it's gonna it's going to eliminate the
122:13 - possibility of tunneling
122:15 - that's great but now i can't jump up on
122:17 - my platforms anymore so how do i fix
122:19 - this well the way to fix it is to go
122:21 - ahead and change your gravity and
122:24 - friction
122:26 - at least that's one way to fix it so i'm
122:28 - going to save that so it's back the way
122:29 - it was i'm going to come over here and
122:30 - i'm going to take a look at the code
122:33 - excuse me let's take a look at the code
122:35 - inside of part 6.
122:38 - so
122:39 - in part 6 i'm still using a velocity of
122:41 - negative 15 when i jump
122:43 - the only difference is now i'm clamping
122:46 - my movement velocity when i
122:49 - update the player's position
122:51 - so basically to do that i'm just saying
122:53 - if the absolute value of the player's x
122:56 - velocity or y velocity is greater than
122:59 - some max velocity and that's going to be
123:02 - 16 or 15 basically our tile size or
123:04 - maybe one less just to be safe
123:07 - if it's greater than that then we're
123:08 - going to set our velocity to
123:11 - the max velocity and actually this code
123:13 - is wrong because i don't want to change
123:16 - the sign
123:17 - of my velocity
123:19 - i just want to change the
123:21 - amount of my velocity so but you get the
123:24 - idea part 6 is still in development
123:26 - basically what you want to do is you
123:27 - want to clamp your movement speed
123:30 - and
123:33 - to get the same jump height
123:35 - with the different y velocity what you
123:37 - do is you just reduce
123:39 - gravity and friction so here is
123:43 - what a jump looks like in part five
123:45 - as you can see he jumps a lot faster
123:49 - it's kind of almost too quick so this is
123:51 - almost an improvement for visuals as
123:53 - well this is part six where i've kind of
123:55 - changed it up so he can
123:57 - have a clamped velocity and he just
123:59 - moves a little more smoothly if you look
124:01 - at it it's a little more smooth
124:04 - here's part five again
124:06 - jumps really far really fast it's a
124:08 - little bit
124:10 - too quick
124:11 - part six
124:13 - a little more smooth hopefully you can
124:14 - pick that up with my my video recorder
124:16 - here because sometimes it doesn't quite
124:18 - match the frame rate of the game when
124:20 - it's recording
124:21 - so
124:22 - basically what you want to do to fix
124:23 - tunneling is you want to clamp your jump
124:26 - speed
124:28 - so
124:28 - the amount of velocity that you apply to
124:31 - a jump and that's going to be where a
124:32 - lot of your velocity comes into play
124:34 - high velocities when you're jumping
124:35 - that's going to be a thing you wanna
124:37 - clamp it to
124:39 - an amount that's less than one tile
124:40 - space
124:41 - then in order to
124:43 - get the height of the jump that you want
124:45 - you're gonna have to reduce uh gravity
124:48 - and friction
124:50 - so for me i came in when i defined the
124:52 - world object
124:54 - what i do is i just have
124:56 - gravity and friction defined here so for
124:58 - example friction if i change the value
125:00 - of friction to say
125:02 - 0.9
125:03 - 0.99 that's going to be really low
125:06 - friction so if i come over here and
125:07 - refresh
125:09 - now i'm going to have really really low
125:10 - friction
125:12 - and as you can see i'm just moving
125:14 - really fast all over the place jump
125:16 - really far really fast because there's
125:17 - no friction
125:19 - so i don't want that but that's
125:20 - basically how you fix tunneling you just
125:22 - basically have to clamp your velocity to
125:24 - a certain speed and to get the jump
125:27 - height that you want you just
125:30 - mess with friction and gravity and
125:32 - that's gonna do it for tunneling
125:34 - i'm going to show you how to create
125:36 - level data files using json how to load
125:38 - level data and use it to populate the
125:40 - game world and finally how to trigger
125:42 - subsequent level loads by colliding with
125:43 - doors
125:45 - let's take a look at what has changed
125:47 - since part five and part five and a half
125:50 - so this is part six and everything is
125:52 - basically the same
125:53 - i did make quite a few changes but most
125:55 - of those changes pertain to loading
125:57 - different levels so when i jump up into
125:59 - this area here and walk off the side of
126:01 - the screen it's actually going to load a
126:03 - different level as you just saw so how
126:05 - how this is working is i have a little
126:07 - door hit region just off the right of
126:09 - the screen here and it's just a
126:10 - rectangular box and when the player
126:13 - character's center point hits that box
126:15 - it loads the level and places the player
126:17 - in
126:18 - whatever location he needs to be to
126:21 - start this level out when walking
126:22 - through that door from the other level
126:23 - so basically in part six i just have a
126:25 - couple different levels and i've defined
126:27 - a couple different types of doors
126:29 - they're all just rectangles you just saw
126:31 - two small rectangular doors this area on
126:34 - the bottom of this level is one big
126:37 - rectangular door so i can jump up
126:39 - through it at any point
126:41 - in this rectangle so this system works
126:43 - great for any size door doesn't just
126:45 - have to be one tile it can be any size
126:48 - rectangle that you define
126:50 - so that's basically part six so now that
126:52 - you know what the example program is
126:53 - about let's get into how this works
126:56 - before we get into the javascript code
126:58 - let's actually take a look at the
127:00 - different level files so this would be
127:03 - level zero zero or i call it zone zero
127:06 - zero so the file to load this level that
127:08 - you see on the screen is this file right
127:10 - here zone zero zero and basically it's
127:13 - just a couple of
127:15 - different json structures so i have a
127:17 - doors array and inside of that i just
127:20 - have the doors that are contained in
127:21 - this level so for this level level zero
127:24 - zero or zone zero zero i have one door
127:27 - just to the right of this tile the door
127:28 - would be right here off the level that
127:31 - you see on the screen
127:33 - and
127:34 - this json here defines an array of doors
127:36 - and this object inside of it will be
127:39 - that door object that resides right over
127:42 - here
127:43 - so that's my doors array down here i
127:46 - have some information about the maps
127:48 - each map has 12 columns and 9 rows i did
127:51 - not format this so you could actually
127:53 - see it in kind of a 2d
127:56 - row and column format i just have it in
127:58 - one big long array but if i were to line
128:01 - this up so each
128:03 - row had 12 columns in it you would see
128:05 - that the maps are 12 columns by 9 rows
128:08 - but this is my graphics map so these are
128:10 - all my graphics tile values this is my
128:12 - collision map so these are all the
128:13 - collision values for the tiles
128:16 - and then finally i have id and that's
128:18 - just going to be the level id so like i
128:20 - said this is zone zero zero so when i
128:23 - load zone zero zero this just tells my
128:26 - world object that
128:28 - it's
128:29 - zone id zero zero
128:32 - so
128:33 - now let's take a look at zone two and
128:35 - we'll just take a look at zone two's
128:37 - code really quick just so you get it in
128:39 - your head that this is what the the
128:41 - format is
128:42 - so here's my doors array zone two has
128:45 - two doors there's a door right here to
128:46 - go back into zone zero or actually it's
128:48 - zone one excuse me
128:50 - because i start labeling a zero but this
128:52 - is zone one and it leads back into zone
128:55 - zero zero there's a door right off the
128:56 - left side of the screen
128:58 - here and it goes into zone zero two with
129:02 - a door right over here on the far right
129:04 - side of the screen so inside of my doors
129:06 - array i have defined two door objects
129:10 - and then same as before i have my
129:12 - columns and rows and my two maps and the
129:15 - id that just indicates what zone this is
129:19 - so
129:20 - if you know how to write javascript you
129:21 - know how to write json for the most part
129:23 - it's really easy and it's a really great
129:26 - natural fit for
129:27 - writing information that you're going to
129:29 - load into your javascript game because
129:31 - it's so similar to javascript already
129:33 - and you have the built-in
129:35 - json.parse method to parse this
129:38 - information into usable javascript
129:40 - objects so now that you know how to
129:41 - write the level data let's get on to the
129:44 - next part of the video
129:45 - okay so now that we know how to define
129:48 - our level data we need to figure out a
129:49 - way to load it and the best way to load
129:51 - it is with
129:53 - xmlhttprequest so
129:54 - inside of my main.js file i have a class
129:57 - called assets manager and it basically
129:59 - just has a function called request json
130:01 - inside of it
130:02 - so in order to load my json file i'm
130:04 - going to call this request.json function
130:07 - i'm going to pass in the url of the file
130:09 - to load so basically i'm just if i want
130:11 - to load zone 0 0 i'm going to pass in
130:13 - the string
130:14 - zone00.json and i'm going to provide a
130:17 - callback function but i'll get to the
130:19 - callback function later so first thing
130:20 - i'm going to do is create an xml http
130:22 - request i'm going to give it an
130:25 - eventlistener for the load event
130:27 - and i'm going to have an event handler
130:29 - for when it loads which is just going to
130:30 - call my callback and hand in the parsed
130:34 - json
130:35 - string from my json file so
130:38 - i'm going to send off my request to the
130:40 - server it's going to process it it's
130:41 - going to hand me back the
130:43 - file content
130:44 - remember that file was
130:47 - zone00.json
130:48 - it's literally going to hand back
130:50 - this stuff in response text or just text
130:53 - format
130:55 - and i'm going to take that response text
130:57 - or the content my json file i'm going to
130:59 - use json.parse to turn it into a
131:01 - javascript object and i'm going to call
131:03 - the callback
131:04 - so that's the request json file that
131:07 - we're going to use to actually load our
131:09 - data so now let's take a look at where
131:10 - we first load up a level when we first
131:13 - start the game and that's going to
131:14 - happen all the way at the bottom of the
131:16 - main js file in the initial the
131:19 - initialization section
131:21 - so
131:22 - this is where we're using the request
131:24 - json file to load up our very first
131:26 - level so when i click refresh
131:29 - my code is gonna run in main.js
131:31 - and this
131:33 - right here is gonna be responsible for
131:34 - loading up zone zero zero which is on
131:37 - the screen right here so let's just take
131:38 - a look at what we're handing in
131:41 - calling assets manager dot request json
131:45 - zone prefix that's just gonna be the
131:47 - string zone for the first part of our
131:49 - url
131:51 - game.world.zone id
131:53 - when i first instantiate
131:56 - game it creates an object called world
131:59 - so game.world is a world object and that
132:02 - has a default value in it of
132:04 - 0 zero for world zero zero or zone zero
132:07 - zero so that's where we're going to get
132:09 - the zero zero from this is going to be
132:10 - zero zero and zone suffix is just gonna
132:13 - be
132:15 - dot json so i have the zone prefix of
132:18 - zone plus the game dot world dot zone id
132:22 - which is zero zero plus zone suffix
132:25 - which is going to be dot json
132:28 - so i'm going to hand in that url to
132:29 - request json it's going to send a
132:31 - request to the server when the server
132:33 - returns
132:35 - the json data inside of zone zero zero
132:38 - in text format i'm going to parse it
132:40 - into a js or a javascript object
132:43 - and then i'm going to hand that
132:46 - javascript object into my callback
132:49 - function which is just going to be
132:50 - defined here i defined it in arrow
132:52 - function format
132:53 - so
132:55 - this is my callback function and
132:56 - remember that i passed in json.parse
133:00 - request.responsetext so that's going to
133:02 - be the javascript object that i created
133:06 - from my
133:07 - zone file
133:09 - and i'm going to hand that into
133:11 - game.world.setup so let's go ahead and
133:13 - take a look real quick at
133:14 - game.world.setup
133:16 - and also where we
133:18 - create the very first
133:20 - default value for zone id so let me see
133:24 - if i can find where i'm at here i'm
133:26 - inside of the game file
133:29 - and this is the
133:32 - game.world.prototype so
133:34 - let's go up a little bit more
133:36 - game.world this is where we define
133:38 - game.world let me real quick just take a
133:40 - look at the default value for zone id
133:42 - so remember the default value for zone
133:45 - id we're going to use that right here
133:47 - when we're loading our first level
133:49 - so that's just going to be defined right
133:51 - here
133:52 - right now the default value is zero zero
133:54 - so when i refresh the page
133:56 - the first level it loads is zero zero if
133:58 - i change that to say zero one and save
134:01 - it
134:01 - and refresh the page keep an eye on the
134:03 - level map it's gonna load up world zero
134:06 - one if i change it again let's go world
134:08 - zero two save we're gonna load up and
134:11 - it's gonna immediately well it dropped
134:13 - us in world two but we fell down into
134:15 - world three so basically this sets our
134:17 - default level to load initially when we
134:20 - boot up the game
134:22 - so
134:23 - that's where we defined that but now
134:24 - we're going to take a look at
134:28 - game.world.setup where we actually put
134:30 - all the information from our zone file
134:33 - into our game.world object which we use
134:37 - on every frame of animation to do stuff
134:40 - with our game so
134:42 - down here is the
134:44 - setup function this is game.world.setup
134:47 - and it takes one parameter which is the
134:50 - zone which we just parsed into a
134:52 - javascript object from our
134:55 - zone00.json file
134:57 - so
134:58 - basically all we do is copy over all the
135:01 - values from our newly created zone
135:03 - object and we copy those values into our
135:06 - world object
135:08 - pretty simple
135:09 - the only one we don't copy directly is
135:11 - the doors array
135:13 - and the reason for that is because i
135:15 - want to use
135:16 - a door object that i defined i'll talk
135:18 - about that in the next part but we do
135:20 - loop through all the doors in the zone's
135:22 - doors array and we just create a new
135:25 - door from the doors that we loop through
135:28 - so inside of this
135:29 - zone file we have an array called doors
135:31 - every object inside we get and we
135:34 - convert this data
135:37 - into
135:39 - a
135:40 - game.door object so this class here
135:43 - we're just going to create a door object
135:45 - from the door data inside of our
135:48 - zone.doors array so whatever door we
135:51 - loop over in that doors array gonna be
135:53 - converted into a game.door class and
135:55 - that's what we're gonna use for our
135:57 - actual game
135:58 - logic and game physics when we collide
136:00 - with the doors and stuff
136:02 - now we finally know how we're setting up
136:05 - the very first initial level
136:07 - i'm getting out of breath here i'm
136:08 - talking so much but
136:10 - now we need to know one more thing and
136:12 - that's how to actually go ahead and load
136:15 - a level
136:16 - on the fly when we when we walk into a
136:19 - door so
136:22 - where we do that is inside of the update
136:25 - function for the game so on every cycle
136:27 - of our game engine
136:29 - on every game loop so to speak we're
136:31 - going to call this function from inside
136:33 - of main and this is the update function
136:35 - so the first thing we do is get some
136:37 - user input then we call game.update
136:39 - game.uptake
136:41 - takes care of moving the player takes
136:42 - care of all the world collision
136:44 - and inside of the game.update function
136:47 - is the world.update function so let's go
136:49 - ahead and take a look at
136:51 - world.update real quick
136:53 - already inside a world
136:55 - uh game.world.prototype so this is the
136:58 - game.world.update function which is
137:00 - called inside of the game.update
137:02 - function which we're calling right here
137:04 - so basically this function is going to
137:06 - call this function
137:09 - so
137:10 - first thing we do is update the player's
137:12 - position we collide the player with the
137:15 - world this refers to game.world
137:18 - so we're going to cloud the player with
137:19 - the world so all the tiles and then
137:21 - we're going to come down here and we're
137:23 - going to loop through all the doors in
137:25 - the world in the current region or zone
137:27 - of the world
137:28 - we're going to get each door
137:31 - and we're going to test for collision
137:32 - with the door and it's just basic
137:34 - rectangular collision i'll cover in the
137:36 - next part of the video basically if we
137:38 - do collide with the door so if the
137:40 - player actually collides with the door
137:44 - we're going to set
137:45 - this dot door or game.world.door
137:48 - equal to that door that we just collided
137:51 - with so
137:53 - normally this dot door is undefined
137:55 - so out here in our update function which
137:57 - is called on every frame
138:00 - we're going to
138:01 - test to see if game.world.door is not
138:04 - equal to undefined and the only time
138:06 - it's not equal to undefined is when for
138:08 - a split second we actually walk into it
138:12 - and
138:13 - then this if statement returns true and
138:15 - we go ahead and load the world that was
138:18 - specified by whatever door we collided
138:20 - with so let's just go through this real
138:22 - quick and see what happens the first
138:23 - thing that happens when i run into a
138:25 - door
138:26 - so if i run into a door the first thing
138:28 - that happens is i stop the engine
138:32 - i then make a request with request json
138:35 - to
138:36 - whatever zone that door
138:39 - brings you to so if i come up here into
138:41 - my zone00.json
138:44 - we're in zone zero zero
138:46 - the destination zone for this specific
138:48 - door located at an x of 192 which is
138:51 - about there and a y of 64 which is about
138:53 - there has a width and height of 16. so
138:55 - right off the right of the screen here
138:56 - is a box that's about 16 by 16 pixels
139:00 - and when i collide with it it's gonna
139:03 - load
139:05 - zone zero one and it's going to put the
139:06 - player at destination x of zero and
139:10 - negative one just means we're not going
139:12 - to use destination y so the player's y
139:14 - destination remains the same but i'll
139:15 - get into that in the next part
139:17 - um
139:18 - so basically we're gonna request
139:20 - the
139:21 - destination zone specified by that door
139:23 - so
139:24 - this door here that we're about to walk
139:26 - in right to the right of the player will
139:28 - tell us to go to world or zone zero one
139:31 - so when i walk into it
139:33 - this code loads up zone zero one
139:36 - pretty simple the same thing that we did
139:38 - for the initial level load we're just
139:40 - doing again right here even have the
139:42 - same arrow function with uh
139:45 - the zone parameter specified inside then
139:48 - inside of our callback after request
139:50 - json requests the level data the server
139:53 - gives it back to us in text format it
139:55 - parses that into a json object called
139:59 - zone and hands it back to us we're just
140:02 - going to call game.world.setup
140:04 - and it's going to get all the
140:06 - information out of the level file and
140:08 - put it on the screen basically
140:10 - so there is one difference this time
140:12 - however because now we're going to have
140:15 - to use some information from a specific
140:17 - door so let me go back inside the
140:20 - game.world.setup function real quick
140:23 - i'm going to scroll up to it
140:26 - right here game.world.setup
140:28 - and we check for the case that we are
140:32 - colliding with the door because remember
140:35 - when we
140:36 - enter into collision with the door we
140:37 - set the world's this dot door property
140:40 - equal to the door
140:42 - so when we call setup this dot door is
140:45 - actually going to be equal to whatever
140:47 - door we just collided with so if i come
140:49 - over here
140:50 - and collide with the door that's right
140:51 - over here
140:52 - it's going to be equal to that door that
140:54 - i just clouded with and it's basically
140:57 - it's just going to set the player's x
140:59 - and y center position to whatever the
141:02 - door's destination x and y values were
141:05 - that's it really simple everything else
141:07 - works the same as the initial level load
141:09 - the only difference is when you walk
141:10 - into a specific door
141:12 - you reposition the player according to
141:14 - that door's destination x and
141:15 - destination y so stay tuned for the next
141:18 - part where i'm going to talk about the
141:19 - door class specifically the collision
141:22 - and all that kind of good stuff
141:24 - now i want to take a look at what a door
141:27 - actually is so if i zoom in here i'm
141:29 - going to look at what a door is inside
141:31 - of my zone00.json
141:33 - file i've got an x position and a y
141:36 - position a width and a height so
141:37 - basically my door is just a rectangular
141:40 - region on the screen somewhere that the
141:42 - player object can collide with
141:44 - then i also have a destination zone
141:46 - that's going to be where the player is
141:48 - going to go what level i'm going to load
141:50 - if the player hits the door and i have a
141:52 - destination x and a
141:53 - destination y for the player as well so
141:56 - this is where i'm gonna put the player
141:58 - in the newly loaded zone when it loads
142:02 - if i have a negative one that just means
142:05 - destination y does not get used and the
142:07 - player's y position remains the same
142:09 - same thing for x if i have a negative
142:11 - one
142:12 - the destination x position isn't going
142:14 - to be used the player's x position is
142:16 - going to remain the same so we can see
142:18 - this functionality over here
142:21 - if i fall into this world
142:23 - i'm not being repositioned on the y-axis
142:28 - or on the x-axis rather because i don't
142:31 - need to be i just want to fall right
142:33 - through and naturally have my player end
142:35 - up where he has to be
142:37 - based on where he was in the previous
142:38 - level i don't want to jump through this
142:42 - floor door right here and end up at the
142:44 - very start of the door over here in the
142:46 - next level if i jump through over here
142:47 - like if i jump through right here i
142:49 - don't want to come out in this world
142:50 - right here because it just wouldn't look
142:52 - right
142:52 - so that's the only reason i have a
142:54 - negative one there but anyway let's look
142:56 - at the door class the game.world.door
142:59 - class and actually see what that looks
143:01 - like and the collision code that i'm
143:03 - using to have the player in the door
143:06 - actually collide so if i could find that
143:08 - wherever that is
143:10 - scroll scroll scroll
143:12 - hopefully i'll come across it soon
143:15 - ah this is it right here so it's a
143:16 - really simple object
143:19 - i'm gonna
143:20 - correct that small formatting error
143:22 - there
143:23 - really tiny object basically is the same
143:26 - exact thing as this right here it just
143:28 - has a prototype
143:32 - defined with the collide object function
143:34 - inside of it so
143:36 - this is the door class and i'm going to
143:38 - call object on it object all it is is
143:42 - a rectangle class that has some
143:44 - functions for helping me determine the
143:46 - sides
143:47 - of a rectangle so it has functions like
143:50 - get left get right get top get bottom
143:53 - just defining a rectangle here
143:55 - inheriting from the object class then
143:57 - i'm going to set the destination x y and
144:00 - zone to whatever those are from the door
144:02 - object that we hand in and that's just
144:04 - going to be whatever is defined inside
144:06 - of the zone file
144:09 - then inside of the prototype i have a
144:11 - function called collide object and
144:13 - that's just going to test to see
144:15 - if the object's center points
144:19 - are
144:19 - inside of the rectangular region of the
144:23 - door so
144:24 - this code right here just tests to see
144:26 - if the player is not colliding with the
144:28 - door if he's not then i'm going to
144:30 - return false and that means we didn't
144:31 - have a collision with the door if any of
144:33 - this is true
144:35 - or actually if any of this is false
144:38 - then we know that we have collided with
144:40 - the door and in that case we're going to
144:42 - return true so where do we actually use
144:44 - this that's going to be inside of the
144:47 - world.update function so if i come down
144:50 - here to worlds
144:52 - world.update
144:56 - right here there we go
144:59 - okay so inside of world.update i have
145:01 - all the doors defined inside of my
145:03 - world.doors array i'm going to loop
145:05 - through
145:06 - every door in that array
145:08 - i'm going to get each individual door
145:10 - i'm gonna test to see if the door is
145:12 - colliding with the player object and if
145:15 - it is
145:16 - i'm just gonna set the world's door
145:18 - property equal to that door and then
145:21 - just like in the last part we're going
145:23 - to go into the
145:25 - update function for our main game loop
145:28 - game loop and inside of that we're going
145:30 - to have an if statement that just checks
145:32 - to see is game.world.door defined and
145:34 - the only time it's defined is right
145:37 - after we collide with the door so we're
145:39 - going to stop the engine we're going to
145:40 - load the level defined by the door by
145:43 - the door's destination zone more
145:44 - specifically we're going to set up that
145:46 - zone in game.world.setup and we're going
145:48 - to restart our engine now inside of
145:51 - setup
145:52 - i know i'm recapping stuff that i just
145:54 - talked about but inside a setup we have
145:56 - this is the inside of the setup function
145:58 - we have an if statement that just checks
146:00 - to see is this door or game.world.door
146:04 - defined is it not undefined if it's
146:06 - defined and we have a door in there
146:08 - we're going to set the player's x and y
146:11 - coordinates equal to whatever those were
146:13 - defined
146:15 - as by the door object and if it's not
146:18 - equal to negative one then we know we
146:19 - can set it up if it is equal to negative
146:21 - one we just leave it alone so that's
146:23 - like in this case here where i'm not
146:25 - changing the player's x position
146:28 - so for both of these doors this door up
146:31 - here and this door down here for each
146:33 - level respectively
146:35 - the destination x position for that door
146:38 - is going to be set to negative 1 because
146:40 - i only want to change the player
146:42 - character's y position
146:45 - this way i don't have him jump through
146:46 - here and start out over here on this
146:48 - door
146:50 - so that's basically it that's how i
146:52 - define my door objects and
146:55 - that's how to load levels with doors
146:58 - i'm going to show you how i define the
147:00 - carrot and grass objects in the level
147:01 - data file their respective classes and
147:04 - the basic collision detection used to
147:05 - collide with the carat objects
147:07 - the first thing i'm going to talk about
147:09 - is what this example program is all
147:11 - about and where the carrot and grass
147:14 - objects are defined because since the
147:15 - last installment of this series i have
147:18 - since added carrot objects and grass
147:21 - objects you can see that i'm running
147:22 - into the carrot objects and when i
147:24 - collide with their hitbox i collect a
147:26 - carrot i have a carrot counter at the
147:28 - top left of the screen and then down
147:30 - here i have some grass
147:31 - objects and all the grass objects are
147:33 - are just
147:35 - objects with an x and y position and
147:37 - they have an animator inside of them
147:39 - they extend the animator class and it
147:41 - just updates the image on every frame of
147:44 - the grass to give the impression that
147:45 - the grass is actually swaying back and
147:47 - forth so
147:48 - just some basic objects i've added and
147:50 - if i come over here and take a look at
147:52 - the zone file
147:54 - you can see that
147:56 - this is my level data file and i have an
147:58 - array for carrots i have an array for
147:59 - grass and basically they're just little
148:02 - arrays inside of here that define an x
148:05 - tile position and a y tile position so
148:07 - if i come over here to my map and i
148:10 - refresh this carrot is going to be at
148:13 - position
148:14 - 1 comma 2. so the x tile is going to
148:18 - start at 0 and go to 1 because this
148:20 - right here is 1 2. so x tile of 1 y tile
148:23 - of 2 so if i count from zero i get zero
148:26 - one on my x tile axis and for the y tile
148:29 - axis i have zero one two so i know that
148:33 - from this map i wanna carry it at
148:34 - position one two and that's that carrot
148:38 - same thing for the grass my first grass
148:40 - tile is at x position two y position
148:43 - seven
148:44 - and that's going to be this grass object
148:47 - right here
148:48 - so pretty simple so when i load my level
148:50 - up i'm gonna actually have to loop
148:52 - through these arrays here get the x and
148:55 - y tile positions from them and then
148:57 - create an object
148:59 - from that x and y tile position and if i
149:02 - am looping through the carrots array
149:03 - i'll create a carrot object if i'm
149:05 - looping through the grass array i'll
149:06 - create a grass object so let's go in and
149:09 - check out the setup function of the
149:12 - game.world object
149:14 - the setup function just runs i come over
149:16 - here and refresh my screen the setup
149:18 - function runs right after the level data
149:20 - is loaded so right after i load this
149:22 - level data and i get access to it with
149:25 - json.parse
149:26 - i then call the setup function i pass in
149:30 - the json object that i just parsed after
149:32 - i loaded that level data from json and i
149:35 - go ahead and i set up all of the game
149:39 - objects
149:40 - and the graphics and collision map and
149:42 - everything for this level
149:44 - and then i'm going to go ahead and i'm
149:45 - going to loop through the zones carrots
149:48 - array and the zones grass array and
149:52 - basically those are literally just going
149:54 - to be
149:55 - these two arrays right here
149:57 - so i'm going to loop through them and
149:58 - i'm going to create a new carrot and a
150:00 - new grass object for every instance of
150:02 - one of those little
150:04 - x and y tile arrays that i come across
150:06 - inside of the zone file so what that
150:09 - looks like is i'm just going to use a
150:11 - for loop i'm going to go ahead and i'm
150:12 - going to loop through all the carrot
150:14 - objects inside of my zone's carrots
150:16 - array which is just the little tiny x
150:19 - and y tile arrays
150:20 - i'm going to create a carrot
150:24 - object or not an object but a variable
150:26 - to store that x and y position from the
150:28 - zone.carrots array and then i'm going to
150:31 - store a new game.carrot
150:34 - inside of
150:35 - my
150:37 - game's actual carrots array that i'm
150:39 - going to use on every frame of animation
150:42 - inside of my game cycles for my game
150:44 - loop so what i'm going to do is i'm
150:46 - going to feed it in x position in pixels
150:48 - not in tile space so i'm going to take
150:51 - the x tile position of the carrot which
150:53 - is located at position 0 inside of that
150:55 - array that we loaded from the
150:57 - level data and i'm going to multiply it
150:59 - by the tileset.tile height which is 16
151:02 - pixels plus 5 is just going to give me
151:04 - an offset so if i were to
151:06 - come out here and make this plus 0
151:10 - and save
151:11 - i come over here what's going to happen
151:12 - is i'm no longer going to i'm not going
151:14 - to have an offset of 5 pixels anymore so
151:16 - you can see they're kind of offset to
151:18 - the left by 5.
151:19 - if i come back in here and i undo that
151:23 - the z control z
151:25 - save come back over here and refresh now
151:28 - all my carrots are in the right position
151:30 - pretty much
151:32 - i do the same thing with the grass
151:34 - basically i just loop through all the
151:35 - grass in the level data file and i
151:37 - create a new instance a new grass object
151:40 - and i just position it based on the x
151:43 - and y tile values stored in my level
151:45 - data so that's it next i'm going to take
151:47 - a look at the actual classes that we use
151:50 - to make the grass and carrot objects
151:53 - now we're going to take a look at the
151:55 - grass and the carrot classes
151:57 - respectively so first i'm going to start
151:59 - out with the grass class and all it is
152:02 - is really simply an animator object it
152:04 - inherits from animator this way i can
152:06 - animate the frames
152:08 - and it also has an x and y position if
152:11 - you look at a grass object which is just
152:13 - this right down here obviously all it
152:14 - does is sit in a location so that's
152:17 - going to be my x and y position and it
152:19 - is animated so it's going to have to
152:21 - inherit from the animator now the
152:22 - animator class is the same class that i
152:24 - use to animate the rabbit it can be
152:26 - reused for all different kinds of game
152:28 - objects to give them an animation so
152:31 - really simply the grass class just has
152:33 - an animation and a position and the
152:35 - carrot class kind of does too but it
152:38 - also has a lot more so let's go up and
152:40 - take a look at the carat class
152:42 - and see what makes it move and how we
152:45 - collide with it with the player object
152:47 - so here's the carrot class and it
152:50 - inherits from the object class the
152:52 - game.object class as well as the
152:54 - animator class so the animator class
152:56 - just gives it the animation
152:57 - the object class is what's going to give
152:59 - it its x and y position as well as its
153:02 - width and its height and in addition to
153:04 - those things it also gets the collide
153:06 - object function which is going to
153:09 - be responsible for allowing us to
153:11 - collide with a carrot and actually
153:13 - collect it so
153:16 - that's important to note
153:17 - then some cool features about the carrot
153:19 - we have the base x y and position x y
153:23 - values so base x and base y are just
153:26 - referring to
153:28 - the
153:29 - center position that the carrot is
153:30 - rotating around or making that figure
153:32 - eight around so that's going to be the
153:34 - base x and base y position the carat
153:36 - does still have an
153:39 - x and y position that's going to be
153:40 - where it's actually drawn to the base x
153:43 - and base y are going to be just the
153:44 - point that it rotates around
153:47 - position x and position y are going to
153:49 - be
153:50 - vectors that the caret is placed
153:55 - by the amount of the vector on whichever
153:58 - axis away from the base x so to explain
154:00 - that a little more clearly
154:02 - if base x is in the center position x
154:05 - and position y are going to be distances
154:07 - away from the base on their respective
154:10 - axes and that's what's going to
154:13 - determine how far from the base the
154:15 - carrot is
154:16 - and we're going to i'll show you how i'm
154:19 - using position x and position y in a
154:20 - second
154:21 - just going to move down here but i set a
154:23 - random value up here
154:25 - and
154:27 - that basically just
154:29 - makes all the carrots kind of have a
154:31 - different um path because otherwise if i
154:34 - just set this up to be
154:36 - let's see
154:38 - zero
154:39 - all the carrots would have the same
154:42 - rotation pattern they'd all be
154:43 - synchronized basically so if you look
154:45 - now you can see very clearly that
154:47 - they're all synchronized and that's kind
154:49 - of a bad look so
154:50 - just go back to how it was before
154:54 - save and now you can see that they all
154:57 - kind of move independently and it's a
154:59 - lot less jarring to look at because
155:01 - before it was almost like there was a
155:02 - big
155:03 - just
155:04 - solid image of carrots with the
155:06 - transparent background just moving back
155:08 - and forth on the screen that's not what
155:09 - we want to go for we want to have
155:11 - independent movement we want to have
155:13 - things looking like everything is random
155:16 - so also speaking about that up here the
155:19 - frame index
155:21 - if you notice all the carrots on screen
155:24 - are not sharing the same uh
155:27 - animation sequence well they they're
155:30 - they're sharing the same frames
155:31 - obviously but
155:33 - if you look at two you can see that
155:35 - they're animating at different rates
155:37 - i just have to find two that are going
155:39 - at offset values here
155:41 - these two this one and this one they
155:44 - display the
155:46 - opposite frame from one another so when
155:48 - this one is on frame zero this one's on
155:50 - frame one when this one's on frame one
155:52 - this one's on frame zero that keeps
155:53 - things looking fresh so
155:55 - if i come up here and change this to
155:58 - just be
156:00 - zero
156:03 - it's going to reduce the
156:05 - randomization and we're just gonna have
156:08 - everything animating the same exact way
156:10 - almost like it's updating from the same
156:12 - exact animation object so that's not
156:14 - what we want either we want things to
156:17 - randomly update their animation not
156:19 - randomly but look like they have their
156:21 - own unique animation even though they're
156:23 - displaying the same frame so to do that
156:25 - all i'm doing is i'm starting off the
156:27 - animation at
156:29 - a
156:30 - randomized frame index
156:33 - alright so now let's take a look at what
156:35 - actually makes these things rotate
156:36 - around the base x and base y position
156:39 - inside of the game.carrot.prototype
156:43 - which is going to be the prototype for
156:44 - our charact class i have a function
156:47 - called update position and that's oh
156:49 - that's the only function for this class
156:51 - and this is going to be called on every
156:53 - frame of animation we're going to talk
156:54 - about this in the next part
156:56 - but
156:58 - all it does is it updates the position x
157:00 - and position y value
157:02 - and
157:04 - sets the actual x and actual y value of
157:06 - the carat object which we're going to
157:08 - use to draw it to the screen so
157:11 - excuse me position x and position y what
157:13 - it does
157:15 - is it's just a distance from the base so
157:17 - you can think of it as a vector distance
157:19 - from the base
157:21 - so
157:22 - oh actually well that is true but
157:24 - when i'm updating these
157:27 - it kind of controls the speed of the
157:29 - animation so if i were to make this five
157:32 - and this
157:33 - nine and save we're gonna see the
157:35 - carrots move a lot more quickly so when
157:38 - i press refresh up here
157:40 - now they're really moving like those
157:42 - guys are jumping around quite a bit
157:44 - there so that controls the speed at
157:48 - which things move because on every frame
157:50 - of the animation i'm adding uh 0.5 or
157:52 - 0.9 to these and that's going to make
157:56 - the thing move a lot more quickly
157:57 - obviously
157:58 - so let's get back to how things were
158:01 - save come down here and look at how we
158:03 - actually use these
158:05 - so
158:07 - math.cosine and math.sine are what's
158:09 - going to give us that circular motion
158:11 - and we just plug in position x and
158:13 - position y into cosine and sine
158:16 - and over here we have a multiplier of
158:18 - two
158:19 - that's going to control the distance
158:22 - that the carrot sways on the x-axis so
158:25 - if i come over here and refresh to get
158:26 - things back to normal
158:28 - you can see that it sways a little bit
158:30 - further from side to side than it does
158:33 - from up to from top to bottom there
158:36 - so the reason for that is because of
158:38 - this two
158:40 - if i were to make this a 10
158:43 - and save that
158:44 - the carrots are going to sway a lot more
158:46 - from side to side than they do right now
158:48 - so now you can see they're really
158:50 - swaying from side to side but that looks
158:52 - kind of ridiculous so we don't want that
158:54 - but basically what's happening here is
158:56 - we're just increasing we're incrementing
158:58 - up position x and position y
159:00 - uh math.cosine and math.sine
159:03 - give us a nice uh
159:06 - rounded or circular
159:09 - kind of effect there and then the
159:12 - multiplier is just going to be how big
159:14 - is that distance vector from the base
159:17 - position
159:19 - i guess it's actually a scalar because
159:21 - it's only one single value but together
159:23 - they make a vector so
159:25 - let's just put that back to two
159:28 - so on every frame i'm going to call
159:30 - update position and this code is going
159:32 - to run and it's going to make the carrot
159:34 - move back and forth
159:35 - now if i refresh
159:39 - everything's back to normal so next i'm
159:40 - going to talk about how we actually do
159:42 - the collision between the carrot and the
159:44 - player
159:45 - to do the collision detection between
159:47 - the player object and the carat object
159:49 - we need a function that basically just
159:51 - does collision detection between two
159:52 - square hitboxes so where that function
159:55 - is is inside of game.object so i'm going
159:58 - to scroll up to game.object
160:02 - and we're going to take a look at the
160:03 - function that we used to do that hit
160:05 - detection so here's the
160:07 - game.object.prototype
160:09 - that's just the prototype for our game
160:10 - the object class and we have collide
160:13 - object
160:14 - and what collide object does is it just
160:16 - tests for square collision detection
160:18 - between two rectangular objects so
160:22 - this object is going to collide with the
160:24 - parameter object that i hand in
160:26 - so basically i'll be able to hand in two
160:28 - objects
160:29 - and
160:31 - determine whether or not their hitboxes
160:33 - are overlapping so
160:35 - just wanted to show you this function
160:37 - and
160:38 - now you'll kind of know where the
160:40 - collision detection function is coming
160:41 - from
160:42 - where i'm actually utilizing all this is
160:45 - going to be inside of
160:46 - game.worlds
160:48 - update function so i'm going to come all
160:50 - the way down to the bottom
160:52 - all the way down past the player object
160:55 - pass the tile set object to the world
160:58 - object inside of the
161:01 - not the setup function
161:03 - but the update function so here we are
161:05 - inside of the update function and here
161:08 - we are going to call all of this code on
161:11 - every frame of our game's animation
161:14 - and we start up we uh we update the
161:18 - player's position we collide the player
161:20 - with the game world to get the tile
161:22 - collision going and then we're going to
161:23 - start colliding with carrots so we have
161:26 - a carrots array that's going to hold all
161:27 - of our carrot objects that we created
161:29 - inside of game.setup or game.world.setup
161:32 - rather we're going to loop through all
161:34 - of those carat objects so just these
161:36 - guys here and we are going to update the
161:39 - carrots position we're going to animate
161:41 - the carrot
161:42 - and then we're going to say is the
161:44 - carrot colliding with the player with
161:46 - the clad object function
161:48 - if that function returns true we're
161:50 - going to splice that specific carrot out
161:53 - of the carrots array
161:55 - and we're going to just remove it
161:58 - completely and we're going to add one
162:00 - two carat count and it's as simple as
162:02 - that we're just going to test for
162:04 - collision between the player and the
162:05 - carrot
162:06 - if collision occurs we're going to just
162:08 - remove the carrot carrot object is
162:10 - totally gone it will be garbage
162:11 - collected later on assuming that i
162:13 - removed all references to it and i think
162:15 - i have so then what's gonna happen is
162:18 - i'm going to increase carrot count by
162:20 - one
162:22 - and carrot count is what we're using to
162:24 - update this p element's inner html right
162:27 - here so where does that happen that
162:29 - happens inside of the main js file
162:32 - if i come down to the render function i
162:34 - have a p element it's referenced with
162:36 - the p variable
162:37 - and
162:38 - i just set its inner html to equal
162:40 - carrots plus
162:42 - game.world.carrotcount on every frame
162:45 - and that's it
162:46 - so i hope you guys learned something i
162:47 - hope you enjoyed the video and i'll see
162:49 - you guys next time

Cleaned transcript:

hey guys my name is frank i'm starting a series on how to program a tilebased platforming game called rabbit trap it will feature tilebased collision detection and response scrolling maps loading levels sprite animation and interactive game objects in this first part of the series i'll be talking about how to build a strong foundation for the game the concepts i'm going to explain are strongly rooted in objectoriented programming and can be used in any program to improve organization and modularity this might seem boring but if you use this approach it can save you hours of editing and frustration and leave you more time to focus on fun stuff like level design and graphics so be sure to watch this video in this video i'm going to talk about the model view controller approach to organizing a program and how the different components of this example work together in the main js file then i'm going to talk about how this structure increases maintainability and modularity as always feel free to use the comments section and be sure to check out the links to the source code and working example in the video description and if you learned something give this video a like so basically what i have here is just an example of a model view controller architecture where you separate out your game logic from your display logic and you also separate out your controller logic so i have my game logic stored in the game class the display logic in the display class and the controller logic in the controller class and each one of these handles its own business and it's totally separate from the other so i'm not going to run into any issues with having references to the game logic inside of the display i'm not going to have the controller logic referenced inside of the game i'm going to have all these different components interact with each other through their public methods inside of the main js file context and by the way each one of these classes is defined in its own individual file you don't need to have your own individual files but it makes it a lot easier to just use these different things in other applications if i choose to for example the engine i might want to use this fixed time step engine inside of another application at some point so it's nice to just store it in its own file but anyway what all this code does for this example is basically the game class controls color value right here that's the color variable from the game class basically it just increments the different red green and blue channels inside of a color value to change these different colors that you're seeing on the screen and then it will talk to the display class which governs things like the canvas and resizing the canvas when the screen resizes and rendering and the game will hand a color value to the display and the display will render it on every frame and the engine takes care of frames as for the controller i didn't really have anything cool to do with the controller for this example so all it does is take user input from the keyboard and tell the user which key he or she pressed so for example i just press the a key that's key 65. so basically what i'm trying to say is i want to keep things as organized as possible for this rabbit trap game and i want you guys to kind of think about organization of code before you start developing a game because if you just jump into things and try to mesh all this together in one big file with references going between different components it's going to get very messy very fast and here's an example of that that i want to show you so i define all my components i define my engine it's going to run at 30 frames per second and i'm handing in the render and update function down at the bottom of my main.js file i'm going to start my engine and that's going to execute the render and update function 30 times per second until i stop my game engine so the render and update functions i define up here and these are them right here so the update function is just going to tell the game to change that color value and that's what the update function of the game does just increments this color value in a random direction gradually to change the color now the render function is also going to be called on every frame of my game loop and inside i'm actually going to be communicating the game's color value to the display and i'm going to have the display object draw that color value to the onscreen canvas so here is a great example of why this is so good so i could just as easily write object literals to govern my display logic and my game logic and you've seen that if you've you've watched my other tutorials i'm kind of sloppy i just throw stuff together with object literals here i'm not doing that if i had written object literals i could put a reference to game.color directly inside of the display's render color function or better yet i probably wouldn't have even had a render color function i would just have a render method that handled rendering the entire thing the reason i have two here is because render color draws a color to a buffer canvas and then display.render renders that buffer canvas to the final onscreen canvas that you see so the old version of how i wrote my code or just the sloppy way that i write my code would just be to put two object literals on the main js file and one would be display one would be game and i would have a reference to game.color inside of my render function and display would just draw that color directly to the canvas now the reason this is bad is because say i want to change the name of my color variable to hue if i go ahead and i have a reference to game.color inside of my display and i change the variable color to hue inside of my game object now all of a sudden i'm editing my game class or my game object to change that value to hue and i have to go into my display object and change all the references to game.color to game.hue now that's a pain i don't want to have to do that and it's unnecessary so i don't see why i do it anyway with this method the mvc approach you don't actually have to have any internal references to any other components the display only has references to itself inside of itself the game only has references to things that it controls so how do they communicate they communicate just like this they communicate through public methods so display can only communicate with other objects like game and controller through public methods that it has so if i come into the display object here and i take a look at render color you can see that just takes a color value and inside of it it does exactly what i said it just changes the buffer's fill style to the specified color and draws that color to the buffer canvas and then here's the render function and all this is going to do is draw the buffer canvas to the final display canvas i'm not going to get too much into detail on that but you get what's going on here now i could have just as easily gone like this inside of this function and said game.color had i made these object literals instead of classes but that's actually really bad practice because like i said if i change something inside a game it might break my display object and prevent it from working so that's twice the editing that i'm going to have to do because i'm going to have to change all the values in display as well as all the values in game so this is just a much cleaner way of doing things so basically this is how you want your different components to interact and just take a look at this main js file it's really short everything is super clean i just have my two functions here render and update that i hand into my game engine and here i'm defining everything this is super clean i don't have huge object literals to take care of just sprawling out across my my screen here in my editor and to instantiate everything it's real simple i just add my event listeners for the screen resize and the the keyboard inputs and i just resize my screen initially so my canvas fits the screen when i start up and i start my engine and everything runs the way i expect it to so using the mvc approach or just separating out the different components of your game into logical groups is a really great way to keep your code maintainable and modular and i'm going to get into why in the next part of this video so now i want to talk about how this approach makes things more modular and more easy to maintain so obviously right off the bat it's a lot more organized you can see that clearly i have my different components reference here and instantiated here in one single line each rather than having big sprawling object literals defined and by separating these things out into their own classes i have the option of putting them into their own files which makes things even more organized because i could have all of these different classes right on top of each other in one big file or i could separate them like i did into their own files and now if i want to edit the game logic i only have to deal with 42 lines of code apparently instead of having to search through one big file so that's obviously one way that this technique lends itself to easy maintainability then there's the other thing i mentioned where you don't have internal references to one component inside of another component and like i said then it's a lot easier to just work with public methods and have your components communicate via public methods kind of like is happening right here in the render function display is interacting with game through a public method called render color rather than having an internal reference to game.color which would be a lot harder to maintain because if i change game.color in the game object i'm going to have to go through display and edit all of those references to game.color so this is another way it lends itself to maintainability now what about modularity okay well i've got a engine class down here which is basically a fixed time step engine now i can use this engine in any application that i want to and it's very easy for me to do that because this is a totally selfcontained class that i store in its own file now i don't have to store it in its own file but by storing it in its own file i can very easily just reference that single file in another application and then all of a sudden bam i have a perfectly good game engine for a whole nother game and i didn't even have to write code for it i already had it on hand but if i were to have that game engine integrated into all my other components it would be a lot harder for me to extract the the engine components from say the game logic and that just isn't very modular the way i have it set up now is very very modular and it will save me a lot of time in the future when i need a game engine object so sometimes i write my code this way for most of my tutorials i just throw stuff together in one file because i want everything to be there for you guys to see up front i don't want to have to bring things in from other applications but this is how i would go about writing a more structured application and that's what i'm trying to do i'm trying to write this game rabbit trap and i just want it to be very structured and i want everything to go smoothly so using the mvc approach and separating my game logic from my display logic and my controller logic is just going to make everything go super smooth throughout this whole process so anyway i hope this has been a good explanation of how everything is going to be for this rabbit trap thing and i hope you guys are interested in what's going to come because i expect it to be a really cool game before i wrap things up i want to talk about my html for this example so i actually am going to do a whole bunch of parts in this series and rather than having to upload the sprite sheet for this example a thousand times to my github page or however many parts i have i don't want to upload this multiple times my github page because i don't want to waste memory space so i'm just going to use the same graphics i'm going to use the same html file in css file and i'm just going to write new javascript files as need be so that's going to keep the memory footprint on my github page a little bit smaller for this whole series that i'm doing so anyway the way i'm going about that is inside of my html i'm dynamically determining which javascript files to load based on a url variable specifying the part number so when i come into my actual html page here and i look at my url to the rabbittrap.html file at the end of it there is a question mark and a one which is the part number for this example now if i wanted to get to part two i would just come in and type two i haven't actually made typed or part two yet but that's how you would access part two so i'm accessing these different parts with a url variable that is just the part and i have a default to where if you don't specify anything it just brings you to part one so that's what i'm doing and this big chunk of code in the middle the middle of my html file is taking care of that for me so it just it defines all the sources i'm gonna use and that's just these files here it gets the url variable or that part number from my url that 01 after the question mark and then it goes ahead it checks to see if it's a viable part if there is no part specified it just sets it to part one and then it just loops through and adds a script tag for every single javascript file in the application so i'm always going to have controller display engine game main and manifesto is just my script for the video and i'm just going to add a new script for each one of those and i'm going to edit i'm going to parse together the url or the source attribute to match whichever part i'm in so hopefully that was a good explanation of how i'm actually getting these things in and if you had any questions about why my html was weird like this that's the reason i'm just trying to save memory space on my github page so being cheap but i kind of figured out this cool little script to just import uh javascript files based on what part i'm in so anyway that is an explanation of that this part is going to be on adding a player object to the screen and controlling him with the keyboard this is a vital component of any game so stay tuned to find out how it's done in this video i'm going to talk about the example program what it does and how the program has changed since part one then i'm going to show you the specific code that handles creating the player controlling him and drawing everything to the screen finally i'm going to show you my implementation of a fixed timestep game loop and how it works if you have any comments or questions post them and if at any point while you're watching this video you get the sensation that you're learning be sure to support this video with a like first thing i want to talk about is what this example actually does and how this program has changed since part one so all this example does is allow me to place a square which represents my player on the screen and use the keyboard to make him jump up and down i also added some stuff in for collision detection and to make it look nice so he changes color on every jump and he leaves a trail the reason he's leaving a trail is just because i'm filling the background i'm redrawing the background on every frame of animation with a a slightly transparent background so that's the reason i'm getting that trail if i was drawing just a plain opaque black ground or opaque i guess some people pronounce it that way if i was doing that you wouldn't be able to see that trail behind them but i thought that was pretty cool and it kind of helps you visualize the what's going on in every frame of animation because each one of those squares that you see trailing behind him is drawn on one frame of animation all right so now that you know what the program does let's talk about what has changed since part one so in part one i had to find my three different classes my controller my display and my game i also had my engine class and my main js file so all these are updated for part two that's why the file name has a o2 after it the ones from part one like engine i haven't changed since part one that has a part one so that's my naming convention that i'm using really the only thing that i changed majorly besides the code that went into making the example work was i took the event listeners out of the display and the controller classes so the key down up actual event handler function i hand into the event ad event listener method in my main js file i'm actually defining those inside of my main file now so this would be one that i moved out the key down up event listener and the resize event listener or actually event handlers that's what these are so if i come all the way down to the bottom of my main js file you can see that i'm adding these event listeners to the window object and i'm just handing in the methods that i define inside of my main.js file into these event listeners so that's one of the changes i made i decided to make that change because i didn't think that my event handling system was really something i wanted to put inside of my individual classes or my individual components and the reason for that is a lot of times inside of these i'm going to have to do interactions with multiple components of my game so for example the resize component actually needs to handle two different components and have them interact it needs the display component which handles drawing everything to the screen and all my graphics and it also takes information from the game component which has information about my world's height and width and my player location and stuff like that so that's just a little bit about the example program and what it does and a few things that have changed since the last part of this series all right so now i'm going to talk about how i define the world and the game object and this is basically going to define the world that my little player square can run around it and jump in and it's going to define the player itself that's going to be just the rectangle that defines the player as well as the color and it's going to handle some collision detection stuff as you can see i can't fall through the floor and i can't jump or walk through the walls so all of this is going to be handled inside of my game logic so i'm going to come into the game part 2 file and take a look at my game class but i'm going to keep it expanded so we could actually look at the code all right so the first thing i'm defining in here is a object literal called world so inside of my game class i'm going to have access to this world object and inside of this i'm just going to have my background color and by the way this is that transparent color so if i come in here and i just uh change this to something like zero zero zero zero zero zero that's gonna be the color for black if i come in there and save it and then refresh my screen now i'm no longer going to have that trailing graphic behind my player whenever he jumps but if i come back in here and change it back ctrl z a bunch of times get rid of that and that and save and come back here now all of a sudden i get my trailing graphics behind my player whenever he jumps in it looks like he has just a cool trail of fading graphics behind him so that's pretty cool and it's really really easy to implement all you got to do is draw this semitransparent background color to erase your canvas on each frame of animation so anyway to get back to the world object i just want to make a side note of this and how i did that color trailing feature the world is just going to have everything to do with the world so friction and gravity are going to be defined here the player is going to be defined here later on i'm going to define other objects that are going to be ingame objects they're going to be defined here the world boundaries so the height and width of our level are going to be defined here if i were to change this let's say i want to make the height something like 200 and have a really tall screen if i do that and come here and refresh the screen now you can see that i have a really really tall game world and that looks kind of stupid so we're going to change it back save refresh and now i'm back to my normal size but basically the world object just holds everything to do with the game world including stuff like collision so this collide object function is just going to take an object parameter and for now that's just going to be handled inside of our game loop on every update and i'm going to pass clyde object the player object that we're defining i'm going to get to that class later and basically it's just going to test c is the object to the left of zero so that's going to be the far left of our screen and is he beyond the right side of the screen is he above the top of the screen is he below the bottom of the screen it's just going to set him to where he needs to be and handle collision with the boundaries of our rectangular world here so pretty simple stuff everything in this example is actually really basic take a look at the source code i have it linked in the description here i have the update function now this is actually going to update everything to do with our world so the player is going to have gravity added to his y velocity on every frame this function is going to be called on every frame of animation inside of the game loop the player has his own update function and if i come down to the player object down here we could take a look at it see what we got here update it just adds his x and y velocity to his current x and y position go back up see what else we got here so we're going to update the player we're going to add some gravity to his y velocity we're going to add friction or we're going to reduce his x and y velocities by the amount we defined in friction which is up here 0.09 it's just a simple pseudophysics way to employ friction in your game then we have this dot clyde object this stop player and this is referring to the world object that we are talking about so that's a really simple world object it just governs everything to do with the world the dimensions the player the colors that you're seeing in there and also in our game class we have added or i have added rather uh the player and it's a simple class it's uh using dot syntax to kind of add this player class to the game class and that's kind of just a way to keep things organized and almost like name space in there it's not real name spacing but by doing this i'm not going to have a a global class called player instead i'm going to have to reference it with game dot player like that so if i have a bunch of classes that i'm throwing into an external context say your game is going to run on another website and it's going to be part of the global scope of that website you don't want your classes and stuff to be just floating around with all the other variable names and class names that other developers have defined so it's good to try to abstract out your own class names and variable names and do stuff like put them into anonymous functions just to keep your code separated from everybody else's code out there on different websites but anyway that's besides the point we define our player class here he has a color he has a height he has a width he has x and y velocities he has a value for jumping to determine whether or not he's jumping and he's in the air if he's standing on the ground we also have his x and y position and since i'm just being lazy and i'm not loading him in from a level map i'm just going to define his values all right at the start here when the player object is instantiate instantiated with the new operator so now i go into the prototype and i have a couple different functions that govern govern how he moves i have the jump function uh basically just says if he's not jumping then we're gonna change the color and we're gonna make him jump down here so pretty simple this is the code to get a random color and i'm not really gonna go into that but basically it just makes his color change every time he jumps every time i press the up arrow on my keyboard the jump function is called on the player and this code runs pretty simple same thing for the move left and move right functions these functions are going to be called in my main javascript file i'm going to take a look at that in a second and all it does is just add half a pixel to his x and y or x velocity depending on which button you press if i press left i'm going to subtract 0.5 pixels from his x velocity if i press right on my keyboard i'm going to add 0.5 pixels to his x velocity and then finally that update function that's just going to add his x and y velocity to his x and y locations in the canvas respectively so now let's let's take a look inside of the main js file and see where all of these are being employed which is going to be inside of the update function so the reason i have my update functions all over the place i have one for my player i have one for my world and i have one in my main javascript file is because i'm doing different things inside of all of them and i want to keep all of my objects as selfcontained as possible so for instance uh the player object his update function is really simple it just handles stuff that has to do with the player my world's update function only handles stuff to do with the world so this.world.update is going to be this function right here the world's update function only has to do with things inside of the world the main javascripts file javascript file has an update function that handles the controller as well as the game so i'm mixing these two major components of my game's logic inside of this one method inside of my main.js file and that's kind of where i want everything to communicate i don't want to have those internal references pointing to other components inside of my game i want all of my code to be very selfcontained and when i have it interact with other components inside of my code i want it to be in a safe context kind of like the main js file that's where i'm going to do most of my editing so anyway i'm getting information from the controller i'm just saying is the controller being pressed are these keys active on the keyboard and if so i'm going to execute a corresponding function function on my player object finally i'm going to call game.update and game.update is going to go ahead and call world.update world.update is going to call all this stuff and that's going to give me these nice cool physics and take care of all my numbers and player position and velocity and whether or not he's colliding and that's going to take care of all of the physics logic in my game it's also going to change the player color alright so now i just talked about what actually makes the game logic work and that is of course the game class itself stored in the game o2 file so now i have to talk about how i'm getting keyboard input and relaying that to the game class so it can actually take that input and do something with it so i just showed you inside the main file here that i'm i'm conveying the keyboard's input via the controller object to the game object and telling the game object to do something with the player's position like move left move right or jump and that's all going to happen depending on what the controller object is doing so let's take a look at the controller class and see how that works so the controller class just has three objects here a left right and up object and those objects are going to be controller dot button input classes so let's take a look at the button input class and see what it is it's really really simple all it is is an object that has two boolean values inside of it one called active and one called down now active is gonna hold the virtual state of our button so i'll get into that in a little bit because it has to do with jumping and down is going to refer to the physical state of our button on the keyboard so if i physically press the up key down down is going to be true and if i hold that key down it's going to remain true the active value however is going to depend more on my actual game's logic so just remember keep in mind that down refers to the physical state of the button on my keyboard and that's what that is going to track and active is just going to track uh what that value is of my button object inside of my game's code or my game logic so now that you know what the button input class is these three objects are going to be button inputs and this key down up event handler function is going to be called every time i press a key on my keyboard whether i press it down or it comes back up this is going to be called it's going to check to see what the event type is key down or key up so when i press a key down on the keyboard the type's going to be key down when i release that key it's going to be key up and depending on which one it is it's either going to be true or false and then i'm just going to use the get input method of my button input class and hand in that down value which is either going to be true or false and that's going to look like this it's just going to say if the key tracker or the button input object if that currently is down the state is currently down or if the state is not equal to whatever we're handing in then we're going to set active equal to whatever we're handing in and we're just going to set down equal to whatever we're handing in because that's going to be the physical state of the button pretty simple maybe not so simple take a look at the source code and fiddle around with it because that's really the best way to get an idea i'm just here running over everything i'm trying to get it done quick because this video seems like it's going to go long i don't want it to go too long but basically this is a controller class just takes keyboard input and i'm adding the event listener for the controller component inside not my engine but inside of my main javascript file at the bottom if i come all the way to the bottom you can see i'm adding the key down and key up listener to the key down up function which i'm defining also inside of my main file and that is just going to call the controller's key down up method and hand in the event.type and the code which we use to determine what the type is whether it's a down press or an up press and the key code is just going to determine which key on the keyboard i'm pressing so 37 38 and 39 are the left up and right arrow keys on the keyboard so basically this controller class just gets keyboard input and then we relay that input to the game component right here in the main js file inside of its update function which is called on every frame of animation managed by our engine which i'm going to talk about later on in this video so really simply just checks to see if the left right and up keys are active and then it goes ahead and it calls a player movement function so move left move right or jump so where the active value comes into play here is when the player is jumping so notice that i'm actually setting the virtual state of the controller dot up button input to false i'm changing the active value to false so that's going to give me the ability to press my key once and hold it down and not have my player jump again if i were to come in and comment this line of code out like this and just go like this comment this guy out save my file come over here to my browser refresh now i'm just going to jump up and down continuously now this might be desirable for some people for some games this might be what you want but for other games you're not going to want to keep on jumping just because you have the key pressed down so if that's something you want in your game not having the player jump up and down continuously as your button is pressed in this controller class right here and these button input objects here with this dual virtual and physical uh button state tracker objects here these boolean values this is going to allow you to prevent your player from just jumping up and down continuously and you're going to get functionality that looks like this instead you're just going to be able to jump one time and only jump when you press the key rather than jumping just continuously if you have the key held down all right so now that you know how to define the player object and the world object in our game class and you know how to get user input to actually control this guy and move them around the screen the only thing left is how to draw this guy so how we're drawing the player object and the world itself to this canvas element is with the display class so inside of the display class i just define a buffer and a context of my canvas so these are two uh 2d rendering contexts canvas rendering context context is the rendering context of the onscreen canvas that you see on screen buffer is just an offscreen canvas that is going to be sized perfectly to match our world height and width so if we come back into our game and scroll down here the buffer canvas is going to be sized at 72 pixels high and 128 pixels wide and that is actually going to happen all the way at the bottom of our main.js file and the reason for that is just so everything scales the way it should so i'm setting that up right here in the initialization portion of my main.js file so let's get back into display and talk a little bit more about it so i've added a couple different functions i have the fill function or method all it does is take a color and draw it to the buffer which remembers the offscreen canvas which is then drawn by the render function to our onscreen canvas it draws this offscreen buffer canvas to the onscreen display canvas that you actually see in the browser window so the fill method just fills the buffer with color render renders that buffer to the screen draw a rectangle just draws this rectangle here that's what i'm handing in in terms of x y width and height and color and it just draws that to the buffer as well i'm actually rounding down the x and y positions of the rectangle that i'm handing in this way it doesn't render it on a half pixel so let's see what happens when i take this code out first let's uh take a look at what this guy actually looks like moving around the screen so pretty smooth nothing weird going on all the edges look pretty straight if i come in here and i just put in x and y though let's take a look and see if anything changes as you can see it looks a little bit funky i mean it's hard to tell because i have this background let's actually go in here and change the background color of my game to something else here let's uh let's make it black instead zero zero zero zero zero zero that's going to give me black i'm gonna come in here refresh my screen take a look at the player character you see how his edges are kind of messed up they're kind of wavering a little bit kind of looks like he's just fading around instead of just sitting on the exact pixel he's meant to sit on well that is actually because he's sitting on half pixels from time to time and you can fix that by rounding down the values you pass into your draw method so we can go from this which looks a little bit funky to this which now looks really sharp and not so funky at all it's basis basically the best we can get on a html5 canvas so now let me set back my background color to the way it was before so we could have that nice fading effect that follows the character around refresh my screen and so that's what i'm going to use to draw my rectangle to the screen and round him to the nearest full pixel location with math.floor so he doesn't get that weird blur around the edges now let's take a look at the main.js file and that's where all of these are going to be called actually i think inside of actually no i'm wrong let's just take a look at the main js file and see where these guys are called i think it's going to be inside of the render function i haven't looked at this code in a little bit so we have display.fill and by the way the render function is going to be called by our game engine which is our game loop on every frame of the animation so 30 times every second so we call display.fill that's going to fill our background color with this nice dark gray here we're going to call drawrectangle and hand in the game.world.player which is a rectangle we're going to hand in all those values as well as the color value and finally we're going to call display.render and that's going to draw the buffer that we just filled with the background color and drew the rectangle to and we're going to draw that that buffer to the final display canvas now one more thing i want to talk about here because this is pretty simple stuff is the resize functionality so the resize functionality is going to take care of scaling my onscreen canvas it's also going to take care of keeping the aspect ratio of the game world which you remember has the height and width coordinates it's going to keep that aspect ratio from the game world and the buffer to the final display canvas so we get a nice square rectangle every time so what's important about that well if we come down here i told you that we're going to set our buffers canvas height and width to the game world height and width now if i were to change this and say height times 0.5 obviously that would warp our game a little bit so let's take a look at that and what that looks like oh kind of cut off half the world but you can see that when i jump up the player is actually a lot taller than he is wide by about twice as much so let's set back that that back to normal and go ahead and take a look at the resize function which i'm adding to the window that handles all of that stuff so resize is right here it's going to call display.resize and it's going to hand in document.documentelement.clientwith and klein height it's going to subtract 32 pixels from both of those to give us this nice 16 pixel margin on either side of our display canvas which i have to refresh so it goes back to the way it's supposed to be so that's what that's doing those 32 pixels then it's going to hand in an aspect ratio of our game world which is going to be just the height divided by the width of our game world so now let's take a look inside of the display object's resize method and see what it's actually doing so here i am inside of the resize method and as you can see it's not super complicated it's actually pretty simple it's basically just going to say if the height and width ratio that we handed in from document.documentelement.com with incline height minus 32 pixels to give us that nice 16 pixel margin on each side it's going to say if that ratio is greater than the height width ratio of the world object the game world then if that height with if the screen's height width ratio is greater than the height width ratio of the world then we're going to set the canvas's height to the width times the ratio and we're going to set the canvas's width to the width of the screen so right now we have a max width scenario otherwise we don't have a max width scenario we have a max height scenario and it's going to set the canvas's height to the max height and it's going to set the width to the height divided by the height with ratio so this code is basically going to allow me to do this if i come in here and i change the scale of my window as you can see it's always going to keep it centered right now i have a max height situation and i have a shorter width in my game world but the aspect ratio remains the same and here i'm going to go back down somewhere around here i'm going to change over from a max height situation to a max width situation and now you can see my display canvas gradually getting smaller in height so that's pretty cool that's the display function takes care of resizing the canvas and maintaining that nice aspect ratio so our game can scale nicely across many different devices alright so now i'm going to do a brief run through of my fixed time step game engine and this is the game engine class it's in the engine file i haven't changed it since part one of this series it's exactly the same as it was although i did add in this accumulated time variable definition because it wasn't in here it was actually being added later right here so i just fixed that but it's basically exactly the same so what a fixed time step game loop does is it causes your game to update and draw at a fixed rate as time passes and it does that by taking a time step value which in this case is going to be 1000 divided by 30 if i come over to my main js where i actually instantiate this i am passing 1000 divided by 30 which is roughly 33.3 repeating forever and that is going to be the number of milliseconds that i'm going to call render and update on so every 33.33 milliseconds i'm gonna call render and update and the render and update functions are just right here you've seen them throughout this video and they're basically just going to update my game logic and render the changed game state to the screen let's hop back inside of the engine and talk about this game loop some more alright so we've got our time step and that's going to be in this case about 33.33 milliseconds and so every 33.33 milliseconds i'm going to call the update and render function i passed in they're going to be stored right here and i'm going to keep track of how much time has passed in the accumulated time variable so every time 33.33 milliseconds passes hopefully our our game is updating close to that but anything that overflows is going to be stored in accumulated time so let's say 33.33 is our minimum time step and that's exactly what it is but let's say uh request animation frame which is what we're using to update our game logic fires at 40 milliseconds now we're gonna have about what is that seven six something about six milliseconds left over and we're going to store that in accumulated time and when accumulated time reaches our time step or 33.33 we're going to update or call update one more time so basically we're storing all the time that passes in accumulated time and we're just taking bites out of that accumulated time we're taking 33 millisecond bytes out of our accumulated time the time value is just going to be the last time our run function executes and this is just going to be the looping function this is going to be the function that loops over and over again a lot of game engines will call this cycle some call it loop i'm just calling my run because engines run so this is going to be one run of the game loop so inside of the run function we're adding the current time stamp that's handed to us by request animation frame we're subtracting the current time or the last time our game executed from the current time and we're adding that to accumulated time so let's say that our the last time our game executed was at 100 milliseconds and we're just now getting in a new call to the run function from request animation frame and it's going to happen at 140 milliseconds so we're going to have 140 milliseconds minus 100 milliseconds and 40 milliseconds is going to go into accumulated time so now we have 40 milliseconds in accumulated time we're just going to set the the new most recent time value to the current time value but just remember 40 milliseconds in accumulated time here is where the fixed time step game loop really shines because this well actually this is just a safety i'm not going to talk about but but this is where it really shines the while loop so remember we have 40 milliseconds of accumulated time and we have our 33 i'm going to round that down to 33 or 33 milliseconds in our time step so 40 is greater than 33 so while 40 or our accumulated time is greater than our time step we are going to reduce our accumulated time by the time step we're going to call update and we're going to set this updated flag to true but don't worry about that too much so then we're going to loop again and see if that's true again and we subtracted 33 from 40 so that's going to give us 7 and 7 is no longer greater than our time step so we're not going to update again but let's say that accumulated time was equal to 70. okay so now we have 70. 70 is greater than 33 so we're going to call update then we're going to try to loop again well 70 minus 33 what is that 47 is that accurate anyway 47 is still going to be greater whatever it is it's still going to be greater than 33 so we're going to update again so even if we didn't have another request animation frame event fire and we didn't update the screen again we're still going to be updating twice on the next time request animation frame fires and gives us a new run command or we're going to call run again so we're going to be keeping up with time no matter what happens so even if our game runs really slow and laggy it's still going to keep up with time and it's going to run at the same rate basically on any device regardless of how slow it is unless the device is so slow that it just can't handle the game and then it will crash but that's that's not something you really should worry about uh unless your game is crashing all devices but if your game is just crashing the you know computers from 1995 then you shouldn't worry about it but basically the fixed time step game loop just says if too much time has passed or if a certain amount of time has passed we're going to update our game at whatever rate we want it to update until we have caught up with however much time has passed and that's a really great functionality of fixed time step game loops and it's a great reason to add them in to any game that you're writing so now down here we have the updated flag basically we turn that flag on we set it to true anytime we do an update and then if it is true if we have updated then we're going to call the render function and that's just going to draw our game so why is this good well let's say accumulated time only has 20 milliseconds in it but we need 33 milliseconds to justify an update otherwise we'd be going faster than we want to update well if that's the case then this never fires we never update our game and if we don't update our game nothing has changed and anything we draw is just going to be a waste of cpu or gpu so we don't want to draw anything that hasn't been updated or changed so if no update has occurred update updated stays false and we don't draw and finally inside of the run function we just make another call to the handlerun method and the handlerun method is just down here it's just an arrow function that calls uh the engine.run method now the reason i'm using an arrow function is because if you've worked with event listeners or request animation frame before the this keyword inside of whatever function you hand into your event listener as your event handler or request animation frame as your response to a request animation frame event firing is going to point to the object that you request the frame or add an event listener to so in this case it's the window so i don't want this to refer to window i want this to refer to my actual engine object so by using this arrow function i can actually make this refer to my engine object rather than the window so that's the only reason i have that kind of set up as an arrow function there to make sure that this keyword is referring to engine instead of window otherwise i would have to have a reference to engine inside of the engine and that just is really it just seems really sloppy to me so i set up the arrow function and that's what that does and anyway i hope that was a good explanation of a fixed time step engine and probably wasn't the best i was kind of going through it really fast it's really cold in this room where i'm recording and i'm kind of i'm like freezing to death so don't hold it against me i should turn up the heat but you know just i'm doing what i'm doing here so hopefully that was a good enough explanation of a fixed time step game loop and if not definitely take a look at the source code i commented everything in here so you guys can get a better understanding of the code as you read through it line by line in this video i showed you how to lay the groundwork for any platforming game so far i've implemented keyboard input simple platforming physics scaling for multiple devices and a fixed timestep game loop to handle updating your game at a consistent rate no matter what device it's on which is perhaps the most important thing you could take away from this video i'm going to show you how to draw a tiled background from a onedimensional tile map i'm going to talk about the example program and what i've added since part two then i'm going to talk about how to load the tilesheet image and store in a tilesheet class finally i'll show you the tile map in the game class and how it's drawn alrighty guys let's take a look at what has changed since part two if i come over here in the browser first i'm gonna real quick i'm gonna go ahead and i'm gonna pull up part two so you guys can see it and that is right here i'm gonna press enter load up part two and this is part two so as you can see i have some jumping physics i get keyboard input but there's no tile background and to make this game i'm definitely going to need a cool tile background so let's go over to part three and check out what we've done there alright so this is part three and as you can see it's a lot better i still have the same game physics where my character jumps around and moves around same fluid physics exact same physics code the only difference now is the world is a different size and i have a tile map inside of it also the color of the character is just a solid white and gray the reason i did that was to more closely resemble the player sprite we're gonna be using which is this little rabbit dude and basically that's it that's all the changes that have happened in part three since part two the files where the changes occurred are display game and main everything else i'm using uh the controller class from part two if i come into my directory here i'm gonna be using the controller class from part two and i'm gonna be using that file and i'm also gonna be using the engine class from part one but this is part three and these are the only three files that you need to worry about if you've already watched part one and two so anyway on to the rest of the video so the first thing we need to worry about for this application is how we're going to get our sprite sheet png image into our javascript so we can actually do something with it and have it render over here on the screen and show up on the background of our canvas element so first we need to define some sort of container for our sprite sheet image and its different variables and we do that inside of the display class so here's my display class it's one of the files that has changed since part two and inside of it i define a class called tilesheet i come down to the bottom here here's my tile sheet class it's just a really simple object it has an image inside of it this image object is going to store our tile sheet or our sprite sheet and then it records the tile size and i'm just going to hand in 16 because each one of our tiles is 16 by 16 pixels and the number of columns in our tile sheet so i think that's eight off top of my head but if we come over here and we actually count them we're gonna have one two three four five six seven eight different tiles kind of hard to tell but there's eight tiles or eight columns in this map eight tiles across or eight columns not just eight tiles in the map obviously there's more but so we have to define this tilesheet class and it's just going to have an image which is going to be our image it's going to have the tile size and it's going to have the number of columns in our tilesheet image now that we have this we can actually go about loading this png image into our javascript so we can do something with it where that happens is the main js file for part three so if i come down to the bottom of my file here you can see that i am setting the image of my tilesheet object in the display class i'm setting the source of that image to the rabbittrap.png and that's going to start loading the rabbittrap png image here into the tilesheet objects image and when it's done loading it's going to fire this event listener for loaded so it's going to say okay my image just loaded i have an event listener for that let's call this function the event handler function for a load event there i'm going to resize the screen that's just going to resize the browser window or not the browser window but resize our canvas to fit the browser window rather and it's going to call engine.start that's going to start our game loop off and then we're actually going to be able to use that graphic because if we start our engine before the graphic is fully loaded we're going to try to draw graphics that just aren't loaded yet and that's a problem so make sure that your graphic is fully loaded with an event listener for load before you actually start your engine also down here this extra parameter once colon true that just tells this event listener to only fire once and after it's done it just junks it sends it to the trash sends it to garbage collection we don't have to worry about removing this event listener from our tile sheet image because this parameter here just takes care of it all right so now that we've loaded our tile sheet image into our javascript we actually have to get these individual images out of this sprite sheet or tile sheet we have to draw them to different locations on the canvas to create something of a tiled map like you see here so how do we do that well it starts out in the game class and i have a map inside of my game class inside of the world and basically it's just a big long array of values that point to different locations in the tile sheet so the best way i can explain this to you is by just giving you an example and i'm gonna look down here in the bottom right of my numeric tile map at these three values 1 43 and 10. now these values correspond to locations inside of my tile sheet graphic and they also correspond to these locations on the map so this is the one tile this here is going to be the 43 tile and this over here is going to be the 10 tile and as you can see you can kind of make that connection those three tiles are going to be in this bottom right hand corner of the map so now let's take a look at these tiles inside of the sprite sheet itself we're going to have one so that's going to be for this example it's going to be at position one in our map normally i start at zero i start counting at zero but for this example i'm gonna start counting at one so tile one is just going to be this corner tile and as you can see right here in the map it is that corner tile these two tiles are the same so tile one is just gonna be this one right here and if you think about it makes sense because this is the first tile index in the map so just go 1 2 3 4 5 6 7 8 9 10 and remember this is tile 10 we have our 10 tile right here and it's just a plain clear brown tile and if i come back to my map you can see that that is in fact valued at tile 10. so now you kind of understand or hopefully you understand the correlation between these values in a onedimensional tile map and the images on screen as well as the locations of those images in the tile sheet image itself but just because we have the map doesn't mean we're actually drawing this stuff to the screen we actually have to write a function for that and that function is going to be inside of the display class and it's a function called draw map and it's just going to take the map which is just that array of values so it's just going to be this i'm going to hand in and the number of columns in the map and we have 12 columns on our map i define that here 12 columns if you count i actually have 1 2 3 4 all the way to 12 columns inside of my map if you look at the screen you can count 12 tiles across so this draw map function is just going to take the map and it's going to take the columns and it's going to loop through every single value in the map so it's going to loop through every single number right here and it's going to get the value there i subtract 1 from it and that's going to if i don't subtract 1 this is what happens if i just add 0 let's take a look real quick and see what happens and i'll show you a really simple way to remedy this which i didn't use because i used the tile map editor to make this because i have really complex tiles here but this is what it looks like it's because all of my tile values are offset by one now i set it back to negative one the reason for that is in my tile map these are all one higher than they should be so this should actually be 17 this should be 48 this should be 49 this should be 31. they're all offset by one that's just because the tilemap editor i use which is tiled exports the comma separated values uh starting at one instead of zero i didn't feel like going through and changing all these so hopefully this doesn't throw you guys off too much don't worry about it when you make your maps just make sure you have the right value starting at index zero in your tile sheet so basically instead of this being one it would be zero and you start counting from zero but if you want to use a map editor like tiled and you don't mind just having that offset it's really simple all you have to do is subtract one from the tile value and you're good to go so anyway that aside let's get into how i'm actually placing those images from the source onto the buffer and then drawing it on the screen so i get the different values or i get the value of the specific tile in the map that i'm looping over i get the source x and y position that i'm going to cut it out of the tile sheet at and that's what this code right here does it just takes the number of columns in the tile sheet takes the value that gets the column and then you multiply by the tile size to get the actual position to cut out of inside of the tile sheet image oh didn't mean to do that but that's basically just getting the x position to start cutting out of uh come back in here then we have the y value that's going to get the y position to start cutting out of and then when you get the source you're going to hand in the source x and y which is just these two values here and the tile height and tile width which i just have one of it's tile size and it's 16 pixels so source x and source y are going to get me to the appropriate tile say i am at tile 8 that's going to put me right here it would actually be a value of 7 but that's going to put me right here and then i'm going to cut 16 pixels wide and 16 pixels high so the y value would be 0 the x value would be 128 minus 16 to get me right here to the left side of this tile and then because 120 is the width of my map and it's just going to cut this tile out so pretty simple come back here display look the rest of this destination it kind of looks like the same kind of mathematical formula i'm just using the number of columns in my game world which you remember is 12 so that's the number of columns in this map and i'm multiplying that by 16 as well now i guess i should be using the game.world dot tile size but i'm just using 16 for both so i guess it doesn't really matter and then finally you're going to use this information to cut the appropriate image out of your tilesheet image and draw it into your buffer which is then going to be drawn to the final onscreen canvas so you're just going to say i want to draw an image to my buffer from the tile sheet image and i'm going to cut the image out of the tile sheet out at source x and source y and tile size width and tile size height i'm going to draw it to the buffer at destination x destination y at the 16 by 16 width and height so that's all that does and then if i come out here into my main js file and i come down to the or up rather to the render function you can see that i'm calling the display.drawmap function i'm handing in the game.world.map and thegame.world.coms into that function and that is how you draw all those tiles to the game screen i talked about how to load a sprite sheet image into your javascript how to create a tile map array and how to draw tiles from the sprite sheet to to display canvas if you're worried that there was a lot of code i didn't cover don't all you need to know is how these basic components work together in order to build them yourself chances are your application structure will be different from mine so don't focus too much on what i didn't show you and instead try to build the components i'm talking about into your own application this stuff really works and if you need the source code you can find it on my github page i'm going to show you the aspiring game programmer how to add pixel perfect professional quality tilebased collision detection and response to a platforming game i'm going to talk about what's changed since part three then i'm going to go over the three main components of my collision system there's the broad phase the routing function and finally the narrow phase let's take a look at what's changed since part three so this is part four it looks just like part three for the most part except now i have collision detection and response between my player character and the game world so as you can see i'm i'm moving smoothly across the tops of the tiles i'm jumping up along the sides of the tiles i'm not getting hung up on any of the edges anywhere i can jump through the bottoms of these platform tiles basically i have pixel perfect tile based collision detection and response and everything looks and works the way you would expect it to in a tilebased platforming game so now that you know what the example is all about let's take a look at what's changed in the code so the only two files that have changed since part three are the game file which holds the game class and the display file which holds the display class display had a minor change since part three if you remember part three i had an issue with the export values for my tile map because i used the tile map editor and all the values were offset by one so i just changed this function and i changed my tile map values to what they're supposed to be so i got rid of the offset as you see i have the comment no longer subtracting one take a look at part three so you can see what i'm talking about also in here in the draw player class i change math. floor to math.round in this line and this line here and the reason is because it just rounds my player to the appropriate spot that he's going to be drawn in more smoothly so those are two really minor changes in the display file inside the game file a lot has changed i've added the collider function i've added my collision map which is this guy right here a collision map is different than the graphical map for the tiles themselves that you see on the screen these are for the collision shapes uh down here i've amended my collide object function inside of the world class to do the broad phase collision detection and response that are these functions right here then i've also added the collider class the collider class takes care of the routing function as well as all of the narrow phase collision methods like collide platform bottom so cloud platform bottom would be called whenever you physically clyde you're the top of the player with the bottom of a platform so i'm jumping up and clyde platform bottom is firing every time my player hits his head on the bottom of that tile there so that's what that does then i've also added a bass class for the player object called object and that's nested inside a game.world the object is basically just a simple rectangle class and i'm going to talk about xold and wild and why we need those later on in a different part in this video but basically the object class is just the superclass of the player class now basically the player is going to inherit all of these values from object and it's going to get all of these neat little helper functions to get the different sides of his rectangle so that's all that does and then down here you can see i'm actually extending the object class inside of the player constructor and down here i'm actually extending the player prototype off of the object prototype with object.sine so those are all the changes in part four stay tuned for the rest of the video there are three main components to this approach to tile based collision detection response and those are the broad phase the routing function and the narrow phase and they're all centered around having a collision map full of collision tile values each value represents a different shape or collision shape so for instance if i hop over here i can jump through the bottom of this tile but not fall through the top of this tile here i can cloud with the bottom i can collide with the right side and i can collide with the top of that as well this tile over here these two i can collide with the left side so all of these tile values correspond to collision shapes that have different sides so the broad phase gets what tile my player character is standing on it determines what the value of that tile is that my player character is standing on gets that value from the collision map it then hands that value as well as the player object into the routing function the routing function checks the value in a switch statement and it says okay well let's check for instance i'm standing on top of tile one here this is tile one so the routing function would say okay you're colliding with tile type one and for tile type one i'm going to call a certain set of narrow phase collision detection and response methods so the broad phase determines what the tile value is the routing function determines which narrow phase functions to call and the narrow phase does the final collision detection and response and that's how the system works so stay tuned and i'm going to go into the code that makes that stuff work in detail all right so now i want to talk about the broad phase collision method and that is going to be the collide object function which is located inside of the game.world class so i'm going to come down here and show you what this broad phase does the whole function all it does is first it checks for collision with the outsides of the world and that's going to be this right here that's from part three that's pretty simple stuff and then the other thing it does is it checks all of the different corners all four corners of our player character so i have these four chunks of code i have one here for the top left i have one for the top right one for the bottom left one for the bottom right and that's the end of the function so this is the entire broad phase just these four chunks and this chunk up here which does collision with the boundaries of the world so let's take a look at the first chunk that tests for broad phase collision with the collision map with the top left corner of our player character so what these are are a row and a column value inside of our collision map so top is going to be the row that the top side of our player is in and left is going to be the column that the left side of our player is in so this is going to be the top of our player this is going to be the left side of our player and this is going to be the row that the top is in now if i move the player over here this is going to be the row that he's in and if i check the left side this is going to be the column that he's in if i move him over here now the left side of the player is in this column so pretty simple the math that we use to get the row and column and convert it from the physical xy position of the player to the onedimensional index or of a row or column value it's not really onedimensional it's twodimensional just simplified basically you just get the top of the object which is the y position at the top of the object you divide by tile size that gives you the row of the top and then you do the same thing for the column you just get the left side of the object which is right here you divide it by tile size that's going to give you the column value and then you're going to go ahead and convert those the row and the column into a index inside of our map array or collision map array and you just do that by multiplying the row by the number of columns inside of the collision map ours was 12 and then you add the column that the player is standing in so that's the row of the side of the player multiplied by the number of columns in the collision map plus the column of the side of the player pretty simple and then you go ahead and you hand in that value as well as the uh row and column positions of the tile multiplied by tile size to give you the actual x and y position of the tile so for instance if i was going to get the top left of my player that would be right here he's inside of this tile the top and left values multiplied by the tile size is going to give you this position right here which is going to be the x and y position of the tile so we're going to hand all that information into the colliders collide method and that's going to be the routing function you're going to hand in the value you're going to hand in the object you're going to hand in the left side of the tile and you're going to hand in the top side of the tile you're also going to hand in the tile size and then you just go ahead and you do this for every corner of the player so we just did the top left down here we're going to do the top right then we do the bottom left bottom left there we go and we do the bottom right and we just do that for all four corners now you might be thinking well you're redefining some values that you're reusing so why not just define for instance here we go let me find a good example here right so this is checking the top right corner right this right here and this is checking the bottom right corner well i'm defining right two times but why would i do that well the reason i'm doing that is because here i'm defining right and i'm checking for collision if i have a collision and i respond to it my player character is going to move and right as i defined it here might not be the same anymore so down here when i'm getting the right side of the player again i'm not going to want to use this old value for right i'm going to want to get the right side of my player again because it might be different than it was when i checked collision with the top right so i check collision with the top right if there is in fact a collision up here it's going to move my player and then i check oh this is the top right i keep getting confused there but then when i check the bottom right if i moved that value is going to have to be redefined to get the appropriate new location of the player's right side after he had collision resolved with the top right corner so this is the broad phase it's not as complicated as you think it's really simple the math is really simple you're just getting a value out of an array based on a player's column and row or row and column rather and then you're handing all that information into the routing function we're going to take a look at the routing function in the next part of the video now let's take a look at the routing function so i'm going to come down here to the routing function and that is going to be in the game.world.collider class and it's going to be called collide so the collide function is my routing function and all it does is it takes the tile value the object and tiles x and y position as well as the tile size which is the tile's width and height and it takes all that from broad phase and it hands in the value of the tile into a big switch statement which then routes you and that's why i call it a routing function it routes you to the appropriate narrow phase collision methods and it also does some tweaking to the tiles so for instance case one if i move my player down here i'm actually gonna be standing on a one tile i know for a fact this here is a one tile and it's gonna call collide platform top and it's gonna hand in the object so that's gonna be my player character it's going to hand in tile y not tile x because we don't need it in this case we just need to know what the top of the tile is going to be now if i want this to be a little bit lower say i want to make a half tile i'm just going to hack this right now but i'm going to put in plus 8 and i know for a fact that 8 is half of my tile height so that's going to be didn't mean to do that that's going to be my change that i made i saved my file i'm going to refresh my screen now as you can see all the one tiles that i'm colliding with are going to have half height so this tile right here i'm now going to be colliding with a value that's a little bit lower interesting so i can take my narrow phase functions and i can tweak them a little bit inside of my routing function and that's going to give me the ability to create a whole bunch of different tile types however i want so all the different shapes are going to be defined basically inside of the routing function and all it really does is gets the tile value and links it to a certain set of narrow face functions let's take a look at let's see what i got here let's take a look at something a little more complex first i'm going to have to see what tiles are what because i can't think right off the top of my head what those values actually stand for but if i look at my map i'm going to come over here to a 13 tile and that looks to be at the left side of this t right here so 13 is going to be oh wait i forgot to refresh my screen let's refresh and get functionality back to normal so 13 is going to be this tile right here that i'm standing on now so let's take a look in the routing function at the 13 tile all right here we go it's going to call the methods collide platform top clyde platform left and collide platform bottom and the reason for that is because i'm going to collide with the left side of this tile cloud with the left side maybe if i can actually hit it with the left side i'm going to cloud with the bottom and i'm also going to collide with the top so those are the three sides that i'm going to be able to collide with if i happen to meet a tile with a value of 13. now the reason i have some of these functions nested inside of if statements is because i can only collide with one of those sides of a tile at a time so i can only collide with the top and if i do i can't possibly be climbing with the left or the bottom certainly not the bottom if i'm coming from the top how would i cut with the bottom so i use these if statements to early out of my routing function and not have to execute checks for these other two functions which is great because for any given tile we're only checking collisions on sides until we actually do collision and then we just exit out we don't have to check the rest of the collision so clyde platform top is going to be in this if statement if i collide with platform top then i'm no longer going to have to check for colliding with the left side or colliding with the bottom side of the tile now inside of my narrow phase my function returns true if i do in fact have a collision and it is resolved and returns false if no collision was detected and nothing was resolved and if that's the case if it's false it'll just jump down to this next narrow phase collision method call that if there's no collision there it will jump finally to the last method in the case and call that and if that doesn't return true then there is no collision and nothing gets resolved so that's the routing function pretty simple that's how it works uh in previous tutorials on how to do this systems tile based collision system i used an array and i used um objects object references to get these but actually it's much much faster to use a switch statement so that's why i made the switch to a switch statement pun intended there so anyway next step onto the narrow phase now let's look at the narrow phase and that is going to be farther down inside of the collider classes prototype so inside the cladder classes prototype i have four functions and those are collide platform bottom cloud platform left clyde platform right and cloud platform top and awesomely enough with these four functions we can do collision detection and response with all of the different tile types basically any tile that has four sides we can take these four functions and combine them to get all kinds of different combinations up to 15 combinations which is as many combinations as you can have with a foursided tile so let's take a look at let's see here clyde platform top where i think i was on alright let's take a look at cloud platform top and see how this actually works so from the routing function you're going to get the object and you're going to get the top side of the tile so top side of the tile is just going to be whatever the top of the tile is that you're standing on so right now i'm standing on this tile i have my object i have the top of my tile and we're just going to run an if statement that checks to see if the bottom of our player character is greater than the tile top and if it is then we run this code but wait there's more there's an and in here so we've got to see what that is too we're also going to check to see if the bottom of the player from the last frame of animation is above the tile top now if you didn't include this it would still work but it would not work as smoothly as you see here so let's go ahead and comment this out and see what happens when we don't use the old position from the last frame of the player character i'm going to comment that out i'm going to save i'm going to come in here i'm going to refresh and now let's see what we get everything might work perfectly but oh wait how about that i just jumped right through that tile now the reason for that is the when i jump up the top left and top right corners of my player are going to enter into this tile space the broad phase is going to detect that it's going to hand the information to the the routing function and the routing function is going to call collide platform top now cloud platform top without doing this check on the last position that the bottom of the player was in the last frame of animation without that it's just going to check to see is the bottom of the player greater than the tile top and if it is set it to the top of the tile so that's what's happening when i enter into the tile it detects that the player was below the top of the tile and it just sets it right to the top so that's the functionality you're gonna get without this when you add this in basically what's happening is it's saying hang on let me refresh real quick basically it's saying okay the bottom of my player may be inside of this tile but if on the last frame it wasn't up here and therefore entering into this tile between frames so on frame one he's going to be here on frame two with the force of gravity he's going to be down here inside the tile he's going to be entering in through the top and collide platform top is going to detect that inside of this if statement because the bottom on the current frame is going to be below the tile top and the bottom on the last frame is going to be above the tile top so that's going to be true and then we're going to get the appropriate response that we expect and we're no longer going to jump through the bottom of the tile and get that kind of glitchy looking collision response so now let's take a look at what happens after we do that after we collide with the top of the tile so i'm going to cloud the top of my tile here this is going to be true the bottom on the current frame is going to be slightly below the bottom on the previous frame is going to be above and what i'm going to do is i'm going to set the bottom of the object i'm going to set this bottom of the object to the tile top and i'm going to subtract this little value here i'm going to get into why i subtract that value in a minute i'm going to take a look at another function because that better explains why i do that i'm going to set y velocity to zero this way gravity doesn't keep increasing and eventually pull me through the tile altogether i'm going to set jumping to false so i can jump again and i'm going to return true so i can tell the routing function not to do any more narrow phase collision calls so now let's take a look at this little value and see what it does but i'm going to do it in the context of the collide platform left function because that also has a similar problem cloud platform write and cloud platform bottom don't have this problem and it has to do with rounding so let's just comment this out and see what happens but first i'm going to show you the desired functionality so right now i'm colliding with the left side of these two tiles and it's calling collide platform left to do that collision resolution so as you can see i can jump up and down and it's as you would expect i'm jumping up and falling down nothing is broken yet so let me comment this out and break the code i'm not really breaking the code it's all going to work the same it's just not going to have the desired effect i'm going to refresh my screen and i'm going to come over here and i'm going to do this again now when i jump i land on top of the tile and the reason for that is because when i'm falling down i'm actually going to be in this tile space with the right side of my player so the right side of my player when i'm falling down into this tile space is actually going to be in this tile space just looking at it with a naked eye it looks like he's fully inside of this column but really his right side is just barely inside of this column over here so unless we subtract that .01 or some tiny number doesn't have to be 0.01 it could probably be 0.1 or 0.001 if you prefer because we subtract that we are pushing the player character out of this tile into this column and he's no longer touching this after he enters or exits collision with the left side of this tile space so let's refresh and see what that good functionality looks like now i'm colliding with the left side of this con this tile right here it's pushing me out of collision and it's actually pushing me out of the tile space entirely by .01 pixels so when i jump i am fully inside of this column as you would expect and i'm no longer going to be colliding with these tiles unless i press right on my keyboard and move the player into them so that's why i have to subtract that little value now before i stop talking about the narrow phase collision let me just talk a little bit about object.getold right and how we actually do that so basically all we're doing is on every frame we are saving the last frames player position and we're getting the new frames new player position so where that happens is inside of the player object we actually come out here and look so we can actually see the code a little bit the player class now extends the object class and inside of the object class we have this is the object class right here inside of this we have some information to describe a rectangle and we're also going to have the x old and y old values so keep that in mind we have a x and y location we have the x and y location from the previous frame of animation so if i come down here to the player class and i come down here to his update function this is where we're going to be keeping track of this x old and y old are going to be updated on every frame of animation to equal that frame's current x and y position and then we're going to update x and y to be as fresh as possible in the new frame so we're basically just keeping track of the player's old x and y position from the last frame and his current x and y position from the current frame and that allows us to calculate his angle of trajectory and we can see based on that trajectory if he was above a tile before he entered into it and that will give us the ability to get rid of that broken functionality that you saw where i would jump up and just almost teleport through this tile and sit on top of it so that's why we have to keep track of this this is also great for interpolation which is something really useful for smooth animation but i'm not going to talk about that in this video anyway that is the narrow phase it's really simple the functions are all really really simple if you just take a look at the source code i urge you to go to the link in the video description and check that out on my github page and that's it i'm going to show you how i added sprite animation to the game so you can take my example and use it to put sprite animation into your own programs i'm going to talk about what's new in part 5. then i'll give you a very simple and brief refresher on how sprite animation works when using a sprite sheet and finally we'll take an indepth look at the animator class and how it works with the player's movement to render the appropriate animations alrighty so the first thing i want to take a look at in part 5 is the example program and as you can see in this example program i no longer am working with the little white and gray square now i am working with this animated rabbit and he looks a lot better it's starting to look a lot more like a game that you can actually play just minus powerups and items and stuff like that so basically not much has changed other than i've added an animator class that does the sprite animation and i've also tweaked his physics for jumping and stuff like that a little bit but that's pretty pretty common sense stuff kind of know how to do that if you're already to this point in the tutorial series so i'm not going to worry about the specific changes i made for this video instead i'm just going to worry about showing you guys how the animator class works to get this guy animated on the screen if you do want to see what has actually changed in the code since part four take a look at the source code that i've linked in the video description at the top of each file that has changed and for part five it's just these three the game the display and the main files for each file that has changes in it i've added a bulleted list in the comments at the top of each file that outlines what exactly has changed specifically in the code so if you want to find out what's changed take a look at the source code and take a look at these comments but in this video i'm just gonna focus on the animator class and how to get this dude animated on the screen so stay tuned and i'll show you how it's done now let's take a brief look at how sprite animation actually works when you're using a sprite sheet so this here is my sprite sheet images the png has all my tile graphics and it has my sprite images in it now each sprite animation is just a compilation of these different unique images so each image can be considered just a square that you would cut out of this bigger image and then put on the screen in quick succession to give yourself an animation so for instance right now my player character isn't doing anything he's just sitting still this frame is literally being cut from this position right here if you notice this and this are exactly the same image so currently he is displaying this frame of animation if i were to move him to the left now he's going to stand still he's going to be displaying this frame right here when he's walking it's going to give me an animation so i'm going to be playing those frames over and over again in quick succession it's kind of hard to tell because he's walking so fast but he's basically playing when i walk to the right he's playing this set of frames right here he's stepping through these four frames right here and that's going to give me my animation so what's happening is on every frame that i draw to the screen i'm going to see which frame that my player characters class is determining that he should show based on his movement pattern it's going to take that frame it's going to go into this tile sheet image is going to cut that specific frame out of the tile sheet it is then going to take that frame and draw it to the player's location on this display canvas this canvas element that i have in the browser window and you're going to see whatever frame that is supposed to be displayed and that's going to give you animation so that's basically how it works basically you're just cutting different images out of a bigger sprite sheet image and you're displaying those smaller images at the player's unique location on the screen now we're going to take an indepth look at what makes the code actually work or i guess we're just going to take an indepth look at the code because the code makes the code work so here i'm going to start with the frame class now the frame class is just going to define a rectangular region that we are going to cut our sprite images out of the tile sheet width so it has an x value y value width and a height and that's just going to be the source rectangle that defines the individual image inside of our sprite sheet so i'm going to use one of those frame classes to define each rectangular region for each one of these individual images so that's what the frame class is going to be for and just bear with me as i explain all these different classes and you'll see how they fit together at the end of this part of the video so don't worry about the offset x and y positions just yet i'll tell you about those later just keep in mind it's just a rectangular region for the moment now we're going to look at the tile set class and this used to be the tile sheet class inside of the display file but i moved it over to the game file basically the functionality is exactly the same i just renamed it and its location is different basically just keeps track of the number of columns and tile size of our rabbit trap sprite sheet image and that's it where animation comes in here is with the frames array so now we just talked about the frames class which is down there the frames class is just a rectangular region with an offset position each one of these values inside of this frames array is just going to be one of the rectangular regions that corresponds to a specific graphic for our animation so for example this frame is where the idle left graphic is inside of our sprite sheet this frame is where the jump left graphic is inside of our sprite sheet this group of frames is going to be where all of the individual graphics are for the walk left animation down here we got the walk right animation so basically all i'm doing is defining each rectangular region for every one of my sprite animation components or basically these individual images so now you know where the individual frames are going to be defined inside of the tile set class now we're actually going to have to define what those animations are so the animation itself is going to be defined by the object that's using it so the animation for this rabbit or for the player is going to live inside of the player class so every unique animation the idle frames the walking left and right frames the jump frames those are all going to be stored inside of the player class inside of its prototype so i'm just scrolling up to that here we have the player prototype and inside of it we have an object called frame sets and inside of frame sets we have all the different animations for the player we have as idle left jump left move left and then the right words motions for those different animations so each one of these values corresponds to a frame inside of our tile sets frames array so for example idle left is going to have a value of 0 in it and 0 is going to be the frame index or the index inside of our frames array where the rectangular region is defined to cut the image out of the sprite sheet for the idle left animation and that's just going to be here so this is index 0 inside of our frames array it's idle left and that's what we're going to use for the idle left animation of our player and that's why that value is going to be a zero so as you can see each one of these values just corresponds to a different frame inside of the frame's array and what a frame is it's just a rectangular region that we use to cut out our sprite sheet images from the sprite sheet so how do we actually animate these that's going to be our next class that we look at and that's going to be the animator class so i'm going to scroll up to the animator class and i'm going to take a look at what this guy does so here's the animator class it's a frame rate dependent animation class so what that means is the rate of frames that you see for each animation is going to be totally dependent on the game engine's frame rate so if you don't want that kind of functionality this probably isn't for you but if you're just going to run your game consistently at 30 frames per second across all devices this is probably what you want to do and for html5 games that's a pretty good bet so this will probably work for you so i define a couple different values in here i have count delay frame set frame set is going to be those different frame sets or those different animation arrays that i define inside the player so for example frame set could be i'm going to scroll down here it could be any one of these animations it could be idle left it could be this array right here it could be move left which is that array right there could be any one of those and basically it's just going to use that information and loop through it when it does my animation think i went too far here we go so the frame set is just going to be one of those arrays with those values and those values of course correspond to our different frames that we use to cut the animation image out of the sprite sheet frame index is just going to be where we are or where the play head is so to speak inside of that frame set array frame value is going to be the value of whatever index we're in inside of our frame set so for idle left remember that was value zero the value was zero so for that particular animation it would be at index zero inside the frame set and the value would also be zero for the idle left image and then we have mode mode right now for this example there are only two modes we have pause and we have loop now pause and loop are just going to be the two types of playback that we want our animations to do so pretty simply i'm going to just explain that as we go i'm going to come down to the loop function all it does is it just changes the playhead position every so many frames that pass in our game loop so count is going to increase one time on every cycle of our game loop until it reaches the delay that we specify so for the walking left and right animations i've i've defined a delay of five inside of the player class so every five frames of our game loops animation or cycle we are going to run the code inside of this while loop so count we're just going to decrease that by delay and that makes us wait again frame index this is where we set the frame index or the playhead inside of our animation basically this we're just going to say is the frame index currently less than the frameset.length so let's take a visual look at what's going on here inside of our rabbit trap png so let's say the frame set that we're going to use has values that correspond to the walking right animation which is going to be these four frames right here so frame index at zero is going to yield a frame value of this image right here at frame index of one i'm going to move over one it's going to be a value that corresponds to this image right here when i move it over again it's going to correspond to this image right here so basically what the code inside of the loop function is doing is it's just increasing my frame index by 1 until it reaches the end of the frame set and when it reaches the end of the frame set the next time it goes to increase instead it just sets it back to zero so inside of my loop function all that we're going to do is just say set the frame index equal to the frame index plus one if it's not yet past the end of our frame set length and if it is past the end of the frame set length just set it to zero to restart the animation loop over again then finally what we do is we get the frame value that's just going to be the value that corresponds to the specific rectangular region that we store in the tile sets frames array that corresponds to the image that we're going to be cutting out of the sprite sheet so the frame value is just going to be set to whatever our frame set array is and we're going to hand in the index of the the playhead so whatever frame index is that's going to give us the value inside of our frame set that we're currently at in the animations loop cycle all right so that was a mouthful and hopefully i'm explaining everything quite well i think the next place we want to go is probably the render function but first i want to just touch on uh this functionality here the change frame set function inside of the animator class and basically what this does is it just changes what frame set we're using so whenever i press left on the keyboard i'm going to call change frame set it's just going to change the frame set to the left animation which is that array inside of the player class that defines which frames to use for the left animation uh when i press right it's going to call change frame set i'm going to hand in the player's right movement animation if i jump to the left i'm going to call change frame set i'm going to hand in the left animation you kind of get what i'm saying here then the only other function in here is going to be the animate function it just checks to see which mode we're in loop or pause pause is gonna be for no animation so pause is gonna be called on the idle animation so idle right and idle left pause is gonna be the play method that we use for the walking animations we're going to be using the loop method because we want to keep animating that cycle of frames over and over and over again and basically this is just called on every frame and it just calls the corresponding method it's pretty simple so now that we know how we're animating our frames let's actually take a look at the render function which lives inside of the main file and we're going to take a look at how we actually use that frame information to cut our image out of the sprite sheet itself so the first thing we do we're actually going to have to jump to another section of code real quick because i'm using an assets manager to load my tileset image so real quick i'm just going to jump up here check out the assets manager class all it is is an image and i'm going to load in an image with our rabbittrap.png image inside of it so really all that we're doing here is just using the assets manager to load our tilesheet really simple so that's all that is don't worry about it too much you could write your own code you don't need an assets manager all you need is to load up the tilesheet image to use it for drawing from that tile sheet image so here we go here's where we get the frame value so frame we're going to get the the frame remember is just that rectangular region but we're going to get to it through all those classes i just talked about so the animation class is going to give us a pointer to a frame value which lives inside of the frames array inside of the tile set class and then the tileset class is going to be using the frame class to define its rectangular regions to cut images out of the tilesheet image so how we get the frame is we just get the frames array from our games tile set then we go ahead and we hand in the player's current frame value which is kept up to date on every cycle of our game loop inside of the update function we're going to be calling player dot update animation and that's going to update our frame value inside of the loop function most likely of our animator class so draw object is going to take all this information and put it together to give us the appropriate image that we need to see to make our animation work on the screen so what we're going to do is we're going to hand in our source tile sheet image then we're going to hand in the actual source frames x and y position to cut from then this is going to look a little complex but it's really not we're going to hand in the players x location and y location and we're just going to add basically an offset where we want the frame to show up and be drawn to the screen so right now the player's frame is slightly offset from the player's real location and the reason i want that to happen is so when i stand on the edge of a tile i actually fall through and if you look his ears on the the frame are actually kind of moving through the tile if i go over here this the image itself is actually overlapping the tile i don't want it to be pixel perfect like that i want it to be functional i want the player to have fun i don't care about pixel perfect collision as much as i do the player having fun so this code basically what it does is it just repositions the frame a little bit to center it on the player's position so we can more easily move him around the screen without that pixel perfect collision that makes his hitbox seem a lot larger than it needs to be so all this does it gets his exposition it adds the center or it gets the center of where i want to draw that frame on top of the player by just getting half of his width subtracting half of the frame source frames with and then it just adds the frames offset x position if i don't add that offset x position and remember i was talking about that for the frame class if i come back into the frame class all the way at the bottom here we define the offset x and offset y and then when we actually instantiate each frame we're going to add negative 2 which is the going offset y position for this player if i don't add negative two this is what happens i just set it to zero i saved i'm going to come back in here as you can see now that was the y offset he's now two pixels deep into the ground and that does not look quite right so that's why i have that offset position all it does is add a slight offset when i draw the frame to the screen to make him appear in the appropriate location so that's it that's all that does you don't need this stuff like i said i i'm using a frame based approach you could easily use a tile based approach where you have all your graphics inside of one big grid kind of like the tiles are instead of having them all close together and cutting them out specifically the reason i do this is because if i were to add let's say my my rabbit has a sword and the sword comes out to here now my sprite is going to be different and it's not necessarily going to fit uniformly into a box or into a grid row and column cell with all the other sprites so i do it this way because sprites change they change in size they vary in size depending on what animation you're doing so this is just much more flexible for me so now let's get back into the rendering function went off on a little rant there so basically all the draw object function does of the display class is just draw from the tile set from the frame's x and y position and it draws to the screen whatever frame is currently in the animation in the player's animation draws that frame to the screen at a slight offset position then we call display.render and that draws everything to the screen including the tiles and whatever frame of animation our player is in alright so now let me just quickly see if i actually missed anything here i think i went over everything how everything works let me take a look inside of the player class itself and actually see how we're doing the players animation how we're actually deciding which frames to display and which frame sets to use this is going to be done inside of the update animation function so update animate animation is going to be called on every cycle of our game loop and it's basically just going to check to see what direction the player is facing and it's going to choose an animation based on that so the very first if statement inside of update animation is going to be is the player moving up which means is the player jumping up so if i press up on the keyboard the player is going to move up and if you look closely you can see that the up animation or the up frame is played briefly while he's moving up while he's moving down it switches back to idle left so if he is moving up and if his direction which is determined just by which direction he's facing so when i press the left key his direction is going to be negative one when i press the right key direction is going to be positive one so if his direction is negative one so if he's facing left i'm going to change his animation frame set to jump left if that's not the case and he's facing the right i'm going to change his animation frame set while he's jumping to jump right i'm going to do that in the pause position now for these other ones basically is he moving to the left if he is and his velocity is a certain amount then we're going to play the move left animation if the velocity is not a certain amount or less than that basically if he's basically stopped and his velocity is very small we're going to play idle left instead now this is cool because what this functionality allows us to do is it allows us to have our player gradually stop walking even though we're not pressing the walk key anymore so if i were to come in here and change this code to let's say this is the left walking animation what is this move left let's change this to two negative two and i saved i'm going to come up here refresh my screen now let's see what happens for the walk animation because i have to be moving at 2 a velocity of 2 to the left the move animation doesn't actually run unless i hit that 2 pixels of movement velocity per frame so what this allows me to do is it allows me to create an effect where i gradually walk to a stop instead of just halting to a stop really hard like that so a better a better kind of example would be if i used one instead and i refresh the screen up here let's see what that looks like now i start walking right away because i hit a velocity of one to the left really quick but as soon as i stop i go into the idle animation and that's not really good because it looks like i'm sliding too much or maybe you do prefer that and that's the great thing about this code you can just do whatever you want i kind of like it where i'm just gonna gradually stop walking until i'm completely stopped i don't prefer to just automatically stop and slide on my feet like that so what i've done is i've just set a very small value for the velocity check and if he is moving slower than negative 0.1 pixels to the left then he's going to idle and if not he's going to continue walking until he just comes that gradual stop like that so that's pretty cool so basically the update animation function is fired on every frame after you do collision detection with the player in the world and it just determines what way he's moving and depending on what direction he's moving it runs a certain animation now this is actually really important it's more important than you think not necessarily for the player because you can have fine control over the player but for nonplayer characters who move on their own you have to determine their animation based on how they're moving because you don't control them you can't say play the run animation when i press the run key because you're not pressing a key for a nonplayer character for those nonplayer characters you have to keep track of what direction they're moving how they're moving and based on that you have to set their animation so that's what this code does it just automates the process of setting the animation it doesn't rely on key presses or user input it just sets the animation depending on what direction he's moving before i go any further with this series i want to address something called tunneling it presents major problems for any physics engine and tile based engines are no exception tunneling is sure to affect you particularly if you are writing your own physics engine so stay tuned while i talk about how to overcome this pesky glitch alright so let's take a look at what tunneling actually looks like so this is the part five example program and i haven't changed any of the code since part five but i just want to show you this one glitch that happens underneath this tshaped structure of tiles when i am running into this tile from the right so i'm pressing down on the left key and i jump i actually pass into the tile now i can actually jump down below the tiles and walk around because of the nature of my tilebased collision code but obviously you don't want that to happen this actually isn't a problem with the collision code itself this is just a problem with tunneling and it seems to happen just in this one scenario so in order to show you guys better what's actually happening first i'm going to explain what tunneling is just using my mouse pointer as an example and then i'm going to show you in slow motion when i slow this game down i'm going to show you what's actually happening with the player and why tunneling is happening in this particular instance so tunneling is when the object moves too far in one frame to actually collide with a collision shape so let's say that this tile is going to be my collision shape and the mouse pointer is going to be my object so this is frame one on frame one my object is right here where the mouse pointer is and on frame two i'm going to move my object a little bit to the left so this is frame one this is frame two my object has moved about 16 pixels to the left now this is okay because i'm not moving more than one tile space i'm actually going to be over top of this tile space it's going to detect that i'm colliding with it and it's going to move the mouse out of the collision and put it back into an empty tile space that's how it should work tunneling happens when the mouse moves much farther than one tile space or 16 pixels in this case over the course of one frame so if this is frame one and i move in frame two all the way to here what's happening is i'm jumping right from here all the way to here and i'm never detecting a collision with that tile because i'm never landing in it so tunneling is basically just moving a player object or any object too quickly to detect collision with a stationary collision object so now that you kind of understand what tunneling is let me slow this down and show you in action what the tunneling looks like with the player character so i'm going to save my code i'm going to set the frame rate to one frame per second that's going to slow things down a lot and i'm going to refresh now as you can see things are really really slow so i'm going to run over here into the corner and it's going to take a while so just bear with me but i'm going to show you this glitch in as slow motion as i think it should be i don't want to go any slower than this or would take forever so here i am i'm standing next to the tile i'm going to press up and i'm just going to jump straight up so i jumped up and immediately this tile up here resolves collision and throws me right back down below it but if i jump up while i'm pressing the left key i jump up and i move slightly to the left now that's when the tunneling occurs so the tunneling isn't actually happening on this tile right here it's actually it's kind of a special case but i'll show you why so i'm going to run back out here and i'm just going to jump up the tunneling is actually happening when i jump because the player character is moving about 20 pixels upwards as soon as i start jumping and you'll be able to see that when i jump here in a moment so i could actually get this thing to comply it's just moving so slowly all right so i'm gonna jump and just take note of where this player actually moves to when i jump so this is the top of the player right here this would be 16 pixels from the ground right here when i press the jump key immediately my player is above that 16 pixels his feet were about right here and he clearly moves more than 16 pixels which is our tile space so if he can potentially move past one full tile space without stopping in it he can tunnel because tunneling is basically when on frame one we're out of collision on frame two we jump over a collision object and never touch it so what's happening here is when he jumps imagine what happens if he were standing right here he's going to jump up on the first frame his the top of his hitbox is actually going to be over top of this tile and the bottom of his hitbox is going to be inside of this tile so what's happening is when he jumps and he's standing here he's going to jump up he's not even going to have a chance to clyde with this tile because the top two corners that i'm checking out on his hitbox are over top of this tile even the only reason collision happens on this tile is because his two bottom feet or his two bottom corners are inside of this tile and he can still technically move to the left while he's in this tile because collision is only going to happen in this tile with the bottom side of the tile and it does when i'm standing underneath this tile it does do collision but just on the bottom side i can still move to the left so when i jump up underneath this tile i'm going to jump i'm going to hit my head on the bottom and it's going to send me right back down again but remember i'm jumping 20 pixels high so what's going to happen is just my feet are going to collide with this when i jump i'm actually going to move up here then it's going to place me back down there and i can still move over to the left so when i jump up and press left i'm actually going to be up here and i'm going to fall back down into this tile on the wrong side of the collision boundary so that's what tunneling is and there's a really easy way to fix it if i come in here and i set this back to let's see 30 frames a second that ought to do let's see what that looks like 30 frames a second things are back to normal what i'm actually going to do is i'm going to come out here and i'm going to change the speed at which he jumps and that's actually going to fix everything so if i can find where that is oh it's actually in the game object here jump i'm actually setting jump whenever he jumps i call this function and it moves him 20 pixels up it sets his y velocity at negative 20 pixels so what i'm going to do is i'm going to set it to negative 15 pixels and that's going to prevent him from ever moving more than one tile space and actually i'm going to set this back to one frame so you guys can see that in action as well let's go back to one frame per second refresh and now we're going to zoom in and take a closer look at this guy jumping so this is what 16 pixels looks like when he jumps as you can see his bottom feet are no longer way up here on that first frame on that first frame they're down here so he'll still end up colliding with this tile right here so when i move back into collision and i'm going to speed things up for this set it back to 30 frames a second save come over here refresh my page and now tunneling can no longer happen so collision is going to happen as i expect it to so that is the problem and i guess i kind of showed you how to fix it in the first part but i'll go into more detail on how to fix it in the next part okay so we just looked at part five's example program where we had this glitch where actually i fixed it but very fresh we had this glitch i'm gonna leave that in actually so if you ever check out part five that glitch is gonna be left in there but now i wanna show you a better way to fix it and this is a sneak peek if you will at part six where i actually did fix this problem so here's the same exact tile structure same scenario in part six without the glitch now how i did this was i basically just clamped his movement velocity to never exceed 16 pixels or one tile space now if you just reduce the amount of velocity that he jumps at it can cause problems so for instance here i'm going to take a look at part five again here's part five i can jump up above this tile if i have a a y velocity of negative 20 pixels per frame when i jump so obviously if i reduce this to 15 and i save it's gonna it's going to eliminate the possibility of tunneling that's great but now i can't jump up on my platforms anymore so how do i fix this well the way to fix it is to go ahead and change your gravity and friction at least that's one way to fix it so i'm going to save that so it's back the way it was i'm going to come over here and i'm going to take a look at the code excuse me let's take a look at the code inside of part 6. so in part 6 i'm still using a velocity of negative 15 when i jump the only difference is now i'm clamping my movement velocity when i update the player's position so basically to do that i'm just saying if the absolute value of the player's x velocity or y velocity is greater than some max velocity and that's going to be 16 or 15 basically our tile size or maybe one less just to be safe if it's greater than that then we're going to set our velocity to the max velocity and actually this code is wrong because i don't want to change the sign of my velocity i just want to change the amount of my velocity so but you get the idea part 6 is still in development basically what you want to do is you want to clamp your movement speed and to get the same jump height with the different y velocity what you do is you just reduce gravity and friction so here is what a jump looks like in part five as you can see he jumps a lot faster it's kind of almost too quick so this is almost an improvement for visuals as well this is part six where i've kind of changed it up so he can have a clamped velocity and he just moves a little more smoothly if you look at it it's a little more smooth here's part five again jumps really far really fast it's a little bit too quick part six a little more smooth hopefully you can pick that up with my my video recorder here because sometimes it doesn't quite match the frame rate of the game when it's recording so basically what you want to do to fix tunneling is you want to clamp your jump speed so the amount of velocity that you apply to a jump and that's going to be where a lot of your velocity comes into play high velocities when you're jumping that's going to be a thing you wanna clamp it to an amount that's less than one tile space then in order to get the height of the jump that you want you're gonna have to reduce uh gravity and friction so for me i came in when i defined the world object what i do is i just have gravity and friction defined here so for example friction if i change the value of friction to say 0.9 0.99 that's going to be really low friction so if i come over here and refresh now i'm going to have really really low friction and as you can see i'm just moving really fast all over the place jump really far really fast because there's no friction so i don't want that but that's basically how you fix tunneling you just basically have to clamp your velocity to a certain speed and to get the jump height that you want you just mess with friction and gravity and that's gonna do it for tunneling i'm going to show you how to create level data files using json how to load level data and use it to populate the game world and finally how to trigger subsequent level loads by colliding with doors let's take a look at what has changed since part five and part five and a half so this is part six and everything is basically the same i did make quite a few changes but most of those changes pertain to loading different levels so when i jump up into this area here and walk off the side of the screen it's actually going to load a different level as you just saw so how how this is working is i have a little door hit region just off the right of the screen here and it's just a rectangular box and when the player character's center point hits that box it loads the level and places the player in whatever location he needs to be to start this level out when walking through that door from the other level so basically in part six i just have a couple different levels and i've defined a couple different types of doors they're all just rectangles you just saw two small rectangular doors this area on the bottom of this level is one big rectangular door so i can jump up through it at any point in this rectangle so this system works great for any size door doesn't just have to be one tile it can be any size rectangle that you define so that's basically part six so now that you know what the example program is about let's get into how this works before we get into the javascript code let's actually take a look at the different level files so this would be level zero zero or i call it zone zero zero so the file to load this level that you see on the screen is this file right here zone zero zero and basically it's just a couple of different json structures so i have a doors array and inside of that i just have the doors that are contained in this level so for this level level zero zero or zone zero zero i have one door just to the right of this tile the door would be right here off the level that you see on the screen and this json here defines an array of doors and this object inside of it will be that door object that resides right over here so that's my doors array down here i have some information about the maps each map has 12 columns and 9 rows i did not format this so you could actually see it in kind of a 2d row and column format i just have it in one big long array but if i were to line this up so each row had 12 columns in it you would see that the maps are 12 columns by 9 rows but this is my graphics map so these are all my graphics tile values this is my collision map so these are all the collision values for the tiles and then finally i have id and that's just going to be the level id so like i said this is zone zero zero so when i load zone zero zero this just tells my world object that it's zone id zero zero so now let's take a look at zone two and we'll just take a look at zone two's code really quick just so you get it in your head that this is what the the format is so here's my doors array zone two has two doors there's a door right here to go back into zone zero or actually it's zone one excuse me because i start labeling a zero but this is zone one and it leads back into zone zero zero there's a door right off the left side of the screen here and it goes into zone zero two with a door right over here on the far right side of the screen so inside of my doors array i have defined two door objects and then same as before i have my columns and rows and my two maps and the id that just indicates what zone this is so if you know how to write javascript you know how to write json for the most part it's really easy and it's a really great natural fit for writing information that you're going to load into your javascript game because it's so similar to javascript already and you have the builtin json.parse method to parse this information into usable javascript objects so now that you know how to write the level data let's get on to the next part of the video okay so now that we know how to define our level data we need to figure out a way to load it and the best way to load it is with xmlhttprequest so inside of my main.js file i have a class called assets manager and it basically just has a function called request json inside of it so in order to load my json file i'm going to call this request.json function i'm going to pass in the url of the file to load so basically i'm just if i want to load zone 0 0 i'm going to pass in the string zone00.json and i'm going to provide a callback function but i'll get to the callback function later so first thing i'm going to do is create an xml http request i'm going to give it an eventlistener for the load event and i'm going to have an event handler for when it loads which is just going to call my callback and hand in the parsed json string from my json file so i'm going to send off my request to the server it's going to process it it's going to hand me back the file content remember that file was zone00.json it's literally going to hand back this stuff in response text or just text format and i'm going to take that response text or the content my json file i'm going to use json.parse to turn it into a javascript object and i'm going to call the callback so that's the request json file that we're going to use to actually load our data so now let's take a look at where we first load up a level when we first start the game and that's going to happen all the way at the bottom of the main js file in the initial the initialization section so this is where we're using the request json file to load up our very first level so when i click refresh my code is gonna run in main.js and this right here is gonna be responsible for loading up zone zero zero which is on the screen right here so let's just take a look at what we're handing in calling assets manager dot request json zone prefix that's just gonna be the string zone for the first part of our url game.world.zone id when i first instantiate game it creates an object called world so game.world is a world object and that has a default value in it of 0 zero for world zero zero or zone zero zero so that's where we're going to get the zero zero from this is going to be zero zero and zone suffix is just gonna be dot json so i have the zone prefix of zone plus the game dot world dot zone id which is zero zero plus zone suffix which is going to be dot json so i'm going to hand in that url to request json it's going to send a request to the server when the server returns the json data inside of zone zero zero in text format i'm going to parse it into a js or a javascript object and then i'm going to hand that javascript object into my callback function which is just going to be defined here i defined it in arrow function format so this is my callback function and remember that i passed in json.parse request.responsetext so that's going to be the javascript object that i created from my zone file and i'm going to hand that into game.world.setup so let's go ahead and take a look real quick at game.world.setup and also where we create the very first default value for zone id so let me see if i can find where i'm at here i'm inside of the game file and this is the game.world.prototype so let's go up a little bit more game.world this is where we define game.world let me real quick just take a look at the default value for zone id so remember the default value for zone id we're going to use that right here when we're loading our first level so that's just going to be defined right here right now the default value is zero zero so when i refresh the page the first level it loads is zero zero if i change that to say zero one and save it and refresh the page keep an eye on the level map it's gonna load up world zero one if i change it again let's go world zero two save we're gonna load up and it's gonna immediately well it dropped us in world two but we fell down into world three so basically this sets our default level to load initially when we boot up the game so that's where we defined that but now we're going to take a look at game.world.setup where we actually put all the information from our zone file into our game.world object which we use on every frame of animation to do stuff with our game so down here is the setup function this is game.world.setup and it takes one parameter which is the zone which we just parsed into a javascript object from our zone00.json file so basically all we do is copy over all the values from our newly created zone object and we copy those values into our world object pretty simple the only one we don't copy directly is the doors array and the reason for that is because i want to use a door object that i defined i'll talk about that in the next part but we do loop through all the doors in the zone's doors array and we just create a new door from the doors that we loop through so inside of this zone file we have an array called doors every object inside we get and we convert this data into a game.door object so this class here we're just going to create a door object from the door data inside of our zone.doors array so whatever door we loop over in that doors array gonna be converted into a game.door class and that's what we're gonna use for our actual game logic and game physics when we collide with the doors and stuff now we finally know how we're setting up the very first initial level i'm getting out of breath here i'm talking so much but now we need to know one more thing and that's how to actually go ahead and load a level on the fly when we when we walk into a door so where we do that is inside of the update function for the game so on every cycle of our game engine on every game loop so to speak we're going to call this function from inside of main and this is the update function so the first thing we do is get some user input then we call game.update game.uptake takes care of moving the player takes care of all the world collision and inside of the game.update function is the world.update function so let's go ahead and take a look at world.update real quick already inside a world uh game.world.prototype so this is the game.world.update function which is called inside of the game.update function which we're calling right here so basically this function is going to call this function so first thing we do is update the player's position we collide the player with the world this refers to game.world so we're going to cloud the player with the world so all the tiles and then we're going to come down here and we're going to loop through all the doors in the world in the current region or zone of the world we're going to get each door and we're going to test for collision with the door and it's just basic rectangular collision i'll cover in the next part of the video basically if we do collide with the door so if the player actually collides with the door we're going to set this dot door or game.world.door equal to that door that we just collided with so normally this dot door is undefined so out here in our update function which is called on every frame we're going to test to see if game.world.door is not equal to undefined and the only time it's not equal to undefined is when for a split second we actually walk into it and then this if statement returns true and we go ahead and load the world that was specified by whatever door we collided with so let's just go through this real quick and see what happens the first thing that happens when i run into a door so if i run into a door the first thing that happens is i stop the engine i then make a request with request json to whatever zone that door brings you to so if i come up here into my zone00.json we're in zone zero zero the destination zone for this specific door located at an x of 192 which is about there and a y of 64 which is about there has a width and height of 16. so right off the right of the screen here is a box that's about 16 by 16 pixels and when i collide with it it's gonna load zone zero one and it's going to put the player at destination x of zero and negative one just means we're not going to use destination y so the player's y destination remains the same but i'll get into that in the next part um so basically we're gonna request the destination zone specified by that door so this door here that we're about to walk in right to the right of the player will tell us to go to world or zone zero one so when i walk into it this code loads up zone zero one pretty simple the same thing that we did for the initial level load we're just doing again right here even have the same arrow function with uh the zone parameter specified inside then inside of our callback after request json requests the level data the server gives it back to us in text format it parses that into a json object called zone and hands it back to us we're just going to call game.world.setup and it's going to get all the information out of the level file and put it on the screen basically so there is one difference this time however because now we're going to have to use some information from a specific door so let me go back inside the game.world.setup function real quick i'm going to scroll up to it right here game.world.setup and we check for the case that we are colliding with the door because remember when we enter into collision with the door we set the world's this dot door property equal to the door so when we call setup this dot door is actually going to be equal to whatever door we just collided with so if i come over here and collide with the door that's right over here it's going to be equal to that door that i just clouded with and it's basically it's just going to set the player's x and y center position to whatever the door's destination x and y values were that's it really simple everything else works the same as the initial level load the only difference is when you walk into a specific door you reposition the player according to that door's destination x and destination y so stay tuned for the next part where i'm going to talk about the door class specifically the collision and all that kind of good stuff now i want to take a look at what a door actually is so if i zoom in here i'm going to look at what a door is inside of my zone00.json file i've got an x position and a y position a width and a height so basically my door is just a rectangular region on the screen somewhere that the player object can collide with then i also have a destination zone that's going to be where the player is going to go what level i'm going to load if the player hits the door and i have a destination x and a destination y for the player as well so this is where i'm gonna put the player in the newly loaded zone when it loads if i have a negative one that just means destination y does not get used and the player's y position remains the same same thing for x if i have a negative one the destination x position isn't going to be used the player's x position is going to remain the same so we can see this functionality over here if i fall into this world i'm not being repositioned on the yaxis or on the xaxis rather because i don't need to be i just want to fall right through and naturally have my player end up where he has to be based on where he was in the previous level i don't want to jump through this floor door right here and end up at the very start of the door over here in the next level if i jump through over here like if i jump through right here i don't want to come out in this world right here because it just wouldn't look right so that's the only reason i have a negative one there but anyway let's look at the door class the game.world.door class and actually see what that looks like and the collision code that i'm using to have the player in the door actually collide so if i could find that wherever that is scroll scroll scroll hopefully i'll come across it soon ah this is it right here so it's a really simple object i'm gonna correct that small formatting error there really tiny object basically is the same exact thing as this right here it just has a prototype defined with the collide object function inside of it so this is the door class and i'm going to call object on it object all it is is a rectangle class that has some functions for helping me determine the sides of a rectangle so it has functions like get left get right get top get bottom just defining a rectangle here inheriting from the object class then i'm going to set the destination x y and zone to whatever those are from the door object that we hand in and that's just going to be whatever is defined inside of the zone file then inside of the prototype i have a function called collide object and that's just going to test to see if the object's center points are inside of the rectangular region of the door so this code right here just tests to see if the player is not colliding with the door if he's not then i'm going to return false and that means we didn't have a collision with the door if any of this is true or actually if any of this is false then we know that we have collided with the door and in that case we're going to return true so where do we actually use this that's going to be inside of the world.update function so if i come down here to worlds world.update right here there we go okay so inside of world.update i have all the doors defined inside of my world.doors array i'm going to loop through every door in that array i'm going to get each individual door i'm gonna test to see if the door is colliding with the player object and if it is i'm just gonna set the world's door property equal to that door and then just like in the last part we're going to go into the update function for our main game loop game loop and inside of that we're going to have an if statement that just checks to see is game.world.door defined and the only time it's defined is right after we collide with the door so we're going to stop the engine we're going to load the level defined by the door by the door's destination zone more specifically we're going to set up that zone in game.world.setup and we're going to restart our engine now inside of setup i know i'm recapping stuff that i just talked about but inside a setup we have this is the inside of the setup function we have an if statement that just checks to see is this door or game.world.door defined is it not undefined if it's defined and we have a door in there we're going to set the player's x and y coordinates equal to whatever those were defined as by the door object and if it's not equal to negative one then we know we can set it up if it is equal to negative one we just leave it alone so that's like in this case here where i'm not changing the player's x position so for both of these doors this door up here and this door down here for each level respectively the destination x position for that door is going to be set to negative 1 because i only want to change the player character's y position this way i don't have him jump through here and start out over here on this door so that's basically it that's how i define my door objects and that's how to load levels with doors i'm going to show you how i define the carrot and grass objects in the level data file their respective classes and the basic collision detection used to collide with the carat objects the first thing i'm going to talk about is what this example program is all about and where the carrot and grass objects are defined because since the last installment of this series i have since added carrot objects and grass objects you can see that i'm running into the carrot objects and when i collide with their hitbox i collect a carrot i have a carrot counter at the top left of the screen and then down here i have some grass objects and all the grass objects are are just objects with an x and y position and they have an animator inside of them they extend the animator class and it just updates the image on every frame of the grass to give the impression that the grass is actually swaying back and forth so just some basic objects i've added and if i come over here and take a look at the zone file you can see that this is my level data file and i have an array for carrots i have an array for grass and basically they're just little arrays inside of here that define an x tile position and a y tile position so if i come over here to my map and i refresh this carrot is going to be at position 1 comma 2. so the x tile is going to start at 0 and go to 1 because this right here is 1 2. so x tile of 1 y tile of 2 so if i count from zero i get zero one on my x tile axis and for the y tile axis i have zero one two so i know that from this map i wanna carry it at position one two and that's that carrot same thing for the grass my first grass tile is at x position two y position seven and that's going to be this grass object right here so pretty simple so when i load my level up i'm gonna actually have to loop through these arrays here get the x and y tile positions from them and then create an object from that x and y tile position and if i am looping through the carrots array i'll create a carrot object if i'm looping through the grass array i'll create a grass object so let's go in and check out the setup function of the game.world object the setup function just runs i come over here and refresh my screen the setup function runs right after the level data is loaded so right after i load this level data and i get access to it with json.parse i then call the setup function i pass in the json object that i just parsed after i loaded that level data from json and i go ahead and i set up all of the game objects and the graphics and collision map and everything for this level and then i'm going to go ahead and i'm going to loop through the zones carrots array and the zones grass array and basically those are literally just going to be these two arrays right here so i'm going to loop through them and i'm going to create a new carrot and a new grass object for every instance of one of those little x and y tile arrays that i come across inside of the zone file so what that looks like is i'm just going to use a for loop i'm going to go ahead and i'm going to loop through all the carrot objects inside of my zone's carrots array which is just the little tiny x and y tile arrays i'm going to create a carrot object or not an object but a variable to store that x and y position from the zone.carrots array and then i'm going to store a new game.carrot inside of my game's actual carrots array that i'm going to use on every frame of animation inside of my game cycles for my game loop so what i'm going to do is i'm going to feed it in x position in pixels not in tile space so i'm going to take the x tile position of the carrot which is located at position 0 inside of that array that we loaded from the level data and i'm going to multiply it by the tileset.tile height which is 16 pixels plus 5 is just going to give me an offset so if i were to come out here and make this plus 0 and save i come over here what's going to happen is i'm no longer going to i'm not going to have an offset of 5 pixels anymore so you can see they're kind of offset to the left by 5. if i come back in here and i undo that the z control z save come back over here and refresh now all my carrots are in the right position pretty much i do the same thing with the grass basically i just loop through all the grass in the level data file and i create a new instance a new grass object and i just position it based on the x and y tile values stored in my level data so that's it next i'm going to take a look at the actual classes that we use to make the grass and carrot objects now we're going to take a look at the grass and the carrot classes respectively so first i'm going to start out with the grass class and all it is is really simply an animator object it inherits from animator this way i can animate the frames and it also has an x and y position if you look at a grass object which is just this right down here obviously all it does is sit in a location so that's going to be my x and y position and it is animated so it's going to have to inherit from the animator now the animator class is the same class that i use to animate the rabbit it can be reused for all different kinds of game objects to give them an animation so really simply the grass class just has an animation and a position and the carrot class kind of does too but it also has a lot more so let's go up and take a look at the carat class and see what makes it move and how we collide with it with the player object so here's the carrot class and it inherits from the object class the game.object class as well as the animator class so the animator class just gives it the animation the object class is what's going to give it its x and y position as well as its width and its height and in addition to those things it also gets the collide object function which is going to be responsible for allowing us to collide with a carrot and actually collect it so that's important to note then some cool features about the carrot we have the base x y and position x y values so base x and base y are just referring to the center position that the carrot is rotating around or making that figure eight around so that's going to be the base x and base y position the carat does still have an x and y position that's going to be where it's actually drawn to the base x and base y are going to be just the point that it rotates around position x and position y are going to be vectors that the caret is placed by the amount of the vector on whichever axis away from the base x so to explain that a little more clearly if base x is in the center position x and position y are going to be distances away from the base on their respective axes and that's what's going to determine how far from the base the carrot is and we're going to i'll show you how i'm using position x and position y in a second just going to move down here but i set a random value up here and that basically just makes all the carrots kind of have a different um path because otherwise if i just set this up to be let's see zero all the carrots would have the same rotation pattern they'd all be synchronized basically so if you look now you can see very clearly that they're all synchronized and that's kind of a bad look so just go back to how it was before save and now you can see that they all kind of move independently and it's a lot less jarring to look at because before it was almost like there was a big just solid image of carrots with the transparent background just moving back and forth on the screen that's not what we want to go for we want to have independent movement we want to have things looking like everything is random so also speaking about that up here the frame index if you notice all the carrots on screen are not sharing the same uh animation sequence well they they're they're sharing the same frames obviously but if you look at two you can see that they're animating at different rates i just have to find two that are going at offset values here these two this one and this one they display the opposite frame from one another so when this one is on frame zero this one's on frame one when this one's on frame one this one's on frame zero that keeps things looking fresh so if i come up here and change this to just be zero it's going to reduce the randomization and we're just gonna have everything animating the same exact way almost like it's updating from the same exact animation object so that's not what we want either we want things to randomly update their animation not randomly but look like they have their own unique animation even though they're displaying the same frame so to do that all i'm doing is i'm starting off the animation at a randomized frame index alright so now let's take a look at what actually makes these things rotate around the base x and base y position inside of the game.carrot.prototype which is going to be the prototype for our charact class i have a function called update position and that's oh that's the only function for this class and this is going to be called on every frame of animation we're going to talk about this in the next part but all it does is it updates the position x and position y value and sets the actual x and actual y value of the carat object which we're going to use to draw it to the screen so excuse me position x and position y what it does is it's just a distance from the base so you can think of it as a vector distance from the base so oh actually well that is true but when i'm updating these it kind of controls the speed of the animation so if i were to make this five and this nine and save we're gonna see the carrots move a lot more quickly so when i press refresh up here now they're really moving like those guys are jumping around quite a bit there so that controls the speed at which things move because on every frame of the animation i'm adding uh 0.5 or 0.9 to these and that's going to make the thing move a lot more quickly obviously so let's get back to how things were save come down here and look at how we actually use these so math.cosine and math.sine are what's going to give us that circular motion and we just plug in position x and position y into cosine and sine and over here we have a multiplier of two that's going to control the distance that the carrot sways on the xaxis so if i come over here and refresh to get things back to normal you can see that it sways a little bit further from side to side than it does from up to from top to bottom there so the reason for that is because of this two if i were to make this a 10 and save that the carrots are going to sway a lot more from side to side than they do right now so now you can see they're really swaying from side to side but that looks kind of ridiculous so we don't want that but basically what's happening here is we're just increasing we're incrementing up position x and position y uh math.cosine and math.sine give us a nice uh rounded or circular kind of effect there and then the multiplier is just going to be how big is that distance vector from the base position i guess it's actually a scalar because it's only one single value but together they make a vector so let's just put that back to two so on every frame i'm going to call update position and this code is going to run and it's going to make the carrot move back and forth now if i refresh everything's back to normal so next i'm going to talk about how we actually do the collision between the carrot and the player to do the collision detection between the player object and the carat object we need a function that basically just does collision detection between two square hitboxes so where that function is is inside of game.object so i'm going to scroll up to game.object and we're going to take a look at the function that we used to do that hit detection so here's the game.object.prototype that's just the prototype for our game the object class and we have collide object and what collide object does is it just tests for square collision detection between two rectangular objects so this object is going to collide with the parameter object that i hand in so basically i'll be able to hand in two objects and determine whether or not their hitboxes are overlapping so just wanted to show you this function and now you'll kind of know where the collision detection function is coming from where i'm actually utilizing all this is going to be inside of game.worlds update function so i'm going to come all the way down to the bottom all the way down past the player object pass the tile set object to the world object inside of the not the setup function but the update function so here we are inside of the update function and here we are going to call all of this code on every frame of our game's animation and we start up we uh we update the player's position we collide the player with the game world to get the tile collision going and then we're going to start colliding with carrots so we have a carrots array that's going to hold all of our carrot objects that we created inside of game.setup or game.world.setup rather we're going to loop through all of those carat objects so just these guys here and we are going to update the carrots position we're going to animate the carrot and then we're going to say is the carrot colliding with the player with the clad object function if that function returns true we're going to splice that specific carrot out of the carrots array and we're going to just remove it completely and we're going to add one two carat count and it's as simple as that we're just going to test for collision between the player and the carrot if collision occurs we're going to just remove the carrot carrot object is totally gone it will be garbage collected later on assuming that i removed all references to it and i think i have so then what's gonna happen is i'm going to increase carrot count by one and carrot count is what we're using to update this p element's inner html right here so where does that happen that happens inside of the main js file if i come down to the render function i have a p element it's referenced with the p variable and i just set its inner html to equal carrots plus game.world.carrotcount on every frame and that's it so i hope you guys learned something i hope you enjoyed the video and i'll see you guys next time
