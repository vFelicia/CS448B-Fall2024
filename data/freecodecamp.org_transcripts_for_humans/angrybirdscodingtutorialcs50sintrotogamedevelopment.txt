With timestamps:

00:16 - COLTON OGDEN: All right.
00:17 - Good evening, everybody.
00:18 - Welcome back to GD50.
00:19 - This is lecture six.
00:21 - And today we're going to be
venturing out of the 8-bit world
00:23 - and back into a more
modern era of gaming.
00:26 - We're talking about Angry Birds today.
00:28 - I have pretty fond memories
of Angry Birds, actually.
00:30 - It was the first mobile
game that I remember
00:33 - playing where I realized that mobile was
actually a viable platform for gaming.
00:38 - I played it, I think, back in 2009,
was when it was first released.
00:42 - And I really enjoyed it.
00:43 - It has a very simple formula.
00:45 - The goal, if you're
unfamiliar, is you have
00:47 - birds that you control by a sling
shot on the left side of the screen.
00:52 - And then these pigs that
have stolen your eggs,
00:54 - you're trying to destroy
them or kill them
00:56 - by knocking down their fortresses made
out of various materials, wood, glass,
01:01 - metal.
01:02 - And you get a few different bird types.
01:03 - But the gist of it is, basically, just
sling shot a bird into some structure,
01:08 - knock it down.
01:09 - And the whole entire
underlying mechanism
01:12 - for how things work is
via a physics engine,
01:15 - which we'll talk about today in
lecture, called Box2D Probably
01:18 - the most ubiquitous 2D physics engine.
01:21 - But that's the overall
structure of the game.
01:24 - It's literally just throwing things
into structures, knocking them down.
01:27 - And then that tactile and fun game play
makes for really great mobile gaming.
01:32 - And I enjoyed it a lot back in the day.
01:34 - This is a screenshot of the first
level in the first Angry Birds, which
01:38 - most people I think have probably seen.
01:41 - This is a sample from
one of their newer games.
01:44 - As you can see, it's taken
a whole new layer here.
01:48 - There's stone and a bunch of intricately
varying structures and new creatures
01:54 - and stuff like that.
01:55 - The game has changed a lot, but
the formula has stayed the same.
01:57 - And today we'll explore the foundation
of what makes this game work.
02:02 - And the topics today,
a smaller than usual.
02:04 - But Box2D, we can consider as
being a pretty large topic.
02:09 - We'll be talking about
Box2D, which is the physics
02:11 - engine we'll be using today in lecture.
02:13 - And via Love2D, which has
its own wrapper for Box2D.
02:16 - And we'll also talk a little bit about
mouse input, which you haven't really
02:19 - done a lot.
02:20 - But it's very apt, especially
in the context of mobile gaming.
02:23 - Because mouse input and
touch input are synonymous.
02:28 - But first, let's get a lecture demo.
02:30 - If we have a volunteer come
up on stage to showcase
02:34 - what I've put together here.
02:35 - So let me make sure I'm in
the right directory here.
02:42 - So whenever you're ready,
go ahead and press Enter.
02:49 - So this is a little demo I put together
to demonstrate the concepts we'll
02:54 - talk about today in class.
02:55 - This is just the Start
screen, but it already
02:57 - shows Box2D representing a bunch of
these square shaped aliens, which
03:02 - we'll actually be what we're
trying to target in the game.
03:05 - But notice that they all fell
and had their own collision
03:08 - and their own physics that took place,
and I didn't have to manually code
03:12 - rotation and stuff like this.
03:14 - This is all stuff that
Box2D takes care of for us.
03:17 - And we'll see it used
to great effect soon.
03:19 - If you go ahead and just
click anywhere on the screen,
03:20 - we'll go to the main part of the game.
03:22 - So this is a very simple
representation of what Angry Birds is.
03:26 - You start on the left
side of the screen.
03:28 - You have a bird, in
this case an alien, we
03:29 - used a free art pack that
uses aliens instead of birds,
03:33 - but it's the same concept.
03:34 - You have an alien that
you can click and drag.
03:36 - So if you click it and
then drag around, you
03:38 - can see the trajectory that you'll
have when you let go of the mouse.
03:43 - So we're simulating where it's going
to go via these purple circles.
03:46 - And then the goal in Angry
Birds is to throw the bird into,
03:50 - or the alien, into the
fortress guarding the pigs,
03:53 - or in this case, square shaped aliens.
03:56 - So if you go ahead and just launch
the bird by letting go of the mouse
03:59 - you'll see.
04:00 - Oh, there we go.
04:00 - And we knocked down the.
04:02 - OK.
04:04 - What happened was we shot
the alien into the structure.
04:08 - It destroyed one of the wooden
blocks guarding the other alien.
04:16 - And then, as soon as that
happened, the top box,
04:19 - because these are all being
simulated via Box2D's physics engine,
04:23 - that other box was detected
as being unsupported.
04:27 - So it fell down, it hit the other alien.
04:29 - And we've coded it so that
when a collision occurs
04:31 - between an obstacle and our
alien of sufficient speed,
04:35 - it should kill the alien.
04:37 - Which is how it works in Angry Birds.
04:38 - So if you'll try it again.
04:40 - And this time we hit both
of those at the same time.
04:42 - So it triggered both
of those being deleted.
04:44 - But this guy is still alive.
04:46 - So after it stops moving,
which is similar to how
04:50 - it behaves in the original game, it's
going to let us try again to shoot.
04:54 - So if we try one more time.
04:57 - And then we launch and hit it, we
kill it and then we get a victory.
05:00 - So that's the overall underlying
foundation for what Angry Birds is.
05:04 - Obviously we're using a
very simple representation.
05:06 - It doesn't have a lot of the
frill that Angry Birds does.
05:09 - But we could easily build upon
this and create a fully fleshed out
05:13 - game very similar to Angry Birds.
05:14 - So thanks, Steven.
05:15 - I appreciate the demonstration.
05:25 - So that's our goal today.
05:26 - We'll be talking about how to construct
a very basic but functional simulation
05:33 - of what Angry Birds is at its core.
05:35 - Which is just flinging things
into obstacles, destroying them,
05:38 - and ultimately destroying the
things that they're protecting,
05:41 - the aliens, the pigs that
are in the base game.
05:46 - So here's a shot of what the different
sprite sheets we're going to be using
05:49 - are.
05:50 - There's a really great sprite sheet
that I got off of Open Game Art.
05:53 - Kenny is the artist.
05:54 - He makes a lot of great art.
05:56 - If you notice, it's very
similar looking to the art
05:58 - that we use in the Mario lecture.
06:01 - Actually, it's the same artist.
06:02 - So if you're ever looking for assets,
he's got a ton of awesome assets
06:06 - on open game art.
06:07 - So we have a set of aliens,
square and round shaped.
06:10 - I decided just arbitrarily we made
the round shaped aliens the birds.
06:14 - So we shoot those into
the structures that are
06:17 - protecting the square shaped aliens.
06:19 - The square shape aliens will
be the bad guys in this case.
06:23 - And then we have another sprite sheet
down here below on the left side.
06:26 - Which just, I used the tile here
just to make a ground element.
06:30 - The rest of these you could easily
include in the game if you wanted to,
06:33 - but we're only using the ground here.
06:36 - And then notice here, we
have this large sprite sheet
06:38 - which has a bunch of different
shapes and sizes of materials.
06:42 - The whole sprite sheet comes with metal
and explosive and glass sheets as well.
06:47 - But just for simplicity
we only use the wood here.
06:49 - But notice that we have
entirely whole pieces
06:53 - and then we have pieces
that are partially destroyed
06:55 - and then pieces that are hollow.
06:57 - You could easily model all of
these in your game and use them.
07:00 - But we only decided to use
just a couple of these,
07:04 - which was just the horizontal
and the vertical ones that
07:07 - are completely whole.
07:09 - These, unfortunately, don't have
quite the same systematic layout
07:14 - as the sprites that we used before.
07:16 - They're not laid out in
a grid evenly spaced.
07:18 - So in this case, in util
dot Lua, I ended up hard
07:22 - coding the different XY
width and height quads
07:26 - for each of these, which is what
you have to do in a situation
07:29 - where you're interacting
not with tiles per se,
07:31 - but with more organic shaped objects.
07:33 - So it can take a little
more time to end up
07:36 - constructing all of the
quads for your objects
07:39 - when you have a sprite sheet like this.
07:40 - But, fortunately, you
only have to do it once.
07:43 - Here's a few useful links before we get
started in talking about what Box2D is
07:46 - and how to use it, and basically
how it's called love dot
07:50 - physics, effectively, in love2D.
07:52 - The first two links are
documentation for love 2D,
07:56 - what the functions and objects
are that we'll be talking about.
07:58 - And a simple tutorial that
talks about how to make a ball
08:01 - bounce in love 2D using Box2D.
08:05 - The third is a great
resource that I used actually
08:07 - to learn most of what I
know about Box2D, especially
08:11 - in the context of this lecture.
08:13 - So it talks about a lot
of different concepts.
08:15 - It talks about all the things
that we'll be talking about.
08:17 - And then it goes into a
lot more detail about how
08:19 - you can go about constructing a lot of
really cool, crazy things like tanks
08:24 - and pulleys and a whole
bunch of different things
08:27 - that are worth looking into if you're
looking into potentially making
08:30 - a physics based game.
08:31 - Obviously we won't be going into
things of that complexity here.
08:35 - But you could easily do it with Box2D.
08:37 - It makes it very, very possible.
08:40 - So the very first thing
that we should talk
08:43 - about when we want to construct
a game, or simulation,
08:47 - or whatever we want to
do, with Box2D is we
08:50 - need some sort of system that will
actually perform the simulation for us.
08:55 - And the fundamental core of what a Box2D
app or game is, the core is the world
09:02 - object.
09:03 - So there is a world that you can
think of as sort of being your world,
09:06 - but what it effectively is is a machine
that simulates all of the pieces
09:12 - that you've told it interact
with each other in Box2D.
09:16 - So Box2D has a set of objects
called fixtures and bodies.
09:20 - Those perform the physical interactions.
09:22 - And it's up to the world
to update all of those
09:25 - and apply the relevant forces
and physics calculations
09:28 - that resolve collisions
and do all sorts of things.
09:32 - All of the things that
Box2D does for us, the world
09:35 - takes care of this for us.
09:36 - So we don't have to manually go
through and update every single object
09:40 - with its velocity that we've done
before and check for collisions.
09:43 - The world does this for
us, and resolves them
09:45 - based on how we tell it to resolve them.
09:48 - And the world also possesses,
like an actual world
09:51 - would, gravity on the x and y-axis.
09:53 - In this case, we have gravity
applied on the y-axis going down,
09:57 - so it's a positive value.
09:59 - We set it to 300 in this distro, but
you can set it to whatever you want.
10:03 - Setting a lower gravity
would have the effect
10:05 - of making it feel like we're
on the moon or something.
10:08 - Making it feel like we're
on a different planet.
10:10 - So that's what the world is.
10:11 - The world simulates everything.
10:12 - And we'll go through
just a few terms here
10:14 - before we look at some source code.
10:15 - But there's a few terms that we need
to understand before we can really
10:20 - understand what Box2D is doing.
10:22 - And this is the function that we
use to create a new world in love2D.
10:26 - Very simple, love dot
physics dot new world.
10:29 - And this love dot physics
is just a name space that
10:33 - encapsulates all of the Box2D functions
and objects that love2D has access to.
10:41 - So anything that you see in
love dot physics is effectively
10:44 - a wrapper for Box2D.
10:47 - And to clarify about Box2D, Box2D is
just a library that's written in C++
10:51 - that you can plug-in pretty
much anywhere you want to.
10:54 - Unity uses it and, actually,
most 2D game engines
10:58 - that I've ever seen including Live GDX,
for example, which is a very large Java
11:03 - 2D game framework uses Box2D.
11:05 - You can use it anywhere.
11:07 - In this case we're using
love2D's own wrapper for it.
11:11 - So the people that created
love 2D, they took Box2D
11:15 - and then they just put
a bunch of Lua functions
11:17 - around them, around all
the objects and functions
11:19 - to make it possible to
use it in the same style
11:22 - that we use the rest of the framework.
11:24 - This is how you create a new world.
11:26 - This is the first step in getting
your Box2D simulation working.
11:29 - So any questions so far as
to how we can get that going?
11:32 - OK.
11:34 - So beyond the world object, which is the
foundation, sort of sets up our stage,
11:39 - you can think of it as
our stage, we need bodies
11:42 - to actually interact with each other.
11:44 - So a body is just an abstract container.
11:47 - It basically holds a
position and a velocity.
11:52 - And you attach things to it
via what are called fixtures
11:56 - that allow you to give the body a
shape, and therefore a collision box,
12:00 - and therefore allow it to
interact with other things.
12:02 - But a body is essentially all the
disparate things in your scene interact
12:07 - with each other and move around.
12:09 - And so to create a new body we just
do love dot physics dot new body.
12:14 - We pass in the world, so
therefore when we do this,
12:17 - the world has a reference
to this body now.
12:19 - And every time we call
update on our world, which
12:22 - we'll see in the source
code, it will know, OK,
12:25 - I have a reference to this body,
perform all of the relevant checks
12:29 - on the collision for that body and
all the fixtures that it contains.
12:33 - Update its position, updates
velocity, and so forth.
12:38 - And not only a world, but
it also gets an x and a y,
12:41 - which will place it in the
world on instantiation.
12:45 - The last parameter here, type.
12:48 - There are three
fundamental types of bodies
12:51 - which we'll see in love 2D,
static, dynamic, and kinematic.
12:56 - And that basically influences how
it'll interact with the other objects,
12:59 - the other bodies, in our scene.
13:01 - So we have the world, which
encapsulates everything,
13:04 - all the bodies, all the fixtures.
13:06 - And then we have the bodies, which
are the entities in our game world
13:10 - that have position and
velocity, effectively.
13:14 - The last key ingredient
here that will allow
13:18 - us to create interactions between
the bodies that we have are fixtures.
13:23 - And fixtures, all a fixture
is, is this abstract object
13:28 - that will allow you to
attach a shape to a body.
13:31 - So bodies are shapeless by
default. They don't have a shape.
13:34 - They are just a container that has
position velocity, effectively.
13:39 - But they don't interact
with anything else.
13:42 - And they don't know how to
interact with anything else
13:44 - until you give them a fixture.
13:46 - And the fixture you will
give the body and a shape.
13:50 - So for example, if you
want the bird that we
13:52 - were looking at earlier, the alien, the
round alien, we create a body for it
13:56 - in our world, which
doesn't mean anything yet.
13:59 - But we say, I'm going to
attach a fixture to that alien.
14:03 - I'm going to give it a circle shape.
14:05 - And it'll then know whenever
it performs any calculations,
14:08 - that that alien should interact
with things as if it were round.
14:13 - And therefore trigger collisions
based on a circular hitbox,
14:16 - as opposed to a rectangular or
polygonal hitbox, as we'll see.
14:21 - Fixtures, in addition
to attaching shapes
14:24 - to bodies, which will,
as said here, influence
14:27 - how they collide with other bodies,
they have density, which we'll see.
14:32 - So that things with
higher density obviously
14:34 - will fall faster, or not fall faster,
but they will influence things
14:38 - as if they have more weight.
14:39 - They will push things farther
when they collide with them.
14:43 - They also have friction
and they have restitution.
14:46 - Restitution is bounciness.
14:48 - So if something, if we had our alien,
no restitution when it hits the ground
14:51 - it'll just fall flat.
14:53 - But if we give it a
higher restitution it
14:55 - will actually bounce
when it hits the ground.
14:58 - And therefore interact with the
world a little bit differently.
15:02 - So when we want to take a fixture
and apply a shape to a body,
15:08 - we have a few different
shapes that we can
15:09 - apply to it that are given
to us by default in love 2D.
15:12 - So circle shape, rectangle
shape, edge shape.
15:15 - These are just, effectively,
how we define how
15:18 - our bodies interact with other bodies.
15:20 - How, for example, if it's
something that's circular
15:24 - it should roll when it's
moving along the ground.
15:26 - Or when it hits something
the corner obviously of it
15:29 - won't hit something because it's
rounded, as opposed to something
15:32 - that has a square hit box, it'll affect
things in a slightly different way.
15:36 - And we can define arbitrarily shaped
hit boxes, thanks to the polygon shape.
15:40 - If we want something to be shaped
like a pentagon, for example,
15:45 - and have it roll around
and behave like such,
15:47 - we can just define a polygon
via a set of vertices.
15:51 - And then affix that
to a body and it will
15:54 - behave as if it were pentagon shaped.
15:57 - And this is how you would
instantiate just as we've
16:00 - seen with love dot physics dot new
world and love dot physics dot new body,
16:03 - love dot physics dot new fixture
takes in a body and a shape,
16:07 - and will apply that shape to the body.
16:10 - And the world after that will know
exactly how to collide with things.
16:14 - And so the last thing,
the last slide we'll
16:16 - look at here before we
start looking at source code
16:19 - is what the different body types are.
16:20 - So I alluded to having three different
body types before, static, dynamic,
16:25 - and kinematic.
16:26 - So a static body will exist in our world
but not actually be affected by gravity
16:32 - or the collision of anything else.
16:34 - Things can hit it and bounce off
of it and do their own thing,
16:36 - but the static body will never
be influenced by something else.
16:39 - It exists as some sort of permanent
structure, almost like the ground.
16:43 - You don't really affect the ground by
moving into it and bouncing into it,
16:46 - unless you do it with enough force.
16:49 - But in our Box2D world, a static body
cannot be influenced by anything else.
16:55 - A dynamic body is the opposite.
16:57 - It has the full simulation of Box2D.
17:03 - Gravity affects it, things collide
into it, it will bounce off of them.
17:06 - It'll do what you would
expect a normal body to do.
17:09 - If I throw a ball in this room and it
hits the wall, it's a dynamic body.
17:13 - The walls are the static
bodies in this case.
17:15 - And then a kinematic body
is a hybrid between the two.
17:19 - It's something that can move
and can rotate and do things,
17:24 - but it's not influenced by
other objects colliding with it.
17:28 - So, for example, if I have a platform
that's just spinning indefinitely,
17:32 - but it's not being affected by gravity
and it doesn't move when I hit it,
17:36 - that's a kinematic body.
17:38 - It's still moving and it's semi-static
and it influences other things,
17:42 - but it's not purely static.
17:43 - It does have a little bit of
behavior that it can grant it.
17:47 - So let's go ahead and
look at a few examples
17:49 - now and see how this
actually looks in code.
17:53 - So I'm going to go into an example,
if you're looking in the distro,
17:56 - there is an example called static.
17:58 - So we'll take a look here and see what
a static body looks like in our scene.
18:02 - And for all of these examples
leading up to Angry Birds,
18:04 - we're just going to render everything
with shapes for simplicity.
18:08 - But this, as anti-climactic as
it is, is a full Box2D world
18:14 - with just a single static body.
18:17 - And it's just this square
here, colored white.
18:19 - The static body doesn't
move, it doesn't do anything.
18:21 - Nothing can influence
how it moves or behaves.
18:25 - But it exists in our world
as a permanent fixture.
18:27 - And if we had dynamic bodies and
we threw a dynamic body at it,
18:30 - for example, the dynamic
body would bounce off,
18:32 - the static body would
stay there permanently.
18:34 - So let's go ahead and
take a look at what
18:36 - the source code looks like for that.
18:38 - So I'm here in main dot
Lua of our static file.
18:42 - And just as we've seen before,
we needed to find a world.
18:46 - So I have a world here on line 45.
18:49 - Love dot physics dot new
world, no x-able gravity,
18:52 - but we are going to have 300 units of
positive gravity on the y-axis, which
18:57 - is going from top to bottom.
19:01 - We need a body for our square that's
in our game world, our static square.
19:06 - So we're going to go ahead
and define a new body here.
19:08 - Love dot physics dot new
body takes in the world,
19:11 - recall, because that's how our world's
going to have a reference to that body,
19:14 - doesn't know about it unless we pass
it into here, our new body constructor.
19:18 - And then I'm just going to put it
right in the middle of the screen.
19:20 - So virtual width divided by 2
and virtual height divided by 2.
19:25 - The difference between
Box2D bodies and things
19:29 - that we've drawn before
or seen before is
19:31 - that everything is defined by its center
point, as opposed to its top left.
19:34 - So I'm able to say
virtual width divided by 2
19:37 - and virtual height divided by 2 here.
19:39 - But I don't actually need to say virtual
width divided by 2 minus whatever
19:42 - the half of that square is.
19:44 - By default, the center point
is the XY of that object.
19:50 - And this last string here in the
constructor for our new body, static,
19:55 - tells the constructor that this is
going to be a static body specifically,
19:58 - not a dynamic body and
not a kinematic body.
20:02 - So we have a body and it's static,
but it doesn't have a shape,
20:05 - it doesn't really know how to interact
with anything else in our world.
20:08 - So we're going to give it a--
20:10 - we're going to create a new shape first.
20:12 - So love gives us a few functions
in the form of new X shape.
20:18 - We have new rectangle shape, new
circle shape, new edge shape,
20:20 - a few other ones.
20:22 - We're just going to create a new
rectangle of width and height of 10.
20:26 - So that's what the 10 and 10 are here.
20:28 - Then we're going to
create a new fixture.
20:31 - We're going to affix the box shape
to our body with this function.
20:37 - And then once we do that, all we have
to do is then render a polygon with fill
20:44 - and then we get the coordinates for
our-- or the vertices for our polygon
20:48 - by saying, body get world points.
20:52 - So that's a function
off of any Box2D body
20:55 - that will basically get where it is
in the world and all of its vertices.
21:01 - And then you just pass in the shape
that you want to get the points for.
21:04 - And that will end up just exploding
here into a set of vertices
21:08 - that fill up this love
dot graphics dot polygon.
21:10 - And the end result of
that is we get a square.
21:17 - And we specifically use
polygon instead of love
21:21 - dot graphics dot new rectangle
because that's what the get
21:24 - world points function explodes out to.
21:26 - It doesn't explode out to the number
of arguments that would satisfy
21:32 - love dot graphics dot rectangle.
21:35 - So not a very exciting example.
21:37 - But this is basically the foundation
of a full Box2D application.
21:43 - So any questions as to
how this works at all?
21:46 - AUDIENCE: Yeah.
21:47 - I'm wondering.
21:48 - How does it determine the
center of a abnormal shape?
21:52 - Not like a polygon, square,
rectangle, or circle.
21:54 - COLTON OGDEN: The center
of an abnormal shape.
21:56 - I'm not entirely sure.
21:57 - The circle is just--
22:00 - AUDIENCE: [INAUDIBLE]
22:01 - COLTON OGDEN: Yeah.
22:02 - I'm not entirely sure
about a polygon though.
22:04 - I haven't looked into
that into too much detail.
22:06 - I can explore that and see.
22:08 - That's something that I think Box2D is--
22:11 - the actual library implements
that and calculates that.
22:14 - Probably based upon
calculating the area of--
22:18 - and to repeat for the camera if
I didn't repeat already, it's
22:20 - how does Box2D calculate the center
point of something non-symmetrical,
22:25 - like a polygon?
22:27 - And best I can understand is that it
would do an area calculation off of it
22:33 - and figure out where all the
vertices tend towards, I guess.
22:38 - But, yeah, that's something
that's implemented in the library.
22:41 - I'm not entirely sure.
22:42 - I can look into it and see and
then I'll post in the Slack.
22:46 - AUDIENCE: It seems like
[INAUDIBLE] you did have that,
22:48 - it would be difficult to
place in a very precise spot.
22:52 - COLTON OGDEN: Yeah.
22:55 - If it were-- yeah.
22:56 - If we did have an odd shape to
get it placed in a exact spot.
23:00 - Yeah, I'm not entirely sure.
23:01 - I'd have to explore that a little bit.
23:04 - Interesting idea though.
23:07 - But, yeah, that's essentially how
we get a Box2D world up and running.
23:13 - We have a static body.
23:14 - It's not terribly interesting.
23:16 - But with one change--
23:19 - so I have a separate example called
dynamic in the source code distro.
23:23 - But all we need to do to
really see the difference
23:26 - between a static and dynamic body is on
line 48, just change static to dynamic,
23:32 - save it, and then rerun it.
23:35 - And then we'll immediately see
that it's affected by gravity
23:38 - and it moves downwards as we've
told the world that our gravity is
23:41 - set to positive 300.
23:43 - And so that behaves how
we would expect it to.
23:47 - Now, there's nothing else in the scene
so it's not particularly interesting.
23:50 - So I've created a another
example called ground.
23:55 - So let's go ahead and look at that.
24:02 - So if we want more interesting behavior,
what do we need to do in a nutshell?
24:09 - AUDIENCE: Have more
shapes and make a ground.
24:11 - COLTON OGDEN: Some more
shapes and make a ground.
24:13 - Exactly.
24:14 - That's a simple way we
can start to get instantly
24:17 - a sense of how powerful Box2D is.
24:19 - Just introduce more shapes that interact
with each other in different ways.
24:22 - So ground is an example that just
introduces a ground into our scene,
24:28 - so that we can see the box fall down and
actually collide with something else.
24:33 - And Love2D makes this nice and easy.
24:36 - Excuse me.
24:37 - They have a actual edge
shape that will allow us
24:40 - to basically form where the ground is.
24:44 - Anything that collides with
this-- it's effectively a line.
24:48 - But no matter how fast
anything moves in are scene,
24:52 - the body will not move past that line.
24:56 - So it's a nice, easy way of
getting a ground in our scene
25:00 - without having to implement a polygon
that maybe has two vertices going
25:03 - left to right on the screen.
25:05 - So that's what we do here.
25:06 - We have a ground body, which
is a static body, recall.
25:11 - Because the ground shouldn't move.
25:14 - We're going to change the
box into a dynamic body,
25:18 - but the ground shouldn't move.
25:19 - The ground should be
unaffected by anything.
25:21 - It's going to be static in our scene.
25:23 - And it's going to have an edge shape.
25:25 - So notice here, we take 0, 0 as the XY.
25:28 - And then a virtual width is zero.
25:31 - So with shapes, when
we define them here,
25:35 - it's not going to draw the shape
at 0, 0, at virtual width in 0.
25:39 - This is relative to wherever
the body is located.
25:42 - So wherever our body
is, this shape will be
25:45 - drawn with these coordinates, this
X and Y and this width and height,
25:49 - relative to that.
25:50 - And specifically, relative to the center
point of wherever we place a body.
25:56 - So if this ground is set to 0,
0 at virtual width and zero,
26:01 - where do we need to place
the actual body for it
26:03 - to render the ground appropriately?
26:08 - AUDIENCE: The middle bottom.
26:09 - COLTON OGDEN: Yeah, so we place
it towards the middle bottom.
26:12 - So we actually end up placing the body
itself here at virtual height minus 30.
26:18 - And when we affix this edge
shape to the body, we'll end up,
26:21 - even though it says 0,
0 virtual width zero,
26:24 - it's relative to wherever
the body's XY are.
26:27 - So it's actually going to be
0 virtual height minus 30,
26:31 - virtual width zero will
be where that edge exists.
26:35 - And then lastly, just
as we did with our box,
26:37 - we need a ground fixture so
that the ground body knows how
26:41 - it should interact with other things.
26:43 - So we're going to affix the edge
shape, which is just a line,
26:47 - to our ground body.
26:49 - And then here we do
love dot graphics-- just
26:53 - as we did with the love dot
graphics dot polygon for our box,
26:58 - we're going to do love dot graphics
dot line for our ground body.
27:00 - And we're going to do the exact
same thing, get world points
27:03 - and get points passing
the edge shape here.
27:06 - And I'm also setting
a line width of 2 just
27:09 - so we can see it a little bit better.
27:11 - And I'm going to color it red.
27:13 - Again, I colored the box up here green.
27:17 - So go ahead take a look
at what this looks like.
27:20 - So I'm going to go into ground.
27:27 - And so notice-- and I also added
a little bit of restitution
27:30 - to the-- as I said before, restitution
is a quality that a fixture can
27:33 - have which gives it bounciness.
27:35 - So rather than just falling
flat down onto the ground,
27:38 - it bounces a little bit as well.
27:39 - And we can see the interaction,
so I'll play it one more time.
27:42 - It starts in the middle.
27:43 - And then as soon as it
hits the ground body
27:46 - that we created before, the edge
shape, it bounces a couple of times.
27:49 - But it shows that the box is
dynamic, but the ground is static.
27:54 - Nothing influences the
position of the ground.
27:57 - It gets hard set and will
stay there permanently.
28:01 - So that shows a nice,
easy simple demonstration
28:05 - of an interaction between a
static and a dynamic body.
28:09 - I'm going to go ahead and
pull up another example here.
28:13 - So kinematic, recall, what was
the difference between a kinematic
28:18 - and a static or dynamic body?
28:21 - AUDIENCE: Kinematic can move
but not influence other shapes.
28:23 - COLTON OGDEN: Correct.
28:24 - So a kinematic body can move.
28:26 - You can ascribe it positional velocity
or angular velocity, it's rotation.
28:31 - But when something collides with it,
it's not going to be influenced by it.
28:35 - It's going to influence the
body that it collides with.
28:38 - It's going to affect it
in some way, but nothing
28:40 - colliding with the
kinematic body is going
28:42 - to have an effect on its
position or its velocity.
28:45 - It's something that exists
and does something programmed
28:48 - and will just do that
indefinitely, but it
28:50 - will interact with other dynamic
bodies as we have programmed.
28:55 - And it will not interact with
other kinematic bodies either.
28:57 - They will almost pretend that
each other doesn't exist.
29:00 - If you overlap a static and a kinematic
body or kinematic and a kinematic body,
29:03 - they render on top of each
other, but they don't actually
29:06 - influence each other's
position or anything like that.
29:09 - So I'm going to go ahead and
run the kinematic example.
29:19 - So here we have a few things going on.
29:23 - We have the box body that we
had before, the dynamic box that
29:27 - falls from the middle of the screen.
29:29 - We have the ground on the
very bottom to catch it.
29:31 - But we have three kinematic
boxes in the very center that
29:35 - are spinning that
influence the green box
29:39 - when the green box collides with them.
29:41 - So as you can see, it
tosses it around and then
29:44 - the green body falls back to the bottom.
29:46 - And in this example I've
taken away its restitution.
29:49 - So as soon as it hits the
ground, it just falls flat.
29:53 - Just like that.
29:54 - And so, as you can see, these
blue bodies, they're moving.
29:57 - They have angular velocity indefinitely.
30:00 - Specifically 360 degrees per second.
30:04 - And they will stay in that exact
position and rotate in that exact way
30:09 - forever.
30:10 - But as soon as they interact
with a dynamic body,
30:13 - they actually cause a collision
with that dynamic body.
30:16 - And the collision resolves
and this green body
30:19 - gets tossed around because it's dynamic.
30:21 - It will basically do whatever it
can to interact with the game world
30:27 - as long as it's interacting
with other bodies
30:30 - and resolving its collision that way.
30:34 - And so that's the key example between
what the three different bodies are
30:39 - fundamentally.
30:40 - And with these three body types you
can construct pretty much any scene
30:45 - that you want to.
30:45 - And obviously the bodies and the
fixtures can get insanely complex.
30:50 - I mean, we can look back
here at this first example.
30:55 - These structures are a composition of
many different types of dynamic bodies
31:05 - that have been given anchors and
joints and all sorts of other things
31:11 - to make them look as if
they're big constructions.
31:15 - But at the end, they're all
just a bunch of little bodies
31:18 - that are welded together,
fixtures that are welded together.
31:23 - And these fundamental building blocks
are how you construct scenes like this.
31:27 - Put a bunch of these blocks together,
weld them together with joints,
31:32 - in this case.
31:33 - We won't cover joints in
the context of this lecture.
31:35 - But if you're wondering how
all of these individual things
31:39 - can be collideable while still
constructing these massive scenes
31:44 - and having physics
applied to them, they're
31:46 - just jointed together using weld joints
or other types of joints, pulley joints
31:51 - depending on what they are.
31:52 - In this case, there is two circle
shapes here, circle fixtures,
31:58 - that are the wheels
on this cart and then
32:01 - they're welded to the
flat constructions here.
32:06 - Allowing those to be dynamic allows
the wheels to roll, and therefore
32:09 - carry the other load with it.
32:12 - Same with this bridge.
32:14 - I forget the exact name of the joint,
but it's a chain of fixtures together
32:18 - that are welded by a
specific kind of joint.
32:20 - And by putting them
together in this way,
32:23 - you get a bridge and all sorts of
things that you could think of,
32:27 - including tanks, which
is in the notes here.
32:33 - This third link, one
of them talks about how
32:36 - to implement a tank
by having treads going
32:37 - around circles and then a massive body.
32:40 - You could do anything with
Box2D, it's an awesome library.
32:45 - In the context of Angry
Birds, really we just
32:47 - scratched the surface for
what is possible here.
32:52 - So I'm going to demo now.
32:54 - Actually, I enjoyed, I think,
this demo, this bit of code,
32:59 - more than I enjoyed the
Angry Birds implementation.
33:03 - And it's a program that
I wrote called Ball Pit.
33:06 - Oh, by the way, before I get into that.
33:08 - So I'll leave that as a
little teaser, I guess.
33:11 - Looking at kinematic, really quickly.
33:15 - We're going to look and
see that I've created
33:18 - a table for the kinematic
bodies, a table for the fixtures,
33:23 - and then one shape.
33:24 - Because you only need
one shape actually,
33:26 - and you can apply one
shape to as many bodies
33:28 - as you want to as long as
they all have the same shape.
33:32 - I just create three
kinematic bodies here.
33:35 - So spacing them out relative to
the center with this math here.
33:39 - They get the string kinematic.
33:41 - And that's really the key difference.
33:42 - And then before finishing,
I make sure that I
33:45 - set them to have an angular velocity.
33:47 - So this is how you spin something.
33:49 - If you want to set something
to spin indefinitely,
33:51 - just set an angular velocity.
33:52 - In this case, 360 times
degrees to radians.
33:56 - And that's just a formula written out as
a constant, which is just the number--
34:01 - I forget offhand what
exactly the formula is.
34:05 - But it's up here.
34:06 - It's degrees to radians
0.01745329, et cetera.
34:13 - But just like pi, it's
a number that you can
34:15 - use to multiply a number in degrees,
and you'll get a number in radians.
34:19 - And there's the reverse
up there as well.
34:22 - We have to do this because Box2D
expects, for any types of rotation,
34:26 - it expects it in radians.
34:28 - I prefer thinking in degrees.
34:30 - So I passed in 360 times
degrees to radians.
34:33 - And so we render down here, just
as we did with the box body.
34:37 - We render the kinematic bodies,
polygon fill, kinematic bodies at i
34:42 - get world points kinematic
shape get points.
34:45 - Nothing terribly different.
34:47 - The only real key difference is that
we've added kinematic as a string
34:50 - to the constructor for the body.
34:53 - And we've added some angular velocity.
34:55 - And recall, this will
make it spin indefinitely,
34:58 - but it will never be influenced--
its angular velocity will never
35:00 - be influenced, its position
will never be influenced
35:03 - by anything else in our scene.
35:06 - So now with that out of the way,
I'm going to pull up Ball Pit.
35:13 - And maybe I'm just a little
bit too excited about this.
35:15 - But I enjoyed this a lot.
35:18 - So what it is, is this is
like a bigger demonstration
35:22 - of putting all these pieces together.
35:24 - We have a bunch of circle shapes.
35:26 - They're all interacting with each other.
35:28 - They all have physics.
35:29 - And then I have a larger
shape here, this square,
35:33 - which has a higher density
than everything else.
35:35 - And by pressing Spacebar
I can just dive into--
35:38 - throw it into the ball pit,
and it'll cause an interaction
35:41 - with everything else.
35:42 - And a bug slash feature
that I discovered
35:46 - about this is that if you press
Spacebar over and over again,
35:51 - it never resets its velocity.
35:53 - So it just slams down into the ball pit.
35:55 - So it's just kind of fun, and
I think there might actually
35:58 - be possibly a game idea in here.
36:00 - But, I mean, well, what
are the pieces here?
36:02 - What's different about this?
36:07 - AUDIENCE: They're all dynamic shapes.
36:10 - COLTON OGDEN: Yeah.
36:11 - So they're all dynamic shapes.
36:13 - Except for the ground
at the very bottom.
36:15 - And also, hidden from view are
actually two more static shapes
36:21 - on the left and right.
36:22 - Because if we didn't have
those, all of the balls
36:25 - would fall to the side out of view.
36:28 - But yeah, we have the static
delimiters for our scene.
36:33 - But we have a bunch of dynamic
bodies, the balls are all dynamic.
36:38 - And then the square is also dynamic.
36:42 - And then, like I said before, the
only real difference between them
36:45 - is that obviously the
square is a rectangle.
36:47 - But it also just has a higher density.
36:49 - And so by giving it a higher density
it pushes everything else-- oh,
36:53 - what happened there?
36:53 - That was weird.
36:54 - It pushes-- I think it went to
sleep because we didn't do anything
36:57 - for a while.
36:57 - But it's able to fall
through everything else
37:01 - because it knows that it's heavier,
and that it should push and apply
37:05 - a larger force to everything
else that's around it.
37:09 - And so by using these fundamental
building blocks of what Box2D is,
37:14 - you can construct a lot of really cool
simulations and other fun programs
37:18 - and actually get interesting game ideas.
37:20 - I'm inclined to believe that Angry Birds
started out as somebody messing around
37:25 - with the Box2D, or
physics engine like this.
37:27 - And it was inspired by some other game
that I should look into a little bit.
37:31 - But the creators of that game,
presumably, found this physics engine
37:34 - and were like, oh, this is cool.
37:36 - I'm going to put a tower of blocks
here and just throw something at it.
37:39 - And then they realized, oh, we
can make a game out of this.
37:42 - And so I encourage you, if you're ever
curious to just experiment with things
37:46 - like that.
37:47 - We could probably turn this into a game.
37:49 - I don't know.
37:49 - I like this a lot.
37:50 - It's a good segue from the abstract,
for lack of a better word, examples
38:00 - that we used earlier, and
merges it more into the realm
38:05 - of how can we make
something fun with this?
38:09 - And so that's how we're going to
start moving into the distro today.
38:14 - So the main topic of today's lecture is
Box2D and how we use it to make a game.
38:21 - Another thing that we should
consider is mouse input.
38:23 - We haven't really used it yet.
38:25 - And I believe I've mentioned
it before, slightly offhand.
38:29 - But Love2D makes it super easy.
38:31 - It's just like we do
with keyboard input.
38:33 - We just have a couple of callbacks
that are in main dot Lua,
38:36 - mouse pressed and mouse released.
38:38 - The difference between these
and key pressed and key
38:41 - released is that they also get
an X and a Y. Because usually,
38:45 - when you click the mouse
or release the mouse,
38:47 - you want to know where it
happened because that's
38:49 - obviously pertinent to what you're
doing when you're using a mouse.
38:53 - So these are fired by Love2D every time
you click or release a mouse button.
38:58 - And they get the X the
Y and the key, and you
39:01 - can do whatever you want with those.
39:03 - And just as we've done
in prior lectures so
39:05 - that we can use mouse input in
other modules besides main dot Lua,
39:10 - there's a function called love
dot mouse dot key pressed and key
39:13 - released that I implemented
in main dot Lua.
39:15 - You can check those out.
39:16 - They're very similar to how we did the
input tables for the keyboard before.
39:20 - But they allow us to use
this functionality inside
39:24 - of other functions, other
modules, besides main dot Lua.
39:30 - So let's go ahead and start looking at--
39:35 - this is where we're going to start
looking at the distro for Angry Birds
39:42 - and how we can take all these pieces
and form them into an actual game.
39:46 - So the first thing we'll do, we'll
take a look at just a couple of things
39:49 - and then we'll take a
short break and then we'll
39:51 - get more into the meat of it.
39:53 - But let me go ahead and
clear out all of these.
39:58 - And then we're going to pull up--
so the distro is in Angry 50.
40:02 - And so main dot Lua is here.
40:06 - So not a whole lot is different in here.
40:08 - So we have two states in our game.
40:11 - So we had a start and a play
state, as we saw before.
40:14 - The start state is
like we've done before.
40:16 - The only difference is in this
start state, well, for one,
40:20 - it's running a Box2D simulation.
40:22 - And two, we're actually
using mouse input.
40:25 - So actually, let's
look at main so you can
40:27 - see where I've added this,
which is different than before.
40:31 - So we have love dot key
pressed, as we've seen before.
40:35 - But we also have mouse
pressed and mouse released.
40:38 - And then mouse was pressed
and mouse was released.
40:40 - So those are the main differences in
main dot Lua this time, as opposed
40:44 - to last prior lectures, which
we only had keyboard input.
40:49 - And as you can see here, we have input
tables for keys pressed and released
40:53 - on the mouse.
40:54 - And so we initialized those
to empty on every update frame
40:57 - just like we've done with the keyboard.
41:00 - And then the input tables get
updated in the callback functions
41:05 - as we've done before.
41:07 - And so that's basically all that's
different about main dot Lua this time.
41:10 - And that's how we've tied together the
new mouse functions that we've just
41:15 - looked at into our game.
41:19 - The states that exist in our game
are play state and start state.
41:24 - So very simple.
41:25 - Very similar to last week
where we looked at Zelda,
41:27 - we only basically had a
start state and a play state.
41:31 - The start state, we can see
here, just to tie together
41:37 - the last bit of our usage of the mouse.
41:41 - Love dot mouse dot was pressed 1.
41:43 - Does anybody know what this 1 is?
41:46 - AUDIENCE: Is that left click?
41:48 - COLTON OGDEN: It is left click.
41:49 - So Love2D assigns integer values
to all of your mouse buttons.
41:53 - And 1 is traditionally the
default value for left click.
41:58 - Some frameworks will use 0.
42:00 - But Lua, 1 index so start
with 1 instead of 0.
42:06 - The thing about the start state here
that's kind of cool and interesting.
42:10 - So I'm going to go ahead
and play it again, the game.
42:18 - So we start off and right off the
gate, just to make things interesting
42:21 - rather than just have a
static screen that says
42:23 - Anger 50 click to start, we're
actually running a Love2D,
42:28 - a Box2D simulation here.
42:30 - It's a world with a bunch of squares.
42:33 - And so what kind of
bodies are all of these?
42:37 - AUDIENCE: [INAUDIBLE].
42:38 - COLTON OGDEN: They're
all dynamic bodies.
42:40 - And we've encapsulated them all, just as
we did before in the ball pit example,
42:44 - with some invisible static bodies on the
left, right, and bottom of the screen.
42:47 - Because if we didn't
have those static bodies
42:49 - they would just fall all the way down.
42:52 - And the nice thing is we don't
actually have to render anything.
42:56 - So if you want maybe an invisible
barrier for something in your game,
43:01 - or you want to encapsulate
something, something physical,
43:04 - you don't have to render anything.
43:05 - You can just have arbitrarily
shaped and positioned static bodies.
43:10 - And that will act as a container.
43:11 - So that's all we're doing there.
43:13 - We have a container set for all
of our little square alien guys.
43:17 - And by creating, I think, a hundred
of them and just letting them drop,
43:22 - we have this interesting
visual start to our game
43:27 - with very, very minimal effort.
43:29 - So we can take a look at this.
43:31 - So in our start state init, as
I said before, we have a world.
43:36 - We obviously need a member of new world.
43:38 - Anytime we do any Box2D
stuff you have to start
43:40 - by having a love dot
physics dot new world,
43:43 - else you won't be able
to run any simulations.
43:46 - Going to create a ground, walls,
and then a bunch of aliens.
43:51 - So this here, we can see that we have a
table that we're inserting aliens into.
43:57 - But we have a class called alien.
44:00 - So anybody want to ballpark
what an alien class ultimately
44:04 - encapsulates or ultimately is?
44:10 - AUDIENCE: Probably the way
it looks, like the skin.
44:15 - COLTON OGDEN: It is, yeah,
that's definitely a part of it.
44:18 - So the way it looks, or it's skin.
44:19 - So it does have a reference to that.
44:23 - And then more functionally, it also
possesses a body and a fixture.
44:31 - So rather than having a
bunch of bodies and fixtures
44:35 - that are separated out
and maybe just in tables
44:38 - at the surface level of whatever,
our level, just wrap them in a class.
44:44 - And then we just can
maintain a reference
44:46 - to each individual alien's
body and fixture that way.
44:50 - So it's a little bit more encapsulated.
44:53 - It's a little bit more object oriented,
little bit cleaner in my opinion.
44:57 - The alien class can take
square or round as its--
45:03 - well, it can take anything
you want to as its type.
45:05 - So this will ultimately decide how
it's rendered and what shape it gets.
45:09 - But if it's square, which is
the default, so if you just
45:13 - create an alien with
no type, it will get
45:18 - a love dot physics dot rectangle shape.
45:21 - So as we saw before, that's just a box.
45:23 - And then if not, we just
default to circle shape.
45:26 - But you could program it to
take in whatever shape you want,
45:29 - and then just give it that shape.
45:30 - And you don't really
have to do much in terms
45:33 - of coding how it interacts with anything
else in terms of collision, at least.
45:36 - Because, thankfully, Box2D
will know, OK, it's a circle.
45:40 - It should spin around and interact
with things like a circle.
45:43 - Or it's a rectangle so it should
interact with things like it's a box.
45:47 - Just nice and convenient.
45:48 - And then we'll just
create a fixture here.
45:52 - This set user data
function here is important
45:55 - because we'll see in the context of
how we actually resolve collisions
46:01 - in a customized way,
we'll need user data
46:05 - to be able to differentiate
what gets collided in our world.
46:08 - But at the moment you can just know that
this basically allows us to pass in--
46:14 - to set arbitrary data onto a fixture.
46:17 - So we can say, fixture set user
data alien, the string alien.
46:22 - And what that means is that fixture has
some customized metadata about it that
46:28 - says, this is an alien.
46:30 - It's whatever we want to do with it.
46:31 - We could give this a table as well.
46:33 - We could just say, the
user data is a table
46:35 - and then has a bunch of information
that we can then use at collision time
46:40 - to perform different work on it.
46:42 - But this set user data
function is how we
46:44 - are able to resolve collisions between
obstacles and aliens differently than,
46:48 - say players and aliens, or
even the alien and the ground.
46:53 - Because when we do any Box2D
collision, right, the world's
46:57 - taking care of the collisions for us.
46:59 - How do we tell the world, OK, when I
hit the ground I want to play a sound,
47:04 - but not do anything.
47:05 - If I hit this box at this
velocity, I want it to destroy it.
47:10 - If I hit the alien, I want
the alien to disappear
47:12 - and I want to show a victory label.
47:16 - How do we do all these different things?
47:18 - We do that with what are
called collision callbacks
47:21 - in the context of Box2D.
47:23 - And we'll see how that works.
47:24 - But suffice to say, user data will
be very important coming forward.
47:30 - And then this launched false,
actually we don't end up
47:33 - using this so this is irrelevant.
47:34 - But it has a render function here,
which just takes in the bodies X and Y
47:43 - and will draw it at
the angle that it's at.
47:46 - So that's an important thing.
47:47 - When we before, what we were doing
is drawing things via shapes.
47:52 - So love dot graphics dot polygon,
love dot graphics dot circle,
47:55 - love dot graphics dot line.
47:57 - But if we want to draw
a sprite instead, we
48:03 - need to draw it at the right
position, first of all, right?
48:06 - And then things also rotate in Box2D.
48:09 - So we need to draw it
at the right angle.
48:13 - So what we do is we can actually
query the body for its X.
48:17 - We can query the body for its Y. And we
can also query the body for its angle.
48:21 - And then we can draw
the texture and the quad
48:24 - that we want to using
those XY and the angle,
48:28 - and that will have the effect of
drawing a sprite in the world that
48:33 - mirrors what's going on in Box2D,
rather than just a simple shape.
48:37 - So that's as simple as it is for
drawing a sprite instead of a shape.
48:42 - You can see here, the 17.5 17.5.
48:46 - Does anybody know what that's for?
48:48 - AUDIENCE: Not sure.
48:49 - COLTON OGDEN: So 17.5 17.5 at
the end is half of the width
48:52 - and half of the height of the aliens.
48:56 - So aliens are 35 by 35 in this game.
48:58 - We pass those in.
49:00 - This is the center of origin.
49:02 - So when we rotate something
by center of origin,
49:05 - it basically describes where the
rotation is going to take place.
49:11 - So if it's rotated about the top
left and we rotate something,
49:15 - it's going to have the effect
of the sprite going around
49:17 - in a circle in sort of an odd way.
49:20 - If we rotate the sprite based on the
center of origin of the actual sprite
49:23 - itself, that will have the effect of
rotating the sprite on its center.
49:28 - So you can set that origin
wherever you want to
49:31 - and it'll perform a 360 degree
rotation about that point.
49:35 - And we're setting that point to half--
49:37 - to basically the middle of
where we're drawing the sprite.
49:40 - So that will have the effect of
when we give it this angle here,
49:42 - self dot body to get angle, the
rotation will take place in place.
49:46 - It won't take place-- it won't be some
sort of weird about the top left corner
49:50 - rotation, which is not what we want.
49:52 - So when you see center of
origin being modified like that,
49:55 - you can assume that it's
because we have an offset
49:58 - and we're trying to find the
center of where we're drawing
50:01 - and rotate about that to
do an in place rotation.
50:04 - But not necessarily, you
could also draw something.
50:08 - You could also, maybe you want something
some sort of magical ball of energy
50:12 - to rotate about a rod or something.
50:15 - And so you want it to rotate
around a different center,
50:17 - or whatever you want arbitrarily.
50:20 - But typically, at least
mostly that I've seen,
50:23 - this is useful for making sure that
your rotations, your in place rotations,
50:27 - are accurately rendered.
50:29 - So any questions about
how the alien class works?
50:36 - All right.
50:38 - So that's the alien class.
50:40 - That's the basically the fundamental
building block of our game.
50:44 - The other part is the obstacle.
50:48 - We have obstacles and we have aliens.
50:50 - The obstacles and aliens
are actually very similar.
50:53 - So what's the difference between--
50:55 - I mean, ultimately,
how are they similar?
51:03 - AUDIENCE: They're both
dynamic [INAUDIBLE]..
51:05 - COLTON OGDEN: They're
both dynamic bodies, yeah.
51:07 - Really, the only thing that's
different about a obstacle and an alien
51:11 - is what we do with them in our
scene and how they're rendered.
51:14 - But they function very similarly.
51:16 - They're just dynamic bodies
that we give a shape to
51:18 - and we render them with that shape.
51:24 - In this case, the obstacle
constructor, we've
51:28 - decided to design it such that it could
take a shape horizontal or vertical,
51:33 - which is similar to the type that
we saw before with the alien,
51:36 - where it could be square or circular.
51:38 - In this case, if we look back
at our sprite sheet back here,
51:45 - we can see there's a
ton of different shapes.
51:48 - But the only two shapes that we're going
to use in the context of this game,
51:51 - just for this demonstration, are the
horizontal, clean wooden shape here
51:55 - and the vertical one that's right here.
51:59 - And so in order to find
those out I had to open up
52:02 - basically this sprite
in my sprite editor,
52:05 - figure out where the XY width
and height were, and then create
52:08 - a quad manually off of that.
52:10 - And then I edited the util
dot Lua-- or not util dot Lua,
52:14 - the dependencies dot Lua here.
52:17 - Normally we just create gframes
and then we use generate quads.
52:21 - And you can do that like with the
aliens and with the tiles, the tiles
52:25 - being this sprite sheet that--
52:28 - this one right here.
52:29 - These are 35 by 35.
52:31 - These are 35 by 35.
52:32 - These are not 35 by 35.
52:34 - These are a bunch of
different shapes and sizes.
52:38 - So I went through and gframes wood
is for manually created quads here.
52:47 - And then there's four because I also
added the semi broken shapes as well.
52:53 - But we don't actually use those.
52:55 - But you could decide to turn
these into these on collision,
53:03 - perhaps maybe if the velocity isn't
strong enough to break it necessarily,
53:06 - but you want to have some sort of
feedback that you collided with it.
53:09 - You can just set maybe the frame to
1 or 2 on collision for that object,
53:15 - instead of 2 and render
it appropriately.
53:18 - But if you're dealing
with a sprite sheet
53:21 - and that sprite sheet has odd
distribution of its sprites,
53:26 - sometimes you have to figure out
where the offsets are manually
53:29 - and do it that way.
53:31 - The ideal is that you don't have to and
that you can do it programmatically.
53:34 - But it really depends on the
game, what your domain is
53:38 - and what objects you're
interacting with in the scene.
53:42 - Any questions on the
why or how as to that?
53:47 - Cool.
53:48 - So back to the obstacle.
53:51 - So they're horizontal or
vertical, and what that does
53:54 - is it sets the frame to 2 or 4.
53:55 - And the 2 or 4 being in gframes that
would, the 4 quads that I had a hand,
54:02 - figure out the coordinates for.
54:06 - And really, it's not a whole
lot different at that point.
54:09 - If it's a horizontal
or a vertical shape,
54:15 - then we need to set its width
and height appropriately.
54:17 - Because it's going to have a different
width and a different height.
54:19 - If it's vertical, obviously the
height is higher than the width.
54:22 - And if it's horizontal,
the opposite is true.
54:25 - But they're both a rectangle shape.
54:27 - So you can pass in the
width and the height
54:29 - after you calculate that,
and give it the right shape,
54:32 - and then ascribe it a fixture.
54:33 - And then set user data in this
case, we set user data to obstacle.
54:37 - So now that obstacle,
the fixture specifically,
54:40 - knows that it's an obstacle, as
opposed to being an alien, as opposed
54:45 - to being anything else, as
opposed to being the ground.
54:47 - And so when we explore in a few minutes
what the custom collision, world
54:54 - collision callbacks,
that we can actually
54:56 - define all this interesting
collision behavior for,
54:58 - this user data is going to be relevant.
55:01 - And then we render it just like
we render the alien as before.
55:08 - So any questions on obstacles
and aliens, how they differ,
55:10 - how they're the same?
55:14 - Cool.
55:15 - All right.
55:16 - Let's take a five minute now.
55:18 - When we get back, we're going to
actually look at the play state.
55:21 - We're going to look
at what makes a level.
55:23 - And we're going to actually look
at how we can customize the world
55:27 - to resolve collisions in ways that
are relevant to our game behavior.
55:32 - As in, how to make things break
when we collide with them,
55:36 - how to make the victory screen pop
up when we've destroyed the bird,
55:40 - so on and so forth.
55:43 - All right.
55:44 - Welcome back.
55:45 - So before we took a
break, we were talking
55:47 - about the aliens and
obstacles that are in our game
55:51 - world that interact with each other.
55:52 - They are the backbone of what makes
our games slash Angry Birds work.
55:58 - You throw aliens into the
obstacles, obstacles break,
56:02 - the bad pigs slash aliens die
and then you score points.
56:07 - But we actually have to
model these interactions
56:10 - and we have to tell our
game, our world, what
56:13 - to do when these collisions happen
in order for things more interesting
56:16 - than just things bouncing
off each other to work.
56:19 - That's the default behavior.
56:20 - Box2D's goal, by default,
is when two things overlap,
56:26 - assuming that they're dynamic or
at least one of them is dynamic,
56:29 - is to push the dynamic bodies
away until they no longer overlap
56:34 - via either position or rotation.
56:38 - But that's not the gist
or the goal of our game.
56:42 - Because what we want to have
happen is different things happen
56:45 - and certain things to disappear and
to break and all sorts of other things
56:49 - to happen when different
kinds of objects
56:52 - interact with different kinds
of objects at differing speeds.
56:56 - So in order to do this, we need
to define collision callbacks
57:00 - for our world.
57:01 - So a callback, recall,
is a function that gets
57:04 - called back when something happens.
57:06 - It's just something that will get
called at a specific time or later on.
57:12 - And we can define these
callbacks for our world
57:16 - such that when two things
collide with each other,
57:19 - it will execute this call back and
then perform the corresponding logic
57:23 - that we've defined therein.
57:25 - And with every collision in Box2D, there
are four callbacks that take place.
57:30 - There's begin contact, so when
two things begin to overlap
57:35 - or begin to contact one another.
57:37 - End contact, so once that
ends, once two objects
57:40 - are pushed away from each other.
57:42 - Presolved, which happens right
before the collision actually gets
57:46 - solved in Box2D, meaning that the
things get pushed away from each other.
57:50 - And then postsolved, meaning right after
they get pushed away from each other.
57:54 - And the postsolved in
particular is interesting
57:58 - because it gets the information about
how the collision needed to resolve.
58:02 - So how much velocity or rotation needed
to happen within that interaction.
58:08 - And we will not be using end
contact, presolve, or postsolve.
58:12 - We will only be using begin
contact because, really, that's
58:15 - all we need in order to model the
behavior that we're looking for.
58:18 - Because anything that
happens in our game
58:20 - we can just figure it out as soon
as two objects touch each other.
58:25 - And these are things, if you're
interested in a tutorial that
58:28 - goes over these in perhaps
a little bit more detail,
58:31 - there's a link here in the slides.
58:33 - But I'll show you how to actually
implement these callbacks yourself.
58:38 - You do this via a function
called world set callbacks,
58:42 - in this case, F1, F2, F3, F4.
58:45 - And recall, because Lua is a
dynamic language where functions
58:47 - are first class objects, you can
pass in functions as arguments
58:52 - to other functions.
58:53 - And that's what we're doing here.
58:54 - So this is assuming that
we have four functions
58:56 - we've defined called begin contact,
end contact. presolve, or postsolve.
59:00 - Their actual names don't matter at all.
59:03 - These are just the de
facto names for them.
59:05 - What matters is that you have the logic
there and you pass in function objects
59:09 - that perform something.
59:11 - And you can pass in all empty functions
and Box2D will still behave as normal.
59:15 - These are only for when you want more
complicated behavior out of your game
59:20 - than just things bouncing
off of each other
59:23 - and moving relative to one another.
59:26 - So does that make sense?
59:29 - So we'll see how this actually works.
59:32 - We're going to go ahead
and open up level dot Lua.
59:34 - So level dot Lua is a
container class that
59:37 - basically has our game
level in it, including
59:40 - the world and all the entities.
59:42 - And we update it and are
able to model, effectively,
59:47 - like a level from Angry Birds.
59:48 - That's really what it is.
59:50 - It has a world.
59:51 - So the level has its own world with 300
positive Y gravity, as we saw before.
59:55 - It has a table called destroyed bodies.
59:58 - And we'll see that in a second.
60:01 - And then here we have four functions.
60:02 - Starting on line 22, we have begin
contact, which is a long function.
60:06 - And then we have end contact,
presolve, and postsolve.
60:09 - Those are the four
callback functions that I
60:11 - alluded to just a few seconds ago.
60:14 - They take in slightly
different signatures.
60:16 - The first three take
A, B, and collision.
60:19 - And then the last one takes in A, B,
collision, and then a normal impulse
60:23 - and a tangent impulse, which are the
forces that it needed to apply in order
60:26 - to push apart the two objects.
60:29 - Like I said, we won't be
using these three functions.
60:31 - But there might be a situation where
you need to use those functions.
60:36 - Maybe you want end contact because,
in your game, two objects attached
60:40 - to one another, when they collide
maybe they're magnetic or something,
60:43 - and then once they pull apart
maybe you want a particle effect
60:46 - or something to show that
they've separated or something.
60:50 - And then presolve and postsolve.
60:52 - Presolve, offhand I can't
think of a use case,
60:54 - but postsolve could be useful
for, depending on your game,
60:59 - whether you need to just figure
out maybe the amount of force
61:03 - that they needed to separate.
61:04 - Maybe you multiply that by some amount
and cause some sort of dramatic effect.
61:11 - Those are ultimately dependent
on the domain of your game.
61:14 - The important function
that we'll be using today
61:16 - is the first one, begin contact.
61:18 - And notice, that we've
defined these four functions,
61:21 - even if these three are just empty.
61:23 - But we pass in, as I said
before, the set callbacks
61:27 - function takes in those four functions.
61:29 - And notice another interesting thing,
because of Lua's dynamic nature, line
61:33 - 11 you can see that we
have level init, which
61:35 - is the constructor for our level class.
61:37 - Within the constructor we
are defining more functions.
61:41 - You can define functions as
many layers deep as you want to.
61:45 - And you can even return
functions from functions, which
61:47 - are called higher order functions.
61:50 - Really do whatever you want to.
61:52 - In this case we're just defining
the collision callbacks here inside
61:55 - of our init.
61:56 - But you could put the
most anywhere you want to.
61:58 - You can have them outside of the class,
you can have them wherever you want.
62:01 - You can have them be global
functions in your main dot Lua,
62:03 - which I don't know
how I feel about that.
62:05 - But you can do whatever you want
to as long as the functions exist
62:08 - and you can reference their
symbols, you can pass them
62:11 - into self dot world set callbacks.
62:14 - And now, whenever a collision
happens in the world period,
62:19 - it's going to call all
four of those functions
62:22 - at each stage of each collision.
62:26 - So you could see that
potentially getting a little bit
62:29 - hairy if you were to scale high
enough with all of your logic.
62:33 - If you had a million lines
of code in each of these
62:36 - and its executing million
lines of code per collision,
62:38 - you could run into trouble.
62:39 - But, fortunately, we're not
going anywhere near that.
62:43 - The gist of begin contact, so it
takes in an A and a B and a collision.
62:49 - We don't end up using the collision
itself, we just use the A and the B
62:53 - because that's all we
need for our game world.
62:56 - The A and the B are what?
62:58 - Do we know what the A and the B are?
63:00 - AUDIENCE: Probably the
two objects [INAUDIBLE]..
63:02 - COLTON OGDEN: The two objects.
63:02 - Do you know whether it's
a body or a fixture?
63:08 - AUDIENCE: It would the fixture.
63:10 - COLTON OGDEN: It would be the fixture.
63:11 - The fixtures collide with
each other, not the bodies.
63:14 - So when you have a body, recall that the
fixture attaches the shape to a body.
63:18 - The body is just a position and velocity
container for a bunch of fixtures,
63:22 - the body is.
63:24 - Each individual fixture
collides with other things,
63:27 - other fixtures in your game world.
63:30 - And so, recall that
before we had fixture
63:33 - set user data because
that's what we ended up
63:36 - needing to have data on
when we do the collisions.
63:39 - We check to see via get
user data what something is
63:43 - or what metadata we've
given to that fixture.
63:46 - And then we can then separate
different classes of objects this way.
63:51 - We can say, oh, this object was an
alien, or this object was an obstacle,
63:55 - or this object was the ground.
63:56 - And then we can say, oh, did
we collide with an alien?
63:59 - Was the collision between
an alien and the ground?
64:01 - If it was, OK, let's play
a bounce sound effect.
64:04 - And if it was between an alien
and the other alien, the player
64:07 - and the other alien, and the
velocity was fast enough,
64:10 - OK, the alien should die.
64:11 - Right?
64:12 - We can do arbitrary things.
64:15 - And so the way that I've
programmed it here such that we
64:19 - can see what two things
interacted with each other,
64:21 - and this is a very
simple use of user data.
64:26 - All we we're doing in this code base
is just assigning strings to fixtures,
64:31 - but you could assign tables to
fixtures with arbitrary amounts of data
64:34 - and do all sorts of things.
64:36 - In this case, we're only using strings.
64:39 - So I create a table, an
empty table, and then I just
64:42 - assign at table, at that string, true.
64:47 - And then I can just query that table.
64:49 - Do I have a key player and a key alien?
64:52 - Do I have a key obstacle
and a key obstacle?
64:56 - This is how you can figure out
what your two objects were.
64:58 - Because A could be a player
and B can be an obstacle.
65:02 - A can be an obstacle and
B could be the player.
65:04 - So you have to take both
of that into consideration.
65:08 - So it allows us to do if types
obstacle and types player, so
65:12 - a collision between the player and an
obstacle, if it's fast enough, then we
65:20 - can destroy the obstacle.
65:22 - This is what we do here.
65:23 - So I take the absolute value
of the velocity on the X and Y.
65:29 - So I do vel X vel Y gets
the body's linear velocity.
65:33 - So linear velocity is just
where it's moving in the world.
65:37 - And it returns two values because
velocity has an X and Y component.
65:42 - And then we sum it here by taking
its absolute value of both parts
65:48 - and adding it together.
65:50 - So if it's moving fast on the
x-axis, but not fast on the y-axis,
65:54 - or if it's not moving fast on either,
or if it's moving fast on both,
65:57 - we have a sense, in general, what's
the average velocity of our object.
66:02 - If it's moving fast
on any of the axes, we
66:04 - can assume that that's sufficient
force to cause an object
66:08 - to get destroyed, right?
66:10 - So we do if the velocity is greater
than 20, just an arbitrary value
66:14 - that I came up with
that seemed appropriate,
66:16 - then we're going to do this.
66:19 - Table dot insert self dot destroyed
bodies, which we saw earlier.
66:24 - And then the obstacles body.
66:25 - Now, why are we inserting
that value here as
66:30 - opposed to, maybe just destroying
it inside this function?
66:38 - AUDIENCE: Destroying the fixture.
66:39 - COLTON OGDEN: Destroying the body.
66:41 - The fixture, yeah, in this case.
66:43 - AUDIENCE: I mean the fixture, sorry.
66:45 - Because you're still referencing
it later in the code.
66:47 - COLTON OGDEN: You're still
referencing later in the code.
66:49 - Box2D maintains a reference
to all of the bodies, all
66:52 - of the fixtures in your
world, regardless of
66:58 - whether you've deleted them or not.
67:00 - But if you delete them while
it's in the middle of a,
67:03 - like checking for collision,
it'll try to do another collision
67:06 - with that destroyed body and you'll
get a crash or a stack overflow error.
67:12 - I found I experienced both of those.
67:14 - You don't want to ever delete or destroy
anything while inside a collision
67:19 - callback for your world.
67:21 - It will cause horrible things to happen.
67:24 - So what we do is we maintain a
reference to everything that we're
67:26 - going to destroy by just inserting it.
67:29 - So if we do table dot insert the body of
whatever we want into destroyed bodies,
67:37 - we can then loop over that
after the world updates.
67:40 - And then just destroy them one by
one outside of the update function.
67:45 - And the reason that we are passing
in the body and not the fixture
67:49 - is when we destroy a body,
it destroys all the fixtures
67:55 - associated with that body as well.
67:57 - So we're just destroying the
top level container here.
67:59 - In this case, it doesn't matter too much
whether we destroy a fixture or a body
68:04 - because it's a one to one relationship.
68:09 - But if you had, let's say, a body
that has five fixtures on it.
68:14 - And if that entire thing
collides with something else
68:16 - and you want to destroy
that entire thing,
68:18 - you want to destroy the body,
not an individual fixture.
68:20 - Because when you destroy the body, it
destroys all the fixtures, not just
68:24 - the one fixture.
68:25 - So that's we're deleting the body,
adding the body to destroyed bodies,
68:29 - and then later performing
a delete off of that.
68:34 - The function is destroy here.
68:39 - So on line 157--
68:42 - well, 155 to 159, this
is where we actually
68:45 - iterate over everything
that we wanted to flag,
68:48 - or that we've flagged as
destroyed, and we destroy it.
68:51 - So if not body is destroyed, destroy it.
68:55 - And then once we destroy it, we're
going to go down here and end up
69:01 - actually removing the
obstacle and the alien class
69:05 - from our list of aliens and obstacles.
69:09 - Because that maintains a
reference to what we're drawing
69:12 - and we want to also delete that.
69:13 - So not only do we want to delete
the object from the world,
69:17 - we want to delete the
objects that we've created
69:19 - that are a wrapper for
the bodies and fixtures
69:23 - and also the drawing of our aliens so
it no longer gets drawn to the scene,
69:26 - basically.
69:30 - So yeah, don't ever delete a body
or a fixture inside your callbacks.
69:36 - Always flag them and
delete them afterwards.
69:39 - Basically, don't delete in the
middle of a world update function
69:43 - call, which we see here.
69:45 - Notice that this takes place,
152, were doing self world update.
69:49 - And then on 155 to 159, we've populated
destroyed bodies via the collision
69:55 - callback that we defined up above.
69:57 - So in here, this is where we
can actually destroy everything.
70:00 - This is outside of the update function,
here, the world update function.
70:04 - We don't need to worry about stack
overflow or a segfault, which
70:08 - we get by deleting something
while it's in the middle
70:13 - of processing its collisions.
70:16 - So unfortunate bug.
70:17 - If you ever find yourself running
into stack overflows or segfaults
70:21 - in your collision callbacks, make
sure you're not deleting anything.
70:25 - But we can see here, it's
very similar, the behavior
70:28 - we defined between obstacles and the
player, between obstacles and aliens,
70:32 - and between the player and alien.
70:34 - Ultimately, it's check to see
whether the average of its velocity
70:38 - is greater than a certain
number, in this case, 20.
70:41 - And if it is, flag it as destroyed.
70:44 - So if the player hits
the alien, destroy it.
70:46 - If a obstacle hits
the alien, destroy it.
70:48 - And it's similar to how
it works in Angry Birds.
70:51 - When you throw something at a structure
in Angry Birds and a piece of debris
70:57 - falls off of it and hits the
pig, usually kills the pig too.
71:00 - And if your bird hits the pig,
that usually kills the pig.
71:04 - But if you're not moving fast
enough or if a piece of debris
71:06 - isn't moving fast enough,
it'll just nudge the pig,
71:09 - it won't actually kill the pig.
71:11 - So that's why we're taking all
of this into consideration.
71:13 - We're not just doing a blind delete
off of the body's in our code,
71:18 - we're actually making sure, is
it also moving fast enough, i.e.
71:22 - does it have enough force?
71:24 - And if it does, then perform the code,
then perform the deletion or flag it
71:28 - as being deleted.
71:30 - And so once again, that's
why user data is important.
71:33 - Because that's how we're able to--
because notice in the callback
71:37 - we just get an A and a B. And those
are always going to be fixtures.
71:41 - Fixtures, in order for it to
know what kind of a fixture
71:44 - it is, whether it belongs
to a player or an alien,
71:48 - we need to give it some information.
71:50 - So the set user data flags the
fixtures as being of a specific type.
71:55 - And then we can fetch it
here with get user data
71:58 - and then actually perform
the relevant game logic.
72:02 - Any questions as to how this works?
72:05 - AUDIENCE: Are you checking for if
two obstacles knock into each other?
72:11 - COLTON OGDEN: Am I checking with two
obstacles collide with each other?
72:14 - I might not be.
72:15 - In that case-- you should.
72:18 - In that case, since we're not,
they'll just bump into each other.
72:21 - But, yeah, if we wanted
two wooden obstacles
72:24 - to destroy each other
if they hit fast enough,
72:27 - you would just do the same thing here.
72:29 - If types obstacle, I guess.
72:32 - But in this case, because
they're both the same key,
72:35 - you would have to do if types--
72:39 - let's see how we're doing it again.
72:40 - So types obstacles is true,
types obstacles is true.
72:45 - You would say if types obstacle and not
types alien, not types player, not--
72:50 - there's a cleaner way to do it.
72:52 - AUDIENCE: Like a series
of [INAUDIBLE] statements.
72:54 - COLTON OGDEN: Yeah.
72:54 - AUDIENCE: [INAUDIBLE] statements.
72:55 - COLTON OGDEN: Yeah.
72:56 - That's true.
72:57 - Yeah, there's a lot of ways.
72:59 - And if I were to re-engineer this,
I would also abstract out this code
73:02 - and make it a function.
73:03 - Because it's pretty much the same
code between all three of these.
73:07 - But just to illustrate
and just for simplicity
73:09 - because it's pretty
similar interactions,
73:12 - didn't really put too much
engineering forethought into it.
73:15 - Definitely if you expand upon
it, I would recommend doing that.
73:20 - But that's the gist of making our
world behave beyond just resolving
73:26 - collisions and pushing obstacles
away from each other, which
73:28 - is the default behavior.
73:31 - So we set the callbacks.
73:33 - We're good.
73:33 - Now things, when we interact with each
other, they'll behave differently,
73:36 - they'll trigger different behavior.
73:39 - We have this thing called a launch
marker, an alien launch marker.
73:42 - Anybody know what that might be?
73:47 - AUDIENCE: Is that the little
dots that show the trajectory?
73:50 - COLTON OGDEN: Yeah, so it's the
dots that show the trajectory.
73:53 - It's one, the alien being rendered
on the left side of the screen
73:56 - without any physics applied to
it, that's click and dragable.
74:00 - And it also renders a trajectory.
74:02 - And when you release the mouse,
it launches an actual Box2D alien
74:07 - traveling in the direction
that that trajectory foretells.
74:12 - If we look at alien launch marker here,
it basically maintains a reference to
74:19 - whether we're aiming or not.
74:20 - So it's got a couple of states.
74:21 - It's got a launch state
and an aiming state.
74:25 - An alien that we'll have a
reference to eventually, which
74:27 - will spawn and will give it an impulse.
74:30 - So an impulse is effectively setting
its velocity immediately to some value,
74:36 - as opposed to something over time.
74:38 - We can apply force to
an object, which would
74:40 - be like you driving your
car up against something
74:43 - and then gradually accelerating,
that's applying force.
74:46 - And we can also apply impulse
by going full speed with our car
74:49 - and hitting an object,
and that will have
74:52 - the effect of applying an
impulse at a certain velocity.
74:56 - When we drag our alien
and then we release it,
75:00 - we want to apply an impulse in the
opposite direction of where we're
75:03 - dragging based on a certain amount.
75:06 - I scaled it by 10, but you
can have it be arbitrary.
75:10 - And then the trajectory
models where it's going.
75:14 - And the trajectory is
calculated via these lines here.
75:20 - So from line 90 to 104.
75:22 - There is a formula
for, in that Box2D set
75:25 - of tutorials, that
actually shows you how
75:27 - to calculate an estimated trajectory
given a starting impulse and a starting
75:31 - position.
75:33 - Which is this formula here.
75:36 - It's semi-complicated.
75:38 - The article goes into
detail as to how it works,
75:40 - but it effectively
calculates 1/60 of a second,
75:45 - assuming that we're running our
simulation at 1/60 of a second,
75:48 - it will, over 90
iterations here, 1 to 90,
75:52 - calculate each individual
step of that simulation.
75:56 - And then I only render every 5 here.
75:58 - So if i is mod 5 s 0,
then I'll actually end up
76:03 - drawing a circle at
trajectory X, trajectory
76:05 - Y. Trajectory X and Y being here.
76:07 - Shifted X, shifted Y being
the starting location.
76:10 - And then we multiply i by 1/60
of a second, which will give us
76:15 - the scalar for this impulse here.
76:19 - And then with gravity we have
to do this i squared plus
76:23 - i times 1/2 times the gravity on
the y-axis times 1/60 squared.
76:31 - The article goes into a little bit
more detail as to how it works.
76:34 - But that's it converted
into source code.
76:38 - But it's effectively
a gravity simulation
76:41 - and a velocity simulation over time.
76:44 - And by rendering it based
on 90 iterations, which
76:47 - is one and a half seconds,
at 1/60 of a second
76:51 - we can forecast where
exactly we're going.
76:54 - And then when we apply this impulse, X
and Y, the ball will actually travel,
77:00 - the alien will actually travel in that
direction at that exact trajectory.
77:09 - That's the complicated
part of the launch marker.
77:12 - The other part is that it has a
couple of states, like I said before.
77:16 - So when we click and we're not
launched, it should go into aiming mode.
77:20 - And so if we're aiming then we're
going to set a rotation to--
77:25 - actually, rotation is not relevant
because this was before I ended up
77:31 - using the predictive trajectory method.
77:34 - The shift at X and Y though, those are
relevant because that's the starting
77:39 - location for your trajectory.
77:41 - That's wherever your mouse is.
77:43 - And we clamp it so that it
doesn't go past a certain limit
77:45 - on the left or the right, so
that it stays within a box area.
77:49 - But this will be whenever
you let go of the mouse, that
77:52 - will be where we spawn
the Box2D alien and apply
77:55 - an impulse in a negative direction
relative to where we move the mouse.
77:59 - So if we move the mouse
to the left and down,
78:01 - it's going to negate that
with an impulse going up
78:05 - and to the right, if that makes sense.
78:08 - And that's what's shown
by the trajectory.
78:13 - And then, aside from that,
it renders different things
78:15 - depending on whether or not--
78:16 - what state we're in.
78:17 - So if we haven't launched, it
will render just the alien.
78:20 - If we're in aiming mode then it
should actually render and calculate
78:23 - the trajectory.
78:24 - Otherwise, it would
just render the alien.
78:27 - And so once we release the mouse,
so was released 1 and were aiming,
78:34 - launched is true, spawn an alien.
78:35 - So we create a new alien
with self world, it's round.
78:40 - We started at shifted
X and shifted Y. We
78:43 - set its linear velocity to the same
values that we calculated before.
78:48 - So it's base X minus shifted X times 10.
78:51 - So the times 10 is a scalar amount.
78:56 - And then the base X is where
we've moved it, effectively.
79:03 - Or, no.
79:03 - Base X is where it starts and
shifted X is where we've moved it.
79:07 - And so by subtracting
shifted from the base,
79:11 - we get the negative direction that
we want to effect the impulse.
79:16 - And then the impulse is set
here with linear velocity.
79:21 - And then we also set it to
have a restitution of 0.4.
79:26 - Recall, restitution is bounciness.
79:29 - So our alien bounces a little
bit when it hits the ground.
79:32 - And then anybody know what
angular damping might be?
79:37 - Any guesses?
79:39 - Angular damping is when it rotates,
basically, friction on its rotation.
79:45 - So that when it rotates on the
ground, it doesn't roll indefinitely.
79:49 - If we don't set that, it'll just roll
forever and ever and ever and ever.
79:52 - Which is not what we want.
79:54 - We want it to stop at a certain
point because once it stops,
79:56 - we know, OK, now we can get
the next alien ready to launch.
80:03 - And that's the gist
behind the launch marker.
80:05 - How we render trajectory.
80:07 - For the math on that, a little bit more
in detail, I would explore that URL.
80:10 - It goes into it into pretty good detail.
80:12 - I use that as a reference for
creating this bit of code here.
80:18 - But yeah, effectively,
is it's just rendering
80:20 - a bunch of circles with that
trajectory and calculating it
80:24 - over 90 ticks, 90 frame iterations.
80:30 - Back to the level.
80:32 - Sorry, any questions overall as
to how the launch marker works?
80:37 - AUDIENCE: No.
80:38 - COLTON OGDEN: Cool.
80:40 - All right.
80:40 - So then we have an alien's
table, an obstacles table,
80:44 - edge shape for the ground.
80:47 - And then we just create
an alien to destroy.
80:50 - Spawn a few obstacles here.
80:52 - So in this case, two vertical
obstacles and a horizontal one.
80:56 - Positioned such that the horizontal
one is over the vertical ones
80:59 - and they're spaced apart such that
the aliens are in the middle of them.
81:04 - Then the ground here, we give
the ground some friction, 0.5.
81:08 - And that's pretty much it
for setting up our level.
81:12 - So if we wanted to, after this
point, we have the foundation
81:18 - necessary to really spawn arbitrary
levels with admittedly simple obstacles
81:24 - at this point.
81:24 - But we could set--
81:26 - because all we're doing here is
just simple insertions to our aliens
81:30 - and obstacles table, we could create
pretty much any level just by, maybe
81:36 - in data, specifying level
could be like a table
81:40 - and then aliens could be another table.
81:44 - And then maybe all it is just
a like X equals some value,
81:53 - and then Y equals some value.
81:55 - And then obstacles is the same thing.
81:59 - And then all we do is just we
iterate over this level definition
82:02 - and we just say, new alien
for every table here.
82:07 - And then new obstacle
for every table in here.
82:09 - And then now your
levels are data driven.
82:11 - It's easy just to make levels.
82:13 - You don't have to code, really, much.
82:15 - And you can put this in a separate file.
82:16 - Be like, levels dot Lua, and then
just load individual levels at a time.
82:21 - Level 1 equals-- levels would
be the top level container.
82:28 - And then you would have 1
equals all of this, and then 2
82:33 - equals another one,
3 equals another one.
82:36 - And then you're not
really programming as much
82:37 - as you are just laying
things out in data.
82:40 - Super nice and concise.
82:41 - That's a nice thing about a
language like Lua, is that you can,
82:44 - and it's the same thing
in JavaScript with JSON,
82:47 - you can just define things
as data and then write
82:50 - a script to go over it and construct
your actual relevant data structures
82:54 - that way--
82:55 - in your code that way.
82:57 - When you have the
foundation like we have now
82:59 - where you can think in terms
of obstacles and aliens,
83:02 - you can construct levels like so.
83:04 - And obviously you could go a
lot more complicated with this.
83:07 - All we're doing is having very simple
almost boring static obstacles.
83:14 - They're not static in a technical
sense because they're dynamic objects,
83:17 - but all they really do is just
stand there and then fall over.
83:21 - But if you wanted a
pulley system or maybe
83:25 - something that's shaped in
a giant head or something,
83:29 - you can create arbitrarily complex
objects that way using joints.
83:36 - And if you're curious, I recommend to
look into the documentation for Love2D
83:40 - a little bit more.
83:40 - Especially their weld joints
are what you would use
83:44 - to combine pieces in arbitrary shapes.
83:47 - But you could easily take
this to the next level
83:50 - and start to create in that same
level definition, arbitrarily shaped,
83:56 - welded together obstacles.
84:01 - But that would be, I think,
a next step if you're looking
84:03 - to take this beyond just one level.
84:06 - I would say, think in terms of, how
can I get my game world represented
84:12 - in a very simple data like way?
84:14 - Because not only does it make it
easier for you to create content,
84:17 - it allows you to shift that
burden to somebody else
84:20 - and allow you to give the
task of creating levels
84:23 - less to a programmer and
maybe more to somebody
84:24 - who has just a design background who
isn't as comfortable writing code.
84:28 - And allow you to create the engine that
constructs the game world based off
84:31 - of this data.
84:34 - Any questions as to how
we've set things up here?
84:40 - OK.
84:41 - So we have the ground,
we have a background.
84:43 - A background is just a simple
class that renders a static image
84:47 - that you can scroll the
image with left or right,
84:49 - but we don't end up using it much.
84:51 - It's relevant in Angry Birds because
in Angry Birds they have a camera,
84:55 - and the camera pans left to
right depending on how far away
85:00 - the fortress is from your sling shot.
85:02 - So that's in there if you want
to experiment with it at all,
85:06 - and experiment with a moving camera.
85:08 - Maybe use timer dot
tween to tween the camera
85:11 - or just to have it track the
alien if you want larger worlds.
85:15 - But we don't end up using
it in the distro as much.
85:19 - Our update function is simple.
85:20 - We update the launch
marker, update the world,
85:23 - and then we process all the bodies
that we flagged as being destroyed,
85:26 - which we've already seen.
85:27 - We reset destroyed
bodies to an empty table
85:29 - because we've processed all of them.
85:31 - We actually remove from our
level the obstacle objects
85:38 - so that they're no longer
rendered, and we no longer
85:40 - try to reference the
bodies that are destroyed.
85:44 - And then notice here too,
when we destroy the obstacle,
85:49 - we're playing a sound effect
inside this bit of code.
85:52 - So we can just do g sounds.
85:54 - I put five wooden sound effects
in there just for variability.
85:57 - It'll pick a random one.
85:58 - And then using to string
at the number, just
86:00 - create break one, two,
three, four, five here.
86:03 - And then stop and play it.
86:06 - Same thing here.
86:07 - I have a sound called kill
for when we destroy an alien.
86:09 - So when we flag an alien as destroyed
and we remove it from the scene,
86:14 - we should also call that sound effect.
86:16 - And then if the alien stops
moving in our scene, the player,
86:27 - we can get a reference to it here,
self dot launch marker dot alien,
86:31 - as opposed to any aliens in our scene.
86:33 - When it stops moving, so we
get the average of its velocity
86:36 - and if it's less than
1.5, so not perfectly
86:38 - still, because it's tedious to
wait that long, but almost still,
86:43 - we destroy the alien and then
we create a new launch marker.
86:48 - We destroy the alien so that the
world doesn't keep a reference to it
86:52 - and then we just create
a brand new marker,
86:54 - which has the effect of instantiating
a new alien there when we relaunch.
87:00 - And then here, if there are
no more aliens in our scene,
87:04 - if we've destroyed all of the aliens,
in this case there's only ever one,
87:07 - but there could easily,
with a little more work,
87:09 - be a few more aliens in the
scene, if it's set to zero,
87:13 - then go back to the start.
87:14 - Which we saw before when we
finally killed the alien.
87:18 - And then all we're
doing here is deferring
87:19 - rendering to the individual objects
we want to render, the launch marker,
87:26 - the alien, the obstacle.
87:27 - We render ground tiles.
87:29 - So recall, from our ground example
before we were just using a line,
87:34 - an edge shape to represent the ground.
87:36 - But if we look at our game, it's a
little hard to see because I'm in 720,
87:44 - but there's actually a ground tile here
at the very bottom, a bunch of them.
87:49 - And even though we have
all of those tiles,
87:52 - all we're doing to detect
collision is just an edge shape.
87:56 - So what we're doing is just beyond
having the edge shape in our scene,
88:02 - we draw that tile, which is
frame 12 in our sprite sheet
88:09 - from negative virtual
width to virtual times 2.
88:11 - So three screen widths total.
88:13 - And then we just do it in
increments of 35 pixels
88:16 - because that's how wide the tile is.
88:17 - And that'll just create
a bunch of the same tile
88:19 - at the very bottom of our screen.
88:24 - So just a graphical thing, not
really necessarily functional.
88:28 - We have the edge shape already in our
scene, but just to make the ground
88:31 - look a little larger
than one pixel tall.
88:35 - And then if we haven't
launched anything,
88:38 - we should display some
instructions here.
88:40 - And then if we're at
no aliens left, then we
88:45 - should display the victory screen.
88:47 - And the victory thing will last
for just a little bit of time,
88:51 - because even though self dot
aliens is zero, this bit of code
88:55 - doesn't register until after
the velocity of our moving alien
88:59 - slows down sufficiently.
89:01 - So this will get called when we're
just about to finally stop moving,
89:05 - and then we check to see, oh, OK,
do we indeed have no aliens left?
89:09 - If not, time to go back to the start.
89:12 - We've completed a level.
89:13 - And then you obviously
would just change this
89:15 - to go to be next level if you
ended up implementing more
89:19 - levels in your game besides just one.
89:23 - Beyond that, that's pretty much all
of the code that's in this example.
89:27 - It's fairly, I would say,
unsophisticated relative
89:32 - to prior examples.
89:33 - But mainly, the burden
is learning how to use
89:35 - the physics engine, the
Box2D physics engine, which
89:38 - itself is quite a few functions.
89:42 - It's some of the longest documentation
on Love2D's wiki, I think.
89:47 - But the principles are
pretty simple, in my opinion.
89:50 - I think it's actually quite easy to get
rolling with a lot of cool features.
89:57 - The vast majority of which I
don't think we even really cover,
90:00 - at least in terms of what you can
do with compound objects and joints
90:03 - and things like that,
which really start to go
90:06 - into the world of more sophisticated
and interesting physical simulations.
90:12 - Things like I alluded to before, pulleys
and tanks and other things like that.
90:16 - Some features that we could look
at potentially expanding upon
90:19 - if we wanted to make our
game more interesting,
90:21 - is more shapes for our objects.
90:24 - So if we look at our
sprite sheet here, we
90:28 - can see there are things like roofs
and circles and things like that.
90:33 - So more interesting obstacles
beyond just square rectangular
90:36 - shaped obstacles.
90:40 - Go back to-- like I said
before, compound obstacles.
90:44 - So a bunch of things
put together via joints.
90:47 - So pulleys, there's motors, weld
joints, which you can use to-- you
90:51 - can affix a roof to a square and then
have two pieces that are tied together.
90:56 - And you can make arbitrarily
complex and shaped things
90:59 - and just be really interesting.
91:01 - And that big thing, that
body with all these fixtures,
91:03 - will collide just as any other
thing would, thanks to Box2D.
91:09 - As I alluded to before, instead
of having levels to be hard coded
91:13 - into our level class, maybe define them
in a Lua file called levels dot Lua.
91:19 - And then just have aliens
be a table, obstacles
91:22 - be a table, and then
whatever else, however
91:23 - more complicated you want
to get with your game.
91:25 - You can add more things.
91:27 - But just have it be represented
as simple data structures.
91:32 - So aliens that maybe have
different shooting mechanics.
91:34 - So if you've played Angry Birds
you're familiar with the fact
91:37 - that some birds will split
off into multiple birds.
91:40 - Some birds will dive and go super fast
and break through all the obstacles
91:44 - in their path.
91:45 - Some birds will explode,
and then their explosion
91:48 - affects all of the
obstacles around them.
91:50 - So there's a lot of
different game play mechanics
91:52 - you can implement using different
types of birds or aliens.
91:57 - And then different obstacle materials
is another direction we could go.
92:01 - And it's supported out of
the box with the sprite sheet
92:04 - that I provided because
it has sheets for metal
92:08 - and glass and explosive material.
92:10 - So there's a lot of
different interesting things
92:12 - you could do just by changing up what
materials you're using in the game.
92:15 - And obviously those will have different
densities and behave in different ways.
92:19 - So assignment five is a
fairly simple assignment.
92:21 - So this is just as I alluded to before.
92:24 - The task here is to
split the bird that you
92:27 - shoot by pressing Spacebar when
it's in the bird-- the alien, when
92:31 - it's in the air, press Spacebar
and have it split into three.
92:35 - So you have your one that
you're shooting already.
92:37 - So it should just shoot off two more.
92:39 - One that's angled higher,
one that's angled lower.
92:41 - And all of those should be
interactable with your game world.
92:45 - And that's really it.
92:46 - So if you can do that then
it'll show that you know
92:48 - how to effect the Box2D game world.
92:52 - Next time, next lecture,
we'll be talking about--
92:55 - the theme is going to
be Pokemon, but we'll
92:57 - be talking about more generally RPGs
and turn-based games of that nature.
93:03 - It won't maybe necessarily
look quite as pretty as this.
93:05 - But we'll be striving
for a similar over world
93:08 - that we can walk around and then engage
in fairly simple turn-based battles
93:11 - and stuff like that.
93:12 - And also, we'll be talking
about user interfaces and things
93:15 - like dialogue and stuff like that.
93:18 - But that was it for
lecture six, Angry Birds.
93:20 - I'll see you next time.
93:21 - Thank you.

Cleaned transcript:

COLTON OGDEN All right. Good evening, everybody. Welcome back to GD50. This is lecture six. And today we're going to be venturing out of the 8bit world and back into a more modern era of gaming. We're talking about Angry Birds today. I have pretty fond memories of Angry Birds, actually. It was the first mobile game that I remember playing where I realized that mobile was actually a viable platform for gaming. I played it, I think, back in 2009, was when it was first released. And I really enjoyed it. It has a very simple formula. The goal, if you're unfamiliar, is you have birds that you control by a sling shot on the left side of the screen. And then these pigs that have stolen your eggs, you're trying to destroy them or kill them by knocking down their fortresses made out of various materials, wood, glass, metal. And you get a few different bird types. But the gist of it is, basically, just sling shot a bird into some structure, knock it down. And the whole entire underlying mechanism for how things work is via a physics engine, which we'll talk about today in lecture, called Box2D Probably the most ubiquitous 2D physics engine. But that's the overall structure of the game. It's literally just throwing things into structures, knocking them down. And then that tactile and fun game play makes for really great mobile gaming. And I enjoyed it a lot back in the day. This is a screenshot of the first level in the first Angry Birds, which most people I think have probably seen. This is a sample from one of their newer games. As you can see, it's taken a whole new layer here. There's stone and a bunch of intricately varying structures and new creatures and stuff like that. The game has changed a lot, but the formula has stayed the same. And today we'll explore the foundation of what makes this game work. And the topics today, a smaller than usual. But Box2D, we can consider as being a pretty large topic. We'll be talking about Box2D, which is the physics engine we'll be using today in lecture. And via Love2D, which has its own wrapper for Box2D. And we'll also talk a little bit about mouse input, which you haven't really done a lot. But it's very apt, especially in the context of mobile gaming. Because mouse input and touch input are synonymous. But first, let's get a lecture demo. If we have a volunteer come up on stage to showcase what I've put together here. So let me make sure I'm in the right directory here. So whenever you're ready, go ahead and press Enter. So this is a little demo I put together to demonstrate the concepts we'll talk about today in class. This is just the Start screen, but it already shows Box2D representing a bunch of these square shaped aliens, which we'll actually be what we're trying to target in the game. But notice that they all fell and had their own collision and their own physics that took place, and I didn't have to manually code rotation and stuff like this. This is all stuff that Box2D takes care of for us. And we'll see it used to great effect soon. If you go ahead and just click anywhere on the screen, we'll go to the main part of the game. So this is a very simple representation of what Angry Birds is. You start on the left side of the screen. You have a bird, in this case an alien, we used a free art pack that uses aliens instead of birds, but it's the same concept. You have an alien that you can click and drag. So if you click it and then drag around, you can see the trajectory that you'll have when you let go of the mouse. So we're simulating where it's going to go via these purple circles. And then the goal in Angry Birds is to throw the bird into, or the alien, into the fortress guarding the pigs, or in this case, square shaped aliens. So if you go ahead and just launch the bird by letting go of the mouse you'll see. Oh, there we go. And we knocked down the. OK. What happened was we shot the alien into the structure. It destroyed one of the wooden blocks guarding the other alien. And then, as soon as that happened, the top box, because these are all being simulated via Box2D's physics engine, that other box was detected as being unsupported. So it fell down, it hit the other alien. And we've coded it so that when a collision occurs between an obstacle and our alien of sufficient speed, it should kill the alien. Which is how it works in Angry Birds. So if you'll try it again. And this time we hit both of those at the same time. So it triggered both of those being deleted. But this guy is still alive. So after it stops moving, which is similar to how it behaves in the original game, it's going to let us try again to shoot. So if we try one more time. And then we launch and hit it, we kill it and then we get a victory. So that's the overall underlying foundation for what Angry Birds is. Obviously we're using a very simple representation. It doesn't have a lot of the frill that Angry Birds does. But we could easily build upon this and create a fully fleshed out game very similar to Angry Birds. So thanks, Steven. I appreciate the demonstration. So that's our goal today. We'll be talking about how to construct a very basic but functional simulation of what Angry Birds is at its core. Which is just flinging things into obstacles, destroying them, and ultimately destroying the things that they're protecting, the aliens, the pigs that are in the base game. So here's a shot of what the different sprite sheets we're going to be using are. There's a really great sprite sheet that I got off of Open Game Art. Kenny is the artist. He makes a lot of great art. If you notice, it's very similar looking to the art that we use in the Mario lecture. Actually, it's the same artist. So if you're ever looking for assets, he's got a ton of awesome assets on open game art. So we have a set of aliens, square and round shaped. I decided just arbitrarily we made the round shaped aliens the birds. So we shoot those into the structures that are protecting the square shaped aliens. The square shape aliens will be the bad guys in this case. And then we have another sprite sheet down here below on the left side. Which just, I used the tile here just to make a ground element. The rest of these you could easily include in the game if you wanted to, but we're only using the ground here. And then notice here, we have this large sprite sheet which has a bunch of different shapes and sizes of materials. The whole sprite sheet comes with metal and explosive and glass sheets as well. But just for simplicity we only use the wood here. But notice that we have entirely whole pieces and then we have pieces that are partially destroyed and then pieces that are hollow. You could easily model all of these in your game and use them. But we only decided to use just a couple of these, which was just the horizontal and the vertical ones that are completely whole. These, unfortunately, don't have quite the same systematic layout as the sprites that we used before. They're not laid out in a grid evenly spaced. So in this case, in util dot Lua, I ended up hard coding the different XY width and height quads for each of these, which is what you have to do in a situation where you're interacting not with tiles per se, but with more organic shaped objects. So it can take a little more time to end up constructing all of the quads for your objects when you have a sprite sheet like this. But, fortunately, you only have to do it once. Here's a few useful links before we get started in talking about what Box2D is and how to use it, and basically how it's called love dot physics, effectively, in love2D. The first two links are documentation for love 2D, what the functions and objects are that we'll be talking about. And a simple tutorial that talks about how to make a ball bounce in love 2D using Box2D. The third is a great resource that I used actually to learn most of what I know about Box2D, especially in the context of this lecture. So it talks about a lot of different concepts. It talks about all the things that we'll be talking about. And then it goes into a lot more detail about how you can go about constructing a lot of really cool, crazy things like tanks and pulleys and a whole bunch of different things that are worth looking into if you're looking into potentially making a physics based game. Obviously we won't be going into things of that complexity here. But you could easily do it with Box2D. It makes it very, very possible. So the very first thing that we should talk about when we want to construct a game, or simulation, or whatever we want to do, with Box2D is we need some sort of system that will actually perform the simulation for us. And the fundamental core of what a Box2D app or game is, the core is the world object. So there is a world that you can think of as sort of being your world, but what it effectively is is a machine that simulates all of the pieces that you've told it interact with each other in Box2D. So Box2D has a set of objects called fixtures and bodies. Those perform the physical interactions. And it's up to the world to update all of those and apply the relevant forces and physics calculations that resolve collisions and do all sorts of things. All of the things that Box2D does for us, the world takes care of this for us. So we don't have to manually go through and update every single object with its velocity that we've done before and check for collisions. The world does this for us, and resolves them based on how we tell it to resolve them. And the world also possesses, like an actual world would, gravity on the x and yaxis. In this case, we have gravity applied on the yaxis going down, so it's a positive value. We set it to 300 in this distro, but you can set it to whatever you want. Setting a lower gravity would have the effect of making it feel like we're on the moon or something. Making it feel like we're on a different planet. So that's what the world is. The world simulates everything. And we'll go through just a few terms here before we look at some source code. But there's a few terms that we need to understand before we can really understand what Box2D is doing. And this is the function that we use to create a new world in love2D. Very simple, love dot physics dot new world. And this love dot physics is just a name space that encapsulates all of the Box2D functions and objects that love2D has access to. So anything that you see in love dot physics is effectively a wrapper for Box2D. And to clarify about Box2D, Box2D is just a library that's written in C++ that you can plugin pretty much anywhere you want to. Unity uses it and, actually, most 2D game engines that I've ever seen including Live GDX, for example, which is a very large Java 2D game framework uses Box2D. You can use it anywhere. In this case we're using love2D's own wrapper for it. So the people that created love 2D, they took Box2D and then they just put a bunch of Lua functions around them, around all the objects and functions to make it possible to use it in the same style that we use the rest of the framework. This is how you create a new world. This is the first step in getting your Box2D simulation working. So any questions so far as to how we can get that going? OK. So beyond the world object, which is the foundation, sort of sets up our stage, you can think of it as our stage, we need bodies to actually interact with each other. So a body is just an abstract container. It basically holds a position and a velocity. And you attach things to it via what are called fixtures that allow you to give the body a shape, and therefore a collision box, and therefore allow it to interact with other things. But a body is essentially all the disparate things in your scene interact with each other and move around. And so to create a new body we just do love dot physics dot new body. We pass in the world, so therefore when we do this, the world has a reference to this body now. And every time we call update on our world, which we'll see in the source code, it will know, OK, I have a reference to this body, perform all of the relevant checks on the collision for that body and all the fixtures that it contains. Update its position, updates velocity, and so forth. And not only a world, but it also gets an x and a y, which will place it in the world on instantiation. The last parameter here, type. There are three fundamental types of bodies which we'll see in love 2D, static, dynamic, and kinematic. And that basically influences how it'll interact with the other objects, the other bodies, in our scene. So we have the world, which encapsulates everything, all the bodies, all the fixtures. And then we have the bodies, which are the entities in our game world that have position and velocity, effectively. The last key ingredient here that will allow us to create interactions between the bodies that we have are fixtures. And fixtures, all a fixture is, is this abstract object that will allow you to attach a shape to a body. So bodies are shapeless by default. They don't have a shape. They are just a container that has position velocity, effectively. But they don't interact with anything else. And they don't know how to interact with anything else until you give them a fixture. And the fixture you will give the body and a shape. So for example, if you want the bird that we were looking at earlier, the alien, the round alien, we create a body for it in our world, which doesn't mean anything yet. But we say, I'm going to attach a fixture to that alien. I'm going to give it a circle shape. And it'll then know whenever it performs any calculations, that that alien should interact with things as if it were round. And therefore trigger collisions based on a circular hitbox, as opposed to a rectangular or polygonal hitbox, as we'll see. Fixtures, in addition to attaching shapes to bodies, which will, as said here, influence how they collide with other bodies, they have density, which we'll see. So that things with higher density obviously will fall faster, or not fall faster, but they will influence things as if they have more weight. They will push things farther when they collide with them. They also have friction and they have restitution. Restitution is bounciness. So if something, if we had our alien, no restitution when it hits the ground it'll just fall flat. But if we give it a higher restitution it will actually bounce when it hits the ground. And therefore interact with the world a little bit differently. So when we want to take a fixture and apply a shape to a body, we have a few different shapes that we can apply to it that are given to us by default in love 2D. So circle shape, rectangle shape, edge shape. These are just, effectively, how we define how our bodies interact with other bodies. How, for example, if it's something that's circular it should roll when it's moving along the ground. Or when it hits something the corner obviously of it won't hit something because it's rounded, as opposed to something that has a square hit box, it'll affect things in a slightly different way. And we can define arbitrarily shaped hit boxes, thanks to the polygon shape. If we want something to be shaped like a pentagon, for example, and have it roll around and behave like such, we can just define a polygon via a set of vertices. And then affix that to a body and it will behave as if it were pentagon shaped. And this is how you would instantiate just as we've seen with love dot physics dot new world and love dot physics dot new body, love dot physics dot new fixture takes in a body and a shape, and will apply that shape to the body. And the world after that will know exactly how to collide with things. And so the last thing, the last slide we'll look at here before we start looking at source code is what the different body types are. So I alluded to having three different body types before, static, dynamic, and kinematic. So a static body will exist in our world but not actually be affected by gravity or the collision of anything else. Things can hit it and bounce off of it and do their own thing, but the static body will never be influenced by something else. It exists as some sort of permanent structure, almost like the ground. You don't really affect the ground by moving into it and bouncing into it, unless you do it with enough force. But in our Box2D world, a static body cannot be influenced by anything else. A dynamic body is the opposite. It has the full simulation of Box2D. Gravity affects it, things collide into it, it will bounce off of them. It'll do what you would expect a normal body to do. If I throw a ball in this room and it hits the wall, it's a dynamic body. The walls are the static bodies in this case. And then a kinematic body is a hybrid between the two. It's something that can move and can rotate and do things, but it's not influenced by other objects colliding with it. So, for example, if I have a platform that's just spinning indefinitely, but it's not being affected by gravity and it doesn't move when I hit it, that's a kinematic body. It's still moving and it's semistatic and it influences other things, but it's not purely static. It does have a little bit of behavior that it can grant it. So let's go ahead and look at a few examples now and see how this actually looks in code. So I'm going to go into an example, if you're looking in the distro, there is an example called static. So we'll take a look here and see what a static body looks like in our scene. And for all of these examples leading up to Angry Birds, we're just going to render everything with shapes for simplicity. But this, as anticlimactic as it is, is a full Box2D world with just a single static body. And it's just this square here, colored white. The static body doesn't move, it doesn't do anything. Nothing can influence how it moves or behaves. But it exists in our world as a permanent fixture. And if we had dynamic bodies and we threw a dynamic body at it, for example, the dynamic body would bounce off, the static body would stay there permanently. So let's go ahead and take a look at what the source code looks like for that. So I'm here in main dot Lua of our static file. And just as we've seen before, we needed to find a world. So I have a world here on line 45. Love dot physics dot new world, no xable gravity, but we are going to have 300 units of positive gravity on the yaxis, which is going from top to bottom. We need a body for our square that's in our game world, our static square. So we're going to go ahead and define a new body here. Love dot physics dot new body takes in the world, recall, because that's how our world's going to have a reference to that body, doesn't know about it unless we pass it into here, our new body constructor. And then I'm just going to put it right in the middle of the screen. So virtual width divided by 2 and virtual height divided by 2. The difference between Box2D bodies and things that we've drawn before or seen before is that everything is defined by its center point, as opposed to its top left. So I'm able to say virtual width divided by 2 and virtual height divided by 2 here. But I don't actually need to say virtual width divided by 2 minus whatever the half of that square is. By default, the center point is the XY of that object. And this last string here in the constructor for our new body, static, tells the constructor that this is going to be a static body specifically, not a dynamic body and not a kinematic body. So we have a body and it's static, but it doesn't have a shape, it doesn't really know how to interact with anything else in our world. So we're going to give it a we're going to create a new shape first. So love gives us a few functions in the form of new X shape. We have new rectangle shape, new circle shape, new edge shape, a few other ones. We're just going to create a new rectangle of width and height of 10. So that's what the 10 and 10 are here. Then we're going to create a new fixture. We're going to affix the box shape to our body with this function. And then once we do that, all we have to do is then render a polygon with fill and then we get the coordinates for our or the vertices for our polygon by saying, body get world points. So that's a function off of any Box2D body that will basically get where it is in the world and all of its vertices. And then you just pass in the shape that you want to get the points for. And that will end up just exploding here into a set of vertices that fill up this love dot graphics dot polygon. And the end result of that is we get a square. And we specifically use polygon instead of love dot graphics dot new rectangle because that's what the get world points function explodes out to. It doesn't explode out to the number of arguments that would satisfy love dot graphics dot rectangle. So not a very exciting example. But this is basically the foundation of a full Box2D application. So any questions as to how this works at all? AUDIENCE Yeah. I'm wondering. How does it determine the center of a abnormal shape? Not like a polygon, square, rectangle, or circle. COLTON OGDEN The center of an abnormal shape. I'm not entirely sure. The circle is just AUDIENCE [INAUDIBLE] COLTON OGDEN Yeah. I'm not entirely sure about a polygon though. I haven't looked into that into too much detail. I can explore that and see. That's something that I think Box2D is the actual library implements that and calculates that. Probably based upon calculating the area of and to repeat for the camera if I didn't repeat already, it's how does Box2D calculate the center point of something nonsymmetrical, like a polygon? And best I can understand is that it would do an area calculation off of it and figure out where all the vertices tend towards, I guess. But, yeah, that's something that's implemented in the library. I'm not entirely sure. I can look into it and see and then I'll post in the Slack. AUDIENCE It seems like [INAUDIBLE] you did have that, it would be difficult to place in a very precise spot. COLTON OGDEN Yeah. If it were yeah. If we did have an odd shape to get it placed in a exact spot. Yeah, I'm not entirely sure. I'd have to explore that a little bit. Interesting idea though. But, yeah, that's essentially how we get a Box2D world up and running. We have a static body. It's not terribly interesting. But with one change so I have a separate example called dynamic in the source code distro. But all we need to do to really see the difference between a static and dynamic body is on line 48, just change static to dynamic, save it, and then rerun it. And then we'll immediately see that it's affected by gravity and it moves downwards as we've told the world that our gravity is set to positive 300. And so that behaves how we would expect it to. Now, there's nothing else in the scene so it's not particularly interesting. So I've created a another example called ground. So let's go ahead and look at that. So if we want more interesting behavior, what do we need to do in a nutshell? AUDIENCE Have more shapes and make a ground. COLTON OGDEN Some more shapes and make a ground. Exactly. That's a simple way we can start to get instantly a sense of how powerful Box2D is. Just introduce more shapes that interact with each other in different ways. So ground is an example that just introduces a ground into our scene, so that we can see the box fall down and actually collide with something else. And Love2D makes this nice and easy. Excuse me. They have a actual edge shape that will allow us to basically form where the ground is. Anything that collides with this it's effectively a line. But no matter how fast anything moves in are scene, the body will not move past that line. So it's a nice, easy way of getting a ground in our scene without having to implement a polygon that maybe has two vertices going left to right on the screen. So that's what we do here. We have a ground body, which is a static body, recall. Because the ground shouldn't move. We're going to change the box into a dynamic body, but the ground shouldn't move. The ground should be unaffected by anything. It's going to be static in our scene. And it's going to have an edge shape. So notice here, we take 0, 0 as the XY. And then a virtual width is zero. So with shapes, when we define them here, it's not going to draw the shape at 0, 0, at virtual width in 0. This is relative to wherever the body is located. So wherever our body is, this shape will be drawn with these coordinates, this X and Y and this width and height, relative to that. And specifically, relative to the center point of wherever we place a body. So if this ground is set to 0, 0 at virtual width and zero, where do we need to place the actual body for it to render the ground appropriately? AUDIENCE The middle bottom. COLTON OGDEN Yeah, so we place it towards the middle bottom. So we actually end up placing the body itself here at virtual height minus 30. And when we affix this edge shape to the body, we'll end up, even though it says 0, 0 virtual width zero, it's relative to wherever the body's XY are. So it's actually going to be 0 virtual height minus 30, virtual width zero will be where that edge exists. And then lastly, just as we did with our box, we need a ground fixture so that the ground body knows how it should interact with other things. So we're going to affix the edge shape, which is just a line, to our ground body. And then here we do love dot graphics just as we did with the love dot graphics dot polygon for our box, we're going to do love dot graphics dot line for our ground body. And we're going to do the exact same thing, get world points and get points passing the edge shape here. And I'm also setting a line width of 2 just so we can see it a little bit better. And I'm going to color it red. Again, I colored the box up here green. So go ahead take a look at what this looks like. So I'm going to go into ground. And so notice and I also added a little bit of restitution to the as I said before, restitution is a quality that a fixture can have which gives it bounciness. So rather than just falling flat down onto the ground, it bounces a little bit as well. And we can see the interaction, so I'll play it one more time. It starts in the middle. And then as soon as it hits the ground body that we created before, the edge shape, it bounces a couple of times. But it shows that the box is dynamic, but the ground is static. Nothing influences the position of the ground. It gets hard set and will stay there permanently. So that shows a nice, easy simple demonstration of an interaction between a static and a dynamic body. I'm going to go ahead and pull up another example here. So kinematic, recall, what was the difference between a kinematic and a static or dynamic body? AUDIENCE Kinematic can move but not influence other shapes. COLTON OGDEN Correct. So a kinematic body can move. You can ascribe it positional velocity or angular velocity, it's rotation. But when something collides with it, it's not going to be influenced by it. It's going to influence the body that it collides with. It's going to affect it in some way, but nothing colliding with the kinematic body is going to have an effect on its position or its velocity. It's something that exists and does something programmed and will just do that indefinitely, but it will interact with other dynamic bodies as we have programmed. And it will not interact with other kinematic bodies either. They will almost pretend that each other doesn't exist. If you overlap a static and a kinematic body or kinematic and a kinematic body, they render on top of each other, but they don't actually influence each other's position or anything like that. So I'm going to go ahead and run the kinematic example. So here we have a few things going on. We have the box body that we had before, the dynamic box that falls from the middle of the screen. We have the ground on the very bottom to catch it. But we have three kinematic boxes in the very center that are spinning that influence the green box when the green box collides with them. So as you can see, it tosses it around and then the green body falls back to the bottom. And in this example I've taken away its restitution. So as soon as it hits the ground, it just falls flat. Just like that. And so, as you can see, these blue bodies, they're moving. They have angular velocity indefinitely. Specifically 360 degrees per second. And they will stay in that exact position and rotate in that exact way forever. But as soon as they interact with a dynamic body, they actually cause a collision with that dynamic body. And the collision resolves and this green body gets tossed around because it's dynamic. It will basically do whatever it can to interact with the game world as long as it's interacting with other bodies and resolving its collision that way. And so that's the key example between what the three different bodies are fundamentally. And with these three body types you can construct pretty much any scene that you want to. And obviously the bodies and the fixtures can get insanely complex. I mean, we can look back here at this first example. These structures are a composition of many different types of dynamic bodies that have been given anchors and joints and all sorts of other things to make them look as if they're big constructions. But at the end, they're all just a bunch of little bodies that are welded together, fixtures that are welded together. And these fundamental building blocks are how you construct scenes like this. Put a bunch of these blocks together, weld them together with joints, in this case. We won't cover joints in the context of this lecture. But if you're wondering how all of these individual things can be collideable while still constructing these massive scenes and having physics applied to them, they're just jointed together using weld joints or other types of joints, pulley joints depending on what they are. In this case, there is two circle shapes here, circle fixtures, that are the wheels on this cart and then they're welded to the flat constructions here. Allowing those to be dynamic allows the wheels to roll, and therefore carry the other load with it. Same with this bridge. I forget the exact name of the joint, but it's a chain of fixtures together that are welded by a specific kind of joint. And by putting them together in this way, you get a bridge and all sorts of things that you could think of, including tanks, which is in the notes here. This third link, one of them talks about how to implement a tank by having treads going around circles and then a massive body. You could do anything with Box2D, it's an awesome library. In the context of Angry Birds, really we just scratched the surface for what is possible here. So I'm going to demo now. Actually, I enjoyed, I think, this demo, this bit of code, more than I enjoyed the Angry Birds implementation. And it's a program that I wrote called Ball Pit. Oh, by the way, before I get into that. So I'll leave that as a little teaser, I guess. Looking at kinematic, really quickly. We're going to look and see that I've created a table for the kinematic bodies, a table for the fixtures, and then one shape. Because you only need one shape actually, and you can apply one shape to as many bodies as you want to as long as they all have the same shape. I just create three kinematic bodies here. So spacing them out relative to the center with this math here. They get the string kinematic. And that's really the key difference. And then before finishing, I make sure that I set them to have an angular velocity. So this is how you spin something. If you want to set something to spin indefinitely, just set an angular velocity. In this case, 360 times degrees to radians. And that's just a formula written out as a constant, which is just the number I forget offhand what exactly the formula is. But it's up here. It's degrees to radians 0.01745329, et cetera. But just like pi, it's a number that you can use to multiply a number in degrees, and you'll get a number in radians. And there's the reverse up there as well. We have to do this because Box2D expects, for any types of rotation, it expects it in radians. I prefer thinking in degrees. So I passed in 360 times degrees to radians. And so we render down here, just as we did with the box body. We render the kinematic bodies, polygon fill, kinematic bodies at i get world points kinematic shape get points. Nothing terribly different. The only real key difference is that we've added kinematic as a string to the constructor for the body. And we've added some angular velocity. And recall, this will make it spin indefinitely, but it will never be influenced its angular velocity will never be influenced, its position will never be influenced by anything else in our scene. So now with that out of the way, I'm going to pull up Ball Pit. And maybe I'm just a little bit too excited about this. But I enjoyed this a lot. So what it is, is this is like a bigger demonstration of putting all these pieces together. We have a bunch of circle shapes. They're all interacting with each other. They all have physics. And then I have a larger shape here, this square, which has a higher density than everything else. And by pressing Spacebar I can just dive into throw it into the ball pit, and it'll cause an interaction with everything else. And a bug slash feature that I discovered about this is that if you press Spacebar over and over again, it never resets its velocity. So it just slams down into the ball pit. So it's just kind of fun, and I think there might actually be possibly a game idea in here. But, I mean, well, what are the pieces here? What's different about this? AUDIENCE They're all dynamic shapes. COLTON OGDEN Yeah. So they're all dynamic shapes. Except for the ground at the very bottom. And also, hidden from view are actually two more static shapes on the left and right. Because if we didn't have those, all of the balls would fall to the side out of view. But yeah, we have the static delimiters for our scene. But we have a bunch of dynamic bodies, the balls are all dynamic. And then the square is also dynamic. And then, like I said before, the only real difference between them is that obviously the square is a rectangle. But it also just has a higher density. And so by giving it a higher density it pushes everything else oh, what happened there? That was weird. It pushes I think it went to sleep because we didn't do anything for a while. But it's able to fall through everything else because it knows that it's heavier, and that it should push and apply a larger force to everything else that's around it. And so by using these fundamental building blocks of what Box2D is, you can construct a lot of really cool simulations and other fun programs and actually get interesting game ideas. I'm inclined to believe that Angry Birds started out as somebody messing around with the Box2D, or physics engine like this. And it was inspired by some other game that I should look into a little bit. But the creators of that game, presumably, found this physics engine and were like, oh, this is cool. I'm going to put a tower of blocks here and just throw something at it. And then they realized, oh, we can make a game out of this. And so I encourage you, if you're ever curious to just experiment with things like that. We could probably turn this into a game. I don't know. I like this a lot. It's a good segue from the abstract, for lack of a better word, examples that we used earlier, and merges it more into the realm of how can we make something fun with this? And so that's how we're going to start moving into the distro today. So the main topic of today's lecture is Box2D and how we use it to make a game. Another thing that we should consider is mouse input. We haven't really used it yet. And I believe I've mentioned it before, slightly offhand. But Love2D makes it super easy. It's just like we do with keyboard input. We just have a couple of callbacks that are in main dot Lua, mouse pressed and mouse released. The difference between these and key pressed and key released is that they also get an X and a Y. Because usually, when you click the mouse or release the mouse, you want to know where it happened because that's obviously pertinent to what you're doing when you're using a mouse. So these are fired by Love2D every time you click or release a mouse button. And they get the X the Y and the key, and you can do whatever you want with those. And just as we've done in prior lectures so that we can use mouse input in other modules besides main dot Lua, there's a function called love dot mouse dot key pressed and key released that I implemented in main dot Lua. You can check those out. They're very similar to how we did the input tables for the keyboard before. But they allow us to use this functionality inside of other functions, other modules, besides main dot Lua. So let's go ahead and start looking at this is where we're going to start looking at the distro for Angry Birds and how we can take all these pieces and form them into an actual game. So the first thing we'll do, we'll take a look at just a couple of things and then we'll take a short break and then we'll get more into the meat of it. But let me go ahead and clear out all of these. And then we're going to pull up so the distro is in Angry 50. And so main dot Lua is here. So not a whole lot is different in here. So we have two states in our game. So we had a start and a play state, as we saw before. The start state is like we've done before. The only difference is in this start state, well, for one, it's running a Box2D simulation. And two, we're actually using mouse input. So actually, let's look at main so you can see where I've added this, which is different than before. So we have love dot key pressed, as we've seen before. But we also have mouse pressed and mouse released. And then mouse was pressed and mouse was released. So those are the main differences in main dot Lua this time, as opposed to last prior lectures, which we only had keyboard input. And as you can see here, we have input tables for keys pressed and released on the mouse. And so we initialized those to empty on every update frame just like we've done with the keyboard. And then the input tables get updated in the callback functions as we've done before. And so that's basically all that's different about main dot Lua this time. And that's how we've tied together the new mouse functions that we've just looked at into our game. The states that exist in our game are play state and start state. So very simple. Very similar to last week where we looked at Zelda, we only basically had a start state and a play state. The start state, we can see here, just to tie together the last bit of our usage of the mouse. Love dot mouse dot was pressed 1. Does anybody know what this 1 is? AUDIENCE Is that left click? COLTON OGDEN It is left click. So Love2D assigns integer values to all of your mouse buttons. And 1 is traditionally the default value for left click. Some frameworks will use 0. But Lua, 1 index so start with 1 instead of 0. The thing about the start state here that's kind of cool and interesting. So I'm going to go ahead and play it again, the game. So we start off and right off the gate, just to make things interesting rather than just have a static screen that says Anger 50 click to start, we're actually running a Love2D, a Box2D simulation here. It's a world with a bunch of squares. And so what kind of bodies are all of these? AUDIENCE [INAUDIBLE]. COLTON OGDEN They're all dynamic bodies. And we've encapsulated them all, just as we did before in the ball pit example, with some invisible static bodies on the left, right, and bottom of the screen. Because if we didn't have those static bodies they would just fall all the way down. And the nice thing is we don't actually have to render anything. So if you want maybe an invisible barrier for something in your game, or you want to encapsulate something, something physical, you don't have to render anything. You can just have arbitrarily shaped and positioned static bodies. And that will act as a container. So that's all we're doing there. We have a container set for all of our little square alien guys. And by creating, I think, a hundred of them and just letting them drop, we have this interesting visual start to our game with very, very minimal effort. So we can take a look at this. So in our start state init, as I said before, we have a world. We obviously need a member of new world. Anytime we do any Box2D stuff you have to start by having a love dot physics dot new world, else you won't be able to run any simulations. Going to create a ground, walls, and then a bunch of aliens. So this here, we can see that we have a table that we're inserting aliens into. But we have a class called alien. So anybody want to ballpark what an alien class ultimately encapsulates or ultimately is? AUDIENCE Probably the way it looks, like the skin. COLTON OGDEN It is, yeah, that's definitely a part of it. So the way it looks, or it's skin. So it does have a reference to that. And then more functionally, it also possesses a body and a fixture. So rather than having a bunch of bodies and fixtures that are separated out and maybe just in tables at the surface level of whatever, our level, just wrap them in a class. And then we just can maintain a reference to each individual alien's body and fixture that way. So it's a little bit more encapsulated. It's a little bit more object oriented, little bit cleaner in my opinion. The alien class can take square or round as its well, it can take anything you want to as its type. So this will ultimately decide how it's rendered and what shape it gets. But if it's square, which is the default, so if you just create an alien with no type, it will get a love dot physics dot rectangle shape. So as we saw before, that's just a box. And then if not, we just default to circle shape. But you could program it to take in whatever shape you want, and then just give it that shape. And you don't really have to do much in terms of coding how it interacts with anything else in terms of collision, at least. Because, thankfully, Box2D will know, OK, it's a circle. It should spin around and interact with things like a circle. Or it's a rectangle so it should interact with things like it's a box. Just nice and convenient. And then we'll just create a fixture here. This set user data function here is important because we'll see in the context of how we actually resolve collisions in a customized way, we'll need user data to be able to differentiate what gets collided in our world. But at the moment you can just know that this basically allows us to pass in to set arbitrary data onto a fixture. So we can say, fixture set user data alien, the string alien. And what that means is that fixture has some customized metadata about it that says, this is an alien. It's whatever we want to do with it. We could give this a table as well. We could just say, the user data is a table and then has a bunch of information that we can then use at collision time to perform different work on it. But this set user data function is how we are able to resolve collisions between obstacles and aliens differently than, say players and aliens, or even the alien and the ground. Because when we do any Box2D collision, right, the world's taking care of the collisions for us. How do we tell the world, OK, when I hit the ground I want to play a sound, but not do anything. If I hit this box at this velocity, I want it to destroy it. If I hit the alien, I want the alien to disappear and I want to show a victory label. How do we do all these different things? We do that with what are called collision callbacks in the context of Box2D. And we'll see how that works. But suffice to say, user data will be very important coming forward. And then this launched false, actually we don't end up using this so this is irrelevant. But it has a render function here, which just takes in the bodies X and Y and will draw it at the angle that it's at. So that's an important thing. When we before, what we were doing is drawing things via shapes. So love dot graphics dot polygon, love dot graphics dot circle, love dot graphics dot line. But if we want to draw a sprite instead, we need to draw it at the right position, first of all, right? And then things also rotate in Box2D. So we need to draw it at the right angle. So what we do is we can actually query the body for its X. We can query the body for its Y. And we can also query the body for its angle. And then we can draw the texture and the quad that we want to using those XY and the angle, and that will have the effect of drawing a sprite in the world that mirrors what's going on in Box2D, rather than just a simple shape. So that's as simple as it is for drawing a sprite instead of a shape. You can see here, the 17.5 17.5. Does anybody know what that's for? AUDIENCE Not sure. COLTON OGDEN So 17.5 17.5 at the end is half of the width and half of the height of the aliens. So aliens are 35 by 35 in this game. We pass those in. This is the center of origin. So when we rotate something by center of origin, it basically describes where the rotation is going to take place. So if it's rotated about the top left and we rotate something, it's going to have the effect of the sprite going around in a circle in sort of an odd way. If we rotate the sprite based on the center of origin of the actual sprite itself, that will have the effect of rotating the sprite on its center. So you can set that origin wherever you want to and it'll perform a 360 degree rotation about that point. And we're setting that point to half to basically the middle of where we're drawing the sprite. So that will have the effect of when we give it this angle here, self dot body to get angle, the rotation will take place in place. It won't take place it won't be some sort of weird about the top left corner rotation, which is not what we want. So when you see center of origin being modified like that, you can assume that it's because we have an offset and we're trying to find the center of where we're drawing and rotate about that to do an in place rotation. But not necessarily, you could also draw something. You could also, maybe you want something some sort of magical ball of energy to rotate about a rod or something. And so you want it to rotate around a different center, or whatever you want arbitrarily. But typically, at least mostly that I've seen, this is useful for making sure that your rotations, your in place rotations, are accurately rendered. So any questions about how the alien class works? All right. So that's the alien class. That's the basically the fundamental building block of our game. The other part is the obstacle. We have obstacles and we have aliens. The obstacles and aliens are actually very similar. So what's the difference between I mean, ultimately, how are they similar? AUDIENCE They're both dynamic [INAUDIBLE].. COLTON OGDEN They're both dynamic bodies, yeah. Really, the only thing that's different about a obstacle and an alien is what we do with them in our scene and how they're rendered. But they function very similarly. They're just dynamic bodies that we give a shape to and we render them with that shape. In this case, the obstacle constructor, we've decided to design it such that it could take a shape horizontal or vertical, which is similar to the type that we saw before with the alien, where it could be square or circular. In this case, if we look back at our sprite sheet back here, we can see there's a ton of different shapes. But the only two shapes that we're going to use in the context of this game, just for this demonstration, are the horizontal, clean wooden shape here and the vertical one that's right here. And so in order to find those out I had to open up basically this sprite in my sprite editor, figure out where the XY width and height were, and then create a quad manually off of that. And then I edited the util dot Lua or not util dot Lua, the dependencies dot Lua here. Normally we just create gframes and then we use generate quads. And you can do that like with the aliens and with the tiles, the tiles being this sprite sheet that this one right here. These are 35 by 35. These are 35 by 35. These are not 35 by 35. These are a bunch of different shapes and sizes. So I went through and gframes wood is for manually created quads here. And then there's four because I also added the semi broken shapes as well. But we don't actually use those. But you could decide to turn these into these on collision, perhaps maybe if the velocity isn't strong enough to break it necessarily, but you want to have some sort of feedback that you collided with it. You can just set maybe the frame to 1 or 2 on collision for that object, instead of 2 and render it appropriately. But if you're dealing with a sprite sheet and that sprite sheet has odd distribution of its sprites, sometimes you have to figure out where the offsets are manually and do it that way. The ideal is that you don't have to and that you can do it programmatically. But it really depends on the game, what your domain is and what objects you're interacting with in the scene. Any questions on the why or how as to that? Cool. So back to the obstacle. So they're horizontal or vertical, and what that does is it sets the frame to 2 or 4. And the 2 or 4 being in gframes that would, the 4 quads that I had a hand, figure out the coordinates for. And really, it's not a whole lot different at that point. If it's a horizontal or a vertical shape, then we need to set its width and height appropriately. Because it's going to have a different width and a different height. If it's vertical, obviously the height is higher than the width. And if it's horizontal, the opposite is true. But they're both a rectangle shape. So you can pass in the width and the height after you calculate that, and give it the right shape, and then ascribe it a fixture. And then set user data in this case, we set user data to obstacle. So now that obstacle, the fixture specifically, knows that it's an obstacle, as opposed to being an alien, as opposed to being anything else, as opposed to being the ground. And so when we explore in a few minutes what the custom collision, world collision callbacks, that we can actually define all this interesting collision behavior for, this user data is going to be relevant. And then we render it just like we render the alien as before. So any questions on obstacles and aliens, how they differ, how they're the same? Cool. All right. Let's take a five minute now. When we get back, we're going to actually look at the play state. We're going to look at what makes a level. And we're going to actually look at how we can customize the world to resolve collisions in ways that are relevant to our game behavior. As in, how to make things break when we collide with them, how to make the victory screen pop up when we've destroyed the bird, so on and so forth. All right. Welcome back. So before we took a break, we were talking about the aliens and obstacles that are in our game world that interact with each other. They are the backbone of what makes our games slash Angry Birds work. You throw aliens into the obstacles, obstacles break, the bad pigs slash aliens die and then you score points. But we actually have to model these interactions and we have to tell our game, our world, what to do when these collisions happen in order for things more interesting than just things bouncing off each other to work. That's the default behavior. Box2D's goal, by default, is when two things overlap, assuming that they're dynamic or at least one of them is dynamic, is to push the dynamic bodies away until they no longer overlap via either position or rotation. But that's not the gist or the goal of our game. Because what we want to have happen is different things happen and certain things to disappear and to break and all sorts of other things to happen when different kinds of objects interact with different kinds of objects at differing speeds. So in order to do this, we need to define collision callbacks for our world. So a callback, recall, is a function that gets called back when something happens. It's just something that will get called at a specific time or later on. And we can define these callbacks for our world such that when two things collide with each other, it will execute this call back and then perform the corresponding logic that we've defined therein. And with every collision in Box2D, there are four callbacks that take place. There's begin contact, so when two things begin to overlap or begin to contact one another. End contact, so once that ends, once two objects are pushed away from each other. Presolved, which happens right before the collision actually gets solved in Box2D, meaning that the things get pushed away from each other. And then postsolved, meaning right after they get pushed away from each other. And the postsolved in particular is interesting because it gets the information about how the collision needed to resolve. So how much velocity or rotation needed to happen within that interaction. And we will not be using end contact, presolve, or postsolve. We will only be using begin contact because, really, that's all we need in order to model the behavior that we're looking for. Because anything that happens in our game we can just figure it out as soon as two objects touch each other. And these are things, if you're interested in a tutorial that goes over these in perhaps a little bit more detail, there's a link here in the slides. But I'll show you how to actually implement these callbacks yourself. You do this via a function called world set callbacks, in this case, F1, F2, F3, F4. And recall, because Lua is a dynamic language where functions are first class objects, you can pass in functions as arguments to other functions. And that's what we're doing here. So this is assuming that we have four functions we've defined called begin contact, end contact. presolve, or postsolve. Their actual names don't matter at all. These are just the de facto names for them. What matters is that you have the logic there and you pass in function objects that perform something. And you can pass in all empty functions and Box2D will still behave as normal. These are only for when you want more complicated behavior out of your game than just things bouncing off of each other and moving relative to one another. So does that make sense? So we'll see how this actually works. We're going to go ahead and open up level dot Lua. So level dot Lua is a container class that basically has our game level in it, including the world and all the entities. And we update it and are able to model, effectively, like a level from Angry Birds. That's really what it is. It has a world. So the level has its own world with 300 positive Y gravity, as we saw before. It has a table called destroyed bodies. And we'll see that in a second. And then here we have four functions. Starting on line 22, we have begin contact, which is a long function. And then we have end contact, presolve, and postsolve. Those are the four callback functions that I alluded to just a few seconds ago. They take in slightly different signatures. The first three take A, B, and collision. And then the last one takes in A, B, collision, and then a normal impulse and a tangent impulse, which are the forces that it needed to apply in order to push apart the two objects. Like I said, we won't be using these three functions. But there might be a situation where you need to use those functions. Maybe you want end contact because, in your game, two objects attached to one another, when they collide maybe they're magnetic or something, and then once they pull apart maybe you want a particle effect or something to show that they've separated or something. And then presolve and postsolve. Presolve, offhand I can't think of a use case, but postsolve could be useful for, depending on your game, whether you need to just figure out maybe the amount of force that they needed to separate. Maybe you multiply that by some amount and cause some sort of dramatic effect. Those are ultimately dependent on the domain of your game. The important function that we'll be using today is the first one, begin contact. And notice, that we've defined these four functions, even if these three are just empty. But we pass in, as I said before, the set callbacks function takes in those four functions. And notice another interesting thing, because of Lua's dynamic nature, line 11 you can see that we have level init, which is the constructor for our level class. Within the constructor we are defining more functions. You can define functions as many layers deep as you want to. And you can even return functions from functions, which are called higher order functions. Really do whatever you want to. In this case we're just defining the collision callbacks here inside of our init. But you could put the most anywhere you want to. You can have them outside of the class, you can have them wherever you want. You can have them be global functions in your main dot Lua, which I don't know how I feel about that. But you can do whatever you want to as long as the functions exist and you can reference their symbols, you can pass them into self dot world set callbacks. And now, whenever a collision happens in the world period, it's going to call all four of those functions at each stage of each collision. So you could see that potentially getting a little bit hairy if you were to scale high enough with all of your logic. If you had a million lines of code in each of these and its executing million lines of code per collision, you could run into trouble. But, fortunately, we're not going anywhere near that. The gist of begin contact, so it takes in an A and a B and a collision. We don't end up using the collision itself, we just use the A and the B because that's all we need for our game world. The A and the B are what? Do we know what the A and the B are? AUDIENCE Probably the two objects [INAUDIBLE].. COLTON OGDEN The two objects. Do you know whether it's a body or a fixture? AUDIENCE It would the fixture. COLTON OGDEN It would be the fixture. The fixtures collide with each other, not the bodies. So when you have a body, recall that the fixture attaches the shape to a body. The body is just a position and velocity container for a bunch of fixtures, the body is. Each individual fixture collides with other things, other fixtures in your game world. And so, recall that before we had fixture set user data because that's what we ended up needing to have data on when we do the collisions. We check to see via get user data what something is or what metadata we've given to that fixture. And then we can then separate different classes of objects this way. We can say, oh, this object was an alien, or this object was an obstacle, or this object was the ground. And then we can say, oh, did we collide with an alien? Was the collision between an alien and the ground? If it was, OK, let's play a bounce sound effect. And if it was between an alien and the other alien, the player and the other alien, and the velocity was fast enough, OK, the alien should die. Right? We can do arbitrary things. And so the way that I've programmed it here such that we can see what two things interacted with each other, and this is a very simple use of user data. All we we're doing in this code base is just assigning strings to fixtures, but you could assign tables to fixtures with arbitrary amounts of data and do all sorts of things. In this case, we're only using strings. So I create a table, an empty table, and then I just assign at table, at that string, true. And then I can just query that table. Do I have a key player and a key alien? Do I have a key obstacle and a key obstacle? This is how you can figure out what your two objects were. Because A could be a player and B can be an obstacle. A can be an obstacle and B could be the player. So you have to take both of that into consideration. So it allows us to do if types obstacle and types player, so a collision between the player and an obstacle, if it's fast enough, then we can destroy the obstacle. This is what we do here. So I take the absolute value of the velocity on the X and Y. So I do vel X vel Y gets the body's linear velocity. So linear velocity is just where it's moving in the world. And it returns two values because velocity has an X and Y component. And then we sum it here by taking its absolute value of both parts and adding it together. So if it's moving fast on the xaxis, but not fast on the yaxis, or if it's not moving fast on either, or if it's moving fast on both, we have a sense, in general, what's the average velocity of our object. If it's moving fast on any of the axes, we can assume that that's sufficient force to cause an object to get destroyed, right? So we do if the velocity is greater than 20, just an arbitrary value that I came up with that seemed appropriate, then we're going to do this. Table dot insert self dot destroyed bodies, which we saw earlier. And then the obstacles body. Now, why are we inserting that value here as opposed to, maybe just destroying it inside this function? AUDIENCE Destroying the fixture. COLTON OGDEN Destroying the body. The fixture, yeah, in this case. AUDIENCE I mean the fixture, sorry. Because you're still referencing it later in the code. COLTON OGDEN You're still referencing later in the code. Box2D maintains a reference to all of the bodies, all of the fixtures in your world, regardless of whether you've deleted them or not. But if you delete them while it's in the middle of a, like checking for collision, it'll try to do another collision with that destroyed body and you'll get a crash or a stack overflow error. I found I experienced both of those. You don't want to ever delete or destroy anything while inside a collision callback for your world. It will cause horrible things to happen. So what we do is we maintain a reference to everything that we're going to destroy by just inserting it. So if we do table dot insert the body of whatever we want into destroyed bodies, we can then loop over that after the world updates. And then just destroy them one by one outside of the update function. And the reason that we are passing in the body and not the fixture is when we destroy a body, it destroys all the fixtures associated with that body as well. So we're just destroying the top level container here. In this case, it doesn't matter too much whether we destroy a fixture or a body because it's a one to one relationship. But if you had, let's say, a body that has five fixtures on it. And if that entire thing collides with something else and you want to destroy that entire thing, you want to destroy the body, not an individual fixture. Because when you destroy the body, it destroys all the fixtures, not just the one fixture. So that's we're deleting the body, adding the body to destroyed bodies, and then later performing a delete off of that. The function is destroy here. So on line 157 well, 155 to 159, this is where we actually iterate over everything that we wanted to flag, or that we've flagged as destroyed, and we destroy it. So if not body is destroyed, destroy it. And then once we destroy it, we're going to go down here and end up actually removing the obstacle and the alien class from our list of aliens and obstacles. Because that maintains a reference to what we're drawing and we want to also delete that. So not only do we want to delete the object from the world, we want to delete the objects that we've created that are a wrapper for the bodies and fixtures and also the drawing of our aliens so it no longer gets drawn to the scene, basically. So yeah, don't ever delete a body or a fixture inside your callbacks. Always flag them and delete them afterwards. Basically, don't delete in the middle of a world update function call, which we see here. Notice that this takes place, 152, were doing self world update. And then on 155 to 159, we've populated destroyed bodies via the collision callback that we defined up above. So in here, this is where we can actually destroy everything. This is outside of the update function, here, the world update function. We don't need to worry about stack overflow or a segfault, which we get by deleting something while it's in the middle of processing its collisions. So unfortunate bug. If you ever find yourself running into stack overflows or segfaults in your collision callbacks, make sure you're not deleting anything. But we can see here, it's very similar, the behavior we defined between obstacles and the player, between obstacles and aliens, and between the player and alien. Ultimately, it's check to see whether the average of its velocity is greater than a certain number, in this case, 20. And if it is, flag it as destroyed. So if the player hits the alien, destroy it. If a obstacle hits the alien, destroy it. And it's similar to how it works in Angry Birds. When you throw something at a structure in Angry Birds and a piece of debris falls off of it and hits the pig, usually kills the pig too. And if your bird hits the pig, that usually kills the pig. But if you're not moving fast enough or if a piece of debris isn't moving fast enough, it'll just nudge the pig, it won't actually kill the pig. So that's why we're taking all of this into consideration. We're not just doing a blind delete off of the body's in our code, we're actually making sure, is it also moving fast enough, i.e. does it have enough force? And if it does, then perform the code, then perform the deletion or flag it as being deleted. And so once again, that's why user data is important. Because that's how we're able to because notice in the callback we just get an A and a B. And those are always going to be fixtures. Fixtures, in order for it to know what kind of a fixture it is, whether it belongs to a player or an alien, we need to give it some information. So the set user data flags the fixtures as being of a specific type. And then we can fetch it here with get user data and then actually perform the relevant game logic. Any questions as to how this works? AUDIENCE Are you checking for if two obstacles knock into each other? COLTON OGDEN Am I checking with two obstacles collide with each other? I might not be. In that case you should. In that case, since we're not, they'll just bump into each other. But, yeah, if we wanted two wooden obstacles to destroy each other if they hit fast enough, you would just do the same thing here. If types obstacle, I guess. But in this case, because they're both the same key, you would have to do if types let's see how we're doing it again. So types obstacles is true, types obstacles is true. You would say if types obstacle and not types alien, not types player, not there's a cleaner way to do it. AUDIENCE Like a series of [INAUDIBLE] statements. COLTON OGDEN Yeah. AUDIENCE [INAUDIBLE] statements. COLTON OGDEN Yeah. That's true. Yeah, there's a lot of ways. And if I were to reengineer this, I would also abstract out this code and make it a function. Because it's pretty much the same code between all three of these. But just to illustrate and just for simplicity because it's pretty similar interactions, didn't really put too much engineering forethought into it. Definitely if you expand upon it, I would recommend doing that. But that's the gist of making our world behave beyond just resolving collisions and pushing obstacles away from each other, which is the default behavior. So we set the callbacks. We're good. Now things, when we interact with each other, they'll behave differently, they'll trigger different behavior. We have this thing called a launch marker, an alien launch marker. Anybody know what that might be? AUDIENCE Is that the little dots that show the trajectory? COLTON OGDEN Yeah, so it's the dots that show the trajectory. It's one, the alien being rendered on the left side of the screen without any physics applied to it, that's click and dragable. And it also renders a trajectory. And when you release the mouse, it launches an actual Box2D alien traveling in the direction that that trajectory foretells. If we look at alien launch marker here, it basically maintains a reference to whether we're aiming or not. So it's got a couple of states. It's got a launch state and an aiming state. An alien that we'll have a reference to eventually, which will spawn and will give it an impulse. So an impulse is effectively setting its velocity immediately to some value, as opposed to something over time. We can apply force to an object, which would be like you driving your car up against something and then gradually accelerating, that's applying force. And we can also apply impulse by going full speed with our car and hitting an object, and that will have the effect of applying an impulse at a certain velocity. When we drag our alien and then we release it, we want to apply an impulse in the opposite direction of where we're dragging based on a certain amount. I scaled it by 10, but you can have it be arbitrary. And then the trajectory models where it's going. And the trajectory is calculated via these lines here. So from line 90 to 104. There is a formula for, in that Box2D set of tutorials, that actually shows you how to calculate an estimated trajectory given a starting impulse and a starting position. Which is this formula here. It's semicomplicated. The article goes into detail as to how it works, but it effectively calculates 1/60 of a second, assuming that we're running our simulation at 1/60 of a second, it will, over 90 iterations here, 1 to 90, calculate each individual step of that simulation. And then I only render every 5 here. So if i is mod 5 s 0, then I'll actually end up drawing a circle at trajectory X, trajectory Y. Trajectory X and Y being here. Shifted X, shifted Y being the starting location. And then we multiply i by 1/60 of a second, which will give us the scalar for this impulse here. And then with gravity we have to do this i squared plus i times 1/2 times the gravity on the yaxis times 1/60 squared. The article goes into a little bit more detail as to how it works. But that's it converted into source code. But it's effectively a gravity simulation and a velocity simulation over time. And by rendering it based on 90 iterations, which is one and a half seconds, at 1/60 of a second we can forecast where exactly we're going. And then when we apply this impulse, X and Y, the ball will actually travel, the alien will actually travel in that direction at that exact trajectory. That's the complicated part of the launch marker. The other part is that it has a couple of states, like I said before. So when we click and we're not launched, it should go into aiming mode. And so if we're aiming then we're going to set a rotation to actually, rotation is not relevant because this was before I ended up using the predictive trajectory method. The shift at X and Y though, those are relevant because that's the starting location for your trajectory. That's wherever your mouse is. And we clamp it so that it doesn't go past a certain limit on the left or the right, so that it stays within a box area. But this will be whenever you let go of the mouse, that will be where we spawn the Box2D alien and apply an impulse in a negative direction relative to where we move the mouse. So if we move the mouse to the left and down, it's going to negate that with an impulse going up and to the right, if that makes sense. And that's what's shown by the trajectory. And then, aside from that, it renders different things depending on whether or not what state we're in. So if we haven't launched, it will render just the alien. If we're in aiming mode then it should actually render and calculate the trajectory. Otherwise, it would just render the alien. And so once we release the mouse, so was released 1 and were aiming, launched is true, spawn an alien. So we create a new alien with self world, it's round. We started at shifted X and shifted Y. We set its linear velocity to the same values that we calculated before. So it's base X minus shifted X times 10. So the times 10 is a scalar amount. And then the base X is where we've moved it, effectively. Or, no. Base X is where it starts and shifted X is where we've moved it. And so by subtracting shifted from the base, we get the negative direction that we want to effect the impulse. And then the impulse is set here with linear velocity. And then we also set it to have a restitution of 0.4. Recall, restitution is bounciness. So our alien bounces a little bit when it hits the ground. And then anybody know what angular damping might be? Any guesses? Angular damping is when it rotates, basically, friction on its rotation. So that when it rotates on the ground, it doesn't roll indefinitely. If we don't set that, it'll just roll forever and ever and ever and ever. Which is not what we want. We want it to stop at a certain point because once it stops, we know, OK, now we can get the next alien ready to launch. And that's the gist behind the launch marker. How we render trajectory. For the math on that, a little bit more in detail, I would explore that URL. It goes into it into pretty good detail. I use that as a reference for creating this bit of code here. But yeah, effectively, is it's just rendering a bunch of circles with that trajectory and calculating it over 90 ticks, 90 frame iterations. Back to the level. Sorry, any questions overall as to how the launch marker works? AUDIENCE No. COLTON OGDEN Cool. All right. So then we have an alien's table, an obstacles table, edge shape for the ground. And then we just create an alien to destroy. Spawn a few obstacles here. So in this case, two vertical obstacles and a horizontal one. Positioned such that the horizontal one is over the vertical ones and they're spaced apart such that the aliens are in the middle of them. Then the ground here, we give the ground some friction, 0.5. And that's pretty much it for setting up our level. So if we wanted to, after this point, we have the foundation necessary to really spawn arbitrary levels with admittedly simple obstacles at this point. But we could set because all we're doing here is just simple insertions to our aliens and obstacles table, we could create pretty much any level just by, maybe in data, specifying level could be like a table and then aliens could be another table. And then maybe all it is just a like X equals some value, and then Y equals some value. And then obstacles is the same thing. And then all we do is just we iterate over this level definition and we just say, new alien for every table here. And then new obstacle for every table in here. And then now your levels are data driven. It's easy just to make levels. You don't have to code, really, much. And you can put this in a separate file. Be like, levels dot Lua, and then just load individual levels at a time. Level 1 equals levels would be the top level container. And then you would have 1 equals all of this, and then 2 equals another one, 3 equals another one. And then you're not really programming as much as you are just laying things out in data. Super nice and concise. That's a nice thing about a language like Lua, is that you can, and it's the same thing in JavaScript with JSON, you can just define things as data and then write a script to go over it and construct your actual relevant data structures that way in your code that way. When you have the foundation like we have now where you can think in terms of obstacles and aliens, you can construct levels like so. And obviously you could go a lot more complicated with this. All we're doing is having very simple almost boring static obstacles. They're not static in a technical sense because they're dynamic objects, but all they really do is just stand there and then fall over. But if you wanted a pulley system or maybe something that's shaped in a giant head or something, you can create arbitrarily complex objects that way using joints. And if you're curious, I recommend to look into the documentation for Love2D a little bit more. Especially their weld joints are what you would use to combine pieces in arbitrary shapes. But you could easily take this to the next level and start to create in that same level definition, arbitrarily shaped, welded together obstacles. But that would be, I think, a next step if you're looking to take this beyond just one level. I would say, think in terms of, how can I get my game world represented in a very simple data like way? Because not only does it make it easier for you to create content, it allows you to shift that burden to somebody else and allow you to give the task of creating levels less to a programmer and maybe more to somebody who has just a design background who isn't as comfortable writing code. And allow you to create the engine that constructs the game world based off of this data. Any questions as to how we've set things up here? OK. So we have the ground, we have a background. A background is just a simple class that renders a static image that you can scroll the image with left or right, but we don't end up using it much. It's relevant in Angry Birds because in Angry Birds they have a camera, and the camera pans left to right depending on how far away the fortress is from your sling shot. So that's in there if you want to experiment with it at all, and experiment with a moving camera. Maybe use timer dot tween to tween the camera or just to have it track the alien if you want larger worlds. But we don't end up using it in the distro as much. Our update function is simple. We update the launch marker, update the world, and then we process all the bodies that we flagged as being destroyed, which we've already seen. We reset destroyed bodies to an empty table because we've processed all of them. We actually remove from our level the obstacle objects so that they're no longer rendered, and we no longer try to reference the bodies that are destroyed. And then notice here too, when we destroy the obstacle, we're playing a sound effect inside this bit of code. So we can just do g sounds. I put five wooden sound effects in there just for variability. It'll pick a random one. And then using to string at the number, just create break one, two, three, four, five here. And then stop and play it. Same thing here. I have a sound called kill for when we destroy an alien. So when we flag an alien as destroyed and we remove it from the scene, we should also call that sound effect. And then if the alien stops moving in our scene, the player, we can get a reference to it here, self dot launch marker dot alien, as opposed to any aliens in our scene. When it stops moving, so we get the average of its velocity and if it's less than 1.5, so not perfectly still, because it's tedious to wait that long, but almost still, we destroy the alien and then we create a new launch marker. We destroy the alien so that the world doesn't keep a reference to it and then we just create a brand new marker, which has the effect of instantiating a new alien there when we relaunch. And then here, if there are no more aliens in our scene, if we've destroyed all of the aliens, in this case there's only ever one, but there could easily, with a little more work, be a few more aliens in the scene, if it's set to zero, then go back to the start. Which we saw before when we finally killed the alien. And then all we're doing here is deferring rendering to the individual objects we want to render, the launch marker, the alien, the obstacle. We render ground tiles. So recall, from our ground example before we were just using a line, an edge shape to represent the ground. But if we look at our game, it's a little hard to see because I'm in 720, but there's actually a ground tile here at the very bottom, a bunch of them. And even though we have all of those tiles, all we're doing to detect collision is just an edge shape. So what we're doing is just beyond having the edge shape in our scene, we draw that tile, which is frame 12 in our sprite sheet from negative virtual width to virtual times 2. So three screen widths total. And then we just do it in increments of 35 pixels because that's how wide the tile is. And that'll just create a bunch of the same tile at the very bottom of our screen. So just a graphical thing, not really necessarily functional. We have the edge shape already in our scene, but just to make the ground look a little larger than one pixel tall. And then if we haven't launched anything, we should display some instructions here. And then if we're at no aliens left, then we should display the victory screen. And the victory thing will last for just a little bit of time, because even though self dot aliens is zero, this bit of code doesn't register until after the velocity of our moving alien slows down sufficiently. So this will get called when we're just about to finally stop moving, and then we check to see, oh, OK, do we indeed have no aliens left? If not, time to go back to the start. We've completed a level. And then you obviously would just change this to go to be next level if you ended up implementing more levels in your game besides just one. Beyond that, that's pretty much all of the code that's in this example. It's fairly, I would say, unsophisticated relative to prior examples. But mainly, the burden is learning how to use the physics engine, the Box2D physics engine, which itself is quite a few functions. It's some of the longest documentation on Love2D's wiki, I think. But the principles are pretty simple, in my opinion. I think it's actually quite easy to get rolling with a lot of cool features. The vast majority of which I don't think we even really cover, at least in terms of what you can do with compound objects and joints and things like that, which really start to go into the world of more sophisticated and interesting physical simulations. Things like I alluded to before, pulleys and tanks and other things like that. Some features that we could look at potentially expanding upon if we wanted to make our game more interesting, is more shapes for our objects. So if we look at our sprite sheet here, we can see there are things like roofs and circles and things like that. So more interesting obstacles beyond just square rectangular shaped obstacles. Go back to like I said before, compound obstacles. So a bunch of things put together via joints. So pulleys, there's motors, weld joints, which you can use to you can affix a roof to a square and then have two pieces that are tied together. And you can make arbitrarily complex and shaped things and just be really interesting. And that big thing, that body with all these fixtures, will collide just as any other thing would, thanks to Box2D. As I alluded to before, instead of having levels to be hard coded into our level class, maybe define them in a Lua file called levels dot Lua. And then just have aliens be a table, obstacles be a table, and then whatever else, however more complicated you want to get with your game. You can add more things. But just have it be represented as simple data structures. So aliens that maybe have different shooting mechanics. So if you've played Angry Birds you're familiar with the fact that some birds will split off into multiple birds. Some birds will dive and go super fast and break through all the obstacles in their path. Some birds will explode, and then their explosion affects all of the obstacles around them. So there's a lot of different game play mechanics you can implement using different types of birds or aliens. And then different obstacle materials is another direction we could go. And it's supported out of the box with the sprite sheet that I provided because it has sheets for metal and glass and explosive material. So there's a lot of different interesting things you could do just by changing up what materials you're using in the game. And obviously those will have different densities and behave in different ways. So assignment five is a fairly simple assignment. So this is just as I alluded to before. The task here is to split the bird that you shoot by pressing Spacebar when it's in the bird the alien, when it's in the air, press Spacebar and have it split into three. So you have your one that you're shooting already. So it should just shoot off two more. One that's angled higher, one that's angled lower. And all of those should be interactable with your game world. And that's really it. So if you can do that then it'll show that you know how to effect the Box2D game world. Next time, next lecture, we'll be talking about the theme is going to be Pokemon, but we'll be talking about more generally RPGs and turnbased games of that nature. It won't maybe necessarily look quite as pretty as this. But we'll be striving for a similar over world that we can walk around and then engage in fairly simple turnbased battles and stuff like that. And also, we'll be talking about user interfaces and things like dialogue and stuff like that. But that was it for lecture six, Angry Birds. I'll see you next time. Thank you.
