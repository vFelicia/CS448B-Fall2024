With timestamps:

00:00 - Zach galwitzer created our extremely
00:02 - popular front-end web development boot
00:04 - camp course now he's back with this
00:08 - project-based course that will help you
00:10 - solidify your understanding of a variety
00:13 - of front-end web development Concepts
00:15 - you'll practice HTML CSS JavaScript
00:18 - typescript react and more so let's get
00:21 - started hey free code Camp my name is
00:23 - Zach and today I'm really excited to
00:26 - share a video I've been working on for a
00:28 - while where I take a tic-tac-toe game
00:32 - and build it in vanilla JavaScript HTML
00:35 - and CSS and then refactor that to go to
00:40 - typescript and then finally typescript
00:42 - plus react this is going to be a super
00:45 - fun tutorial it's going to be long but I
00:48 - hope that you're going to learn a ton
00:50 - from this and get some practical Real
00:52 - World Experience building this with me
00:55 - now this is actually what I would call
00:57 - kind of a sequel to another video that I
01:01 - posted on this very Channel free code
01:03 - Camp a couple months ago I posted a
01:06 - front-end developer boot camp and since
01:10 - then it has gotten over a million views
01:12 - so thank you all for watching that I'm
01:15 - glad that you enjoyed it this video is
01:18 - meant to be a direct follow-up to that
01:21 - because all the lessons that you learned
01:23 - throughout are going to be applied in
01:27 - this video we're going to take all of
01:28 - that stuff and put it into action and
01:31 - give you a project that is a little bit
01:33 - more real world a bit more challenging
01:36 - but a great learning experience as
01:39 - always want to give a big shout out to
01:41 - free code camp for allowing me to come
01:44 - on the channel and giving me the
01:46 - exposure to to teach a broader audience
01:49 - I have a smaller Channel myself you can
01:52 - check that out got a link in the
01:53 - description and I will also make a note
01:56 - that this video is actually three videos
01:59 - squashed together so I originally posted
02:01 - these three on my channel this is just
02:04 - all combined so if you kind of hear me
02:07 - talking about the next video or the
02:09 - previous video that's why and finally
02:12 - there is a GitHub repository I'll
02:14 - mention this a couple times in the
02:16 - description that you should check out as
02:19 - it's got all of the source code that I
02:21 - will be writing in this project as well
02:24 - as some attribution because this was
02:26 - actually originally a subscriber
02:28 - refactor I react I reached out to my
02:31 - subscribers and said hey submit your
02:33 - code I'll review it and redo it and show
02:36 - you how I would approach it so that's
02:38 - how this originally started so thank you
02:40 - Yvonne and Meg for submitting that their
02:43 - handles are also in that GitHub
02:46 - repository so without further Ado let's
02:50 - jump in and build this tic-tac-toe game
02:52 - in this video I'm going to walk you
02:55 - through the step-by-step process of
02:58 - building this tic-tac-toe game which is
03:01 - mobily responsive you can play it on a
03:04 - mobile device and it works across
03:07 - browser tabs leveraging local storage so
03:11 - that you know you can have different
03:12 - players playing from different browser
03:14 - tabs and it also is going to have a
03:18 - bunch of different things such as some
03:20 - animations going on up here you've got
03:23 - some an actions menu that allows you to
03:26 - reset the game and then once you get
03:29 - through and start recording different
03:32 - wins so you don't really have to play on
03:35 - these separate tabs but you can once
03:38 - someone wins you'll see a modal pop up
03:40 - and gray out the entire background and
03:43 - you can click play again you'll see that
03:46 - that state is tracked over time and even
03:48 - if we refresh the browser tab that's
03:51 - going to stay there you can even reset
03:53 - that and make it a new round all of the
03:56 - code that I'm writing here is going to
03:58 - be in this tic-tac-toe subscriber
04:00 - refactor repository that is on my GitHub
04:04 - and I'll drop that in the video
04:05 - description
04:08 - all right so this video is going to
04:12 - cover all sorts of Concepts
04:14 - um this is actually loaded with useful
04:17 - Concepts doing anything with vanilla
04:20 - JavaScript HTML and CSS really requires
04:23 - you to think about things because you
04:26 - don't get all of the backstops that some
04:29 - libraries and Frameworks like react or
04:32 - vue.js give you so it will really
04:34 - require us to think a bit but it will be
04:37 - fun to explore some different concepts
04:40 - and patterns for example we're going to
04:42 - be looking at what is a MVC
04:44 - architectural pattern or model view
04:47 - controller we're going to be talking
04:49 - about what is State what does that
04:51 - actually represent
04:53 - we're going to talk a little bit about
04:54 - event delegation so in other words what
04:58 - that means
04:59 - is when you go to this game and you
05:02 - click one of these squares it's actually
05:04 - registering a click listener on the
05:06 - parent component and then delegating
05:09 - that event so that we can find which
05:11 - Square was clicked so that will be fun
05:14 - to go through
05:15 - mobile responsiveness as I showed you
05:17 - some CSS animations that uh tic-tac-toe
05:22 - grid is actually using CSS grid and then
05:25 - a lot more so all of these Concepts will
05:28 - be fun to go through and if you are not
05:31 - familiar with HTML CSS in JavaScript I
05:36 - recommend you go through my full stack
05:38 - which kind of became a front-end
05:41 - development roadmap and it's like over
05:43 - 21 hours and it's all posted on my
05:46 - channel here and I'm probably going to
05:48 - put this video as the next video in that
05:51 - series because it is a perfect
05:53 - transition from all of those Concepts
05:55 - that we covered throughout that series
05:57 - and applying them in a very real world
06:00 - type scenario to build this game out so
06:03 - this is kind of doubling as a subscriber
06:06 - refactor and just a very useful project
06:09 - to build and learn a bunch of cool
06:11 - concepts with but you definitely have to
06:14 - know HTML CSS in JavaScript at least at
06:17 - a basic level to get through this video
06:20 - and I recommend you watch the prior
06:22 - video where I kind of walk through the
06:25 - original project that this was based on
06:27 - and I kind of talked through what are
06:29 - some of the good things that they did
06:31 - there what were some of the things that
06:33 - could be improved and I'll be
06:35 - referencing kind of back to that to kind
06:37 - of show how we can improve on certain
06:39 - things so I recommend you at least watch
06:41 - the first part of that video or kind of
06:44 - skim through it now I will forewarn you
06:46 - I've put that this is a beginner to
06:49 - intermediate level video
06:51 - um because we're going to be covering a
06:54 - lot of ground here this will be very
06:56 - challenging to you if you are just kind
06:59 - of starting out and I did this on
07:02 - purpose because I think there's not a
07:04 - lot of tutorials out there that really
07:06 - focus on the vanilla side and vanilla
07:09 - just means no extra Frameworks or
07:12 - libraries involved I don't think there's
07:14 - a lot tutorials out there that really
07:16 - show you how to take a vanilla app and
07:20 - actually put some design patterns behind
07:22 - it and do it in a way that you could
07:24 - extend it into the future and you can
07:27 - come back to this project and understand
07:29 - what's going on and have a quick
07:31 - straightforward way to add new features
07:34 - to the game with all that said let's get
07:36 - started this is going to be a long and
07:39 - fun video so I'll put some time stamps
07:42 - in there and
07:44 - um probably want to grab a hot drink and
07:46 - get situated because this is gonna it's
07:49 - gonna take a while so
07:52 - um these brand or this uh repository is
07:56 - the repository that I will post in the
07:59 - put in the video description it has the
08:01 - completed projects so you can see I have
08:04 - a reactory factor that'll actually be
08:05 - the next video where we take our build
08:07 - from this video and we throw that into
08:10 - well not throw it we rebuild it as a
08:14 - react application and show you kind of
08:16 - the progression of how do you go from
08:18 - vanilla to react and what are some of
08:21 - the commonalities and differences
08:22 - between the two and it will really help
08:25 - you understand why we use something like
08:28 - react and why it makes our lives easier
08:31 - as a developer so that's what those are
08:33 - the original is the original project
08:36 - just as a reference
08:38 - um but what I'm going to do is actually
08:40 - create a new folder
08:43 - uh live vanilla build and this is where
08:46 - we're going to be working out of for
08:49 - this video I'll basically be recruit
08:51 - recreating everything here in the
08:54 - vanilla refactor and I may reference
08:56 - this
08:57 - um a little bit here and there just so
08:59 - that we're not getting too far off from
09:01 - that code so just as a forewarning the
09:05 - live build that we're going to do might
09:07 - have like some tiny little differences
09:09 - between the final state that you see on
09:11 - GitHub but overall it will go in the
09:14 - same exact Direction all right so what
09:16 - is the first thing that we do when we
09:18 - start a new project well we're doing a
09:22 - front-end project here so the natural
09:25 - thing to do is create an index.html
09:29 - document but before that I want to do
09:31 - some administrative stuff
09:34 - um with Visual Studio code I'm going to
09:37 - assume that you are using visual studio
09:39 - code
09:41 - um and the reason is because it's an
09:43 - awesome editor and most people use it so
09:46 - the first thing you'll need to do is go
09:48 - over to extensions and open up live
09:52 - server this is an extension that
09:54 - basically allows you to view HTML
09:58 - documents in your browser on Port 5500
10:02 - is the default so you can see that's
10:04 - already running let me go ahead and
10:06 - click close
10:08 - so that'll dispose that
10:11 - um let me get these windows
10:13 - figured out here
10:15 - okay so if you see I reload this it
10:18 - won't reload let's go ahead and close
10:20 - that
10:21 - and then if you go down
10:24 - get rid of my bar down there if you
10:26 - click go live once this live server is
10:28 - installed with Visual Studio it will
10:31 - open up Port 5500 so let's go to
10:37 - this and it'll show you just the
10:39 - directories you're working with so it's
10:41 - just replicating this right here and
10:44 - what we're going to do is click on the
10:45 - live vanilla build right now it's empty
10:48 - so it's not going to show anything but
10:50 - what we're going to do is create an
10:53 - index.html file so we'll say index.html
10:58 - and then we'll use vs code's built-in
11:01 - emit Snippets to type HTML and then
11:04 - we'll click
11:05 - HTML5 to get some boilerplate built out
11:08 - for us
11:09 - now the second thing that I'm going to
11:11 - show you is format on Save and this
11:15 - should be really part of your Dev
11:17 - workflow no matter where you go because
11:20 - it's just useful so as you can see this
11:22 - boilerplate is not indented correctly
11:25 - and when I click command s on my Mac to
11:28 - save you can see that it formats this
11:30 - document
11:31 - so the way that I got that working is
11:33 - through another extension called
11:35 - prettier and prettier is a code
11:38 - formatter used by pretty much everyone
11:41 - at this point or at least it feels like
11:43 - so it's a very industry standard and
11:46 - what you can do is hit command P
11:50 - hit the little bracket or not bracket
11:53 - whatever that carrot and type open user
11:58 - settings and it's right here because
11:59 - I've used it recently
12:01 - don't worry about all this stuff these
12:04 - are the only lines that really matter so
12:06 - you'll add these two configuration lines
12:09 - this is also documented uh in the
12:12 - extension it'll show you right here that
12:15 - you need to add those and once you've
12:17 - added the added those it's going to
12:19 - detect every time you save and reformat
12:21 - the file
12:22 - all right so that is kind of the
12:24 - administrative stuff that we're dealing
12:26 - with
12:28 - um I don't think I missed anything so
12:30 - make sure that you you get set up with
12:32 - both of those things so now that I have
12:35 - saved this we can go back to our live
12:39 - server and we should have an empty HTML
12:42 - document so if you inspect
12:45 - you can see that here the elements and
12:49 - let's just go ahead and change this to
12:52 - vanilla Js
12:55 - T3 for Tic-tac-toe and then we'll go
12:58 - ahead and just put a placeholder
13:01 - P tag in there so you can see something
13:04 - and you can see that when we save that
13:06 - it auto loads
13:09 - um or it you know has hot reloading so
13:11 - that all the changes are reflected
13:13 - immediately in the browser alright so
13:15 - the very next thing that I will always
13:17 - do when I'm starting a project and this
13:20 - is really kind of the starting point for
13:22 - me at least for any project whether we
13:25 - have a back end involved if it's full
13:28 - stack or just like we're doing here
13:31 - where it's just front end
13:32 - I'm going to start with the UI and build
13:35 - the layout for the entire application
13:39 - and I actually have a video on that that
13:42 - kind of explains that process in depth
13:44 - in my front end course on this channel
13:47 - so you can go revisit that if you need
13:50 - but basically the goal here is to build
13:54 - out the HTML structure and then build
13:56 - out the layout with CSS now I debated
13:59 - this in my head a bit of how much time I
14:02 - was going to spend on this portion of
14:04 - the video and I ultimately decided that
14:07 - this is going to be deprioritized a
14:10 - little bit so that we can focus more on
14:13 - the JavaScript patterns behind all this
14:15 - I have plenty of previous videos where
14:19 - we go in depth like in excruciating
14:21 - detail of how to build HTML and CSS how
14:26 - to bring those together and design
14:27 - things and if you watched my front end
14:30 - course the last
14:32 - um a series of videos in that course was
14:35 - all about CSS grid so we're going to
14:38 - leverage that we're going to use that in
14:40 - a real world project here but I am not
14:42 - going to be getting into every last
14:44 - little detail we're going to take some
14:46 - Liberty and do a little bit of copy
14:49 - pasting from this
14:52 - um
14:53 - vanilla refactor that I've already built
14:56 - um as as kind of a precursor to this
14:59 - video that said we're going to take it
15:01 - piece by piece so that you can at least
15:03 - see how it's coming together in the
15:05 - thought process behind that but I will
15:07 - not be typing the HTML and CSS line by
15:10 - line because we will be here for the
15:13 - next 10 years if um if if I do that my
15:16 - videos are already quite long and they
15:19 - do not need to be longer especially when
15:22 - this is not what we're focusing on so
15:25 - let's go ahead and do some copy pasting
15:29 - here so if we look at this index.html
15:32 - this is the final HTML of this project
15:35 - the one that we're going for so the
15:37 - first thing I want to focus in on is the
15:40 - grid so that's the hardest thing to
15:44 - conceptualize with building this out and
15:47 - when I say that grid we're going to
15:49 - actually duplicate this tab so that we
15:52 - have a reference to look at
15:54 - and my
15:57 - vanilla refactor will give us that
15:59 - complete picture that we want and so
16:02 - what we're trying to do here is build a
16:04 - grid that has all of these squares here
16:07 - but then as you can see there's also
16:10 - these uh State variables down here I
16:14 - shouldn't call them State variables but
16:15 - a little scoreboard that lines up
16:18 - perfectly with this grid and something a
16:21 - little bit less obvious up here the
16:24 - actions menu also lines up perfectly
16:26 - with the grid and this player one you're
16:30 - up indicator this spans kind of two
16:33 - sections of the grid so really what
16:36 - we've got here
16:37 - and what we need to replicate is a grid
16:41 - that is let's count it you've got three
16:44 - columns so one two three and then the
16:48 - number of rows is going to be one so
16:50 - this this top kind of header section is
16:52 - going to be one section of our grid then
16:55 - two three four and then this five bottom
16:59 - one so really what we have is a how does
17:04 - this go which one goes first is it the
17:07 - five by three or three by five grid
17:09 - um hard hard to remember that while I'm
17:11 - talking here on video but that's
17:14 - basically what we're going to be
17:15 - building and if I Collapse this finished
17:18 - document so vs code has these code
17:20 - collapse things that can really help for
17:24 - to see kind of how things are structured
17:27 - um so what we can do is collapse
17:30 - everything until it's a lot more clear
17:32 - as to what the grid items are
17:35 - so you can see that my
17:38 - container has a class of grid and that
17:42 - grid is going to give us the display
17:44 - grid so if we go to our index.css
17:47 - and we go to the grid class you'll see
17:50 - that that is initializing the grid
17:52 - container
17:54 - um and let's go back to this
17:57 - HTML and then as we know if you watched
18:00 - that previous series on grid is that
18:04 - grid is going to have child Elements
18:06 - which are called The Grid items now
18:09 - these are direct descendants of its
18:11 - container and as you can see we have one
18:14 - two and then there's nine of these
18:17 - squares and then there's three little
18:21 - scoreboard squares there at the bottom
18:23 - so that's the basic structure but we are
18:26 - not going to start with all of these
18:27 - different styles and markup you want to
18:30 - start simple and the way that we're
18:32 - going to do that is by creating a bunch
18:36 - of divs and just starting with a basic
18:39 - grid here in order to do that we need an
18:42 - index.css file so if you see in the
18:45 - vanilla refactor we've got some folders
18:47 - for the different types of files you
18:50 - don't really need that that was just an
18:52 - organization thing
18:54 - for this rebuild I'm just going to try
18:56 - to mirror that so we'll create a CSS
18:59 - folder and then a new file in there
19:02 - called index.css
19:05 - and then let's go ahead this is
19:08 - something that I always do let's just
19:10 - throw uh an all selector and then color
19:13 - red
19:15 - and that means every text everything is
19:17 - going to be or all the text is going to
19:19 - be red and the reason I do that is just
19:21 - to make sure we're hooked up correctly
19:23 - so let me close all these files out out
19:25 - this index.html is our starter you can
19:29 - see I have a placeholder here and what I
19:32 - need to do is right above the title
19:34 - we're going to add a link
19:35 - and we're going to go down and hit enter
19:37 - on the link CSS and you can see it
19:40 - already knows to go grab the style.css
19:44 - but that's not what we want because we
19:46 - have a custom directory
19:47 - so let's go to CSS and select index
19:51 - save that and now if this is hooked up
19:54 - correctly this should be red
19:57 - so let's go right here and you can see
20:00 - that it is red and it is connected up so
20:02 - the very first thing that we need to do
20:04 - is put in a main
20:06 - HTML tag and the reason that we put the
20:10 - main tag in there is because this should
20:12 - represent the dominant content of the
20:15 - document now if you wanted to figure
20:17 - that out on your own you can just type
20:19 - in mdn main so mdn Main and it'll be the
20:23 - first result and it says it represents
20:26 - the dominant content if you scroll down
20:28 - here on the usage notes it says it
20:31 - should be unique for the document
20:32 - content that is repeated such as
20:35 - sidebars nav links copyright should not
20:38 - be within main so in our case this
20:42 - tic-tac-toe board is the dominant
20:43 - content of this index.html document so
20:46 - we want it inside Main
20:48 - furthermore we'll need a div container
20:52 - which will be the grid container itself
20:55 - and we want to give that a class of grid
20:58 - which we will style within index.css but
21:02 - if you remember let me hit command B on
21:04 - my Mac to close out that sidebar
21:07 - if you remember on this original we had
21:11 - the grid class and then we had all these
21:14 - grid items so we had one two
21:18 - um nine more right here so 11 12 13 14.
21:23 - if I can count basic math right but
21:27 - basically we just need a bunch of divs
21:29 - within here so we can make one command C
21:32 - copy that all the way down and how many
21:35 - is that three six nine eleven
21:40 - okay we'll we'll come back to this if we
21:42 - didn't get that right but anyways we've
21:45 - got the skeleton of our grid and now if
21:47 - we come into index.css
21:49 - we can make that grid class and say
21:53 - display grid another thing that we'll
21:55 - want to do just to start us out is the
21:58 - CSS reset this was in the original
22:00 - project already
22:02 - and we can just copy it over
22:06 - so the CSS reset is just gonna reset
22:09 - everything so that we don't have any
22:10 - weird padding going on and
22:12 - anything like that so let's go ahead and
22:15 - put that at the top
22:17 - and then we can also initialize our
22:20 - fonts and colors like I said I'm not
22:22 - going to spend a ton of time on this
22:24 - portion of the video
22:26 - um I've got prior videos that go into
22:27 - more depth here but basically we're
22:29 - importing uh a Google font right here
22:33 - and then we are initializing our set of
22:36 - colors as CSS variables on the root
22:39 - selector so we'll be able to use that
22:42 - with the VAR and then dash dash whatever
22:44 - variable it is within our CSS so we'll
22:47 - save this we'll come back to our
22:51 - document here and you'll see that it's
22:53 - completely empty which is kind of what
22:55 - we're looking for now if you looked at
22:57 - the vanilla refactor here got it zoomed
23:00 - in way too much
23:01 - it has this darker background so the
23:05 - first thing that we can do is actually
23:06 - actually get that in there and that
23:08 - would be I believe the dark gray right
23:11 - here so let's just copy that over we're
23:14 - going to select the HTML in the body
23:17 - and
23:19 - give it that background color now the
23:21 - reason that we have a hundred percent
23:22 - height this is something that's useful
23:25 - for mobile devices because there's
23:27 - another strategy of 100 of the screen
23:30 - height but that screen height is
23:31 - different on a mobile device versus a
23:33 - desktop and you'll actually get some
23:35 - little padding at the bottom so I prefer
23:37 - to do height of a hundred percent but
23:40 - anyways the main point here is we're
23:41 - giving it that background color and this
23:44 - is actually kind of a mistake from the
23:46 - original we should be just putting in a
23:49 - CSS variable there
23:51 - all right so we'll come back and it
23:53 - looks like we've got our background
23:54 - matching that looks good and now we can
23:58 - start to initialize this grid so at the
24:01 - moment you should be able to find in the
24:04 - main that we have all of these grid
24:06 - items they're just not showing up at all
24:08 - so we need to give them some space
24:10 - within the document so that we can start
24:13 - to work with them so if we wanted to do
24:15 - that the quickest way to come in here
24:16 - and do that is to go right below the
24:19 - grid and then just select any div that's
24:22 - within the grid class and let's just
24:24 - give it a height of 20 pixels and a
24:28 - width of 20 pixels we'll get rid of this
24:31 - in just a moment but oh and then we also
24:33 - need to give it a background color of
24:36 - let's just say red something annoying
24:38 - and you can see there's our grid items
24:41 - we could also give it you know a margin
24:46 - of 10 pixels you can start to see that
24:48 - separation so right there there are our
24:51 - grid items and they obviously don't look
24:55 - near what we want them to so what we
24:57 - need to do is set the boundaries of this
25:00 - grid rather than doing this height and
25:02 - width we can actually dictate how large
25:05 - these items are using the grid container
25:08 - so if you look in our original
25:11 - CSS that was built out
25:14 - you'll see that the grid container has
25:17 - template columns and template rows and
25:19 - then a grid Gap
25:21 - so let's start with the columns we will
25:24 - copy that over and what this is going to
25:27 - do when we say repeat three times 80
25:29 - pixels that means that each column is
25:32 - going to be 80 pixels wide so let's save
25:35 - that and you can start to see that we've
25:38 - got some columns going here and
25:40 - immediately you can see that I've added
25:42 - one too many div elements
25:45 - so we can come over to the index.html
25:48 - and delete those
25:51 - so now we have this perfect grid right
25:52 - here
25:53 - and then
25:56 - we can come back to the CSS and then add
25:59 - our template rows now our template rows
26:02 - are going to be a little bit different
26:03 - so I'll explain this in a second but
26:06 - we'll copy that in and what we're saying
26:08 - is that the first row is going to be 50
26:12 - pixels tall then we're going to have
26:15 - three rows so we're repeating three
26:17 - times the next three rows are going to
26:20 - be 80 pixels tall so that will
26:22 - correspond with our columns so we'll
26:24 - have those perfect squares and then the
26:28 - final row which is kind of like that
26:30 - scoreboard at the bottom will be 60
26:32 - pixels high so that once we save it
26:35 - you'll see that expressed within the
26:38 - grid here and I believe
26:41 - we actually need more grid items here
26:44 - I'm sorry I'm it's hard to count while
26:46 - I'm teaching here but let's make three
26:49 - more
26:50 - and now I think we're getting what we're
26:52 - looking for so we can now get rid of the
26:57 - um explicit height and width of these
27:00 - items
27:01 - because the grid will take care of that
27:03 - so now you can see that we've got the
27:05 - skeleton of this grid but let's go ahead
27:07 - and start isolating things so we want to
27:09 - maybe style the top row as a different
27:12 - color than the main grid and the
27:15 - scoreboard at the bottom so this will
27:17 - evolve and change but just to kind of
27:19 - demonstrate the concepts I'm going to
27:21 - quickly put something in there so for
27:24 - the top three we're going to hit option
27:26 - in click in vs code and that should
27:29 - allow us to click three things at once
27:32 - we'll give these first ones a class of
27:36 - turn
27:38 - and then we'll come down and give these
27:41 - divs here
27:42 - a class of square
27:46 - how many is that three six and then nine
27:50 - so class equals Square
27:53 - and then finally at the bottom we're
27:55 - going to give these a class
27:58 - oops clicking too many things at once
28:04 - we'll give these a class of the score
28:08 - okay so now we'll come back and instead
28:10 - of grid selecting all the divs all the
28:13 - grid items we'll select them based on
28:15 - what they are so let's get rid of this
28:17 - margin also because we will have a gap
28:21 - we'll go ahead and add a gap of five
28:23 - pixels to every grid item so that
28:26 - everything's spaced evenly and then
28:28 - instead of this we're going to say
28:31 - um uh what was it turn was the top row
28:34 - Square was the middle one and then score
28:38 - was the bottom so we'll give these
28:41 - different background colors the squares
28:43 - will stay red we'll make these turn ones
28:47 - green and then the score will be blue at
28:50 - the bottom so we'll save that and then
28:52 - if we come back now we've got all of
28:54 - these highlighted a little bit
28:57 - differently and if you look at the final
28:58 - you can see that this matches almost
29:01 - perfectly but this little
29:04 - turn indicator seems to take up two full
29:08 - columns and in order to get that working
29:11 - we can actually do this within the child
29:14 - the grid item itself we can tell it how
29:18 - many columns to to span at once so we
29:22 - actually have to go to the HTML
29:25 - and
29:26 - um highlight we we can remove one of
29:29 - these div items and keep that as turn
29:32 - and then this will be actions
29:34 - so this will be the little drop down and
29:37 - then this will be the turn indicator
29:40 - so let's save that and it should be all
29:42 - kind of messed up now at this point but
29:45 - here in red that should be our actions
29:48 - menu and if we go to the CSS
29:51 - let's go actions what do we call that
29:55 - actions yep and then this will be a
29:57 - background color of I don't know
30:00 - um
30:00 - let's go purple
30:03 - like that
30:05 - and then finally the turn is going to
30:07 - stay green but we're going to say grid
30:10 - column start and that's going to be one
30:14 - so we're going to start the first column
30:16 - and then grid column end is going to be
30:19 - three so it spans two columns wide so
30:23 - once we do that we should be able to go
30:25 - back and now you see this green is
30:28 - taking up two full columns we've got the
30:30 - actions in the top right scoreboard at
30:32 - the bottom and Grid in the middle so if
30:35 - you compare this right here to our final
30:38 - that's pretty much what's happening we
30:40 - have two spaces here actions full grid
30:43 - and then scoreboard at the bottom so
30:45 - this is the hardest and First Step that
30:48 - you'll do when building any sort of
30:50 - project like this you have to nail the
30:51 - layout and then we can start you know
30:54 - making it look a little bit better
30:55 - arranging it on the screen
30:58 - so I'm going to keep it looking just
31:00 - like this and we're going to continue
31:01 - this process and get it centered within
31:05 - the document and then also make sure
31:07 - that as we resize things you know as you
31:10 - see when we resize it down to this small
31:13 - device it just kind of breaks out we're
31:15 - going to make sure that it resizes
31:17 - appropriately now if you just take a
31:19 - look at the underlying HTML that we've
31:22 - got going on here let's make this a
31:25 - little bit larger
31:26 - you can see that we've got the main
31:28 - container sitting here and then the body
31:30 - container so if we wanted to Center this
31:33 - main container really all we would have
31:35 - to do is go to the body element itself
31:38 - and I believe we can just display flex
31:42 - and then justify content Center and then
31:46 - align items Center and you can see how
31:49 - that brings everything to the middle of
31:51 - the screen so that's generally what
31:53 - we're going to be doing here so if we
31:56 - come back to our project and then if you
31:59 - look at this original so this is the
32:01 - completed version and if we go to the
32:04 - CSS you'll see that on the body element
32:07 - what we've done is we've displayed Flex
32:10 - we've set the flex Direction column so
32:14 - that it's going up and down rather than
32:15 - left to right and then basically
32:18 - aligning everything to the to the center
32:20 - so what I'll do is I'll just copy this
32:22 - snippet here
32:24 - from our completed CSS and we'll bring
32:28 - this to the top or right under HTML and
32:31 - body and then save that and now when we
32:35 - refresh you should see that it looks
32:37 - very similar the last thing that we need
32:39 - to do as you can see we don't have a
32:41 - footer at the bottom so I've added this
32:44 - little attribution at the bottom which
32:47 - provides some spacing so that it pushes
32:49 - this grid up a little bit so we can
32:52 - quickly go add that
32:53 - so if we come to the final uh the final
32:57 - project here I'm just going to copy this
32:59 - footer markup because it's relatively
33:02 - simple doesn't really add a whole lot to
33:05 - this so I'm just going to copy that
33:07 - verbatim and we will put that under the
33:11 - main tag so remember footer is repeated
33:13 - content that if we added Pages we would
33:17 - probably have that on every page so it
33:19 - doesn't belong in the main content of
33:21 - that page
33:22 - so if we save that let's see what we are
33:25 - looking like
33:26 - you can see that the footer has been
33:28 - added down there and that's because it
33:31 - doesn't look good because we haven't
33:32 - added those Styles yet
33:34 - so let's go back to our completed one
33:37 - and I have a section at the bottom that
33:40 - has the Styles just for the footer
33:43 - so let's see they're all right here so I
33:46 - will copy those styles
33:49 - um to our current working CSS
33:53 - so let's go ahead and say footer styles
34:00 - copy those in and then hopefully this
34:03 - will start to look a little bit better
34:04 - so now we've got the workings of our
34:07 - project this is pretty much the skeleton
34:10 - of things and the last thing we need to
34:12 - do is make sure that it resizes
34:14 - appropriately when we're on a mobile
34:16 - device versus a larger desktop device
34:20 - so to do that we will also go to the to
34:23 - the final project here
34:25 - and I'll point you to where this is
34:27 - happening
34:28 - you can see right here I have a media
34:31 - selector and so this we've talked about
34:33 - in the responsive web design uh
34:36 - video that I've done in the past of the
34:40 - front end series and basically what
34:43 - we're doing is we're saying that we want
34:44 - the grid container itself to resize a
34:48 - little bit differently based on what
34:49 - screen we're on so what this rule is
34:52 - saying is any screen that is 768 pixels
34:56 - or higher so basically like a tablet or
34:59 - desktop device
35:01 - we want the grid to have a width an
35:05 - explicit width of 490 pixels because we
35:07 - know we have enough space for that and
35:10 - then we want to explicitly set the
35:12 - columns and rows to be a different size
35:15 - than these Originals
35:18 - so right now if you were to select one
35:20 - of these squares it's 80 by 80. so you
35:23 - can see as we hover over that it's 80 by
35:26 - 80. now on a desktop device we've got
35:28 - some more space so we would want that to
35:30 - be 150 by 150. so let's go ahead and
35:34 - copy that and paste it right under the
35:37 - main grid selector
35:39 - so essentially this will be the mobile
35:42 - Styles and this will be the desktop
35:44 - styles
35:45 - so once we refresh here
35:48 - we're still on a mobile device in this
35:51 - scenario and it looks a lot smaller and
35:54 - then yes it will cut off eventually but
35:56 - really no mobile devices this small so
36:00 - this is about what it would look like
36:01 - and then as we resize you'll see it jump
36:04 - up so let me go into responsive mode so
36:08 - that we can see this a little bit better
36:10 - and watch this up here you'll see as we
36:13 - hit 768 right here it resizes so we have
36:18 - a much bigger game to work with on these
36:22 - desktop devices all right at this point
36:25 - we have the bulk of the
36:28 - um HTML and CSS the structure of our
36:31 - project in the rest of the work that we
36:34 - need to do here is primarily going to be
36:37 - just details of just finessing the look
36:40 - and feel of this until it matches our
36:43 - final product here where you can see
36:46 - we've got this drop down menu that's
36:48 - going to be controlled with some
36:49 - JavaScript you can see when I hover over
36:51 - each Square it kind of uh gets a little
36:54 - bit darker we've got a pointer cursor
36:57 - you can see the mouse is a little
36:59 - different depending if we're on a
37:01 - clickable element or not and then of
37:03 - course as we take a turn watch this up
37:07 - here it will do this little animation in
37:10 - where it kind of Zooms in and then
37:12 - slides out so these are all just little
37:15 - details that we need to add and like I
37:18 - said we've done a lot of in a lot of
37:20 - HTML and CSS work in Prior videos and
37:24 - the main focus of this one is going to
37:26 - be kind of the JavaScript side so I will
37:29 - walk through over the next several
37:31 - minutes of how we take this right here
37:34 - and turn it into this but I will
37:37 - intentionally be moving a bit quicker
37:39 - than normal so be sure to just pause the
37:43 - video If you see something that you know
37:47 - doesn't make sense and just kind of walk
37:49 - through it on your own to understand you
37:51 - know what's happening here I'm just
37:53 - going to be basically referencing the
37:56 - original CSS document in HTML and I'm
37:59 - going to be progressively building this
38:01 - out I'll try to walk you through the
38:03 - thought process as we go but just a
38:05 - heads up it's going to be a bit quicker
38:07 - than usual the first thing that I want
38:09 - to tackle is this green area which is
38:11 - the animated turn indicator now this is
38:14 - obviously going to be controlled by
38:16 - JavaScript at some point but we just
38:18 - want to get the animation right so in
38:21 - order to do that let me close things out
38:25 - this is our working CSS document and
38:28 - working HTML document from here on out I
38:32 - think what I'm going to do is keep the
38:36 - completed CSS here on the right as well
38:40 - as the completed HTML on the right and
38:42 - then we'll close that out so on the left
38:44 - is our working project on the right is
38:48 - the reference to the final one
38:51 - um and I'll I'll try to just kind of
38:52 - hide this a little bit only for
38:54 - reference
38:56 - okay so what we're working on is this
38:59 - div right here so let's go ahead and put
39:02 - some placeholder content in there just
39:04 - so that you see what's going on so
39:07 - there's our placeholder I'm going to go
39:08 - back into a larger mode here so the
39:13 - first thing that we need to do is get
39:14 - this all centered get the text in there
39:16 - looking good so if we come to our final
39:19 - project
39:20 - you'll see that we have this
39:23 - turn class right here so within the turn
39:27 - class we're going to have some font
39:30 - awesome icons
39:32 - and then a turn indicator so
39:35 - we'll copy that in there and if you
39:37 - notice we have these classes fa solid
39:40 - and fax these are being provided by
39:44 - something that we have not added to the
39:47 - head of the document yet so we will need
39:50 - to do that
39:51 - this was taken originally from the uh
39:56 - the Yvonne who submitted this project
39:59 - had put this font awesome uh kit in here
40:03 - so if you just copy this script over
40:05 - right under the style sheet that will
40:09 - add these classes so that they actually
40:11 - show up within the document and give you
40:14 - an icon to work with so once we've added
40:17 - that script these should show up and you
40:19 - can see there's the little X right there
40:21 - so we know that our our icons are
40:23 - working and then finally we need to just
40:26 - style this so as you can see in the
40:30 - original we've got the turn class on
40:33 - there so we need to go down and Ctrl F
40:36 - to find
40:38 - uh let's see where's the turn class
40:42 - here it is okay so we will copy these
40:45 - styles
40:46 - on over we've got some of them already
40:50 - looks like we've got the
40:52 - um so the background color we're going
40:54 - to keep
40:55 - we want to actually display this as a
40:58 - flex container
41:00 - um with a center alignment of the items
41:03 - and a gap of 20. so that's the only
41:05 - thing that we need to add and then we
41:07 - need to align self-center so that's
41:10 - going to tell
41:12 - um the grid where to align things so
41:14 - really what we have here is just some
41:17 - development only background colors this
41:20 - tells it how to align itself when within
41:22 - the grid and then this is the
41:24 - specification for how the content within
41:27 - this container is going to be aligned so
41:29 - if we come back over you can see that
41:32 - it's now looking a little bit better and
41:34 - if we were to remove this background
41:35 - color now you can see that things are
41:38 - looking great this is exactly the
41:41 - alignment and positioning of the final
41:44 - one now obviously there are different
41:46 - colors going on here but we're going to
41:48 - be controlling a lot of that with
41:49 - JavaScript so we can move on from here
41:52 - at this point just for the moment I'm
41:54 - going to turn this to uh let's make it
41:57 - that yellow text so we can give it a
41:59 - color and then use one of our variables
42:01 - and you remember we had defined a
42:04 - variable of yellow here at the top under
42:07 - our root so we should be able to throw
42:09 - that in there and get that yellow color
42:11 - right here and then we need to animate
42:15 - this so in order to do that this is a
42:18 - little bit more intermediate level CSS
42:20 - stuff but in order to do that we need to
42:23 - add some keyframes
42:25 - um in an animation to animate both the
42:28 - icon and the text
42:30 - first though you can see that we have
42:32 - some selectors for the icon in selectors
42:35 - for the text so I'm going to copy those
42:38 - over
42:39 - right under turn so we've got the
42:42 - paragraph text and then the icon text
42:45 - I'm going to get rid of this animation
42:47 - stuff for just a second and save that so
42:51 - now you can see that we've got this
42:53 - looking a lot closer to what's going on
42:56 - here
42:57 - and now we need to do the animation
43:00 - itself so when we do an animation you
43:03 - have to
43:04 - first specify the animation's name
43:08 - on the animation
43:11 - property the CSS property and you'll
43:15 - give it a duration and then some
43:17 - behavior that you want it to have and
43:19 - then of course the reference so for the
43:22 - icon itself that's what we'll start with
43:25 - this is going to
43:27 - um be the animation that makes it kind
43:29 - of pop in and out get a little bit
43:30 - bigger and then smaller so you can see
43:33 - that we have referenced turn icon
43:36 - animation now this is an arbitrary value
43:38 - that we have actually defined as some
43:42 - keyframes so this uh selector right here
43:46 - matches this the need to match because
43:49 - right here you were referencing to these
43:52 - keyframes and what it's saying is that
43:54 - at zero percent of the duration it's
43:57 - going to scale to a hundred percent and
44:00 - then 25 percent into the animation it
44:03 - will scale to 140 percent and then once
44:07 - it's finally done it will scale back
44:09 - down to a hundred percent so it kind of
44:11 - pops in and then comes out and when we
44:13 - save this you should be able to see that
44:16 - so every time we refresh you can see
44:18 - that this little icon is just popping in
44:21 - and out in and out every time it reloads
44:24 - so that icon is going to be complete now
44:28 - the same thing applies for the text
44:32 - we want that text right now all it's
44:34 - doing is popping in and out and then
44:36 - this right here is staying in one place
44:38 - but in the final you can see what
44:41 - happens is that text kind of Fades from
44:44 - the left and animates out so to get that
44:47 - to work
44:49 - um once again we need to copy in the
44:52 - animation so we find our paragraph of
44:56 - the turn selector and copy that in
44:59 - and right now it's going to be the same
45:01 - animation time as the icon just so that
45:05 - they match up same type of behavior and
45:09 - then turn text animation that doesn't
45:11 - exist yet we need to copy that
45:15 - keyframe right here so now that we've
45:19 - defined our keyframes of keyframes in
45:21 - the turn text animation you can see that
45:24 - we're transforming it at zero percent to
45:26 - negative 20 pixels so it will kind of
45:28 - pull it to the left 20 pixels and then
45:31 - as the animation animates it will
45:34 - translate it
45:35 - to go back to its original positioning
45:38 - which is where the final position we
45:40 - want is so once again turn text to
45:43 - animation references this key right here
45:47 - so when we save it now every time we
45:50 - refresh you'll see that animation is
45:52 - happening really nicely so we've got
45:55 - this indicator done now obviously we've
45:59 - gotten X it should be an O so on and so
46:01 - forth but that's going to be controlled
46:04 - with JavaScript and we are not quite
46:06 - there yet now the next thing that we'll
46:07 - do is we'll build this actions menu now
46:11 - once again this is has to be controlled
46:14 - with JavaScript to toggle the open and
46:18 - close Behavior but what we can do for
46:20 - now is just put a placeholder in here
46:23 - that is styled like this and when you
46:24 - click it it won't do anything
46:26 - so in order to get that we'll come back
46:29 - to our original
46:31 - so let's come back to our original
46:35 - index.html document once again this is
46:38 - the completed one and you can see that
46:40 - we've called this menu and we've got
46:43 - some markup within here we've got a
46:46 - button this is going to actually be what
46:49 - is shown and then down here this is
46:52 - going to be the popover that is initial
46:54 - initially hidden and then as you click
46:57 - the button this is going to show and
47:00 - then hide every time you click
47:03 - so what we can do is just copy this
47:06 - markup
47:07 - and I think I've named it something
47:09 - differently so yeah I gave it a name of
47:11 - actions right here
47:14 - but we'll update that in our CSS
47:17 - so let's see this is the
47:20 - drop down menu turn that into a comment
47:25 - this is the turn indicator
47:29 - and then this
47:32 - oops
47:34 - deleted that
47:35 - this is going to be the game board
47:40 - and then finally this will be the
47:42 - scoreboard
47:45 - just a little bit of organization
47:47 - so what I'm going to do is actually
47:49 - comment out the popover just for a
47:52 - minute and work on this button so if we
47:54 - save this right now it's not going to
47:57 - show up very well it's just showing up
47:59 - just like this and when you click it
48:01 - nothing happens we have the correct icon
48:04 - in here and then the correct text but
48:06 - now we need to actually Center this and
48:09 - style it so you can see that I've given
48:11 - this a menu class which in the original
48:15 - index.css we'll go find this
48:18 - um
48:19 - I've just given the menu class a
48:21 - position of relative the reason for that
48:24 - is because
48:25 - um we need that popover that opens to
48:28 - have a relative reference so that it
48:30 - knows where to open relative to in the
48:33 - Dom because it's going to have absolute
48:34 - positioning
48:36 - so we will put this where should we put
48:40 - this here so we've got our turn stuff
48:43 - let's just make a different section so
48:46 - this will be the menu Styles just trying
48:48 - to keep this straight for everyone here
48:51 - so give that a position of relative
48:54 - that's not going to do anything to it
48:56 - it's still going to look the same but
48:58 - then once we add the menu items so if we
49:01 - go back to our markup in HTML
49:05 - you can see that we should have
49:08 - some items those are commented out so
49:10 - we're not quite ready for that
49:12 - Let's see we just need to style the menu
49:15 - button right now and I'll get rid of
49:18 - this just for the moment that's going to
49:20 - come in later as well as this data ID I
49:23 - just don't want to add anything earlier
49:25 - than it applies
49:27 - so the only thing we don't have styled
49:30 - is this menu button so let's find that
49:32 - here
49:33 - there's our completed style so let's
49:36 - copy that in right under menu
49:38 - you can see that we want it to be a
49:41 - hundred percent width and height of its
49:43 - container and if you remember from this
49:46 - original the container that we're
49:47 - working with is what's highlighted here
49:50 - so this is just one grid item so if we
49:52 - say it's a hundred percent of that it's
49:54 - just gonna be 150 by 50.
49:58 - and then we're going to display Flex so
50:00 - the items within it are going to be Flex
50:04 - items and we're going to give them space
50:06 - around and justify them Center
50:09 - so let's go ahead and
50:12 - show you what that looks like for now
50:15 - so you can see that we've got this
50:17 - menu item that's looking a lot better
50:20 - it's got the wrong Styles but we're
50:22 - getting closer
50:24 - so let's come down
50:26 - uncomment these and here we're going to
50:29 - give it a background color I believe
50:30 - this was like a one-off color that
50:32 - didn't fit into the color scheme so
50:34 - that's why I'm defining it here without
50:36 - a variable
50:37 - and then we want the text to be white
50:40 - we want to give it a border and then
50:41 - make that border rounded a little bit so
50:44 - we'll go ahead and save that save the
50:46 - HTML and now you can see that our
50:49 - actions menu is looking exactly the same
50:52 - as this one
50:53 - now the final thing that we have to do
50:56 - um we can't we don't have JavaScript
50:58 - functionality to this yet but we can
51:00 - still uh kind of mock out what this menu
51:04 - looks like so as we click this and open
51:06 - the menu we can still build this even
51:08 - though we don't have JavaScript so to do
51:11 - that all we need to do is uncomment this
51:13 - div
51:14 - and at the moment we haven't styled
51:17 - these classes so it's going to look very
51:19 - weird you're just going to see it right
51:21 - below the actions menu
51:23 - but what we want to do is make this
51:26 - items class and then more importantly
51:30 - it's going to be hidden initially and
51:32 - then our JavaScript is going to be
51:34 - what's responsible for unhiding that
51:37 - so here's what I'm going to do let's go
51:41 - ahead and remove well no let's keep it
51:45 - as is and Define the items class
51:47 - so where is that search for items
51:51 - all right so here are the menu items
51:53 - I've actually selected the any element
51:56 - with an items class that's within an uh
51:59 - element with a menu class you don't
52:01 - really have to do that we could just
52:03 - copy in items directly because we don't
52:06 - have
52:07 - any additional Styles going on there so
52:10 - we've got the menu button that's always
52:12 - going to show and then the items are
52:14 - going to be
52:15 - these items that you can click once
52:18 - they're expanded so there's a couple
52:20 - really important things going on here
52:22 - the first thing is position absolute so
52:26 - because these items are within the menu
52:30 - class the absolute positioning is going
52:33 - to be relative to the nearest parent
52:36 - element that has a relative position on
52:39 - it and as you can see we've given that
52:42 - menu a relative position so these items
52:45 - are going to be positioned absolutely
52:48 - relative to that menu
52:52 - element a little bit confusing but we've
52:55 - gone over that in Prior videos in the
52:58 - series that I built out
52:59 - so we want to give that absolute
53:01 - positioning and a z index of 10 which
53:04 - means that it will sit over the grid of
53:06 - items you don't want that to go behind
53:08 - so the top it'll be 60 pixels offset
53:12 - from the button itself
53:15 - so I'll show you what that looks like
53:17 - let's go ahead and
53:19 - just look at those Styles right there
53:23 - um actually let's let's go ahead and
53:25 - take out everything except for the
53:28 - absolute positioning
53:30 - okay so absolute position
53:33 - you can see that nothing really has
53:35 - happened here quite yet now once we
53:38 - uncomment the rest of this stuff
53:40 - um let's go ahead and
53:44 - comment that out for a second and we're
53:46 - just going to give it a the actual
53:47 - positioning that we want
53:49 - and now you're going to see that things
53:51 - are looking a little bit better now the
53:55 - positioning is going to be relative to
53:57 - this right here so the top left corner
53:59 - so if you see the total height of this
54:03 - button is 50 pixels so that's why I gave
54:06 - it an offset of 60 pixels from the top
54:08 - so it will offset 50 pixels from this to
54:12 - get it to the bottom of the button and
54:14 - then another 10 pixels to give it this
54:16 - little Gap that you're seeing right here
54:19 - and then of course we need to give it a
54:21 - background color a rounded border radius
54:25 - and some padding within the container
54:27 - so you'll see now it's looking a little
54:30 - bit better we still haven't styled the
54:31 - buttons within it
54:33 - um but then finally We'll add the Z
54:36 - index we just want that there to make
54:38 - sure that it's O is sitting on top of
54:40 - these items now the last thing we need
54:42 - to do is style the buttons in there
54:43 - because they don't look very good as
54:46 - you'll see here they're just they're not
54:48 - super well styled or anything but they
54:50 - look a little bit better so in the HTML
54:53 - you can see that we've got a reset
54:55 - button and a new round button
54:58 - these have data IDs on them I'm going to
55:01 - get rid of those because we don't need
55:04 - that quite yet we're just going to style
55:06 - them based on uh their parent so we're
55:11 - going to look for the menu and then
55:12 - items within the menu and then any
55:14 - button that is within that is going to
55:18 - be styled like this
55:21 - so
55:24 - we can actually just remove the menu
55:26 - it'll still work if we
55:28 - do the buttons relative to items so if
55:31 - we save that now you'll see that the
55:33 - buttons are looking a little bit better
55:34 - although you can see we don't have any
55:36 - like hover effects we want the cursor to
55:40 - become a pointer so that the user knows
55:42 - that they can click on them
55:44 - and to do that we're just going to need
55:47 - some hover Styles so if you pop that in
55:50 - there we're going to underline the text
55:52 - and give it a cursor pointer and now you
55:55 - can see that this looks a little bit
55:57 - better in that regard so as you'll see
56:00 - there's no border around this button in
56:02 - the final until we actually click it and
56:06 - once we click it it's been focused and
56:08 - everything's going to have a border so
56:10 - we'll have to wait on that until we have
56:13 - some JavaScript but for now you can see
56:16 - that everything is being aligned
56:18 - correctly
56:19 - and then the last thing we need to do is
56:21 - just create that hidden class because as
56:24 - you can see we've got the hidden class
56:26 - here and then a border class these were
56:29 - shared styles that we would use across
56:32 - multiple elements so I put them in
56:35 - shared utility classes within the CSS
56:39 - file so we'll bring this to the top
56:41 - we'll put it right under the body
56:44 - as shared utility classes and I'm just
56:46 - going to copy these in all right now so
56:49 - we don't have to come back and do this
56:51 - in the future
56:53 - so we'll copy those in just a hidden
56:55 - class that displays none and it has
56:58 - important on it just to make sure that
56:59 - nothing conflicts with it then we have
57:02 - some shortcuts for yellow and turquoise
57:04 - you don't have to do this it's just a
57:06 - little bit easier once we get into
57:08 - JavaScript and then just some standard
57:11 - borders and shadows that we'll be
57:13 - putting on different elements so once we
57:16 - add those you'll see that given these
57:19 - two classes we've put on this it will
57:22 - hide that menu so you can go ahead and
57:26 - remove that hidden right there and it
57:28 - will be showing back up with the Border
57:31 - but for now we just want that hidden and
57:34 - then JavaScript will unhide it for us
57:36 - once we Implement that all right at this
57:38 - point you can see now we've got some
57:40 - conflicting Styles going on over here
57:42 - we'll be sure to come back to that and
57:44 - handle that with some JavaScript as well
57:47 - as our actions menu that we can't really
57:49 - do anything with at the moment it's not
57:52 - really clickable because we need some
57:53 - JavaScript to enable that so we're done
57:57 - with this first kind of row now these
58:01 - grid squares or game board squares these
58:05 - will be relatively easy to style so
58:07 - let's get in and do that real quick
58:10 - so uh here's our game board and then
58:12 - let's go ahead and look at the reference
58:15 - um the final one
58:17 - you can see that I've given each of
58:19 - those a square class which dictates
58:21 - their Styles and then we've put a shadow
58:24 - remember we just defined those shared
58:27 - utility classes and I've defined a
58:30 - shared Shadow class that will apply to
58:32 - everything so that's just kind of
58:34 - keeping the code dry making sure we're
58:36 - not repeating ourselves too much
58:38 - so what I can do is now add those in so
58:43 - once again I'm going to hit hold down
58:45 - option and click through this within vs
58:48 - code to select multiple at once
58:51 - and we will add that shadow class
58:55 - now furthermore we're going to want to
58:58 - give
58:59 - we don't need the IDS quite yet that
59:01 - will come when we add some JavaScript so
59:04 - let's save that and then finally we can
59:06 - get rid of our background red
59:10 - so wherever we put our squares
59:13 - we don't want that background color
59:15 - anymore we want a much nicer looking one
59:17 - so you can see here are our Square
59:19 - colors we wanted to span 100 the width
59:23 - and height of its container which as you
59:25 - can see
59:27 - um this is going to be the grid item
59:28 - itself so we want that to span 100 and I
59:32 - don't think that is actually necessary
59:34 - now that I'm looking at this because the
59:36 - grid will control those so let's go
59:38 - ahead and just copy this gray background
59:41 - I'm going to put a little rounded border
59:43 - and then we're going to make sure the
59:46 - content within is a it's a flex
59:49 - container so that the content is
59:51 - centered within and then the font size
59:53 - is going to be three Rems because we
59:55 - want those icons that are sitting within
59:57 - to be extra large so we'll copy that
60:01 - into the square class save it and now
60:04 - our board just started to look a lot
60:07 - better
60:08 - so you can see that we've got those
60:09 - Shadows that you see on the final the
60:13 - only thing that we're missing here is
60:14 - when we hover over them it doesn't do
60:17 - anything so it doesn't feel like to the
60:19 - user that you can click
60:21 - so in order to cover that we need the
60:23 - hover Styles so that's what this is for
60:26 - the hover style for a square we'll copy
60:30 - that in we want to give it a cursor
60:32 - pointer and then just a 90 opacity so
60:35 - now when we hover it's going to act like
60:38 - it's actually clickable for now we're
60:40 - going to leave the icons kind of off of
60:43 - this at the moment because that's once
60:46 - again going to be controlled by
60:47 - JavaScript when we actually click these
60:50 - um so the last thing we have is the
60:52 - scoreboard down here at the bottom this
60:54 - is relatively simple markup so we'll
60:57 - look at the final project and you can
61:00 - see we've um just got some basic HTML a
61:05 - bunch of div containers with some
61:07 - paragraph text and then a little styled
61:12 - scoreboard where it shows how many wins
61:14 - they have so I'm going to just copy all
61:18 - of this stuff verbatim it's not very
61:20 - complicated you can read through it on
61:22 - your own so we'll put that in the
61:24 - scoreboard section
61:26 - we've already implemented the shadow
61:28 - class in our shared Styles and I've
61:31 - added an inline style here with the
61:34 - color mainly because it's just easier to
61:37 - read it's easier to see that within the
61:39 - HTML what color it is rather than making
61:42 - a different class for each of these you
61:45 - could do whatever you could add this to
61:47 - the index.css but I just thought this
61:49 - was a little more straightforward to
61:51 - read
61:52 - so once again let's get rid of the data
61:55 - IDs for the moment because those are
61:58 - more applicable when we get to the
61:59 - JavaScript
62:01 - so this is our scoreboard and the last
62:04 - thing we need to do is implement the
62:05 - score class because if we come over here
62:08 - you can see that nothing looks very good
62:11 - we've got the different colors but
62:12 - they're not centering the text or
62:14 - styling the text or anything like that
62:17 - so we need the score class implemented
62:20 - which we can go find in the final
62:22 - index.css
62:25 - um all right so here's the score class
62:30 - we're going to replace the background
62:32 - color blue
62:34 - oops
62:35 - we need to get rid of that
62:40 - okay so we're just going to display Flex
62:42 - so that each uh each box is a flex
62:45 - container and we're going to give it a
62:48 - top to bottom Flex Direction and we're
62:52 - going to justify all the content and
62:53 - align all the content to the center of
62:55 - it and then we're giving it a height of
62:58 - 60 pixels which once again I don't think
63:00 - that that was probably left over
63:03 - stuff because the grid should be
63:05 - dictating that and then we're going to
63:07 - give it a little border radius so that
63:09 - it's rounded so let's save and you can
63:12 - see that things show up uh okay here the
63:14 - last thing we need is this text it's
63:17 - obviously not styled very well yet
63:19 - compared to the final you can see that
63:23 - there's a little bold Style on the title
63:26 - and then the number of wins is going to
63:29 - be a little bit smaller
63:31 - so to do that we're going to do some sub
63:34 - selectors
63:35 - so the paragraph text within the score
63:39 - box is going to have a font size of 14
63:41 - pixels and a font weight of 600 if you
63:44 - scroll to the very top where we've
63:47 - imported our Google fonts
63:49 - you can see that we've imported a font
63:52 - weight of four five in six hundred so
63:55 - that's what allows us to use that font
63:57 - weight if you didn't import that then
64:00 - this is not going to do anything
64:02 - so just a note there and then the span
64:06 - element so this is where we actually
64:08 - show how many wins the person has we're
64:12 - going to give it a font size of 12
64:14 - pixels and a little margin on top
64:17 - so we'll save that and now you can see
64:20 - that everything is styled correctly so
64:22 - at this point
64:24 - um looking between the two we pretty
64:27 - much have the same exact design going
64:29 - here and we're uh for the most part
64:31 - completed with this HTML and CSS portion
64:34 - so let's go ahead and scroll through
64:36 - this final completed one and just make
64:39 - sure that we've got everything uh
64:42 - matched up so we've got the footer in
64:44 - here that's that's perfect uh looks like
64:47 - the modal we need to still do I forgot
64:50 - about that so we'll get to that and then
64:53 - in the main content we've got the scores
64:56 - scoreboard right there we've got all the
64:59 - squares for the game board we've got the
65:03 - menu implemented and then the turns
65:06 - implemented and then I think pretty much
65:08 - everything else is done so HTML looks
65:11 - good aside from this modal and then of
65:14 - course we'll add the script once we get
65:15 - to the JavaScript section and then from
65:18 - a CSS standpoint let's go to the top
65:21 - make sure we've got everything we've got
65:23 - the import correct we've got our Styles
65:26 - the CSS reset Global HTML and body
65:30 - styles
65:32 - um
65:33 - uh let's see
65:35 - we added this Global style that looks
65:38 - like it got
65:40 - put in the wrong place so let's go ahead
65:42 - and add that to our shared utility
65:45 - classes
65:47 - um that's not really supposed to be a
65:50 - utility class but that's Global so I
65:54 - forgot to add that
65:56 - and then the grid we've got that done
65:58 - this is the responsiveness we got all
66:01 - the utility classes we added the turn
66:04 - along with the animations
66:08 - we added the menu
66:11 - looks like we covered all of this
66:17 - we got the footer okay so really we have
66:21 - completed everything except for the
66:23 - modal and when I say modal I'm talking
66:26 - about
66:27 - what happens here when someone wins the
66:30 - game so you can see it pops up this uh
66:34 - kind of focused element and then it puts
66:36 - the game in the background makes it look
66:38 - as if this is the only thing that you
66:42 - can click so in order to implement that
66:44 - we obviously need some JavaScript but we
66:47 - can implement it with just HTML and CSS
66:51 - and then we will come back to it once we
66:54 - have some JavaScript available to us so
66:57 - the first thing that you need to do when
66:58 - you're implementing a modal is give it
67:02 - the HTML markup so we will copy this
67:05 - over and you can notice that I'm putting
67:07 - it at the very bottom under the footer
67:09 - and one could argue that this might
67:12 - belong in the main content
67:14 - but really this is going to be hidden
67:17 - initially and it's going to be
67:19 - absolutely positioned or fixed
67:22 - positioning I think so it doesn't really
67:25 - matter where in the document it goes it
67:27 - will show up correctly
67:28 - so I think one could make the argument
67:31 - that it goes in Maine like I said but
67:33 - let's go ahead just to stay consistent
67:35 - and put it at the bottom and then since
67:38 - we've got this hidden class of the you
67:40 - know this will do display none let's get
67:43 - rid of that for the moment just because
67:45 - we want to see what it looks like
67:47 - and if we go back to our project you can
67:50 - see that the modal is right here it's at
67:53 - the very bottom it's got this P tag and
67:56 - then a button that says play again
67:58 - obviously this is nowhere near what we
68:01 - want we want this centered and have a
68:03 - little backdrop so we've got some CSS
68:06 - that we need to write
68:08 - um and if you see in the final we've got
68:11 - all these modal Styles so I'm going to
68:13 - copy all of this over at once at the
68:17 - very bottom
68:18 - give it its own section and then what
68:21 - I'm going to do is just comment things
68:23 - out so that we can progressively see
68:25 - what things are doing here
68:28 - okay
68:29 - so we've got everything copied in here
68:32 - the first thing we need to do is Target
68:34 - the container so this is the div
68:36 - container with the class of modal
68:39 - so what we're doing here with this modal
68:42 - container is we're giving a a display
68:45 - property of flex and then positioning of
68:48 - fixed now fixed positioning is relative
68:51 - to the entire document so what that or
68:55 - the the viewport I should probably say
68:57 - so if we're looking at our viewport this
69:00 - entire screen here is the viewport
69:02 - itself so this is going to be relative
69:04 - to to the entire viewport well something
69:07 - like absolute positioning is relative to
69:10 - the nearest relatively displayed element
69:12 - so in this case since it's a full screen
69:15 - takeover we want this to be a position
69:18 - of fixed we want to give it a width and
69:21 - height of a hundred percent
69:23 - and that will work because up here at
69:25 - the top we have given the HTML and body
69:28 - a height of 100 and it's automatically
69:31 - going to expand the width of a hundred
69:33 - percent just based on how block elements
69:36 - are displayed so by giving it just this
69:40 - stuff
69:41 - display Flex or we don't even need that
69:43 - yet position fixed with 100 height 100
69:47 - let's save that and now you can see up
69:50 - here it has moved so now this takeover
69:54 - the modal spans the entire screen as you
69:58 - can see now we want to take this content
70:00 - and put it right in the middle and give
70:02 - it some styles
70:03 - so what we need to do is uncomment
70:07 - the justify content and align items and
70:11 - then also the display Flex so really we
70:14 - need to bring those up
70:16 - just so that not for functionality just
70:19 - so you can see it all together so
70:21 - display flex and now you can see it's
70:23 - right in the middle and then finally if
70:25 - we give it a background color it's
70:27 - really going to start to pop out so this
70:30 - entire modal has this dark background
70:33 - color
70:34 - now of course we need to style the
70:37 - contents of the modal to also have a
70:39 - background color and that's where the
70:41 - modal contents come in so if you see in
70:43 - the index.html
70:45 - the container within it has a class of
70:48 - modal contents
70:49 - and what we want to do is just uncomment
70:52 - all of this stuff so I'll quickly walk
70:54 - you through what's going on
70:57 - um let's see
70:59 - the first thing let's get rid of that
71:01 - for a moment
71:03 - height with okay let's get rid of these
71:06 - last ones and start with this so the
71:08 - first thing we're doing is giving this
71:10 - container a height of 150 pixels in a
71:13 - width of a hundred percent
71:15 - and then a Max width of 300 pixels so in
71:18 - other words what we're saying here is
71:20 - that by default we want it to be 100
71:22 - width but if the screen is big enough to
71:27 - wear 100 width is larger than 300 pixels
71:30 - then default to that Max width this is
71:33 - just a little trick that I use a lot for
71:35 - mobily responsive
71:37 - um or mobile first CSS and that way it
71:41 - will just look good on everything so
71:42 - let's go ahead and save this and then go
71:45 - back and you can see our our modal
71:47 - content is coming together so to display
71:50 - or to show you what I mean here let's go
71:52 - down to a smaller device and you can see
71:55 - that that's kind of resizing
71:58 - as we are on the smaller device and then
72:00 - as it gets to a bigger one it's going to
72:02 - stop right now it's 238 pixels but once
72:05 - it reaches 300 it's going to stop
72:07 - getting bigger so right there it reached
72:09 - 300 stops getting bigger and it stays
72:12 - centered
72:13 - so that's what this little trick is
72:15 - doing right here now we want to display
72:18 - flex and basically align everything
72:21 - Center so let's get rid of these
72:24 - comments and now this right here should
72:27 - basically Center everything so now you
72:29 - can see player one wins and play again
72:31 - it's all centered so that looks good and
72:34 - then finally we want to give it a flex
72:37 - gap of 20 pixels so that the content
72:41 - within it has some spacing we want the
72:43 - content to have text color of white and
72:46 - then we want the whole thing to have a
72:48 - margin of 10 pixels so let me comment
72:50 - that out for a second here's our spacing
72:52 - white text and then you'll notice on the
72:55 - mobile device once it gets too small it
72:58 - pushes right up against the edge so if
73:01 - we just add a margin of 10 pixels you
73:03 - can see it adds that little Gap there so
73:05 - that's only for mobile device then the
73:08 - last thing we just need to style this
73:09 - button so you can see that I've targeted
73:12 - any button button within the modal
73:14 - contents and just giving it a padding of
73:17 - 10 pixels background color of turquoise
73:19 - text color of something a little darker
73:22 - than that and then some rounded borders
73:25 - so if we save that you can see that the
73:27 - button now has these nice Styles so our
73:32 - modal is complete and if we just give it
73:36 - that hidden class back so if we put
73:38 - hidden on there it's going to be
73:41 - completely gone and then we comment that
73:44 - out
73:45 - and it's back so you can see how our
73:47 - JavaScript is basically going to take
73:49 - that hidden class and it's going to
73:51 - remove it add it back remove it add it
73:53 - back based on when someone wins the game
73:55 - and then the play again button will also
73:58 - trigger a JavaScript action
74:00 - all right so I know I said that I was
74:03 - going to kind of gloss over a lot of the
74:05 - HTML and CSS which I sort of did we did
74:08 - a lot of copy pasting but hopefully that
74:12 - was a good blend of you know how did we
74:14 - get to this final state but not typing
74:17 - every last little letter
74:20 - so if you just toggle between the final
74:22 - one final game right here and our
74:26 - current game everything looks pretty
74:28 - much the same so HTML CSS that's done
74:31 - but obviously when you click anything on
74:34 - this board nothing is going to happen
74:37 - because we haven't hooked up JavaScript
74:38 - which is going to actually control the
74:40 - game
74:42 - um so we want to be able to you know
74:43 - make plays and reset the game and do
74:46 - things like that
74:48 - so at this point I would recommend if
74:51 - you're watching this video to take a
74:53 - little break
74:54 - um because we're going to switch from uh
74:57 - HTML and CSS mode to JavaScript mode
75:00 - which requires a little bit different
75:02 - type of thinking
75:04 - so we're in the JavaScript section but
75:06 - something that happened to me when I was
75:08 - first starting out is I would always
75:10 - just be asking this simple question of
75:13 - when we're looking at JavaScript where
75:16 - do you even start like what's the first
75:18 - thing that you think about when you're
75:19 - trying to connect up some JavaScript
75:22 - functionality to a static HTML and CSS
75:25 - application
75:26 - so looking at this we can click stuff
75:29 - but it's not going to do anything and so
75:32 - the question is where do we even start
75:34 - thinking about adding this these event
75:37 - listeners and you know all the different
75:39 - State Management that happens to make
75:42 - this game work
75:43 - so in asking this question I think the
75:47 - next question that we need to ask is
75:50 - what actions can a user take in my app
75:55 - so we're building a game and there's
75:57 - really three actions that a user can
76:00 - take let's go back and look at the
76:02 - finished game this is the the refactor
76:04 - that I've done that's actually working
76:07 - and if we
76:09 - let's reset everything new round get
76:12 - everything cleared out
76:14 - and the first action that a user can
76:16 - take is they can click on one of these
76:19 - squares on the game board
76:21 - so this is just you know a Player move
76:23 - that is happening
76:25 - so that is the first thing that we need
76:27 - to jot down a player can make a game
76:30 - move
76:31 - now the second thing that they can do
76:33 - once someone actually wins the game so
76:37 - player one wins we play again and you
76:39 - can see down here player one has one win
76:42 - zero ties player two has zero wins
76:45 - so the next action that they can do is
76:47 - hit new round and that's going to clear
76:50 - out this scoreboard down here at the
76:51 - bottom
76:52 - so we can say clear or actually new
76:56 - round
76:57 - and then finally the last thing that
76:58 - they can do is if they started a game
77:00 - and just want to reset it you can go to
77:02 - the reset button and that will clear
77:04 - things out and it won't touch the
77:06 - scoreboard
77:07 - so we can make a new round or reset the
77:10 - current gain so I think with any
77:13 - application any you know front-end
77:15 - project like this that we do this is a
77:17 - great first question to ask yourself
77:19 - just so that you can get a better
77:21 - understanding of these requirements now
77:23 - of course once we have this question
77:26 - answered you obviously have to start
77:29 - writing code to make this happen within
77:32 - your static HTML and CSS
77:34 - so there's a lot of different ways to
77:36 - approach that and ultimately where we're
77:39 - headed by the end of this video is to
77:42 - have some sort of model view controller
77:44 - pattern that's going to help us organize
77:47 - our code to make this stuff happen and
77:50 - handle these events correctly so model
77:53 - view controller is just a pretty common
77:55 - architectural pattern that's commonly
77:58 - used for developing user interfaces
78:01 - so this is actually me from the future I
78:04 - was editing this video and realizing
78:06 - that I had created I had created this
78:09 - diagram to kind of give an overview of
78:12 - the MVC pattern and I didn't actually go
78:16 - through it so this is the MVC pattern
78:20 - model view controller and I wanted to
78:24 - just walk through kind of the the flow
78:27 - of this
78:28 - so as we're building our application
78:31 - there's three separate concerns
78:34 - basically we have the view which as
78:37 - you'll see this is um event listeners
78:39 - that handle either UI only events so
78:43 - like toggling a menu
78:44 - as we'll see here just toggling this
78:48 - actions menu
78:49 - or we can manipulate the Dom and respond
78:52 - to State changes and what happens is the
78:57 - store over here is kind of the the model
79:00 - and this is responsible for getting
79:03 - State and saving State and emitting
79:05 - State change events and this app in the
79:09 - middle is the controller and this is
79:12 - responsible for kind of orchestrating
79:14 - between State and the view and making
79:18 - sure that you know State updates and the
79:21 - view updates all in one concise
79:24 - Consolidated place so I know this
79:26 - probably doesn't make a whole lot of
79:28 - sense so I'll stop here but just keep
79:30 - this in mind come back to it as we go
79:32 - through this build and hopefully this
79:35 - gives you a little visual representation
79:36 - of this pattern we're using now this is
79:40 - going to be a very challenging pattern
79:42 - to implement straight off you know right
79:44 - off the bat and it's not going to make a
79:47 - whole lot of sense so what I've decided
79:50 - to do is almost a contrived example
79:53 - where we basically start with a more
79:56 - naive approach where everything kind of
79:58 - sits in one file and we don't have
80:01 - really any architectural patterns behind
80:03 - this and we're going to progressively
80:05 - iterate on that and get to that MVC
80:09 - pattern that's a little bit more stable
80:11 - so we'll call this the video progression
80:13 - we're going to start with you know a
80:15 - naive approach all in one file
80:19 - then we're going to refactor and iterate
80:23 - as we go
80:24 - and then finally we're going to end up
80:26 - with MVC pattern that is
80:30 - and this is very important it is going
80:33 - to be easy or easier to debug later
80:37 - and it's going to be
80:40 - easier to extend and add features to
80:44 - later
80:45 - now these are really important parts of
80:48 - building software because anytime you're
80:50 - building software you're going to have
80:51 - users that expect things to be improved
80:54 - and fixed and extended you want to add
80:57 - more features so for example in our
81:00 - basic tic-tac-toe game you might want to
81:02 - add some leaderboard over here to the
81:04 - left side or the right side and you
81:07 - might want to be able to add user logins
81:09 - and you know registration and whatnot
81:11 - and being able to do that is going to be
81:14 - very difficult if we haven't planned out
81:17 - a little bit of architecture in a little
81:19 - bit of software design behind what we're
81:21 - doing
81:22 - in other words everything in one file is
81:25 - going to quickly become unmanageable
81:27 - with that said I think we can go ahead
81:29 - and get started now just thinking about
81:32 - this a little bit
81:34 - um
81:34 - let's enter this down so we got some
81:37 - more room
81:38 - what actions can a user take in my app
81:40 - we've defined these and what I want to
81:43 - kind of point out is that these pretty
81:45 - directly oops did not mean to do that
81:49 - these pretty directly map to event
81:52 - listeners on HTML elements so in each
81:55 - case when we look at this
81:57 - we have individual elements so reset is
82:00 - going to be some sort of button new
82:02 - round is going to be a button and then
82:04 - each of these squares on the game board
82:06 - are going to be like a button or a div
82:08 - or something like that
82:10 - in every HTML element has event
82:12 - listeners that you can hook up and then
82:15 - when that event happens you'll put in
82:17 - some JavaScript logic that will maybe
82:19 - manipulate the Dom and update some sort
82:23 - of persistent state in local storage or
82:25 - session storage so on and so forth all
82:28 - right so I think that's enough planning
82:29 - for the moment we're going to kind of
82:31 - come back to this whiteboard a little
82:32 - bit to to plan out some more features in
82:36 - the as we build this out but I want to
82:38 - get started just to kind of jump in so
82:41 - if we're looking at our HTML document we
82:43 - have to ask the question how are we
82:45 - going to add JavaScript to this
82:47 - well theoretically you can put
82:49 - Javascript pretty much anywhere in this
82:51 - document but you will always see a best
82:54 - practice of putting that JavaScript at
82:58 - the end of the body tag in almost all
83:00 - cases and the reason for that is because
83:03 - when we are loading an HTML document in
83:07 - a browser the browser has a bunch of
83:10 - code that's running in the background
83:11 - that actually has to read through this
83:13 - HTML document and parse it and parse all
83:17 - of the elements there and all the Styles
83:19 - attaching those to the elements and it
83:22 - has to actually paint that to the screen
83:24 - now this is called the critical
83:27 - rendering path and I would say this is a
83:30 - more intermediate to Advanced concept
83:33 - that you can kind of check out on your
83:34 - own
83:35 - but the point of this is to say that
83:38 - when we load this HTML document in the
83:41 - browser it's actually going to make a
83:43 - network request to get the document you
83:46 - can see that over in the network tab
83:48 - you'll see this first 200 get request
83:51 - let's make this a little bit larger this
83:54 - is the initiator is the document and
83:57 - it's a type HTML and when we click this
84:00 - it's going to render the HTML here but
84:02 - if we look at the raw response that
84:04 - we're getting this is the HTML document
84:07 - that has been sent over to the browser
84:09 - and the browser has to go through and
84:11 - parse that now why is this significant
84:13 - well the reason being is if we have
84:17 - JavaScript that happens or is placed
84:20 - here at the top of the body what that
84:22 - means is that before the browser can
84:24 - parse any of the HTML and show that to
84:27 - the user they have to run all of that
84:30 - JavaScript that is sitting there at the
84:31 - top of the body and if you've got a
84:34 - large enough JavaScript bundle
84:36 - that's going to block things and the
84:38 - user's not going to see anything in the
84:40 - browser until that's done so that's just
84:43 - a poor user experience and that's the
84:45 - reason that we'll generally put a script
84:47 - tag at the bottom of the body
84:49 - so once we've got the script tag here
84:52 - we can run arbitrary JavaScript in it so
84:55 - we can say hello world and save that and
84:59 - then our live server is going to reload
85:01 - go to the console and you'll see Hello
85:03 - World and just a side note you'll see
85:06 - this get request that's airing out on
85:08 - the favicon we don't even have this in
85:11 - our HTML document the browser just by
85:13 - default is going to look for this
85:15 - because it's kind of a standard so we
85:17 - can safely ignore that but anyways you
85:20 - can see we've got JavaScript running but
85:23 - obviously we don't want to do all of our
85:25 - JavaScript inline here because we're
85:27 - going to have to write enough of it to
85:29 - where this will get pretty cumbersome so
85:31 - ideally what we need to do is make a
85:34 - script that has a source tag and that
85:37 - Source tag is going to point to a
85:39 - Javascript file that we're going to add
85:40 - to our directory so we'll come over here
85:43 - to the live vanilla build add a new
85:46 - folder called Js
85:47 - it could be anywhere but we can put this
85:50 - in and we'll call it app.js you can call
85:53 - it whatever you want main.js index.js
85:56 - any of those work
85:58 - so here let's go ahead and put our
86:01 - console.log
86:02 - hello
86:04 - world
86:06 - save that and at the moment it's not
86:08 - going to do anything if we refresh
86:11 - well I guess we haven't saved the HTML
86:13 - yet so let's save that
86:15 - refresh and you're not going to see
86:16 - anything you'll just see the source
86:18 - attribute of script is empty and that's
86:20 - because we need to populate that with a
86:22 - path to our app.js Javascript file so
86:27 - once we save this you should see
86:29 - everything's hooked up we get Hello
86:30 - World in the browser and we have our
86:33 - basic Javascript file so at this point
86:35 - now that we've got a basic Javascript
86:37 - file set up I want to go ahead and start
86:39 - on these user actions that can happen so
86:42 - remember we've got these three user
86:44 - actions and there's actually a fourth
86:46 - one that we are going to start with
86:47 - because it's probably the simplest
86:49 - implementation and that one is toggle
86:52 - the menu so this new round and reset
86:55 - current game these are part of the menu
86:58 - but we actually have to implement that
87:01 - so that this menu pops open and closes
87:03 - every time it's clicked and that can't
87:05 - happen with just HTML and CSS at least
87:08 - without something crazy going on so
87:11 - that's the first thing that I want to do
87:13 - because it's rather simple to implement
87:15 - and then we'll start working on those
87:18 - user actions and how do we track the
87:20 - state of the game
87:21 - so the first thing that we're going to
87:23 - do is kind of scaffold out our actions
87:26 - and to do that we need to identify the
87:29 - elements that we are going to select
87:32 - so I'll show you a better way to do this
87:34 - in a couple of minutes but we're going
87:36 - to start with kind of as I said the
87:38 - naive approach of what you might think
87:40 - to do first
87:42 - so if we're looking for that menu
87:45 - you're going to come to the drop down
87:47 - menu section of our HTML and you'll see
87:50 - that we've got a div with the class of
87:52 - menu so probably the easiest way to
87:55 - select this element with JavaScript is
87:58 - going to be let's call it menu and we're
88:01 - going to select the document which
88:03 - should be globally available to us in
88:06 - the browser runtime so that should be
88:09 - available
88:10 - and you can see vs code has already kind
88:13 - of detected that this is available to us
88:16 - so it's giving us all this auto complete
88:18 - stuff of the browser apis
88:21 - so we can say
88:23 - document.queryselector and we can select
88:26 - by a class and select any element that
88:29 - has the menu class which we know just to
88:31 - be one div element now from this menu
88:34 - what we can do is add an event listener
88:37 - and we want to listen for the click
88:39 - event and then on that callback we're
88:41 - going to get an event object which has a
88:45 - Target which represents this element
88:47 - right here so if we were to console.log
88:50 - event dot Target
88:52 - we should see when that is clicked in
88:55 - the user interface we're going to see
88:58 - the element itself printed to the
89:00 - console and you can see that we've got
89:02 - the button and if you open this up
89:04 - you'll see all of these different
89:05 - attributes and these are all the things
89:07 - that we can read off of this element
89:10 - Target now to get this to actually
89:13 - toggle down that menu if you remember
89:15 - from our HTML all we needed to do here
89:18 - is go down I'm sorry not there
89:21 - right here
89:23 - this is the menu items and you can see
89:26 - that we've put a hidden class on there
89:28 - so if we were to go back to the browser
89:31 - and select this element and go find that
89:35 - div that is hidden and then we can
89:37 - uncheck this hidden
89:40 - CSS class you'll see that well this
89:45 - actually shows the modal because we're
89:46 - sharing this hidden class with that
89:49 - modal as well so let me refresh and just
89:53 - remove that class for a moment and
89:56 - you'll see that now by default it is
89:58 - showing so really all we need to do with
90:00 - JavaScript is toggle that class on and
90:03 - off every time that button is clicked so
90:07 - this is the class we're targeting
90:09 - but in order to do that we need the
90:11 - ability to select this item so that we
90:14 - can manipulate it so there's multiple
90:16 - ways that we can do this but you can see
90:18 - we've already selected this div element
90:20 - that has a class of menu so we've
90:22 - already got that context within
90:24 - JavaScript in the menu variable
90:27 - now we can use that and select any div
90:30 - that has the items class within it so a
90:34 - simple way to do this is to say menu
90:37 - items and we can say menu dot query
90:40 - selector
90:41 - and then look for the items class and
90:44 - from there we can then manipulate that
90:47 - so when we see that the button on the
90:50 - menu has been clicked we can come down
90:52 - and say menu items
90:55 - and we can say class list and then we
90:58 - have this method available called toggle
91:01 - and we can pass in a class of hidden and
91:05 - that's going to toggle the hidden class
91:07 - back and forth every time the button is
91:10 - clicked
91:11 - so let's see if that works we click this
91:14 - click it again click it again and you
91:16 - can see over here on the right that
91:18 - hidden class is just being added and
91:20 - removed each time
91:21 - so the question is how did I know to do
91:23 - that that's always a good good question
91:26 - to ask and let's go ahead and go to mdn
91:29 - which is our favorite documentation for
91:32 - the web and what are we going to search
91:34 - we want to look for class
91:39 - let's start with element
91:41 - so element is a base class it's the most
91:45 - General base class from which all
91:46 - element objects in document inherit in
91:50 - other words what that's saying is when
91:52 - we do a query selector and get an
91:54 - element back then all of those are going
91:57 - to have are going to inherit the
92:00 - instance properties in instance methods
92:03 - of the element and if you look at
92:06 - instance properties you'll see that we
92:08 - have a class list available to us and
92:11 - from that class list if you look at the
92:13 - value you can see that we have a toggle
92:15 - method so the toggle method of Dom token
92:18 - list removes an existing token from the
92:20 - list and returns false if the token
92:22 - doesn't exist it's added and the
92:24 - function returns true so that's how I
92:27 - would go to find that this is available
92:29 - to us and that's how I knew that we had
92:31 - a class list on the menu items which
92:34 - basically is going to map to this right
92:37 - here that's what we're dealing with in
92:39 - JavaScript and then the toggle method is
92:41 - just a convenience method that allows us
92:43 - to add and remove this class or whatever
92:47 - class we pass in as an argument
92:50 - so just with a couple lines of code we
92:53 - now have some functionality in our
92:55 - application we can toggle this actions
92:58 - menu now of course we can't click we
93:00 - can't click the new round to reset and
93:02 - expect it to do anything because we
93:04 - haven't set click listeners on those yet
93:07 - but what we do know is that we can
93:09 - toggle it now there's already something
93:12 - wrong here and there's nothing terribly
93:15 - wrong but I'm going to start making a
93:18 - list over here if we can remember where
93:20 - this is
93:22 - we'll say let's zoom in a little bit
93:27 - make this a better font
93:29 - so best practices when
93:33 - developing user interfaces
93:37 - all right so the first one that we're
93:39 - going to talk about here is global scope
93:44 - and namespaces
93:46 - so if we go back to our application
93:49 - there's something that's a little bit
93:51 - wrong here and could cause you problems
93:53 - in the future if your app gets bigger
93:56 - and you start splitting this across
93:57 - multiple script files and using similar
94:00 - variables so let's say that we went
94:05 - ahead and added another script to our
94:09 - index.html so let's copy this down we'll
94:12 - say second app.js
94:15 - and over here we're going to add a new
94:17 - file called second app.js that will
94:20 - delete in just a minute
94:22 - and I'm going to Define a variable
94:24 - called menu and this is just going to be
94:27 - some object some JavaScript object
94:30 - Okay so we've got in our second app.js a
94:34 - variable called menu in our in our first
94:36 - app.js we also have menu but they
94:39 - represent two different values so the
94:41 - question becomes which one's going to
94:44 - win which one's going to take precedent
94:47 - or precedence so let's go in here and
94:50 - click our button again and it seems to
94:52 - be working okay so let's go back here
94:55 - and flip the order of these scripts and
94:59 - save it now let's click here and this is
95:02 - no longer working and the reason being
95:04 - is because we have a redeclaration of
95:08 - the menu variable and so it no longer
95:11 - knows what to do because we're trying to
95:13 - set an event listener on a constant
95:16 - object variable because they're
95:18 - conflicting so as you can see this is
95:21 - already a bit of a problem and the
95:24 - problem here is not that we're defining
95:26 - two variables of the same name that's
95:28 - totally acceptable within you know
95:30 - programming it's the fact that we're
95:33 - declaring the same name in the same
95:35 - scope furthermore we're putting it all
95:37 - in the global scope so believe it or not
95:40 - if we would go to this console here and
95:43 - type menu
95:45 - you can see that that value is an empty
95:48 - object and then if we type menu items
95:51 - let's see menu items will be undefined
95:53 - because we're deriving That Base Time
95:55 - menu but let's go ahead and flip this
95:58 - script
95:59 - um oops
96:02 - okay so we're flipping them in the
96:04 - different order so now this menu will
96:06 - work okay and if we type menu it's now
96:09 - back to that element and menu items is
96:11 - going to be another element so you can
96:15 - see that these are available in the
96:16 - global scope which is usually not a
96:19 - great idea so something that your o is
96:21 - going to want to do when you're
96:22 - developing applications is make it into
96:25 - a namespace
96:27 - so when I say namespace all I'm
96:30 - referring to is a one variable that a
96:35 - single name that we can Encompass and
96:37 - store
96:38 - basically put a closure over all of our
96:41 - other variables so that it's not going
96:44 - to expose all these different variable
96:45 - names in the global scope so a way that
96:48 - we can do that is just defining a
96:51 - variable called app and this will just
96:53 - be a basic object to start with
96:56 - and within this app we're going to store
96:59 - some of our selected items and then
97:02 - we're also going to add an
97:04 - initialization method
97:06 - so the first thing we'll do let's get
97:09 - these the menu and menu items on this
97:12 - within this namespace and something
97:14 - that's really nice to do is put a prefix
97:18 - in front of that so we'll just put a
97:20 - dollar sign that's a pretty standard
97:22 - convention that people would use and so
97:25 - this will be a property of this
97:27 - namespace and this is where we're going
97:30 - to put
97:31 - all of our selected HTML elements okay
97:37 - so right here we're going to call it
97:39 - menu and we can say
97:41 - document.queryselector looking for the
97:43 - menu class and then we will also put
97:46 - menu items but now we no longer can
97:49 - derive this based on menu because at
97:53 - this point in the initialization of this
97:55 - object we don't have menu available to
97:59 - us now you could try to do something
98:01 - like app.menu in reference or sorry app
98:05 - dot dollar sign
98:07 - dot menu and then query selector and
98:11 - then look for items so you could try
98:14 - that but if we save that and go to the
98:18 - document here it's going to say unclot
98:20 - reference error can't access lexical
98:23 - declaration app before initialization so
98:26 - in other words we can't reference it
98:28 - here because it hasn't initialized yet
98:30 - so a quick solution to that is to just
98:33 - replace this instead of deriving it
98:36 - based on that element we'll just look
98:38 - for it in the document there's only one
98:41 - element with a class of items so that
98:44 - should not conflict with anything
98:46 - so we've got our selected elements we're
98:48 - looking a lot better here and now if we
98:51 - go back and let's go back down in our
98:54 - index.html and flip the order to where
98:56 - it was broken before and now if we
98:59 - refresh
99:00 - um it's going to say menu is not defined
99:04 - where did we what are we doing here
99:09 - oh I'm sorry that's because the event
99:12 - listener is no longer going to work so
99:14 - let's comment that out for just a second
99:16 - and things should work now you're not
99:18 - going to get any namespace errors this
99:22 - menu is not going to conflict with this
99:24 - menu because this is uh has a closure
99:27 - over it with app as the namespace so
99:30 - let's get rid of second app that was
99:32 - just for demonstration we'll delete that
99:36 - and then in the HTML we can delete that
99:38 - reference so we're back to where we
99:40 - started
99:42 - and now what you'll see is if we go to
99:44 - try to access the menu variable it's not
99:49 - going to be available so I guess there's
99:51 - a built-in called menu bar but menu is
99:53 - not available but if we go to app
99:56 - dot dollar sign dot menu that is how we
100:00 - could access that element that we've
100:02 - selected so now all we have is a single
100:05 - namespace called app and theoretically
100:08 - we could Define that same variable in a
100:10 - different file and it would conflict but
100:13 - it's much less likely and much easier to
100:16 - track all the variables we're defining
100:17 - when we only have one namespace that's
100:21 - covering everything else that we're
100:23 - defining so the next thing that we'll do
100:25 - to make this a little bit better we
100:27 - could of course uncomment this down here
100:30 - and say app dot dollar sign
100:33 - dot menu dot add event listener and save
100:37 - that and then we come here and it's
100:40 - going to say menu items is not defined
100:42 - I'm sorry because I have to reference
100:45 - app.dollarsign dot menu items as well
100:49 - and we're going to toggle this and it'll
100:51 - work just fine now there's one
100:53 - Improvement we can make because right
100:55 - here we're doing this in the global
100:57 - scope so a better way to do this is to
101:00 - make an init method within our app
101:03 - namespace
101:04 - so the init method is going to be where
101:06 - we're going to add event listeners to
101:08 - our application and just to note this is
101:11 - es6 syntax this is just a shorthand way
101:15 - to define a function property on an
101:18 - object that we're calling app
101:20 - so another way to do this would just be
101:23 - a property and then you could add like
101:25 - an anonymous function just like that or
101:28 - you could do an anonymous function like
101:31 - that so on and so forth you could even
101:34 - Define a function up here and assign it
101:35 - there but this is just a quick way to do
101:38 - that shorthand and then what we're going
101:40 - to do is move this initialization logic
101:43 - into that method right here and what
101:46 - that does for us is now it allows us to
101:49 - control when our app is initialized and
101:52 - what we can do here is if we save this
101:55 - this is no longer going to work because
101:57 - we haven't initialized our app but a
102:00 - nice way to do this is say document dot
102:03 - add event listener and we'll wait for
102:05 - the document to fully load and you can
102:08 - see in the documentation vs code
102:10 - populates
102:12 - um
102:13 - actually this is not for the load event
102:15 - but this is basically waiting for the
102:17 - entire document to load so we know
102:19 - things are safe to use and select and
102:22 - then from here we can have a callback
102:24 - function that we'll call app.anit so
102:27 - another way of doing that we could call
102:29 - it like this so app dot init and save it
102:33 - and if we do this it's not going to work
102:35 - and I believe the reason is this should
102:38 - be window instead of document
102:41 - so let's try that looks like it works
102:44 - let's go ahead and look at the reference
102:45 - here so mdn document
102:49 - so we can look at the
102:52 - um
102:53 - document here and then let's look at the
102:55 - events reference
102:57 - so listen to these events using add
102:59 - event listener on the document and it
103:02 - looks like the load event is not
103:05 - available there
103:06 - but if we look at the window if we can
103:09 - find that so let's look at window
103:13 - and then events here and this is where
103:16 - we're going to find the loaded event I
103:19 - believe
103:19 - and you can see here in the load in
103:21 - unload events reference here's the load
103:24 - event we're listening to and that's
103:25 - fired when the whole page has loaded
103:27 - including all dependent resources
103:29 - such as stylesheet images
103:31 - in other words this happens when all the
103:35 - HTML is in the document and we can start
103:37 - selecting it safely
103:40 - so that's why we're listening on the
103:42 - window here and basically we're just
103:44 - listening for the load and then we're
103:46 - initializing our application which will
103:49 - select these elements and add that click
103:50 - listener to our menu now a shorthand way
103:53 - to refactor this rather than this syntax
103:56 - we can just remove this and remove the
103:59 - call and that's a more concise way to
104:02 - write that and we'll have the same exact
104:05 - functionality just like this all right
104:08 - so we have a basic toggle menu that's
104:11 - working but the next thing that we need
104:13 - to do is kind of start on this game and
104:16 - and working on the state of tracking the
104:19 - different moves that a player can do
104:21 - so let's first scaffold out kind of the
104:25 - events that we're going to have to
104:26 - listen to and the elements that we're
104:27 - going to have to select
104:29 - and then we will come back and fill in
104:32 - that logic with an actual implementation
104:35 - so as you know init is where we're going
104:38 - to register all of these event listeners
104:40 - to handle these
104:42 - um user events so what we can do is
104:44 - first Define the elements that we are
104:47 - going to trigger those events on so
104:49 - let's go back to the game and the first
104:52 - two are pretty easy we need to Target
104:53 - the reset button in the new round button
104:56 - so one way that we could do that you can
104:59 - see that we've got two buttons reset in
105:02 - new round
105:03 - so
105:05 - there's no selectors on either of these
105:07 - buttons so what you could do is just add
105:11 - a class but one thing that I'm going to
105:13 - show you here to refactor and we're
105:15 - going to do this as we go is add a data
105:18 - ID so this is a much more stable way to
105:21 - select elements when you're querying
105:23 - them in the Dom
105:25 - so if you go to mdn and type data dash
105:30 - star
105:31 - you will see this attribute which is
105:34 - global attributes form a class of
105:37 - attributes called custom data attributes
105:39 - this allows you to add proprietary
105:42 - information to be exchanged between HTML
105:44 - and its Dom representation in other
105:47 - words we can give data ID or data
105:50 - whatever we want to Define and that's
105:53 - going to allow us to have a stable
105:56 - selector so
105:58 - let's come back
106:00 - first to Excalibur uh Excalibur here
106:04 - so we've got Global scope and namespaces
106:06 - and now let's talk about stable
106:09 - selectors
106:11 - data
106:12 - star attributes
106:15 - okay so what do I mean by that if we go
106:18 - to index.html
106:20 - you know we could select these buttons
106:22 - indirectly by looking for the menu div
106:26 - and then looking for items and then
106:28 - getting the index of the button to
106:30 - select which one we want but a more
106:32 - stable way to do this let's start with
106:35 - menu up here is to just add a data ID
106:38 - and we're going to call this menu
106:41 - so let's save this document and go back
106:45 - to app.js and update our query selector
106:48 - here for menu so instead of selecting
106:51 - the class we're going to select
106:53 - something we'll put some brackets which
106:56 - says we're selecting an attribute called
106:59 - Data Dash ID and that will be equal to
107:03 - menu so let's save that and see if
107:07 - things are working okay in our app and
107:10 - it looks like they are we're allowed to
107:12 - select that and let's break it on
107:15 - purpose so take out that U just to break
107:18 - things and now it's going to say
107:19 - uncaught type air app dot menu is null
107:22 - so you know that this is working
107:25 - and we could also call this whatever we
107:27 - wanted so
107:29 - data custom selector just to demonstrate
107:33 - and you could update this to say custom
107:36 - selector and that's going to work just
107:39 - fine we'll still have that being
107:41 - selected appropriately so data ID is
107:44 - just a convention that Avo has used and
107:46 - I think it's a good succinct one that
107:48 - you can use as well so we're going to
107:51 - put a data ID on each of these elements
107:54 - that we want to select and the main
107:56 - reason for doing this is to have
107:58 - stability so if you changed the name of
108:02 - this class for menu or if you rearranged
108:05 - the HTML elements in the future you
108:07 - don't want all of your JavaScript to all
108:10 - of a sudden break because you changed a
108:12 - style element of your document you don't
108:15 - want to couple those two pieces together
108:18 - and so this is a way to keep things a
108:20 - lot more stable
108:21 - so we'll come down here and add a data
108:24 - ID for this of menu items
108:29 - and then we'll add a data ID for this
108:32 - reset button
108:36 - same thing here oops
108:41 - new round button okay so now we have
108:45 - selectors that are a lot more stable for
108:47 - all those and we're going to register
108:48 - them here
108:50 - so we need two more we need
108:53 - a reset button
108:57 - in the new round button
108:59 - and we're going to just copy these query
109:02 - selectors so we don't have to rewrite
109:04 - that every time
109:09 - and then we'll replace this with menu
109:11 - Dash items is what we named it this one
109:15 - we called it reset button and this one
109:18 - was new round button so if we got that
109:21 - right we should have all of these being
109:23 - selected and we should see no errors
109:26 - within the document and you don't see
109:28 - any errors other than this one we know
109:30 - about and this is working fine so this
109:33 - has been updated correctly at this point
109:36 - it should be relatively simple to add
109:38 - the rest of our actions here
109:40 - so we've already got the event listener
109:42 - for the menu toggling now we're going to
109:45 - select the reset button and add an event
109:50 - listener
109:51 - we want to wait for a click on that
109:54 - and then open up a callback function
109:56 - that receives the event
109:58 - and we'll just say
110:00 - reset the game
110:03 - that'll be our placeholder for now
110:05 - we can just copy this down almost do it
110:08 - verbatim instead of reset button it will
110:11 - be new round button
110:13 - and we'll say
110:15 - add a new round
110:18 - so we've registered those click
110:20 - listeners and now if we open up the
110:23 - actions it'll toggle if we hit reset it
110:26 - will reset the game and if we hit new
110:29 - round it will add a new round so we've
110:32 - got these hooked up okay and then the
110:34 - last thing that we need to do is
110:35 - register a click listener on each of
110:38 - these squares now there's a better way
110:41 - to do this than what I'm about to show
110:43 - you but the way that I'm about to show
110:46 - you is probably the most intuitive in
110:49 - the simplest way to do it so what we
110:52 - will do is let's look at the index.html
110:55 - and find these game board squares that
110:59 - we're trying to select
111:00 - so the quickest way to do to do this is
111:04 - look let's go ahead and add a data ID
111:10 - and I believe we can duplicate these
111:12 - data IDs so let's just call it square
111:15 - and then we'll add that for all of these
111:18 - properties here so I'll hold down option
111:20 - and just click in vs code you can
111:22 - highlight a bunch at once
111:25 - and then we'll add data Dash ID equal to
111:30 - Square
111:31 - okay so now we have a stable selector on
111:34 - all of these and what we can do here
111:37 - in our selectors
111:39 - is say let's say squares
111:43 - and we'll say document but instead of
111:45 - query selector we're going to do query
111:47 - selector all so we want all of the
111:49 - elements that have a data ID
111:55 - of the square
111:57 - and if we go to the init method and just
112:01 - console.log app dot dollar sign dot
112:05 - squares
112:06 - and look at that in the Dom you can see
112:08 - that we have the node a node list which
112:11 - has all nine of those squares
112:13 - represented here now the last thing we
112:16 - don't have a unique ID on each of these
112:18 - we of course have an index to our array
112:21 - but it would be nice if we just had an
112:23 - ID so that we had kind of a coordinate
112:26 - to map this to
112:27 - so one way we can do that is to just
112:30 - click here and go down to each of these
112:33 - and give it
112:34 - a basic HTML ID property or attribute
112:41 - okay so I'll start every all of them
112:43 - with one and then we'll just go down and
112:45 - replace all these
112:54 - so now when we select these the node
112:57 - list is going to have an ID on each of
112:59 - them so we know when they're clicked
113:01 - which ID that we're dealing with
113:03 - so going back we can add an event
113:06 - listener to all of these but since it's
113:08 - a node list we need to iterate through
113:10 - them so we can say app.dollarsine dot
113:14 - squares and then we'll just do a four
113:17 - each so for each Square this should be a
113:21 - node in the Dom so we should be able to
113:24 - say Square dot add event listener
113:27 - and then add a click listener and then
113:30 - the event that is returned from there
113:32 - should give us an ID so let's go ahead
113:36 - and console log
113:38 - square with ID and then we'll
113:41 - interpolate event dot Target dot ID
113:46 - was clicked so we can remove this
113:48 - console log and now what we would expect
113:50 - is every time we click them we will get
113:54 - the ID back of the square that was
113:55 - clicked so this one should be square id1
113:59 - this should be nine so we're going one
114:02 - two three four five six seven eight nine
114:04 - so let's click one
114:06 - and you can see square with id1 was
114:08 - clicked go down here square with id9 was
114:11 - clicked so that's a pretty simple way to
114:14 - register an event listener there for
114:16 - each of those squares so now going back
114:18 - to our initial question that we had
114:20 - asked
114:21 - let's go over to what actions can the
114:24 - user take in the app we came up with
114:26 - four of them a player can make a game
114:28 - move new round reset current game and
114:31 - toggle menu and if we now look at our
114:33 - init method we have four events that are
114:37 - being listened to on different Dom
114:39 - elements
114:40 - so one organization method that we can
114:43 - use instead of putting this all in the
114:45 - init method we'll leave the init method
114:48 - there and Define a new one and let's
114:50 - just call this register uh
114:55 - register events or event listeners or
114:59 - something like that
115:00 - and this is just going to be an
115:03 - organizational uh technique here where
115:05 - we can just put all of that same type of
115:08 - functionality
115:09 - within that method and then we'll keep
115:11 - the init method pretty clean so all
115:14 - we'll say is app.register event
115:15 - listeners
115:16 - so now what's happening is when the
115:19 - window loads the document we're going to
115:22 - call init and a knit is going to
115:25 - register all of those event listeners
115:27 - for us and if we go back to our app we
115:30 - should be able to toggle this reset the
115:33 - game
115:34 - new round and then click any of these
115:38 - squares and get an ID returned from the
115:40 - squares so at this point we have a
115:42 - template for our application and we've
115:45 - stubbed out some methods that we're
115:47 - going to need to implement so as you can
115:49 - see here we basically we've got this one
115:52 - done
115:53 - this is toggling the menu so we'll call
115:55 - that done I'll just add some comments
115:57 - here so we can track this one is going
116:00 - to be a to do item
116:02 - because we have not implemented what
116:04 - happens when we reset the game or add a
116:06 - new round
116:07 - and then this bottom one is also to do
116:10 - um but this is probably what we're going
116:12 - to work on next but speaking of what to
116:15 - work on next that is a really good
116:17 - question as you're building an app like
116:18 - this how do you know what comes next
116:21 - well in this case we can kind of go
116:24 - through the process of elimination with
116:26 - these actions reset and new round those
116:29 - are not going to be possible to
116:31 - implement until we have a functioning
116:34 - tic-tac-toe game that we can actually
116:36 - reset
116:37 - so let's go back to our notes here and I
116:41 - want to take a minute to go off of this
116:44 - point here
116:46 - let me get my arrows worked out here not
116:49 - super familiar with how to use this
116:51 - quite yet
116:52 - so we're going off of this point of
116:54 - player can make a game move so the next
116:57 - question we've got to ask is what is a
117:01 - game move well there's a couple
117:04 - considerations that we'll have to think
117:06 - about here
117:08 - one being how do we determine who is up
117:12 - who is the player that is up next so let
117:15 - me add that as a requirement here
117:18 - um who is currently up
117:21 - the next thing we want to know is did
117:24 - the latest move cause a tie or a game
117:28 - win
117:30 - and then we also want to know
117:32 - who won or was it a tie
117:37 - and then what else can we think about
117:39 - here let's go to our final refactor the
117:42 - one that's actually working here up here
117:45 - this is our question of whose turn is it
117:47 - we need to know that so we can display
117:49 - that we also need to know that so we
117:51 - know which icon to display when it's
117:55 - clicked and then as you see we have a
117:58 - modal that pop up pops up when someone
118:00 - actually wins the game so we need to
118:02 - know when that happens and then at that
118:04 - point when we click play again we need
118:06 - to be able to reset all of the state to
118:10 - a blank fresh game so those are the main
118:13 - questions that we have to ask
118:16 - um so who is currently up this is for
118:19 - the turn
118:21 - indicator icon to play
118:25 - um and I think that's pretty much it so
118:27 - we'll take these step by step because
118:31 - um it's kind of tough to think through
118:32 - all of this at once
118:34 - as you get more advanced in building
118:36 - these things you can probably map all
118:38 - this stuff out from the beginning and
118:41 - that's kind of my first step when I'm
118:42 - building this is trying to map out what
118:45 - does the state of this application
118:47 - require and what do I need to track
118:51 - um one thing I'll add here is also the
118:54 - question of what state do I need to
118:58 - track
118:59 - so we'll talk about this concept a
119:02 - little bit here in a minute but I'm
119:04 - going to kind of organically talk about
119:06 - this throughout the rest of the video
119:07 - because it's quite challenging at times
119:10 - if you're not super familiar so when I
119:12 - say state I'm really just talking about
119:15 - you know what does the current state of
119:18 - the game look like so that might be
119:21 - things like
119:22 - um current player might be total wins by
119:29 - player
119:31 - we can also track total type here total
119:35 - ties and then prior game history those
119:41 - kind of things are the things that we'll
119:42 - want to track and to do that we're going
119:46 - to just build this you know step by step
119:48 - and we'll eventually come to some sort
119:50 - of model that we'll use to track that
119:53 - state so not going to talk too much
119:55 - about that at the moment let's dive in
119:57 - and start building this out and you'll
119:59 - start to see how this makes more sense
120:02 - in a minute
120:04 - so the first thing that I'm going to do
120:06 - is try to implement a basic move so in
120:11 - other words I want to display an icon in
120:14 - these squares when they're clicked we're
120:16 - obviously already registering event and
120:18 - getting the ID of the square that was
120:21 - clicked so that is useful to us but we
120:23 - need to change the Dom or the UI when
120:27 - that happens
120:28 - and to do that the first thing I will
120:31 - generally do is go to the HTML and just
120:34 - mock something up so just figure out how
120:37 - to statically display that for the first
120:39 - time
120:40 - so I believe all we're going to need to
120:42 - do is put in an I tag with a class
120:46 - and then that's going to be one of our
120:48 - font awesome icons so let me just check
120:52 - my references right here to see which
120:54 - icon we're dealing with
120:56 - okay so it really should just be fa
120:58 - solid is the base class and then it's
121:01 - going to be fax or FAO so we'll uh
121:05 - simulate both of those here just to make
121:08 - sure that our game board is going to
121:09 - display things correctly
121:11 - so fax and FAO
121:14 - and you can see that we've got those
121:16 - displaying correctly so this is the
121:18 - right size obviously these are not the
121:21 - right colors
121:22 - if we were to open up our CSS if you
121:25 - remember from earlier in the video we
121:27 - had some of these shared classes here at
121:29 - the top somewhere and in these shared
121:32 - utility classes I gave us a yellow and a
121:36 - turquoise class just so that things are
121:38 - a little bit easier to deal with and
121:41 - easier to remember so what we can do is
121:44 - just pass in yellow
121:46 - and then turquoise
121:49 - into that class list and then our X's
121:52 - and O's will be the right color now
121:54 - obviously you can see we've got
121:55 - mismatches just about everywhere we'll
121:57 - get that worked out in just a moment
122:00 - so if we're trying to do this with
122:02 - JavaScript obviously we can't just
122:05 - statically put in these different icons
122:08 - we're going to basically build these
122:11 - elements and add them as children to the
122:14 - appropriate div that has been clicked so
122:18 - what I'm going to do is open up app.js
122:20 - again
122:22 - and right down here in our event
122:24 - listeners for each of the squares I'm
122:27 - going to just copy over this HTML and
122:30 - add it as a comment and that's just for
122:32 - reference so that we can look at it and
122:35 - translate it into JavaScript
122:37 - so we've got fax and then FAO
122:42 - these are the two that we're dealing
122:43 - with
122:44 - so we can get rid of those here in the
122:46 - HTML
122:48 - and then in app.js we know which ID was
122:52 - clicked and the event itself carries a
122:55 - Target which represents the individual
122:58 - square that was clicked so what we could
123:01 - do just to start us out
123:03 - is actually derive that or not derived
123:06 - but create this I tag so let's call it
123:10 - an icon and we can say
123:12 - document.create element is one of the
123:16 - built-in browser API or Dom methods and
123:20 - we just need to give that a tag of I
123:23 - so we've created the element and then we
123:25 - can say icon I'm sorry not redefining it
123:28 - we can say icon.class list and then I
123:31 - believe we can just
123:33 - um add an array of tokens and what that
123:37 - would be the classes themselves
123:40 - so we would want to add f a solid
123:43 - f a x and then let's say yellow so we're
123:47 - just kind of hard coding an element
123:48 - we'll hard code a yellow X in this case
123:52 - and then from here we've created the
123:55 - element but we need to insert it into
123:57 - the Target that was clicked so really
124:00 - what we could do is just say
124:01 - event.target dot replace children
124:05 - and then I think we can just pass in the
124:07 - icon so that should work let's go ahead
124:10 - and click
124:11 - and you can see something's going on
124:13 - it's not working so let's inspect
124:16 - you can see there's some sort of content
124:18 - in these div elements
124:20 - and it looks like our icon class or icon
124:22 - element has been added but the class
124:24 - list has commas
124:26 - so we need to not do it that way we're
124:31 - not supposed to pass an array I guess
124:34 - maybe we're just supposed to pass
124:38 - um multiple arguments let's try that
124:41 - okay so that's working better and now
124:44 - you can see that the
124:46 - content within here or where did we go
124:50 - the content within the one we clicked
124:52 - has the correct class list now so now
124:55 - anytime we click any of these we're
124:56 - going to get a yellow X
124:58 - and obviously this is not useful yet
125:01 - we're just filling them up with x's and
125:04 - if we click them twice we also can have
125:07 - problematic Behavior because
125:09 - we're not checking to see if there's an
125:11 - X already there we're just adding it no
125:14 - matter what so that is problematic but
125:16 - at least we've got something working
125:18 - here
125:19 - so ideally what we want to do is know
125:22 - whose turn it is and then depending on
125:24 - that turn we'll choose either fax or FAO
125:29 - and then the yellow or turquoise color
125:31 - and at this point we've finally reached
125:34 - a place where we can start talking about
125:36 - what state is and what state management
125:39 - really represents here for us
125:42 - so to do that I'm going to pop over to
125:45 - the Whiteboard again and we're talking
125:48 - about game moves and what state do I
125:51 - need to track well I think the next
125:53 - question really is
125:56 - what is state
125:58 - well there's really two types of state
126:00 - that we can talk about so we have client
126:03 - State and then we have server State and
126:07 - these are very loose terms so there's a
126:10 - little bit of an overlap between the two
126:12 - but these are the two kind of
126:14 - categorizations that I would be using so
126:17 - when we're talking about client state
126:20 - the way that I think about that is any
126:24 - sort of
126:25 - um
126:26 - uh state that we have within the Dom
126:29 - that does not need to change anything
126:32 - that is persisted long term so I guess
126:36 - that's a complicated way of saying
126:38 - something like this actions menu popping
126:41 - open and closed every time we open and
126:44 - close this the client-side state is
126:47 - changing
126:49 - but we're not actually doing anything
126:51 - you know to persist that change so if we
126:54 - opened this actions menu up and then
126:56 - refreshed the page it's going to close
126:59 - every time because we're not tracking
127:01 - that state across browser refreshes it's
127:04 - just temporary in-memory state that
127:07 - we're tracking so in other words client
127:09 - state
127:10 - a good example of that let's just
127:14 - make an example over here
127:16 - let's add some code here so let's say
127:19 - client state
127:22 - equal to and make this a hopefully was
127:25 - going to get that a little smaller but
127:27 - let's open up some brackets
127:31 - so client State might be something like
127:34 - is menu open and we'll start that with
127:38 - false and so as you can see when we
127:41 - click this menu that state variable is
127:44 - going to update it's going to be either
127:47 - open or closed true or false and that's
127:50 - not going to persist across browser
127:53 - refreshes now server State and server
127:57 - again is kind of a loose term here
127:59 - because we don't actually have a server
128:01 - we're going to be working with local
128:03 - storage to kind of emulate that but
128:06 - generally server state is kind of what
128:09 - you would think of as a database so it's
128:11 - a snapshot in time it's a snapshot of
128:15 - what the current data looks like
128:17 - so this would be more conducive to
128:20 - something like a game move so we could
128:22 - copy this down
128:27 - foreign
128:29 - State could be something like a current
128:33 - player
128:34 - and let's just put an ID in there let's
128:37 - say player one is the current player and
128:40 - then we could also add things like we've
128:42 - got the current player how about the
128:45 - history of games so we might have an
128:48 - array filled with all the different
128:50 - games that we had played in the past
128:53 - we could also track things like
128:56 - um we can also track things like the
128:59 - current game so this might be an array
129:02 - of game moves that have happened and
129:05 - that way we can track across browser
129:07 - refreshes you know who has moved in
129:10 - which Square
129:11 - so these two types of State we're going
129:13 - to need to track and we're going to
129:16 - eventually refactor this to be a little
129:18 - bit more stable but as I said in our
129:21 - kind of game plan over here in this
129:24 - video progression we're doing everything
129:26 - in one file as a naive approach and then
129:29 - we're going to refactor it to be a
129:31 - little bit more stable so what that
129:33 - looks like for us in terms of state I'm
129:36 - just going to create a state property on
129:40 - the app
129:41 - okay and to start out state is not going
129:44 - to be persistent across browser
129:46 - refreshes because this is just a
129:48 - variable and every time we refresh this
129:51 - is going to be re-initialized and
129:52 - reassigned so the first piece of state
129:56 - that we want to track is current
130:00 - player and for now I'm just going to
130:03 - keep things very simple and we're going
130:05 - to say that each player is represented
130:07 - by a number it's going to be either one
130:09 - or two so we'll say that player one is
130:13 - going to always start the game so we'll
130:15 - track the current player and that alone
130:18 - will allow us to decide down here in our
130:22 - event listener which icon that we need
130:25 - to put in the Square
130:26 - so obviously we need to update that
130:29 - state each time a move happens so if we
130:32 - were to
130:34 - um
130:34 - we'll leave this console log here but
130:37 - every time something is clicked what
130:39 - we're going to need to do is say the
130:42 - current player is going to be equal to
130:46 - app.state.current player now you don't
130:49 - need to save that to a variable I'm just
130:51 - doing that to kind of be a little more
130:53 - clear here
130:54 - and then we're going to say if the
130:57 - current player equals one
131:00 - we're going to add a certain element to
131:03 - the Dom otherwise we'll just assume
131:05 - there's only two players here we'll add
131:08 - a different one so in this case let's
131:11 - just say that player one is going to be
131:13 - a yellow X so we can create the icon no
131:18 - matter what because
131:20 - it doesn't matter that's not styled at
131:22 - all but the class list is what we're
131:24 - going to use based on the player so if
131:26 - it's player one we're going to have a
131:29 - yellow X and if it's player 2 we're
131:31 - going to have a turquoise o
131:34 - so we'll put in turquoise right there
131:37 - but the thing is we need to of course
131:40 - update that state every time this move
131:42 - happens so we'll go ahead and create
131:45 - this icon add the class list and then
131:48 - what we're going to do here is say app
131:51 - dot state DOT currentplayer
131:55 - is going to be set equal to whoever is
131:58 - not playing this move so in other words
132:01 - if let's say the current player is one
132:03 - and has created you know this class list
132:07 - so we're going to say if the app dot
132:11 - state that current player equals one
132:13 - then we're going to set the current
132:15 - player equal to two otherwise we're
132:18 - going to set it equal to one so in other
132:20 - words it's sort of just a toggle on
132:22 - who's playing the game and then finally
132:24 - we'll take the event Target which is the
132:26 - square and replace the contents of that
132:30 - square with the appropriate icon and so
132:34 - next time this is clicked we'll know
132:37 - which player to use so I'm going to also
132:41 - log this up top
132:43 - we'll say the current player is and then
132:48 - we'll say
132:50 - app.state.current player so we can get
132:52 - rid of these down here
132:53 - and then there's one more important
132:55 - thing as you saw earlier we can't play
132:57 - in a square twice so we need to know if
133:01 - the square already has some sort of
133:04 - element within it let's go ahead and
133:06 - just save this and see what we're
133:08 - dealing with now in our game
133:11 - so we'll click a square and then the
133:14 - next one should be an o
133:16 - and it is and that's because we've
133:18 - updated the state every time we see a
133:21 - new play now I think if I'm not mistaken
133:24 - what's going to happen if we click this
133:26 - twice
133:27 - so let's say that we click this Square
133:29 - again it's going to add an X to next to
133:34 - the O which is obviously invalid and now
133:36 - it's going to think that the O's turn is
133:39 - up even though X should still be up
133:41 - because they played in the wrong spot so
133:44 - that's obviously a problem and the way
133:46 - that we fix that is basically putting a
133:49 - check within this click event and we're
133:53 - just going to say is there something in
133:55 - that square and if so we're going to
133:57 - return early and we're not going to
133:59 - allow the player to actually play
134:01 - and this will prevent us from updating
134:03 - the current player in state and it will
134:06 - force them to replay before the next
134:09 - player can go so the question is how do
134:11 - we check that well we're going to
134:14 - eventually do this to be
134:16 - um we're going to eventually check this
134:18 - in a much more stable way but for now
134:22 - I'm just going to keep things simple
134:23 - we're going to go to mdn and go back to
134:26 - the element reference
134:28 - so elements reference
134:31 - oops I clicked the wrong one I just want
134:34 - literally the element class
134:37 - so which one is that
134:41 - I think this will work so we've got
134:43 - element.get attribute now we can look
134:46 - through all of the different methods
134:48 - that are available on
134:50 - an element and there should be one to
134:53 - check if there are children already
134:55 - within that element I'm not finding it
134:58 - here so I'm just going to search what I
135:00 - know here has child nodes and we're not
135:03 - finding it on element because it exists
135:05 - on the base class of node
135:07 - this is like the abstract Base Class pun
135:11 - which many other Dom API objects are
135:13 - based so basically any element as it
135:17 - mentions here will inherit all the
135:19 - methods of node
135:21 - so we can use this has child nodes
135:23 - method and this returns a Boolean value
135:26 - indicating whether the given node has
135:28 - child nodes or not
135:30 - in other words what we can do here is
135:32 - the first thing we do is say if
135:36 - event.target dot has child nodes
135:40 - so if there's any X or o in there we're
135:43 - just going to return we're not going to
135:45 - update anything we're not going to
135:46 - update the state we'll just return from
135:48 - that function early so by adding that I
135:52 - believe we should get the desired
135:53 - Behavior here so we'll click one click
135:56 - two and then try to click this one again
135:59 - and it's not working let's see why so I
136:02 - had to pause the video to figure out
136:04 - what was going wrong here and it's a
136:06 - little bit tricky bad programming on my
136:09 - part but basically what happened here
136:13 - is when we clicked on the icon itself
136:17 - you can see if I like specifically click
136:20 - on one of these icons it's going to
136:22 - continue adding icons now if I click
136:25 - somewhere else in the Square it's going
136:28 - to have the correct behavior and what's
136:31 - actually happening here
136:33 - is the event Target so right here is
136:38 - going to represent what was actually
136:40 - clicked so the element that was actually
136:42 - clicked in the Dom now the square up
136:45 - here is going to represent the square
136:47 - that we're actually looking to Target
136:49 - for this Behavior
136:51 - so if I were to
136:53 - console log this
136:55 - let's go ahead and say
136:59 - um console log
137:03 - we'll say the square
137:05 - and then we'll pass in the Square itself
137:08 - and then we'll console log the event
137:12 - Target
137:14 - and then we'll pass in event dot Target
137:17 - now what you're going to see is as we
137:20 - click right here
137:22 - the square
137:23 - is going to represent that div and the
137:26 - event Target represents the div because
137:28 - we clicked on the same thing now if I
137:31 - put the mouse in the middle of that icon
137:33 - remember we now have a new HTML element
137:37 - right here if I click that it's going to
137:40 - register the event Target as that I tag
137:43 - rather than the div so what you'll see
137:47 - here is that the square and the event
137:48 - Target will not match up when I click
137:51 - this and we'll have that weird Behavior
137:53 - so you see the square is the div and the
137:56 - event Target is the actual icon to make
137:59 - this Behavior more stable
138:02 - and just better programming practice in
138:04 - general
138:05 - we should be updating the square element
138:07 - itself and not relying on the event
138:10 - Target because we can't control whether
138:12 - the user is going to click
138:14 - the icon or the square we need it to
138:16 - work no matter what
138:18 - so let's remove these console logs and
138:21 - then instead of checking whether the
138:23 - event target has child nodes we're going
138:25 - to check if the square has child nodes
138:28 - and then furthermore where we're
138:30 - replacing the children down here we
138:33 - don't want to replace the event targets
138:35 - children we want to replace the square
138:38 - so that will make all of this Behavior a
138:41 - lot more stable and when we save this we
138:44 - should be able to click in any Square as
138:47 - many times as we want and you can see
138:49 - our console log is going to say the
138:51 - current player is one still so if I'm
138:54 - clicking any of these the turn is not
138:57 - changing the Turn Only changes when we
139:00 - the player clicks a valid square and
139:03 - then we're going to have a different
139:05 - current player so we've got this working
139:08 - this is kind of some boilerplate for
139:11 - what we're going for we will refactor
139:14 - this to be a little bit more stable some
139:18 - better practices but for now this works
139:20 - just fine I'm going to clean this up we
139:22 - don't need these console logs anymore
139:25 - um the next thing that we're going to
139:26 - need to do
139:28 - is if we just keep clicking these and
139:31 - playing the game
139:33 - you can see when the O player I think
139:36 - that's player two when they win the game
139:39 - nothing happens and that's because we
139:41 - haven't programmed anything to happen so
139:44 - we need a way to detect when this game
139:47 - ends and there's going to be different
139:49 - patterns that represent a winning game
139:52 - and then of course we can also if we
139:54 - refresh reset everything we can also end
139:57 - up in a tie so I believe if we
140:01 - let's see if I can even produce a tie
140:03 - here
140:04 - um
140:06 - requires a little bit of thinking to do
140:08 - that so in this case the game should be
140:11 - a tie and we should be able to recognize
140:13 - that now they're in the original project
140:17 - that I'm I was refactoring here they had
140:21 - a pretty nice way of handling this and
140:24 - they'll want to highlight that
140:25 - so if we open up main.js from the
140:28 - original project
140:30 - um what they were doing to check whether
140:32 - the game was won is they had an uh
140:36 - basically an array of winning patterns
140:38 - and they were basically just checking
140:40 - which squares were currently
140:43 - um had plays in them and did they match
140:46 - these winning patterns and that's how
140:48 - they would determine whether the game
140:50 - was a winning game so I'm going to copy
140:52 - this array here and I'll show you how
140:54 - we're going to use this
140:56 - so let's start writing some comments
140:59 - here because our method is getting a
141:01 - little bit large so check if there is
141:05 - already a play if so return early
141:09 - because we don't want any turns to
141:11 - change or anything like that
141:13 - then we'll come down here and we'll get
141:16 - the current player we'll create the icon
141:19 - and we will add that icon to the div
141:23 - right down here and then the next thing
141:26 - that we need to do is let's let's
141:29 - actually put a comment here
141:33 - determine
141:35 - which player
141:37 - icon to add to the square
141:42 - and then finally check if there is a
141:46 - winner or tie game once again we're
141:50 - going to refactor all this so I know
141:52 - it's getting pretty busy in this method
141:54 - we're going to refactor it I'll show you
141:55 - a better way to do this for now we're
141:58 - going to paste in those winning patterns
142:00 - and so the question becomes how do we
142:03 - know the current state of this game how
142:06 - do we know what squares have been played
142:08 - in and which ones have not been and
142:10 - furthermore which player has played in
142:13 - each of the squares now we could of
142:15 - course do some elaborate check where we
142:19 - basically say you know we search the
142:21 - current Square we check if it has
142:23 - anything in it and then we could maybe
142:25 - check the class list and check if it's
142:28 - an fax or an FAO and then basically Loop
142:32 - through all of the squares on the board
142:35 - to determine what the current state of
142:37 - the game is but what's a lot easier to
142:40 - do is to just track that and State as we
142:43 - go so rather than doing this sort of
142:46 - check we can just check the state but
142:49 - first we need to Define what that state
142:51 - is so what we'll say is that we need to
142:55 - track an array of game moves
142:57 - and those game moves are just going to
143:00 - be the player that has played
143:03 - so what it might look like is something
143:06 - like this where we have
143:09 - um I'm sorry we we need to track the
143:10 - square itself too so we're going to say
143:13 - the square ID is going to be 1 and then
143:16 - the player is going to be one so that
143:19 - move right there would represent if
143:22 - player one clicks this top left Square
143:24 - so we basically are just tracking a
143:27 - square ID and a player ID in the moves
143:30 - array so let's empty that out that's
143:33 - going to be our default state is an
143:35 - empty game
143:37 - and then down here within this event
143:39 - listener
143:41 - as you can see we're updating the
143:43 - current player in state
143:45 - but what we also want to do is we want
143:47 - to push a move to state so app.state dot
143:52 - moves and then we want to push a new
143:55 - move that is going to be an object with
143:58 - a square ID
143:59 - and let's just
144:01 - um reference the square itself
144:04 - or we could also say the yeah we'll just
144:08 - say the square dot ID and this needs to
144:11 - be a number so we'll add a little
144:14 - coercion there to make that a number
144:16 - type
144:17 - and then the player we'll just call it
144:19 - the player ID just for consistency
144:21 - that's going to be equal to the current
144:24 - player of the game so
144:27 - we've already updated the current player
144:29 - right here to be the next player so we
144:32 - need to actually put this state update
144:34 - right above that so that the current
144:36 - player is right so we'll say
144:39 - um
144:40 - I don't know why we're checking this
144:42 - right here we've already extracted that
144:44 - there so let me refactor that real quick
144:48 - and then we can put current player right
144:50 - there
144:51 - and then just for us to see what's going
144:54 - on here I'm going to console log
144:56 - app.state after those updates have
145:00 - happened
145:00 - at the moment this isn't going to change
145:02 - any of the behavior we're just tracking
145:04 - another state variable so let's click
145:07 - something click another click another
145:09 - and you can start to see we're building
145:12 - up State we're building up an array of
145:14 - moves and you can see that square id1
145:17 - has a move from player id1 so the x
145:20 - square 2 has a player ID of 2 an O and
145:24 - square 3 has a player ID of 1 and an X
145:27 - so you can see as we add moves we are
145:30 - adding to that array of moves now what's
145:33 - interesting about this is that we can
145:35 - also derive some State here we can
145:38 - simplify things a little bit so if we go
145:41 - back up to our state you got to ask
145:43 - yourself well who is currently up based
145:47 - on the number of moves that are in that
145:49 - array we actually don't need to track
145:52 - the current player because we will be
145:54 - able to derive that based on the moves
145:56 - that have been played
145:57 - so let's actually delete the current
146:00 - player from State all we really need to
146:02 - track is moves and I'll show you how to
146:05 - derive that right here so the first
146:08 - thing that we want to update
146:11 - um is let's see
146:15 - the current player variable right here
146:17 - so
146:19 - what we can do is we can say if
146:21 - app.state.moves
146:25 - um
146:26 - that length
146:28 - equals zero so if there's been no plays
146:31 - at all then we're going to say the
146:33 - current player is one we'll just always
146:35 - say that the current player is one they
146:37 - start the game every time
146:39 - if it is not equal to zero then we're
146:42 - going to check for the last move of the
146:45 - game so the last element of that array
146:47 - and then grab the player who is opposite
146:50 - of that player so this is going to
146:52 - require a little bit more logic than we
146:54 - have right here
146:56 - um so I'm going to break that out
146:58 - so we'll say the last move
147:00 - is
147:02 - app.state.moves and then you can use a
147:04 - little convenience method you could of
147:07 - course check it by saying
147:08 - app.state.moves
147:11 - dot length minus one that's a typical
147:14 - way that you could grab the last element
147:16 - of the array but there's a more concise
147:19 - way with JavaScript you can just say at
147:21 - negative one which will grab the last
147:24 - element of that array now of course we
147:27 - don't know if that array has anything in
147:30 - it so
147:32 - that could be I believe undefined if
147:35 - there's nothing in the array
147:37 - so now we can come down to the current
147:39 - player
147:41 - we can say if the length of the array is
147:44 - zero we'll go with one otherwise we're
147:46 - going to grab the last move and that
147:50 - move
147:51 - has a player ID in it so it's going to
147:56 - not be the player ID of the last move
147:58 - it's actually going to be the opposite
148:00 - of that so what we can say is a little
148:04 - convenience method get opposite player
148:08 - and we'll just pass in a player ID
148:12 - and we'll say if player ID
148:15 - equals one then we're going to pass in
148:18 - player two otherwise one
148:20 - so we'll say get opposite player of the
148:24 - last move
148:26 - sorry this is getting a little
148:27 - complicated we'll break this out into
148:29 - some helper methods later
148:32 - but basically what we're doing is we're
148:34 - finding the last move we've got a helper
148:36 - method that gets the opposite player and
148:39 - then we're checking to see if there's
148:40 - any moves if there is
148:42 - if there's not any moves then player one
148:44 - is up because it's the beginning of the
148:46 - game otherwise we're going to get the
148:48 - opposite player to the last move that
148:50 - was played and that will give us our
148:52 - current player and that way we don't
148:54 - have to track any of that state and that
148:57 - should flow down to here where we're
148:59 - checking and adding moves to the game so
149:02 - let's save that and see if it works
149:05 - you can see that we're alternating and
149:07 - we can click on these as many times as
149:09 - we want and it's pretty stable now
149:11 - there's one more thing that we can do
149:13 - now that we're tracking the game moves
149:15 - we don't really need to check whether
149:18 - the square has child nodes because
149:20 - that's really relying on the Dom itself
149:23 - it would be better
149:25 - just to express what we're trying to do
149:28 - to check the state of the game so let's
149:31 - say
149:32 - um
149:33 - we need a helper method called has move
149:37 - and what we're going to do is just
149:39 - Define a function
149:42 - that takes a square
149:45 - actually a square ID so it'll be a
149:48 - number and then we're going to just
149:50 - basically return or we're going to say
149:53 - existing move is equal to
149:57 - app.state.moves and then we're going to
150:00 - look for that square ID in that array so
150:02 - we're going to call find
150:04 - and we're going to look at the move
150:07 - and check if the square ID matches the
150:10 - square ID that we're passing into this
150:13 - helper function and then we're going to
150:16 - return the existing move does not equal
150:19 - null and that's another way of saying
150:22 - does not equal undefined or null so we
150:25 - could also say does not equal double
150:27 - equals undefined
150:29 - okay and that will give us whether
150:32 - there's a move so now we can replace
150:34 - this with has move and then we can just
150:37 - pass in the Square dot ID
150:41 - and make sure that's a number so that
150:43 - it's comparing the same type
150:47 - I think if we got this right we should
150:49 - be able to click squares multiple times
150:52 - and it will not do anything which is
150:55 - telling us that our check has worked
150:57 - okay
150:58 - so at this point
151:00 - I know that we've done a lot of
151:01 - refactoring and it seems like for
151:03 - nothing but the goal of this is whenever
151:06 - you're tracking state within an
151:08 - application you want to keep it as
151:10 - simple as humanly possible and the
151:13 - reason being is as we've seen down here
151:15 - where we're actually updating the state
151:19 - to the current player which by the way
151:21 - we can get rid of now because we're
151:23 - deriving that information
151:26 - but when we update State as we're doing
151:29 - here in the moves pushing a move to the
151:32 - array
151:33 - every time you track something in state
151:35 - you also have to update it somewhere and
151:38 - the more things you track in state the
151:40 - more updates you're responsible for and
151:43 - therefore the more possible errors that
151:45 - you're going to introduce to your
151:47 - application so the goal with tracking
151:49 - state is to keep it as simple as
151:51 - possible so that you have the least
151:53 - number of variables to keep track of
151:56 - over the life cycle of your application
151:58 - in this case all we're doing is tracking
152:01 - an array of moves and then from that
152:04 - little piece of information we're able
152:07 - to then derive who is the current player
152:10 - and from that we can then you know
152:13 - update state to to make another move
152:15 - within the game at this point we've
152:17 - refactored our state and we're updating
152:20 - it to just have an array of moves
152:23 - which is a lot it allows us to derive
152:26 - pretty much everything that we need to
152:28 - know about the current game
152:30 - now the next thing that we need to do
152:32 - that we can now actually do with this
152:34 - state is find whether someone has won
152:37 - the game or if it's a tie or if it's
152:39 - still in progress
152:41 - so what we're going to do is actually
152:43 - make a utility function for this and I'm
152:46 - going to add this
152:47 - just at the top and this is not going to
152:50 - be the final destination of it
152:53 - um actually we could even just put it
152:55 - within the app but we'll probably
152:58 - rearrange this in the future so what we
153:02 - want to do is call it something like get
153:05 - game status
153:07 - and this function is going to take
153:11 - an argument here so what are we going to
153:15 - pass in will be an array of moves
153:18 - and then we also probably need well I
153:22 - think that's pretty much all we need we
153:24 - just need an array of moves which is
153:26 - tracked in state so with that array of
153:29 - moves we should be able to give a couple
153:32 - pieces of information so we'll Define
153:35 - the return value of this just to start
153:38 - the first thing is going to be the
153:41 - status which this can either be
153:44 - um we'll call it in progress
153:48 - or complete
153:50 - so we will put a placeholder in there
153:54 - for right now but this will become
153:56 - dynamic
153:58 - and then we will also give a winner
154:00 - which again will put a placeholder in
154:03 - there but this is going to either be one
154:06 - or two so player one or player two and
154:09 - then also it could be null which would
154:11 - represent a tie so that's kind of how
154:14 - we're going to
154:15 - um represent this
154:17 - and based on these two pieces of
154:19 - information we should be able to know
154:21 - whether the game you know what to show
154:24 - in the UI whether we show the modal that
154:26 - pops up and gives the result or we keep
154:29 - playing
154:30 - so to do this the first thing we need to
154:33 - do is get player one moves and the moves
154:37 - array that we're going to be passing is
154:39 - the entire game
154:41 - so all we need to do is filter that
154:43 - and then check on each move whether the
154:46 - player ID
154:49 - is equal to one
154:51 - so that will give us player one moves
154:53 - and then we can copy that down and
154:56 - change the ID to get player 2 moves from
154:59 - there we should be able to bring up our
155:01 - winning patterns so this will now come
155:05 - up in that utility method
155:09 - we'll paste that right there and what we
155:12 - want to do is Loop through each of these
155:14 - winning patterns and check if either of
155:17 - the player moves have all three of these
155:21 - within their array and if all three of
155:24 - them match then we know that one of the
155:26 - players has actually won the game
155:28 - so the way we can do that is start out
155:31 - by saying the winner equals null so
155:34 - we'll just assume to start that it's
155:36 - there's no winner and what we'll do is
155:39 - map through the winning patterns so
155:41 - we'll do a loop for each Loop and we'll
155:45 - call each of them a pattern because this
155:48 - variable will represent one of these
155:50 - arrays
155:52 - and then we'll break that down into a
155:54 - function that will check for this
155:56 - condition so we'll say player one wins
156:00 - and that is only going to be true if
156:03 - every value within the pattern so we'll
156:06 - just say V for value
156:09 - we'll say player one moves includes
156:13 - that value so again we've got player
156:16 - one's moves the array of moves they've
156:19 - made and then we have an individual
156:21 - pattern and if there's a hundred percent
156:23 - overlap between player one's moves and a
156:27 - given pattern we know that they've won
156:29 - so the same thing can be said about
156:31 - player two so we can copy that down
156:33 - again and just update that array and
156:37 - that should tell us whether each of the
156:39 - players have won so then we can write an
156:41 - if statement and we'll say if player one
156:44 - wins then we just update the winner to
156:47 - be equal to one so that's their ID
156:52 - um and then if player 2 wins we'll
156:55 - update the winner to be equal to So in
156:58 - theory this should only be one player
157:01 - that can win and if we don't hit a true
157:05 - condition for either of these then the
157:07 - winner will stay equal to null and we'll
157:09 - just assume that's a tie if the game is
157:12 - complete
157:13 - so we come down here and instead of hard
157:16 - coding that we can just remove that and
157:19 - winner will be assigned to this variable
157:22 - right here so that's either going to be
157:24 - null for a tie one or two and then the
157:28 - status of the game is going to be in
157:31 - progress if there are either no winner
157:34 - or the game moves does not equal nine so
157:38 - if we look at our game there's nine
157:39 - squares so if all of them have a move
157:42 - then we know that the game is over so
157:45 - that will be our first check we'll say
157:47 - if the moves dot length
157:51 - is equal to nine
157:54 - then
157:55 - we can say that is going to be a
157:58 - complete Game otherwise it will be in
158:00 - progress now we of course need one more
158:03 - check here so if the moves that length
158:05 - equals nine or the winner does not equal
158:10 - no yeah so we're checking whether the
158:13 - winner does not equal null because that
158:16 - would represent that someone has won
158:18 - before the game reached a final state of
158:21 - nine plays which would be a tie so that
158:24 - will help us figure out what the status
158:26 - is
158:27 - so now with this utility function get
158:30 - game status we can come down here
158:33 - and where we're checking if there's a
158:35 - winner or a tie game let's just assign
158:38 - that to a variable called status so
158:41 - we'll say
158:42 - app.getgame status and then we will pass
158:45 - in the
158:48 - app.state.moves and that's going to
158:50 - represent the newest array of moves that
158:53 - has been played
158:55 - let's console.log that status just to
158:58 - see what we're dealing with
158:59 - and let's play a couple moves so you can
159:03 - see the status is going to print every
159:05 - time so our game's in progress there's
159:07 - no winner
159:09 - still in progress
159:11 - and then this click right here should
159:14 - change the status
159:16 - and you see that it doesn't and we'll
159:18 - have to check out why because that
159:20 - should have updated to complete and
159:22 - populated a winner of player one
159:25 - so let's go ahead and check that see
159:28 - what is happening here just to debug
159:30 - this let's go ahead and just do a
159:32 - classic console log
159:35 - this will be quite a few logs because
159:38 - we're going to be printing on every
159:40 - pattern here
159:43 - so let's just console log the pattern
159:47 - and then player one moves in player 2
159:50 - moves
159:51 - just so we can get that in one big
159:53 - object
159:54 - and then we'll play all these moves and
159:57 - then right here this is where we should
159:58 - be getting a different result than we're
160:00 - getting
160:01 - oh and I can already see what's
160:03 - happening here
160:04 - so what we did wrong what I missed
160:07 - is when I was filtering the player one
160:09 - moves this is just going to give me the
160:11 - entire move so if we print that out
160:15 - to the console
160:17 - what you'll see is in this array we're
160:20 - printing an object with a square ID and
160:23 - a player ID and when we're comparing
160:26 - that down here in the every utility
160:28 - method we're actually comparing a number
160:31 - which is the key of the square
160:35 - to that object which will never equal
160:37 - each other so what we really need to do
160:40 - is actually add a map utility at the end
160:43 - and we're going to map that move to be a
160:47 - number value that is equal to the square
160:50 - ID
160:51 - of those moves so now if we print this
160:55 - out into the console
161:00 - player one moves this should represent
161:02 - an array of numbers now as you can see
161:05 - representing the coordinate
161:08 - um of this of the place so this should
161:11 - be one two and then one two three and
161:15 - now you can see that the status is
161:17 - complete and the winner is equal to
161:19 - player one so our utility method seems
161:22 - to be working let's reset the game and
161:24 - try to tie the game
161:27 - so let's mix this up here
161:31 - oops I accidentally won it's kind of
161:34 - hard to tie this game okay so now we've
161:37 - got a tie game and you can see that the
161:40 - status is complete and the winner is
161:42 - null so that should tell us that it was
161:44 - a tie game so now we can Implement that
161:47 - logic
161:48 - down in our event listener
161:52 - so down here at the bottom where we're
161:54 - just console logging the status what
161:56 - we'll say is if the status equals
161:59 - complete
162:01 - then what I'm going to do is just make
162:04 - an alert in the in the browser so we'll
162:07 - say if the status I'm sorry this should
162:11 - really be
162:13 - status dot status so we should probably
162:15 - rename this variable
162:17 - we'll say game
162:20 - and this will be game dot status
162:24 - and now we'll say if the game
162:28 - um
162:30 - if the game has a winner
162:34 - then we're going to alert
162:36 - player
162:37 - winner wins
162:40 - otherwise we know that it's a tie
162:44 - so we'll say tie
162:47 - let's try this out so let's go ahead and
162:50 - make player one a winner
162:54 - says Winner's not defined for some
162:56 - reason
163:04 - and that's because I'm not referencing
163:06 - it correctly
163:09 - try that one more time
163:12 - and there we go player one wins so kind
163:14 - of small but you can see now we've got
163:16 - the essential functionality hooked up
163:18 - and at this point I think the next step
163:22 - is to trigger that modal to open when
163:26 - someone has won the game or there's a
163:28 - tie but before we do that let's just
163:30 - recap what this big long event listener
163:33 - is doing
163:34 - so first We're looping through each of
163:37 - the squares on the game board and we are
163:40 - adding a click listener to that square
163:44 - when that square is clicked all this
163:47 - code is going to run
163:48 - so the first thing we'll do is check if
163:52 - there's a move already present within
163:54 - that square
163:55 - if there is we're going to exit early
163:57 - and not do anything because someone can
164:00 - never play twice in the same square
164:03 - once we get past that we know that there
164:06 - is a valid move so we're going to check
164:08 - who Moved last based on the state
164:12 - we're going to then get the opposite
164:14 - player
164:15 - of that last move and set the current
164:19 - player of the game
164:21 - we will then take and create an icon
164:25 - and based on the player who is up we'll
164:27 - add an X or an O as an icon and then
164:32 - we'll put that in the Dom and we'll add
164:35 - that icon to the square we'll also push
164:38 - a move a new move to the state so that
164:42 - we're tracking the history of moves in
164:45 - the game
164:46 - we'll then check the game's status after
164:49 - that move has happened and if the status
164:52 - is complete we then know we can do
164:55 - something and open a modal to explain
164:57 - whether someone has won or if the game
165:00 - was a tie and now our goal is to open
165:03 - that modal and give the user an action
165:05 - to actually reset the game and start
165:08 - over
165:09 - if you remember from our index.html
165:12 - when we built this
165:14 - a couple hours ago you'll see down here
165:17 - with the modal we just have that hidden
165:19 - class sitting on there and if we remove
165:21 - that and save the file you'll see that
165:25 - we get this dialog to open and it's
165:28 - going to cover the screen with a play
165:30 - again button so the things that we have
165:32 - to do is number one we have to trigger
165:35 - this to actually open and then close
165:37 - when we're done with it and number two
165:40 - we have to add a click listener to this
165:42 - button right here so that when someone
165:45 - clicks play again the game state has
165:48 - reset and you know everything goes back
165:51 - to the beginning so let me add this
165:53 - hidden class back because that's our
165:55 - default state
165:56 - and as I said this is going to be
165:59 - refactored at some point we've got a lot
166:02 - of code all sitting in one place which
166:04 - is going to be hard to follow long term
166:07 - but at the moment we're just putting
166:09 - everything in one method
166:11 - keeping it simple so that we don't have
166:12 - to refactor anything quite yet
166:14 - so the way that we're going to do this
166:16 - is First add a selector to this modal so
166:20 - just like we've done up here with let's
166:24 - see
166:26 - we've given data IDs to the elements
166:29 - that we're going to select and control
166:30 - with JavaScript so we'll do the same
166:33 - thing with this modal
166:34 - let's just call it modal and then the
166:37 - modal contents will also give it a data
166:40 - ID
166:43 - and we'll set that equal to modal
166:45 - contents
166:48 - and what we're going to do here
166:51 - let's see or actually we're not going to
166:53 - put it there because we don't really
166:55 - need to control that we need to control
166:58 - this text element so data ID equals
167:03 - modal text
167:06 - and then this will be the data ID
167:10 - modal button
167:12 - so you don't really need to add these
167:14 - data IDs to all of them because really
167:15 - you could just select the modal and then
167:17 - grab those elements dynamically I'm just
167:20 - being pretty explicit about it just for
167:23 - clarity so let's go ahead and select
167:26 - these within our app because that's kind
167:28 - of what we've been doing I'm just
167:31 - collecting all of these elements that
167:33 - we've selected so let's copy this down
167:36 - and we'll name this one modal
167:39 - this data ID will be modal
167:43 - and then we'll say modal text
167:46 - and modal button
167:54 - and as you can see we're doing a lot of
167:56 - repetitive stuff here so if you're
167:58 - thinking this will be refactored too to
168:01 - be a little bit simpler and to eliminate
168:04 - the need to write all of this boiler
168:06 - played out but I'm leaving it here now
168:08 - because it's it's pretty clear what's
168:10 - happening
168:11 - so now that we've got these three we can
168:13 - pretty much control them
168:15 - down here in this check on the game
168:17 - status
168:18 - so if the game status is complete and we
168:21 - have a winner
168:22 - the one thing that we know we need to do
168:25 - is print to the modal who has won that
168:28 - game so let's just say app dot dollar
168:32 - sign because that's our namespace for
168:34 - all of those elements
168:37 - um
168:38 - actually first we need to open the modal
168:41 - I'm sorry so if the game's complete we
168:43 - know that we need to open the modal
168:45 - so modal and then what we're what we're
168:48 - going to do is look at the class list in
168:51 - toggle
168:52 - the hidden class on that but to be a
168:55 - little bit more explicit since we know
168:57 - that we're opening it here rather than
169:00 - toggling the hidden class which could
169:02 - work there what we're going to do is
169:04 - actually remove
169:07 - what is the yeah we should be able to
169:10 - say classlist.remove
169:13 - that hidden class
169:14 - so let's try that first let's make sure
169:17 - that that's working so someone wins the
169:20 - game here
169:21 - and says modal.classlist is undefined so
169:25 - we mess something up here oh and that
169:28 - the problem is we're using query
169:29 - selector all because that's what we had
169:31 - for squares this should just be a basic
169:34 - query selector so now I believe this
169:37 - part should work
169:39 - so let's win the game for someone and we
169:42 - get the alert but we also get the modal
169:44 - so let's remove this alert
169:47 - um for the moment because it's kind of
169:49 - getting in the way but now that we know
169:51 - there's a game winner what we can do is
169:54 - we can say that the text is going to be
169:56 - equal to player and then give the
169:59 - game.winner so that'll be the ID
170:02 - so that's the message that we want to
170:04 - put so let's call that message actually
170:08 - and here our message is going to be
170:12 - tie game
170:15 - and then all we have to do
170:17 - we can actually extract that to a
170:19 - message up here
170:22 - um
170:24 - and then
170:28 - assign that there and then no matter
170:30 - what we're going to say app
170:32 - dot dollar sign dot modaltext dot inner
170:37 - text or is it inner HTML I can't
170:40 - remember
170:42 - uh it's not in or anything it's text
170:44 - content is equal to the message
170:48 - so let's save that and see if that works
170:51 - so someone's going to win the game here
170:54 - and it's player one
170:56 - now let's refresh the page and this time
170:59 - let's let player 2 win so player 2 wins
171:02 - and you can see that dynamically will
171:04 - populate
171:06 - now the last thing that we need to do is
171:07 - put that click listener on the play
171:09 - again button
171:11 - we're not going to do that in this
171:12 - method because remember we're
171:15 - registering our event listeners all at
171:19 - the top level of this function
171:22 - so let's just put that right here we'll
171:25 - say app dot dollar sign dot modal button
171:31 - add event listener
171:33 - we're going to listen for a click event
171:35 - and then with that event all we're going
171:38 - to do is set set the state DOT moves
171:42 - equal to an empty array because we want
171:45 - to reset the game and then we also want
171:48 - to close the modal if it's open so the
171:51 - way that we'll do that is app.d dollar
171:54 - sign dot modal and then classlist dot
171:58 - actually not remove we want to add the
172:01 - hidden class back so that will hide the
172:03 - modal
172:04 - so now that should be hooked up
172:06 - and if we go through the game someone
172:09 - wins and we click this button it closes
172:12 - it and you can see there's still game
172:15 - moves here because resetting the state
172:18 - doesn't actually change the UI quite yet
172:20 - we will refactor that at some point
172:23 - but at the moment it does not so not
172:27 - only do we have to reset the state but
172:29 - we also have to Loop through each of
172:31 - those squares and empty out their
172:34 - contents so let's see how we would do
172:37 - that is we'd say app.dollarsign squares
172:42 - and then we'll say for each Square
172:45 - we're going to say Square dot replace
172:48 - children and just leave that empty and
172:52 - that's just a shortcut to clear
172:54 - everything out of the squares
172:56 - so now let's go back and try it one more
172:58 - time someone wins the game we click play
173:01 - again and everything has cleared
173:03 - so we now have a functioning tic-tac-toe
173:07 - game
173:08 - player one wins again see if we can get
173:10 - a tie here
173:12 - you have to really think about this one
173:14 - to get a tie
173:17 - um let's see that should work okay
173:19 - there's a tie game play again clears it
173:22 - out the last thing that is not working
173:24 - here is this turn indicator you can see
173:27 - that no matter what we play it's just
173:29 - staying the same and we obviously want
173:31 - to update that now a great place to do
173:34 - that is going to be within this super
173:36 - long event listener for each of the
173:39 - square clicks where we're updating the
173:42 - current player so we'll actually do that
173:44 - in this if else statement but first we
173:48 - have to grab those elements that we want
173:50 - to update
173:52 - so let's find the turn indicator
173:55 - and you can see right here this is where
173:57 - we're doing it and we've got an icon
173:59 - that we need to update and some text
174:02 - that we need to update so here what
174:04 - we're going to do is add a data ID and
174:09 - call that turn
174:11 - so we'll now go select that in our list
174:14 - of elements
174:17 - so we'll say turn
174:19 - and then just copy this down again
174:25 - and one thing that we need to do here
174:27 - that I kind of missed is we've got the
174:30 - turquoise class set on the individual
174:32 - icon but we want these both to match so
174:35 - it would be a little bit easier
174:38 - if we just put that up here on the turn
174:40 - element and we also need to match things
174:43 - up so the first player is player one
174:46 - which we're just determining is going to
174:48 - be X and that's going to be yellow so we
174:52 - need to match those up let's save that
174:54 - and just make sure that this is matching
174:56 - now which it is so this is what we're
174:59 - looking for as a starting point and now
175:01 - all we need to do is just toggle this
175:04 - from yellow to turquoise and back and
175:06 - then we'll toggle the elements within it
175:09 - to indicate the turn
175:11 - so we can do that here
175:14 - um
175:14 - one thing we'll need to check is get a
175:17 - little bit more clear on who's up next
175:20 - so the current player represents who's
175:23 - actually clicking right now
175:25 - the next player is going to be the one
175:28 - that we want to change the turn
175:30 - indicator for
175:32 - so you've got the current player and
175:35 - then
175:36 - we can say next player and reuse that
175:39 - get opposite player I know we're a
175:42 - little redundant here
175:44 - um
175:45 - but we'll go ahead and use it so this
175:47 - should represent it in the ID of the
175:50 - next player
175:51 - now we can come down here and say the
175:55 - turn label
175:57 - is going to be a new element
176:01 - you could have replaced the element
176:02 - that's already there but I'm just going
176:04 - to create a p element
176:06 - and then that turn label
176:09 - dot inner text
176:11 - is going to be equal to
176:14 - player
176:15 - next player
176:17 - what we determined up there
176:20 - you are up
176:23 - and we'll copy that down
176:25 - um actually we can just put that right
176:27 - there
176:28 - and then from here
176:30 - we can just say app.d dollar sign and
176:33 - select the turn element so remember
176:35 - we're just selecting this entire div and
176:39 - we want to replace the contents of it
176:41 - so all we need to do is say replace
176:43 - children and then we can pass as it
176:47 - shows here we can spread out parameters
176:51 - as individual nodes so it will replace
176:55 - them in order
176:56 - so if we want the icon to go first we
176:59 - just pass that there and then we'll pass
177:01 - the turn label
177:03 - when we save this let's see if we get
177:05 - the correct result so I'll go here
177:08 - and you can see that we're getting the
177:10 - correct text but the color is not
177:12 - updating and we're not getting the icon
177:15 - to also be added
177:17 - I believe the problem here is we're
177:19 - actually adding this same icon to two
177:22 - different places so we probably need to
177:25 - break that out into two separate
177:27 - elements
177:28 - so we'll say turn icon
177:31 - and then this will be the square icon
177:35 - so those will be two separate elements
177:37 - and down here
177:39 - we'll pass the square icon
177:42 - and then here we'll pass the turn icon
177:46 - and we of course want the same exact
177:51 - colors here I believe
177:54 - or actually no these need to be opposite
177:56 - because once again we have the next
177:59 - player is going to be the opposite color
178:03 - of the current player
178:05 - so we'll say the
178:08 - Square icon
178:16 - and then we'll copy this down and this
178:18 - will be the turn icon and this will be
178:21 - the exact opposite
178:23 - so this will be the o
178:26 - and it will be turquoise
178:32 - this will be turn icon with an X that is
178:36 - yellow
178:37 - once again we are going to refactor this
178:39 - it's not going to be this confusing and
178:42 - verbose here in the future
178:45 - so hopefully this works
178:48 - now we're getting a lot closer we have
178:51 - everything correct except for it looks
178:54 - like this text is O is yellow
178:57 - and it's because we're not setting the
179:00 - color of that so we need to say the turn
179:03 - label
179:04 - dot class list
179:07 - and let's go ahead and do that down
179:11 - here so turn
179:13 - babel.class list
179:15 - and we'll set that equal to turquoise
179:20 - to match what we're making the turn icon
179:22 - right here and then we'll copy that down
179:27 - and make this one yellow if it's player
179:30 - two
179:33 - so now it looks like we're getting
179:35 - everything correct so if we play in O
179:38 - now X player one is up if we play an X
179:41 - well we've got to play again but you can
179:45 - see that that is updating correctly now
179:48 - as you noticed if we end the game and
179:51 - player one wins you'll see up here
179:53 - player 2 has it is up next and that's
179:56 - their turn
179:57 - and if we click play again that's not
179:59 - going to reset so we need to remember to
180:02 - reset the turn and since we've coupled
180:06 - all of that turn logic within this event
180:09 - listener we have no easy way to do that
180:12 - up here when we're resetting everything
180:14 - so at this point we've reached a place
180:18 - in our code where we've got a lot of
180:21 - stuff going on
180:22 - right in this method that we would like
180:25 - to be able to reuse in different places
180:28 - to like reset the state and whatnot but
180:31 - right now it's very hard to do that so
180:33 - the next segment of this video is going
180:35 - to be taking this code and refactoring
180:38 - it to look a little bit cleaner and be
180:40 - more reusable and easy to follow so
180:44 - we'll go through that but as of right
180:46 - now we have a working game for the most
180:48 - part as long as we refresh things
180:51 - and we can determine who wins the game
180:54 - so once again we'll refactor things then
180:57 - we'll start talking about keeping this
180:59 - state for the scoreboard and then moving
181:02 - into the MVC pattern so as we talked
181:06 - about
181:07 - we've got the naive approach all in one
181:09 - file that's what we're still on we've
181:11 - been refactoring iterating as we go and
181:14 - then we'll end up with something pretty
181:16 - clean that we can reuse and extend into
181:18 - the future so we've reached a point
181:20 - where our code is getting a bit
181:21 - confusing and if we continued to add
181:24 - this functionality so if we were trying
181:27 - to reset this turn indicator when the
181:29 - game ends remember we've got a problem
181:32 - here it doesn't reset and then we also
181:34 - have to be able to reset the whole game
181:36 - and reset the round track all of this
181:38 - state you know the history of the games
181:40 - there's a lot to do here and given our
181:44 - current code it's going to be very
181:45 - confusing to do because we've got all
181:47 - this stuff in one method there's all
181:50 - sorts of stuff we're updating State
181:51 - we're updating the view all in one spot
181:55 - so this is where a pattern comes in and
181:57 - helps us out a bit I waited until this
182:00 - point
182:01 - um to mainly simulate a real life
182:04 - scenario where generally you're going to
182:06 - start off in one file just to understand
182:09 - the logic that you need within your
182:11 - application and then as you go you you
182:13 - have to refactor to keep things clear in
182:16 - your head and to make the code
182:18 - maintainable
182:19 - so at this point we understand what
182:22 - patterns we actually need here and that
182:25 - makes it a lot easier to introduce
182:27 - something like an MVC or model view
182:29 - controller pattern just as a side note
182:32 - the MVC pattern is really relevant to
182:36 - something like Ruby on Rails so if you
182:38 - typed Ruby on Rails
182:40 - and you go to the documentation you'll
182:44 - start to see a lot of these patterns and
182:46 - if we were I'm introducing this not
182:49 - because I think you need to use Ruby on
182:51 - Rails but more so because it's kind of
182:54 - the Premier example of a framework that
182:57 - leverages this model view controller
182:59 - pattern and has gained a lot of
183:02 - popularity so if we go to the docs let's
183:06 - see if we go to the API Maybe
183:09 - that's probably not where we want to go
183:11 - so as we're scrolling through the docs
183:13 - you can already see there's a header
183:15 - section called models
183:17 - then there's views
183:19 - and then there's controllers so they
183:22 - very explicitly build out this pattern
183:25 - so this is just a good reference you
183:26 - don't need to check this out I just
183:28 - wanted to point it out
183:30 - so enough Theory here let's get into
183:32 - this the way that we're going to build
183:35 - this model view controller pattern is
183:38 - actually by breaking this single file
183:40 - out into those three different
183:42 - responsibilities
183:44 - and that kind of brings us back to our
183:47 - best practices so whether or not you're
183:49 - using a model view controller pattern
183:51 - there's other patterns that you could
183:53 - use the main point here is that we want
183:56 - to separate
183:58 - um logic by
184:01 - um
184:01 - responsibility
184:03 - in other words this is the separation of
184:06 - concerns principle that is just a good
184:10 - programming principle in general it's
184:12 - something that you would always want to
184:14 - try to aim for no matter what pattern
184:17 - you're using so let's jump back over
184:20 - we've obviously got quite a bit of
184:22 - functionality here that we don't want to
184:24 - have to completely redo a lot of this is
184:27 - good stuff that we've worked out but we
184:30 - do need to refactor this into a couple
184:32 - files
184:33 - so in our JS directory I'm going to add
184:36 - a new file one called the view.js one is
184:40 - going to be called store.js and this
184:43 - will actually represent the model I'm
184:45 - just calling it store because it kind of
184:48 - represents the storage that we're using
184:50 - you could call it whatever you want
184:53 - um so we'll call that store
184:56 - and then app.js this is really going to
184:58 - be our quote unquote controller it's not
185:02 - a super explicit
185:04 - um adherence to the pattern but we're
185:06 - getting very close and the goal of a
185:09 - design pattern is to make things easier
185:11 - for you so you don't need to follow it
185:13 - so rigidly that everything matches up
185:15 - one to one as long as it's useful it is
185:19 - going to be okay so as we go and build
185:22 - this out I'm going to be kind of looking
185:23 - up here
185:25 - um to my other screen because I've
185:27 - actually as you know I've already built
185:29 - this app out in preparation for this
185:31 - video and I just want to make sure that
185:34 - this live build that we're doing matches
185:37 - up with the final code that you're going
185:40 - to see in the GitHub repository that is
185:42 - linked in the video description so
185:44 - that's all I'm doing I'm just making
185:46 - sure that I'm naming the methods the
185:48 - same so on and so forth so what we need
185:52 - to start with I think is going to be
185:56 - um let's go ahead and do the view
185:57 - because that is what most of this logic
186:00 - we have in our application is pertaining
186:04 - to at the moment
186:05 - so let's open up View and we're going to
186:09 - be jumping into some object-oriented
186:11 - programming Concepts here so that's just
186:14 - another way of saying we're going to be
186:16 - working with some JavaScript classes and
186:20 - specifically es6 syntax 4 classes I'll
186:24 - try to point out some of the syntax that
186:26 - I'm using and what it means but if you
186:29 - are not at all familiar with classes and
186:32 - what they are and how they work I would
186:35 - recommend brushing up on that pausing
186:37 - the video
186:39 - and just reading a couple you know
186:40 - overview guides just to get yourself a
186:43 - little bit up to speed that said I will
186:45 - try to explain things as we go and I'm
186:48 - not going to assume that you have any
186:50 - sort of advanced knowledge here so we'll
186:53 - we'll walk through it together
186:55 - so the first thing that we need to do in
186:57 - our view is Define that class that we're
187:00 - we're going to be using
187:03 - now we can call this a class of view
187:08 - and that's really all the syntax that we
187:10 - need we of course will use a Constructor
187:13 - this is kind of the initialization of
187:16 - the class and it belongs on it's
187:19 - available on any class that you use
187:22 - and then furthermore we're going to
187:25 - start to bring over our methods so there
187:28 - are things
187:30 - um that are available on the class
187:31 - instances
187:33 - um called class properties and that's
187:36 - where we're going to store those
187:37 - elements that we had defined earlier so
187:40 - we'll just initialize the dollar sign to
187:42 - an empty object and we'll start
187:44 - populating that here in a second so the
187:47 - first thing that we want to do in our
187:49 - class and we'll do this in the
187:51 - Constructor because we want all of these
187:53 - elements to be selected when the class
187:56 - is initialized so we'll go back to our
187:59 - app.js and we'll take all of these
188:03 - selectors that we've used
188:05 - and we will assign them in the
188:07 - Constructor so we'll have to update some
188:11 - of the syntax here but really we'll just
188:13 - click down and select a bunch at once
188:20 - and what we'll say is this dot dollar
188:23 - sign dot whatever the variable is
188:26 - because we are basically referencing
188:29 - when we say this we're referencing the
188:32 - class instance itself and on that class
188:35 - instance we have defined a property uh
188:39 - which is the dollar sign this could be
188:41 - any variable we're just using a short
188:43 - name space for easy easy way to access
188:46 - and so what we're doing is we're saying
188:48 - the class instance
188:50 - the property that we want and then the
188:53 - um another nested property that will
188:56 - represent the element itself so now
188:58 - instead of colons we'll need to set
189:01 - those to equal signs
189:08 - and then we'll hit command s to format
189:11 - things and save it although we've got
189:13 - some
189:14 - commas here at the end that we need to
189:16 - get rid of first
189:23 - now we can save it in a prettier we'll
189:25 - format this for us remember as I
189:28 - mentioned earlier in the video I've got
189:29 - format on Save setup with the prettier
189:32 - extension in vs code so that's why it's
189:35 - saving like that and formatting
189:37 - everything
189:38 - so at this point we've got our basic
189:40 - class and when it initializes we're
189:43 - going to select all the elements in the
189:45 - document but just having this alone it's
189:48 - not going to actually work quite yet we
189:51 - need to connect this to our app.js
189:53 - furthermore we're not going to really
189:56 - need this namespace anymore because
189:58 - we're going to be working with
190:00 - um or we we may use the namespace but
190:02 - we're going to be moving pretty much all
190:04 - of this code out but in order to do that
190:07 - without completely breaking everything
190:09 - I'm going to leave all the code intact
190:11 - it's just a good way to do it when
190:14 - you're refactoring something you want to
190:16 - leave the original code intact and just
190:18 - build the new code side by side and then
190:22 - you'll replace it at the end but since
190:24 - we're not going to have any of this code
190:26 - here anymore what I'm going to do is
190:29 - build this side by side and we're going
190:31 - to just make a standalone function
190:33 - called init and yes this is in the
190:36 - global namespace but this should could
190:38 - really be the only thing this and maybe
190:41 - one other variable that we'll put in the
190:43 - global scope so that should be fine
190:47 - and what we'll do in the init method is
190:51 - basically initialize the class itself so
190:54 - we'll say the view is going to be equal
190:56 - to New View
190:59 - so that is going to make a class
191:01 - instance of this class right here and
191:05 - then what I'm going to do just to test
191:06 - things is console.log view dot dollar
191:10 - sign and then let's just say turn
191:12 - because that was one of the elements
191:16 - that we selected in other words we're
191:18 - just testing to make sure that this was
191:19 - initialized correctly
191:21 - furthermore we want to duplicate this
191:24 - event listener we will eventually remove
191:26 - this once we've refactored everything
191:29 - but for now we just want to use this
191:32 - knit method when the the window loads so
191:37 - let's save that and then go back to our
191:39 - browser let me get these tabs organized
191:42 - again
191:45 - okay so we'll go to our browser here and
191:47 - go to the console
191:50 - and it's going to say uncut reference
191:52 - error the view is not defined and
191:55 - there's a good reason for this it's
191:57 - because we have not imported that script
192:01 - now obviously app.js has been imported
192:05 - right here at the bottom but we would
192:07 - also need to import the view.js for that
192:11 - to be defined and if we come back now
192:14 - you'll see that our console log worked
192:16 - because that's now defined
192:18 - but let's go back
192:19 - and flip these let's put them in a
192:22 - different order so we first load the
192:23 - view and then we load the app
192:26 - does it still work well the answer is
192:28 - yes and I believe that's because of
192:30 - hoisting that happens with JavaScript
192:34 - um but what's confusing about this is
192:36 - we've got these two separate files
192:39 - with different variables and they kind
192:42 - of reference each other but that can get
192:45 - confusing when you have more and more
192:46 - files so one solution to this that will
192:50 - help us out quite a bit and allows us to
192:53 - just import one script is to use es6
192:56 - modules so instead of adding this
192:58 - additional script import which gets
193:01 - messy once you have five or six Scripts
193:04 - we're just going to import app.js and
193:07 - then we're going to set a type attribute
193:10 - on the script and we're going to name it
193:11 - module what this is going to do is it's
193:14 - going to tell the browser that this
193:16 - script is an es6 module and now in
193:21 - pretty much every major browser es6
193:23 - syntax is
193:25 - supported as well as modules so this is
193:28 - a nice way to handle imports and exports
193:32 - so now in app.js rather than just
193:35 - referencing this view class variable
193:40 - we can import that so at the very top of
193:43 - our file
193:44 - what we'll do is we'll say import view
193:47 - from
193:48 - view.js
193:50 - now right now this is not going to work
193:52 - and it's not going to work because we
193:55 - haven't exported anything from this
193:57 - module
193:58 - what we need to do is put an export
194:01 - and then we want to export this as the
194:04 - default export so that we can reference
194:06 - it in our file just like this now if we
194:09 - left out this keyword of default
194:12 - we would need to put this in Brackets
194:15 - in reference it just like this so if we
194:18 - did that this should work if we go to
194:20 - the browser you'll see that this is
194:22 - being printed out which is what we're
194:24 - doing here at the bottom
194:27 - right here that's the console log but I
194:31 - think it's a little cleaner if we just
194:33 - export the default
194:35 - go back to app and then remove these
194:37 - brackets
194:39 - save it and then we'll check to make
194:41 - sure this console log is working and it
194:44 - is
194:46 - now another property
194:48 - um or feature of using modules is that
194:52 - by default they use strict so if you've
194:55 - ever seen use strict in JavaScript
194:59 - use strict we'll look that up
195:03 - strict mode is something in JavaScript
195:06 - that used to be really relevant as you
195:10 - had different files that would have
195:11 - different modes nowadays you'll pretty
195:14 - much see strict mode on every file that
195:16 - you ever write but this has a lot of
195:20 - useful defaults to kind of protect your
195:22 - code from all sorts of problematic
195:26 - patterns so by default these es6 modules
195:30 - or in strict mode which means that in
195:33 - the view.js you might say well oh this
195:36 - view is in the global scope but that's
195:40 - not the case we haven't actually
195:41 - attached it to the window so if we were
195:44 - to go to our console and type view it's
195:47 - going to say view is not defined the
195:50 - only way that that would be possible
195:52 - as if we said if we explicitly attached
195:55 - it to the window like this so
195:57 - window.view equals View and now we
196:00 - should be able to see the class that
196:03 - we've defined but this is not what we
196:05 - want and I just wanted to point that out
196:07 - as a feature of es6 modules by default
196:12 - they're going to behave this way and
196:14 - we're going to protect the global scope
196:16 - that way what this also means is that
196:18 - our init method if you remember from
196:21 - earlier
196:22 - scrolling up we had defined this app
196:25 - variable as the namespace around our
196:28 - entire app so that we didn't litter the
196:31 - global scope with all of these variable
196:33 - declarations
196:34 - but now if we try to access app at all
196:39 - um we're not going to be able to because
196:41 - it's in an es6 module and by default
196:44 - that is not exposed to the global
196:47 - namespace so that's basically why I'm
196:49 - okay adding this init method in the
196:52 - global scope because I know that's not
196:54 - going to be exposed in the in the
196:56 - browser
196:57 - unnecessarily so that's just a little
197:00 - tidbit but let's keep moving here on our
197:04 - refactor so looking through our app
197:06 - let's also find other things that relate
197:09 - to The View
197:10 - one of those things that is very
197:13 - relevant to just a view class is these
197:16 - event listeners we want the event we
197:19 - want the view to register event
197:20 - listeners initially so we can copy all
197:23 - of this over
197:24 - in my final code I want to see how I
197:29 - which method I put this under so in my
197:32 - final code each of these event listeners
197:35 - has its own method in the view so I'm
197:37 - going to open up two
197:39 - code Windows here and make it a little
197:42 - bit smaller for us hopefully you can
197:44 - still see that
197:45 - and what we'll do is we'll basically
197:48 - take each of these event listeners and
197:50 - make it its own method within the view
197:52 - class
197:53 - so just to stay consistent with my
197:57 - naming we will call the first one bind
198:00 - game reset event
198:03 - so that is the game reset and this is
198:07 - actually a new pattern that we're
198:08 - introducing rather than handling the
198:11 - event listeners within the view we want
198:14 - to do that in the controller and the
198:17 - reason being is because the controller
198:18 - is going to read the current state of
198:22 - the application and based on that state
198:24 - it may have to do different things to
198:27 - the view so you don't want to leave it
198:29 - just to the view itself to handle these
198:32 - events so we're going to put a Handler
198:35 - callback function passed as an argument
198:38 - to each of these event listeners
198:41 - so we'll use some es6 syntax to Define
198:45 - this function and then here we're going
198:48 - to actually register those event
198:51 - listeners so I'll type out the first one
198:53 - just so you can see it slowly and then
198:56 - we'll copy things over so for example
198:59 - let's look at this one
199:01 - um or no that's not a good example
199:04 - we'll use the reset game here
199:07 - so all we're going to do is reference
199:09 - these initialized selected elements that
199:12 - we have
199:13 - so this dot dollar sign
199:16 - dot which one are we selecting here
199:20 - reset button and then just like we're
199:23 - doing over here we're going to add the
199:25 - event listener
199:28 - listening for a click event and then in
199:31 - the Callback
199:32 - we're going to do something but the
199:35 - difference here is instead of handling
199:38 - this in the view we're just going to
199:40 - pass the Handler itself so we can just
199:44 - pass that Handler
199:45 - from here down to this event listener
199:48 - and then all of that is going to be
199:50 - handled in app.js so let me add the rest
199:53 - of them so bind new round event
199:57 - pass that Handler
199:59 - and then bind Player move event with a
200:03 - Handler
200:04 - and here what we can do is basically
200:07 - just copy this over so this is the
200:10 - um
200:11 - the move event
200:13 - so we'll just copy this over so this is
200:16 - the new round
200:17 - so we just add this dot dollar sign and
200:21 - that should work okay but of course we
200:23 - want to handle this elsewhere so we'll
200:25 - pass the Handler from the function
200:28 - parameters
200:30 - or arguments I mean
200:32 - and then for the player move event this
200:35 - is the one where We're looping through
200:36 - each of the squares and adding those
200:39 - listeners so at this point I don't want
200:41 - to just copy everything over because
200:43 - we're going to do this a little bit
200:45 - differently moving forward so we're
200:48 - going to start to diverge from our
200:50 - original implementation and just start
200:52 - to use it as a reference only not trying
200:55 - to copy things verbatim
200:57 - so what we want to do here is Select
201:00 - those squares
201:02 - and for each of those squares similar to
201:05 - how we're doing it here we'll want to
201:08 - bind an event listener so we'll say
201:11 - Square dot add event listener
201:14 - listening for a click and then we're
201:16 - passing this Handler right here now
201:19 - let's talk about
201:21 - um event listeners that are going to be
201:24 - view only things so you'll notice that I
201:27 - skipped over
201:28 - here on the left I skipped over this one
201:31 - right here where we are clicking on the
201:35 - button to reset the game although that
201:38 - should probably be added here but
201:40 - specifically let's look at this one
201:42 - where we're just toggling something in
201:44 - the UI so remember we just have this
201:46 - actions menu That's opening and closing
201:49 - this is not going to affect the state of
201:51 - the game whatsoever it's purely a view
201:56 - um client only piece of state that we're
201:58 - tracking and therefore
202:01 - in terms of responsibilities The View
202:03 - can handle a hundred percent of that it
202:06 - doesn't need to change any state or
202:07 - anything so we can actually register
202:10 - that in the Constructor and keep it
202:12 - entirely encapsulated here so we'll call
202:16 - this section UI only event listeners
202:25 - and here what we're going to say is this
202:28 - dot dollar sign that menu
202:31 - items I'm sorry we need the modal button
202:36 - for menu button menu items and then
202:40 - we're just going to toggle the class
202:42 - list
202:43 - so we'll say menu items that add event
202:45 - listener listening for a click
202:49 - and then we'll go back in that callback
202:51 - and we're handling this in the view
202:53 - itself
202:55 - so we'll say this dot dollar sign dot
202:57 - menu items dot class list
203:00 - that toggle hidden and we're going to
203:03 - actually improve this Handler just a
203:06 - little bit
203:08 - for some reusability but let's start
203:10 - with that and at this point I think it's
203:13 - time to kind of
203:16 - comment out this app that we had before
203:18 - so we're going to be resetting a good
203:21 - amount of functionality for the time
203:24 - being
203:25 - oops
203:28 - so we'll just go through this whole app
203:30 - here
203:32 - the whole thing including the uh load
203:35 - event you can comment that out
203:38 - we'll keep it here for reference but
203:40 - it's all commented out at this point
203:44 - so all we have now is just the view so
203:48 - let me collapse all that because it's
203:50 - just going to be easier to see and we'll
203:53 - save this and now let's see what the UI
203:56 - looks like so right now I can't really
204:00 - do anything I can click stuff but
204:02 - nothing is going to actually happen now
204:04 - the reason nothing is working is because
204:07 - I actually grabbed the wrong thing here
204:09 - on the right let's bring this over so we
204:12 - have a full screen
204:14 - um in our new view class I'm actually
204:16 - actually adding a click listener on menu
204:19 - items it should just be menu
204:21 - because if we go back to our index.html
204:24 - and look for that we want to register
204:28 - register The Listener on menu
204:30 - or probably more specifically we want to
204:34 - add a data ID and call this menu button
204:38 - so let's go back to our view
204:41 - we've got the menu menu items and let's
204:44 - add one more
204:45 - menu button
204:51 - and then we'll add the selector here
204:54 - and now we're listening for a click on
204:56 - the menu button and then when that
204:58 - happens we're toggling the hidden class
205:00 - on many items
205:02 - so going back we should now be able to
205:04 - toggle the menu open and closed but
205:07 - that's just about it we can't do
205:09 - anything clicking the reset button new
205:11 - round a square it doesn't do anything
205:13 - anymore
205:14 - and we need to start wiring up those
205:17 - events just to show you the pattern that
205:20 - we'll be using you can see that we are
205:22 - we have methods to bind these event
205:25 - listeners but remember by default when
205:28 - this class is initialized
205:32 - um are instantiated these methods are
205:34 - not going to run because they're just
205:36 - methods of the class
205:38 - someone needs to actually call these for
205:40 - these event listeners to be added
205:43 - so that's what we're going to do in the
205:45 - apps init method so right here below the
205:50 - class initialization we now have a class
205:52 - instance called View
205:54 - which we should be able to bind all of
205:57 - these events so we'll bind the game
206:00 - reset event and you can see that our
206:02 - autocomplete tells us that we need to
206:04 - pass a Handler in there and that Handler
206:08 - is going to give us an event
206:11 - so we can stub it out just like this and
206:14 - we can consult that log the event
206:16 - will also console.log the name so
206:20 - reset event
206:23 - so we'll copy this down for all of them
206:27 - we just had three of them so let's see
206:30 - what we call bind new round event
206:34 - and then bind Player move event
206:38 - so now we're actually calling those
206:42 - methods that are registering the event
206:44 - listeners so now when we go back to our
206:47 - UI we should be able to at least click
206:50 - things and see things happening so new
206:53 - round event
206:54 - or if I click the first Square it says
206:57 - Player move event and you'll see the
206:59 - click Target is
207:01 - um the square with the ID of one so div
207:04 - ID equals one or if we click down here
207:07 - we'll see in the ID of nine now with
207:11 - this pattern we want to keep our
207:13 - controller logic which is in this app as
207:16 - simple as possible we want this to
207:18 - really just orchestrate what happens to
207:21 - the state in the view but we don't want
207:24 - to add a lot of logic to this file most
207:28 - of the logic needs to happen in view.js
207:30 - or store.js which we haven't created
207:33 - quite yet
207:34 - I will get to this and show you why we
207:37 - have this
207:38 - but let's continue with the view and
207:41 - start implementing some of these methods
207:44 - here I think a good place to start is to
207:47 - go back to our app open up our original
207:50 - implementation
207:52 - and let's let's go ahead and go down
207:57 - to this big event listener that we have
207:59 - or no we'll start with these these
208:02 - littler ones
208:03 - and just so that we can see this better
208:05 - I'm going to uncomment everything
208:08 - and we're just not going to initialize
208:10 - it so I'll uncomment the whole app but
208:13 - because we're not initializing it here
208:15 - we can delete that this is just going to
208:18 - be a variable that's initialized it's
208:21 - not going to actually do anything or
208:22 - register any sort of event listeners
208:25 - so this is just for reference so if we
208:28 - go down and look at some of the code
208:30 - that we've already written we've
208:32 - implemented this toggle method over here
208:35 - in view as a UI only event that doesn't
208:38 - need to happen anywhere else now these
208:42 - have not been implemented we have a
208:44 - click listener on the modal button
208:47 - which allows us to hide the modal once
208:50 - the game ends we'll get to that in a
208:52 - second
208:53 - but really what we want to start looking
208:55 - at is all of this logic because it's a
208:58 - little bit messy and we could probably
209:01 - create individual methods to achieve
209:03 - what we're doing here
209:05 - let's start by improving our menu toggle
209:09 - right now in the UI what you'll see is
209:12 - that it opens and closes but this little
209:15 - Chevron down icon it's not going to
209:18 - change and generally when you have
209:20 - something like this the icon will rotate
209:23 - 180 degrees and go up when it's open and
209:26 - down when it's closed or vice versa I
209:28 - can't even remember which one is the
209:30 - correct design
209:32 - the correct way to do it from a design
209:34 - perspective but anyways we can improve
209:37 - this a little bit and we can also add
209:39 - like a selected state so that there's
209:41 - like a border when it's open so this
209:44 - will help us to kind of ease into this
209:46 - new pattern so as you can see I'm
209:49 - handling this UI only event in the
209:52 - Constructor and directly toggling that
209:55 - hidden class but what we'll do is break
209:57 - out this view into a couple sections
210:01 - so this section is going to be register
210:04 - all the
210:06 - event listeners
210:08 - then the next section is going to be
210:11 - some utility methods so uh Dom helper
210:16 - methods and that just means we're going
210:19 - to have some methods to change the UI in
210:22 - some way in the first one we'll Define
210:24 - is toggle menu
210:27 - and that's going to be called
210:30 - we're going to move this logic
210:32 - into that method and then we will just
210:36 - say this dot toggle menu and call that
210:39 - so we've just refactored it a little bit
210:41 - and we're going to add some stuff to
210:43 - this so let's make sure it works if we
210:46 - click this it toggles the menu okay and
210:49 - we're set but now we want to add
210:51 - something a little bit better to this so
210:54 - what I want to do is First add a border
210:57 - when the menu is selected so we're going
211:01 - to say this dot menu button because
211:04 - that's what we're going to put the
211:06 - border around and then let's toggle on
211:10 - the class list a border which if you
211:13 - remember from our styles
211:16 - index.css we have the shared utility
211:20 - classes and we've got this border class
211:22 - so we can just toggle that to get a
211:25 - border on it so now if we click you'll
211:28 - see that when it's open we have a border
211:30 - and when it's closed there's no border
211:33 - so that's just kind of a nice addition
211:36 - you could probably achieve this with CSS
211:38 - but I thought it'd be
211:40 - um nice to just demonstrate some
211:42 - JavaScript
211:44 - um and then furthermore we want that
211:46 - little icon to flip up and down
211:48 - depending on the open or closed state
211:52 - so to do that we need to actually
211:55 - um
211:56 - create a different icon based on that
211:59 - state and what I'll do is Define that in
212:01 - a variable and from here I'm going to
212:05 - let's see I'm going to grab from the
212:08 - menu button so the menu button is going
212:12 - to be
212:13 - this right here and you can see that
212:16 - I've got an icon down here at the bottom
212:19 - so basically what I'm doing is I'm
212:22 - selecting the button itself and then I'm
212:24 - grabbing any eye tag that is within it
212:27 - so we'll say query selector and we're
212:29 - going to look for any I tag that we can
212:32 - find which should represent that icon
212:34 - and then what we're going to do is look
212:37 - at the class list of that and since
212:39 - we're using font awesome we can just
212:42 - toggle
212:43 - fa Chevron down and then also Chevron up
212:48 - and this should basically just flip it
212:51 - every time the menu is toggled so if we
212:54 - click here you'll see this little icon
212:56 - just flips every time it opens and
212:59 - closes so that's just a nice addition to
213:02 - polish that up but more importantly it
213:04 - demonstrates in a pretty simple way how
213:07 - we can Define all of these Dom helper
213:09 - methods and then within our event
213:11 - listeners we'll just call those to
213:13 - basically change the Dom and change what
213:16 - the user is seeing from A View
213:18 - perspective
213:20 - before we uh go to the next set of event
213:23 - listeners I want to do one little
213:26 - refactor here and add a utility method
213:29 - for selecting elements as you can see
213:32 - we're using a lot of markup here just to
213:35 - select kind of basically using the same
213:38 - syntax and more importantly this is the
213:41 - the better reason to do this refactor
213:43 - we're not entirely certain whether this
213:46 - is going to result in a element being
213:49 - selected we can put these
213:52 - selectors in and check them over and
213:55 - over again but we really have no
213:57 - assurances that what we have attached to
214:01 - this list of elements is going to
214:03 - actually be valid selected elements so
214:06 - what we can do is at the very bottom of
214:09 - this class we can add a few helper
214:12 - methods
214:14 - what I'm going to call this is a Qs for
214:18 - that's short for query selector and then
214:21 - you should be able to pass in a string
214:23 - selector to that method and all I'm
214:26 - going to do is look for the element
214:30 - and that's going to be on the document
214:33 - dot query selector and then we'll pass
214:36 - in that selector that was in the
214:39 - parameters and then what we're going to
214:42 - do is make a check so we're going to say
214:45 - if there is no element that was selected
214:47 - so in other words we passed the wrong
214:49 - selector something went wrong
214:52 - we're going to throw a new error and the
214:55 - reason for that is we don't really want
214:57 - to continue
214:59 - um with our application and trying to
215:01 - perform all the additional logic if
215:04 - these selectors don't work in the first
215:05 - place because that will just mess up
215:07 - everything so we're going to say could
215:09 - not find elements
215:12 - and this will just give us as the
215:14 - developer some confidence that we're
215:15 - passing in the right selectors and here
215:18 - we can just return the element which we
215:20 - know is defined now
215:22 - so there's a few improvements we'll make
215:24 - to this but let's go ahead and try this
215:27 - out
215:28 - so with the menu we can just say this
215:31 - dot Qs and then we pass in the data ID
215:34 - and that should select the menu so let's
215:37 - go back to the UI you can see that
215:39 - there's no errors I'm going to get rid
215:42 - of this for for the moment because that
215:44 - was something left over from
215:46 - right here so let's get rid of that so
215:48 - we're not confused
215:52 - but this worked and so now what we can
215:55 - do is go down with the query selectors
215:58 - and replace these now you'll notice
216:02 - we've got a query selector all which
216:04 - will not work with our utility method so
216:07 - we'll leave that one alone for the time
216:09 - being
216:10 - so this dot Qs
216:13 - and then we'll replace all of these
216:18 - and save and as you'll see it all works
216:21 - there's no errors let's just demonstrate
216:24 - in air so let's pass an invalid selector
216:26 - now you're going to see unclawed error
216:29 - could not find elements we want this
216:31 - error to happen so that we know that we
216:34 - should go back to our code and fix it
216:36 - now just a few improve improvements that
216:38 - we can make with es6 class syntax the
216:42 - way that you define a private class
216:44 - method which is something that we don't
216:46 - want to expose to the outside world of
216:49 - this class
216:50 - you can put a dollar sign or not a
216:53 - dollar sign but a hashtag in front of
216:56 - the method so let me just demonstrate
216:58 - the difference here right now we have
217:00 - this as a public method on the class so
217:03 - if we go to app.js and we call the
217:06 - instance view dot Qs you're going to see
217:09 - in autocomplete on in vs code because it
217:13 - thinks that this is a public method but
217:16 - we really don't want to be calling this
217:17 - query selector from anywhere outside of
217:20 - The View
217:21 - um we don't want to be doing that from
217:22 - our controller so to make that private
217:25 - we'll put that hashtag save it and now
217:28 - when we try to grab this on The View you
217:31 - won't see it as a possible method that
217:34 - we can use now you could I think you can
217:37 - override this I'm not sure if it's
217:39 - enforced at runtime but it's just a good
217:43 - practice to keep everything private that
217:46 - you don't need outside that class
217:49 - we can also do that for the toggle menu
217:51 - so we'll put a hashtag there and we need
217:54 - to Now update the calls to this so this
217:58 - dot toggle menu or actually we may not
218:02 - let me let me check this let's go to the
218:04 - UI
218:05 - yep okay we need to update that so we'll
218:09 - say
218:11 - #toggle menu don't know what just
218:13 - happened
218:14 - and then query selector so this dot
218:17 - query selector
218:22 - just highlighting them all
218:25 - and let's grab the right one there and
218:27 - then the last thing we need to do is
218:29 - implement this query selector all as a
218:32 - safe method so one thing I want to do
218:35 - with the query selector is enable
218:38 - us to add like a parent element that we
218:41 - can pass
218:42 - so basically this will just give us some
218:45 - flexibility so we don't always have to
218:46 - search on the document
218:48 - so we'll say if there's a parent
218:49 - argument we're going to search from the
218:53 - parent
218:54 - otherwise we're going to search from
218:57 - the document
218:59 - so just a quick little refactor there
219:01 - then we're going to copy this whole
219:03 - method down
219:05 - we probably don't need the parent for
219:07 - this one but we'll call this query
219:09 - selector all
219:11 - and in this one
219:16 - it's going to be the same thing we're
219:18 - passing a selector but now we're just
219:20 - going to use a different Dom method so
219:23 - if there's not an element list
219:28 - we're gonna throw could not find
219:30 - elements otherwise we're going to return
219:31 - it so now we can replace
219:34 - that query selector all with this dot
219:38 - query selector all
219:40 - save it and make sure we don't have any
219:42 - errors which we don't and then finally
219:44 - let's just make a different name space
219:46 - for for
219:48 - um squares because it represents a node
219:50 - list well these just represent
219:53 - individual elements so we'll just make
219:55 - another namespace a double dollar sign
219:57 - which will represent the ones that we're
220:00 - picking
220:02 - as a node list so we'll assign the
220:05 - squares to that one just so that we have
220:08 - some separation
220:09 - a little bit of organization there
220:13 - all right let's continue our refactor
220:15 - looking at our app.js in the original
220:18 - implementation here the next thing that
220:21 - I want to cover and break out into a
220:24 - more concise method is some of this
220:26 - stuff right here so if you remember what
220:28 - we're doing here is we are adding an
220:31 - icon with a certain color to the square
220:34 - that was clicked and we're also updating
220:37 - this turn indicator up here in the top
220:40 - left so I think what we can do looks
220:44 - like we actually have an error here this
220:46 - dollar sign squares is undefined
220:49 - let's fix that before we keep going
220:52 - and the problem is is we've reassigned
220:55 - the squares to that double dollar sign
220:57 - but we did not update that down here in
221:00 - our event handler
221:01 - so let's save that and we should have
221:04 - that working again all right back to it
221:07 - we need to update this turn indicator
221:10 - and then of course when we click
221:12 - something we need to turn that event
221:14 - into an element in the Dom
221:16 - so we can break these out into two
221:19 - separate functions I think the first one
221:22 - is going to be setting a turn indicator
221:26 - so down here in our helper methods
221:30 - let's add a method called set turn
221:34 - indicator
221:36 - and for right now since we're not really
221:39 - we don't have the context of what player
221:41 - has actually made the move
221:45 - um we're just going to hard code
221:46 - something and then we'll fill it in
221:48 - later with something more dynamic
221:50 - so the first thing that we need to do is
221:52 - just look back at what what we're doing
221:55 - before we were basically creating a turn
221:58 - icon and a label and then giving some
222:01 - inner text to the label and setting a
222:06 - color on the icon so we'll do that same
222:09 - logic in the set turn indicator I will
222:13 - put a player
222:15 - as an argument but we're not going to
222:17 - leverage that just quite yet it'll just
222:20 - be kind of a placeholder so what we need
222:22 - to do is create an icon we can say
222:24 - document dot create element
222:27 - we want an i element and then we want a
222:30 - label
222:32 - which is going to be
222:35 - a paragraph element for now let's just
222:38 - assume that player is going to be either
222:41 - equal to one or two
222:44 - and we'll style it according to that
222:46 - we're going to update that in the future
222:48 - but just for now we'll assume that
222:51 - so for the icon we're going to look at
222:54 - the class list
222:55 - and we're going to add a certain color
222:58 - class based on the player so if player
223:01 - equals one we're going to call that
223:03 - yellow otherwise it's going to be
223:05 - turquoise
223:06 - that is similar to our logic here so if
223:09 - the current player is one we were
223:12 - calling the
223:14 - I'm sorry the square icon was the yellow
223:17 - and we're doing the opposite for the
223:18 - turn icon but this gets a bit simpler
223:22 - because right here we're tracking
223:23 - basically two pieces of State we're
223:25 - trying to see who was the current player
223:27 - that made the move and then for the next
223:29 - turn
223:31 - um we're trying to decide who's the
223:33 - player after that so we're mixing a lot
223:35 - of things and it's a little confusing
223:37 - really over here in the view we want to
223:40 - be more declarative and explicit we're
223:42 - just saying that player one is
223:45 - associated with yellow in player 2 is
223:47 - associated with turquoise
223:49 - same thing goes for the label
223:51 - we'll add the class list
223:54 - player equals one
223:56 - that's yellow otherwise turquoise now I
224:00 - think in our original implementation we
224:02 - weren't updating the color
224:05 - of the label or were we
224:09 - let's look at our HTML
224:11 - you can see we have an element called
224:14 - Turn which we really could just select
224:16 - this and add the color class to that so
224:20 - that's what we're already doing so let's
224:22 - stay consistent
224:23 - and do that here
224:25 - so instead of setting the color based on
224:28 - the player let's just say player one is
224:31 - fax
224:36 - and then for the message that were sent
224:38 - that we're adding we need to set the
224:41 - text content so let's delete that
224:46 - so if it's player one fax otherwise FAO
224:50 - we need to select one more element so
224:53 - turn
224:54 - div and I think we already have this it
224:57 - should be at the top here
225:00 - so right here we've selected the turn
225:02 - element
225:06 - so we'll say this dot dollar sign dot
225:08 - turn dot class list
225:11 - and we are going to add
225:14 - the color based on the player now there
225:17 - could be an existing color so we'll have
225:19 - to do two calls here so add and remove
225:23 - so we'll say if the player equals one
225:25 - we're going to add a yellow color
225:28 - otherwise we're going to add a turquoise
225:31 - and then what we're going to remove is
225:34 - if it's the player is one then we want
225:36 - to remove any turquoise class
225:39 - and otherwise we want to remove any
225:42 - yellow class so let's just make sure
225:44 - that we remove The Unwanted one and add
225:46 - The Wanted class
225:48 - this down here we're setting the actual
225:51 - icon that we're rendering and then the
225:54 - label we can set the inner text of that
225:58 - and we'll basically say if it is player
226:01 - one we'll say player one you're up
226:06 - otherwise we will say player 2.
226:10 - you're up now at this point this isn't
226:12 - going to do anything because we just
226:14 - kind of created these elements in memory
226:16 - we actually have to commit those to the
226:19 - Dom so what we need to do is select the
226:22 - turn div that we had modified up here
226:25 - with the classes and we need to replace
226:28 - children so that will just replace the
226:32 - child elements with first the icon and
226:35 - then the label that we created right
226:37 - here
226:38 - so let's save that and right now set
226:41 - turn indicator is not hooked up to
226:43 - anything
226:44 - but let's put that in our controller
226:48 - logic
226:50 - so if you remember we are binding a
226:53 - Player move event right here and we're
226:55 - just uh printing that to the console at
226:58 - the moment but what we can do now is
227:01 - reference The View
227:03 - and grab that utility method that we
227:07 - used now it is a private method by
227:09 - default so let me check if we need to
227:11 - make that public yeah let's go ahead
227:13 - let's make that public for now so that
227:17 - we can use it here
227:18 - so we'll say set turn indicator and for
227:22 - now we're just going to hard code the
227:24 - player ID we're not tracking any state
227:27 - yet so we're going to always say that
227:29 - we're going to pass in player one
227:31 - so let's save that and see what happens
227:34 - if we click a square
227:36 - it's not doing anything and we need to
227:39 - find out why so let's inspect the HTML
227:44 - if we click this Square
227:46 - just looks like it's not doing anything
227:48 - okay so now every time we click one of
227:51 - the squares we'd expect this to update
227:54 - to player one now it's already player
227:56 - one so you won't see a change so let's
227:59 - go back and instead of setting it to
228:01 - player one we'll set it to player two
228:04 - and when we click it now changes that to
228:08 - an O but we're not getting the right
228:10 - colors we're getting the right text
228:12 - getting the right icon but not the right
228:14 - Colors oh okay so our problem here is
228:18 - that by default our class
228:20 - of turn so this one right here is
228:23 - setting the color and then we're adding
228:25 - this turquoise class later which is not
228:28 - getting over it's not overriding that so
228:31 - a better way to probably approach this
228:33 - we'll go back to our CSS
228:36 - and instead of making that turn have
228:39 - this initial color we will handle that
228:42 - with the class so let me show you what I
228:46 - mean so I'll remove that from turn in
228:49 - CSS and then if we go to the HTML you'll
228:53 - see I'm just passing yellow as a class
228:56 - to style the initial icon and message
229:00 - and so now we're not coupling the color
229:02 - to the turn class so this should work
229:05 - you can see player two you're up
229:10 - um and it's going to set that every
229:11 - single time let's refresh
229:13 - so player one you're up and now we're
229:15 - going to hard code that to player two
229:17 - one other thing that you'll notice that
229:20 - I think I've kind of messed up is this
229:22 - icon has almost like italics to it
229:27 - um and that's because we're not adding
229:29 - the fa solid class so with font awesome
229:31 - you have to add fa solid
229:34 - and when we hit enter on that now it
229:36 - looks a lot better so we need to
229:38 - remember to add that
229:40 - let's go to our view
229:43 - and when we create this icon
229:46 - um let's
229:48 - make sure and add that class so
229:49 - classlist dot add
229:52 - f a solid
229:54 - and what you can actually do is pass
229:56 - this as two arguments so instead of
229:58 - doing that twice we can just pass f a
230:01 - solid and then give it a comma to do
230:04 - another argument and then we'll give it
230:07 - the actual icon to render
230:09 - so now you see we start with that X it's
230:12 - yellow it's player one and when we click
230:16 - we are hard coding it to be player two
230:19 - so we click and now it's an O player two
230:22 - and everything is that turquoise color
230:25 - so we know that our set turn indicator
230:27 - method is working correctly the next
230:30 - thing that we need to do is actually
230:32 - populate
230:34 - the square so we have to put an icon
230:36 - within the square and you can see in our
230:38 - original app logic somewhere right here
230:42 - we are adding the square icon and doing
230:45 - something pretty similar so let's go
230:48 - back to the view
230:50 - and this one is going to be called
230:54 - handle
230:55 - Player move
230:58 - and for this function we're going to
231:01 - pass the square element that was clicked
231:04 - so the reference to that and then the
231:07 - player that made the move so that we
231:10 - know which icon to put in there
231:12 - so this one will be rather simple we
231:15 - just need to create an icon similar to
231:17 - how we're doing here so we'll copy that
231:19 - logic so we're creating a new icon HTML
231:22 - element we are then adding a class list
231:26 - which we are going to put the fa solid
231:29 - remember we did that right here and then
231:32 - we can use the same logic to figure out
231:34 - whether it's going to be an X or an O so
231:37 - depending on the player and then finally
231:39 - we're going to reference the square
231:41 - element so whatever Square was actually
231:43 - clicked
231:44 - and we're going to replace children with
231:48 - that new icon that we have just set now
231:51 - of course we don't have a color
231:52 - specified so we can just group that here
231:55 - so if it's player one it's going to be
231:57 - an X and that's going to be yellow if
232:00 - it's player 2 it's going to be an O and
232:02 - that will be turquoise
232:04 - so let's save that and now we will call
232:07 - handle Player move in our controller so
232:11 - now you can start to see what the
232:13 - controller is supposed to be doing it's
232:15 - supposed to be kind of orchestrating the
232:17 - events that take place so we're going to
232:20 - set the turn indicator and then we are
232:22 - going to handle the player move and
232:24 - let's hard code player two so those are
232:27 - synced up
232:30 - so now when I click this Square we would
232:33 - expect that this turn indicator will
232:34 - turn turquoise with an O and this Square
232:38 - will
232:40 - um or actually now that I'm thinking
232:42 - through this we want the player move to
232:45 - be player one and then the turn will be
232:47 - set to the next player which will be
232:49 - player two once again we will refactor
232:52 - this so it's dynamic in the future we're
232:54 - just trying to get our view logic to
232:55 - work
232:57 - so let's save that
232:58 - and we'll click here and this should be
233:00 - a yellow X and then this will turn to a
233:03 - turquoise o
233:05 - and you can see it has not done anything
233:10 - and it says Dom token list add the token
233:13 - cannot contain white space
233:16 - so let's see what I did here okay so I
233:19 - cannot do this I actually messed that
233:22 - one up we need to duplicate this logic
233:25 - so that
233:26 - we're just doing one token per argument
233:36 - so just two little just a little
233:38 - refactor there and that should probably
233:40 - work
233:41 - so make sure we're refreshed and click
233:44 - Square element replace children's not a
233:47 - function because I'm just
233:48 - getting tired here
233:51 - um we can't just pass in that one we
233:53 - need to pass in the event Target so this
233:57 - will represent the square that was
233:58 - clicked and so we want to pass that into
234:01 - our method
234:02 - and hopefully third time's a charm as
234:05 - you can see it did work finally and just
234:07 - going to put X's everywhere yellow X's
234:10 - because we've hard-coded that in player
234:12 - two Zoe is going to be up
234:14 - obviously we want to make this a little
234:16 - better experience so at this point
234:20 - we have reached a place where we need to
234:23 - address this file
234:25 - store.js because we are doing some you
234:30 - know view logic but right now we're hard
234:33 - coding which player is up and if you
234:36 - remember from the earlier implementation
234:38 - we had the state variable right here
234:41 - where we're tracking the moves and then
234:43 - based on those moves we're getting a
234:46 - game status if there's a winner and
234:49 - we're also using that information to
234:52 - determine you know what's the current
234:54 - player and which you know icon and which
234:56 - colors am I going to add looking at our
234:59 - previous implementation this is kind of
235:02 - a critical moment in the refactor where
235:04 - we start to see things separating into
235:07 - different concerns so separation of
235:10 - concerns
235:11 - as you can see in our event listener for
235:14 - the player move we're doing multiple
235:17 - things we are changing what the user is
235:20 - seeing in the Dom so we're updating
235:22 - classes HTML elements so on and so forth
235:27 - and that's happening in logic just like
235:30 - this
235:31 - where we're replacing the children with
235:33 - some new elements now we're also doing
235:36 - something completely separate and that
235:39 - is reading and updating the state of our
235:42 - game
235:42 - so as you can see uh sprinkled
235:45 - throughout this uh listener we are doing
235:48 - things like checking if the square has a
235:52 - move and we're reading the state of the
235:54 - application to figure that out
235:56 - furthermore we're coming down here and
235:58 - we're actually mutating or changing the
236:01 - state of the application
236:03 - right alongside the changes to the view
236:07 - these two things are separate concerns
236:09 - and that's why we need this store.js
236:12 - file
236:13 - so similar to the view.js we're going to
236:16 - create a default class and Export it
236:20 - so we'll copy the syntax
236:23 - and this one's going to be called the
236:25 - store
236:27 - we of course need a Constructor
236:31 - and now one new thing that I'm going to
236:34 - introduce we're going to set two private
236:36 - methods
236:37 - we're going to add a get State method
236:41 - and a Save State method
236:46 - and what these are going to represent
236:48 - for us is a way to get a read-only copy
236:52 - of our current game State and then save
236:55 - state is going to change
236:58 - um and basically transition to the next
237:01 - state of the application now there's
237:04 - some really good articles online about
237:06 - State Management one of those is the
237:09 - Redux
237:11 - documentation Redux
237:14 - is I guess probably better to say it was
237:18 - the leading State Management solution
237:20 - for client-side apps for a long time now
237:23 - that react has kind of refactored and
237:26 - moved towards a functional component
237:29 - approach with use State and stuff like
237:31 - that it hasn't been used quite as much
237:33 - but there are some best practices that
237:37 - they have written over years of managing
237:40 - state within an application and they're
237:43 - very good to read through
237:46 - the one that I'm going to point us to is
237:49 - the Do Not mutate State best practice
237:53 - so mutating state is the most common
237:55 - cause of bugs in Redux applications or
237:58 - in applications in general including
238:01 - components failing to re-render properly
238:03 - and will also break time travel
238:05 - debugging in the Redux Dev tools so
238:07 - that's kind of specific to Redux
238:11 - um but actual mutation of State value
238:12 - should be avoided and we're going to
238:16 - stick to this approach because it's
238:17 - generally just a good idea and reduces
238:21 - the surface area for bugs to occur
238:24 - if you see from our original
238:25 - implementation we are directly mutating
238:29 - state so we're reading it up here where
238:33 - we're checking for something like the
238:34 - last move and then we're directly
238:36 - updating it here there's nothing
238:39 - terribly wrong with this at for the size
238:42 - of our application but it's just better
238:44 - to make sure that we're not doing that
238:48 - so what we're going to do here is
238:50 - actually add a private
238:53 - State variable and that's going to be
238:56 - equal to an array of moves so that's
238:59 - very similar to what we had up here
239:01 - right here but it's going to be private
239:04 - so only
239:05 - this class itself can read the state and
239:09 - write to it and we have to use an
239:12 - intermediate method to actually retrieve
239:15 - the state as I'll show in just a second
239:18 - so when we get the state all we're going
239:20 - to do is return this Dot
239:23 - State now this is kind of a redundant
239:26 - method you'll see why this is useful for
239:29 - us
239:30 - later in this video when we refactor
239:33 - this to use a little bit more persistent
239:35 - State Storage so we'll be looking into
239:38 - local storage right now that's not
239:41 - um needed so we're going to keep it like
239:43 - this but the get State method will just
239:46 - return this private State variable
239:49 - or property and then the save state is
239:52 - going to set it so we'll say this dot
239:56 - hashtag State and then that's going to
239:59 - be equal to whatever new state is passed
240:02 - in
240:04 - now something that's very useful when
240:06 - you have a Save State method is being
240:09 - able to reference the prior state within
240:12 - that method so rather than just passing
240:15 - a hard-coded object
240:17 - as new state I'm going to make a
240:20 - parameter called state or function
240:23 - and this can be passed as one of two
240:27 - things you can pass just a raw object or
240:31 - you can pass a callback function that we
240:33 - are going to give the previous value of
240:36 - state to so let me just walk through
240:39 - this it's a little bit confusing if
240:41 - you're not familiar but this will really
240:43 - help us out later
240:45 - so we'll say the previous state is equal
240:48 - to this dot get state
240:50 - so that's the previous state we're
240:52 - dealing with that's reading here
240:54 - and then we need to check what kind of
240:56 - argument that we're actually dealing
240:58 - with so we'll say let new state
241:01 - that's going to be just a
241:04 - variable that we're going to initialize
241:06 - but not assign yet and now we're going
241:09 - to say switch
241:11 - on the type of state or function
241:15 - so we've got a switch statement and
241:17 - we're going to look for a function type
241:19 - and we'll break from that or a object
241:24 - type because our state is an object and
241:27 - we'll break from that and then the
241:29 - default is going to be throw a new error
241:32 - invalid param or invalid argument passed
241:38 - to save state
241:40 - because we only want to handle these two
241:43 - cases
241:44 - so it's pretty simple from here if it's
241:46 - a function all we're going to do is say
241:49 - the new state is equal to the state or
241:52 - function which we know is a function
241:54 - here and then we're going to pass in the
241:57 - previous state so that whoever calls
241:59 - this has access to that
242:02 - now if it's an object we're just going
242:04 - to set the new state is equal to the
242:07 - um not the previous state
242:11 - but the state or function so in this
242:14 - case we've just passed a literal object
242:16 - and we just want to assign that to state
242:19 - then from here all we're going to do is
242:22 - basically later we'll save this to local
242:26 - storage but for now it's all good
242:29 - we'll just say this dot state
242:33 - is equal to the new state that we had
242:36 - just assigned right here
242:38 - so let's save that now we've got our get
242:40 - State and save State functions
242:42 - implemented and now we need to actually
242:45 - initialize this so we'll have a default
242:48 - value that we're passing into this store
242:51 - and this default value
242:54 - is going to
242:56 - we'll just call it initial value and
243:00 - we'll set that equal to moves and that
243:02 - will be an empty array so as you can see
243:06 - we've initialized it right there but
243:08 - really we can just refactor that to say
243:11 - initial value once again I know this is
243:13 - a bit contrived we're doing a little bit
243:15 - of indirect stuff but you'll see later
243:17 - why this makes sense once we start
243:19 - getting into local storage
243:22 - at this point if you're paying attention
243:24 - you'll probably notice that everything
243:26 - that we've defined here is a private
243:28 - method or property and therefore this
243:31 - class is not very useful so what we want
243:34 - to do is expose a getter method that
243:38 - allows us to read the state and then our
243:40 - application can take that state that
243:43 - we've read and do something with it so
243:46 - if you'll see in app.js one of the
243:48 - things that we had defined was get game
243:51 - status and we just passed in the moves
243:54 - that was you know in state and that's
243:57 - going to give us things like the status
243:59 - of the game if it's complete or in
244:01 - progress and then if there's a winner it
244:03 - will Define that so this is something
244:06 - that we'll need and we can Define that
244:08 - in the store now something I like to use
244:11 - when we're just reading a read-only
244:13 - value from a class is to add a getter
244:16 - method so if we add the get keyword
244:19 - followed by something like game and then
244:22 - we Define a method this is going to be
244:25 - evaluated at runtime and basically what
244:28 - we can do here
244:30 - where we initialize the store which we
244:33 - still need to do so store equals new
244:36 - store
244:37 - and that should have Auto imported
244:39 - things for us so import store from
244:41 - store.js
244:43 - so when we initialize that now
244:45 - store.game is a property that is
244:49 - available
244:49 - so let's just console.log store.game
244:53 - right now
244:55 - and we'll just return dummy value
244:59 - so let's go back to our UI and you can
245:01 - see that it prints dummy value now just
245:04 - to demonstrate if we remove that getter
245:06 - it's going to break we're just going to
245:08 - get a function called game so we would
245:11 - need to go over here and actually call
245:14 - that as a function to get the dummy
245:17 - value that we're looking for so that's
245:19 - why I like to just use a getter because
245:21 - you don't have to call anything you can
245:24 - just add that get keyword and then this
245:26 - acts as a property on the class instance
245:29 - so as you can see in our Handler for a
245:32 - Player move we are hard coding right now
245:35 - the player that is up so we obviously
245:39 - want to get that from the state of our
245:42 - game or from the store
245:44 - so to do that we're going to update this
245:49 - class property
245:51 - to basically derive some state so the
245:55 - goal with saving State as we talked
245:57 - about earlier is to keep it as simple as
245:59 - humanly possible and then we're going to
246:01 - derive as much as we can at runtime from
246:05 - that so that just makes it so that we
246:07 - only have to update a small piece of
246:10 - state and then we can just dynamically
246:11 - get the rest
246:13 - so I'm going to basically take this
246:16 - method that we had defined earlier
246:18 - get game status and I'm going to kind of
246:21 - refactor this make it a little bit
246:23 - simpler and the first thing that I'll do
246:26 - here is Define our list of players this
246:29 - is going to make things a lot easier for
246:31 - us and I'm just going to copy in from
246:34 - the completed app so we don't have to
246:35 - type things out and then I'll explain
246:37 - what we're doing here
246:40 - so down here I think at this point I'm
246:43 - going to collapse
246:45 - our app because we're once again not
246:48 - using this we're just using it as a
246:50 - reference
246:51 - so here we're going to define the
246:53 - players of the game how I've decided to
246:55 - represent these players is just a tuple
246:58 - or an array of players and we'll just
247:01 - know that the zero index is player one
247:03 - and the one index is player two
247:07 - now what we're doing is basically adding
247:10 - some configuration here so this is a
247:12 - configuration array that's saying we
247:14 - have got two players this is the name of
247:17 - player one they are going to be the X
247:19 - icon and they're going to have a color
247:21 - class of turquoise likewise player 2 O
247:25 - in color of yellow so this is going to
247:28 - help us with our internal logic quite a
247:30 - bit and I'll show you what I mean uh
247:33 - here in a second so before we even touch
247:36 - the store anymore let me just pass in uh
247:40 - players and then the first index so that
247:43 - would represent player two obviously
247:46 - this is going to break that method
247:48 - because we're not expecting an object so
247:51 - if we click stuff it's just not going to
247:54 - work correctly
247:55 - but if we go to The View
247:58 - and go down to that method that we had
248:00 - defined so set turn indicator
248:04 - this player now represents that object
248:07 - so now that we're passing an object as
248:09 - the player this logic here gets a bit
248:12 - simpler but the problem is if you look
248:15 - at our index.html we're defining the
248:17 - color on that top level which means we
248:20 - have to add and remove classes so really
248:23 - we would need to pass in player and then
248:25 - opponent and then here what we would do
248:28 - is say player dot let's see color class
248:34 - and then this one would be opponent
248:39 - dot color class so we're adding the
248:42 - players the current players color class
248:43 - and then we're removing the opponent's
248:46 - color class now a bit simpler way to
248:49 - handle this I know I'm kind of going
248:51 - back and forth here
248:53 - um but let's go back to index.html and
248:55 - remove the color property from this
248:58 - outer div and instead let's just
249:01 - initialize the color property of this
249:04 - each element Within
249:07 - so to start the game out we're going to
249:09 - have a yellow X for player one because
249:12 - that will be o is the first player so
249:15 - let's save that and then here in the
249:18 - view that means that we no longer have
249:20 - to remove classes
249:22 - and instead of looking at the turn we
249:26 - can just directly add these to the icon
249:28 - so icon.class list
249:32 - dot add and then we'll say player dot
249:35 - color class and then label dot
249:40 - um class list
249:44 - will also be color class
249:47 - we can remove the opponent here
249:50 - and then if we come down here let's just
249:52 - kind of group these icon classes
249:54 - together this is where we're defining
249:57 - which icon it is and rather than doing
249:59 - this switch here we can just say player
250:02 - dot icon class so remember we defined an
250:08 - icon class and a color class on each
250:10 - player so here we're adding the color
250:13 - class here we're adding the icon class
250:15 - and since we're doing the doing this to
250:18 - the same icon we can actually combine
250:20 - all of this
250:21 - so we'll say f a solid
250:25 - then a color class
250:27 - and then an icon class and we can delete
250:30 - this line so this will pass to all three
250:32 - of those
250:33 - then finally the label gets a color
250:36 - class and then we need to update the
250:39 - label inner text but instead of these
250:42 - static strings once again we've made it
250:44 - easy for ourselves in our configuration
250:46 - so we can just say player.name
250:50 - as you can see right here we've defined
250:53 - a player name so we can just add some
250:57 - string interpolation here
251:01 - and we'll say player one
251:05 - you're up
251:07 - and then finally we're getting the
251:09 - container and we're replacing it with
251:11 - the icon in the label so now that we've
251:14 - done that we should be able to uh see
251:18 - this working so we don't need to pass
251:20 - that opponent anymore just the player so
251:23 - let's go back and click something so
251:26 - this should be turquoise not yellow so
251:29 - let's see what's happening here
251:31 - we're passing in players index of one so
251:35 - we're basically passing this object
251:36 - we'll bring that over to The View
251:39 - just so that we have a reference
251:42 - to see what we're passing
251:44 - so that's the object that is being
251:46 - passed in this case
251:49 - and we are grabbing the color class
251:53 - which is defined as yellow and the icon
251:56 - class which is O so that's our problem
251:59 - our configuration object is actually
252:01 - different
252:02 - let's check the final implementation so
252:05 - the vanilla refactor
252:07 - you can see that the x is turquoise and
252:10 - the O is yellow so I actually had things
252:13 - backwards this whole time I apologize
252:16 - the O should be yellow and the X should
252:18 - be turquoise
252:21 - so I think this is intended Behavior
252:25 - let's delete that
252:26 - and then instead of player two we'll
252:29 - pass in player one
252:31 - and let's see that is working a little
252:34 - bit better
252:35 - we've got a blue X and then if we load
252:39 - by default we need to update that as
252:41 - well
252:43 - so this should start as turquoise
252:47 - this should start is turquoise so player
252:49 - one you're up
252:51 - a turquoise X is that the same thing we
252:54 - get here let's reset yep we get a
252:57 - turquoise X so we're starting in the
253:00 - right State and then as we click
253:02 - something
253:06 - we should be getting that to change so
253:08 - let's
253:09 - click for player two
253:11 - and there we go we've got a yellow o
253:13 - with player two text added in there
253:17 - and then the last thing we can kind of
253:19 - re-factor here is the handle Player move
253:22 - instead of just hard coding in one we
253:26 - can hard code in players at one
253:30 - so we'll go back to handle Player move
253:34 - and this player is now an object
253:37 - so we can replace this here with player
253:40 - dot icon class
253:43 - and then player.color class
253:47 - save that make sure our icons are going
253:50 - in correctly and it looks like they are
253:53 - so that is refactored that makes things
253:55 - a little bit easier for us to handle and
253:59 - now we can go to the store and start
254:01 - defining this read-only game State
254:04 - variable right now we're just returning
254:07 - a dummy value which is not useful to us
254:09 - but the purpose of this getter method
254:13 - is to basically take the raw State
254:16 - object which is just an array of game
254:18 - moves and calculate all sorts of useful
254:22 - information from that
254:24 - you can already see we've done that
254:26 - um with our get game stats right here or
254:30 - get game status so the the things that
254:33 - we're really doing here is checking for
254:35 - a winner and then also at some point
254:38 - we're going to have to figure out who's
254:40 - the current move
254:42 - um or who's up to play so we can
254:45 - Encompass all of that within a single
254:48 - method here and we're going to build
254:50 - this uh kind of piece by piece until we
254:53 - have something to read from so that we
254:55 - can determine down here in our
254:57 - controller method where we're setting
254:59 - the turn indicator and handling the
255:02 - player move that way we can just pass in
255:04 - that derived state so that these methods
255:07 - know what to actually do with the UI
255:11 - so let's start out by getting the
255:14 - current player so we will First grab
255:17 - state
255:19 - which can be read
255:20 - with the get State method so this is
255:23 - just a assignment we could just read
255:26 - this directly but nice to have a
255:28 - variable to work with here
255:30 - so that is the first step and then we're
255:33 - going to derive the current player with
255:36 - a little trick and I believe the
255:39 - original
255:40 - creators of this game that I'm
255:43 - refactoring here already had this little
255:46 - trick and they were using it but we can
255:48 - use the modulus operator to basically
255:51 - determine the current player so what
255:53 - that looks like is we'll say the current
255:55 - player is equal to
255:58 - um the list of players which we do not
256:01 - have access to here but really just a
256:04 - list of players and then we can grab the
256:07 - index of that based on
256:09 - um how many moves have been made within
256:12 - the game but like I said we don't have
256:14 - the list of players so one thing that we
256:16 - need to do is pass that to the store so
256:18 - that it has access to that
256:21 - so we'll pass that array of players and
256:24 - then we'll set a player's
256:27 - property on the class and so that way we
256:31 - can access it right here and then grab
256:34 - whichever player we want so we'll put in
256:36 - zero for now as a hard-coded value let's
256:39 - go back to app and where we initialize
256:42 - the store
256:43 - since we have the list of players right
256:46 - here we can just pass that array down to
256:49 - the store via the Constructor so at this
256:52 - point what we can do is we can say State
256:55 - DOT moves dot length so that will tell
256:59 - us how many moves are in this current
257:01 - game
257:02 - and we can use the modulus operator and
257:06 - use it modulo 2 which will basically
257:09 - give us either a 1 or a zero based on
257:14 - the the number of moves so if we just
257:17 - open up a terminal here and open up a
257:22 - little playground with node.js
257:24 - you can see that if we have let's say an
257:27 - array of moves and let's just say it's
257:31 - one two one two just to fill it up so we
257:35 - currently have a moves.length of four So
257:38 - based on this if player one is the
257:41 - starting player then we know that player
257:43 - one made this move player two made this
257:45 - move one made this move and two made
257:47 - this move so who's up next
257:50 - well the way that we can determine that
257:52 - is basically just doing moves.linked
257:55 - modulo 2. and that will give us a zero
257:58 - and since our players array is just two
258:03 - objects the zero index is going to be
258:06 - player one and the one index is going to
258:09 - be player two so if we were to push a
258:12 - new move to that array so let's say
258:15 - player one moves now if we do
258:17 - moves.length modulo two we get one which
258:21 - is the index of player two so you can
258:25 - see how based on the length of this
258:27 - array we can quickly determine who the
258:30 - current move belongs to so we'll go to
258:33 - the store and we will do this operation
258:37 - to get the current player and then from
258:39 - there we can also derive the next player
258:43 - in the game so we'll say but we actually
258:46 - might not need that let's hold off on
258:47 - that one for the moment
258:49 - so let's go ahead and return the current
258:52 - player as part of an object so we now
258:55 - have that as part of our game state
258:58 - and then we can come down here to the
259:00 - set turn indicator and we're going to
259:03 - reverse this because first we need to
259:06 - actually handle the player move and I'm
259:08 - going to make a variable to keep things
259:10 - clear
259:11 - we will say that the clicked square is
259:15 - equal to the event.target because that's
259:17 - what that actually represents if you go
259:20 - back to the view where we are binding
259:23 - that move we're just looping through the
259:25 - squares and adding that event listener
259:27 - listener which is going to pass the
259:30 - individual Square to that Handler that
259:33 - was clicked so that's what that
259:35 - represents and just for clarity we can
259:38 - pass it like that and then for the
259:41 - current player that we want to move now
259:44 - we have some game state so we can say
259:47 - store Dot Game Dot currentplayer
259:51 - and that should satisfy the stub of this
259:54 - method so we are now passing the current
259:57 - player in and at this point we need to
260:00 - update some of our state because we of
260:03 - course have made a move by this player
260:05 - and now we want to set the turn
260:06 - indicator but we don't want to set that
260:09 - for the current player because they have
260:10 - just moved we want to do it for the next
260:12 - player so we need a way to update the
260:15 - state to advance it to the next play
260:19 - so the way we can do that is make a
260:21 - method in store a public method called
260:25 - let's see what I called it in the final
260:28 - project I think I just called it Player
260:31 - move and what we're doing here is
260:34 - passing a square ID so that's one
260:37 - through nine based on which one was
260:39 - clicked and to follow our Convention of
260:41 - not mutating State directly we first
260:44 - need to grab state from the getter
260:47 - method that we've defined right here so
260:50 - we're returning that private variable
260:52 - then we need to make a clone of it so
260:55 - we're going to go ahead and
260:58 - call that state clone and there's a
261:01 - built-in method to browsers called
261:05 - structured clone which you can pass an
261:07 - array an object pretty much anything and
261:09 - it will give you a clone of that object
261:11 - so we're no longer referencing we're no
261:15 - longer passing a value by reference
261:17 - where we've got a completely different
261:19 - object that we're able to mutate here
261:23 - so from this point we can go ahead and
261:26 - take the state clone and push a new move
261:29 - to this array
261:31 - um actually we don't want to push it
261:33 - directly there because the the state
261:35 - object has an array of moves but that is
261:39 - a property so what we're really saying
261:42 - is State clone dot moves dot push and
261:46 - then we need to pass in the Square ID
261:49 - right here and then also the player ID
261:52 - so or not the ID we'll just pass in the
261:55 - player that is currently up so that
261:59 - would be state or not state but this Dot
262:02 - Game remember we just derived that up
262:05 - here so we can actually access that
262:07 - property within the class
262:09 - and we can pass it the current player so
262:12 - when we call Player move it's going to
262:15 - take the square ID that was clicked and
262:18 - the current player that was up and push
262:20 - that as a move to the state object so
262:23 - that's going to actually update our
262:25 - state for us
262:27 - um but the last step we need to call is
262:30 - this dot Save State in this case our
262:33 - state object's pretty simple so we can
262:35 - just pass in that literal object rather
262:39 - than a callback function but we'll come
262:41 - back and refactor this as we develop our
262:44 - state handling a little bit further
262:46 - later on so let's save that and then
262:49 - back in app.js all we need to do now is
262:52 - call store dot Player move
262:55 - in here we just need to pass the click
262:58 - square but we need to pass an ID so
263:02 - really what that is is going to be dot
263:05 - ID and we need to cast that to a number
263:08 - because uh the event ID or the event
263:11 - targets ID will come as a string by
263:13 - default so we're passing in a number ID
263:16 - and we're updating state so at this
263:19 - point we're allowed to Now set the turn
263:21 - indicator to the current player because
263:24 - that has been updated with this method
263:27 - so we can go back to the store.game dot
263:30 - currentplayer and set the turn indicator
263:33 - now the important thing to notice here
263:35 - is that this store.game.current player
263:39 - is a different player than this
263:42 - store.game.current player and that is
263:44 - because we have made a state change
263:46 - happen in between the two and every time
263:49 - that state changes that getter value
263:53 - that we've defined right here is going
263:55 - to automatically re-evaluate and update
263:58 - so if all worked when we click a square
264:01 - it should update things dynamically so
264:04 - it says player one you're up and we
264:06 - click
264:07 - and now we've played with player one
264:10 - with that X and you can see player 2 is
264:12 - now up now we should be able to click
264:15 - and we get an O and now player one is up
264:18 - so now we have this working again but if
264:21 - you remember from the original
264:23 - implementation we had one big problem
264:25 - and that's if you click twice on a
264:28 - square so we need to make sure that we
264:31 - are not updating a square twice and that
264:34 - should be relatively simple to handle so
264:37 - let me comment some things in here we
264:40 - will say
264:41 - um
264:42 - place an icon of the current player in a
264:47 - square
264:49 - advance to the next state by pushing a
264:54 - move to the moves array
264:57 - and then
264:58 - set the next players turn indicator
265:03 - now up here at the top this is where we
265:05 - need to check whether there's an
265:07 - existing move
265:08 - so you can see in our original
265:11 - implementation what we did here was we
265:14 - made a little helper method that says
265:16 - whether a square ID has an existing move
265:19 - and then we checked if that current
265:22 - Target matched that and if it did we
265:24 - returned early
265:26 - so we can actually we could make a
265:29 - helper method to do this
265:31 - within the store or we could just check
265:34 - it inline I'm going to go ahead and just
265:36 - check this inline as you'll see in just
265:39 - a second
265:41 - so let's collapse the app
265:44 - and let's say the existing move is going
265:47 - to be equal to the store dot game
265:50 - that moves dot find and so we're looking
265:55 - for a specific move that has a square ID
265:59 - equal to the clicked Square dot ID and
266:03 - we need to make sure that that is a
266:05 - number
266:05 - so we're comparing the same thing
266:08 - so if there's an existing move
266:11 - if that's not undefined basically we're
266:13 - going to return early and we're not
266:15 - going to handle that Player move
266:17 - save the state or set the turn indicator
266:20 - let's save that and now let's play and
266:24 - it looks like we've got a problem and
266:27 - you can see that we're getting an error
266:29 - here by reading the
266:31 - store.game.moves it says that it is
266:33 - undefined and that makes sense because
266:35 - we have not actually added that to our
266:39 - getter so let's go back to the store and
266:43 - remember game is only returning the
266:45 - current player so it would be nice if we
266:48 - also just gave it uh the moves array
266:51 - just so we have access to that
266:54 - so we'll save that and now things should
266:57 - work a lot better so now if we click
267:00 - something twice it's actually still
267:03 - messing up and I believe this is because
267:05 - of the same reason we ran into earlier
267:07 - that I failed to recognize once again
267:12 - when we're binding to this Player move
267:14 - event if you look in the view
267:17 - we are basically just passing
267:20 - um the event
267:22 - uh to the Handler and that event could
267:24 - have been an icon that was clicked so
267:27 - instead of just blindly passing the
267:29 - Handler right here what we really need
267:32 - to do is break this out into a function
267:35 - and pass the square itself that we are
267:39 - setting the event listener on rather
267:41 - than the event Target which was the
267:44 - default that was passed
267:45 - so let's update that go back and see if
267:49 - that fixed things for us
267:51 - Square element is undefined
267:54 - we just need to make one adjustment here
267:57 - it is no longer an event that's being
267:59 - passed it's a square reference so this
268:03 - is actually more expressive anyways so
268:07 - we will check
268:10 - Square
268:13 - and then update these references
268:19 - and hopefully finally this will work
268:23 - so we're clicking clicking click it
268:25 - again and it does not do anything as we
268:27 - expected so now we've got a lot more
268:30 - stable behavior and we're almost back to
268:33 - where we started but of course we've got
268:35 - a tic-tac-toe in two places and the game
268:38 - has not recognized that yet and that's
268:40 - because we need to once again build up
268:43 - our
268:45 - derived state which is in this method
268:47 - right here the last piece of state that
268:50 - we need to derive in this game property
268:53 - or getter is who has won the game we've
268:57 - already done this in our previous
268:59 - implementation
269:01 - we did this right here where we were
269:05 - checking the player moves the winning
269:06 - patterns and then checking the player
269:08 - moves against those winning patterns
269:10 - we were then deriving it as a status and
269:14 - a winner so I'm going to do something
269:16 - similar to this but we're going to
269:19 - simplify just a little bit in this new
269:22 - derived State method
269:25 - so the first thing we'll do is copy in
269:27 - those winning patterns because those are
269:29 - just static and then we'll initialize
269:31 - the winner to be equal to null
269:34 - just to get a variable in place
269:38 - and then what we're going to say is four
269:40 - we're going to do a for Loop
269:43 - we're going to Loop through each player
269:45 - so for player of this dot players so
269:49 - remember we initialized the list of
269:52 - players which is just two people in the
269:55 - Constructor so we can Loop through each
269:57 - player and then within that Loop we can
270:01 - get the selected Square IDs of that
270:04 - player so we'll say this
270:07 - dot game
270:11 - dot moves
270:13 - and remember this is just the current
270:16 - state of the game so this.game.moves
270:20 - or I'm sorry we should probably not do
270:22 - that because we're referencing this
270:24 - method from itself
270:26 - so what we need to reference is this
270:29 - state uh
270:31 - variable right here where we're getting
270:34 - the raw state so we'll say state DOT
270:39 - moves and we're going to filter those
270:42 - moves to only be the moves of the
270:45 - current player
270:46 - that we are looking at
270:52 - so just walking through this logic a
270:54 - little bit we've got the array of raw
270:57 - state of moves and we're going to filter
271:01 - out
271:02 - any player that does not match the
271:05 - current player in our Loop furthermore
271:08 - we're going to map that resulting array
271:12 - and just grab the square ID off of the
271:16 - individual move so if you remember we're
271:19 - pushing a square ID and a player to that
271:22 - moves array so that's basically what
271:24 - we're reading
271:26 - off of this right here so we've got a
271:29 - list of selected Square IDs for the
271:31 - current user and now we're going to do
271:34 - an inner loop
271:35 - and we're going to say for pattern of
271:37 - winning patterns
271:41 - now we're going to check check if the
271:43 - pattern
271:44 - matches every one of those selected
271:48 - Square IDs
271:49 - or actually I should probably say if the
271:51 - square IDs has every element of the
271:54 - pattern so we'll say selected Square IDs
271:58 - includes that value
272:01 - and so this will check if there is a
272:03 - winning pattern and if that's the case
272:06 - we're going to set that winner variable
272:08 - that we initialized up here to whatever
272:11 - player we're in during that Loop in
272:15 - other words we're going to go through
272:16 - this Loop and if no winning patterns are
272:19 - found the winner is going to be left
272:21 - equal to null which is going to tell us
272:24 - that this was a tie game
272:27 - along with the status of the game so
272:30 - we'll come down here and add a status
272:32 - property
272:33 - and we're going to say is the game
272:36 - complete this is going to be true if the
272:39 - winner does not equal null so if the if
272:43 - there is a winner populated we know the
272:45 - game's complete or if the
272:48 - state.moves.length is equal to nine
272:50 - because we know that that's the maximum
272:53 - number of moves that can be be played in
272:56 - a given game
272:57 - and then finally we'll pass the winner
272:59 - variable right here which will either be
273:02 - null or set equal to some player
273:05 - so now we have some derived State and
273:09 - I'll just remind you that we are
273:11 - deriving all of this information
273:14 - the current player the status whether
273:16 - it's complete whether there's a winner
273:18 - we're driving all that off of one simple
273:21 - array of game moves so that's going
273:24 - along with our pattern of trying to keep
273:26 - State as simple as possible and then
273:28 - deriving what we need to know from it
273:30 - later on dynamically now that we have
273:33 - this information populated we should be
273:36 - able to come back to our app.js or our
273:40 - controller and this is where we will
273:43 - check whether there's a winner and if
273:45 - there is we're going to open up some
273:47 - sort of modal
273:49 - to show that status to the user if you
273:52 - remember from our first implementation
273:55 - we had
273:57 - um let me collapse some of this stuff
273:58 - we're not using
274:01 - so if you remember from here at the very
274:04 - bottom this is where we're checking the
274:06 - game status and if the game is complete
274:09 - we're going to remove the hidden class
274:11 - on that modal so that it opens up
274:14 - and then we're going to set a message so
274:18 - we can make some utility classes or some
274:21 - Dom helper methods within our view class
274:23 - to achieve this so let's go back to the
274:27 - view class and hook up some of those
274:29 - methods we can put them pretty much
274:31 - anywhere I'll just put them at the top
274:32 - here the first one that we'll want is an
274:35 - open modal method and we're going to
274:38 - pass in a message
274:41 - and what we'll do with that is select
274:45 - the modal itself
274:48 - and that's going to be the one that we
274:51 - removed the class from
274:53 - so there's the modal in our index.html
274:56 - that is this entire div that's got
274:59 - hidden on it so let's remove that real
275:01 - quick and you can see how it pops that
275:03 - up
275:05 - so really what we're trying to do is
275:06 - just toggle that class
275:08 - in the way we'll do that
275:11 - so we'll come down to our helper method
275:13 - and we'll look at the class list and we
275:15 - will remove
275:17 - the hidden class
275:19 - so very similar to what we were doing
275:20 - before
275:21 - so let's just try this little
275:24 - um
275:25 - helper out right now to make sure that
275:28 - it's working and then we'll come back
275:29 - and improve it with
275:31 - an actual message that we can show
275:35 - so we're coming down here we've set the
275:37 - turn indicator for the next player
275:40 - and now it's probably time to check
275:43 - whether someone has won the game
275:45 - so really we need to do this before we
275:49 - set the turn indicator because this will
275:51 - update that text up here and if the
275:54 - game's over we don't really want that to
275:55 - change
275:56 - so here's where we check that state
275:58 - we're going to say if the store dot game
276:02 - dot status is complete
276:05 - this is where we're going to perform
276:07 - this logic and we're going to add a
276:09 - return statement here because if it's
276:12 - complete we know we don't want to run
276:13 - this logic so we always want to return
276:17 - at this point we'll call View
276:19 - Dot openmodal and that should open
276:22 - things up for us so let's go to the game
276:24 - and play it
276:26 - and see if it recognizes this winning
276:28 - pattern
276:29 - and it does so we see player one wins if
276:33 - we click play again it's not going to do
276:34 - anything because we haven't updated that
276:36 - event listener
276:38 - so let's refresh the game start over
276:41 - and at this point we need to pass in
276:43 - some a message to say who won the game
276:47 - and we can go ahead and derive that
276:57 - so we'll put in a variable here
277:02 - or actually we should probably not do
277:04 - that yet
277:05 - we want to say if the store.game
277:08 - dot status
277:10 - dot is complete or no we already know
277:12 - that dot winner
277:16 - if there is a winner then we want to say
277:20 - store.game.status.winner dot name
277:23 - because that's a player that we're
277:24 - referring to
277:26 - and then we'll say wins otherwise it's
277:29 - going to be Thai
277:31 - so that should be the correct Logic for
277:34 - opening the message in the modal
277:36 - we still don't have any listener for
277:40 - resetting the game but player one wins
277:43 - let's reset real quick in this case
277:45 - let's make sure that player 2 wins
277:48 - and it's still saying that player one
277:50 - has won the game so we've got a little
277:52 - bit of a problem here and it's actually
277:55 - not a problem I'm just getting tired and
277:58 - forgetting things in our view when we're
278:01 - opening the modal we have to actually
278:03 - update the text within it so this dot
278:06 - modal text
278:08 - dot inner text is going to be equal to
278:11 - the message
278:14 - so let's try that again
278:16 - let's make sure player 2 wins
278:19 - so here we go we got player two wins
278:22 - refresh and then if we have player one
278:25 - wins that'll show up there so the last
278:27 - thing we need to do is register an event
278:30 - listener on this play again button which
278:32 - will reset the game State since we're
278:34 - resetting the state we need to do this
278:37 - event listener outside of the view this
278:40 - bind game reset event is meant to be
278:44 - um
278:45 - a Handler for whenever we click this
278:47 - reset button but we can also overlap and
278:51 - use it for when the game is complete so
278:54 - not only do we want to register that on
278:56 - the reset uh button we also want to
279:00 - register that on the modal button
279:03 - because that is going to also reset the
279:05 - game and do the same exact thing
279:08 - so we'll pass in the same event and the
279:11 - same Handler and make sure that's hooked
279:13 - up
279:14 - then when we go back to app
279:17 - and we go to the bind game reset event
279:19 - this is what we need to now fill in
279:22 - so whenever this pops up
279:25 - and we have
279:27 - an end State when we click this we want
279:30 - everything to close and reset so one
279:33 - thing we need to implement is the close
279:35 - modal helper method
279:38 - so right next to open modal
279:40 - we'll make one that says close modal
279:43 - and this will be very simple
279:45 - we will just add the hidden class
279:49 - this time so let's go ahead and call
279:52 - that
279:53 - close modal
279:54 - and see if that works so we should be
279:58 - bound to this button here and when we
280:01 - click it it should now close the modal
280:03 - which it does but you can see the state
280:06 - has not reset which we want to have
280:08 - happen so this is a job for the store
280:10 - class
280:12 - and we need to just Implement a method
280:15 - let's put it under Player move and I
280:18 - think I called this just reset in the
280:20 - final implementation so we'll say reset
280:24 - within this method we're basically going
280:26 - to read
280:28 - or we're going to just set the state to
280:30 - be empty so we can
280:33 - just call Save State and we'll set it to
280:36 - the initial value
280:39 - so initial value is referencing this
280:42 - right here so this is basically
280:44 - resetting the game now if you'll notice
280:46 - we're not saving any history of past
280:50 - games we'll eventually add that but for
280:52 - right now we just want to get things to
280:54 - reset correctly so over in app.js we are
280:58 - closing the modal and then we're calling
281:00 - from the store we want to reset the game
281:03 - and then the one last thing we need to
281:05 - do just to make sure that player one is
281:08 - going to be up at the beginning of the
281:10 - next game is say view dot set turn
281:14 - indicator and you remember we can just
281:16 - pass a player there
281:18 - so we should be able to just pass
281:21 - players zero because that represents
281:23 - player one and we always want to reset
281:26 - to player one
281:28 - now another way to do this is we know
281:30 - that the after we've reset the state we
281:34 - know that if we access
281:36 - store.game.current player
281:38 - that's going to also give us player one
281:40 - so that's probably a more semantic way
281:43 - to do that
281:44 - so let's command s to save so we're
281:47 - going to close the modal reset the state
281:49 - and set the next turn indicator so
281:52 - everything should be cleared out at that
281:54 - point the only thing that we're probably
281:57 - missing is we don't have a method to
282:00 - clear the game board so we're resetting
282:03 - this state itself but we're not clearing
282:05 - the game board so let's go to the view
282:07 - and we'll say clear moves
282:11 - and what we're going to do is just
282:14 - look at these squares
282:16 - how did I access this hold on yep so I'm
282:19 - just accessing it like this so for each
282:23 - Square
282:27 - I just want to clear things out so
282:28 - Square dot replace
282:30 - children and leave that empty to
282:33 - basically just clear everything out
282:35 - so we need to clear the moves
282:38 - after we've reset the store so view dot
282:41 - clear moves and then we'll set the turn
282:44 - indicator and this should pretty
282:46 - sufficiently clear everything from the
282:48 - state and The View
282:50 - so let's refresh and play the game
282:54 - player one wins and when we click play
282:56 - again everything clears and player one
282:59 - is going to be up
283:00 - so if we do the same thing for player
283:03 - two player two wins you can see player
283:06 - two is up but that will reset to player
283:08 - one you are up at the end
283:11 - but obviously at this point we have a
283:14 - working game but if we started to play
283:16 - then we refresh the browser it's going
283:19 - to reset
283:20 - if we play and player one wins and we
283:23 - click play again none of this stuff is
283:25 - being tracked down here we have no
283:28 - history of games of the past so if we
283:32 - wanted to implement that that's going to
283:34 - basically be the next phase of this
283:36 - video and it's going to get into some
283:38 - really cool concepts with local storage
283:41 - and finally we will kind of refactor
283:44 - this to be a little bit more declarative
283:46 - so that we can just kind of react to all
283:49 - of these State changes and render
283:51 - whatever UI should be based on that
283:54 - current state one last thing I wanted to
283:56 - test let's make a move on the game board
283:59 - and I believe we should be able to click
284:02 - reset
284:03 - and everything resets okay
284:06 - now this does not close which we're
284:08 - going to want to implement but just
284:11 - wanted to show you that because we
284:12 - actually indirectly implemented this
284:15 - reset method when we were working on
284:17 - handling a winning game and how we did
284:20 - that remember when we binded to the game
284:24 - reset event that is actually linked to
284:28 - both the reset button and the modal
284:30 - reset button so it's running the same
284:33 - Handler regardless now as you saw that
284:37 - doesn't close everything so in app.js
284:40 - where we are closing the modal let's
284:44 - refactor this to not do closed modal but
284:47 - close all
284:49 - and we need to implement that method
284:51 - we'll put that right under close modal
284:54 - and we'll say close all
284:56 - and this is basically going to
284:59 - um
285:00 - call the close modal so we're going to
285:02 - close the modal and then we want to
285:04 - close the menu we currently have a
285:06 - toggle menu method but we also want to
285:10 - have a close menu method so this is
285:13 - going to look pretty similar to this
285:15 - method we're just going to say this dot
285:18 - dollar sign dot menu items
285:21 - and then on that class list we're going
285:23 - to add hidden to make sure that it's
285:25 - closed we're going to also remove the
285:29 - Border
285:30 - so remove the border on the menu button
285:34 - because when that's closed we know that
285:36 - should not be there
285:37 - and then we'll reselect the icon because
285:40 - we always want to make sure that that is
285:42 - going to be the icon that points down
285:46 - so let's just copy these two
285:49 - and instead of toggle we're going to add
285:53 - this one and remove this one so when we
285:56 - call close menu it's just going to make
285:58 - sure that everything is in its closed
286:00 - state
286:02 - and then we'll add that to
286:04 - the close all method and at this point
286:07 - we can make this close menu a private
286:10 - method because that's only being called
286:11 - here
286:12 - we can also make closed modal it's put
286:16 - that down here and make that a private
286:18 - method because it's only being called
286:20 - here
286:21 - so now we have a helper method close all
286:23 - that is being called when the game is
286:26 - reset and that should clear all the
286:28 - state so if we make a move open this
286:31 - actions and reset
286:34 - it's going to say closed modal is not a
286:37 - function
286:39 - and that's because we are not
286:42 - referencing it from its private
286:44 - declaration so now that should work
286:48 - so make a move
286:49 - reset that closes this resets game board
286:53 - is cleared and everything is working
286:56 - great so as I mentioned we're not
286:58 - tracking down here the history of all
287:01 - the games that have been played and we
287:04 - also don't have anything happening here
287:06 - when we click new round
287:09 - so in order to track that we need to
287:12 - update our state object
287:14 - so right now this is the initial value
287:17 - we're just tracking an array of moves
287:19 - but really what we need to be doing is
287:22 - tracking an array of moves and a history
287:25 - object that has the current round gains
287:31 - and that should be an array and then all
287:34 - games which is just basically all the
287:37 - history from
287:38 - you know all the time so with this
287:42 - information right here we should be able
287:44 - to calculate some statistics of how many
287:48 - wins each player has so just for clarity
287:51 - I'm going to also update update this to
287:54 - current
287:56 - um or current game moves
287:58 - so this will still represent the same
288:00 - thing we just need to update
288:03 - our references to here so current game
288:07 - moves
288:11 - current game moves do we have it
288:14 - anywhere else
288:15 - okay I think that's it so if that worked
288:18 - um we should be
288:20 - able to see the same functionality
288:23 - things should still be working
288:26 - and it looks like it is
288:28 - and so now all we need to do to start
288:31 - tracking this is when we reset the game
288:35 - instead of just saving the state back to
288:37 - the initial value we should update the
288:40 - state to basically take that finished
288:43 - game that we just completed push that to
288:46 - the history and then start a new game
288:49 - so what does that look like so to start
288:52 - tracking the history here let's just
288:55 - refactor a little bit right up here so
288:59 - we don't really need two variables let's
289:01 - just pass
289:03 - get State into structured clone
289:07 - and we'll just call this one state clone
289:10 - so that's for the player move
289:12 - and that should remain the same the
289:15 - reset method is where we're really going
289:17 - to do some updating in the reset method
289:21 - we're going to have to check for a very
289:23 - specific condition
289:26 - and that is if this dot game so we're
289:29 - reading that getter up here that we've
289:31 - defined
289:33 - um dot status is complete
289:36 - if it's complete we want to push this
289:39 - game that we're resetting to the history
289:42 - object or the history array
289:44 - and if it's not complete then we just
289:47 - want to reset it totally because
289:49 - remember
289:50 - in the view we're adding this reset to
289:54 - two different places we're adding it to
289:57 - this drop down right here which could
289:59 - reset the game even if it's incomplete
290:02 - we're also adding it to this button
290:04 - right here when the game is complete so
290:07 - we need to make sure that we're checking
290:09 - that before we push an incomplete game
290:12 - to the history
290:14 - so all we need to do is check for
290:18 - um the moves we can destructure that
290:21 - from this Dot Game really we should just
290:25 - destructure all of this stuff
290:27 - so we'll say status moves and then I
290:33 - think that's it
290:40 - so now we can reference status that is
290:42 - complete
290:45 - and we should also make a state clone
290:48 - because we're not going to mutate State
290:50 - directly
290:51 - so in here we'll say state
290:54 - clone and then remember our state now
290:58 - looks like this so we can grab the
291:00 - history and then current round games
291:03 - array is where we want to Target this
291:06 - so State clone dot history dot current
291:09 - round games
291:12 - and we're going to push the final game
291:15 - here so I believe that would just look
291:18 - like
291:19 - um let's see
291:23 - we probably just want to push the moves
291:26 - in the status
291:27 - we don't want to just push the moves
291:29 - because we want a easy way to Loop
291:32 - through all the history of games and see
291:35 - the status on those which is that
291:38 - derived state right here so we want to
291:40 - kind of archive that as well now after
291:43 - we get past this block this is where
291:46 - we're going to look at the state clone
291:48 - and set the current game moves equal to
291:52 - an empty array because we want to reset
291:55 - that and then instead of saving it to
291:57 - the initial value we're going to State
291:59 - save it to the state clone that we've
292:02 - just mutated here in these two places so
292:06 - at this point if we've done everything
292:07 - correctly here we should be able to add
292:10 - a new getter so we've got the current
292:14 - game and then let's also make a stat
292:18 - skidder so this will be responsible for
292:20 - getting us the total number of wins by
292:23 - player
292:24 - and to start us off let's just console
292:27 - log this Dot
292:30 - um
292:31 - get state
292:34 - so we'll go back to our game let's play
292:37 - at least one round
292:40 - and reset and so right there that should
292:43 - have pushed
292:45 - um a few or it should have pushed a game
292:47 - to history and since we're not actually
292:49 - calling this anywhere it's not showing
292:51 - up
292:52 - um so we need to call that somewhere
292:56 - we'll just call it at the end of the
292:58 - game reset so console log store dot
293:01 - stats
293:03 - we'll remove that in just a second but
293:05 - let's play one more game so I think
293:07 - player one should have two wins at this
293:09 - point when we reset so you can see in
293:12 - history we have current round games is
293:15 - an array
293:16 - of one and it shows all the moves from
293:19 - that game and then the status
293:22 - showing that the winner was player one
293:25 - and if we play this again I'm hoping
293:28 - things will update correctly
293:32 - yep so now in history we have two games
293:35 - in history so if we keep playing these
293:37 - that's basically what's going to happen
293:39 - so at this point player one has won
293:41 - three games and you can retrieve all of
293:44 - those in history right here
293:46 - so now our job is to go back to the
293:50 - stats method on our store class and
293:53 - actually derive some useful state that
293:56 - we can use to update those that
293:59 - scoreboard down here at the bottom so
294:02 - what I want to return from this it
294:04 - should be pretty simple so player with
294:07 - stats
294:09 - um what I'm going to do here is map
294:13 - through the players array which remember
294:15 - we initialized the Constructor with
294:18 - players and then assigned that as a
294:20 - property of the class
294:22 - so we have that and we can map through
294:24 - and look at each player
294:26 - and then all we're going to do is add
294:29 - whether they have a win
294:31 - or add how many wins they have so we'll
294:34 - calculate wins by looking at the current
294:38 - state so this Dot Game or I'm sorry not
294:41 - this dot game but we will look at the
294:44 - history so we need to grab
294:48 - the current state which is this Dot
294:53 - oops
294:56 - get state
295:01 - so we'll say state DOT history we're
295:04 - looking in the history of the current
295:06 - round games
295:08 - and we're going to filter that
295:12 - and we're going to look at the game
295:17 - and check for the status
295:19 - of that and see if there's a winner and
295:22 - if there's a winner we'll use a
295:25 - an operator here that JavaScript has
295:28 - available to basically coalesce any
295:31 - undefined values uh when we're accessing
295:34 - this property
295:35 - so we can pass ID and check if that's
295:38 - equal to the current player.id so we're
295:42 - checking the player we're mapping
295:44 - through against the game status of the
295:47 - current game we're mapping and at the
295:49 - end of that we should be able to get the
295:51 - length of that array so that will give
295:54 - us the number of wins that this player
295:56 - has we will then from this map
296:00 - function we will then spread the player
296:03 - object
296:04 - to this object and then we'll pass the
296:08 - number of wins so essentially this is
296:10 - giving us a list of players where it has
296:13 - this additional property called wins
296:15 - that will tell tell us later how many
296:18 - wins that player has
296:19 - furthermore we then have ties and that
296:23 - one's pretty easy we'll just look
296:24 - through the history again
296:27 - and this time we're going to filter it
296:29 - for games where the game.status dot
296:33 - winner is equal to null so that will
296:37 - tell us when we have a tie if there's no
296:40 - winner
296:41 - and we'll give it the length there as
296:44 - well so now when we read the stats
296:46 - object we should be getting a much
296:48 - different picture so let's go ahead and
296:51 - play another game
296:53 - and now we've got the stats object we've
296:57 - got player with stats and you can see
296:58 - that's an array of two players and if we
297:01 - open up those players we get all of
297:04 - their attributes of course and then we
297:06 - also get how many wins that they've had
297:08 - so far in history we get the ties is
297:12 - equal to zero and you can all already
297:14 - see that we can basically take this
297:16 - information and just update the HTML to
297:20 - show that in these three boxes down here
297:22 - so populating these will be relatively
297:25 - quick I think
297:27 - we just need to go to view
297:29 - and make one more helper method I'll
297:32 - just keep putting it here at the top
297:34 - let's go ahead and say update scoreboard
297:40 - is the method that we're going to use
297:43 - and I think we might need to put a data
297:45 - ID on some of these
297:48 - yep so I'm going to put a data ID
297:52 - and we're going to call this one uh
297:55 - player one
297:57 - scoreboard
298:01 - or let's let's actually just make it
298:04 - shorter P1 wins
298:07 - so we'll copy that one down
298:11 - to player two so P2 wins and then we
298:15 - already have a data ID because I guess I
298:17 - forgot to pull that out during our HTML
298:21 - build so that's already there for ties
298:25 - so if we go to our view
298:26 - we just need to select these elements
298:30 - um
298:31 - we could just do it in this method we
298:33 - really could do all this in that method
298:35 - I just like to consolidate stuff up here
298:38 - so we're going to select the player one
298:40 - wins and this is going to be selected
298:51 - P1 wins let's make sure that's right
298:56 - okay
298:58 - then let's copy that down
299:01 - player two wins
299:03 - and then ties
299:09 - and then now we have these three
299:11 - elements to work with
299:13 - so we can update the scoreboard by
299:15 - saying this dot dollar sign that player
299:17 - one wins
299:19 - and we'll set the inner text
299:22 - equal to
299:24 - and then we'll get the number there and
299:27 - we'll say that number of wins
299:29 - so that'll be this dot game I'm sorry
299:31 - this dot stats
299:37 - nope never mind we are in the view I was
299:40 - gotta gotta be careful where you're
299:42 - putting stuff we don't have access to
299:44 - that information yet so we're just going
299:47 - to pass that information directly to the
299:50 - method so player one wins player two
299:53 - wins and ties
299:56 - so we'll just pass that in and then
299:58 - we'll take care of actually getting
300:00 - these values into this method later
300:04 - okay so that method should update the
300:07 - scoreboard
300:08 - we just need to call it
300:10 - from somewhere
300:12 - so just checking looks good so we just
300:16 - need to call that from somewhere and I
300:18 - think the best place to do that at the
300:20 - moment is to do it in the game reset
300:24 - event because that's the only place that
300:26 - we are actually
300:28 - cataloging the end of the game
300:31 - so after we have set the turn indicator
300:34 - we're going to call from The View
300:36 - to update the scoreboard and at this
300:40 - point we're going to pass in store dot
300:44 - stats Dot
300:46 - player with stats
300:48 - we're going to select the first player
300:50 - and pass the number of wins
300:54 - we'll do the same thing
300:56 - for player two
301:00 - and then finally
301:02 - with the ties
301:04 - we can get rid of this console log
301:07 - and hopefully if that worked correctly
301:09 - this will update things and our game
301:13 - will be sort of done
301:16 - we've gotten error it says it cannot
301:18 - find elements and that's because we did
301:20 - not save the index.html
301:23 - so now it's finding it
301:27 - and you can see player one has one win
301:30 - player two to win one
301:33 - there's a win and then if we can somehow
301:37 - get a tie going here
301:40 - um
301:41 - I guess that one's not gonna work
301:49 - ah I can't get a tie going so we got
301:52 - player two with three wins player one
301:54 - with one win so that is the current
301:56 - history now the very last thing that we
301:59 - need to do
302:01 - um when we reset right here it's not
302:04 - going to clear any of this the only
302:06 - thing that's going to clear this
302:07 - scoreboard is the new round so we need
302:10 - to implement that method
302:12 - and let's go ahead and do that in the
302:15 - store first because
302:16 - that's pretty close to the reset
302:21 - so we'll say new round
302:22 - and what we want to do with the new
302:24 - round is basically take all of the games
302:26 - that are in the current round games and
302:29 - push them to this all games array and
302:33 - we're basically going to clear out this
302:35 - one and clear this one so one way that
302:38 - we can do that
302:40 - since we know that a new round is going
302:43 - to also be a reset
302:45 - what we can first do is call this dot
302:47 - reset so that will take any completed
302:50 - games put them into the current round
302:51 - games in clear everything out
302:55 - and after we've reset we need a state
302:59 - clone because we can't update State
303:02 - directly just to best practice as we
303:04 - talked about
303:05 - and what we're going to do is take the
303:08 - state clone
303:09 - grab the history
303:11 - and we're going to populate the all
303:13 - games
303:14 - um
303:15 - with the most recent current round games
303:20 - so one quick way that we can do this
303:22 - because this is going to be an array is
303:24 - we can spread that out to the push
303:27 - method so State clone dot history dot
303:30 - current round games so that will just
303:34 - push that to all games and then at last
303:36 - we will take
303:38 - that current round games and set that to
303:42 - an empty array
303:43 - and then finally we will save the state
303:46 - pass in that state clone that we have
303:48 - modified
303:50 - now there's one thing that's going to be
303:51 - messed up
303:52 - and it's probably not super apparent so
303:55 - if we go through and play some games
304:03 - and then we go and reset everything
304:07 - let me see
304:08 - and at this point we really just need to
304:10 - hook this up
304:12 - to the view so we have bound the new
304:15 - round event
304:17 - and in app.js we just have a placeholder
304:20 - here
304:21 - so what we need to do is basically call
304:24 - the store
304:26 - call for a new round and then I think
304:29 - we'll want to clear everything so
304:32 - similar to the the reset we'll want to
304:34 - close everything
304:36 - we will want to clear the moves so this
304:39 - is the UI not the store
304:43 - we'll want to set the turn indicator
304:49 - and then we'll want to update the
304:51 - scoreboard
304:55 - so this call actually needs to go first
304:58 - so that the state is updated and then
305:00 - all of these will read from that state
305:02 - to appropriately populate the um the UI
305:07 - so let's go try this
305:11 - we've got so far
305:13 - um let's populate some state
305:17 - so player one has two wins if we click
305:20 - something and reset it'll just clear the
305:22 - board but keep this if we go and hit new
305:25 - round you can see that it clears
305:27 - everything and now the scoreboard is
305:30 - also cleared
305:31 - so at this point we have a fully
305:34 - functioning game and everything works
305:37 - everything's being updated
305:39 - the last thing that we're going to look
305:41 - at here is persisting State across
305:44 - refreshes as you can see if we play a
305:47 - game
305:48 - and you get player one having one win
305:51 - and then you refresh the page this is
305:53 - all cleared out and ideally we would
305:56 - want to be able to refresh the page and
305:58 - still keep a record of the games in
306:01 - history and the only way that we can
306:03 - really do that is by using local storage
306:06 - now to make our game more persistent
306:08 - across browser refreshes and
306:10 - additionally to allow two users to
306:13 - basically play at the same time in
306:15 - different browser tabs we can use local
306:18 - storage so if we go to the documentation
306:22 - for local storage
306:27 - you can see that it is a property of the
306:30 - window interface allows you to access a
306:33 - storage object for the document's origin
306:35 - so it's similar to session storage
306:38 - except that while local storage data has
306:40 - no expiration session storage data gets
306:44 - cleared when the page session ends that
306:46 - is when the page is closed local storage
306:49 - does not do that so you can actually
306:52 - close the page entirely and reopen it it
306:55 - will still be there so it's just a
306:57 - little bit more persistent and it's also
307:00 - available across browser tabs so if we
307:04 - go to the event reference let me see if
307:06 - I can find that
307:08 - let's click on storage Maybe
307:10 - and then look at storage event alright
307:13 - so this is what we're looking for in
307:15 - Wool eventually implement this but the
307:18 - storage event is implemented by or the
307:21 - storage event interface is implemented
307:22 - by the storage event which is
307:25 - sent to a window when a storage area the
307:27 - window has access to is changed within
307:30 - the context of another document
307:33 - that is a long way of saying that
307:35 - basically you can add an event listener
307:38 - on the window for this storage event and
307:41 - if you have one tab sitting open
307:44 - with our tic-tac-toe game and a player
307:46 - is clicking in it then that's going to
307:49 - trigger this event and you can have
307:51 - another tab listening for this event and
307:54 - it will recognize when that player has
307:56 - played in a different tab so that will
307:58 - allow us to sync the two tabs together
308:01 - and allow us to basically have two
308:03 - players in simulate a more realistic
308:06 - game so we're going to implement local
308:09 - storage but as we know with local
308:11 - storage you need a key so we will
308:14 - Implement that but first let's get rid
308:16 - of our previous app we can finally hit
308:19 - the delete button on that because
308:20 - everything's working in our refactor
308:23 - everything's a lot cleaner
308:26 - and now it's time to go over to the
308:28 - store
308:30 - and in the Constructor to this store
308:32 - rather than just passing players we're
308:35 - going to also pass a key
308:37 - and this key is going to represent the
308:40 - key of local storage that we're going to
308:43 - actually keep the data so if we go to
308:46 - storage and we go to the local storage
308:50 - right there you'll see I've already
308:53 - populated this because it's happening in
308:56 - the the finished game over here
308:58 - but the key is what's going to be
309:00 - referenced to get it and save it and
309:04 - then here's all the game state that
309:06 - we're tracking so let's go ahead and go
309:10 - back to our app and we will give this a
309:12 - special key so in app.js where we
309:15 - initialize
309:17 - the store right here we'll say live
309:22 - um
309:23 - tic-tac-toe so T3
309:25 - storage key it could literally be
309:28 - anything
309:29 - so we're passing that key and now what
309:32 - we need to do is save that so we'll say
309:35 - this dot storage key is equal to key
309:40 - and then this dot players is equal to
309:42 - players so that should be working and
309:45 - then the last thing that we need to
309:46 - actually do is go down to our get get
309:51 - State and save State and now instead of
309:54 - saving this in memory on a property of
309:57 - the class instance we're going to
309:59 - replace this with local storage
310:01 - so that's why as I was talking about
310:04 - earlier this seemed a little redundant
310:06 - why would we access this through another
310:09 - method well it's so that we can refactor
310:12 - it to this a lot easier so we'll get rid
310:14 - of that instance property and in the get
310:17 - State this is where we're going to
310:19 - retrieve from local storage but as we
310:22 - know uh if the local storage is empty
310:25 - it's going to give us undefined so
310:27 - remember at the top we have this initial
310:29 - value and that's go that's what will
310:32 - return if there's nothing found within
310:35 - local storage for that key
310:37 - so what we'll do is we'll first try to
310:40 - grab an item and we'll say window dot
310:44 - local storage
310:46 - dot get item that's a built-in method
310:48 - and then we will pass the storage key
310:51 - that we initialized in the Constructor
310:54 - of this class
310:56 - so this is going to return us either
310:58 - undefined or the string representation
311:01 - of this value so basically what we're
311:05 - going to return here is we're going to
311:06 - say if we have found an item that is
311:10 - defined we're going to parse it
311:13 - because it's a string
311:15 - otherwise we're going to return the
311:17 - initial value as a JavaScript object so
311:21 - in other words we're going to return the
311:23 - same type we're just falling back to
311:26 - this value so that's the get State
311:29 - implementation
311:31 - and then for the Save State we'll
311:33 - replace this call down here and we will
311:36 - say
311:37 - window.localstorage that's set item
311:40 - and this is going to
311:43 - um
311:44 - be the storage key
311:48 - and then we need to actually do the
311:50 - opposite of
311:52 - json.parse and we need to stringify our
311:56 - object so you can see here this is where
312:00 - we're storing the new state after we've
312:02 - saved it so we can just pass that raw
312:05 - object right here
312:07 - and that should persist things to local
312:09 - storage just fine
312:12 - let's go back to our game and see if
312:14 - things are working better
312:16 - so we'll play the game
312:19 - player one wins
312:21 - you can see it's tracked down here in
312:24 - the scoreboard let's get player 2 to win
312:26 - a game
312:28 - that's tracked down here and now for the
312:31 - the big tell all let's refresh the
312:33 - browser
312:35 - when we refresh the browser it looks
312:38 - like there's zero wins but in reality
312:41 - we're actually tracking this state we
312:43 - just have one big problem here and that
312:46 - problem is that on the initialization of
312:49 - the page
312:50 - so let's go to our app at the bottom
312:54 - when we were waiting for the load event
312:57 - we are not actually updating the Dom
313:01 - with the latest state so you can see in
313:04 - the reset we the reset and the new round
313:07 - we're calling all of these changes to
313:10 - the view well we really need to call
313:12 - this on the first load of the page as
313:15 - well and as you can see we're repeating
313:18 - things quite a lot so it would be best
313:21 - to put this in a little helper method
313:23 - so we'll say init View
313:27 - we can put that right there
313:29 - and basically when we init The View
313:31 - let's make sure everything's closed
313:34 - let's clear all the moves
313:37 - let's set the turn indicator to whatever
313:41 - the current player is in state and that
313:44 - state value is now coming from local
313:46 - storage so we have
313:48 - we have some
313:50 - things that we need to update in
313:52 - addition to this in a second
313:54 - so last we'll update the scoreboard to
313:57 - be the current stats
313:59 - and now we can basically call this down
314:01 - here in the reset
314:03 - so we can get rid of all this
314:06 - and a knit View
314:09 - after we've reset the store
314:18 - so that's just a little helper method
314:20 - for us let's check to make sure we
314:22 - didn't break anything
314:24 - so we'll play in the game someone wins
314:27 - and we reset so it looks like everything
314:29 - worked now we've got two wins for player
314:32 - one one win for player two and if we
314:35 - refresh the page still nothing is going
314:37 - to happen but if we go down to
314:40 - [Music]
314:41 - um
314:42 - basically if we call this a knit View
314:46 - from the scope of the init method then
314:50 - that's going to populate things because
314:52 - we're doing that on page load so now the
314:55 - next time we refresh we're gonna stick
314:57 - with those two wins and one wins we can
315:00 - refresh it as many times as we want it's
315:02 - O is going to end up in the same thing
315:04 - but we have one last problem to to
315:07 - Really solve here and that is what
315:09 - happens if there's like three moves on
315:12 - the game board when we refresh the page
315:14 - it's going to clear that but you can see
315:17 - in state player 2 is up not player one
315:19 - so we need a way to actually reconstruct
315:22 - the moves that have been made on the
315:25 - game board on the initialization of the
315:27 - page so if you remember from our view we
315:31 - had some helper methods and one of those
315:34 - helper methods was handle a Player move
315:38 - and what that does is creates an icon
315:40 - and it replaces the square that that
315:44 - belongs in and all you have to do is
315:46 - pass it the square element that you want
315:49 - to replace
315:51 - so one thing that we could do is we
315:55 - could Loop through all the squares and
315:57 - basically update it in state so we
316:00 - really need to implement this method
316:02 - so initialize
316:05 - moves
316:09 - and what we're going to be doing is
316:10 - calling this
316:12 - dot squares
316:15 - so let's take a look at a previous
316:18 - implementation
316:20 - so we're clearing the moves here so
316:22 - let's let's move this
316:24 - up closer to that because it kind of
316:27 - relates
316:28 - so when we're clearing the moves we're
316:30 - just replacing children like that but
316:33 - when we're adding the moves
316:36 - we need to go through each Square
316:38 - and we basically need to check if
316:40 - there's an existing move in state so
316:43 - this needs to pass a moves array of the
316:46 - current game moves and then what we'll
316:49 - do is we'll check moves dot find
316:53 - and we'll look on that move for a square
316:56 - ID
316:57 - that is equal to the square dot ID
317:02 - which is what We're looping through
317:03 - right here
317:05 - and if there is an existing move
317:08 - we're going to call this dot handle
317:10 - Player move and now we can pass in the
317:13 - square and then we can pass in the
317:16 - player that made the move which is going
317:18 - to be the existing move dot player
317:25 - so that should initialize the moves
317:27 - let's go back to our app and right after
317:29 - we init The View
317:32 - um we want to call view dot initialize
317:35 - moves and these seem pretty similar but
317:39 - um when we init the view in the reset we
317:42 - don't want to
317:43 - actually it should be okay because the
317:45 - state would be cleared so let's go ahead
317:48 - and put that as as the last
317:51 - method here
317:54 - so we'll reinitialize the moves and
317:56 - since we've cleared the moves right here
318:00 - um or I'm sorry not not because of that
318:02 - but in the reset event we're resetting
318:05 - the store or new round on the store so
318:08 - that should clear all the current moves
318:10 - and this will basically be an empty call
318:13 - because it's not going to find any
318:14 - existing elements
318:16 - so let's go ahead and save that
318:19 - and let's refresh the page
318:23 - looks like we've broken something
318:25 - moves is undefined
318:30 - oh because I haven't passed in the
318:33 - current state
318:34 - so we cannot just call this with an
318:37 - empty
318:38 - function call we need to pass in the
318:41 - store.game
318:42 - dot moves and now you can see that it's
318:46 - initialized so no matter how how many
318:48 - times we refresh it's always going to
318:50 - reconstruct the latest moves of the game
318:54 - let's reset that so it resets up here
318:57 - and now we refresh and it's empty let's
319:00 - put a play down here
319:02 - refresh keeps that there and you can see
319:05 - how we can just
319:07 - recreate the state every single time so
319:10 - let's set this to a new round which
319:12 - clears everything including the
319:14 - scoreboard and just play through one
319:16 - more time player one wins
319:20 - player 2 wins got one win on each side
319:23 - and then Place something there refresh
319:27 - reset
319:29 - refresh everything looks like it's
319:31 - working great now the real test as I
319:34 - talked about earlier is we should be
319:35 - able to play this in two separate tabs
319:38 - so let me copy this URL and paste it
319:42 - here so we are now looking at the same
319:45 - exact game running
319:47 - but if we update in this tab and put an
319:51 - X there and then go to this tab you will
319:53 - not see it update and that's going to
319:57 - cause all sorts of problems because when
319:58 - we click here
320:00 - it's really going to be out of sync with
320:03 - the other Tab and you don't really have
320:05 - a way to play this game
320:06 - we have a pretty quick way to fix this
320:09 - as I mentioned with this storage event
320:12 - we just need to go to the app.js and in
320:16 - our initialization we can just listen
320:19 - for that event
320:21 - so let's go ahead
320:24 - let's find a good spot for that
320:27 - so right here this is where we're
320:28 - listening for The View events we're
320:31 - knitting initializing The View here
320:32 - let's put this at the very top
320:35 - or actually let's put it right here next
320:37 - to a net View
320:38 - so we'll say window dot add event
320:40 - listener
320:42 - and we're listening for the storage
320:43 - event
320:44 - so this is when the other tab updates
320:47 - it's not when the current tab updates
320:49 - where the other tab updates we'll put a
320:51 - console log in here we'll say State
320:54 - changed from another tab
320:57 - let's just see what that looks like
320:59 - first
321:00 - okay so we
321:02 - click and go to the other Tab and you
321:05 - can see the state change from another
321:06 - tab we'll click here and then see that
321:10 - state change from another tab over here
321:12 - so basically every time the opposite tab
321:15 - changes you'll get this event fired
321:18 - we'll leave that there and what we
321:21 - basically need to do is when that
321:23 - happens we need to initialize the view
321:26 - again
321:27 - so we're initializing The View on the
321:29 - first page load and we're initializing
321:31 - The View when the storage changes
321:34 - let's go back refresh the page and like
321:37 - reset everything
321:39 - so we'll make a move let's first look at
321:42 - this board this is empty this tab is
321:44 - empty and if we make a move in the top
321:47 - left corner what I would expect now is
321:50 - that we'll get a console log on this tab
321:52 - and we'll also see this x recreated
321:56 - and you can see when I clicked there we
321:58 - got it let's put an o in the bottom
322:00 - right
322:01 - and you'll see when I clicked over to
322:03 - this tab it showed up here and we got
322:05 - that console log so that's just a cool
322:07 - little trick so that you can play in
322:10 - multiple tabs now the last thing that I
322:12 - want to do before we
322:15 - go into the optional typescript refactor
322:18 - that's totally optional this has been
322:22 - obviously a long enough video at this
322:24 - point but hopefully you've learned a lot
322:26 - and maybe give a subscribe to the
322:28 - channel or something
322:30 - um but if you're still here we're going
322:32 - to now kind of connect some dots
322:35 - if you have not used react you've
322:38 - probably heard of it and react is what
322:42 - they call a reactive UI framework
322:44 - although that is only partially true if
322:48 - you really look under the hood
322:49 - but the idea the overarching idea is
322:53 - that in react you program declaratively
322:56 - I have a blog post on my website so
323:00 - let's go to my website
323:03 - and go search for some Concepts
323:07 - and I've written about imperative versus
323:09 - declarative programming and if you come
323:12 - down to the middle of this you'll see a
323:14 - section called react declarative versus
323:17 - jQuery imperative
323:19 - so far what we have done is been
323:23 - programming imperatively in other words
323:26 - what that means you can go ahead and
323:27 - read over these examples but I'm about
323:30 - to explain it here in this video
323:32 - when we program imperatively that means
323:35 - that we are saying okay here's the
323:37 - outcome that I want and here are the
323:39 - seven different steps that you have to
323:41 - take to get to that outcome now
323:44 - declarative programming
323:46 - is basically saying here's the outcome I
323:49 - want go figure out how to make that
323:51 - happen and I think I have an example in
323:54 - this blog post about building a house
323:57 - imperatively versus declaratively so if
324:00 - you're doing this imperatively you're
324:01 - going to specify the steps you build the
324:04 - foundation you put in the framework
324:06 - install the utilities add the walls
324:08 - finishing touches so on and so forth
324:11 - if you're building a house declaratively
324:13 - the only step is basically saying I
324:16 - don't care how you build it but I want a
324:17 - nice fireplace a Lakefront View and a
324:20 - big kitchen so these are the outcomes
324:22 - that you are declaring that you want and
324:25 - you let the Builder of that house
324:27 - determine the best way to make that
324:30 - happen
324:30 - so the same thing happens with the react
324:34 - Library some people would call it a
324:36 - framework even
324:37 - react is basically looking at the state
324:41 - of your application and based on that
324:43 - state and based on The View that you
324:46 - have defined that links that state it's
324:49 - going to figure out how to render the
324:52 - page to the screen
324:54 - and if we look back at our program
324:58 - we have a lot of imperative stuff going
325:00 - on
325:01 - so we are binding to all of these
325:03 - different clicks so when when these
325:06 - buttons are clicked we have a lot of
325:08 - very explicit steps written out of how
325:12 - we want the UI and this state to
325:15 - actually update now we can do a rather
325:19 - small it's not going to be huge refactor
325:22 - where we can basically take all of these
325:25 - individual steps and we can wrap them in
325:28 - a render method from there then the idea
325:30 - is that the render method is all that
325:33 - you need to call on The View and then
325:36 - you need to pass the state of the
325:39 - application so remember the store
325:41 - gives us that state of the game
325:46 - um the game right here and then the
325:48 - stats so that's basically our state and
325:51 - all we need to do is pass all of that
325:53 - information to the Views render method
325:56 - and then we can basically Define all
325:59 - those steps to figure out how to show
326:02 - the page to the user
326:04 - so let's try to do that I think this
326:07 - will be
326:08 - um a really nice way to clean this thing
326:10 - up for once and for all and will kind of
326:13 - get us to our final state of this
326:15 - application finally believe it or not
326:17 - this init view method actually
326:19 - represents a lot of what we're trying to
326:22 - do
326:22 - so we will be copying a lot of this
326:24 - stuff so let's make this a little
326:26 - smaller open up the view over here to
326:29 - the right
326:30 - actually we'll make it a little bigger
326:31 - that's kind of tough to see so now that
326:34 - I've you know talked about all this
326:37 - stuff in the render method basically
326:39 - what we can do at this point is we can
326:42 - put a hashtag in front of pretty much
326:46 - all of these methods because they're all
326:48 - going to be called from within the
326:50 - render method
326:53 - so these are all internal implementation
326:56 - details of our view class and nobody
326:59 - needs to know about them except for the
327:02 - view itself
327:07 - so you can think of all of these methods
327:09 - as basically just Dom helpers that we're
327:12 - going to call from the main render
327:15 - method so these event listeners are
327:18 - going to be public methods that can be
327:21 - called from the app or the controller
327:23 - and then we will have one render method
327:27 - here at the top
327:29 - so we're going to call that render
327:31 - nothing significant about this name
327:33 - necessarily other than convention this
327:37 - is generally what you would call it in
327:39 - when react was using class-based
327:42 - components that was the method that you
327:45 - had to put all of your jsx into and
327:47 - whatnot so this is more of a convention
327:49 - naming convention than anything
327:52 - so what we're going to pass into this is
327:54 - the store itself
327:56 - in that store as we know has those
327:59 - getter methods on it
328:01 - but I'm going to be more explicit
328:04 - actually I want to pass the game and the
328:08 - stats you could pass the entire store
328:11 - object and I think maybe in the final
328:12 - implementation that's what I've done but
328:15 - we'll be explicit with this so that we
328:18 - know exactly what we're dealing with so
328:20 - in other words the game and the stats
328:23 - are represented by this method stats in
328:27 - this method the game and based on this
328:29 - information we should be able to build
328:31 - our UI entirely so let's start building
328:35 - this up the first thing that we know
328:37 - needs to happen no matter what no matter
328:40 - what the state of this application we
328:43 - know that we want to populate this
328:45 - scoreboard based on the current state of
328:47 - the game
328:48 - so that'll be the first thing we'll do
328:50 - we'll call this dot update scoreboard
328:53 - and we have to pass in player one wins
328:57 - player two wins and number of ties and
329:00 - as we know we have all of that state
329:02 - available to the render method so we'll
329:05 - come back to app.js and you can see this
329:08 - is where we're extracting that stuff
329:10 - but we can actually do some
329:11 - destructuring to make this a little
329:13 - easier to deal with
329:15 - so from the stats
329:18 - we can grab the
329:21 - player with stats
329:26 - and the ties and then from the game what
329:30 - can we grab we can grab
329:36 - let's take a look
329:43 - we can grab moves the current player
329:46 - and the status which we can also
329:49 - destructure that is complete
329:52 - and the winner property so that's from
329:54 - the game
329:55 - so all of these this is just
329:57 - destructuring with es6 to get these
330:01 - variable references so we don't have to
330:03 - Define all of them or have this you know
330:06 - nested
330:07 - object property access going on
330:11 - so with the update scoreboard let's go
330:14 - back to our app and see how we did that
330:17 - we basically basically just looked at
330:20 - the stats
330:22 - dot player with stats so this will be
330:24 - the first player
330:26 - and we're finding the first player's
330:28 - number of wins
330:30 - player with stats one so that would be
330:32 - the second player their wins and then
330:34 - the ties will pass straight into that
330:38 - so right there we are rendering
330:40 - rendering the scoreboard and we can go
330:43 - ahead and start pulling all of this
330:46 - initialize functionality out of this
330:48 - method
330:50 - so we can remove this
330:55 - or actually we're going to replace a
330:56 - knit View
330:58 - with view.render
331:01 - and this is where we're going to pass
331:03 - the store dot game in store.stats
331:10 - we will also pass this right here to
331:13 - that storage event listener
331:16 - and now we can
331:20 - also pass it down here
331:23 - in these event listeners
331:35 - so let's save that
331:38 - and let's go back to our app
331:41 - and refresh the page and you can see
331:43 - that at least the scoreboard has been
331:45 - updated because we implemented that one
331:49 - method within render so the next thing
331:52 - that we need to do
331:54 - um let's see is probably reconstruct the
331:57 - game board
331:59 - we can really just follow this init view
332:01 - so
332:02 - we're updating the scoreboard we need to
332:05 - close everything and clear the moves so
332:08 - let's let's actually put that right
332:10 - above this
332:11 - so this
332:13 - Dot close all
332:16 - this dot clear
332:20 - all the moves we're going to update the
332:23 - scoreboard
332:27 - then we're going to initialize the moves
332:30 - so that's going to cover a lot of ground
332:32 - just there
332:35 - we need to set the turn indicator I
332:37 - missed that one
332:39 - so that one will come right here
332:43 - and that one takes a player so we need
332:46 - to pass in the current player that we're
332:48 - grabbing from the state
332:50 - so that will grab the current player and
332:52 - set that
332:53 - so now if we refresh and go back
332:56 - we should see a good amount of stuff
332:58 - being updated
333:00 - I don't think we'll be able to play
333:02 - quite yet and we've got a moves is
333:05 - undefined and once again I've forgotten
333:08 - to pass the correct data to this
333:11 - so we need to pass the moves
333:14 - from here down to the initialize method
333:18 - let's make sure we're not missing
333:19 - anything here
333:21 - okay we'll save that
333:23 - and right now we can't click anything
333:25 - because we have removed all of the
333:27 - functionality from the main app but we
333:31 - can get rid of this
333:33 - we'll keep this event listener because
333:35 - that's going to listen for changes on a
333:37 - different tab
333:38 - this is our initialization where on the
333:42 - first page load it's going to render The
333:43 - View
333:44 - then on each of our
333:47 - reset and new round events we're going
333:50 - to update the store and then render the
333:53 - new view
333:55 - our last thing to handle is that click
333:58 - event that happens on each Square so I
334:01 - think this logic can stay because this
334:03 - is just a check
334:05 - against the state and it's going to
334:08 - return early if it finds there's an
334:10 - existing move on the Square so that's
334:12 - not view related at all
334:14 - but right here we are handling the
334:17 - player move
334:18 - which
334:20 - um
334:21 - this should be covered every time we
334:24 - call render
334:25 - because all we have to do now is update
334:27 - the state and then the render method
334:31 - will then figure out how to recreate the
334:33 - moves that the next state represents
334:36 - so we can actually comment this out we
334:39 - can also comment out the player move
334:42 - I believe or I'm sorry we should not do
334:45 - that this is where we are updating State
334:48 - this is very important we need to update
334:51 - state with that Player move so that the
334:54 - render method gets the latest version of
334:56 - the state to actually recreate the game
334:59 - with
335:00 - so we can remove this view.handle Player
335:04 - move
335:04 - this is fine
335:06 - then we check if the game is complete
335:08 - and if it is we'll open the modal but we
335:11 - can actually do this check within the
335:13 - render method
335:14 - so let's see where's the best place to
335:17 - do that though so we've we're closing
335:19 - everything clear and move send the turn
335:22 - indicator
335:23 - update the scoreboard so we can really
335:25 - just do this at the end so we're really
335:28 - just checking to see if the status
335:32 - Let's see we can just grab that Inc is
335:35 - complete
335:36 - variable that we've destructured so if
335:39 - everything is complete the game's
335:41 - complete we will call this
335:43 - dot open modal
335:46 - and then from there we will grab the
335:48 - winner and check if there's a winner and
335:51 - if there is we will pass in this string
335:55 - otherwise we will pass in a tie
335:58 - so this check right here basically takes
336:01 - care of all of this
336:03 - right here and then at the end we're
336:06 - setting the turn indicator so maybe we
336:09 - should bring this one down to the very
336:11 - end of this render method because we
336:14 - don't want to set the turn indicator
336:15 - until
336:17 - um we know that the game is
336:20 - not complete so we're going to return
336:22 - early if we see that the game is
336:24 - complete okay so I think we can remove
336:27 - all of this
336:30 - from our method so at this point the
336:32 - player move event is really just
336:35 - checking State and updating it so we're
336:37 - checking for an existing move if we find
336:39 - it we're not going to do anything with
336:42 - the UI we're not going to re-render it
336:44 - if that doesn't if there is not an
336:48 - existing move that means it's a valid
336:49 - play
336:50 - and we're going to update state by
336:53 - making a Player move and then once we
336:56 - have updated State we can render The
336:58 - View with the new state
337:01 - that we have retrieved
337:05 - let's go back to our game
337:08 - it says this dot handle Player move is
337:10 - not a function so let's figure out where
337:12 - we're trying to call that
337:17 - I believe that's happening in the
337:19 - initialize moves
337:23 - yep so right here we just need since we
337:25 - made this a private method we just need
337:27 - to add that hashtag so that it can
337:30 - handle the player move just like this
337:34 - let's go back see if we got any errors
337:36 - and it looks like things are being
337:38 - populated so let's try to play
337:42 - again
337:46 - all right so when it detected a win it
337:49 - says the store is not defined
337:51 - so we're referencing something here in
337:54 - incorrectly
337:56 - oh okay so over here
337:59 - in the render method you can see I'm
338:02 - grabbing the winner name from the store
338:05 - except that's not available to us we
338:08 - really just need to grab this value
338:10 - right here so we can get rid of all this
338:13 - and just grab winner.name
338:16 - and so now we don't have any invalid
338:18 - references
338:19 - and it looks like player one wins so we
338:22 - can play again and it clears things
338:25 - to play through the game once more
338:27 - and you can see player one is racking up
338:29 - the wins here we can reset to a new
338:32 - round
338:33 - that works
338:35 - we can reset the game board that seems
338:38 - to work
338:39 - and I think we should see everything
338:42 - populating across these two tabs which
338:45 - appears to be the case so that is also
338:48 - working
338:48 - I know it's been a complete Marathon
338:51 - here
338:52 - um but we just have two more things to
338:55 - improve on this application and I think
338:57 - they're just really cool additions to
339:00 - this app
339:01 - um the first one is somewhat easy to
339:05 - grasp the second one is maybe not so
339:08 - easy so you can feel free to kind of
339:11 - skip over
339:12 - either of these but I wanted to add them
339:14 - in as a supplement to this video
339:17 - as you can see in our app.js
339:20 - we are calling view.render
339:23 - in a lot of different places
339:26 - so you can see we're calling this like
339:28 - what five six times five times
339:32 - there's probably an easier way to do
339:34 - this and one thing that we can do is go
339:38 - back to our store class
339:40 - and make one little update to this and
339:44 - it will make our lives a lot easier and
339:46 - automate a lot
339:48 - so right now this is just a plain es6
339:52 - class
339:52 - but if we put the keyword extends we can
339:56 - extend an event Target
339:59 - so if we go and look on mdn
340:04 - for event Target
340:06 - you can look and see that this is an
340:08 - interface that's implemented by objects
340:11 - that can receive events and may have
340:13 - listeners for them in other words any
340:15 - Target of events implements the three
340:18 - methods associated with this interface
340:20 - and if you look at the instance methods
340:22 - we have add event listener remove event
340:25 - listener and dispatch event
340:28 - this is basically what we've been doing
340:30 - with all of our elements and by default
340:33 - all of these Dom elements are going to
340:38 - inherit
340:39 - this class from this class so
340:42 - we can also create a store that extends
340:45 - this in that way we can send a custom
340:48 - event every time that store changes
340:51 - so
340:53 - the first thing we need to do
340:55 - is
340:56 - and I'm sorry I think I extended The
340:58 - View which is I'm getting tired here
341:02 - let's remove this from The View and
341:05 - instead we're putting this on store
341:07 - so this becomes an event Target and then
341:10 - at the top of the Constructor we just
341:12 - need to call Super and super is the
341:14 - keyword that will basically allow us to
341:17 - inherit from this event Target so this
341:20 - is kind of some object-oriented
341:21 - programming Concepts but in other words
341:24 - once we add super we should be able to
341:26 - get access to those three methods so
341:29 - let's comment out super and go to app.js
341:33 - and go to store
341:36 - um let's see
341:37 - it says that we can add event add an
341:40 - event listener but I think that's
341:41 - probably just
341:44 - confused let's reload
341:46 - oh I'm sorry that's because we we called
341:50 - super there but we need to remove this
341:53 - so if we remove this for one second and
341:56 - then go to store you're going to see
341:58 - that we these are the available
341:59 - properties in methods and you don't see
342:02 - ad event listener anywhere because vs
342:05 - code has not detected that as part of
342:07 - the interface
342:08 - but the second we add this back and
342:11 - extend the event Target
342:13 - and then call Super
342:15 - we will now have access to an event
342:18 - listener and we want to listen to a
342:22 - specific event
342:24 - and this event we're going to Define as
342:27 - a state change
342:29 - so we'll say State change is the custom
342:32 - event we're going to be listening for
342:33 - and then in the Callback to that
342:37 - we're going to render The View
342:39 - so we'll render The View with the
342:41 - store.game and store.stats
342:44 - and that will allow us to basically
342:46 - remove the view.render from pretty much
342:49 - all of these
342:51 - so we can remove it from here because
342:53 - when we call store.reset that's going to
342:55 - trigger this event and it's going to
342:58 - call view.render
342:59 - we can remove it from here same thing
343:02 - we're updating the store so it's going
343:04 - to trigger this event
343:06 - and then finally down here we are
343:08 - updating the store so it will trigger
343:10 - that event
343:12 - as we stand right now it's not going to
343:14 - do anything because we haven't actually
343:16 - dispatched any sort of event but since
343:19 - we've Consolidated everything into the
343:22 - Save State method we know that this is
343:25 - the only place in the entire class where
343:27 - state is actually being updated
343:30 - so if we come down to the set item call
343:33 - for local storage all we have to do is
343:36 - call this which represents the store
343:38 - which extends an event emitter which has
343:42 - these properties available
343:44 - we can dispatch an event
343:46 - and what we can do is pass a new event
343:50 - so event right here is just
343:53 - let's go to the reference
343:59 - let me just type this in mdn event
344:03 - so the event interface represents an
344:05 - event which takes place in the Dom an
344:07 - event can be triggered by the user
344:09 - action clicking the mouse blah blah blah
344:11 - and you can basically customize this
344:13 - with whatever method you want so let's
344:16 - look at the Constructor
344:18 - the event Constructor creates a new
344:19 - event object and you can pass a type to
344:23 - it which is a string with the name of
344:25 - the event so that's what we're doing and
344:27 - we're calling it State change
344:29 - so when state has changed we're going to
344:32 - dispatch this new event
344:35 - and therefore our event listener for the
344:38 - state change key is going to be fired
344:41 - and we're going to render The View
344:44 - now of course we need to keep
344:46 - view.render in this event listener
344:48 - because that's not going to be fired
344:50 - here these are two very separate events
344:54 - this one is when the current tab State
344:58 - changes
345:00 - and this is when a different tab
345:05 - State changes
345:07 - and then finally this one
345:09 - is the first
345:13 - load of the document
345:15 - so let's save this and see if things are
345:18 - working correctly
345:20 - so we refresh it looks like we've got a
345:24 - problem
345:24 - [Music]
345:28 - I don't know what happened it looks like
345:30 - our live server timed out or something
345:33 - so let's refresh that page
345:35 - reset the game and you can see on all of
345:38 - these actions that we're clicking
345:40 - it's re-rendering the page so clicking
345:44 - all these actions player one wins we
345:46 - play again it resets we get a scoreboard
345:49 - update
345:52 - and let's keep playing player one wins
345:54 - again and now we can reset the game
345:59 - we can reset the round and then if we
346:02 - click here we can see that populated in
346:04 - the other tab actually we cannot
346:08 - says must call Super Constructor before
346:10 - using this in the derived class
346:12 - Constructor
346:14 - let's see what that's all about
346:17 - okay I think that might have just been
346:18 - old
346:20 - I just needed to refresh
346:24 - yeah okay that was just old that was
346:27 - from when live server cut out so now
346:30 - things are being kept in sync and we can
346:33 - play from multiple tabs
346:35 - so let's win the game from this tab
346:38 - player 2 wins and we should see over in
346:41 - this tab the same message
346:43 - when we reset
346:45 - this is reset as well so at this point
346:48 - everything is pretty much complete
346:52 - um there's just one helper method that
346:55 - we can refactor that will make things a
346:58 - little more performant and I'm going to
347:01 - just plug this in and you can kind of
347:03 - study it on your own time
347:05 - so let's go ahead and look at the view
347:09 - so I'm going back to the view here and
347:12 - at the very bottom
347:14 - I'm going to add something called
347:15 - delegate
347:17 - now this is a pattern that I did not
347:19 - come up with on my own this kind of a
347:21 - well-known pattern when you're working
347:23 - with the Dom and the purpose of this
347:27 - helper method is so that we don't have
347:29 - to do what we're doing up here and that
347:33 - is looping through each of the squares
347:39 - um not that not those specifically
347:43 - but right here where we're binding an
347:45 - event listener to every single Square
347:47 - element
347:48 - this results in a lot of event listeners
347:52 - and it's a little bit more performant
347:54 - and efficient to just register an event
347:58 - listener on the parent element and then
348:01 - we can kind of match match up which
348:05 - child element was clicked on that event
348:07 - and figure out which Square we're
348:09 - dealing with for this so if we look at
348:12 - the index.html you can see that we have
348:14 - this entire grid
348:16 - and then we have these squares so
348:20 - wouldn't it be nice if we could just
348:21 - register an event listener on this grid
348:24 - and then we can basically figure out
348:27 - which element was clicked within it
348:31 - um based on that you know helper method
348:33 - so we can go back to view and instead of
348:36 - doing this dot squares for each
348:39 - we can just call this dot delegate
348:43 - and the element that we pass is going to
348:45 - be this dot dollar sign dot grid
348:49 - let's see if we've selected that
348:52 - it looks like we have not
348:54 - so we'll say this dot dollar sign dot
348:56 - grid
348:59 - and we will select
349:03 - the data ID of grid let's make sure that
349:05 - we add that right here
349:12 - so now we're adding the event listener
349:14 - to this parent div
349:17 - the selector that we're looking for
349:20 - is going to be a class called Square or
349:24 - a data ID called Square so this will be
349:26 - a little bit more stable
349:28 - so we'll use that
349:32 - so we'll just grab an example here
349:38 - and then pass this as a square
349:42 - and then the event that we're listening
349:44 - to is a click event in the Handler is
349:48 - going to be
349:49 - handled by the controller
349:52 - so instead of looping through all of
349:54 - them adding an event listener to each
349:55 - we're just going to do it once with the
349:57 - delegate method
349:59 - and I believe this should work for us
350:02 - let's go back to app.js
350:05 - and just get a sense of what's being
350:07 - passed here
350:09 - so console log Square
350:13 - and when we click
350:14 - it's going to give us a div with an ID
350:18 - equal to the square that we have clicked
350:20 - so as we're clicking through this
350:22 - everything works just the same and that
350:25 - little refactor just made things a
350:27 - little bit more performant and we're
350:30 - using kind of a pattern that you'll see
350:33 - quite often is kind of the main reason I
350:35 - wanted to expose it here is you'll see
350:37 - this out in the wild and it's just good
350:40 - to know kind of what it's trying to
350:41 - achieve all right so there you have it
350:44 - we've got a tic-tac-toe game that is
350:46 - working and most importantly we learned
350:49 - a lot along the way so if you're looking
350:52 - for some next steps
350:54 - um to kind of continue Connecting the
350:56 - Dots here I'm going to be creating a
350:59 - couple more videos that kind of play
351:01 - along from this original build so put in
351:05 - the work to get this built and now I
351:07 - promised what we would do at the end of
351:09 - this video is refactor this with
351:12 - typescript which is a pretty popular
351:15 - superset of JavaScript that a lot of
351:18 - employers are looking for at the moment
351:21 - here in early 2023
351:24 - but I realized that this is kind of a
351:27 - diverging concept from what we've just
351:30 - worked on so I thought it deserved its
351:32 - own Standalone video so I will link in
351:35 - the description to that video and then
351:37 - after that we will actually do a
351:40 - refactor to react so how do we take this
351:43 - vanilla game and make it into a react
351:47 - app and then the last video there I'm
351:49 - hoping to do the same thing and take the
351:53 - vanilla react app and make it into
351:55 - typescript so I made a video where I
351:57 - refactored subscribers code and we
352:00 - worked on this tic-tac-toe game and we
352:03 - built this in vanilla JavaScript it took
352:06 - us quite a while because I went through
352:07 - a lot of uh different concepts and
352:10 - patterns to build this out but now it's
352:13 - time to refactor this to typescript and
352:17 - the question is why am I doing this what
352:20 - is the point of using typescript in the
352:23 - first place so this video is going to be
352:26 - a refactor where we take a vanilla
352:30 - JavaScript tic-tac-toe game and we
352:33 - refactor it to use typescript and along
352:36 - the way I'm going to explain and point
352:39 - out why typescript is so helpful and why
352:42 - so many employers look for this skill in
352:46 - developers let me start by saying that
352:49 - this video is specifically Geared for
352:51 - people who either have not used
352:54 - typescript and are trying to understand
352:56 - what the hype is about or are just a
352:59 - beginner developer you're looking to
353:01 - land a job and you're trying to
353:03 - understand what that path to getting
353:06 - that job looks like and I can assure you
353:09 - there are many companies out there using
353:11 - typescript today I write it in my
353:14 - day-to-day job and it's an awesome thing
353:17 - if you learn how to use it correctly so
353:20 - with that said we're going to just jump
353:22 - into this video I recommend that if you
353:26 - want the most out of this video you
353:27 - should probably watch the original build
353:30 - so like I said we built or we refactored
353:34 - some subscriber code and built this
353:36 - tic-tac-toe game and took several hours
353:39 - so I know it's it's a bit of a pain to
353:42 - go re-watch all of that but this is
353:44 - going to be a much clearer video if you
353:48 - have that background and you understand
353:50 - the steps that we took to get here at
353:53 - the very very least be sure to go to my
353:56 - GitHub repository I've linked to it in
354:00 - the video description
354:02 - um but let me just show you the one that
354:05 - I'm talking about here
354:07 - um so let's go nope that's not the right
354:10 - one
354:12 - so tic-tac-toe subscriber refactor at
354:15 - the very very least you need to go
354:17 - through and open up this vanilla
354:19 - refactor and then read through all of
354:22 - the code here okay and we have a second
354:26 - branch called typescript which this is
354:29 - the final version of the video that I'm
354:31 - doing right now so we're going to head
354:34 - towards this right here and we're going
354:37 - to start with the vanilla JavaScript
354:40 - so without further Ado let's jump in and
354:44 - get this refactored to typescript all
354:46 - right so the first thing I'm going to do
354:48 - is just copy this entire folder
354:53 - um so let's see
354:55 - paste
354:57 - all right and then we're going to call
354:59 - this a uh typescript
355:04 - actually let's say live
355:06 - TS refactor
355:09 - okay so here forget about this for one
355:13 - second we'll get to that that's very
355:16 - important for this refactor it was just
355:19 - in my git ignore so just to overview
355:21 - we've got an index.html file that's got
355:25 - some Styles and it has this script down
355:28 - here that connects to these the App
355:31 - Store and Views so the MVC pattern that
355:33 - we talked about in that prior video once
355:35 - again Linked In the video description
355:37 - and here's the CSS file nothing crazy
355:40 - going on here like I said you need to be
355:43 - familiar with this application because
355:45 - I'm not going to explain uh it in any
355:48 - detail here so the question is if you
355:51 - want to move towards a typescript code
355:53 - base and you've got a vanilla JS code
355:56 - base to start with how do you go about
355:59 - migrating it if you are dealing with a
356:02 - very large vanilla JavaScript code base
356:05 - this is not the video to teach you how
356:07 - to migrate that this video is basically
356:10 - going to walk you through the the most
356:12 - simple steps the initial setup of a
356:15 - typescript app
356:16 - so the first thing that we need to do
356:19 - and to understand is that when we're
356:22 - writing typescript we will now need
356:25 - developer dependencies so talking about
356:28 - like a package.json if you notice in our
356:32 - original build we don't have a package
356:35 - Json or node modules or anything like
356:37 - that because we don't need them we can
356:40 - just write uh vanilla JavaScript es6
356:44 - syntax and run that directly in the
356:48 - browser so there's no developer
356:50 - dependencies there's no build steps
356:53 - transpiling any of that stuff
356:56 - so the biggest thing you need to
356:58 - understand to start out is that we need
357:00 - some dependencies and the dependency we
357:03 - need is typescript
357:05 - um itself as well as the typescript
357:07 - compiler now I'll be honest I don't set
357:10 - up uh blank typescript projects from
357:13 - scratch every day it's not a very common
357:16 - thing because once you get your stuff
357:18 - set up you don't really think about it
357:19 - so I'm going to imagine that you know
357:22 - you're starting from scratch trying to
357:24 - figure out how to get this started and
357:27 - we're going to just use documentation to
357:29 - get ourselves there so let's go to the
357:31 - typescript documentation this is the
357:34 - first place that you would obviously go
357:36 - to figure this out
357:37 - so there's a get started a handbook and
357:41 - a reference these are going to come in
357:44 - once you're kind of well into things the
357:46 - get started is where we want to start
357:49 - so let's go ahead and look maybe
357:53 - typescript Tooling in five minutes looks
357:56 - like a good starting place so if we look
357:59 - at this page it's going to tell us how
358:01 - to get started so we can install
358:03 - typescript in two main ways through npm
358:07 - or yarn or pnpm or whatever we're using
358:10 - or by installing the visual studio
358:13 - plugins now I believe this is talking
358:15 - about Visual Studio the full on IDE not
358:20 - necessarily Visual Studio code I think
358:23 - there's a there's a big difference
358:24 - between those two we'll get to that
358:27 - though and it says you can install it
358:30 - just like this
358:31 - but what I want to find out vs code
358:35 - typescript let's see how it pairs with
358:38 - Visual Studio code which is what we are
358:40 - using here
358:42 - it says you know typescript is a
358:45 - superset of JavaScript blah blah
358:47 - and it says it comes with the language
358:49 - support but it does not come with the
358:52 - TSC or typescript compiler so just
358:56 - zooming out for a second remember
358:58 - typescript is a superset of JavaScript
359:01 - it does not natively run in any browser
359:04 - in other words you have a build step
359:08 - um or not not necessarily a build step
359:10 - but a compile step where you have to
359:13 - transpile that typescript syntax to
359:17 - plain JavaScript and once it's compiled
359:21 - to plain JavaScript then it can run in a
359:23 - browser so that's kind of our goal here
359:25 - and to do that we need the typescript
359:27 - compiler or TSC
359:30 - so here it's telling us to do the same
359:32 - thing as over here so if we go back to
359:34 - visual studio code I am using the yarn
359:38 - package manager you can also use npm but
359:42 - we'll just say yarn Global add this is
359:45 - the same as npm G or npm install Dash G
359:50 - and I'm going to add typescript and I
359:53 - already have it installed but it will
359:55 - install the latest version and there's
359:58 - the compiler and then the TS server as
360:00 - well now Visual Studio code I believe
360:03 - comes with this server so if you hit
360:06 - command p and you hit the little carrot
360:10 - and then type
360:12 - typescript let's see
360:15 - uh it's not going to show up quite yet
360:17 - because we don't have a typescript file
360:19 - open so let's just try something here
360:23 - Okay so we've created a TS file and just
360:26 - I've added a basic type just to fill
360:29 - something up and what you'll see down
360:31 - here in the the bottom right is that vs
360:34 - code has detected that we're using
360:37 - typescript and it's kind of kicked off
360:40 - the TS server I believe that's how it
360:42 - works uh leave a comment if I'm wrong on
360:45 - that but if we hit command p and then
360:48 - type a little carrot you can see that we
360:51 - can search for typescript and restart
360:53 - the TS server or reload the project so
360:56 - just know that in the background
360:58 - typescript vs code is working and
361:02 - actively looking through your code and
361:05 - recognizing the different types that are
361:07 - added so let's go back to the
361:09 - documentation it says building your
361:11 - first typescript file
361:13 - and it's giving you basic typescript and
361:17 - then it's saying you can compile it by
361:20 - passing the file name to the typescript
361:22 - compiler
361:24 - and then I think it just goes through
361:27 - some like basic introduction to
361:29 - typescript which this tutorial is not
361:33 - going to be necessarily an introduction
361:35 - to typescript but more of a like why
361:38 - would I need typescript and what does it
361:40 - solve for me so it'll be a light
361:42 - introduction but we're not going to
361:43 - really get into the meat of of
361:45 - typescript
361:46 - so let's go back and clear the terminal
361:50 - here and with our index.ts let's just
361:54 - Define some variable equal to 20 and
361:59 - then
362:00 - um
362:01 - let's give it a custom object type okay
362:06 - so we'll we'll say that some variable
362:10 - is a number another variable is a string
362:15 - and then if we assign this type
362:21 - to our object now typescript is going to
362:24 - kick in and it's going to start telling
362:26 - you
362:27 - um you know that you've missed certain
362:29 - typings so we've got these red
362:31 - squigglies because vs code has detected
362:34 - that you are typing this object as a
362:37 - custom object type which has these two
362:40 - properties so we need to actually fill
362:43 - these in with their matching types
362:46 - so if we put these in just like that and
362:49 - then finish off the object now this is
362:52 - matching the type that we've assigned it
362:54 - and if we tried to add an extra prop
362:59 - it's going to yell at us because that
363:01 - does not exist in the type that we gave
363:03 - it so anyways the point of this is to
363:06 - just give a Bare Bones introduction to
363:09 - what typescript is doing and we'll see
363:12 - how this kind of plays out to benefit us
363:14 - in the refactor for right now I'm just
363:17 - going to compile this so we've got the
363:20 - TSC or the typescript compiler installed
363:24 - globally
363:25 - let's go ahead and check so we'll pass
363:29 - the version it gives us 4.9.5 and now
363:33 - let's go and call for help so this will
363:37 - basically give you all the options which
363:39 - is pretty
363:41 - overwhelming to start with but you can
363:43 - see that
363:45 - if we just run TSC it compiles the
363:48 - current project
363:49 - so let's pass this file to it so TSC
363:54 - uh app or I'm sorry JS and then
364:00 - no we need to get into our live TS
364:03 - refactor first
364:05 - now we'll say TSC Js index.ts
364:10 - and you can see that we ran that command
364:13 - and now we have an index.js sitting over
364:17 - here which is the compiled version of
364:20 - index.ts so let's open up the two files
364:24 - next to each other and what you're going
364:26 - to see here is typescript in action over
364:30 - on the left is our DOT TS file this is
364:33 - what we're writing our source code in
364:35 - and we're able to use custom typings and
364:39 - assigning those typings to a variable
364:42 - now looks like something is going wrong
364:45 - here
364:47 - and it looks like the two files are
364:49 - actually conflicting so let's uh name
364:52 - this let's put something at the end
364:55 - there and it will solve this error for
364:57 - us so just know that because they're in
364:59 - the same directory and vs code is pretty
365:01 - smart it's detecting that we have two
365:04 - variables that are the same name now
365:07 - this is not going to happen in our final
365:09 - code because we're going to configure it
365:11 - not to but just know that that's what's
365:12 - happening here but anyways the point is
365:15 - that we've got a type here which is
365:17 - actually not valid JavaScript code you
365:20 - can't run that in a browser or node.js
365:23 - or any JavaScript or runtime so what the
365:26 - typescript compiler does is it removes
365:29 - this type and it removes this type
365:31 - annotation right here and it gets us to
365:34 - this just vanilla JavaScript object that
365:38 - can actually run in the browser so
365:40 - there's really two questions that come
365:43 - out of this number one why would we want
365:46 - to do this this what is the purpose of
365:48 - adding these types and then number two
365:51 - how do we get more control over how this
365:54 - compiles to this because there's going
365:57 - to be different
365:59 - um options that we can use to make that
366:02 - transformation happen and furthermore
366:04 - you know we don't want them going in the
366:07 - same directory because obviously that
366:08 - screws things up with you know variable
366:11 - declarations happening twice and so on
366:13 - and so forth so there's some
366:15 - configuration that we can do to make
366:17 - this better for us so let's go back to
366:21 - Excalibur here
366:23 - and come down here and say
366:27 - benefits of typescript
366:30 - so you could definitely go through a
366:32 - laundry list of things that typescript
366:36 - helps with and you know there's plenty
366:38 - of people that go and do that but I'm
366:40 - going to keep it simple here and just
366:42 - give one or two reasons why it is
366:45 - beneficial for your code base the first
366:48 - one is just
366:50 - um
366:52 - code checking in general so in other
366:55 - words it's going to if you're using
366:57 - visual studio code and you're using
366:59 - typescript visual studio code is
367:01 - basically walking through all of your
367:03 - code base and making sure that
367:06 - everything talks to each other
367:08 - appropriately so we will see this in
367:11 - action as we start to refactor but if we
367:13 - go back to our original application let
367:17 - me delete this index.ts file
367:21 - um and then the index.js
367:25 - if we go back to our original project
367:28 - which once again if you haven't seen
367:30 - this already if you didn't watch the
367:31 - prior video at least make sure that
367:34 - you've skimmed over the code and know
367:35 - what's there if we go to app.js
367:40 - um and let's try to find a good example
367:42 - of this
367:43 - so here's a good one when we are calling
367:46 - view dot render and we are passing in
367:49 - all of our state of the application
367:53 - these State objects have a certain type
367:57 - and as you can see Visual Studio code is
368:01 - giving you some you know suggestions as
368:04 - to what types these are already even
368:06 - though we're not using typescript and
368:09 - it's just inferring this from the
368:11 - function definitions over here in store
368:14 - so it can read through the functions and
368:17 - it can see you know what we are
368:19 - returning so the return type here and
368:22 - then it kind of infers okay what
368:24 - properties are on this object that was
368:26 - returned so on and so forth but if we go
368:29 - back to app.js it doesn't really know
368:32 - what type anything really is it can
368:35 - figure out the Boolean type but the
368:38 - moves in the current player in the
368:40 - winner these are all any types because
368:43 - because it can't really figure that out
368:45 - with plain vanilla JavaScript and what's
368:49 - Difficult about this and hard to
368:52 - maintain as your project grows is as
368:55 - you're typing things
368:57 - um quite literally as you're like typing
368:59 - on the keyboard and passing variables
369:03 - around in your application it's very
369:05 - useful to know are you passing something
369:07 - valid into a function and typescript
369:11 - allows you to do this very easily you'll
369:14 - really start to see this benefit as we
369:16 - start to refactor so the second benefit
369:19 - that I've personally found with
369:22 - typescript is refactoring so very soon
369:25 - you know for this video since we're
369:28 - refactoring stuff but if you have a big
369:31 - code base and you're trying to go
369:32 - through and refactor an entire feature
369:35 - it is extremely difficult to do so if
369:38 - you just have vanilla JavaScript and you
369:41 - don't have any strong typings throughout
369:43 - your application
369:44 - with typescript it's a lot easier
369:46 - because as you change things you know
369:49 - Visual Studio code or your editor that
369:51 - runs the typescript server is going to
369:53 - be able to tell hey did you move things
369:55 - around correctly and are you passing you
369:58 - know is your refactor going to break the
370:01 - compilation of the code
370:04 - but enough talk let's get started
370:08 - um so the first thing that we need to do
370:10 - now that we've got typescript installed
370:12 - and we kind of understand the general
370:14 - concept of what's going on is get it set
370:17 - up for this specific application
370:20 - so I know we've got it installed
370:22 - globally if you use TSC and you know
370:25 - type the version that's that binary is
370:28 - installed on our computer globally but
370:31 - it's always a good practice to install
370:33 - it as a developer dependency within your
370:37 - project and the reason being is you know
370:40 - the the global version is going to be
370:42 - different on each developer's computer
370:45 - so if you're collaborating on a project
370:46 - it's good to pin that typescript version
370:50 - for the application so that you have
370:52 - predictable builds in compiles when you
370:56 - when you compile that code to plain
370:58 - JavaScript so to do that I'm going to
371:01 - type yarn init
371:04 - and pass the dash Y flag just to say yes
371:08 - to all the options and just get a
371:10 - package.json file created so here's our
371:16 - package Json and we've got live TS
371:18 - refactor blah blah and the first thing
371:22 - we'll do is
371:25 - um yarn add and then patch a dash dash D
371:29 - for developer dependency and then I want
371:32 - to install typescript
371:34 - so now you can see dev dependencies has
371:37 - typescript now why is this a developer
371:40 - dependency and not a regular dependency
371:43 - well this is super important and the
371:46 - reason being is because as we talked
371:48 - about typescript is only going to happen
371:51 - before you deploy your application so
371:55 - you write all your code in typescript
371:56 - but obviously that's not correct or it
372:00 - is correct it's not valid for running in
372:03 - the browser or a node.js runtime so
372:07 - before you deploy your application you
372:09 - know out on some server like AWS or
372:12 - render or digitalocean what what have
372:14 - you you need to First build it to the
372:18 - appropriate runtime that you're using
372:20 - which is probably going to be common JS
372:23 - or es6 so the point of having this as a
372:27 - Dev dependency is to express the fact
372:29 - that you're not going to need this to
372:32 - actually run the application you just
372:34 - need it to to build the application to
372:36 - the point where then it can run
372:38 - the next thing that we need to do is
372:41 - initialize a TS config so this file is
372:45 - going to be a special file that sits in
372:48 - the root directory of your project and
372:51 - it tells this compiler so remember TSC
372:54 - is the compiler we don't want to use the
372:56 - global version anymore so in this case
372:59 - we can run yarn TSC to grab it
373:02 - specifically from the project and then
373:05 - just run that and it's going to try to
373:08 - compile stuff but it doesn't find any
373:10 - typescript files to actually compile so
373:14 - anyways we need to set up a TS config to
373:18 - tell it how to compile things so how we
373:22 - do that is we say
373:24 - yarn TSC I think init is the right thing
373:29 - so let's go to help
373:31 - and let's read through the options okay
373:35 - so here's the start of the options and
373:39 - you can see TSC dash dash init creates a
373:43 - tsconfig.json with the recommended
373:45 - settings in the working directory so
373:48 - that is what we want to do so we'll run
373:51 - yarn TSC dash dash init
373:55 - and you can see that it created a nuke
373:58 - tsconfig.json which we can open up up
374:01 - here and this these are the options that
374:04 - it gave it by default so let's go read
374:07 - through this
374:08 - and right off the bat you can see that
374:11 - there's quite a lot going on so by
374:14 - default it's going to have everything
374:16 - commented out
374:18 - and we're going to get rid of all this
374:20 - these are just kind of all the different
374:22 - options and you can go to this link here
374:27 - to view the reference for this so the TS
374:30 - config and it basically just takes you
374:33 - through all the different compiler
374:34 - options you can click on these links to
374:37 - to figure out what they do
374:39 - but most of these options are not going
374:41 - to be relevant starting out
374:44 - especially for a beginner these are more
374:47 - of just options to control you know your
374:51 - developer experience as you're building
374:53 - in a typescript code base and also of
374:56 - course how it actually builds and
374:59 - compiles the typescript to JavaScript so
375:01 - let's go ahead and get rid of all the
375:03 - comments just to see what it gave us so
375:06 - these are the defaults that you're going
375:08 - to get and we'll go from the kind of
375:11 - least important to most starting from
375:14 - the bottom skip lib check this just
375:16 - tells uh typescript to ignore kind of
375:19 - the node modules dot d dot TS files
375:23 - um that's not super relevant here strict
375:26 - true this is always going to be a good
375:29 - thing to turn on because as you go
375:32 - through your code and write typescript
375:34 - the intellisense that's provided by
375:36 - Visual Studio code will make sure that
375:38 - everything
375:39 - checks out and all the types are
375:42 - consistent so this is always good to
375:45 - have on these two options are just
375:48 - related to some maintenance of your code
375:52 - base so forces you know file naming
375:55 - consistency this allows you to
375:58 - um
376:00 - have interoperability between common JS
376:04 - modules and es6 modules so I actually
376:07 - wrote a whole post on this if you go to
376:10 - my site
376:11 - scripts versus common JS versus UMD AMD
376:15 - and es6 modules so this is a mouthful
376:18 - but this kind of explains what that is
376:20 - talking about
376:22 - and then most importantly is the Target
376:24 - and the module options so this is
376:27 - telling the typescript compiler
376:30 - what kind of code that needs to be
376:33 - output into you know code that can
376:37 - actually run within a browser and that's
376:39 - our goal is to get our typescript files
376:42 - to run regular JavaScript files so that
376:45 - we can just write our code and
376:46 - typescript and then the compiler deals
376:49 - with getting that to a place where it
376:51 - can run in the browser so let's go to
376:53 - the reference
376:55 - um we'll go to the the reference guide
376:57 - here so we'll start with the first one
377:00 - which is the target
377:02 - now I believe this is going to be in the
377:06 - um let's see where is this so just to
377:09 - orient ourselves it's in this is the
377:11 - compiler options uh field so if you
377:15 - you'll notice all this is defined in
377:18 - compiler options and here in the
377:20 - language and environment section you'll
377:23 - find Target right here
377:26 - let's click on that it'll scroll down
377:28 - and it says modern browsers support all
377:31 - es6 features as we've been talking about
377:34 - and we wrote our original project in so
377:38 - es6 is a good choice you might choose to
377:40 - set a lower Target if your code is
377:43 - deployed to older environments or a
377:45 - higher Target if your code is guaranteed
377:47 - to run in newer ones so in other words
377:50 - what Target represents is the end state
377:53 - of the code that is going to be compiled
377:56 - so we are going to Target es6 because
378:01 - that is going to mirror what we did the
378:04 - original refactor the Vino the vanilla
378:07 - JS one
378:09 - um so you can see we've already got that
378:12 - es2016
378:14 - um you can pass a couple different
378:15 - options I think it yeah it gives you all
378:18 - the options right here
378:20 - um but es6 es2015 yes 2016
378:25 - um all the way up to es next so let's
378:27 - just grab es6 because we know that
378:30 - that's available in all browsers
378:33 - um I'm not sure why they did es
378:36 - 2016 when they say es6 is a good choice
378:39 - kind of mismatching their defaults but
378:43 - anyways this is what the code compiles
378:45 - to the next one is module so let's go
378:49 - look at that we'll go back to the top
378:51 - and if you see modules you will find the
378:55 - module property
378:57 - this sets the module system for the
378:59 - program
379:00 - and
379:02 - um see the modules reference you very
379:05 - likely want common JS for node projects
379:08 - so not to backtrack at all but going
379:11 - back to that post
379:13 - that I wrote here scripts common JS es6
379:17 - modules this really talks about these
379:20 - different module systems but basically
379:22 - if we look at let me do a sample file
379:27 - so sample.ts basically if we look at you
379:31 - know this syntax import something from
379:34 - some uh Library this is what we would
379:38 - consider es6 module syntax now if we did
379:42 - something like this const
379:46 - something equals require
379:50 - some lib this is going to be common JS
379:53 - syntax so the require syntax and then
379:57 - also module dot exports
380:01 - at the bottom of your file this is all
380:03 - going to be common JS syntax now if we
380:06 - do es6 once again it's import something
380:09 - from some web and then you can come down
380:12 - and you can export
380:15 - um you know some object or export
380:17 - default and this will export things from
380:20 - your file which is uh one to one with a
380:24 - module so that's what that is talking
380:26 - about and you'll see that it defaults to
380:29 - Common JS which again is a little bit of
380:31 - a mismatch it says the default is common
380:34 - JS if the target is ES3 or es5 es6
380:38 - otherwise I'm not really sure given this
380:42 - documentation and the fact that we're on
380:45 - the latest version of typescript
380:47 - why it defaulted to that but we really
380:50 - want to just have es6
380:53 - because we want to deal with that nice
380:55 - module syntax
380:57 - um that es6 comes with and then going
380:59 - down the list es module interoperability
381:02 - as I said is the ability to basically
381:05 - combine the syntax that we just went
381:08 - through and have files from multiple
381:11 - module systems being able to compile
381:14 - together this is going to be important
381:17 - especially if you have certain you know
381:19 - libraries that still use old common JS
381:23 - module systems or newer ones that you
381:27 - know use es6 modules and don't support
381:29 - common JS so having that
381:32 - interoperability is really nice
381:34 - especially in larger projects
381:36 - so at this point we've gone through most
381:38 - of this and once again you can read
381:40 - through the documentation if you have
381:42 - questions on any other properties but
381:46 - for now I want to build a sample project
381:49 - just to get our our bearings here so
381:52 - let's make a folder called test
381:57 - TS and this is just going to have a test
382:01 - TS file just something to work with and
382:05 - in this file we're going to just you
382:07 - know
382:08 - Define a sample type
382:10 - and the sample type is going to have a
382:13 - name which is a string and an age which
382:17 - is a number and then we will say let's
382:20 - actually
382:21 - call this a person type and then we'll
382:24 - say const person is a variable and this
382:27 - will be of person type and then we will
382:30 - just give it a string so Bob and then
382:33 - age
382:35 - so something like that so this is our
382:38 - basic TS file let's save our TS config
382:42 - and now we should be able to compile
382:45 - some things so the first question is
382:49 - well how does it know where to look how
382:51 - does it know that we want to compile
382:52 - that test.ts file well let's go ahead
382:55 - and try it so yarn TSC and run it
382:59 - and it says done in 0.73 seconds and it
383:03 - obviously found the correct file to
383:05 - compile so the question is how did it
383:08 - actually know that well let's go to the
383:11 - documentation and look outside of the
383:13 - compiler options at the top level
383:15 - options
383:16 - let's go to include
383:19 - and this is an array that specifies an
383:22 - array of file names or patterns to
383:24 - include in the program and then over
383:26 - here in the default the array if files
383:30 - is specified all otherwise so as you can
383:35 - see in our code base we ran the TSC
383:38 - compiler and it automatically just
383:41 - looked for any dot TS file in the entire
383:44 - folder and compiled it and that's
383:46 - because it's got this default glob that
383:50 - is including everything
383:52 - so given that behavior I think we're
383:54 - fine now the um the problem with
383:57 - compiling your TS files in the same
384:01 - directory as where they're written is it
384:05 - just starts to get really messy and then
384:06 - furthermore you really want to Output
384:09 - them into their own build folder now
384:13 - there's a lot more to this subject in
384:15 - general like uh creating a bundle and
384:18 - that involves things like webpack or
384:21 - parcel or whatever have you whatever now
384:23 - there's a lot more to this specific
384:25 - subject we could talk all day about you
384:29 - know how things are compiled where
384:31 - they're stored all that kind of stuff
384:33 - this gets into bundling and code
384:36 - splitting and you know build tools like
384:38 - webpack or roll up or parcel or whatever
384:42 - we're not going to get into that because
384:45 - we don't need it for this simple of a
384:47 - project our goal is to basically take
384:49 - all of our TS files and put them in one
384:53 - spot and then that will be imported to
384:56 - the index.html and it will run just like
385:00 - our vanilla project would so to do that
385:03 - we have a option that we can specify
385:07 - and let's see where it is so
385:11 - looking under a mitt
385:13 - this is probably where we want to look
385:15 - and yes here's the out directory
385:19 - this is if it's specified
385:22 - dot JS files will be emitted into this
385:26 - directory the directory structure of the
385:28 - original source files is preserved see
385:31 - root directory if the computed root is
385:33 - not what you intended so that's probably
385:35 - not going to apply for us
385:38 - um but you can see it gives an example
385:41 - where it outputs to a dist directory or
385:45 - distribution which is a very common
385:47 - directory to Output compiled files so
385:51 - that's what we're going to do
385:54 - we'll come back to compiler options and
385:57 - give it a out directory you can see vs
386:02 - code knows all these options gives you
386:04 - some autocomplete so if we specify out
386:07 - directory gives us the documentation
386:09 - which is very useful
386:11 - and we're going to say that we want to
386:14 - put this to the dist folder
386:16 - so we're getting some errors here and
386:19 - that's because we need a comma
386:23 - and once we save this and we rerun the
386:26 - compilation now it's going to Output
386:30 - everything into dist and there's our
386:32 - test.js file so you can see use strict
386:35 - is put in there and we've got a person
386:38 - compiled you'll notice that from earlier
386:41 - in the video this is a different syntax
386:44 - than we saw earlier earlier we saw this
386:48 - was a VAR and there wasn't any use
386:51 - strict going on at the top and that's
386:53 - because we didn't have a TS config we
386:56 - didn't have all of these targets and
386:59 - modules that were specifying how we
387:01 - wanted things to be output
387:03 - so anyways this is the basics of
387:07 - compiling a typescript project now our
387:10 - next order of business here is to look
387:13 - in our JS directory from our original
387:16 - refactor and convert these files to
387:20 - typescript so I'll leave this test TS
387:23 - folder for us let me get rid of the dot
387:26 - JS compiled file because that's now
387:28 - going to be over in dist
387:31 - um one thing that you would want to do
387:33 - here
387:34 - before we get too far is add a git
387:36 - ignore if you're working with Git and
387:40 - put the dist directory
387:43 - as well as node modules because we've
387:45 - added both of those neither of those
387:47 - need to be uploaded to Source control
387:50 - because node modules obviously can be
387:53 - installed by yarn and then the dist
387:57 - directory is the build itself which is
388:00 - going to be created with yarn TSC so
388:04 - let's close out TS config and let's
388:06 - start in the app.js file so now that
388:10 - we're working with typescript we can
388:12 - just rename this to dot TS and now vs
388:16 - code is going to automatically recognize
388:18 - that this is a typescript file and it's
388:22 - going to start underlining things and
388:24 - it's going to yell at us for all sorts
388:27 - of stuff because nothing is typed here
388:29 - now there are some strategies that you
388:32 - can use to migrate a JS project to
388:36 - typescript but in our case things are
388:38 - small enough that the best strategy here
388:41 - is to just rename all of these to TS so
388:46 - that we're dealing with typescript
388:47 - across the board
388:50 - now if we were to go through and
388:53 - just try to compile this right now it's
388:56 - going to throw all sorts of errors and
388:59 - the reason that it does that is kind of
389:01 - the whole purpose of typescript and that
389:04 - is it's going to check the types and
389:06 - make sure that they're all compatible
389:08 - across all the files with the Imports
389:10 - exports you know function calls
389:13 - parameters all of that stuff and that's
389:16 - a good thing that's what you want but
389:18 - when we first start out and everything
389:20 - has these red squiggly underlines and
389:23 - typescript is really mad at us it's not
389:25 - so fun
389:26 - but I'm going to work through this it's
389:29 - not as
389:30 - um it's not as intimidating as you'll
389:32 - think
389:33 - um and we'll get this thing worked out
389:35 - shortly so just as a reminder
389:38 - um the current project is no longer
389:41 - going to work because in index.html
389:44 - we are importing app.js and that does
389:49 - not exist any longer we have app.ts if
389:53 - we tried to replace this it's just not
389:56 - going to work because typescript is not
389:58 - valid in our JS runtimes so what we
390:03 - really need to adjust here I'm just
390:06 - going to do this right off the bat so
390:08 - that we don't forget is now that
390:11 - everything's being compiled to the dist
390:13 - directory we need to now specify instead
390:16 - of JS we're going to look in the dist
390:19 - directory and import
390:23 - app.js
390:24 - so same thing as the original project
390:26 - it's just going and looking in a
390:28 - different directory instead of the
390:30 - source code that you know in our prior
390:32 - refactor was able to run in the browser
390:35 - now we have to use the compiled code and
390:38 - you can see in dist it's going to
390:40 - maintain that folder structure so we
390:44 - actually need to say dist slash JS slash
390:48 - app.js
390:50 - and you can see that it will you know
390:53 - this this has been compiled
390:56 - um it through a bunch of errors but it
390:59 - still compiled it so we could probably
391:01 - get this to work actually let's just see
391:04 - real quick
391:06 - the way that we'll do this
391:08 - is we already have live server running
391:10 - just I had this before the video so it's
391:13 - on Port 5500
391:15 - and we're looking in dist Js app.js
391:19 - so let's go to
391:22 - the vanilla refactor and instead we'll
391:24 - go to the live TS or let's just go to
391:27 - let's go to localhost localhost 5500
391:32 - live TS refactor and let's see it seems
391:36 - to be working
391:38 - so even though there was all those type
391:40 - errors
391:42 - um it still compiled the JavaScript and
391:44 - this makes sense because typescript is
391:47 - just a superset of JavaScript so while
391:50 - not all typescript is valid JavaScript
391:53 - all JavaScript is valid typescript so in
391:56 - other words when we went to compile
391:58 - these vanilla JS files just in a
392:02 - different form it still knew how to do
392:04 - it it just was complaining about all the
392:06 - types so in this case where we're
392:09 - migrating an existing vanilla JS project
392:13 - this behavior is actually good because
392:16 - we can you know gradually migrate our
392:19 - code over and not break everything from
392:22 - the start so there are some options
392:25 - though once we get to a more final state
392:28 - if we go to the documentation let's
392:31 - close some things out here
392:34 - if we go back to this reference there
392:38 - should be some sort of configuration
392:40 - property that allows us to basically
392:43 - fail the build if there are any errors
392:46 - so we ran yarn TSC
392:51 - and it it's going to give us all of
392:54 - these errors if we just look through
392:55 - them
392:57 - um but it's going to still compile all
392:59 - those files to our output directory but
393:02 - just to demonstrate how you can change
393:03 - this behavior I'm going to get rid of
393:05 - the test TS directory now just so that
393:09 - that's not clouding anything up and then
393:12 - I'm going to completely delete the dist
393:14 - directory
393:16 - so that's okay because remember we can
393:19 - just run yarn TSC and it's going to
393:21 - create the disk directory interestingly
393:24 - enough now that we deleted that other
393:26 - directory that had typescript this Now
393:30 - does not maintain the JS directory
393:32 - structure so before I forget I'm sure
393:36 - there's an option to change that but
393:38 - before I forget let's go and remove that
393:41 - path
393:42 - and if we go back to our browser
393:45 - um let me get rid of this
393:48 - let's refresh and we can still play our
393:51 - game
393:52 - so this is looking at the live TS
393:54 - refactor
393:56 - so it's still working but if we go to
393:58 - the options reference there should be
394:01 - some options in the emit so if we're
394:03 - scrolling through there's this option
394:05 - called No emit on air
394:08 - and I think that's
394:10 - um
394:11 - what we want let's just scroll through a
394:13 - few more things okay so let's click on
394:16 - no omit on air
394:17 - this says do not emit compiler output
394:20 - files like JavaScript source code Source
394:23 - Maps or declarations if any errors were
394:25 - reported this defaults to false making
394:29 - it easier to work with typescript in a
394:31 - watch-like environment where you may
394:32 - want to see results of changes to your
394:34 - code in another environment before
394:36 - making sure all errors are resolved so
394:39 - let's just take this property no emit on
394:42 - air
394:43 - we'll open up our TS config
394:46 - and we'll throw this at the end so no
394:49 - emit on air
394:51 - and this defaults to false but we're
394:53 - going to say true
394:54 - now let's once again delete the dist
394:56 - directory
394:59 - and let's try the yarn TSC to compile
395:02 - our typescript files
395:05 - and now you'll see that even though we
395:08 - ran this there's no dist directory
395:11 - because we've said if there are errors
395:14 - do not emit any you know output files
395:18 - now once again we don't really want this
395:21 - because when we are converting our
395:23 - project over we want the ability to you
395:27 - know just compile the typescript files
395:29 - with errors so that we get a build
395:31 - output and then in a final State you
395:34 - might you know once you've converted
395:36 - your project over you might add that
395:38 - back or have other sort of build checks
395:41 - to make sure that you know you get a
395:43 - clean build before you deploy your
395:45 - application so now that we have
395:47 - everything set up and we've got the app
395:50 - working with this disk directory we will
395:53 - just jump into this JS folder it's
395:57 - probably you know not the best name for
395:59 - it anymore JS but technically typescript
396:03 - is a superset of JavaScript so it's
396:05 - somewhat valid
396:06 - but what we'll do is we will start
396:10 - um I think rather than starting an app
396:12 - which kind of consumes both the store
396:14 - and The View
396:16 - let's just start with the store because
396:19 - um it's always good to Define the types
396:22 - of your state at the beginning that just
396:26 - kind of helps you inform you know the
396:27 - rest of the files in the project design
396:30 - in general so this is just in general a
396:33 - good place to start now in this folder
396:35 - I'm also going to make a new file called
396:38 - types dot TS and this is going to be a
396:43 - module that exports a bunch of types
396:45 - that the rest of our files are going to
396:47 - consume and pass around
396:49 - to keep things more clear in our heads
396:52 - and to also satisfy the compiler so let
396:56 - me just reference
396:58 - um my final to make sure I'm getting the
397:01 - right types here okay so let's close
397:03 - this out our types will go on the left
397:06 - and then we'll put our store on the
397:08 - right so the first thing that we'll see
397:10 - as we're going through aside from all
397:13 - the red squigglies is this initial state
397:16 - so this is the
397:18 - um the shape of the object that we're
397:21 - storing in local storage as you can see
397:24 - here so if we open up our app and
397:27 - inspect and we go over to storage and
397:31 - local storage
397:33 - you'll see that I've already played the
397:35 - game and you can see this updates on
397:37 - every move
397:39 - and if we open this up you can see the
397:42 - parsed value so we've got the current
397:44 - game moves the history all games current
397:47 - round games and then you can go through
397:49 - and just see all the moves that have
397:51 - been made by the different players so
397:54 - that is the shape of that object that
397:56 - we're storing in state now the benefit
397:59 - of typescript is to just have confidence
398:01 - over you know the types we're passing
398:04 - around so it would be a great idea to
398:07 - Define that state so in typescript you
398:10 - define a typing with either the type
398:13 - keyword or the interface keyword the
398:16 - difference between the two is a
398:18 - discussion for another day I generally
398:21 - prefer types
398:23 - um but you know some people will get
398:25 - very in you know heated with a
398:28 - discussion about which one is better in
398:30 - which situation
398:32 - but we'll start with just a type
398:35 - and I'm going to call this the game
398:37 - state so game state is an arbitrary name
398:40 - I'm giving this type similar to how we
398:42 - would you know Define a variable name
398:44 - and the type is defined using you know
398:47 - basic object syntax so I'm just going to
398:51 - match this so let me copy this shape
398:54 - over and get rid of this comment
398:58 - so right now this is not really a valid
399:00 - type
399:02 - um it's not really complaining about
399:03 - anything but this is not a valid type
399:06 - let's go ahead and give this a type of
399:11 - let's see current game moves
399:14 - let's just say it's any for right now
399:18 - and it's going to be an array so it's
399:20 - going to be an array that has objects
399:23 - that are have any shape so this is just
399:26 - our starting point now we need to Define
399:29 - all of these types right here so this is
399:32 - kind of our final thing that we need to
399:34 - get to but we need to decompose our
399:37 - types into you know smaller units so
399:40 - that we can pass them around our files a
399:43 - little bit easier
399:44 - so the first thing I want to do is
399:46 - Define a player so you can see that
399:49 - we've got squiggly lines under the
399:51 - players param or argument that we're
399:54 - passing into the class Constructor and
399:57 - if we were to open up the app.ts
400:00 - you can see the player's array that
400:02 - we've defined so let's give a type to
400:05 - these objects you can see that they have
400:07 - the same exact object shape so we can
400:11 - give this a representation of player
400:15 - and a player is going to have an ID a
400:19 - name an icon class and a color class now
400:22 - these are the actual values
400:25 - but we want to give these a type so a 1
400:29 - is going to be a number type
400:32 - player one is going to be a string type
400:35 - the icon class is also a string type and
400:38 - the color class is a string type so here
400:42 - we have defined a player type now you'll
400:45 - notice that all of these just have
400:47 - regular you know primitive typings
400:50 - and they don't have anything crazy going
400:53 - on here now with typescript you can make
400:55 - a property optional by adding a little
400:58 - question mark after the property or I
401:02 - guess not sure if you'd call that a
401:04 - property but you put this question mark
401:06 - here and now the color class would be an
401:09 - optional property so you can hover over
401:12 - it and it says it's either string a
401:14 - string or undefined and if we remove
401:17 - that it is just going to be a string for
401:20 - our game since this is a configuration
401:22 - property we want this to be all required
401:26 - properties so this is the correct shape
401:30 - so now what we can do is go back to
401:34 - stored.ts and move on to the next type
401:37 - that we'll need
401:38 - this does not satisfy anything that
401:40 - we've got going on here but it will be a
401:43 - building block for us to work from so
401:46 - the first thing I want to do is Define
401:48 - the current game moves so what is a move
401:51 - in our game if you we scroll down to
401:55 - Player move you can see that what we're
401:58 - pushing to state is a property with a
402:01 - square ID and a player so we just
402:05 - defined the player interface or type but
402:09 - what is square ID well this is just
402:11 - going to be a number and we can Define
402:15 - this as a move so let's call it a move
402:19 - and it's going to have a square ID which
402:22 - is a number and then a player which will
402:26 - basically be this type right here so if
402:29 - we hover over move you can see that this
402:32 - is the type that we've given it we can
402:35 - now take this move type and replace the
402:38 - any type in the current game moves with
402:41 - move so now the current gave game moves
402:44 - is an array of moves and that lines up
402:47 - with what we've done here where we are
402:50 - pushing a move to the array of current
402:53 - game moves which is our state now to
402:56 - figure out what we're going to type the
402:58 - history object with we need to go down
403:00 - into the store class and figure out what
403:04 - we're doing
403:05 - so in the reset method
403:08 - what we are doing is pushing games to
403:13 - the history object under the current
403:15 - round games property
403:17 - so this is the type that we're looking
403:19 - for we are pushing an object
403:22 - that has a moves property and a status
403:26 - property now it's pretty clear what
403:28 - moves represents moves is going to be
403:31 - what we just defined an array of moves
403:34 - so we can start with that and we're
403:37 - going to call this a game
403:40 - so a game is going to be represented by
403:44 - an array of moves and then we have a
403:47 - status property
403:49 - we don't really know what that is yet so
403:51 - let's give it a type of any to start
403:53 - with and now we can kind of go look
403:56 - through our code base and Define what
403:58 - that type is so if we track backwards
404:01 - and look at status it's coming from a
404:04 - destructured property off of this Dot
404:07 - Game and if we look what this dot game
404:10 - is
404:12 - that is a getter method on the class and
404:15 - the return type of that getter method is
404:18 - all of this stuff so we have a moves
404:21 - array we have a current player and we
404:24 - have a status
404:26 - this object right here the status is
404:29 - what we are trying to Define so let's
404:32 - make one more type called game status
404:34 - and that's going to be an object with an
404:38 - is complete property which is going to
404:40 - be a Boolean value value as you can see
404:44 - and then the winner is going to be a
404:47 - player so the winner is going to be
404:50 - represented by a player which we defined
404:53 - right up here so now we can take this
404:56 - game status
404:57 - and this is going to be the
405:00 - representation of status within the game
405:03 - type
405:04 - so once again we're coming down here and
405:07 - this is where we're pushing a game to
405:10 - the history of current round games we've
405:13 - got a moves property which is now
405:15 - represented by an array of moves and we
405:17 - have a status property which is now
405:19 - represented by a game status which has
405:22 - this type and now we're finally ready to
405:25 - replace some things here so we have a
405:29 - game and a game status
405:31 - let's put game right here for current
405:34 - round games now the last thing we have
405:36 - to fill in is the all games we have to
405:39 - figure out what type of array that is
405:40 - and I'll just save us some pain of
405:44 - looking through this and just say it's
405:46 - going to be the same thing so the
405:49 - current round games in all games going
405:51 - to have the same exact type
405:53 - at this point we have defined all of
405:56 - these supporting types for our game and
406:00 - in this case we had just looked at our
406:03 - reference code our JavaScript and we're
406:05 - basically just looking at you know what
406:08 - kind of objects are we passing around
406:11 - what are we returning from our different
406:13 - functions and we're just looking and
406:16 - analyzing our code to see that
406:19 - information
406:20 - if you're starting this project from
406:22 - scratch and you intended to use
406:24 - typescript all the way through
406:26 - this is actually a great exercise to go
406:29 - through before you even write any code
406:32 - defining the types of your game is a
406:36 - great way to define the functionality
406:38 - behind it without writing any code it's
406:41 - actually one of the first things that I
406:43 - will do when I'm building a new feature
406:46 - is just map out the different types that
406:48 - I'm going to be dealing with and then
406:50 - I'll figure out what functions do I need
406:52 - what types are going to be accepted as
406:55 - arguments to each of these functions
406:57 - what are the return types of these
406:59 - functions so on and so forth so as you
407:02 - can see
407:03 - typescript is already making us think a
407:07 - lot more clearly about what types of
407:09 - objects we're passing you know objects
407:13 - arrays so on and so forth what types
407:15 - were passing through our code and it
407:18 - makes us a lot more explicit about that
407:20 - and more organized so if we go back to
407:24 - our Excalibur where I was briefly
407:27 - listing out the benefits of typescript
407:30 - um I think one of the other benefits is
407:34 - makes you think more clearly and
407:38 - explicitly about your code
407:41 - so that's what we just experienced we're
407:43 - we're having to explicitly type out our
407:46 - game now at this point we still have
407:48 - squiggly lines and that is because we
407:51 - have not assigned these types to
407:53 - anything here
407:54 - so I will keep both of these open I'm
407:57 - going to just collapse this a little bit
408:01 - and let's just start working from the
408:03 - top of our file
408:04 - so the first thing let's look at is the
408:07 - Constructor with typescript we can add
408:11 - types to things by adding a colon and
408:14 - then giving it a type in in this case
408:17 - the key is our local storage key and
408:20 - that's just a primitive string type so
408:22 - we can just pass that in directly we
408:25 - don't need to do anything over in our
408:26 - types file because you know we don't
408:28 - need to redefine a string now players is
408:31 - going to be an array of players so we'll
408:34 - give it a colon and then we will say
408:36 - player and then array so that is going
408:40 - to be the type we're dealing with now
408:42 - you can see that it figured out that
408:44 - type already even though we didn't
408:46 - import it now this is not always going
408:49 - to be the case it works works okay here
408:52 - but generally what you'd want to do is
408:55 - import that type explicitly so with es6
408:59 - modules what we can do is import a type
409:03 - and then that type will be called player
409:06 - and that type will come from the types
409:09 - file so types.ts is what we're looking
409:13 - for now you're going to see an import
409:15 - path cannot end with a TS extension
409:18 - consider importing types.js instead
409:21 - let's Google this it's probably some
409:24 - configuration property that we missed
409:27 - this person is just saying that we can
409:30 - just remove the extension let's just try
409:33 - that I don't think that worked now it's
409:35 - saying that types.ts is not a module oh
409:39 - I actually know what's going on here I'm
409:42 - sorry I messed this up so these are all
409:46 - just scoped to the types.ts file and
409:50 - it's also not saved so that that would
409:53 - be a big problem that we cannot import
409:56 - that so the first thing we do is save
409:59 - this file that will help us out quite a
410:01 - bit it will not solve this error because
410:04 - we have not exported any of these from
410:06 - the file so to use them throughout our
410:09 - code we need to export them just like we
410:13 - would export you know if we had some
410:16 - variable equals 20 and then we export
410:19 - some variable or
410:22 - export default something like that or we
410:26 - could just export it like this
410:28 - and it would do the same thing and now
410:30 - we can you know import some variable
410:34 - from
410:36 - the types file
410:38 - so that's just a regular JavaScript
410:41 - variable I will get rid of this and
410:44 - let's keep exporting all of these Okay
410:47 - so we've exported all of our types let's
410:49 - save it
410:51 - and now we should not get so much uh
410:54 - grief from the typescript server now
410:57 - there's no red squigglies we've got the
410:59 - player type and you can see we can hover
411:01 - over it and you can see that type which
411:03 - is really nice to just be able to hover
411:05 - over this you can also hover over it
411:08 - down here and now we have a strongly
411:11 - typed Constructor and it knows exactly
411:14 - what's being passed in but at this point
411:16 - we get these problems storage key and
411:20 - players these are instance properties of
411:24 - the store class
411:25 - and since we have not explicitly typed
411:28 - those it's complaining now one way that
411:31 - we could do this is come up here at the
411:34 - top
411:35 - and say that storage
411:37 - key
411:38 - is a string and that will satisfy it
411:41 - because we're passing in this key and
411:44 - then in the Constructor we are assigning
411:46 - this to a string so there's actually a
411:49 - shortcut to doing this a more concise
411:52 - way to do it and instead of calling this
411:55 - key and then this storage key and having
411:58 - that mismatch there we can short circuit
412:02 - this delete that
412:04 - rename this to storage key
412:08 - and so far it's not going to do anything
412:13 - so if we tried to assign this dot
412:15 - storage key equal to storage key it's
412:17 - not going to work
412:18 - we can remove that entirely now this is
412:22 - not going to work but if we say this is
412:24 - a read-only property of the class it
412:28 - will Define it so that we can access it
412:31 - later in the class so if we go to the
412:33 - bottom where we are saving the state you
412:36 - can see we're accessing this dot storage
412:38 - key in these two places and if we hover
412:41 - over that it's going to know that it's a
412:44 - string now if we come to the top and we
412:47 - get rid of that read only
412:50 - and just leave it to storage key
412:52 - it will complain about that because it
412:55 - says it does not exist on the type store
412:57 - so all we need to do is give it a
413:01 - read-only and you can also give it
413:03 - either a public
413:05 - or private just to define whether it's
413:08 - accessible in from outside the class or
413:11 - not we'll call it private because only
413:14 - the internal methods of this class can
413:18 - access this and then same goes with
413:21 - players so once again we can delete all
413:24 - of this
413:26 - and this can just become a private
413:29 - read-only array of players and so right
413:33 - here this is basically the shortcut for
413:36 - passing in these
413:39 - um parameters and then assigning it to
413:42 - the class all in one step and you can
413:44 - see if we look for this dot players it
413:48 - knows that it's of type player all right
413:51 - so we're getting closer we're seeing a
413:53 - lot less little squiggly red lines
413:56 - we just have a few more things to work
413:58 - out in this file
414:01 - um let's go ahead and start here at the
414:05 - bottom this is pretty isolated so this
414:09 - state or function has an implicit any
414:11 - type which basically means typescript is
414:14 - yelling at us because we haven't defined
414:17 - any type one thing that we could do
414:21 - if we really wanted to as we are
414:24 - refactoring this and migrating our code
414:27 - base if we change strict to false
414:31 - and save that
414:33 - and then restart the TS server you'll
414:36 - see that this no longer complains about
414:38 - this at all we can Define this as an any
414:42 - type and typescript's not going to be
414:44 - mad about it this of course comes with
414:47 - the detriment that now you don't have
414:50 - any red squiggly lines to tell you where
414:52 - you've messed up that is why most people
414:55 - would encourage you to put on strict
414:58 - mode
414:59 - restart the TS server here
415:03 - but I just wanted to show you that just
415:05 - so you can see now let's start at the
415:07 - bottom Here Again State or function this
415:11 - is a great use case for typescript this
415:13 - is where your life becomes a lot easier
415:16 - and that is because in this case we are
415:19 - allowing
415:21 - um
415:22 - someone that is using this function to
415:24 - pass either an object that represents
415:27 - state or a function that we will pass
415:31 - the previous state to and then it
415:33 - returns a new state so two different
415:36 - types of parameters that you can expect
415:39 - here and so we can type this a lot
415:43 - better now that we know or now that
415:45 - we're using typescript so saving the
415:48 - state we are going to be passing game
415:51 - state so that is the type that we're
415:54 - looking to pass in there so we'll say
415:55 - game state
415:57 - and it's going to complain about this
415:58 - because it cannot find that name
416:01 - let's go to the top
416:02 - and let's import game state from our
416:06 - types so we're importing that type
416:09 - now it's not complaining anymore
416:12 - but it complains right here because it
416:15 - thinks this function thinks that state
416:18 - or function is just an object that is
416:22 - represented by game State and right here
416:24 - we are trying to call it as a function
416:27 - so the problem here is that we've only
416:30 - defined one of the possible types so
416:33 - here we can define a typescript union
416:36 - let's go to the documentation and
416:39 - briefly look at this
416:41 - so let me make a new tab and typescript
416:45 - docs let's start over
416:49 - and let's go to either the reference or
416:51 - the handbook I'm a little surprised that
416:54 - we don't see unions
416:56 - um starting out but let's go to the
416:58 - basics
417:00 - that's not what we're looking for
417:04 - let's just search the docs so Union
417:08 - typescript unions uh looks like
417:11 - typescript for functional programmers is
417:13 - where we found that one
417:16 - um but anyways in typescript Union types
417:18 - are untagged in other words they're not
417:20 - discriminated unions like data and
417:22 - Haskell I I don't use Haskell so I don't
417:24 - know what that means
417:26 - um but what this is trying to basically
417:28 - say is that if you put this little pipe
417:30 - character that means that the type can
417:33 - be you know either this or that so it's
417:37 - kind of like an or
417:39 - um an or operator but for types so you
417:43 - can read more about that but let me just
417:44 - show you what this looks like it's going
417:47 - to be game state or and then this is
417:50 - where we Define our function that we're
417:52 - looking for so the function is going to
417:56 - be a separate type and I'm going to
417:57 - actually add this to
418:00 - um let's add it to the top of the file
418:03 - so since we're in typescript we can just
418:05 - add types within our files so we'll say
418:10 - Save State
418:12 - CB for callback
418:14 - and to define a function there's a
418:17 - couple ways you can do it but one quick
418:19 - way is to basically just give it an
418:22 - arrow function and tell it what it needs
418:25 - to return so in this case we want to
418:28 - return the game State and we're going to
418:31 - pass the previous state which is going
418:34 - to be a game state so basically I talked
418:37 - about this in the previous video when we
418:39 - did this build but it's always nice in
418:42 - your Save State function to be able to
418:44 - access the previous state so that you
418:46 - can derive that next state so that's why
418:50 - we're passing this but this is the type
418:52 - that we can Define and if we took this
418:55 - key right here the type
418:57 - and we passed it right here Save State
419:00 - callback you'll see that there's no more
419:02 - complaints from the typescript server
419:04 - compiler because state or function
419:07 - matches the type that we gave in
419:10 - previous state
419:12 - um is not typed yet but it satisfies
419:15 - that constraint so I can actually take
419:18 - this to be a little more concise and
419:21 - copy that type itself
419:25 - and just pass it in right here and then
419:28 - you need to put some parentheses around
419:30 - it
419:32 - and that should work just fine now we
419:35 - can get rid of this
419:37 - I just wanted to break it out so that it
419:39 - was more clear now everything's working
419:41 - here but if we hover over previous state
419:44 - that's going to have an any type which
419:46 - no one's complaining about this here
419:49 - with typescript but it would be nice to
419:52 - know what that is
419:53 - one way that we can do this and this is
419:55 - a little bit tricky with typescript it's
419:58 - um not super obvious but when we do
420:01 - local storage dot get item and set item
420:05 - it's not going to return a type so get
420:09 - item is going to by default return in
420:12 - any type
420:13 - um or actually sorry a string or null
420:16 - and the Json parse method
420:20 - this is where it's going to return in
420:22 - any type so what we want to do if we
420:25 - want to actually give this a strong
420:27 - typing is we will cast the type
420:30 - so we can say
420:32 - json.parse item and then this is going
420:34 - to be as game
420:37 - state
420:39 - so now get state is going to have a
420:43 - return type of game State and you can
420:46 - actually explicitly Define that
420:48 - on the function itself and if we remove
420:51 - this now
420:53 - um and we say as string or something
420:56 - like that it's going to yell at us
420:58 - because we're not returning the correct
421:01 - type that this function was declared as
421:03 - now that's for a whole nother day we're
421:06 - not going to be typing all of our
421:08 - functions
421:09 - explicitly with return types some
421:12 - programmers really like that to be
421:14 - explicit about typing all the functions
421:16 - this is just a refactor and I just want
421:19 - to get this working so for the moment
421:22 - I'm not going to worry about that
421:25 - but just know that you can Define the
421:27 - return Types on your functions
421:30 - so now that we have done this we can
421:32 - come back here in previous state will be
421:35 - a type of game State and it still works
421:39 - to pass it into state or function the
421:41 - game State can go into state or function
421:43 - because that is what we typed it as
421:47 - all right
421:48 - let's keep scrolling up I think we have
421:51 - one or two more errors
421:53 - the square ID this should be very easy
421:56 - let's just give this a number that's the
421:59 - expected type now if we hover over
422:01 - current game moves we would expect that
422:04 - to have the
422:07 - um move type but it does not it has an
422:10 - any type and I believe we can fix that
422:13 - where would we fix that one thing we can
422:16 - do is give this initial state
422:19 - a game State type so now anywhere we
422:22 - pass that it's going to recognize it so
422:25 - right here the initial state is of type
422:28 - game state so if we look here the
422:31 - structured clone method
422:33 - is actually similar to local storage
422:36 - where it's a a browser API and by
422:39 - default it's not going to type anything
422:42 - so in this case we're going to cast this
422:45 - to a game State object because we know
422:48 - that this state is going to be
422:50 - represented there
422:52 - so now where we're pushing to all games
422:55 - it's going to recognize that current
422:57 - round games is of type game so you can
423:00 - start to see how this comes together and
423:01 - how we are starting to get stronger
423:04 - types across our code okay so I think
423:07 - the only thing we have left here is that
423:10 - red squiggly
423:12 - not saying that the red squiggles are
423:15 - your map necessarily you obviously need
423:18 - to check other things but just given the
423:21 - fact that we know that this code worked
423:23 - before and we have strict mode on we can
423:27 - really use those as a guide for our
423:29 - refactor to to find areas that we have
423:32 - not strongly typed things
423:34 - so let's dig in into this error it says
423:37 - property includes does not exist on type
423:40 - number array do you need to change your
423:42 - target Library try changing the lib
423:45 - compiler option
423:46 - to es2016 or later all right so it's
423:50 - going to say 2016 or later
423:53 - so this is es7 I believe
423:56 - so let's target es2016
424:00 - and then restart the TS server
424:04 - and now you can see that will go away
424:06 - because that built-in method on an array
424:10 - is available in the ecmascript 2016 spec
424:15 - so we are let me be clear about this we
424:19 - are using es6 modules which tells us how
424:24 - we can export and import things from
424:27 - modules and then we're compiling our
424:30 - typescript code to this standard of
424:34 - JavaScript
424:36 - so that standard of JavaScript has this
424:39 - method
424:41 - and at this point we have completed
424:45 - this file
424:47 - we've imported our types that we need
424:49 - and there are no red squiggly lines so
424:52 - that's a good indication that we're
424:54 - pretty much done with this file
424:58 - let's save that and go to the next one
425:01 - so we are done with the store
425:04 - let's go to The View
425:06 - this one will be slightly more difficult
425:08 - because we're going to have to deal with
425:11 - um
425:11 - Dom element types which are a little bit
425:14 - more confusing
425:16 - so we've got a bunch of red squiggly
425:18 - lines here but they're all coming from
425:19 - this query selector helper method that
425:23 - we defined
425:25 - let's go straight down to that
425:29 - and let's start typing it so the
425:32 - selector itself is just going to be a
425:34 - string
425:35 - that's like the class or you know
425:37 - selector that we're passing into the
425:39 - query selector method and then when
425:42 - we're typing things with typescript
425:44 - something useful you can do is just
425:46 - hover over these methods
425:50 - um it's not going to work because we're
425:51 - using it on the parent but if we go to
425:53 - the document there's some built-in types
425:56 - for the Dom
425:58 - methods and Global types so document is
426:03 - of type document and query selector this
426:07 - will give you a stub giving you the
426:10 - types that are available here
426:14 - you can see the selectors are string
426:16 - that's how I knew to give that a string
426:20 - and then element is what's going to be
426:24 - returned from it so we're going to pass
426:27 - a parent which is of type element
426:31 - and now we should see that's of element
426:34 - and then query selector is now available
426:36 - on that
426:38 - and we're passing in a string so let's
426:40 - let's retype this to a number real quick
426:43 - and you'll see that that's an invalid
426:46 - thing to pass to a query selector so
426:50 - that's how we know that string is going
426:52 - to be the correct thing and then
426:54 - furthermore we can go to query selector
426:56 - all and just give that a string type as
426:59 - well
426:59 - so these two methods are now strongly
427:02 - typed and if we come to the top
427:04 - it's still going to be yelling at us
427:06 - just a little bit
427:09 - it's saying it expected two arguments
427:11 - but it got one so what we have to do is
427:15 - come down to our methods and in this
427:19 - case the parent element is totally
427:22 - optional
427:23 - so what we can do is pass a question
427:26 - mark right after that and that will now
427:29 - make this an element or undefined and
427:32 - that's okay because we are first
427:34 - checking with our ternary operator
427:36 - whether that parent
427:38 - argument is has a value and if it does
427:42 - have a value we're going to use it
427:44 - otherwise we're going to fall back to
427:47 - the document so if we were to refactor
427:51 - this a little bit
427:53 - and intentionally break it if we just
427:56 - tried to access the parent element and
427:59 - grab a query selector off of it and then
428:02 - pass the selector it's going to work
428:04 - because Visual Studio code already knew
428:07 - what we were trying to do but if we
428:09 - remove that right there it's going to
428:12 - yell at us because it says parent is
428:14 - possibly undefined and you can't access
428:17 - a method like this on an undefined
428:19 - parameter now you'll see that vs code
428:23 - added this question mark here which is
428:26 - the optional chaining so let's type that
428:30 - in optional chaining
428:33 - this is actually not a typescript
428:35 - concept this is an operator in newer
428:39 - versions of JavaScript which we're using
428:41 - that accesses an object's property or
428:44 - calls a function
428:46 - and if it cannot find what it's looking
428:49 - for if the if the type is undefined or
428:52 - null as shown here it will short circuit
428:56 - and evaluate to undefined so the reason
428:59 - that that works to do this is because
429:02 - we're first this operator right here is
429:05 - just checking hey is the parent element
429:07 - defined if it is let me call this method
429:10 - otherwise let's turn element to
429:12 - undefined and then as you can see here
429:15 - we're checking if element is defined
429:18 - throwing an error and if it's not or if
429:20 - it is defined we're returning it so that
429:23 - technically does work but in this case
429:26 - we want to use this logic just to be
429:29 - explicit and say if it exists grab from
429:32 - the parent otherwise fall back back to
429:34 - the document and that gives us assurance
429:36 - that we're going to find that element
429:38 - so we've fixed all these red squiggly
429:41 - lines but now we have a problem here and
429:43 - it says property menu does not exist on
429:45 - type
429:47 - object and you can see here we've
429:50 - defined this as an object
429:52 - what we really want to do
429:54 - is retype this
429:57 - and we're going to use a built-in
430:00 - typescript utility let me make sure I'm
430:04 - doing this the same as my example or my
430:07 - final
430:09 - so if we go to the documentation for
430:11 - typescript
430:12 - let's go back and
430:15 - find ourselves the utility types so in
430:19 - the reference there's this utility types
430:21 - and if you come over here to record
430:25 - this constructs an object type whose
430:27 - property keys are keys right here in
430:31 - whose property values are type right
430:34 - here so this is actually leveraging
430:36 - something called generics in typescript
430:39 - which is kind of beyond the scope of
430:41 - this video you can look it up and and
430:44 - read about it but keys and type are
430:47 - going to be generics and record is going
430:49 - to be the type that allows us to define
430:52 - something so in other words this is just
430:55 - basically defining a basic object
430:58 - so right here this is where we will type
431:00 - this so remember dollar sign is just a
431:04 - property an instance property of the
431:06 - class you could have named this pretty
431:08 - much anything
431:10 - um
431:11 - so you could have named this element
431:14 - object store or something like that but
431:18 - we're just doing this for a shortcut and
431:20 - if we want to type it we can type record
431:23 - and then this is where we pass our
431:25 - generic values so we want to pass a
431:28 - string because we're defining arbitrary
431:32 - strings
431:33 - as the properties of this object and
431:38 - then the value is all going to be the
431:40 - same it's going to be a an element type
431:43 - so if we pass an element now things are
431:46 - satisfied satisfied here because we are
431:49 - passing an arbitrary string property
431:52 - name right here and then the value
431:56 - is going to return an element which as
431:59 - you can see down here
432:01 - we are returning a type of element so
432:05 - that is satisfied so all these are happy
432:07 - now
432:08 - but we need to type the double dollar
432:11 - sign which is the node list now if you
432:15 - come down here to query selector all
432:17 - let's just take a peek at what this
432:20 - element list is it is typed as a node
432:23 - list of elements so that is the native
432:27 - typing that the query selector all
432:30 - built-in method is returning and you can
432:33 - see that's defined right here so let's
432:37 - just copy that because we'll need it
432:40 - come back to the top and now let's
432:43 - define this as a record where we can
432:46 - give it an arbitrary string
432:48 - so squares is an arbitrary string
432:52 - property name and then the type that
432:55 - we're going to give it we'll just paste
432:56 - that in so it's a node list of elements
432:59 - and we'll initialize that to an empty
433:02 - object and now the element list is happy
433:05 - because query selector all returns that
433:08 - node list of in squares is that
433:10 - arbitrary property value so it satisfies
433:13 - this type so that's just a use of a
433:17 - built-in utility type in typescript
433:20 - using some generics I just want to show
433:23 - you another way that you could have done
433:25 - this so if you wanted to not use a
433:28 - utility type what you could do is Define
433:32 - a custom type so let's say
433:37 - um element
433:38 - object
433:40 - uh
433:41 - dictionary that's just our type name
433:45 - that we're giving it and here what we
433:47 - can do is pass in a key
433:51 - of string
433:53 - and this can be an element
433:56 - value and then we'll pass this element
433:59 - object dictionary
434:01 - I'm sorry it should not be of it should
434:04 - be in
434:06 - string so what this is basically saying
434:09 - is I want an object that can have an
434:12 - arbitrary number of properties in the
434:16 - key of that property so menu menu button
434:19 - menu items is a string and then the
434:24 - value of that property is an element as
434:27 - assigned here so this type right here is
434:31 - really the equivalent to what we did
434:33 - earlier where we said
434:35 - record string element and then closed it
434:40 - off and if you really really wanted to
434:42 - get fancy
434:43 - you could do this with generics so sorry
434:46 - I'm going on a little bit of a tangent
434:48 - here but this is just to give you an
434:50 - idea of the power of typescript so we
434:53 - could say custom record utility
434:57 - so what we're trying to produce here is
435:00 - the built-in utility record and just
435:02 - recreating that from scratch
435:04 - what we can do is pass in a generic so a
435:08 - key and a value and usually with
435:11 - generics you're going to put a t in
435:14 - front of it
435:15 - that's just kind of a convention that I
435:17 - use to kind of signify or you know
435:20 - Express this is a generic and then we'll
435:22 - use the same syntax so the key is in
435:27 - t
435:29 - key
435:31 - and then the value is T value now we
435:34 - know in JavaScript the only valid type
435:36 - of property you can give an object is
435:39 - really a string you can't just Define an
435:42 - object
435:44 - like this and start adding numbers to it
435:47 - like this is
435:49 - I guess this might be valid is this
435:51 - valid JavaScript
435:53 - oh that's funny I I guess I don't know I
435:56 - don't think this is valid but let's
435:58 - let's just try it out because now I'm
436:00 - curious
436:02 - I wouldn't be surprised
436:05 - so we'll say this is a test
436:10 - and it looks like it is that is
436:12 - interesting I didn't know that you could
436:14 - do that I don't know why you would ever
436:16 - do this other than maybe a map which is
436:20 - kind of similar to what that does but
436:22 - anyways
436:24 - um I guess I'll learn something new
436:25 - today while making a tutorial about
436:28 - coding
436:29 - that's probably not the best thing but
436:31 - anyways let's just be honest so anyways
436:34 - we want this to be a string so let's
436:36 - just say it extends a string type and
436:40 - now that's going to be fine and then we
436:43 - can just replace this record with custom
436:46 - record utility and it's going to work
436:48 - fine everything's going to be happy
436:50 - because we've basically just implemented
436:52 - that built-in utility type that
436:55 - typescript provides so just a
436:58 - interesting tidbit that you can kind of
437:01 - roll over a little bit so let's get rid
437:04 - of that because that is unnecessarily
437:06 - complex
437:08 - you can see at the top here I had
437:10 - imported the store just for JS doc
437:14 - typings when we had of the vanilla
437:17 - JavaScript project so now that we're
437:19 - using typescript we really don't need to
437:21 - do that
437:22 - so we'll get rid of that
437:24 - so moving down
437:26 - we can now implement the rest of these
437:28 - okay so we'll move on to the render
437:30 - method
437:32 - um
437:33 - the render method takes
437:35 - two State objects and the reason I
437:38 - originally passed this as two separate
437:41 - objects is because we were not working
437:44 - in typescript
437:45 - now that we are working in typescript I
437:48 - probably would just pass the entire
437:50 - State object as one parameter but we'll
437:53 - we'll stay consistent here so if we look
437:56 - at our types that we've defined
437:58 - we have a game type so that one's pretty
438:01 - easy we'll just type that as a game
438:05 - and we need to import that but instead
438:07 - of going to the top of the file
438:10 - in doing it there I'll show you a little
438:13 - trick so if you hold down on a Mac or on
438:16 - a command or on Windows control so
438:20 - command and then period
438:22 - in vs code will give you a suggestion
438:26 - and usually it can find out where it's
438:29 - looking
438:30 - now it's looking for types.js
438:34 - um
438:36 - not types.ts I'm not quite sure what's
438:39 - going on there
438:42 - um why it's saying that
438:44 - I don't even know if there's a there
438:46 - isn't a types JS I'm not sure what it
438:48 - did there but anyways we'll add the type
438:52 - uh import just so it's not importing
438:54 - anything but typescript types
438:58 - and then we can remove that extension
439:00 - and that should work
439:02 - so now that's working let's see if it
439:05 - works on this one so we need to do stats
439:09 - where we I don't know if we have typed
439:12 - that yet okay so I've actually
439:16 - um in my final copy of this that you'll
439:19 - see on GitHub I've used a slightly
439:21 - different strategy so we do not have a
439:25 - type already defined for stats if we go
439:28 - to store.ts
439:31 - the object we're looking for is this one
439:33 - and specifically we're looking for this
439:37 - return type which has a player with
439:39 - stats which is an array of players
439:42 - with this wins property added and then
439:46 - we have ties which is just a number now
439:49 - if we hover over stats it will give us
439:52 - this inferred type which is correct
439:56 - and furthermore the store class is in
440:00 - has an inferred type that has all of the
440:03 - methods on it so something that we can
440:06 - do is derive types from other types
440:10 - and in this case since we don't have a
440:14 - stats type what we can do is go back to
440:17 - the view and we can import
440:22 - type store from store
440:26 - and that will give us the store class
440:29 - that we had defined
440:31 - and then here what we can do is say
440:34 - store and then we can actually access
440:37 - properties on that so you can scroll
440:40 - down just like we're accessing you know
440:43 - properties of an array we can scroll
440:45 - down and see all the methods and
440:47 - properties that we can grab from the
440:50 - store and stats is one of those so now
440:54 - stats is defined because we derived it
440:57 - from the store
440:59 - now someone argued that this is maybe
441:02 - not the best way to do this and I would
441:06 - probably recommend
441:08 - um having stronger types and actually
441:11 - defining a stats type but for now this
441:15 - does work and it's a easy way to get
441:18 - that type without having to define it
441:20 - we can also grab the game uh getter from
441:24 - the store which will properly type our
441:27 - game and that is going to give us the
441:31 - correct types for the render method and
441:34 - again I'm using this to demonstrate
441:36 - something in reality you'd probably want
441:40 - to Define these as actual types over
441:42 - here and we do have that for game so we
441:47 - could use game ready oops
441:50 - scrolling around we could just use game
441:52 - right there but actually it will yell at
441:55 - us because this game is slightly
441:59 - different this is derived state so this
442:03 - game is this the state that we're
442:05 - storing in local storage
442:08 - and then the game that we're trying to
442:10 - represent in this method is derive state
442:14 - so in our store remember we have this
442:17 - method called game and we are reading
442:21 - the state the raw State and we are
442:24 - deriving some useful properties that
442:26 - we're returning for our game to use
442:29 - right here at the bottom so obviously
442:31 - current player is not saved in local
442:34 - storage and not represented in this type
442:37 - so I guess that's another reason why
442:40 - just using the store
442:42 - game is a good way to do it but yeah
442:45 - basically I would say that you'd want to
442:48 - type this function now coming down to
442:51 - the the bind events all these methods
442:55 - the Handler is of type any right now but
442:59 - basically what we're passing to the
443:01 - Handler is the Callback of add event
443:05 - listener so if you look at the stub for
443:09 - this add event listener you'll see it's
443:12 - got some overloads which is kind of an
443:14 - advanced typescript concept
443:17 - but one thing you can do to kind of zoom
443:21 - in on some types
443:22 - let's command click on add event
443:25 - listener and this will take us to
443:29 - lib.dom.d.ts these are the typings for
443:32 - the Dom that are basically provided
443:35 - already
443:38 - um to us and if we open up this in the
443:41 - file pane
443:42 - um I don't even think you're going to
443:43 - see it because
443:45 - this is kind of I believe this is built
443:47 - into vs code just to give you these
443:49 - typings
443:51 - um I could be wrong on that
443:52 - but anyways at event listener it gives
443:55 - you a couple types that you can deal
443:58 - with here
443:59 - and then you can hit command click on
444:01 - this
444:02 - and then you just kind of go until you
444:05 - find the type that you're looking for so
444:07 - event listener
444:09 - and now you can see event listener is
444:12 - actually a type that we can use
444:15 - so we don't even need to define it
444:18 - we can just use
444:20 - event listener which you can see is
444:23 - populated
444:25 - and pass that right there
444:28 - so event listener
444:32 - it's always best to use built-in types
444:35 - if you can if they're not defined then
444:38 - you obviously have to type them yourself
444:41 - but with something as common as an event
444:44 - listener Handler like this you can
444:47 - always expect that there's going to be a
444:49 - type already defined for you that you
444:51 - can use
444:54 - so those are done
444:56 - update scoreboard I believe these are
444:59 - all just numbers
445:01 - say number
445:03 - number
445:05 - and number
445:08 - here it's going to tell us something
445:10 - inner text does not exist on type
445:13 - element
445:15 - I might have used this wrong
445:18 - in my original actually I think this
445:21 - should be text content
445:24 - yeah so that that's actually the right
445:26 - thing to use I don't know why I was
445:28 - using inner text it seemed to work
445:30 - though
445:34 - so let's update all those
445:36 - open modal message is just going to be a
445:40 - string because we're passing a string of
445:42 - who won
445:43 - and then we have the same error here
445:45 - that needs to be changed to text content
445:50 - coming down to initialize moves this one
445:52 - is somewhat simple we've already defined
445:56 - the move type over here so it's going to
445:59 - be a move but right now it's going to
446:01 - complain because it cannot find it so
446:03 - hit command period and we'll update the
446:07 - import and you can see that that
446:09 - actually added the move right there and
446:11 - we're not using game anymore so we can
446:13 - get rid of that
446:15 - but now it's going to complain right
446:17 - here and that's because I've
446:18 - intentionally messed this type up
446:21 - we want an array of moves not just a
446:23 - move so to specify that we can either
446:26 - say array which is a helper utility of
446:30 - typescript
446:31 - or you can just do it shorthand and pass
446:35 - the brackets at the end of it which
446:36 - specifies that moves is now a moves
446:39 - array so now this is valid and you can
446:43 - see everything's working
446:44 - just to start demonstrating the value of
446:47 - typescript let's say that we removed
446:49 - this plus sign so in the original build
446:51 - I remembered to do this but it's pretty
446:54 - easy to forget to cast the ID that you
446:57 - extract from the the element Target to a
447:01 - number so what if I got rid of that
447:03 - now it's going to yell at me because
447:06 - it's an unintentional
447:09 - because types number and string have no
447:12 - overlap and what that's saying is we are
447:14 - doing a triple equals equality which
447:17 - types or which checks the type and the
447:21 - value
447:22 - and we're looking at a move which has a
447:26 - square ID of number and then the default
447:29 - event Target ID is going to be a string
447:33 - so element.id is going to type to a
447:35 - string so these will never evaluate to
447:39 - true
447:40 - now we can of course remove the triple
447:42 - equals and that would technically work
447:45 - because things would be cast but you
447:47 - always want to use triple equals if you
447:49 - can so here that's just a very explicit
447:53 - example of where typescript comes in
447:56 - handy is it reminds you of these little
447:58 - details that you might have kind of
448:00 - glossed over before all right so let's
448:03 - keep going you can see that it's
448:05 - complaining here about icon possibly
448:08 - being null
448:09 - and this is just a case where
448:13 - we could do better so remember earlier
448:18 - in the prior video actually not this
448:20 - video we Define query selector and this
448:23 - is like a safe query selector where we
448:26 - are checking uh whether the element
448:28 - exists and if it doesn't we're throwing
448:30 - in error which is kind of the behavior
448:33 - that we want we don't we don't want to
448:35 - proceed if we can't find the element so
448:37 - one solution to this problem is to put a
448:40 - question mark there because that will be
448:43 - the
448:45 - the optional chaining that we talked
448:47 - about earlier where we're saying hey
448:49 - let's check the icon and if it's an
448:52 - element grab the class list and add this
448:55 - to the class list if it's not an element
448:57 - and it's null let's just uh evaluate
449:00 - this to undefined and not throw any
449:03 - errors now that works you could add that
449:06 - there and it solves your problems but
449:09 - this is kind of an anti-pattern a little
449:11 - bit because you know you throw this in
449:14 - here and all of a sudden you know your
449:16 - app is not grabbing this correctly and
449:18 - you're clicking your toggle menu and
449:20 - it's not working well how do you find
449:22 - that error it's better to be explicit
449:25 - about this kind of thing so let's leave
449:27 - that and take some Clues from typescript
449:29 - and refactor this to instead
449:34 - um let's comment this out and say icon
449:37 - is equal to this
449:39 - and we'll use our safe query selector
449:42 - method in this case we're going to look
449:44 - for an I tag and the parent is going to
449:48 - be this dot dollar sign dot menu button
449:51 - and that is basically how we can safely
449:55 - select that and now icon is definitely
449:57 - an element because we're going to throw
449:59 - an error if it's not so these calls down
450:02 - here are now valid this is actually a
450:06 - concept called type narrowing
450:09 - um that you can read more about in the
450:11 - typescript documentation
450:13 - so I wonder if this is actually
450:17 - somewhere I can show you
450:21 - okay yeah so narrowing
450:24 - and this whole page kind of describes
450:27 - that process of of narrowing the types
450:29 - that I just explained here same thing
450:32 - goes right here we can just copy this
450:36 - down and replace this
450:40 - let's get rid of this and these two
450:43 - functions are good
450:44 - now a couple more the square element
450:48 - you can see that we are
450:51 - replacing the children on it so we know
450:53 - that that should be an element
450:56 - and then the player
450:58 - is going to be a player and command
451:00 - period to update that import at the top
451:05 - same thing here this is going to be a
451:07 - player
451:10 - and then finally we get this fun
451:12 - delegate method that we really it's
451:15 - tough to understand in the first place
451:16 - and now we have to type it
451:18 - but let's just walk you know
451:21 - parameter by parameter and get this done
451:23 - so element
451:25 - pretty self-explanatory this is going to
451:28 - be an element
451:30 - the selector is going to be a string
451:33 - the event key
451:35 - is going to be a string
451:38 - and then the Handler is going to be an
451:40 - event
451:42 - uh
451:43 - what do we call this
451:45 - we have an example of this right up here
451:48 - event listener
451:50 - now we've got a little bit of a tricky
451:52 - situation so you can see right here
451:56 - event Target is possibly null so okay
451:58 - let's put that question mark the
452:00 - optional chaining but we still have this
452:02 - problem property matches does not exist
452:05 - on type event Target so we're going to
452:07 - use this narrowing concept again to
452:10 - narrow these types and get rid of these
452:12 - errors
452:14 - so this is where typescript is actually
452:16 - helping us in a way it's kind of making
452:19 - us more explicitly check things that we
452:21 - otherwise probably wouldn't
452:23 - so the first thing that I want to do
452:24 - let's get rid of this question mark or
452:27 - no we'll leave it there for now
452:29 - and we'll say
452:30 - if
452:32 - the event dot Target
452:35 - is an instance of element so this is a
452:40 - way that we can check if the target is
452:42 - an element
452:44 - so if that's an instance of the element
452:47 - and we actually want to negate this so
452:50 - if it's not an instance of an element
452:54 - then we want to throw a new error
452:57 - and we say event Target not found
453:02 - so this is just a guard that basically
453:05 - says Hey the purpose of the delegate
453:07 - method is
453:10 - um to delegate an event Target and find
453:14 - something within it and if we can't find
453:17 - that in the first place and it's not an
453:18 - element then the rest of this method is
453:20 - useless like we can't really proceed
453:22 - safely so we might as well throw an
453:25 - error exit early and then the developer
453:28 - is you know responsible for fixing that
453:31 - so that solves one of our problems the
453:34 - matches keyword or function Now does not
453:37 - complain about anything
453:39 - now in the Handler it says argument of
453:42 - type element is not assignable to
453:43 - parameter of type event
453:46 - and that is actually because I typed
453:48 - this incorrectly
453:51 - in this Handler we're actually passing
453:55 - the element itself so I have typed this
453:58 - as if we were passing the event but
454:01 - really what we're passing is the element
454:03 - so I need to type it accordingly
454:07 - so we're just passing a function that is
454:10 - called with the element as the first
454:13 - argument and it doesn't return anything
454:16 - so now there's nothing wrong here and
454:19 - we're okay but let's remove this
454:22 - question mark
454:23 - and see what happens so
454:26 - looks like we're okay
454:28 - all right so we're we're good here this
454:30 - works it's typed okay
454:34 - I think this whole file is now strongly
454:37 - typed and we're ready to move on to the
454:40 - final one
454:42 - app.ts and we're going to tie it all
454:44 - together and get it working
454:46 - now just as a reminder this is this app
454:49 - really we haven't done anything
454:51 - structurally to it other than a few
454:53 - things so it should still be working and
454:56 - if we open things up
454:58 - and ran yarn TSC
455:01 - let's look at the disk directory it
455:03 - outputs everything
455:05 - and then if we go to our page
455:07 - let's inspect the page and go to the end
455:10 - of the body
455:12 - and you can see the script is looking in
455:14 - dist Dash app.js
455:17 - and if we click things we can play the
455:20 - game still
455:21 - so there's really nothing that we've
455:23 - changed and it's been working this whole
455:25 - time we're just trying to make our
455:26 - project more maintainable with
455:28 - typescript so that if we want to extend
455:30 - it in the future it's easier to do so
455:32 - want to debug it easier to debug all
455:35 - that kind of stuff
455:37 - okay at this point by fixing those other
455:40 - files we basically fixed a lot of the
455:43 - typings here in in these files now it's
455:46 - always nice to just be pretty explicit
455:49 - about your typings some would argue that
455:52 - you want to infer types as much as
455:54 - possible but
455:56 - let's just go ahead and add a player
455:58 - type to this array
456:01 - and once again it's trying to go to
456:02 - typestop JS for some reason
456:07 - so we've got type player and this is a
456:11 - array of players
456:15 - now remember the store we've typed that
456:18 - so you can hover over it and you can see
456:21 - the storage key should be a string and
456:23 - the players should be a player array
456:25 - so this is a player array and this is a
456:28 - string let's say that we passed in a
456:30 - number it's not going to be happy with
456:33 - that it'll say numbers not assignable to
456:36 - type string so that's kind of the
456:38 - assurance that we're getting here
456:41 - now coming down here let's see what it
456:43 - says property ID does not exist on type
456:47 - event
456:48 - so this is actually I think a mistyping
456:51 - that we had from the bind Player move
456:54 - event
456:55 - let's go back to the view
456:57 - and you can see this is where we're
456:59 - using our delegate
457:01 - and then our Handler we've typed that as
457:04 - an event listener and if you remember
457:06 - down here I made that same mistake
457:10 - um where I was incorrectly typing the
457:13 - Handler so let's copy this handle or
457:16 - type
457:16 - and instead of event listener for the
457:19 - Handler it's just going to pass a
457:22 - function with the element
457:24 - that it's selected
457:26 - so now we come back and these type
457:28 - errors are fixed so this you know fixing
457:31 - type error is really about just reading
457:33 - the error message and being able to you
457:36 - know respond to it and know what it's
457:37 - trying to say which comes with time it's
457:40 - not easy to start and figure that out
457:43 - when you're first starting with
457:44 - typescript
457:45 - all right so at this point everything is
457:48 - strongly typed and our app is working so
457:52 - our last step here is to compile things
457:54 - let's make sure that we're not getting
457:56 - any errors
457:58 - so yarn TSC
458:01 - and there's no errors we're done in a
458:04 - second
458:05 - and the disk directory now has our
458:08 - compiled code
458:10 - and as you'll see as you read through
458:12 - this none of it's really minified or
458:15 - anything like that
458:17 - um and our Target was es2016 so you'll
458:21 - actually see all of these
458:24 - methods that we are using
458:27 - let's see if we can find the includes
458:29 - method
458:31 - here's some interesting stuff this is uh
458:34 - typescript dealing with like the class
458:37 - syntax and private fields and properties
458:40 - it has like a helper method to deal with
458:43 - that
458:44 - so
458:46 - that is kind of interesting
458:49 - so let me just show you if we
458:52 - downgraded this to like ES3 a prior spec
458:57 - of JavaScript as our Target
458:59 - I just want to show you how that plays
459:01 - out with the output
459:04 - it'll be tough to see so let's open up
459:07 - view.js and just kind of watch the code
459:10 - as we recompile this to a different
459:13 - Target
459:14 - you can see that all of this stuff
459:16 - changed and if we go back to es 2016
459:23 - and then recompile and you can also see
459:26 - we get all these errors because we're
459:28 - using things we're using language
459:30 - features that were not available back in
459:33 - that ES3 spec so the compiler is going
459:36 - to give errors so now let's go back to
459:38 - our valid syntax and you'll see like
459:41 - this will update so
459:45 - you can see the modules that we're using
459:47 - but anyways that's just a kind of fun
459:51 - little tidbit to kind of explain that TS
459:54 - config a little bit more
459:55 - but I want to wrap this up by just
459:59 - walking through
460:01 - why this was so important to refactor to
460:04 - typescripts and why someone would go to
460:05 - the effort to do this
460:07 - the value in typescript does not really
460:11 - come as you are you know retyping things
460:14 - it comes when you're trying to refactor
460:16 - things or add new features
460:18 - so if we went to the JS folder and we
460:21 - went to
460:23 - let's say
460:25 - the store
460:27 - and let's say that we came down and we
460:30 - wanted to I don't know change the type
460:32 - that stats uh returned or something like
460:36 - that
460:36 - well if we went through here and let's
460:40 - say
460:42 - we updated this property wins to like
460:45 - win count
460:50 - okay so it's not going to complain at
460:52 - all right here
460:54 - but what you'll see is that if we try to
460:56 - recompile this
460:58 - so yarn TSC
461:00 - it's going to give us errors that were
461:03 - no longer there and the reason being is
461:05 - in our view on line 59 so let's open The
461:10 - View
461:11 - and go to line 59
461:14 - you'll see that we have this underline
461:15 - because we are referencing the output of
461:19 - this stats getter
461:21 - from another place in the code base and
461:24 - we are using the original property so we
461:27 - would need to update that to win count
461:29 - before it's going to stop complaining
461:31 - and what typescript has done for us
461:34 - there is you know as the developer
461:37 - you're going through and you're changing
461:39 - a method and this method is dependent on
461:42 - by other methods in other parts of the
461:45 - code base and so typescript is smart
461:47 - enough to know like hey if you change
461:49 - this and it does not match up with the
461:53 - rest of the code base we're going to not
461:54 - compile this code base because it's just
461:57 - not going to work so otherwise if you
462:01 - had a vanilla JavaScript code base and
462:04 - you try to do something like this
462:05 - nothing would happen you you would just
462:07 - think oh I I'm okay I changed that
462:10 - that's fine and then you would find out
462:12 - that you had errors in your project once
462:15 - you started playing the game
462:17 - and it was not working as intended so
462:20 - that's kind of the benefit of typescript
462:22 - is you get that proactive checking of
462:25 - your code and you find out about errors
462:27 - a lot sooner so rather than pushing a
462:30 - bunch of code up to GitHub and deploying
462:32 - it and finding out that something's
462:34 - broken in your app you just don't it it
462:37 - just does not get deployed correctly and
462:40 - it doesn't build correctly if it's not
462:42 - correct code so that's kind of the the
462:44 - appeal of typescript I'm going to put
462:47 - this back to wins now
462:52 - now like I was saying you would probably
462:54 - want to type this A Little Bit Stronger
462:57 - so if you were going back to the stats
463:01 - getter what you can also do is set a
463:05 - return type on this so if we wanted to
463:07 - open up our types.ts file
463:10 - let's bring that over here to the right
463:13 - and maybe we wanted to actually annotate
463:16 - the expected return of this function
463:19 - which is usually a good idea with
463:21 - functions it's it's better to be
463:22 - explicit and I'll show you exactly why
463:25 - in a second
463:26 - so let's say this type is called derived
463:31 - game
463:33 - state or something like that and you
463:36 - don't have to Define this here you could
463:38 - Define it in this file itself and I
463:42 - would actually say that that's probably
463:43 - the better place for it because it's
463:45 - specific to this file
463:46 - so let's actually get rid of types.ts
463:50 - and we'll open this same file twice just
463:53 - so we can edit it in different places
463:56 - and I'll usually throw types at the top
463:58 - of the file so derived game state
464:01 - and that is what
464:04 - um or actually we don't want to call it
464:05 - that we'll say
464:08 - derived stats is what we want to call it
464:11 - and now I'm going to assign the return
464:14 - value
464:17 - of stats to derive stats and as we see
464:21 - it right now
464:22 - looks like
464:24 - nobody's complaining and that's because
464:26 - we've defined this as an empty object
464:28 - but let's say that we defined it as a
464:30 - string now this is going to complain
464:33 - because our return type does not match
464:35 - the explicitly annotated return type
464:38 - that we had assigned it
464:41 - so now our job is to Define this
464:44 - and we can see that ties is an easy one
464:47 - that's going to be a number
464:50 - so you can see that immediately we get
464:52 - this feedback where this looks okay but
464:55 - player with stats does not
464:57 - so we can come up and say player with
465:00 - stats
465:01 - and you could just say any
465:03 - that satisfies it but what does that get
465:06 - you it doesn't really help you
465:07 - throughout your code base because now
465:09 - anything can be passed here you don't
465:11 - get that explicit type checking
465:14 - so what we want to do is say that this
465:16 - is going to be a player array
465:19 - now let's see it doesn't seem to be
465:22 - complaining about that because
465:25 - this does satisfy player array it also
465:29 - has this wins property so we need to
465:31 - document that too
465:33 - so really what we need to do
465:35 - is make another type
465:37 - that is player with wins and that is
465:42 - going to be an intersection type or a
465:45 - union type I should say
465:48 - and we can actually use this and symbol
465:50 - to add properties so we can say wins
465:53 - and that will be a number
465:56 - so now player with wins represents what
465:59 - we're returning here
466:01 - and we can pass that in right here now
466:05 - if we would call this once again
466:08 - um
466:09 - win count now it's going to be mad
466:12 - because we're calling this wins here but
466:14 - our actual type is Win count
466:17 - so let's match this back up and now let
466:20 - me show you why explicitly uh making
466:24 - these types is advantageous the first
466:27 - thing is if we go over to The View
466:32 - dot TS where we had originally
466:35 - referenced these stats
466:38 - you can see that we can now import the
466:42 - derived stats
466:44 - and we'll import that from the store
466:48 - so we no longer need this right here
466:50 - we'll get rid of that entirely and then
466:52 - we'll add a type annotation so we're
466:54 - just importing the types
466:59 - so now stats is derived stats and then
467:02 - let's also say derived game this has not
467:07 - been defined yet but we can export that
467:11 - as derived game
467:16 - and then we'll import that from the
467:18 - store
467:21 - now it's complaining because we're
467:23 - trying to destructure properties off of
467:25 - derived game which at the moment is just
467:27 - an empty object
467:29 - now we know
467:31 - looking at the store that what we're
467:33 - returning from the game method
467:35 - is going to be the derived game
467:39 - and if we look at the return type here
467:41 - it has a array of moves
467:46 - so we can import that here
467:49 - it has a current player
467:52 - so we can assign it a player
467:55 - and then a status which is an object
467:57 - that has
467:59 - we've actually already defined that too
468:01 - so that is the game
468:03 - status from our types
468:06 - so remember if we go to types.ts
468:10 - we had the move type already defined so
468:14 - we just use that there we had the player
468:16 - type right here so we defined it here
468:18 - and then we had the game status right
468:22 - here which we passed to status so using
468:26 - these types we composed a derived game
468:29 - which is returned
468:32 - from this game getter method we've
468:35 - explicitly typed that as well
468:38 - and you can see winner is not
468:42 - correct here because I think we have a
468:44 - mismatch
468:47 - and I think I pointed this out earlier
468:49 - but I
468:51 - I don't know let's see
468:53 - ah so explicitly typing this actually
468:57 - um exposed I believe a little problem
469:00 - here it says player or null is not
469:03 - assignable to type player
469:06 - um so we're allowing the winner to be
469:09 - equal to null
469:10 - so if we go to our original types
469:13 - and go to game status this should
469:16 - actually be player or null it should not
469:19 - just be player because if it's null that
469:21 - means we have a tie a tie game
469:24 - so that was something that we fixed by
469:27 - being more explicit which is a good
469:29 - thing and why you should always
469:30 - explicitly you know Define your types
469:33 - where where appropriate
469:37 - so now it's not yelling at us for this
469:39 - anymore
469:40 - uh we're looking good let's see if that
469:42 - broke anything elsewhere
469:46 - so now we have explicitly typed the
469:48 - render method to pass in a derived game
469:50 - and derived stats
469:53 - and now the benefit of doing this if we
469:57 - come back to store
469:59 - and we go back to this game method or
470:03 - let's say stats
470:05 - earlier we were looking at Stats and we
470:07 - changed a property on stats so remember
470:11 - we previously had no explicit return
470:14 - type so we just passed win count
470:19 - just like that and nothing highlighted
470:22 - here so if I was a developer and this
470:25 - was a big project and someone else had
470:27 - written this function
470:29 - it's not very clear to me
470:31 - what the contract of this function is
470:33 - how it's being used outside or anything
470:35 - like that so I could come in and change
470:39 - this name to win count and not have any
470:42 - clue that that affected something in
470:44 - another file until I compile it so if we
470:48 - explicitly say derived stats now when we
470:53 - change it it's going to complain because
470:55 - it the wins is declared here but we are
470:58 - calling that win count so if we put that
471:01 - back to wins
471:04 - now it's going to be happy and it gives
471:06 - us the assurance that we didn't break
471:08 - something elsewhere within our code base
471:12 - so having done these additional typings
471:14 - let's close things out
471:17 - and run TSC
471:20 - and everything compiled and if we come
471:23 - back our game is working
471:25 - just fine so that's kind of the benefit
471:29 - um kind of bringing this full circle got
471:32 - the benefits of typescript I've
471:33 - demonstrated a lot of this but really I
471:36 - hope that this video has given you a
471:39 - brief introduction to typescript
471:42 - um just giving you some practical
471:43 - examples and kind of a code along
471:46 - um to to get your feet wet with this and
471:49 - also to kind of see how we can take a
471:52 - vanilla project and Port it over to
471:54 - typescript and get that setup done so if
471:58 - you like this video give it a like
471:59 - subscribe to the channel and I will see
472:02 - you in the next video which is going to
472:04 - be the same project but we're going to
472:06 - build it in react so we're going to take
472:09 - that vanilla JS and make it you know
472:12 - into a react app and then eventually
472:15 - we'll actually do another typescript
472:16 - refactor where we'll take that react app
472:18 - and do this same process of typing
472:21 - things so I'll see you in those next
472:23 - couple videos in this video I'm going to
472:26 - be rebuilding a vanilla JavaScript
472:29 - application to a react application and
472:33 - the purpose of this video is to show you
472:35 - how you transition from that vanilla to
472:38 - react and what problems react is
472:40 - basically solving for you why you would
472:43 - want to do this in the first place and
472:45 - just some basic introduction to you know
472:48 - building with react in general the app
472:51 - that we're going to be rebuilding is
472:53 - this tic-tac-toe game and this is
472:55 - actually a game that I had created in a
472:58 - prior video and I'd shown you how to go
473:02 - from complete scratch nothing on paper
473:05 - to a fully working vanilla HTML CSS in
473:09 - JavaScript tic-tac-toe game so the first
473:12 - thing we're going to do is learn how to
473:16 - set up a react
473:19 - so what that means we're going to learn
473:21 - how to take a vanilla react app so just
473:24 - regular JavaScript and set it up from
473:26 - scratch so from scratch let me zoom out
473:30 - a little bit this step right here is
473:32 - going to take I think it's going to be
473:34 - like over an hour so if you want to skip
473:37 - that if you don't care how it's set up I
473:40 - would highly suggest that you learn this
473:42 - if you haven't dug into it on your own
473:44 - but if you already know how this all
473:47 - works and you know what's going on under
473:49 - the hood to set up react app you can
473:52 - skip this the next chapter is going to
473:55 - be convert from JS to typescript so
473:59 - we're going to take that react app and
474:02 - implement it in typescript before we
474:04 - even write anything and the reason being
474:06 - is I just want to do this project in
474:08 - typescript because it's you know just
474:11 - the best best way to write a react app
474:13 - in my opinion just that you have strong
474:15 - type safety and then finally we're going
474:17 - to take
474:20 - the vanilla Javascript app
474:24 - and convert it to a react typescript app
474:28 - so I'm going to basically show you how
474:31 - you take the ideas that we put together
474:33 - in that prior video that you should have
474:36 - watched or at least gone over we take
474:38 - that MVC model view controller pattern
474:40 - and we translate that to the paradigms
474:43 - that react actually works with so you'll
474:46 - get to see how that translation looks
474:48 - and what problems react is trying to
474:51 - solve for us so that'll be a really fun
474:53 - conversion that we'll be doing
474:55 - and I will just highlight that this
474:58 - conversion is not me walking you through
475:00 - how to build step-by-step this app it's
475:03 - really to just recognize those patterns
475:05 - we're not going to be going through like
475:07 - okay now we're putting this element in
475:09 - and styling it adding this event
475:11 - listener we're going to be doing a lot
475:13 - of lifting and shifting you know copy
475:15 - pasting and reorganization so that's
475:18 - kind of what you should expect for this
475:20 - video let me be a abundantly clear from
475:23 - the beginning if you are looking for a
475:25 - video that is going to hold your hand to
475:28 - create a react app from scratch this is
475:31 - not the video to watch you should not be
475:33 - watching this video
475:35 - I'll say this a couple times but if you
475:37 - really want the best introduction to
475:39 - react go to the new react docs and go to
475:42 - the tic-tac-toe tutorial no relation
475:45 - necessarily to the one that we're doing
475:47 - here and go through this step by step
475:50 - and build this react app this is going
475:53 - to be the best and most straightforward
475:55 - way to learn that there are just a
475:57 - couple prerequisites to this video
475:58 - number one and most importantly make
476:01 - sure you're familiar with the code base
476:06 - for the tic-tac-toe game and the reason
476:08 - I say that is because I'm going to be
476:10 - glossing over a lot of the
476:12 - implementation details in the logic of
476:15 - like how the game works
476:16 - so if you haven't seen the prior videos
476:19 - which will be in the description as
476:21 - links
476:22 - or at least read through the code base
476:25 - to the point where you understand the
476:27 - control flow
476:28 - and understand the goals of what we're
476:30 - doing with this game right here so you
476:32 - can play the game you can reset it you
476:35 - can reset the scoreboard down here with
476:38 - a new round it's a relatively simple
476:40 - game but definitely need to understand
476:42 - what's going on
476:44 - so that's the first prerequisite then
476:46 - HTML CSS and JavaScript you need to be
476:51 - at least a basic Proficiency in them I
476:54 - have a 21 hour course in the description
476:56 - that you can go through if you need to
476:58 - get up to speed with that so go check
476:59 - that out if you feel behind on those
477:02 - three
477:03 - and then finally a basic understanding
477:08 - of react and understanding what jsx is
477:12 - in the first place you know the idea of
477:14 - a functional component those basic
477:16 - concepts and to do that I would go to
477:19 - the react documentation and make sure
477:21 - that you're on the beta react docs not
477:24 - the old ones because this these
477:26 - documentation or this documentation is
477:28 - way better it was completely Rewritten
477:30 - over the course of like two years
477:33 - and they did an excellent job with this
477:35 - so I would actually go to the
477:37 - tic-tac-toe tutorial this is kind of
477:40 - funny that this is the example that they
477:42 - give and this is what we're building I
477:45 - actually did not mean to do that
477:48 - but anyways go through this tic-tac-toe
477:50 - tutorial and just skim through it you
477:54 - don't need to you know build it all from
477:56 - scratch but the goal here is to just get
477:59 - a basic understanding because I'm not
478:01 - going to be going through all the like
478:03 - really basic concepts like react props
478:06 - or component props and passing props
478:10 - down that kind of stuff we're just going
478:12 - to kind of jump into things
478:14 - so that'll be great for you if you've
478:17 - already kind of gone through the basics
478:18 - you just need to see a real life example
478:20 - built live and that way you know you can
478:23 - just follow along and try to pick things
478:25 - up as we go and when I say a basic
478:27 - understanding of react what does that
478:29 - actually mean well I would expect that
478:32 - anyone watching this video has can at
478:35 - least get some sort of react App working
478:38 - they understand you know what jsx is all
478:42 - about so let's just write this down
478:44 - understand what jsx is you should
478:47 - understand
478:49 - what a prop
478:52 - is so this is just a property that you
478:56 - are passing to a component that that
478:59 - component reads as part of their render
479:02 - cycle so
479:03 - these are some pretty basic Bare Bones
479:06 - concepts of react and then finally you
479:09 - should understand what a functional
479:12 - component is so just at a very basic
479:16 - level and in the react documentation
479:18 - make sure that you're on the new beta or
479:21 - at least at the time of this video it's
479:23 - in beta but make sure you're on these
479:26 - docs the new ones they're great they
479:28 - were Rewritten over the course of two
479:30 - years and lots of effort was put into to
479:33 - this and they're just awesome so you can
479:35 - learn a lot from this and I honestly
479:37 - part of the reason I'm not making a
479:40 - beginner level react tutorial is because
479:43 - of these docs right here I think that
479:45 - this is the best place to go learn how
479:47 - to build a react application and
479:50 - specifically before you start in this
479:52 - video if you have no react experience I
479:55 - would go to the Quick Start
479:57 - and at least skim through the tutorial
479:59 - on building a tic-tac-toe game this is
480:02 - actually kind of ironic I did not mean
480:04 - to replicate the same thing as the react
480:07 - docs I actually didn't know that this
480:09 - was the example so that'll be good you
480:12 - can kind of read through their
480:14 - implementation and how they approach
480:16 - this problem and then how I approached
480:18 - it in this video because I was not
480:20 - looking at this when
480:22 - I originally built it so skim through
480:24 - this build it if you want to can't hurt
480:27 - and most importantly go to thinking and
480:29 - react and make sure that you've
480:31 - understood kind of the ideas here
480:33 - and then finally this will just help you
480:35 - along the tutorial that we're doing here
480:37 - I would go down to managing state or
480:41 - actually let's see
480:44 - so adding interactivity and go to the
480:48 - article or page that's called State a
480:51 - components memory and just skim through
480:53 - this just so that you have a basic
480:55 - understanding of the use State hook
480:57 - which is linked right here because we
481:00 - will be using this throughout the video
481:01 - and it'll be good to just have a basic
481:03 - understanding of it now I could sit here
481:05 - and say go read this go read that but
481:07 - ultimately we're gonna just jump into
481:10 - some code and the best way to learn is
481:12 - to just do things so I will be sure to
481:15 - point out different parts of this
481:17 - documentation as we approach those
481:20 - specific Concepts within the build
481:22 - obviously you're welcome to read through
481:24 - any of this and I would recommend
481:26 - reading the entire react docs at some
481:28 - point because it's just a good learning
481:30 - experience but with that you don't want
481:33 - to waste any more time if you meet these
481:35 - prerequisites we will go ahead and get
481:37 - started okay so we're going to look at
481:39 - react here and specifically where do we
481:43 - start so as a beginner or honestly even
481:45 - as an intermediate level developer the
481:49 - question of where do you start when
481:51 - you're building a react application is
481:53 - actually more valid than you might think
481:55 - seems like a silly question but there's
481:58 - a lot of ways that you can start
481:59 - building a react application you could
482:02 - start as simple as just including a
482:04 - script tag in your HTML and using react
482:08 - like that you could even include Babel
482:11 - or Babel however you say that which
482:13 - takes the jsx and turns it into
482:15 - JavaScript and you could use that all
482:18 - within the HTML document so
482:21 - if we went over to our our refactor here
482:25 - what I'm talking about is literally just
482:27 - putting scripts right here and you could
482:29 - serve react from a CDN and you have
482:31 - react in your project so that's one
482:33 - option another option is you could use
482:36 - like a code sandbox so if we went to
482:39 - code sandbox and here you can go new
482:42 - from template and you've got these
482:44 - templates react typescript or react and
482:47 - if you click react it will just spin up
482:50 - react application for you it's working
482:52 - and you can go ahead go ahead and add
482:56 - additional things to it so hello again
482:58 - and you're already programming in react
483:01 - so this is probably the quickest way now
483:04 - you could also go to things like as
483:07 - which is kind of a meta framework
483:08 - sitting around react you can go to
483:11 - create react app
483:13 - I'm not even going to go through all the
483:15 - possibilities just know that there's a
483:17 - lot of different options here and the
483:19 - one that I'm going to choose is actually
483:21 - not recommended by really any
483:24 - documentation that you would see if you
483:26 - go to the react quick start it's going
483:28 - to give you an idea of where to
483:31 - start so start a new react project and
483:34 - if you go down to this section it says
483:37 - if you're learning react we recommend
483:38 - create react app now the unfortunate
483:41 - thing about create react app and you
483:44 - know other Alternatives that kind of
483:45 - just spin it up for you is that you
483:48 - don't get to understand what's happening
483:49 - behind the scenes you don't really
483:51 - understand what what react really is at
483:53 - its core so the approach that I'm going
483:56 - to take here is actually a lot more
483:59 - similar to how code sandbox sets this up
484:03 - so as you can see in code sandbox if you
484:06 - go to index.js you'll see this file
484:09 - right here where we're actually creating
484:12 - a root element in the Dom and then we're
484:15 - using some react helper methods to
484:19 - basically render that react application
484:22 - in the root element that we've specified
484:25 - for react to use this gets us a lot
484:28 - closer to what react is doing at its
484:31 - core and so this is where I'm going to
484:33 - start now you might notice over here in
484:36 - the files pane I know this is kind of
484:38 - small let me make it bigger you're not
484:40 - going to see any sort of build tools
484:42 - going on so you're not going to see
484:43 - webpack or anything like that it just
484:46 - works and unfortunately this also makes
484:50 - an abstraction over react that makes you
484:53 - not really understand what's going on so
484:55 - not only are we going to start right
484:58 - here at its most basic level we're also
485:00 - going to kind of spin up our own to
485:03 - build tools so that we understand how
485:05 - we're taking the jsx
485:07 - converting it to JavaScript bundling it
485:10 - into one file and then including that in
485:13 - our index.html again the purpose of this
485:17 - video is primarily to show you how you
485:19 - take a vanilla JavaScript application
485:21 - and Port that over to react and to show
485:25 - the problems that react is solving for
485:27 - you and to do that we need to basically
485:29 - do everything from scratch so consider
485:32 - this a learning opportunity not so much
485:34 - hey how do I most quickly get a react
485:37 - application working furthermore the
485:40 - approach we're going to take in this
485:41 - video is not what I would recommend you
485:44 - use to create a production ready app
485:47 - that you're gonna you know deploy and
485:49 - work on with a ton of people this is
485:51 - kind of the most minimal setup that you
485:53 - could possibly have and is great for
485:56 - smaller projects some people would
485:57 - probably disagree but I think next.js is
486:01 - probably your best bet in terms of a
486:04 - production ready react framework this is
486:06 - basically a react meta framework that
486:09 - takes a lot of the common things that
486:12 - you might have to do in react such as
486:14 - like managing images and routing and all
486:17 - that kind of stuff different rendering
486:19 - methods and it just comes out of the box
486:21 - ready to go so this is what I would
486:24 - check out if you're wanting to build
486:25 - something in production anyways not
486:28 - going to get too distracted there let's
486:30 - get started building our react app so
486:32 - the first step with any project is to
486:35 - set up the initial you know
486:37 - index.html and get it working in
486:40 - development development mode so that you
486:42 - can basically just go over to the
486:44 - browser and anytime the code changes it
486:47 - will update the application so that is
486:49 - the first step and the way that we'll do
486:51 - that with react is let's go ahead and
486:54 - create a new folder called live react
486:57 - refactor and then our folder structure
486:59 - here is going to be the public folder
487:02 - which is going to have like public
487:03 - static assets that will serve
487:06 - and then we'll also have an SRC or
487:08 - Source folder this is where our react
487:11 - application and components are going to
487:13 - go
487:14 - so in the public folder this is actually
487:17 - where the index.html file is going to go
487:20 - because this is a static file there's
487:22 - really nothing Dynamic about HTML so we
487:26 - can just serve that directly so let's go
487:28 - ahead and just copy that we'll go back
487:31 - to the vanilla refactor once again you
487:35 - should be familiar with this before
487:37 - watching this video so we'll copy
487:40 - index.html and we will paste it over to
487:43 - the public directory now with react we
487:46 - are building things with different
487:47 - paradigms we are not including all of
487:50 - this HTML in this index file
487:53 - we're going to be creating components to
487:55 - deal with this HTML so therefore we can
487:59 - actually strip a lot of this stuff out
488:01 - so let's take pretty much all of the
488:04 - body content
488:06 - and delete it the second thing that
488:08 - we're going to do is change the title
488:10 - this is going to be the react refactor
488:14 - and then just for the moment we're going
488:16 - to comment out the script
488:18 - and save this we'll put a little text in
488:21 - here hello world
488:22 - so this should be a basic HTML document
488:25 - now you'll see in the bottom right
488:27 - corner I'm using live server so I talked
488:31 - about this in Prior videos it's a vs
488:33 - code extension that you can set up it's
488:35 - running on Port 5500 and that's actually
488:38 - what we're looking at here with the
488:40 - vanilla refactor but if we go back to
488:42 - the base of this you'll see that we now
488:45 - can look at the live react refactor
488:48 - and go to the public directory and now
488:51 - we have a Hello World document now if we
488:54 - wanted to connect some styles to this
488:56 - you can see we have this style sheet
488:58 - left over from the previous project but
489:01 - it is referencing the CSS directory
489:04 - index.css now for this react refactor
489:07 - I'm going to name this something a
489:09 - little differently we're going to put a
489:12 - new file in here called
489:14 - globals.css and the reason that I call
489:17 - it globals is because with react we're
489:19 - able to kind of scope our CSS per
489:23 - component rather than per the whole
489:25 - project and so this is just a naming
489:28 - convention that I'm using to make it
489:30 - explicit that anything that we put in
489:32 - global CSS is going to apply to
489:35 - everything that we use in every
489:37 - component that we make and that's
489:40 - because we're putting it in the
489:41 - index.html to start us out I'm going to
489:44 - go to the vanilla refactor and just copy
489:47 - everything from that index.css and paste
489:51 - it here
489:52 - and we will eventually move some of this
489:56 - stuff out of this globals file into
489:58 - component specific CSS files but for now
490:01 - it's just going to all be there and now
490:03 - we have to update our path and this is
490:06 - going to be
490:08 - globals.css and if we save this and go
490:11 - back to the browser you can see that
490:13 - here's our hello world pretty small
490:15 - there but then we also have the correct
490:17 - background color so we know that the CSS
490:20 - file is connected now if we're just
490:22 - looking at this document this is not a
490:24 - react application yet there's nothing
490:26 - here that tells us that this is react
490:29 - in order to actually convert this to a
490:32 - react application we need the JavaScript
490:35 - to be controlled by react and therefore
490:37 - we need a script tag
490:40 - so what we're going to do is create
490:42 - something called an entry point you
490:44 - might see this called
490:46 - index.js or
490:48 - you know entry point or it could be
490:51 - named pretty much whatever but in our
490:53 - source folder I'm going to be very
490:55 - explicit and just call this
490:58 - entrypoint.js and in this file this is
491:00 - where we're going to initialize react
491:03 - now going back to the code sandbox that
491:06 - I had shown you a little bit earlier you
491:09 - can see this pattern right here where
491:11 - the code sandbox is basically importing
491:14 - react and importing the react Dom client
491:18 - and then doing something you can
491:20 - actually find this in the react
491:22 - documentation if you go to add react to
491:25 - a website and then I think at the bottom
491:28 - run the jss jsx preprocessor let's see
491:32 - so somewhere right here you can see
491:35 - where it's you know calling create root
491:37 - and then root dot render it's not really
491:39 - called out explicitly which is a little
491:42 - bit unfortunate but it kind of shows you
491:44 - how you know you might know to do this
491:48 - but anyways we're going to write this
491:50 - out in our file so the first thing that
491:53 - we'll do is we will import the strict
491:56 - mode for react and the reason we'll do
491:59 - this is because it basically parses
492:01 - through your code and it finds all sorts
492:05 - of mistakes that you might make when
492:07 - writing a react application it's just a
492:10 - good practice to get into to have that
492:12 - in strict mode
492:13 - but you might say well how are we
492:16 - importing from react when we don't even
492:18 - have that included in our index.html or
492:22 - node modules and the answer is we're
492:25 - really not if we tried this it's going
492:27 - to break so at this point we're going to
492:30 - install some dependencies for our
492:32 - project so let's CD into the live react
492:35 - refactor
492:37 - then I'm going to run yarn init Dash y
492:41 - to accept all the defaults
492:43 - this will save a package Json to our our
492:48 - folder here
492:49 - now what I'm going to do is add the
492:51 - required react dependencies so really
492:54 - the only things that you need from react
492:58 - yarn add react and then react Dom
493:02 - so let's go ahead and add those you'll
493:04 - see those populate in our dependencies
493:07 - this is all we need to create a react
493:09 - application
493:10 - so now we can go back to our entry point
493:12 - and this should work okay now we need to
493:16 - import the create root method
493:19 - and this will be from react Dom slash
493:22 - client and now here is where we
493:24 - basically insert react into our HTML
493:28 - document remember react is just a bunch
493:31 - of JavaScript that knows how to
493:33 - basically manipulate the Dom and render
493:35 - things
493:36 - it doesn't actually you know create HTML
493:39 - files for you
493:40 - you have to have an index.html to put it
493:43 - in so what we'll do is we will Define a
493:47 - root element
493:49 - and this is going to be a element that
493:52 - we select from the Dom so if you
493:54 - remember from our vanilla refactor if we
493:57 - go to the JS and go to view.js where we
494:01 - are selecting all of these elements via
494:03 - the query selector
494:05 - and then we're in the query selector
494:07 - we're basically just looking at the
494:09 - document and selecting an element well
494:12 - we're going to do the same exact thing
494:14 - here we're going to say document
494:16 - dot get element by ID this is the same
494:20 - as doing query selector with a hashtag
494:23 - in front to select an ID it's just a
494:27 - little bit more specific
494:29 - if you have an ID assigned to an element
494:31 - so we're going to get an element by ID
494:34 - and we're going to call this the react
494:36 - root now where did I get this name well
494:39 - I made it up and we're going to connect
494:41 - it here over in the body so what you
494:45 - need to do is make a div
494:47 - and then you're going to give it an ID
494:50 - and call it react root
494:52 - so what this is doing is it's saying hey
494:55 - here's a container div now react find
494:59 - this container div and put all of your
495:02 - application code right here inside of it
495:05 - so basically we're giving it a container
495:07 - to render into
495:09 - and at this point we've just selected
495:11 - the root element this is just going to
495:13 - be an element now we have to create the
495:15 - react root so we'll call that root and
495:18 - we will call the create root function
495:19 - that we imported from the react Dom
495:21 - client
495:23 - and we're going to pass in that root
495:25 - element that we had selected so that is
495:28 - the react root and then finally we can
495:31 - now call a react Dom specific method
495:35 - called render
495:37 - and what we're going to render is a
495:40 - strict mode container
495:42 - so now we're using jsx and we're going
495:45 - to render strict mode and then we're
495:47 - going to say hello
495:49 - World react
495:52 - and this is just arbitrary jsx code
495:55 - now what you might notice is that this
495:57 - is a DOT JS file we could call this dot
496:01 - jsx because we're using jsx in here and
496:05 - then we'll get JavaScript react down
496:07 - here in the vs code language mode so it
496:10 - will just give us some better syntax
496:12 - highlight highlighting in addition to
496:14 - that when we go to basically transpile
496:16 - these from jsx to JS this file extension
496:20 - will allow us to kind of Target this
496:22 - file to do that for so let's save this
496:24 - entry point
496:25 - now let's go to index.html we will for
496:29 - now keep this script out of here and
496:32 - save this at this point you might say
496:34 - well okay all right we're done with the
496:37 - initial setup for react we've got this
496:39 - react root div and then we've got this
496:42 - entry point.jsx which is selecting it
496:45 - and rendering the react application
496:47 - within it but if we were to go to the
496:50 - index.html in the browser
496:53 - so our live refactor and let's inspect
496:56 - this
496:59 - if you inspect this it's just going to
497:01 - show you the react root but there's not
497:03 - going to be anything within it and this
497:06 - makes sense if you really think about it
497:08 - because what's happening when we re
497:10 - request this right here from like some
497:13 - server in this case our local computer
497:16 - is the server that is serving that
497:18 - index.html file to the browser
497:22 - but basically what's going to happen is
497:24 - the browser is going to load some path
497:26 - and that path is going to make a get
497:29 - request to some server the server is
497:32 - going to send back an index.html
497:35 - document
497:36 - then what the browser is going to do is
497:38 - it's going to read through the document
497:40 - and it's going to parse through all of
497:42 - the HTML and it's going to also parse
497:46 - through any script tag that it sees you
497:49 - can see that we've got a script tag here
497:50 - but that's just injected by live server
497:52 - that's not anything to do with the
497:55 - application that we've built so what's
497:57 - missing well as you can see in our HTML
498:00 - document aside from this live server
498:02 - script we don't have any script so this
498:05 - code that we wrote in the entry
498:07 - point.jsx
498:09 - this is just living in isolation right
498:11 - now it's not actually imported and run
498:15 - within our index.html document yet and
498:18 - so therefore it has no way to select
498:20 - that route and render anything so your
498:23 - next option your next guess might be
498:25 - okay let's just uncomment this script
498:27 - script and then we'll go to the source
498:31 - slash entry point
498:35 - dot jsx all right so we're trying to
498:38 - import that script but if we go to the
498:40 - browser that's obviously not going to
498:42 - work if you go to the console you're
498:44 - going to get loading module from blah
498:46 - blah because the mime type was wrong
498:49 - there's just going to be all sorts of
498:50 - problems here and the reason is because
498:53 - a jsx file one that has actual jsx in it
498:57 - is not going to natively run inside the
499:00 - browser you might get this stuff to run
499:02 - we could probably see if that worked so
499:05 - let's console log the root element looks
499:07 - like even that's not going to work and I
499:09 - don't really care to debug that because
499:11 - we know that this is just not a good
499:13 - strategy in the first place so pause the
499:16 - video and just ask yourself if we can't
499:19 - do this then what can we do how do we
499:21 - actually get that JavaScript to run
499:24 - inside the browser in a script tag and
499:26 - the answer is that we need to transform
499:29 - the code that we have written the jsx
499:32 - code into vanilla JavaScript script and
499:36 - then put that into another file and then
499:38 - import that other file right here if you
499:41 - watch the prior video also linked in the
499:44 - description where we took the vanilla
499:46 - JavaScript build and we refactored it to
499:49 - typescript you might remember that we
499:51 - had some sort of build step where we had
499:53 - to take the typescript code that was not
499:55 - valid in the browser and we had to
499:58 - compile that with the typescript
499:59 - compiler into valid JavaScript that we
500:03 - could run in the browser this is no
500:05 - different what we have to do here is we
500:08 - have to
500:09 - not necessarily compile I think the
500:12 - correct term here is to transpile so
500:15 - let's actually go look that up so
500:16 - transpile versus compile
500:19 - I should know this so compiling is the
500:22 - process of taking the source code
500:23 - written in one language and transforming
500:25 - it to another transpiling is the process
500:28 - of taking source code written in one
500:30 - language and transforming it into
500:32 - another language that has a similar
500:34 - level of abstraction so in other words
500:37 - it's not a real huge difference and we
500:39 - don't need to get hung up on the the
500:41 - differences there but what I want to
500:43 - take you to now is a website
500:47 - some documentation for Babel or Babel I
500:51 - never know how to say this and on the
500:53 - home page if we just zoom in a little
500:55 - bit
500:57 - what you'll see is that it gives you an
500:59 - example of how you put in some Next
501:01 - Generation JavaScript and then you get
501:03 - browser compatible JavaScript out in
501:07 - other words Babble I'm just going to go
501:09 - with Babel is a tool that will take some
501:14 - sort of JavaScript some a flavor of it
501:16 - that doesn't work in a browser and make
501:18 - it work in a browser one of those things
501:20 - that it can do is jsx so if we come down
501:25 - to the presets this is just the the
501:27 - playground you can see that it's using
501:30 - the react preset so it knows you know
501:33 - that we can write jsx code and if we
501:36 - were to write you know something like
501:38 - just a regular P tag
501:40 - hello world and then close that P tag
501:43 - off what you'll see on the right
501:46 - is that it's using the react library to
501:49 - create a new element in the Dom and then
501:52 - render the hello world text within it
501:55 - we could also wrap this in say a div
501:59 - so we're just writing what looks like
502:01 - HTML but really this is jsx
502:07 - so now we're creating elements and we
502:10 - could probably I think in this
502:11 - playground even write a component so
502:15 - this will be a function component and
502:18 - instead of just this isolated jsx we
502:22 - will return that from the function
502:25 - and oops
502:29 - format this a little bit better so you
502:31 - can see that worked and it's returning a
502:34 - JavaScript function that returns these
502:38 - create element calls and then we could
502:40 - even render that so let's make our app
502:45 - and then we want to return
502:48 - the component as a jsx component and now
502:52 - you can see that all of this is going to
502:54 - be valid JavaScript so this is just a
502:57 - DOT JS file that we could include in
503:00 - that index.html file so this right here
503:03 - is totally valid to put in this script
503:06 - tag
503:07 - this right here is not valid and it will
503:10 - not work now Babel under the hood is
503:14 - running a bunch of code against this to
503:16 - get it to this state and therefore we're
503:19 - going to need some intermediate step to
503:22 - get it to this point now once again just
503:24 - like there's many ways to create a react
503:26 - application there's also many ways to
503:29 - transpile code and Babel is not your
503:33 - only option
503:34 - another option is you could use if
503:37 - you're writing this in typescript which
503:38 - hint we are actually going to convert
503:41 - this to typescript in just a few minutes
503:43 - you could use the typescript compiler to
503:46 - do this because the typescript compiler
503:48 - actually supports jsx you could use
503:51 - Babel and you could also use something
503:53 - like webpack which is a build tool so
503:57 - that's what we're going to do I know
503:58 - it's not it this is not the latest and
504:01 - greatest tool chain this is mainly for
504:03 - educational purposes but if we go to
504:07 - some more documentation let's go to
504:09 - webpack docs and now we're dealing with
504:12 - a bundler so it does more than just
504:15 - bundle code but the purpose of using
504:18 - webpack is to take a bunch of different
504:21 - JavaScript files and squash them into
504:24 - one Javascript file that we call a
504:26 - bundle if you really want to understand
504:28 - why we need a bundler
504:31 - I've written a post that I've referenced
504:33 - a couple times at this point throughout
504:35 - this video series and it's the Scripps
504:37 - versus common JS UMD AMD es6 modules and
504:41 - if you come down to the bottom let's see
504:45 - so the last step module bundlers this is
504:49 - where I go through and explain why do we
504:51 - need a module bundler in the first place
504:53 - so I'd recommend reading this short post
504:56 - just to get a better understanding there
504:58 - but our goal is to basically take this
505:01 - entry point jsx file
505:04 - and then we're going to have many many
505:06 - other jsx files that will have all our
505:08 - different components and instead of
505:11 - coming to index.html and copying this
505:14 - down and importing every single script
505:17 - that's been transpiled from jsx to JS
505:20 - this is going to get very confusing
505:22 - our goal is to just do this we're going
505:25 - to have one file and it's going to come
505:28 - from the public directory and it's going
505:31 - to be called
505:32 - bundle.js and we don't need the type
505:34 - module anymore because we're using react
505:37 - code and we don't need to worry about
505:39 - that but this is our end State and I
505:42 - actually need to update this because
505:43 - remember
505:44 - index.html is actually in the public
505:47 - directory so we just need to reference
505:50 - it relatively so the bundle.js will be
505:53 - output keyword output it's not created
505:57 - yet into this public folder and will sit
506:00 - next to globals.css and
506:04 - index.html so the question becomes how
506:06 - do we get it there how do we get this
506:08 - bundle.js to compile into the public
506:10 - folder the answer is webpack or
506:14 - something similar once again this has
506:16 - kind of gone a little bit out of style
506:17 - but that doesn't matter our purposes
506:20 - here are educational to understand
506:22 - what's going on under the hood of react
506:24 - when we set it up in the first place and
506:27 - you'll hear all sorts of things like oh
506:29 - webpacks so outdated but ultimately tons
506:32 - of projects are still highly dependent
506:34 - on this and will be for many years to
506:36 - come so don't get spooked by you know
506:39 - anyone saying that this is irrelevant
506:40 - this is very relevant and the concepts
506:43 - that we'll learn through it are even
506:45 - more relevant so let's get started
506:47 - there's a lot to this documentation lots
506:50 - of different configuration Concepts and
506:52 - I'm not going to go through these
506:54 - because you really don't need 90 of this
506:57 - for our purposes so what I will do is
507:00 - just start writing the configuration and
507:03 - we'll come back to the documentation to
507:05 - point out the individual options that
507:07 - we're using
507:08 - so in order to start a webpack a project
507:11 - we need to initialize it with a
507:14 - configuration file now if you go to the
507:16 - documentation there should be something
507:19 - about the configuration here
507:21 - so introductory configuration and you
507:24 - can see it's called
507:26 - webpack.config.js so let's just copy
507:28 - this let's copy that default and we will
507:32 - make in the base of our directory a
507:36 - webpack.config.js file
507:38 - and let's just copy that basic example
507:41 - in there now bear with me a little bit
507:43 - for the next couple minutes this is
507:45 - going to get slightly confusing and
507:47 - you're welcome to skip over this section
507:49 - if you want I have time for this video
507:51 - so if you want to skip over these
507:53 - details and just get started building
507:55 - the react application you can do so but
507:58 - I would highly recommend going through
507:59 - this section it's really a good thing to
508:02 - understand what's going on here and
508:04 - we'll serve you for the rest of you know
508:06 - your developer lifetime just
508:08 - understanding this stuff you probably
508:09 - won't have to touch it again but it's
508:12 - good to just know what's going on under
508:14 - the hood so let's take this line by line
508:15 - first off the mode this is in
508:18 - development and if you go to the
508:21 - concepts
508:23 - let's go to environment and right here
508:26 - it says the mode is an option that can
508:29 - be development production or none and
508:32 - this is going to enable certain
508:35 - optimizations that are done in
508:38 - production so webpack will do certain
508:40 - things I believe it's like like
508:42 - minifying the code and stuff like that
508:45 - depending on your environment so we are
508:48 - in development what we can do to make
508:50 - sure that this runs depending on our
508:53 - actual environment let's say that we
508:54 - were deploying this somewhere what we
508:56 - know is that the
508:59 - process.env.node EnV is going to equal
509:02 - production when we deploy it on some
509:05 - server this is just a default that you
509:08 - know any deployment site or Cloud host
509:10 - is going to assign so if there is a
509:14 - process node EnV we're going to use that
509:18 - otherwise we're going to use development
509:20 - so in other words development is our
509:22 - fallback but we're going to look at the
509:25 - node EnV to determine
509:27 - what to use for this mode now this of
509:30 - course assumes that you're only allowed
509:32 - to assign development or production to
509:34 - node EnV if you were you know had like a
509:37 - staging environment then this wouldn't
509:39 - work but
509:41 - most of the time it's either production
509:43 - or development so this should work now
509:44 - our entry this is a little
509:46 - self-explanatory so we don't need to go
509:48 - to the docs for this this is going to be
509:51 - the file that webpack will start from it
509:53 - will start reading that file and then it
509:55 - will Trace all of the Imports that have
509:58 - come into that file and kind of just
509:59 - walk down the code tree to find all the
510:02 - relevant files that it needs to
510:04 - basically bundle up so in our case
510:08 - entrypoint.jsx is going to be that
510:10 - and we are in the root of our folder so
510:14 - we need to look in the source folder
510:16 - entry point jsx so we'll say relative to
510:19 - source
510:22 - entrypoint.jsx
510:24 - that's going to be our entry point and
510:26 - then output is also somewhat
510:27 - self-explanatory it's going to Output a
510:30 - single file we're going to call this
510:32 - just
510:33 - bundle.js and it's going to put it into
510:37 - the dist director now we're going to
510:39 - just rename this instead of dist which
510:41 - is stands for distribution and it's a
510:43 - very common place to Output your your
510:46 - build output we'll just call this public
510:48 - and the reason being is we've got this
510:50 - public folder and what we want is that
510:53 - bundle.js file to get output to public
510:56 - now some would argue that you kind of
510:59 - want to separate these concerns and
511:00 - maybe you want to Output this to dist
511:02 - and then copy over your index.html and
511:06 - CSS to dist so that it's all kind of
511:08 - isolated into this you know build output
511:12 - but for our project it's pretty simple
511:14 - this makes sense and we can just output
511:16 - this to the public directory so let's
511:18 - save this we will save entry point and
511:22 - now the question becomes well how do we
511:24 - actually use webpack well you could
511:26 - install webpack globally in your path or
511:31 - better than that you can install webpack
511:34 - pin it to a specific version for this
511:36 - project that's what we're going to do
511:38 - we're going to say yarn add then we're
511:41 - going to add a Dash D because this is a
511:44 - development dependency remember webpack
511:46 - is just here to look at all of our code
511:48 - and bundle it up into something that can
511:51 - actually run in the browser we don't
511:53 - need it after it has done its job we can
511:56 - just run the code that output and not
511:58 - deal with anything else so what we can
512:01 - do is just add webpack so
512:04 - go ahead and do that and now what I'm
512:06 - going to do is go to package Json and
512:08 - we're going to add some Scripts not
512:11 - necessary but it's just convenience here
512:14 - and something that I want to add is a
512:17 - build script so this will run when we
512:21 - say yarn build
512:23 - is it's going to run this script right
512:25 - here and what I want it to do is look in
512:28 - the development dependencies and just
512:30 - run webpack so we'll save that and now
512:33 - what's going to happen if we run yarn
512:36 - build
512:37 - so yarn build it's going to invoke the
512:40 - webpack binary that we just installed
512:43 - and webpack automatically knows to look
512:47 - for the
512:49 - webpack.config.js file in the root
512:51 - directory and then this config has
512:54 - basically told the the binary to look at
512:57 - this entry point
512:59 - read through all the code and output it
513:02 - to this bundle.js but if we were to run
513:05 - this we really haven't given it any
513:07 - instructions as to like how to do this
513:09 - so let's just try to run yarn build and
513:12 - it's saying that we need to install the
513:13 - webpack client I guess I had forgotten
513:16 - to do that so we'll say yes that's going
513:19 - to actually update our package Json you
513:23 - can see that here in Dev dependencies
513:26 - or I'm sorry we're in the final one
513:28 - there
513:29 - live react refactor
513:31 - so now we have webpack and webpack
513:34 - client
513:35 - so at this point we run yarn build and
513:37 - you can see that we're going to get an
513:39 - air of some sort and it says module
513:41 - parse failed unexpected token you may
513:44 - need an appropriate loader to handle
513:46 - this file type currently no loaders are
513:48 - configured to process this file
513:51 - and what it's complaining about is this
513:54 - jsx that we have written
513:57 - so if we go to entry point by default
513:59 - webpack does not know how to deal with
514:02 - jsx it doesn't know how to transpile
514:05 - this right here
514:08 - and this is where Babel will come in so
514:12 - going back to Babel we talked about how
514:15 - its job is to take this code and turn it
514:18 - into this code and so therefore we need
514:21 - to add something called a loader to
514:24 - webpack so if we go to the documentation
514:26 - there it says loaders are
514:28 - transformations that are applied to the
514:30 - source code of a module they allow you
514:32 - to pre-process files as you import or
514:35 - load them so I'm going to save us quite
514:36 - a bit of pain here and I'm just going to
514:39 - show you how to get this working with
514:41 - react I'll be completely honest this is
514:44 - confusing stuff I would not spend a
514:47 - whole lot of time beating your head
514:49 - against the wall to try to understand it
514:51 - at a super deep level the overall goal
514:53 - here is to just understand the process
514:55 - that our code is going through not
514:57 - necessarily all of these implementation
515:00 - details so what we need to do is add a
515:02 - module property and this module is a
515:07 - valid on the config
515:09 - and then we'll say rules and then we
515:12 - give it an array of rules now each of
515:14 - these rules is going to basically say
515:17 - like hey once you see this certain type
515:19 - of file in you know coming from the
515:21 - entry point here's how you actually you
515:24 - know look at it and transpile it and
515:26 - bundle it so the first rule that we're
515:28 - going to do is we're going to test so
515:31 - this is going to be a regular expression
515:34 - that we're handing it and we're going to
515:36 - say if you see any file that has a jsx
515:40 - extension at the end of it then go ahead
515:44 - and apply this rule
515:48 - but
515:49 - if you see anything in node modules
515:53 - exclude it because we don't want to put
515:55 - that into our bundle and then finally
515:58 - here's where we're going to use a
516:01 - specific loader
516:02 - and that loader is going to be called
516:05 - the Babel loader okay so right here
516:08 - we're importing something that's
516:10 - external so we need to install that as a
516:12 - Dev dependency if you go to Babel let's
516:15 - we're getting
516:16 - got a lot of tabs open here at this
516:18 - point let's open one more
516:20 - so Babble docs and then let's just go
516:23 - down if you go to presets you can see
516:26 - there's a preset for react and it gives
516:29 - you all this really confusing stuff okay
516:31 - so here we get a list of all the
516:34 - different loaders that we can use so
516:36 - let's start with the babble loader so we
516:39 - click on that
516:41 - and it says disclaimer it's a
516:43 - third-party package maintained by
516:45 - community members
516:46 - so this will need to be installed and
516:50 - here's the install command you need to
516:52 - install the babble loader Babble core
516:55 - and preset now I also happen to know
516:58 - that if we go to the preset react we'll
517:01 - need this as well so we're going to just
517:03 - kind of combine all this into one
517:05 - command
517:06 - so we will
517:08 - clear the terminal here and then these
517:10 - are all going to be developer
517:11 - dependencies remember because we're just
517:13 - transpiling code
517:15 - so we need to grab the Babel loader so
517:19 - that's for webpack then we're going to
517:22 - grab Babel specific packages so we need
517:25 - the core module
517:27 - we need the preset M this is basically
517:31 - to just kind of normalize all the
517:33 - different ecmascript versions and
517:35 - whatnot so that we can run JavaScript in
517:39 - all browsers
517:40 - and then finally Babel preset react
517:46 - so we'll install all of those and we go
517:48 - to our package Json
517:50 - you'll see that they're all added right
517:52 - there and now we can come back to our
517:54 - webpack config
517:56 - and this is going to work because we
517:58 - have that installed
518:00 - and then we'll give it some options now
518:03 - this I'm not going to go into a lot of
518:05 - depth because it's more on the advanced
518:08 - side and we'll just assume that this is
518:11 - going to work so what we first need to
518:14 - give it as a preset is the Babel preset
518:18 - M and once again this is just to make
518:22 - sure that you know all the different
518:24 - versions of ecmascript so ES3 456 2016
518:29 - blah blah all of those it kind of
518:31 - normalizes it so that the JS that is
518:34 - loaded is going to work in all browsers
518:36 - and then we're going to give it an array
518:39 - where we give it the Babel or Babel
518:43 - preset react
518:45 - and then this is really important we
518:48 - need to give it a run time of automatic
518:52 - and the reason that we need that is
518:54 - because when we come to entry point over
518:57 - here we are going to need that so that
518:59 - it automatically infers that react is
519:03 - part of this application and we don't
519:05 - have to explicitly import react every
519:07 - time we want to use it so that's the
519:11 - loader that we've set up I know that
519:13 - this whole blob is a a bit confusing but
519:16 - just zooming out the point of this is
519:19 - saying like hey anytime you see a jsx
519:22 - file that came you know as a result of
519:25 - looking in entry point
519:27 - so in other words anytime you see a jsx
519:30 - file in our project go ahead and use the
519:33 - babble loader and make sure you use the
519:36 - preset react which is basically what we
519:39 - were looking at here in this sandbox so
519:42 - that it takes this and creates this out
519:45 - of it
519:46 - so now
519:47 - we might be able to build our apps so
519:50 - yarn build remember that's going to run
519:53 - our webpack script and you can see that
519:55 - we got no errors so that's a good thing
519:58 - now we're not 100 sure that this worked
520:01 - yet but you can see in the public folder
520:04 - we now have a bundle.js and it's a bunch
520:07 - of ugly code that has been you know
520:10 - transpiled and this is not something
520:12 - that you want to actually read through
520:15 - before we get any further let's add a
520:18 - DOT get ignore to our project because
520:22 - we've added some developer dependencies
520:24 - and build output and all that stuff does
520:27 - not belong in source code so first let's
520:30 - look for node modules and ignore that
520:32 - and then I'm going to do this but this
520:34 - is probably not a best practice in any
520:37 - way we're going to look in the public
520:39 - directory and ignore anything called
520:42 - bundle.js and that's just because if you
520:45 - look at this this is a lot of gibberish
520:47 - that doesn't not belong in Source
520:49 - control this is an output of a build
520:52 - and that includes pretty much the whole
520:54 - react library in it so we do not want to
520:58 - put that in our GitHub repository so
521:01 - we'll ignore that let's make sure that
521:04 - that is working so we should not see any
521:07 - bundle.js sorry there's actually some
521:10 - leftover code from my typescript
521:12 - refactor from the prior video but the
521:15 - the main point is there's no bundle.js
521:17 - and if you look in Visual Studio code
521:20 - when it's ignored it's actually grayed
521:23 - out a little bit compared to the other
521:25 - files and folders so that's just a quick
521:27 - trick to know whether your your file's
521:30 - been ignored correct so the ultimate
521:31 - test is if we visit this index.html
521:35 - which is importing the bundle.js that we
521:39 - just output
521:40 - using entry point as the source does it
521:44 - work so let's go to the browser we can
521:47 - close this out I'll leave it open just
521:49 - so that we have reference to it
521:52 - and now you can see right here I gotta
521:55 - zoom in a bunch hello worldreact so
521:59 - something worked here because if you
522:02 - look at entry point you can see that
522:04 - that's where we're rendering the hello
522:06 - world react and so we know that our
522:08 - webpack config worked and we are able to
522:11 - render jsx in our browser
522:15 - and if we go ahead and inspect this now
522:18 - you can see in the react root that's
522:21 - where that P tag has been added but
522:24 - there is one problem still and that is
522:27 - if we go back to our code
522:30 - and we say
522:32 - by Zach or something like that and then
522:35 - we save this
522:37 - entrypoint.jsx well let's refresh the
522:40 - page and uh oh it's not actually working
522:43 - and the reason being is because every
522:46 - time we want to add something we need to
522:49 - rebuild the application so we need to
522:51 - run yarn build again
522:53 - that's going to compile everything and
522:55 - bundle it up and now you'll see Hello
522:57 - World by Zach
522:59 - obviously this is a poor experience as a
523:02 - developer we do not want this to
523:04 - you know we don't want to have to come
523:06 - and say yarn build every time we make a
523:08 - change
523:09 - so this is where the webpack dev server
523:12 - comes in and that is basically going to
523:14 - look at your webpack config and on any
523:17 - change to any file that is included
523:19 - there it's going to rerun this build
523:21 - step and output it to the bundle which
523:24 - is then going to be served to index.html
523:27 - and believe it or not this didn't used
523:29 - to be this easy but now you can
523:32 - basically just add one extra command
523:34 - here
523:36 - so instead of build we're going to give
523:39 - a Dev command which is our development
523:42 - only command and we're going to say
523:44 - webpacks serve and while we're here I'm
523:47 - also going to add a build production
523:51 - script and you know how we talked about
523:54 - over in the config we've got this
523:56 - process node EnV if we want to build it
523:58 - to production we could just pass
524:00 - something like this so set the
524:02 - environment variable and then call
524:04 - webpack
524:05 - so if we ran yarn build prod it's going
524:10 - to just apply some optimizations to
524:12 - everything and if we look at the
524:15 - bundle.js you'll also see that there's a
524:18 - license emitted here that would probably
524:20 - be
524:21 - good to include so let's let's go ahead
524:24 - and just say bundle all
524:27 - and that will include the license as
524:29 - well but if you look at this now it's
524:32 - optimized where like everything is
524:34 - minified it's all you know squashed
524:37 - together which makes it a smaller bundle
524:39 - to load over the wire over an HTTP
524:43 - request so yarn build is going to create
524:46 - something with lots of spaces and it's
524:48 - not optimized and then yarn build prod
524:53 - is going to optimize that but anyways we
524:57 - want to run this in development mode so
524:59 - let's run yarn Dev which is going to run
525:03 - the webpack serve command and this is
525:05 - going to say for using this command we
525:07 - need the webpack dev server package so
525:10 - we'll accept that you'll see that that
525:12 - was added down here at the bottom and
525:14 - now you can see that it's a running
525:16 - process that is just waiting for changes
525:18 - so we'll go back to our our index.html
525:22 - you can see Hello World by Zach and then
525:25 - if we go to the entry point jsx let's
525:28 - remove that and save it you'll see that
525:31 - this just refreshed Reloaded
525:33 - and if we refresh this page it's not
525:37 - doing anything ah so I am just not
525:40 - thinking whatsoever and totally totally
525:43 - messed this up so if we try to go
525:47 - directly to index.html in the browser
525:50 - and we are running this over live server
525:53 - so localhost 5500 we're just going to
525:56 - get the static contents of the public
525:59 - directory now if we look at the output
526:01 - of the webpack dev server it says that
526:04 - the project is running at localhost
526:06 - 8080. so we can kill the live server at
526:10 - this point so we'll close that server
526:13 - now if you reload this page we got it
526:16 - way zoomed in
526:18 - but if you reload this page it's going
526:20 - to say unable to connect but if we go to
526:22 - localhost 8080
526:24 - now you'll see here's our hello world
526:26 - react is working again and then if we go
526:30 - back and make a change
526:33 - and save that it's going to hot reload
526:36 - and update in the browser automatically
526:39 - so the mistake I made I just I was
526:42 - trying to look at the static contents
526:44 - from live server we need to go to a
526:46 - different port here the next step here
526:47 - is to replace this content with our app
526:50 - so we can come over to our files and
526:54 - next to entry point let's call it
526:56 - app.jsx
526:58 - and this is just going to return a basic
527:02 - application wrapper that we're just
527:04 - going to consolidate all of that logic
527:06 - to we can go ahead and use es6 modules
527:09 - so we'll export a default function
527:12 - called app
527:13 - and then this will return some div and
527:17 - then say my app
527:19 - now we can import that into the entry
527:22 - point
527:23 - so import app from app
527:27 - and then replace this content with the
527:31 - jsx element just like that
527:33 - and we're getting an error I think we
527:35 - might need to say app.jsx
527:39 - yep that's all we needed to do it
527:41 - couldn't resolve that without the
527:42 - extension and I believe that happens
527:45 - because our webpack config doesn't know
527:49 - how to kind of parse through and import
527:52 - that if we don't have the extension on
527:53 - it so now
527:55 - this entry point is basically done we
527:58 - don't have to look at this anymore
527:59 - because it's all set up and now we're
528:02 - going to be working from this app.jsx so
528:05 - let's go make sure that it works my app
528:08 - now let's connect some per component
528:11 - styles
528:12 - so we're going to use just vanilla CSS
528:15 - and one way that we can do that is by
528:17 - using CSS modules so we can say app.css
528:23 - and let's go ahead and select everything
528:26 - in this app and make it the color red
528:30 - so this is not going to work by default
528:33 - if we just look at our app but all we
528:36 - have to do is import
528:38 - and then we just import the app.css now
528:43 - you'll see that there's some errors down
528:44 - here and we're not able to compile and
528:48 - that is because we have not specified a
528:51 - CSS loader right now we're in we have an
528:54 - entry point of this which is going to
528:57 - eventually make it to app.jsx then it's
529:01 - going to import
529:03 - app.css but we don't have any rule for
529:06 - that right now we're only looking for
529:08 - jsx files so if we go back to the
529:10 - documentation for webpack right here and
529:14 - we go back to loaders
529:16 - you'll see that there's some different
529:18 - different categories and one of them is
529:21 - styling so we have the style loader add
529:24 - exports of a module as style to adopt to
529:27 - the Dom or css loader load CSS file with
529:30 - resolved Imports in return CSS code
529:33 - we're going to need both of these and
529:35 - these are third-party packages so we'll
529:38 - have to install them
529:40 - so let's come down to our terminal open
529:43 - up another one actually we'll let's just
529:46 - cut this cut the server for now
529:49 - and we'll add
529:51 - this as a developer dependency we'll
529:54 - call it we got to get the style loader
529:56 - and the CSS loader
530:01 - once we've done that we can add another
530:03 - rule so remember rules is going to be an
530:07 - array and we can specify a CSS rule so
530:11 - here we're going to test and look for
530:13 - any dot CSS files
530:16 - so that's what we're looking for and if
530:19 - we find them we're going to use the
530:22 - style loader and the CSS
530:26 - loader
530:28 - so let's save that that's our final rule
530:31 - that we'll add
530:32 - and let's run yarn Dev
530:36 - and now you'll see everything compiled
530:39 - successfully and if we go back to the
530:41 - react refactor in refresh we had to
530:44 - refresh that first time because we had
530:45 - restarted the server so it's red and now
530:48 - if we change this
530:50 - to Green it's going to hot reload and
530:53 - everything is going to be green
530:54 - so at this point we have our entire
530:56 - webpack configuration done we have our
531:00 - entry point to the react app setup and
531:03 - our index.html is importing that bundle
531:06 - that we are you know basically
531:08 - compiling and bundling together with the
531:11 - help of webpack and Babel I know we've
531:13 - spent a solid amount of time just
531:16 - setting up this react app in the first
531:17 - place but I hope that it has been
531:20 - educational and given you a better sense
531:22 - of what's going on under the hood this
531:25 - is basically what the create react app
531:27 - and all of the other you know Frameworks
531:30 - that lets you set up a react app they're
531:33 - all doing some version of this under the
531:36 - hood but that's abstracted away from you
531:38 - and so oftentimes you don't understand
531:40 - what react actually is at its core level
531:45 - so there's one more thing that we're
531:46 - going to do and I kind of debated this a
531:49 - little bit but I want to build this
531:51 - react app with typescript rather than
531:53 - you know doing a whole another
531:55 - additional video where we refactor it to
531:57 - typescript I think using typescript is
532:00 - really awesome especially with react
532:02 - apps and across the stack and it's not
532:05 - going to be too difficult to translate
532:07 - what we have here to typescript and it
532:11 - will also give you a better idea of how
532:14 - we translate vanilla to typescript from
532:17 - a build step perspective if you're not
532:19 - interested in this and you just can't
532:21 - wait to get started once again
532:23 - timestamps are in this video skip to the
532:25 - build where we actually start building
532:27 - out this application and you know
532:30 - translating it from that vanilla
532:32 - JavaScript to react so let's cut this
532:34 - server and I will also add that there is
532:37 - a typescript branch and then a main
532:39 - branch for the repository in the
532:41 - description that follows and basically
532:44 - has all the final code here this is a
532:47 - combined video so you can find the
532:50 - vanilla JavaScript react app in the main
532:53 - branch and then the one that we're
532:55 - building in this video will end up in
532:57 - the typescript branch so I'll leave that
532:59 - in the description and kind of label it
533:01 - so that it's clear so if you haven't
533:03 - watched the prior video where I
533:04 - converted a vanilla Javascript app to a
533:08 - basically vanilla typescript app go
533:11 - watch that because it will cover a lot
533:14 - of the basic concepts that I'm going to
533:16 - gloss over in the next few minutes
533:18 - so I'll leave that in this the
533:20 - description but the first thing we need
533:22 - to do is install typescript so we'll add
533:25 - that as a developer dependency
533:30 - once we have that then we can run yarn
533:33 - TSC which is the compiler and we can run
533:36 - init
533:38 - this will create a TS config although
533:42 - I missed something here it's not a knit
533:45 - it is dash dash init
533:50 - so that creates a tsconfig DOT Json
533:55 - file
533:56 - now there's all these different options
533:58 - here I'm going to go ahead and just copy
534:00 - the final one just because it's going to
534:03 - save us some time okay so this is the
534:05 - basics
534:06 - um the things that I'll point out here
534:09 - this is pretty much the same as that
534:10 - prior video that we did but just to
534:13 - point out we're targeting es6 so that's
534:15 - the version of JavaScript that the build
534:18 - output will be and there's one thing
534:20 - that I've left out on purpose here and
534:23 - that is a property called jsx so let's
534:27 - go to the typescript documentation
534:30 - so typescript
534:32 - and then docs and then go to the
534:35 - reference for the configuration file so
534:39 - I'm not really sure where this would be
534:41 - typescript tooling
534:43 - reference let's just search it config
534:48 - writing a configuration file gosh this
534:51 - is very indirect I want to just go to
534:53 - the reference for this
534:57 - let's go typescript config reference
535:02 - not sure why that's not searchable
535:04 - easier but maybe I'm doing something
535:06 - wrong so anyways let's look at the let's
535:09 - find that jsx property that we had just
535:12 - talked about so that's down in language
535:14 - and environment so jsx
535:18 - and it says controls how jss jsx
535:21 - construct constructs are emitted in
535:24 - JavaScript files This only affects
535:26 - output of JS files that started in TSX
535:29 - files so we have a couple of options
535:33 - here we have react react.jsx jsx Dev
535:37 - preserve and Native this preserve option
535:40 - would be good if we were wanting to
535:43 - basically compile our typescript to
535:46 - JavaScript but leave the jsx as it was
535:49 - and then use Babel to take jsx and
535:53 - convert it to JS now for this simple of
535:57 - a project we don't really need all that
535:59 - in direction we can just use react jsx
536:02 - and get all of that to happen for us
536:05 - so let's give it to the jsx pro property
536:08 - and we'll pass in react jsx and so now
536:12 - the typescript compiler is not only
536:14 - going to look at our typescript and
536:17 - convert it to JavaScript it's also going
536:19 - to recognize jsx and convert that to
536:22 - JavaScript so it's kind of an all-in-one
536:24 - solution which means that we can remove
536:27 - all of the Babel stuff that we had just
536:30 - added that was good to understand you
536:33 - know how you would do something with a
536:35 - vanilla application but if you're using
536:38 - typescript we can remove a lot of this
536:40 - complexity so instead of using all of
536:43 - this Babble stuff we're going to use the
536:45 - TS loader and if we and we're also going
536:49 - to need to change this to TSX so it only
536:52 - searches for TSX files finally we'll
536:56 - need to update all our file extensions
536:59 - to TSX so that it knows to grab those
537:02 - we'll come back to these errors in a
537:05 - second those are type errors that we're
537:06 - getting let's just save this for now so
537:09 - now we have all TSX files and let's go
537:12 - back to this TS loader if we find this
537:16 - in the loaders
537:18 - it's right here for transpiling it says
537:21 - it loads typescript 2.0 like JavaScript
537:23 - so this is also going to be an external
537:27 - one I believe so we'll need to install
537:29 - it so let's open up our terminal here
537:31 - and look at our package Json right now
537:35 - we've got all these Dev dependencies we
537:37 - have Babel core preset M you know all of
537:40 - these Babel stuff and we don't really
537:43 - need it anymore because typescript has
537:45 - taken over the typescript compiler is
537:47 - taken over and done all of that job in
537:50 - addition to compiling typescript for us
537:51 - so we can yarn remove all of that stuff
537:56 - I'm just gonna take a little shortcut
537:58 - and just delete all that
538:00 - we still need the CSS and style loader
538:03 - and then we of course need webpack
538:05 - because we're still using that so let me
538:07 - save that and just yarn install
538:10 - so that's gonna refresh everything and
538:14 - then let's go ahead and add a developer
538:16 - dependency called TS loader
538:19 - so now we have the CSS style in TS
538:22 - loaders in our project and that should
538:25 - work for the webpack config
538:28 - now if we try to build this
538:31 - we're going to get some errors oh okay
538:34 - duh I need to update this to TSX because
538:38 - we're not able to read the entry point
538:40 - all right so now we're getting some
538:41 - errors but it's a much better error it's
538:44 - looking for type files for everything
538:47 - for react and all that stuff and so now
538:50 - we just need to install those you'll see
538:52 - an entry point it's going to say try npm
538:55 - save Dev types react so that's all we're
538:58 - going to do is save the react types and
539:02 - then I believe we also need the react
539:04 - Dom types and you can see this goes away
539:07 - root elements just complaining that it
539:10 - could possibly be null so one thing we
539:13 - could do is we could say if there's no
539:15 - root element then throw new air react to
539:19 - app configured incorrectly and now
539:22 - that's going to solve that because we
539:24 - know that that will exist
539:26 - I tend to just put a exclamation at the
539:29 - end to say like hey we know that this
539:31 - root element is going to be found that's
539:33 - okay to do in this case I think but yeah
539:36 - if you wanted to be safe you'd throw an
539:38 - air or log something or whatever to make
539:41 - sure that that root element was selected
539:42 - correctly let's try one more time yarn
539:45 - build
539:47 - and now it's successfully built things
539:50 - into the public bundle.js so that
539:53 - compiled typescript to JS and jsx to JS
539:57 - so everything can now run in the browser
540:00 - and let's make sure that that worked by
540:03 - going not to localhost 8080
540:07 - but to the static app that we had so
540:10 - localhost
540:12 - 5500 we cannot connect to that because
540:15 - live server is not running
540:17 - but if we hit go live on live server and
540:21 - then refresh and go to live react RE
540:24 - Factor and then the public directory you
540:27 - can see that we have an app running with
540:29 - some styled green text
540:31 - so that means that our our final build
540:34 - worked okay
540:36 - and then if we were to go to yarn Dev
540:38 - and run that Dev server at localhost
540:41 - 8080.
540:42 - and refresh you'll see that it refreshes
540:45 - and once again we can go change this to
540:48 - you know red again and that should hot
540:51 - reload and change the the CSS of this
540:55 - app let me close a bunch of stuff out
540:57 - we'll close all the save files collapse
541:00 - all this
541:01 - and I'm going to collapse this terminal
541:03 - it's just going to be running in the
541:05 - background and if we run into some
541:07 - errors we'll we'll pull it up again so
541:09 - if you remember from the prior video
541:11 - that we did where we refactored
541:13 - everything the live TS refactor we
541:16 - basically took the tic-tac-toe game and
541:19 - we turned it to a typescript code base
541:21 - so we've got the app we've got the store
541:24 - and we've got the view and then we have
541:27 - our types file this is what we're going
541:29 - to be referencing and we're going to be
541:31 - just lifting it over and putting it into
541:33 - react code while we're doing this I'm
541:36 - going to run a live server and that's
541:39 - going to be over here
541:41 - on this tab
541:42 - we'll just grab localhost 5500 and I'm
541:45 - just going to run the vanilla refactor
541:47 - just so that we have a working final
541:50 - version of the game so this is just
541:52 - vanilla JS nothing fancy this was from
541:56 - the first video this is just our
541:58 - reference point and we will eventually
542:00 - reach that same point over here in the
542:02 - react refactor the first thing I want to
542:04 - do is bring over our types file so
542:08 - let's copy this file of our types
542:11 - and put that in source
542:15 - and looking at the types we just have a
542:17 - player a move game status game and game
542:21 - State the next thing that I want to do
542:22 - is copy over the HTML
542:26 - so we had index.html that had all of
542:30 - this structure for us and we had the
542:33 - main tag as well as the footer and then
542:37 - finally a modal that opens when the game
542:39 - ends I'm going to go ahead and copy all
542:42 - of this
542:44 - and just to start us out we're in the
542:47 - live react refactor again
542:49 - and we'll go to app.tsx
542:52 - and instead of my app we're going to
542:55 - return all of this HTML
542:59 - so all that HTML is going in there it's
543:01 - going to yell at you because we need to
543:03 - put a fragment around this because we
543:06 - have no parent element to all of these
543:09 - and then of course we need to update all
543:11 - of our class attributes to be react
543:15 - compatible or jsx compatible attributes
543:19 - which will be class name so let's add
543:21 - that as a class name so that should fix
543:23 - a few things then all of our comments
543:26 - we'll just get rid of them right now
543:29 - those are not valid jsx and then finally
543:33 - you'll see that the style needs to be
543:35 - converted this one will be will be a
543:37 - little bit annoying to do so let me just
543:39 - kind of speed through this real quick so
543:41 - I'm just copy pasting everything from
543:45 - the final version Okay so we've
543:47 - converted the HTML to valid jsx
543:52 - no errors going on here so we should
543:54 - remember we have this server I'm just I
543:57 - guess I'll keep it open here just so we
543:58 - can see a little bit of it so that
544:00 - should be reloading every time we save
544:03 - and now you can see in our react
544:05 - refactor we've got something working we
544:08 - have red text everywhere because I have
544:10 - not removed
544:12 - from our globals
544:14 - or no not globals it was app.css where
544:17 - we added this
544:19 - let's get rid of that because that's
544:20 - annoying
544:21 - and you can see now we have all of the
544:24 - structure and style to our application
544:27 - but if we try to click anything it's not
544:29 - going to do much because we don't have
544:31 - any event listeners or anything hooked
544:34 - up let me go ahead and just close all
544:36 - these tabs we don't really need them
544:37 - anymore so the first thing that you'll
544:39 - want to do when you convert something
544:41 - over to a react application or you're
544:44 - just building a react app from scratch
544:46 - is look through your structure of your
544:49 - HTML and find what parts of this will be
544:54 - best as an individual component
544:57 - so the first one that's pretty obvious
545:00 - that I'd like to kind of rebuild is the
545:03 - footer this could be its own component
545:05 - and so what I'll do is I'll just start
545:08 - using this convention let's add a new
545:11 - folder
545:12 - called components
545:14 - and then in components I will just add a
545:17 - footer.tsx
545:19 - and then the styles for that footer will
545:22 - be footer.css
545:24 - one could argue that you know this
545:26 - organization is not the best but it'll
545:28 - work for now so the template that we're
545:30 - going to work with here is basically
545:32 - we're going to export the default
545:34 - function
545:35 - from each of these component files
545:38 - and I'm trying to do this in the CSS
545:40 - file
545:41 - oops
545:43 - okay so that looks a little bit better
545:45 - so we're going to export a default
545:48 - function and then return some jsx from
545:51 - that and then we're going to import the
545:55 - footer.css at the top so it gets all of
545:58 - the component specific styles
546:01 - and then here we can just go back to our
546:04 - app.tsx and let's just copy the footer
546:08 - entirely and paste it right in here
546:11 - so this will self-contain the footer and
546:15 - I don't think there's anything that we
546:16 - need to modify here so we can just leave
546:19 - that as is and I don't actually think
546:22 - that we yes we do have some styles for
546:24 - that so in our globals.css where we have
546:28 - all of our Styles right now that applies
546:31 - to everything we want to come down and
546:33 - find the footer Styles so right here
546:36 - this is where all the footer styles are
546:38 - let's rip those out
546:41 - and add those to footer.css
546:45 - and then save both of those
546:48 - and so now the Styles and the HTML
546:50 - should be scoped to this one component
546:53 - and we can finally come back to app.tsx
546:56 - and remove the footer and replace it
547:00 - with our footer component
547:02 - and if you hit command period it will
547:05 - add that import for us as you can see
547:08 - right here so it's added the footer and
547:11 - our webpack is going to hot reload
547:14 - and you'll see the footer right here
547:17 - down at the bottom it's working and if
547:20 - you go to your developer tools let's
547:22 - actually look at Firefox extensions
547:26 - and let's look for react
547:30 - and grab some grab the react developer
547:33 - tools all right so now we have some
547:35 - react developer tools and I think if we
547:38 - refresh this
547:39 - yep we can now see the components so you
547:43 - can see that the footer is one of our
547:45 - components now so this is let's zoom in
547:47 - a little bit
547:49 - I guess I can't zoom in unfortunately I
547:51 - don't think I can zoom on
547:54 - the developer tools too much it's pretty
547:56 - small okay the next thing that we can do
547:58 - is break out the modal itself so this
548:02 - right here is the modal that we will pop
548:05 - open when someone wins the game
548:08 - we can bring this over to the components
548:11 - and call it modal.tsx with modal.css as
548:16 - the styles
548:18 - and I'm just going to use this template
548:21 - again so export default function
548:23 - remember to import our
548:26 - CSS and now what we'll do is we'll grab
548:29 - all of this right here
548:32 - and return it from this component
548:36 - we'll go to globals.css and find all the
548:39 - modal Styles which we've organized
548:43 - is another reason to organize your CSS
548:46 - so that when you refactor
548:48 - it's pretty easy to know what goes where
548:50 - so we put the modal CSS here
548:53 - we'll save Global Styles we'll save that
548:56 - component and then we will once again
549:00 - add the modal
549:02 - oops we need to import that
549:05 - from our components and you're going to
549:08 - notice that this is going to mess things
549:10 - up a little bit so if we come to our
549:13 - refactor
549:15 - well actually it doesn't mess anything
549:16 - up because we still have that hidden
549:18 - class
549:19 - so if you'll see the modal hidden class
549:22 - we're going to now control these sorts
549:26 - of things with react rather than classes
549:28 - so I'm going to get rid of that I'm also
549:31 - going to start removing all these data
549:33 - IDs because we're no longer having to
549:35 - select the elements we can just grab
549:37 - them directly from react so now once we
549:40 - remove those classes you'll see down
549:43 - here at the bottom
549:45 - you get this weird modal happening and
549:48 - let me see what's going on there so if
549:50 - we look at these Styles I think what's
549:52 - happening is we are setting the position
549:55 - to be fixed but we're not giving it a
549:58 - reference point of where it should start
550:01 - so let's give it left to zero and top
550:04 - zero and now that should work okay
550:07 - once again you can't click anything
550:08 - there's no JavaScript functionality
550:10 - quite yet but that should be styled
550:13 - correctly and then if we come to app.tsx
550:16 - now instead of using a hidden class that
550:19 - will toggle with some in you know
550:21 - implicit
550:22 - event listener we can just be more
550:25 - declarative about this and keep a state
550:27 - of whether the modal is open or not and
550:30 - then render it conditionally here so I'm
550:32 - going to just create a variable right
550:35 - now you'll see how this comes into play
550:37 - a little bit later but we'll just make a
550:40 - static variable called show modal and
550:44 - we'll set that to false to start once
550:47 - again you'll see how this changes in the
550:49 - future so don't get caught up on how I'm
550:51 - not using State correctly and stuff like
550:54 - that
550:54 - so show modal we're just going to wrap
550:58 - it in this just like that so now we will
551:02 - be able to conditionally show the modal
551:05 - and then furthermore what we might want
551:07 - to do is add some props to modals so we
551:10 - can pass what we want to show
551:13 - remember we are going to control this
551:17 - text right here with JavaScript so it
551:21 - would be good to add a message as props
551:25 - and then we can define a
551:28 - props type up here that has a message of
551:32 - type string
551:33 - so right here we're destructuring from
551:36 - the props object and we're typing it
551:39 - right here and now instead of player one
551:42 - wins we can say that is set to the
551:46 - message that we passed to the modal as
551:48 - props
551:50 - now since this is a required message if
551:53 - we go back it's going to complain
551:55 - because we haven't given it all of the
551:57 - props for now we're just going to say
551:59 - player one wins because we don't have
552:01 - anything Dynamic to pass quite yet
552:04 - but now you can see if we were to toggle
552:08 - this from false to true
552:12 - it's going to show the modal in pass in
552:14 - player one wins and just to check we can
552:18 - look at our components again and now we
552:20 - have a footer and a modal in our app
552:24 - so let's put this back to false for now
552:27 - so that's not going to show and move on
552:30 - to the next part that we're going to
552:32 - refactor into components all right so
552:34 - looking through the rest of this we
552:36 - could of course make a scoreboard
552:39 - component but this is not a whole lot of
552:41 - HTML I think we'll just leave this here
552:44 - that's really a style preference whether
552:46 - you'd split that out this right here we
552:49 - can simplify using some react
552:51 - conventions so this will be rather
552:54 - simple to do so we'll just open up some
552:57 - brackets here and I'm going to make an
553:00 - array that goes one through nine
553:02 - and you could of course create this with
553:04 - some JavaScript but let's just be
553:06 - expressive about what we're doing it's a
553:08 - lot easier to follow
553:11 - and then from here we're just going to
553:13 - map and we're going to call this the
553:15 - square ID is what each of those numbers
553:18 - will represent
553:20 - and then for each of the square IDs
553:23 - we're going to one of these div elements
553:25 - now whenever you map across multiple you
553:29 - know elements in an array react needs to
553:32 - know the key that you're giving it and
553:34 - the reason is so that it has a
553:36 - predictable order that it can put these
553:38 - elements in and when it goes to
553:40 - re-render and figure out whether each
553:42 - element has changed and it needs to
553:44 - re-render in the Dom it will look at
553:46 - that key to tell tell it that so we
553:49 - don't need this ID anymore we also don't
553:52 - need this data ID because we're not
553:55 - using that old vanilla syntax we do need
553:58 - the key here as I just described and we
554:01 - can pass it the square ID which is
554:03 - basically going to be the number on that
554:05 - square
554:06 - and then furthermore clean our vanilla
554:08 - application we were using JavaScript to
554:12 - render an i element or basically an icon
554:16 - in this div so if we look back when we
554:19 - click something or sorry this is the
554:22 - react app we have if we click something
554:24 - in the finished app it will put one of
554:27 - those icons within the Box
554:30 - so what we can do in react is instead of
554:33 - implicitly doing this we can be or
554:35 - imperatively doing this we can be more
554:37 - declarative and just say let's just put
554:40 - an i tag in there
554:43 - give it a class name and we know this is
554:46 - going to be fa solid now we're going to
554:49 - have conditional classes based on which
554:52 - player is currently up we haven't
554:54 - implemented that quite yet but for now
554:56 - I'm just going to pass in fax
554:59 - and then we'll say I think that was
555:02 - yellow
555:03 - was X or no I think it was turquoise is
555:06 - what we had for player one
555:08 - we will of course come back to this but
555:10 - if we render this now and then at this
555:13 - point we can get rid of all of these
555:15 - so just reducing that amount of code now
555:18 - you'll see there's an X rendered into
555:20 - each of those so we'll leave that there
555:22 - for now we'll come back and make that
555:24 - Dynamic later scrolling through we've
555:26 - got the menu this could actually be a
555:29 - good use case for another component so
555:32 - we'll make it a menu component
555:35 - and we'll export the default menu
555:37 - function oops and then this menu is
555:40 - going to have some props so we'll
555:42 - initialize that and then we also want to
555:45 - import the menu.css which we need to add
555:50 - over here so there's your menu CSS let
555:53 - me close a bunch of these
555:54 - clean this up and we'll just open
555:57 - oops this is from the final so there's
555:59 - our menu and our menu CSS
556:02 - now the first thing we'll do is let's go
556:04 - over to globals and look for those menu
556:07 - styles
556:09 - so it looks like we got them right here
556:11 - so let's copy all of those I think
556:14 - that's all that we need
556:16 - throw those in menu CSS
556:20 - save globals
556:23 - and then we'll go to index.html or I'm
556:26 - sorry not index app.tsx
556:29 - and at this point we can grab all that
556:31 - HTML whoops did that wrong
556:35 - so we'll cut that out of there
556:38 - and then in our component we'll just
556:40 - render that div right there
556:43 - let's clean all of these data IDs up
556:46 - because once again we don't need that
556:48 - since we're working in react now but
556:50 - pretty much anywhere that we have one of
556:52 - these data IDs means that we're
556:54 - registering it for a click listener so
556:57 - we'll have to set up those click
556:59 - listeners here so what I'm going to do
557:01 - for this menu is give it an on action
557:05 - property which is going to have an
557:08 - action type which will either be a reset
557:12 - or it's going to be a new round
557:15 - you could of course do this differently
557:18 - however you want I'm just simplifying
557:20 - things so that all we have to do is
557:22 - check the action type and then we know
557:24 - which of these buttons was clicked so
557:26 - we'll come down to the buttons
557:28 - themselves and we'll say on click
557:32 - and this one
557:35 - will be an on action
557:37 - oops we haven't passed the props yet so
557:40 - let's initialize these so there's your
557:43 - on action and then there's your props so
557:46 - that's grabbing from here and typing it
557:49 - out
557:50 - so now we can say on action and this
557:52 - will be a reset as you can see we get
557:55 - this typescript support because we have
557:57 - this Union type
558:00 - so there's your reset
558:02 - and then here's another click listener
558:04 - we'll say this one is going to be the
558:06 - new round
558:07 - so once again you could split this into
558:09 - two it's just stylistic you could
558:12 - comment this out and say on reset
558:15 - void and then on new round
558:18 - void and then replace these
558:22 - with those two different ones
558:25 - and then come down here and instead of
558:27 - passing
558:29 - the key we'll just say on reset and on
558:32 - new round and that would be the same so
558:35 - same thing just a stylistic concern so
558:39 - I'm going to go back to my original I
558:41 - like that a little bit so now we can
558:43 - throw the menu here where we took that
558:46 - jsx out so there's your menu and then we
558:49 - of course need the on action we'll fill
558:51 - that out in a second
558:53 - so let's import the menu command period
558:56 - to get vs code to do that for you you
558:58 - can see it got imported right there
559:01 - and then the on action for right now
559:03 - we're going to just put a placeholder in
559:05 - there
559:05 - and it's going to pass us an action
559:08 - because that's what we defined and we're
559:11 - just going to console log it for right
559:12 - now
559:13 - we'll eventually hook that up to
559:15 - something now if we go to our app when
559:17 - you click the actions menu you're going
559:19 - to see in the console it should and
559:22 - let's refresh oh we're not getting
559:24 - anything because we set those listeners
559:26 - on the menu items
559:28 - but we also need to listen for a click
559:31 - to the topmost menu so what we're going
559:34 - to do is put a click listener on the
559:37 - actions button
559:40 - and we'll handle this internal to the
559:43 - menu
559:43 - so we'll say whether this is menu open
559:46 - will be a piece of state that we're
559:48 - going to introduce using the use State
559:51 - hook
559:52 - and then what we'll do is we will look
559:55 - at the
559:57 - let's see
559:58 - we've got a function and we're going to
560:00 - set menu open
560:03 - and basically we're going to implement
560:05 - toggle functionality by looking at the
560:07 - previous state and returning the
560:10 - opposite of that so it's complaining
560:13 - about this because we haven't
560:14 - initialized this to anything so by
560:16 - giving it a false default State that's
560:20 - going to type our use State and this is
560:23 - Boolean
560:24 - because it's going to use type inference
560:27 - and it's going to initialize this to be
560:29 - closed but when we click that actions
560:32 - button it's going to basically toggle
560:34 - the menu open and closed we can verify
560:37 - this by going to the UI and clicking
560:39 - this and it's not going to do anything
560:41 - because we're not actually reading this
560:44 - menu open state
560:45 - we want to conditionally render this
560:49 - piece of jsx based on whether the menu
560:53 - is open
560:54 - now we have this leftover hidden class
560:57 - which we need to get rid of because that
560:59 - will override this Behavior so now let's
561:03 - open this up click actions and you can
561:05 - see we can toggle this back and forth
561:07 - the last thing is we need to look at
561:09 - this icon and remember in the the
561:11 - vanilla app we had this flipping
561:13 - depending on the open state
561:16 - so we can come down here where we're
561:18 - rendering that icon and basically say
561:21 - hey if the menu is open we're going to
561:23 - render something otherwise we'll render
561:26 - this
561:28 - so I'll copy
561:30 - this to both of them so right now it's
561:32 - going to be down on both but let's go
561:35 - ahead and put menu or Chevron up when
561:37 - the menu is open and Chevron down when
561:40 - it is closed
561:42 - so there you can see it flips now
561:44 - there's a slightly better way to do this
561:46 - and while we don't necessarily need this
561:50 - dependency it's something that I use and
561:52 - it's pretty helpful so we're going to
561:55 - add something called class names so
561:57 - we'll say yarn add class names this is
562:01 - just a utility really just a utility
562:03 - function is all this represents and if
562:07 - we use that
562:09 - we can refactor this code right here
562:12 - and
562:13 - in our class name
562:15 - we can import class names so we'll go to
562:19 - the top and say
562:22 - import class names from class names
562:26 - and you can see this is just a utility a
562:29 - simple JavaScript utility for
562:31 - conditionally joining class names
562:33 - together
562:34 - pretty common that you'll see this
562:36 - within react so now what we can do is we
562:39 - can say we always know it's going to be
562:40 - f a solid
562:42 - so that's similar across the two the two
562:45 - and then depending on whether the menu
562:47 - is open we will either use the Chevron
562:51 - up
562:53 - or the Chevron
562:55 - down
562:58 - and delete all this
563:00 - so now rather than conditionally
563:01 - rendering the entire element we're just
563:04 - conditionally rendering the class names
563:06 - which is similar to our original
563:08 - implementation so this is a good one for
563:11 - me to pause on and kind of show you what
563:14 - react is doing for you versus what you'd
563:16 - have to do in a vanilla app
563:19 - so if you remember so this is just the
563:21 - menu and if you remember in our vanilla
563:25 - refactor
563:26 - or actually let's go to the live TS
563:28 - refactors the latest one we did and we
563:31 - go to JS and look at the view
563:35 - and then let's go to the event listeners
563:37 - where we binded the click on the menu so
563:41 - this first one is where we're binding
563:44 - The Click event on the menu button
563:47 - and that let me let me just do this side
563:50 - by side so you can see it better
563:53 - so here's our react on the on the right
563:55 - and then vanilla is going to be on the
563:58 - left
563:59 - so vanilla react and you can see that
564:02 - let me zoom out just a little bit here's
564:05 - our actions button and here is our click
564:08 - listener on that button then here's the
564:11 - state that controls whether it's open or
564:13 - closed now that right there is the same
564:17 - as registering an event listener on the
564:20 - button over here in The View
564:23 - and then we're calling the toggle menu
564:24 - class which is down here somewhere in
564:27 - the toggle menu class is going to select
564:30 - the items in the button and toggle some
564:33 - Styles in a border and then figure out
564:36 - which icon to throw on that and that is
564:39 - being implemented right here where we're
564:42 - deciding which one which icon to put and
564:46 - then whether to show it as open or
564:49 - closed then furthermore when we come
564:51 - down here to the menu being open or
564:54 - closed here we're conditionally
564:56 - rendering the menu items based on
564:59 - whether it's open
565:00 - and you can see we have to implement
565:02 - this whole toggle menu and entire close
565:06 - menu to do that when it's pretty easy to
565:09 - just say like hey if that state is true
565:11 - then render it otherwise don't so that's
565:13 - just kind of how we can simplify our
565:15 - lives a little bit and then finally we
565:18 - have the action handlers where we
565:21 - register something that happens when the
565:24 - game resets or there's a new round
565:26 - and you can see that we will register
565:29 - that on the game reset right here so
565:32 - that's what we're doing with these on
565:34 - click listeners so just kind of a before
565:36 - and after look to see how We're
565:39 - translating things so at this point we
565:41 - can come back to our game and we can
565:43 - open and close the menu and if we click
565:46 - one of these we'll get something printed
565:48 - to the console telling us which one was
565:51 - clicked now we haven't actually handled
565:53 - those events yet but we will do those
565:56 - shortly at this point our app.tsx is
565:59 - pretty much done you could of course
566:01 - refactor this even a little more and add
566:03 - more components to clean this up but
566:06 - this is pretty readable at this point
566:08 - and I don't really want to try to go any
566:10 - further because there's no reason to
566:13 - so now we need to add the concept of
566:17 - state to our application and if you
566:19 - remember from the TS refactor we had
566:22 - this entire store class
566:25 - which was responsible for
566:28 - at the very bottom basically saving our
566:30 - state to local storage and then
566:34 - dispatching an event that said hey this
566:37 - state has actually changed and then the
566:39 - app.ts
566:41 - was listening for that event here and
566:44 - when it heard that event it would
566:46 - re-render The View with the new state
566:49 - now this whole process is totally native
566:52 - to react it is in if you think about it
566:56 - what this is really doing is the view is
566:59 - reacting to a state change in
567:02 - re-rendering something so the pattern
567:04 - that we've used here is a very
567:06 - simplified oversimplified version of
567:10 - what react is doing and what the purpose
567:12 - of react is
567:13 - we just had to do it in a much more
567:15 - indirect imperative fashion rather than
567:18 - the declarative fashion that we're doing
567:20 - it in by just you know saying like hey
567:23 - if this state exists like if show modal
567:26 - is true render the modal we really don't
567:29 - need to do anything more complex than
567:31 - that but because we're using react now
567:33 - just because we're using react does not
567:35 - mean that our state is going to like
567:37 - change its shape or anything we're still
567:40 - tracking the same
567:42 - fundamental types as defined here so all
567:46 - we can all we really need to do is
567:48 - redefine a use State hook that will keep
567:51 - track of that game state in the main app
567:54 - and then we'll read that state in our
567:57 - jsx to conditionally render things and
568:01 - make things happen and make it
568:03 - interactive since all of the state works
568:05 - together and none of it's like isolated
568:08 - from one another it makes sense that we
568:10 - would throw this in a single state
568:13 - variable
568:14 - so we're going to call it State and then
568:17 - just use the convention for a use State
568:20 - hook
568:21 - and we'll import that to react and we of
568:24 - course need an initial state that will
568:27 - pass here if you remember from the
568:30 - original so let's go back to the store
568:32 - the initial state that we passed was
568:35 - this right here so what we can do is
568:38 - just copy this object
568:40 - and paste it into the default or
568:43 - basically the the function parameter is
568:46 - going to be the default State now
568:48 - because we're passing this object shape
568:51 - to the use State hook use state is going
568:54 - to use typescript generics to infer the
568:58 - type of state and if you hover over
569:00 - State it's going to give you that object
569:02 - shape so we could explicitly Define that
569:06 - right here
569:07 - and put it in the generic and Define the
569:10 - type of state that we're dealing with
569:11 - but it's just easier to let it infer
569:14 - that and so now we have a strongly typed
569:17 - State object now this is where things
569:19 - get interesting so we have this state
569:22 - object and if you remember from store we
569:25 - are just mutating this state or changing
569:28 - it in a couple of places so when a
569:31 - player moves we are pushing a move to
569:33 - the current game moves array
569:35 - and when we reset the game we are
569:38 - pushing current round games to the
569:40 - history and then when we do a new round
569:44 - we're pushing to all the all games array
569:47 - so those are really the only places that
569:49 - we're changing the state and then the
569:51 - rest of it is going to be something
569:53 - called derived State and that is
569:56 - basically where you are constructing a
569:59 - different or you're constructing a set
570:01 - of information that you have derived
570:04 - from that raw State object and two good
570:07 - examples of this would be our stats
570:10 - getter
570:11 - and our game getter and in the previous
570:13 - refactor that's why I called that
570:15 - derived stats and derived game is
570:18 - because we're basically in both of these
570:20 - we're reading the current raw State and
570:23 - then we are calculating things and
570:25 - returning that to our application so
570:27 - that it can use that information to do
570:29 - things
570:30 - so same thing here we're grabbing the
570:33 - raw State and then calculating all this
570:35 - stuff we're calculating if there's a
570:37 - game winner the current player in the
570:39 - status of everything so this is all
570:41 - derived State and we can actually you
570:44 - know what you might be tempted to do is
570:46 - put you know derived State and then set
570:50 - derived state in some use State call but
570:54 - really you don't need to do that there's
570:56 - no point in doing that because now you
570:57 - have to keep these two State variables
571:00 - in sync with each other
571:02 - if you read through the react
571:04 - documentation it will kind of explain to
571:06 - you why that's a bad idea
571:08 - all we really need to do since this is a
571:10 - pure function is come down here and
571:13 - Define our game object and then we need
571:17 - to make a method to derive that so let's
571:20 - call it derive game
571:23 - and then we also need to derive stats
571:26 - not State we need stats
571:29 - so these are two empty functions that
571:31 - we've defined and here we're going to
571:34 - derive the game
571:36 - and then stats we're going to derive the
571:39 - stats now of course we need to pass the
571:41 - state object into each of these and it's
571:44 - going to yell at us because we haven't
571:46 - defined that as a argument
571:48 - so all we need to do here is say State
571:51 - and then we need to define the state
571:54 - shape now this is where we need to start
571:57 - typing it if we go back to our types.ts
572:00 - that we had defined at the very
572:01 - beginning
572:02 - we have this game State key that we can
572:05 - use so we can pass that here as game
572:08 - state
572:09 - and then import that as a type we'll
572:12 - also put it right here so state is game
572:14 - state
572:16 - and now when we pass the state object
572:19 - into derived game and derived stats it's
572:22 - going to accept it and at this point
572:24 - it's just a copy paste exercise we'll go
572:27 - back to our store which was again let me
572:29 - remind you this is from our prior
572:31 - refactor this is our vanilla application
572:34 - not our react one all we need to do is
572:36 - grab from stats we can copy the return
572:40 - type of stats
572:42 - and then in our derived stats we'll just
572:45 - return that and now we're no longer
572:47 - referencing this dot player that is
572:50 - going to be we need to Define that so
572:52 - we'll do that up here so if we go back
572:55 - to store I think we have a players array
572:58 - or no this was in our original app is
573:01 - where we put that
573:03 - so here's our players config so let's
573:06 - copy that
573:07 - to the top of our app.tsx file
573:12 - so there's our players config and then
573:15 - now we can just grab that from that
573:18 - scope the global scope here and map
573:20 - through it and we have a derived stats
573:23 - object so before we get any further
573:25 - let's just console that log this so
573:27 - console log stats because we've
573:29 - implemented that function
573:31 - and if you go to the console here and
573:35 - refresh you'll see that we have printed
573:39 - this here twice and the reason that it
573:41 - gets printed twice is because we are in
573:44 - strict mode so if you go back to entry
573:47 - point and see this wrapper right here
573:49 - when we're in strict mode react is going
573:52 - to re-render each component two times
573:55 - and that is to catch bugs that happen
573:57 - and I'm not going to go too far into
574:00 - that but that's why we're getting both
574:02 - of these re-renders not just one
574:05 - but anyways we get the player with stats
574:07 - and this derived object where it says
574:10 - player one has zero wins and player two
574:13 - has zero wins and there are zero ties
574:17 - so just with that information we can
574:19 - start to populate our react application
574:24 - so if you go down here to the bottom you
574:26 - can see that we have this static numbers
574:29 - down here denoting who has what number
574:32 - of wins so what I'm going to do is grab
574:35 - the stats array and we know from our
574:39 - config that player one is the zero index
574:41 - and player two is the one index of that
574:44 - array
574:45 - so all I'm going to do is interpolate a
574:48 - variable here and we're going to grab
574:51 - the stats derived state
574:53 - and we're going to look at the players
574:55 - with stats and grab the first player and
574:58 - then we're going to print the number of
575:00 - wins in that slot right there
575:04 - then we can also throw the number of
575:06 - ties so stats dot ties
575:09 - and then finally
575:11 - stats.players with stats we'll grab the
575:14 - first index which is player 2. and pass
575:17 - in wins right there
575:19 - so at this point our player one ties and
575:22 - player 2 are getting dynamically
575:24 - populated and that part is done so the
575:27 - last thing that we need to do is
575:29 - Implement our derived game
575:31 - function right here and we can do that
575:34 - by another copy paste so store.ts from
575:38 - our original project not the react one
575:40 - we had this getter called game
575:43 - and that was basically just
575:45 - recalculating some things and returning
575:48 - some derived state
575:51 - so let's paste that in there
575:55 - we need to reference players from the
575:58 - global scope here and there you have it
576:00 - I think that should be pretty much it
576:02 - we're referencing state right here and
576:06 - that should work so now if we print the
576:10 - game so console log game and refresh
576:13 - here's the game we've got the current
576:15 - player which is player one
576:17 - there are no moves yet and the status is
576:21 - complete is false there's a couple
576:23 - things we can do now let's get rid of
576:25 - this console log and let's also get rid
576:28 - of this show modal static variable so
576:31 - get rid of that we can grab that from
576:33 - the game derived State now
576:36 - so instead of show modal what we can say
576:39 - is hey is the game dot status
576:44 - complete
576:48 - and if the status is complete then we're
576:51 - going to open up the modal and instead
576:54 - of a static message we will say game dot
576:58 - status I think we're going to need to do
577:00 - this dynamically so if there is a winner
577:04 - we're going to say
577:06 - game.status.winner dot name
577:10 - wins
577:12 - otherwise it's going to be a tie so you
577:15 - can see how we're just reading directly
577:17 - from the state
577:19 - to get what we need whether we need to
577:21 - render this and open it up and what the
577:24 - message should be when it happens but of
577:26 - course this isn't going to matter if
577:28 - we're not rendering it within the game
577:30 - itself
577:30 - so now what we can do is read the
577:34 - current state in the current game and
577:36 - figure out which squares need to be
577:38 - populated
577:39 - so right here remember this is where we
577:43 - are looping through all nine of our
577:45 - squares on the game board
577:47 - and rendering an icon if there's a move
577:51 - in that slot so what we can do is grab
577:54 - an existing move
577:57 - so let me show you where this originated
577:59 - from
578:00 - so if we go to our original project and
578:05 - we go to the app.ts
578:07 - I believe that's here you can see that
578:10 - when a player moves we are checking for
578:13 - an existing move and if there's an
578:16 - existing move we are returning because a
578:19 - player can't click that twice and then
578:21 - we are calling Player move furthermore
578:23 - in The View
578:25 - to figure out you know which squares
578:28 - need to have icons we have this
578:30 - initialize moves method and what it's
578:33 - doing is it's saying for each Square on
578:36 - the game board see if there's an
578:38 - existing move and if there is an
578:40 - existing move then we're going to
578:42 - basically simulate a move and populate
578:45 - that square
578:46 - so with react all of this logic is way
578:50 - easier to do so we can basically just
578:52 - copy that logic right here
578:55 - and we're not looking at moves we're
578:58 - looking at we need to look at the
579:00 - current game
579:01 - moves and now the square ID is already a
579:04 - number so we can just replace this
579:06 - entirely with square ID So within this
579:09 - map function we're figuring out if
579:11 - there's an existing move and if there is
579:14 - an existing move
579:16 - we're going to render
579:18 - that icon there now also remember on
579:21 - each move we are we have the player
579:24 - object available to us
579:27 - so let's refactor this right here the
579:30 - class name on this icon
579:32 - rather than a Static X that is turquoise
579:35 - we can use class names so we'll wrap
579:38 - that
579:40 - and let's just start over here so it'll
579:44 - be fa solid no matter what and then
579:47 - we're going to take the existing move
579:48 - grab the player and then give it the
579:52 - color class and then we'll also take the
579:54 - existing move dot player dot icon class
579:59 - and that will tell us what color and
580:02 - what icon to render right here if there
580:05 - is an existing move so now if we go back
580:07 - to our game the board is going to be
580:09 - empty and we still can't click anything
580:12 - because we haven't listened for that
580:14 - event so the last thing that we have to
580:17 - do to make this game interactive is add
580:20 - a click listener
580:22 - on this div for this square that we're
580:24 - listening for so we will attach a
580:28 - callback function to this
580:31 - and we'll say if there's an existing
580:33 - move
580:35 - we're going to return early
580:37 - so we're reusing this that we
580:40 - established up here so if there's an
580:42 - existing move don't do anything
580:44 - otherwise we need to handle the player
580:46 - move and this is going to require all
580:50 - the logic for handling a Player move so
580:53 - I'm going to separate this out into a
580:57 - hand handle Player move function and
581:00 - then I'm going to pass it the square ID
581:03 - of the clicked Square
581:05 - and then I'm going to grab the game dot
581:09 - current player and then we need to
581:11 - Define this function now
581:13 - so we'll come up here
581:15 - and we'll say function handle Player
581:17 - move it's going to take a square ID
581:19 - which is a number
581:21 - and then it will take the what do we say
581:24 - the current player
581:25 - so player is a player
581:29 - so now what happens is if there's an
581:31 - existing move return early otherwise
581:34 - handle the player move and that's going
581:36 - to be defined in this function right
581:38 - here so thinking back to our prior game
581:40 - how did we handle a Player move
581:43 - well let's go to the view this is our
581:46 - original game not a react app anymore
581:48 - and looking at the view this is actually
581:51 - not what we should be looking at because
581:53 - this is all handled by react we already
581:55 - implemented that so we need to look at
581:57 - the store
581:59 - so here is the player move Handler
582:02 - basically what we're doing is we're
582:04 - getting a copy of State we are pushing a
582:07 - move to the current game moves and then
582:09 - we are saving that state so
582:12 - let's go ahead and just copy that
582:16 - paste it here and instead of this dot
582:19 - get state
582:20 - we will just grab actually let's comment
582:23 - this out for just a second
582:26 - when a player moves we know that we need
582:28 - to set the state so let's call set State
582:32 - and to get the prior state that we need
582:35 - to deal with we can pass a callback and
582:39 - this previous will represent the prior
582:42 - state from the prior render snapshot
582:45 - so we can access that here
582:48 - so if we wanted to now place this logic
582:51 - in the set State callback and uncomment
582:55 - it we can do a structured clone of the
582:58 - previous state right here
583:00 - then we can push something to the
583:03 - current game moves and then instead of
583:05 - saving State we will just return the
583:09 - state clone from this set State callback
583:12 - and then the only thing we update here
583:14 - is we're grabbing this from the argument
583:18 - so player goes directly here
583:22 - and then what's it complaining about
583:23 - this argument is not assignable to
583:26 - parameter of type never and it's saying
583:28 - that current game moves is of type never
583:30 - array and that's because we did not
583:33 - explicitly type this as a game move
583:37 - so now we'll come through and actually
583:40 - type this out a little bit and if we
583:43 - wanted to what we could do
583:45 - is just cast this we can say as game
583:49 - State and game state is from our
583:51 - types.ts right here
583:54 - so we can cast that to a game State
583:57 - object and that's going to fix this
583:59 - because now it knows that the current
584:01 - game moves is a move array you could
584:04 - either do that or a better way to do it
584:06 - is just say use state is of type game
584:09 - State and now that will explicitly say
584:12 - like hey the object I'm assigning here
584:15 - is of type game state so now if we
584:18 - handle the player move we should start
584:20 - to see some interactivity here
584:22 - so you can see that our app is starting
584:24 - to work and it detects a player win now
584:28 - if we click play again it's not going to
584:30 - do anything and that's because we
584:32 - haven't set an event listener on the
584:35 - modal
584:36 - so if we command click the modal to open
584:38 - that file
584:40 - you can see that we're going to need an
584:42 - on click Handler
584:45 - and that's going to happen when the user
584:48 - clicks play again so on click and then
584:51 - we'll pass it that on click Handler
584:53 - which is going to be in props so this is
584:57 - really just a way of us to basically
585:00 - tell the outside world that's consuming
585:02 - this modal component hey there's an
585:04 - event and it's an on click event that
585:06 - means that the user wants to play again
585:10 - so now we'll come down here and we'll
585:11 - say on click and we need to do something
585:15 - to close the modal and update the state
585:18 - so in this case we need to reset the
585:20 - game
585:21 - so reset game but the problem is we
585:24 - don't have this implemented yet so
585:27 - similar to how we implemented the handle
585:29 - Player move we will also say reset game
585:34 - oops
585:37 - and now this is going to be a function
585:39 - that we'll call when that modal is
585:42 - clicked so similar to how we are just
585:44 - calling set State and using the previous
585:46 - state to find our next state we can do
585:50 - that here in reset game so set state
585:52 - will grab the previous state and now we
585:55 - have to do something with that previous
585:57 - state and derive something and return
585:59 - the new state that we want the game to
586:02 - be in once again we have already
586:04 - implemented implemented this in our
586:06 - prior refactor so let's go back to
586:10 - store.ts which is where we implemented
586:13 - this and you can see that we have a
586:15 - reset method and then we have a new
586:17 - round method we can pretty much combine
586:20 - these into the same method and just have
586:23 - like a Boolean check to see whether it's
586:25 - a reset or new round
586:27 - so let's first copy over the reset
586:31 - so we'll paste that in
586:33 - and instead of get State we're just
586:35 - going to pass the previous Right Here
586:37 - and Now what we're going to do is we're
586:39 - going to read from the game which is our
586:42 - derived state
586:44 - and we're going to destructure the
586:47 - status in the moves from there
586:49 - and then finally we'll return the state
586:52 - clone
586:53 - which will set that new state for us
586:56 - now like I said in our original we had a
587:00 - reset in a new round
587:02 - so all we have to do is conditionally
587:05 - let's just add a prop or not a prop but
587:09 - a parameter up here and say is this a
587:11 - new round
587:12 - and have that as a Boolean so if we come
587:15 - down here to this reset game we're going
587:18 - to say that's false it is not a new
587:20 - round it's just a game reset and then if
587:23 - you remember from our menu we have this
587:26 - on action so
587:29 - what we can say here is we want to reset
587:32 - the game and then to detect whether this
587:35 - is a new round or not we'll just say
587:38 - does the action equal new Round And if
587:42 - that evaluates to true then we have
587:44 - reset the game otherwise it will
587:46 - evaluate to false and that'll just be a
587:48 - plain old reset
587:50 - so we've hooked up this listener we just
587:53 - have to implement that have to actually
587:55 - use this variable to figure out what to
587:57 - do so all we need to do is come down
587:59 - here after we've reset the current game
588:01 - moves and we'll say if this is a new
588:05 - round so is new round
588:07 - we also want to push to the history so
588:10 - we'll say State clone dot history
588:13 - and then all games
588:15 - and then we'll basically just push and
588:18 - spread the state clone
588:22 - dot history dot current round games
588:27 - and then we will set that
588:30 - current round games equal to an empty
588:33 - array so if there's a new round we're
588:35 - also going to reset that so at this
588:36 - point we've got the reset game completed
588:39 - and I think this is the majority of the
588:43 - logic so let's go try our game out
588:47 - so it detects a win and if we click play
588:49 - again it closes things everything resets
588:52 - and down here player one has one win
588:55 - let's get player two to win one so
588:57 - player two wins we play again player two
589:00 - has one win
589:02 - let's click a square reset that it seems
589:06 - to work let's go ahead and reset the
589:09 - scoreboard down here
589:11 - and that seems to work as well
589:13 - so I think we're pretty much done let me
589:17 - just kind of pause the video here and go
589:19 - through and see if there's any cleanup
589:20 - that we need to do and then we'll be on
589:23 - our way okay so there's actually one big
589:24 - thing that I forgot to come back to and
589:27 - that is local storage at the moment
589:29 - we're not persisting this game across
589:31 - browser refreshes
589:34 - so let me let me collapse some things
589:37 - we'll collapse the players derived game
589:40 - and derive stats
589:42 - we will collapse reset game and handle
589:45 - Player move just to hide them from our
589:47 - view and you can see with our use State
589:50 - hook this is where we're storing the
589:52 - state of the game so if we were to play
589:55 - a couple moves and then refresh this
589:57 - browser it's going to basically reset
590:00 - everything because we're not storing
590:02 - this to local storage any longer and
590:04 - then furthermore I realized that this
590:06 - turn indicator is not implemented so
590:10 - let's go ahead and do that we'll get rid
590:11 - of these data IDs because we don't need
590:13 - those anymore and then this becomes
590:15 - pretty easy so we just add class names
590:19 - around this
590:22 - so fa solid and then we will just figure
590:26 - out whose turn it is by saying the game
590:29 - dot currentplayer.color class
590:33 - game.currentplayer.icon class
590:35 - save that
590:37 - and so now this will be dynamic and then
590:40 - finally we need to just replace this
590:41 - right here with the game
590:45 - Dot currentplayer.name
590:48 - so this should make the color the icon
590:50 - and the name Dynamic let's make sure
590:52 - that that's correct
590:54 - looks like everything's working except
590:56 - for that part
590:58 - because we have this as a static style I
591:01 - think maybe an easier way to do this is
591:03 - just remove this class name altogether
591:06 - remove that from there and then
591:09 - use the entire div to
591:12 - specify the color so we'll say
591:15 - game.currentplayer.color class is going
591:17 - to apply to the entire div which will
591:20 - style its child elements and then we're
591:23 - toggling on the icon
591:25 - so player one player two player one and
591:29 - seems to be working now
591:31 - and once again the last thing is local
591:33 - storage and this is something that I'm
591:36 - not going to spend a ton of time on the
591:38 - implementation to but there is a way
591:41 - that you can extract the local storage
591:44 - function to a react hook
591:47 - so we can basically make a replica of
591:51 - use state but instead of just using
591:54 - state it will also keep it in sync with
591:56 - local storage
591:57 - and in that manner we can use we can
592:00 - basically have the same interface while
592:02 - getting that additional functionality so
592:05 - just so that we're not getting into
592:07 - crazy detail or anything we already did
592:10 - we already do that in these videos
592:12 - I'm going to go into source and make a
592:15 - hook called uselocalstorage.ts
592:19 - this is a react hook you can learn more
592:21 - about this if you are in the react Docs
592:25 - and go to the beta docs then the new
592:28 - ones and then you can go to should be
592:31 - some hooks a hooks reference somewhere
592:33 - let's go to the reference so you've got
592:35 - the built-in react hooks
592:37 - I don't know if it does say anything
592:39 - about like custom Hooks and how you
592:41 - would do that
592:43 - oh here reusing logic with custom hooks
592:46 - this is a good place to check out what
592:48 - I'm about to do and understand
592:51 - why we would do this but I'm just going
592:54 - to copy paste everything in here to this
592:56 - file this is a use local storage hook
592:59 - you know basically what we're doing is
593:02 - we are adopting the same interface as
593:05 - the use State except we are also keeping
593:09 - it in sync with local storage and you'll
593:11 - see right here this is where we're like
593:14 - setting a value to local storage this is
593:17 - where we are getting the value from
593:19 - local storage and then in the parameters
593:22 - we'll pass the key that we'll use to
593:25 - track that in local storage
593:27 - so I've documented this a little bit you
593:29 - can read through it on your own time
593:31 - it's not necessarily super important to
593:33 - understand all the internals here I'll
593:35 - also note that I've added this effect
593:37 - right here that basically keeps track of
593:40 - other tabs that change
593:42 - so if you were let me close some things
593:45 - out and if you went back to our original
593:48 - implementation app.ts this is not the
593:52 - react app this is the prior videos
593:55 - you can see that we're listening for the
593:57 - state change this has pretty much become
593:59 - irrelevant now that we're using react
594:01 - because that is kind of built into the
594:04 - Paradigm of react but we also have this
594:06 - where we're listening to the local
594:08 - storage of another Tab and re-rendering
594:12 - the view if that changes so I've created
594:15 - this effect here which does the same
594:17 - thing and it will update the state
594:19 - variable every time another tab changes
594:22 - its state so I will close this
594:25 - and you'll see how easy this is we'll go
594:28 - back to our app.tsx and we'll just
594:31 - comment out this original state and all
594:34 - we need to do we can name it the same
594:37 - thing so set state state and set State
594:39 - and now instead of use State we're going
594:42 - to use local storage and import that
594:45 - now it's going to ask us for a key so
594:48 - we'll say game State key
594:52 - and then it will ask us for our initial
594:54 - value which is going to be this right
594:58 - here the same thing that we passed
595:00 - earlier so we'll uncomment that so
595:01 - you're going to see how quick and easy
595:03 - this is to update so remember if we go
595:07 - to our react game play some moves and
595:11 - refresh
595:12 - not going to work
595:14 - but all we have to do is replace use
595:16 - state with use local storage and import
595:19 - that from our file
595:21 - and then we need to give it a game State
595:26 - key that's just the key that will be
595:28 - used in local storage as that first
595:31 - argument and then our default value is
595:33 - the second
595:34 - and that should do it that will keep the
595:37 - state in sync with local storage and we
595:40 - don't even have to think about it so we
595:42 - can play the game refresh and it will
595:45 - find the state that we're in after a
595:48 - refresh you can also duplicate the tab
595:50 - play something over here and then that's
595:53 - going to sync up over on this side and
595:56 - vice versa
595:57 - so now that we've got it synced up with
595:59 - a local storage I think we have
596:01 - replicated that original application in
596:04 - full so the last part of this is just
596:06 - going to be some cleanup and making
596:08 - things easier to kind of find and read
596:10 - through
596:11 - so let's go through and look for any
596:13 - like data IDs we don't need any of these
596:16 - because that was a paradigm from
596:19 - the original implementation where we
596:22 - needed a stable way to select
596:24 - a Dom element
596:26 - so we'll get rid of all those let's go
596:28 - through our components
596:30 - should be okay there on the menu
596:35 - no data IDs there and we're good
596:39 - and then furthermore we can just extract
596:42 - some of these things out so let's make a
596:45 - file called
596:46 - utils.ts this will just be some utility
596:49 - functions
596:50 - and if you remember we have this derived
596:53 - derived game and derived stats and then
596:57 - we also have the players up here outside
597:01 - of our component itself
597:04 - so we can take all of this stuff
597:09 - you could leave it here there's no
597:10 - problem with that either but I can throw
597:13 - all that into a utils file
597:15 - and then we can export them from it okay
597:19 - and then we just need to import a few
597:21 - types from the types file
597:24 - so we'll import the player and then the
597:26 - game state
597:27 - and that should satisfy these functions
597:30 - so those are now isolated to the utils
597:33 - file and then we of course need to
597:35 - import them so command period to import
597:38 - from utils
597:40 - do that again here and you can see we've
597:42 - got that import
597:44 - and that should work okay so that kind
597:47 - of cleans up our app file
597:49 - we no longer need use State because
597:51 - we're doing the use local storage hook
597:53 - which uses State under the hood so we'll
597:56 - expand this out and this is pretty much
597:58 - the final game once again you can find
598:00 - all of this code in the repository I've
598:02 - left in the video description be sure to
598:04 - look at the typescript branch to find
598:07 - this exact implementation I just did
598:09 - there's also a non-typescript version of
598:12 - the same app so now that we're done we
598:15 - can close out this develop developer
598:18 - server the webpack dev server and a good
598:21 - thing to do is always to just check to
598:24 - make sure that it builds correctly so we
598:26 - have these build scripts and let's just
598:28 - run yarn build
598:32 - and what this will do is basically check
598:34 - all your types type checking compile
598:37 - everything bundle it up and output it to
598:40 - the public directory with bundle.js
598:43 - and we can also try the build prod to
598:48 - make sure that it does its optimizations
598:49 - okay and it doesn't complain about
598:51 - anything
598:52 - so there you go and then finally we've
598:55 - got live server running on Port 5500
598:57 - already and since we just built this app
599:02 - it's totally static and you can actually
599:05 - view this directly from the public
599:07 - directory rather than using the webpack
599:11 - dev server
599:12 - so you can think of it as webpack came
599:15 - in did its job compiled everything
599:17 - transpiled everything and gave us one
599:20 - nice clean bundle output and now we're
599:23 - just ready to go we've got what we need
599:25 - and the browser knows how to load the
599:27 - app
599:27 - so let's go back to the browser
599:30 - and we'll go to localhost 5500 close
599:34 - everything out and I know we've got a
599:36 - lot of folders here but let's go to the
599:38 - live react refactor and then if we click
599:42 - public it should give us the game and we
599:46 - should be able to use it just like we
599:49 - were with the dev server so we can reset
599:51 - we can get a new round going and just
599:54 - play the game so just wanted to show you
599:57 - that's a good thing to do check your
599:59 - build make sure it works and then you
600:01 - could really just you could deploy that
600:03 - this game right here over any CDN
600:06 - because it's static assets so you could
600:09 - put it on cloudflare you know whatever
600:11 - you want and it can be served to your
600:13 - users thrown on GitHub Pages what have
600:16 - you
600:16 - so hopefully this was an educational
600:19 - video that hopefully you enjoyed seeing
600:22 - how we can go from a vanilla JavaScript
600:26 - application and Port that over to react
600:29 - and kind of see the benefits of using
600:32 - react it makes a lot of our code a lot
600:34 - simpler we basically went from let's
600:37 - just kind of recap we went from this
600:39 - live TS refactor where we had an app
600:44 - let's just close all this out you can
600:46 - just scroll through this is our main app
600:48 - file where we're registering all the
600:51 - event listeners controlling everything
600:54 - this is our state
600:56 - where we have our store class
600:59 - and this is our view where we are
601:02 - handling selecting all the elements up
601:04 - here
601:05 - we are rendering here so this basically
601:08 - what react is doing for us and then
601:10 - we're binding event listeners got all of
601:13 - our helper methods here and all of this
601:16 - stuff it's pretty verbose what we've had
601:18 - to write here we even have the delegate
601:20 - method so that we could figure out which
601:22 - Square was clicked and that was pretty
601:24 - confusing so we've gone from this
601:28 - over to our react application which as
601:31 - you can tell if we go to app.tsx
601:34 - it's pretty concise what we've got here
601:37 - we don't have any delegate methods we
601:39 - can just handle everything
601:41 - basically right here with some event
601:43 - handlers we've got a hook that helps us
601:46 - deal with local storage and then we have
601:48 - our components split out by their
601:51 - separate concerns also with their
601:53 - separate CSS so that's just a much
601:57 - cleaner way to write an application and
601:59 - it's a lot easier to extend into the
602:01 - future let me know what you thought of
602:03 - this video be sure to give it a like And
602:05 - subscribe to the channel and I will see
602:07 - you next time

Cleaned transcript:

Zach galwitzer created our extremely popular frontend web development boot camp course now he's back with this projectbased course that will help you solidify your understanding of a variety of frontend web development Concepts you'll practice HTML CSS JavaScript typescript react and more so let's get started hey free code Camp my name is Zach and today I'm really excited to share a video I've been working on for a while where I take a tictactoe game and build it in vanilla JavaScript HTML and CSS and then refactor that to go to typescript and then finally typescript plus react this is going to be a super fun tutorial it's going to be long but I hope that you're going to learn a ton from this and get some practical Real World Experience building this with me now this is actually what I would call kind of a sequel to another video that I posted on this very Channel free code Camp a couple months ago I posted a frontend developer boot camp and since then it has gotten over a million views so thank you all for watching that I'm glad that you enjoyed it this video is meant to be a direct followup to that because all the lessons that you learned throughout are going to be applied in this video we're going to take all of that stuff and put it into action and give you a project that is a little bit more real world a bit more challenging but a great learning experience as always want to give a big shout out to free code camp for allowing me to come on the channel and giving me the exposure to to teach a broader audience I have a smaller Channel myself you can check that out got a link in the description and I will also make a note that this video is actually three videos squashed together so I originally posted these three on my channel this is just all combined so if you kind of hear me talking about the next video or the previous video that's why and finally there is a GitHub repository I'll mention this a couple times in the description that you should check out as it's got all of the source code that I will be writing in this project as well as some attribution because this was actually originally a subscriber refactor I react I reached out to my subscribers and said hey submit your code I'll review it and redo it and show you how I would approach it so that's how this originally started so thank you Yvonne and Meg for submitting that their handles are also in that GitHub repository so without further Ado let's jump in and build this tictactoe game in this video I'm going to walk you through the stepbystep process of building this tictactoe game which is mobily responsive you can play it on a mobile device and it works across browser tabs leveraging local storage so that you know you can have different players playing from different browser tabs and it also is going to have a bunch of different things such as some animations going on up here you've got some an actions menu that allows you to reset the game and then once you get through and start recording different wins so you don't really have to play on these separate tabs but you can once someone wins you'll see a modal pop up and gray out the entire background and you can click play again you'll see that that state is tracked over time and even if we refresh the browser tab that's going to stay there you can even reset that and make it a new round all of the code that I'm writing here is going to be in this tictactoe subscriber refactor repository that is on my GitHub and I'll drop that in the video description all right so this video is going to cover all sorts of Concepts um this is actually loaded with useful Concepts doing anything with vanilla JavaScript HTML and CSS really requires you to think about things because you don't get all of the backstops that some libraries and Frameworks like react or vue.js give you so it will really require us to think a bit but it will be fun to explore some different concepts and patterns for example we're going to be looking at what is a MVC architectural pattern or model view controller we're going to be talking about what is State what does that actually represent we're going to talk a little bit about event delegation so in other words what that means is when you go to this game and you click one of these squares it's actually registering a click listener on the parent component and then delegating that event so that we can find which Square was clicked so that will be fun to go through mobile responsiveness as I showed you some CSS animations that uh tictactoe grid is actually using CSS grid and then a lot more so all of these Concepts will be fun to go through and if you are not familiar with HTML CSS in JavaScript I recommend you go through my full stack which kind of became a frontend development roadmap and it's like over 21 hours and it's all posted on my channel here and I'm probably going to put this video as the next video in that series because it is a perfect transition from all of those Concepts that we covered throughout that series and applying them in a very real world type scenario to build this game out so this is kind of doubling as a subscriber refactor and just a very useful project to build and learn a bunch of cool concepts with but you definitely have to know HTML CSS in JavaScript at least at a basic level to get through this video and I recommend you watch the prior video where I kind of walk through the original project that this was based on and I kind of talked through what are some of the good things that they did there what were some of the things that could be improved and I'll be referencing kind of back to that to kind of show how we can improve on certain things so I recommend you at least watch the first part of that video or kind of skim through it now I will forewarn you I've put that this is a beginner to intermediate level video um because we're going to be covering a lot of ground here this will be very challenging to you if you are just kind of starting out and I did this on purpose because I think there's not a lot of tutorials out there that really focus on the vanilla side and vanilla just means no extra Frameworks or libraries involved I don't think there's a lot tutorials out there that really show you how to take a vanilla app and actually put some design patterns behind it and do it in a way that you could extend it into the future and you can come back to this project and understand what's going on and have a quick straightforward way to add new features to the game with all that said let's get started this is going to be a long and fun video so I'll put some time stamps in there and um probably want to grab a hot drink and get situated because this is gonna it's gonna take a while so um these brand or this uh repository is the repository that I will post in the put in the video description it has the completed projects so you can see I have a reactory factor that'll actually be the next video where we take our build from this video and we throw that into well not throw it we rebuild it as a react application and show you kind of the progression of how do you go from vanilla to react and what are some of the commonalities and differences between the two and it will really help you understand why we use something like react and why it makes our lives easier as a developer so that's what those are the original is the original project just as a reference um but what I'm going to do is actually create a new folder uh live vanilla build and this is where we're going to be working out of for this video I'll basically be recruit recreating everything here in the vanilla refactor and I may reference this um a little bit here and there just so that we're not getting too far off from that code so just as a forewarning the live build that we're going to do might have like some tiny little differences between the final state that you see on GitHub but overall it will go in the same exact Direction all right so what is the first thing that we do when we start a new project well we're doing a frontend project here so the natural thing to do is create an index.html document but before that I want to do some administrative stuff um with Visual Studio code I'm going to assume that you are using visual studio code um and the reason is because it's an awesome editor and most people use it so the first thing you'll need to do is go over to extensions and open up live server this is an extension that basically allows you to view HTML documents in your browser on Port 5500 is the default so you can see that's already running let me go ahead and click close so that'll dispose that um let me get these windows figured out here okay so if you see I reload this it won't reload let's go ahead and close that and then if you go down get rid of my bar down there if you click go live once this live server is installed with Visual Studio it will open up Port 5500 so let's go to this and it'll show you just the directories you're working with so it's just replicating this right here and what we're going to do is click on the live vanilla build right now it's empty so it's not going to show anything but what we're going to do is create an index.html file so we'll say index.html and then we'll use vs code's builtin emit Snippets to type HTML and then we'll click HTML5 to get some boilerplate built out for us now the second thing that I'm going to show you is format on Save and this should be really part of your Dev workflow no matter where you go because it's just useful so as you can see this boilerplate is not indented correctly and when I click command s on my Mac to save you can see that it formats this document so the way that I got that working is through another extension called prettier and prettier is a code formatter used by pretty much everyone at this point or at least it feels like so it's a very industry standard and what you can do is hit command P hit the little bracket or not bracket whatever that carrot and type open user settings and it's right here because I've used it recently don't worry about all this stuff these are the only lines that really matter so you'll add these two configuration lines this is also documented uh in the extension it'll show you right here that you need to add those and once you've added the added those it's going to detect every time you save and reformat the file all right so that is kind of the administrative stuff that we're dealing with um I don't think I missed anything so make sure that you you get set up with both of those things so now that I have saved this we can go back to our live server and we should have an empty HTML document so if you inspect you can see that here the elements and let's just go ahead and change this to vanilla Js T3 for Tictactoe and then we'll go ahead and just put a placeholder P tag in there so you can see something and you can see that when we save that it auto loads um or it you know has hot reloading so that all the changes are reflected immediately in the browser alright so the very next thing that I will always do when I'm starting a project and this is really kind of the starting point for me at least for any project whether we have a back end involved if it's full stack or just like we're doing here where it's just front end I'm going to start with the UI and build the layout for the entire application and I actually have a video on that that kind of explains that process in depth in my front end course on this channel so you can go revisit that if you need but basically the goal here is to build out the HTML structure and then build out the layout with CSS now I debated this in my head a bit of how much time I was going to spend on this portion of the video and I ultimately decided that this is going to be deprioritized a little bit so that we can focus more on the JavaScript patterns behind all this I have plenty of previous videos where we go in depth like in excruciating detail of how to build HTML and CSS how to bring those together and design things and if you watched my front end course the last um a series of videos in that course was all about CSS grid so we're going to leverage that we're going to use that in a real world project here but I am not going to be getting into every last little detail we're going to take some Liberty and do a little bit of copy pasting from this um vanilla refactor that I've already built um as as kind of a precursor to this video that said we're going to take it piece by piece so that you can at least see how it's coming together in the thought process behind that but I will not be typing the HTML and CSS line by line because we will be here for the next 10 years if um if if I do that my videos are already quite long and they do not need to be longer especially when this is not what we're focusing on so let's go ahead and do some copy pasting here so if we look at this index.html this is the final HTML of this project the one that we're going for so the first thing I want to focus in on is the grid so that's the hardest thing to conceptualize with building this out and when I say that grid we're going to actually duplicate this tab so that we have a reference to look at and my vanilla refactor will give us that complete picture that we want and so what we're trying to do here is build a grid that has all of these squares here but then as you can see there's also these uh State variables down here I shouldn't call them State variables but a little scoreboard that lines up perfectly with this grid and something a little bit less obvious up here the actions menu also lines up perfectly with the grid and this player one you're up indicator this spans kind of two sections of the grid so really what we've got here and what we need to replicate is a grid that is let's count it you've got three columns so one two three and then the number of rows is going to be one so this this top kind of header section is going to be one section of our grid then two three four and then this five bottom one so really what we have is a how does this go which one goes first is it the five by three or three by five grid um hard hard to remember that while I'm talking here on video but that's basically what we're going to be building and if I Collapse this finished document so vs code has these code collapse things that can really help for to see kind of how things are structured um so what we can do is collapse everything until it's a lot more clear as to what the grid items are so you can see that my container has a class of grid and that grid is going to give us the display grid so if we go to our index.css and we go to the grid class you'll see that that is initializing the grid container um and let's go back to this HTML and then as we know if you watched that previous series on grid is that grid is going to have child Elements which are called The Grid items now these are direct descendants of its container and as you can see we have one two and then there's nine of these squares and then there's three little scoreboard squares there at the bottom so that's the basic structure but we are not going to start with all of these different styles and markup you want to start simple and the way that we're going to do that is by creating a bunch of divs and just starting with a basic grid here in order to do that we need an index.css file so if you see in the vanilla refactor we've got some folders for the different types of files you don't really need that that was just an organization thing for this rebuild I'm just going to try to mirror that so we'll create a CSS folder and then a new file in there called index.css and then let's go ahead this is something that I always do let's just throw uh an all selector and then color red and that means every text everything is going to be or all the text is going to be red and the reason I do that is just to make sure we're hooked up correctly so let me close all these files out out this index.html is our starter you can see I have a placeholder here and what I need to do is right above the title we're going to add a link and we're going to go down and hit enter on the link CSS and you can see it already knows to go grab the style.css but that's not what we want because we have a custom directory so let's go to CSS and select index save that and now if this is hooked up correctly this should be red so let's go right here and you can see that it is red and it is connected up so the very first thing that we need to do is put in a main HTML tag and the reason that we put the main tag in there is because this should represent the dominant content of the document now if you wanted to figure that out on your own you can just type in mdn main so mdn Main and it'll be the first result and it says it represents the dominant content if you scroll down here on the usage notes it says it should be unique for the document content that is repeated such as sidebars nav links copyright should not be within main so in our case this tictactoe board is the dominant content of this index.html document so we want it inside Main furthermore we'll need a div container which will be the grid container itself and we want to give that a class of grid which we will style within index.css but if you remember let me hit command B on my Mac to close out that sidebar if you remember on this original we had the grid class and then we had all these grid items so we had one two um nine more right here so 11 12 13 14. if I can count basic math right but basically we just need a bunch of divs within here so we can make one command C copy that all the way down and how many is that three six nine eleven okay we'll we'll come back to this if we didn't get that right but anyways we've got the skeleton of our grid and now if we come into index.css we can make that grid class and say display grid another thing that we'll want to do just to start us out is the CSS reset this was in the original project already and we can just copy it over so the CSS reset is just gonna reset everything so that we don't have any weird padding going on and anything like that so let's go ahead and put that at the top and then we can also initialize our fonts and colors like I said I'm not going to spend a ton of time on this portion of the video um I've got prior videos that go into more depth here but basically we're importing uh a Google font right here and then we are initializing our set of colors as CSS variables on the root selector so we'll be able to use that with the VAR and then dash dash whatever variable it is within our CSS so we'll save this we'll come back to our document here and you'll see that it's completely empty which is kind of what we're looking for now if you looked at the vanilla refactor here got it zoomed in way too much it has this darker background so the first thing that we can do is actually actually get that in there and that would be I believe the dark gray right here so let's just copy that over we're going to select the HTML in the body and give it that background color now the reason that we have a hundred percent height this is something that's useful for mobile devices because there's another strategy of 100 of the screen height but that screen height is different on a mobile device versus a desktop and you'll actually get some little padding at the bottom so I prefer to do height of a hundred percent but anyways the main point here is we're giving it that background color and this is actually kind of a mistake from the original we should be just putting in a CSS variable there all right so we'll come back and it looks like we've got our background matching that looks good and now we can start to initialize this grid so at the moment you should be able to find in the main that we have all of these grid items they're just not showing up at all so we need to give them some space within the document so that we can start to work with them so if we wanted to do that the quickest way to come in here and do that is to go right below the grid and then just select any div that's within the grid class and let's just give it a height of 20 pixels and a width of 20 pixels we'll get rid of this in just a moment but oh and then we also need to give it a background color of let's just say red something annoying and you can see there's our grid items we could also give it you know a margin of 10 pixels you can start to see that separation so right there there are our grid items and they obviously don't look near what we want them to so what we need to do is set the boundaries of this grid rather than doing this height and width we can actually dictate how large these items are using the grid container so if you look in our original CSS that was built out you'll see that the grid container has template columns and template rows and then a grid Gap so let's start with the columns we will copy that over and what this is going to do when we say repeat three times 80 pixels that means that each column is going to be 80 pixels wide so let's save that and you can start to see that we've got some columns going here and immediately you can see that I've added one too many div elements so we can come over to the index.html and delete those so now we have this perfect grid right here and then we can come back to the CSS and then add our template rows now our template rows are going to be a little bit different so I'll explain this in a second but we'll copy that in and what we're saying is that the first row is going to be 50 pixels tall then we're going to have three rows so we're repeating three times the next three rows are going to be 80 pixels tall so that will correspond with our columns so we'll have those perfect squares and then the final row which is kind of like that scoreboard at the bottom will be 60 pixels high so that once we save it you'll see that expressed within the grid here and I believe we actually need more grid items here I'm sorry I'm it's hard to count while I'm teaching here but let's make three more and now I think we're getting what we're looking for so we can now get rid of the um explicit height and width of these items because the grid will take care of that so now you can see that we've got the skeleton of this grid but let's go ahead and start isolating things so we want to maybe style the top row as a different color than the main grid and the scoreboard at the bottom so this will evolve and change but just to kind of demonstrate the concepts I'm going to quickly put something in there so for the top three we're going to hit option in click in vs code and that should allow us to click three things at once we'll give these first ones a class of turn and then we'll come down and give these divs here a class of square how many is that three six and then nine so class equals Square and then finally at the bottom we're going to give these a class oops clicking too many things at once we'll give these a class of the score okay so now we'll come back and instead of grid selecting all the divs all the grid items we'll select them based on what they are so let's get rid of this margin also because we will have a gap we'll go ahead and add a gap of five pixels to every grid item so that everything's spaced evenly and then instead of this we're going to say um uh what was it turn was the top row Square was the middle one and then score was the bottom so we'll give these different background colors the squares will stay red we'll make these turn ones green and then the score will be blue at the bottom so we'll save that and then if we come back now we've got all of these highlighted a little bit differently and if you look at the final you can see that this matches almost perfectly but this little turn indicator seems to take up two full columns and in order to get that working we can actually do this within the child the grid item itself we can tell it how many columns to to span at once so we actually have to go to the HTML and um highlight we we can remove one of these div items and keep that as turn and then this will be actions so this will be the little drop down and then this will be the turn indicator so let's save that and it should be all kind of messed up now at this point but here in red that should be our actions menu and if we go to the CSS let's go actions what do we call that actions yep and then this will be a background color of I don't know um let's go purple like that and then finally the turn is going to stay green but we're going to say grid column start and that's going to be one so we're going to start the first column and then grid column end is going to be three so it spans two columns wide so once we do that we should be able to go back and now you see this green is taking up two full columns we've got the actions in the top right scoreboard at the bottom and Grid in the middle so if you compare this right here to our final that's pretty much what's happening we have two spaces here actions full grid and then scoreboard at the bottom so this is the hardest and First Step that you'll do when building any sort of project like this you have to nail the layout and then we can start you know making it look a little bit better arranging it on the screen so I'm going to keep it looking just like this and we're going to continue this process and get it centered within the document and then also make sure that as we resize things you know as you see when we resize it down to this small device it just kind of breaks out we're going to make sure that it resizes appropriately now if you just take a look at the underlying HTML that we've got going on here let's make this a little bit larger you can see that we've got the main container sitting here and then the body container so if we wanted to Center this main container really all we would have to do is go to the body element itself and I believe we can just display flex and then justify content Center and then align items Center and you can see how that brings everything to the middle of the screen so that's generally what we're going to be doing here so if we come back to our project and then if you look at this original so this is the completed version and if we go to the CSS you'll see that on the body element what we've done is we've displayed Flex we've set the flex Direction column so that it's going up and down rather than left to right and then basically aligning everything to the to the center so what I'll do is I'll just copy this snippet here from our completed CSS and we'll bring this to the top or right under HTML and body and then save that and now when we refresh you should see that it looks very similar the last thing that we need to do as you can see we don't have a footer at the bottom so I've added this little attribution at the bottom which provides some spacing so that it pushes this grid up a little bit so we can quickly go add that so if we come to the final uh the final project here I'm just going to copy this footer markup because it's relatively simple doesn't really add a whole lot to this so I'm just going to copy that verbatim and we will put that under the main tag so remember footer is repeated content that if we added Pages we would probably have that on every page so it doesn't belong in the main content of that page so if we save that let's see what we are looking like you can see that the footer has been added down there and that's because it doesn't look good because we haven't added those Styles yet so let's go back to our completed one and I have a section at the bottom that has the Styles just for the footer so let's see they're all right here so I will copy those styles um to our current working CSS so let's go ahead and say footer styles copy those in and then hopefully this will start to look a little bit better so now we've got the workings of our project this is pretty much the skeleton of things and the last thing we need to do is make sure that it resizes appropriately when we're on a mobile device versus a larger desktop device so to do that we will also go to the to the final project here and I'll point you to where this is happening you can see right here I have a media selector and so this we've talked about in the responsive web design uh video that I've done in the past of the front end series and basically what we're doing is we're saying that we want the grid container itself to resize a little bit differently based on what screen we're on so what this rule is saying is any screen that is 768 pixels or higher so basically like a tablet or desktop device we want the grid to have a width an explicit width of 490 pixels because we know we have enough space for that and then we want to explicitly set the columns and rows to be a different size than these Originals so right now if you were to select one of these squares it's 80 by 80. so you can see as we hover over that it's 80 by 80. now on a desktop device we've got some more space so we would want that to be 150 by 150. so let's go ahead and copy that and paste it right under the main grid selector so essentially this will be the mobile Styles and this will be the desktop styles so once we refresh here we're still on a mobile device in this scenario and it looks a lot smaller and then yes it will cut off eventually but really no mobile devices this small so this is about what it would look like and then as we resize you'll see it jump up so let me go into responsive mode so that we can see this a little bit better and watch this up here you'll see as we hit 768 right here it resizes so we have a much bigger game to work with on these desktop devices all right at this point we have the bulk of the um HTML and CSS the structure of our project in the rest of the work that we need to do here is primarily going to be just details of just finessing the look and feel of this until it matches our final product here where you can see we've got this drop down menu that's going to be controlled with some JavaScript you can see when I hover over each Square it kind of uh gets a little bit darker we've got a pointer cursor you can see the mouse is a little different depending if we're on a clickable element or not and then of course as we take a turn watch this up here it will do this little animation in where it kind of Zooms in and then slides out so these are all just little details that we need to add and like I said we've done a lot of in a lot of HTML and CSS work in Prior videos and the main focus of this one is going to be kind of the JavaScript side so I will walk through over the next several minutes of how we take this right here and turn it into this but I will intentionally be moving a bit quicker than normal so be sure to just pause the video If you see something that you know doesn't make sense and just kind of walk through it on your own to understand you know what's happening here I'm just going to be basically referencing the original CSS document in HTML and I'm going to be progressively building this out I'll try to walk you through the thought process as we go but just a heads up it's going to be a bit quicker than usual the first thing that I want to tackle is this green area which is the animated turn indicator now this is obviously going to be controlled by JavaScript at some point but we just want to get the animation right so in order to do that let me close things out this is our working CSS document and working HTML document from here on out I think what I'm going to do is keep the completed CSS here on the right as well as the completed HTML on the right and then we'll close that out so on the left is our working project on the right is the reference to the final one um and I'll I'll try to just kind of hide this a little bit only for reference okay so what we're working on is this div right here so let's go ahead and put some placeholder content in there just so that you see what's going on so there's our placeholder I'm going to go back into a larger mode here so the first thing that we need to do is get this all centered get the text in there looking good so if we come to our final project you'll see that we have this turn class right here so within the turn class we're going to have some font awesome icons and then a turn indicator so we'll copy that in there and if you notice we have these classes fa solid and fax these are being provided by something that we have not added to the head of the document yet so we will need to do that this was taken originally from the uh the Yvonne who submitted this project had put this font awesome uh kit in here so if you just copy this script over right under the style sheet that will add these classes so that they actually show up within the document and give you an icon to work with so once we've added that script these should show up and you can see there's the little X right there so we know that our our icons are working and then finally we need to just style this so as you can see in the original we've got the turn class on there so we need to go down and Ctrl F to find uh let's see where's the turn class here it is okay so we will copy these styles on over we've got some of them already looks like we've got the um so the background color we're going to keep we want to actually display this as a flex container um with a center alignment of the items and a gap of 20. so that's the only thing that we need to add and then we need to align selfcenter so that's going to tell um the grid where to align things so really what we have here is just some development only background colors this tells it how to align itself when within the grid and then this is the specification for how the content within this container is going to be aligned so if we come back over you can see that it's now looking a little bit better and if we were to remove this background color now you can see that things are looking great this is exactly the alignment and positioning of the final one now obviously there are different colors going on here but we're going to be controlling a lot of that with JavaScript so we can move on from here at this point just for the moment I'm going to turn this to uh let's make it that yellow text so we can give it a color and then use one of our variables and you remember we had defined a variable of yellow here at the top under our root so we should be able to throw that in there and get that yellow color right here and then we need to animate this so in order to do that this is a little bit more intermediate level CSS stuff but in order to do that we need to add some keyframes um in an animation to animate both the icon and the text first though you can see that we have some selectors for the icon in selectors for the text so I'm going to copy those over right under turn so we've got the paragraph text and then the icon text I'm going to get rid of this animation stuff for just a second and save that so now you can see that we've got this looking a lot closer to what's going on here and now we need to do the animation itself so when we do an animation you have to first specify the animation's name on the animation property the CSS property and you'll give it a duration and then some behavior that you want it to have and then of course the reference so for the icon itself that's what we'll start with this is going to um be the animation that makes it kind of pop in and out get a little bit bigger and then smaller so you can see that we have referenced turn icon animation now this is an arbitrary value that we have actually defined as some keyframes so this uh selector right here matches this the need to match because right here you were referencing to these keyframes and what it's saying is that at zero percent of the duration it's going to scale to a hundred percent and then 25 percent into the animation it will scale to 140 percent and then once it's finally done it will scale back down to a hundred percent so it kind of pops in and then comes out and when we save this you should be able to see that so every time we refresh you can see that this little icon is just popping in and out in and out every time it reloads so that icon is going to be complete now the same thing applies for the text we want that text right now all it's doing is popping in and out and then this right here is staying in one place but in the final you can see what happens is that text kind of Fades from the left and animates out so to get that to work um once again we need to copy in the animation so we find our paragraph of the turn selector and copy that in and right now it's going to be the same animation time as the icon just so that they match up same type of behavior and then turn text animation that doesn't exist yet we need to copy that keyframe right here so now that we've defined our keyframes of keyframes in the turn text animation you can see that we're transforming it at zero percent to negative 20 pixels so it will kind of pull it to the left 20 pixels and then as the animation animates it will translate it to go back to its original positioning which is where the final position we want is so once again turn text to animation references this key right here so when we save it now every time we refresh you'll see that animation is happening really nicely so we've got this indicator done now obviously we've gotten X it should be an O so on and so forth but that's going to be controlled with JavaScript and we are not quite there yet now the next thing that we'll do is we'll build this actions menu now once again this is has to be controlled with JavaScript to toggle the open and close Behavior but what we can do for now is just put a placeholder in here that is styled like this and when you click it it won't do anything so in order to get that we'll come back to our original so let's come back to our original index.html document once again this is the completed one and you can see that we've called this menu and we've got some markup within here we've got a button this is going to actually be what is shown and then down here this is going to be the popover that is initial initially hidden and then as you click the button this is going to show and then hide every time you click so what we can do is just copy this markup and I think I've named it something differently so yeah I gave it a name of actions right here but we'll update that in our CSS so let's see this is the drop down menu turn that into a comment this is the turn indicator and then this oops deleted that this is going to be the game board and then finally this will be the scoreboard just a little bit of organization so what I'm going to do is actually comment out the popover just for a minute and work on this button so if we save this right now it's not going to show up very well it's just showing up just like this and when you click it nothing happens we have the correct icon in here and then the correct text but now we need to actually Center this and style it so you can see that I've given this a menu class which in the original index.css we'll go find this um I've just given the menu class a position of relative the reason for that is because um we need that popover that opens to have a relative reference so that it knows where to open relative to in the Dom because it's going to have absolute positioning so we will put this where should we put this here so we've got our turn stuff let's just make a different section so this will be the menu Styles just trying to keep this straight for everyone here so give that a position of relative that's not going to do anything to it it's still going to look the same but then once we add the menu items so if we go back to our markup in HTML you can see that we should have some items those are commented out so we're not quite ready for that Let's see we just need to style the menu button right now and I'll get rid of this just for the moment that's going to come in later as well as this data ID I just don't want to add anything earlier than it applies so the only thing we don't have styled is this menu button so let's find that here there's our completed style so let's copy that in right under menu you can see that we want it to be a hundred percent width and height of its container and if you remember from this original the container that we're working with is what's highlighted here so this is just one grid item so if we say it's a hundred percent of that it's just gonna be 150 by 50. and then we're going to display Flex so the items within it are going to be Flex items and we're going to give them space around and justify them Center so let's go ahead and show you what that looks like for now so you can see that we've got this menu item that's looking a lot better it's got the wrong Styles but we're getting closer so let's come down uncomment these and here we're going to give it a background color I believe this was like a oneoff color that didn't fit into the color scheme so that's why I'm defining it here without a variable and then we want the text to be white we want to give it a border and then make that border rounded a little bit so we'll go ahead and save that save the HTML and now you can see that our actions menu is looking exactly the same as this one now the final thing that we have to do um we can't we don't have JavaScript functionality to this yet but we can still uh kind of mock out what this menu looks like so as we click this and open the menu we can still build this even though we don't have JavaScript so to do that all we need to do is uncomment this div and at the moment we haven't styled these classes so it's going to look very weird you're just going to see it right below the actions menu but what we want to do is make this items class and then more importantly it's going to be hidden initially and then our JavaScript is going to be what's responsible for unhiding that so here's what I'm going to do let's go ahead and remove well no let's keep it as is and Define the items class so where is that search for items all right so here are the menu items I've actually selected the any element with an items class that's within an uh element with a menu class you don't really have to do that we could just copy in items directly because we don't have any additional Styles going on there so we've got the menu button that's always going to show and then the items are going to be these items that you can click once they're expanded so there's a couple really important things going on here the first thing is position absolute so because these items are within the menu class the absolute positioning is going to be relative to the nearest parent element that has a relative position on it and as you can see we've given that menu a relative position so these items are going to be positioned absolutely relative to that menu element a little bit confusing but we've gone over that in Prior videos in the series that I built out so we want to give that absolute positioning and a z index of 10 which means that it will sit over the grid of items you don't want that to go behind so the top it'll be 60 pixels offset from the button itself so I'll show you what that looks like let's go ahead and just look at those Styles right there um actually let's let's go ahead and take out everything except for the absolute positioning okay so absolute position you can see that nothing really has happened here quite yet now once we uncomment the rest of this stuff um let's go ahead and comment that out for a second and we're just going to give it a the actual positioning that we want and now you're going to see that things are looking a little bit better now the positioning is going to be relative to this right here so the top left corner so if you see the total height of this button is 50 pixels so that's why I gave it an offset of 60 pixels from the top so it will offset 50 pixels from this to get it to the bottom of the button and then another 10 pixels to give it this little Gap that you're seeing right here and then of course we need to give it a background color a rounded border radius and some padding within the container so you'll see now it's looking a little bit better we still haven't styled the buttons within it um but then finally We'll add the Z index we just want that there to make sure that it's O is sitting on top of these items now the last thing we need to do is style the buttons in there because they don't look very good as you'll see here they're just they're not super well styled or anything but they look a little bit better so in the HTML you can see that we've got a reset button and a new round button these have data IDs on them I'm going to get rid of those because we don't need that quite yet we're just going to style them based on uh their parent so we're going to look for the menu and then items within the menu and then any button that is within that is going to be styled like this so we can actually just remove the menu it'll still work if we do the buttons relative to items so if we save that now you'll see that the buttons are looking a little bit better although you can see we don't have any like hover effects we want the cursor to become a pointer so that the user knows that they can click on them and to do that we're just going to need some hover Styles so if you pop that in there we're going to underline the text and give it a cursor pointer and now you can see that this looks a little bit better in that regard so as you'll see there's no border around this button in the final until we actually click it and once we click it it's been focused and everything's going to have a border so we'll have to wait on that until we have some JavaScript but for now you can see that everything is being aligned correctly and then the last thing we need to do is just create that hidden class because as you can see we've got the hidden class here and then a border class these were shared styles that we would use across multiple elements so I put them in shared utility classes within the CSS file so we'll bring this to the top we'll put it right under the body as shared utility classes and I'm just going to copy these in all right now so we don't have to come back and do this in the future so we'll copy those in just a hidden class that displays none and it has important on it just to make sure that nothing conflicts with it then we have some shortcuts for yellow and turquoise you don't have to do this it's just a little bit easier once we get into JavaScript and then just some standard borders and shadows that we'll be putting on different elements so once we add those you'll see that given these two classes we've put on this it will hide that menu so you can go ahead and remove that hidden right there and it will be showing back up with the Border but for now we just want that hidden and then JavaScript will unhide it for us once we Implement that all right at this point you can see now we've got some conflicting Styles going on over here we'll be sure to come back to that and handle that with some JavaScript as well as our actions menu that we can't really do anything with at the moment it's not really clickable because we need some JavaScript to enable that so we're done with this first kind of row now these grid squares or game board squares these will be relatively easy to style so let's get in and do that real quick so uh here's our game board and then let's go ahead and look at the reference um the final one you can see that I've given each of those a square class which dictates their Styles and then we've put a shadow remember we just defined those shared utility classes and I've defined a shared Shadow class that will apply to everything so that's just kind of keeping the code dry making sure we're not repeating ourselves too much so what I can do is now add those in so once again I'm going to hit hold down option and click through this within vs code to select multiple at once and we will add that shadow class now furthermore we're going to want to give we don't need the IDS quite yet that will come when we add some JavaScript so let's save that and then finally we can get rid of our background red so wherever we put our squares we don't want that background color anymore we want a much nicer looking one so you can see here are our Square colors we wanted to span 100 the width and height of its container which as you can see um this is going to be the grid item itself so we want that to span 100 and I don't think that is actually necessary now that I'm looking at this because the grid will control those so let's go ahead and just copy this gray background I'm going to put a little rounded border and then we're going to make sure the content within is a it's a flex container so that the content is centered within and then the font size is going to be three Rems because we want those icons that are sitting within to be extra large so we'll copy that into the square class save it and now our board just started to look a lot better so you can see that we've got those Shadows that you see on the final the only thing that we're missing here is when we hover over them it doesn't do anything so it doesn't feel like to the user that you can click so in order to cover that we need the hover Styles so that's what this is for the hover style for a square we'll copy that in we want to give it a cursor pointer and then just a 90 opacity so now when we hover it's going to act like it's actually clickable for now we're going to leave the icons kind of off of this at the moment because that's once again going to be controlled by JavaScript when we actually click these um so the last thing we have is the scoreboard down here at the bottom this is relatively simple markup so we'll look at the final project and you can see we've um just got some basic HTML a bunch of div containers with some paragraph text and then a little styled scoreboard where it shows how many wins they have so I'm going to just copy all of this stuff verbatim it's not very complicated you can read through it on your own so we'll put that in the scoreboard section we've already implemented the shadow class in our shared Styles and I've added an inline style here with the color mainly because it's just easier to read it's easier to see that within the HTML what color it is rather than making a different class for each of these you could do whatever you could add this to the index.css but I just thought this was a little more straightforward to read so once again let's get rid of the data IDs for the moment because those are more applicable when we get to the JavaScript so this is our scoreboard and the last thing we need to do is implement the score class because if we come over here you can see that nothing looks very good we've got the different colors but they're not centering the text or styling the text or anything like that so we need the score class implemented which we can go find in the final index.css um all right so here's the score class we're going to replace the background color blue oops we need to get rid of that okay so we're just going to display Flex so that each uh each box is a flex container and we're going to give it a top to bottom Flex Direction and we're going to justify all the content and align all the content to the center of it and then we're giving it a height of 60 pixels which once again I don't think that that was probably left over stuff because the grid should be dictating that and then we're going to give it a little border radius so that it's rounded so let's save and you can see that things show up uh okay here the last thing we need is this text it's obviously not styled very well yet compared to the final you can see that there's a little bold Style on the title and then the number of wins is going to be a little bit smaller so to do that we're going to do some sub selectors so the paragraph text within the score box is going to have a font size of 14 pixels and a font weight of 600 if you scroll to the very top where we've imported our Google fonts you can see that we've imported a font weight of four five in six hundred so that's what allows us to use that font weight if you didn't import that then this is not going to do anything so just a note there and then the span element so this is where we actually show how many wins the person has we're going to give it a font size of 12 pixels and a little margin on top so we'll save that and now you can see that everything is styled correctly so at this point um looking between the two we pretty much have the same exact design going here and we're uh for the most part completed with this HTML and CSS portion so let's go ahead and scroll through this final completed one and just make sure that we've got everything uh matched up so we've got the footer in here that's that's perfect uh looks like the modal we need to still do I forgot about that so we'll get to that and then in the main content we've got the scores scoreboard right there we've got all the squares for the game board we've got the menu implemented and then the turns implemented and then I think pretty much everything else is done so HTML looks good aside from this modal and then of course we'll add the script once we get to the JavaScript section and then from a CSS standpoint let's go to the top make sure we've got everything we've got the import correct we've got our Styles the CSS reset Global HTML and body styles um uh let's see we added this Global style that looks like it got put in the wrong place so let's go ahead and add that to our shared utility classes um that's not really supposed to be a utility class but that's Global so I forgot to add that and then the grid we've got that done this is the responsiveness we got all the utility classes we added the turn along with the animations we added the menu looks like we covered all of this we got the footer okay so really we have completed everything except for the modal and when I say modal I'm talking about what happens here when someone wins the game so you can see it pops up this uh kind of focused element and then it puts the game in the background makes it look as if this is the only thing that you can click so in order to implement that we obviously need some JavaScript but we can implement it with just HTML and CSS and then we will come back to it once we have some JavaScript available to us so the first thing that you need to do when you're implementing a modal is give it the HTML markup so we will copy this over and you can notice that I'm putting it at the very bottom under the footer and one could argue that this might belong in the main content but really this is going to be hidden initially and it's going to be absolutely positioned or fixed positioning I think so it doesn't really matter where in the document it goes it will show up correctly so I think one could make the argument that it goes in Maine like I said but let's go ahead just to stay consistent and put it at the bottom and then since we've got this hidden class of the you know this will do display none let's get rid of that for the moment just because we want to see what it looks like and if we go back to our project you can see that the modal is right here it's at the very bottom it's got this P tag and then a button that says play again obviously this is nowhere near what we want we want this centered and have a little backdrop so we've got some CSS that we need to write um and if you see in the final we've got all these modal Styles so I'm going to copy all of this over at once at the very bottom give it its own section and then what I'm going to do is just comment things out so that we can progressively see what things are doing here okay so we've got everything copied in here the first thing we need to do is Target the container so this is the div container with the class of modal so what we're doing here with this modal container is we're giving a a display property of flex and then positioning of fixed now fixed positioning is relative to the entire document so what that or the the viewport I should probably say so if we're looking at our viewport this entire screen here is the viewport itself so this is going to be relative to to the entire viewport well something like absolute positioning is relative to the nearest relatively displayed element so in this case since it's a full screen takeover we want this to be a position of fixed we want to give it a width and height of a hundred percent and that will work because up here at the top we have given the HTML and body a height of 100 and it's automatically going to expand the width of a hundred percent just based on how block elements are displayed so by giving it just this stuff display Flex or we don't even need that yet position fixed with 100 height 100 let's save that and now you can see up here it has moved so now this takeover the modal spans the entire screen as you can see now we want to take this content and put it right in the middle and give it some styles so what we need to do is uncomment the justify content and align items and then also the display Flex so really we need to bring those up just so that not for functionality just so you can see it all together so display flex and now you can see it's right in the middle and then finally if we give it a background color it's really going to start to pop out so this entire modal has this dark background color now of course we need to style the contents of the modal to also have a background color and that's where the modal contents come in so if you see in the index.html the container within it has a class of modal contents and what we want to do is just uncomment all of this stuff so I'll quickly walk you through what's going on um let's see the first thing let's get rid of that for a moment height with okay let's get rid of these last ones and start with this so the first thing we're doing is giving this container a height of 150 pixels in a width of a hundred percent and then a Max width of 300 pixels so in other words what we're saying here is that by default we want it to be 100 width but if the screen is big enough to wear 100 width is larger than 300 pixels then default to that Max width this is just a little trick that I use a lot for mobily responsive um or mobile first CSS and that way it will just look good on everything so let's go ahead and save this and then go back and you can see our our modal content is coming together so to display or to show you what I mean here let's go down to a smaller device and you can see that that's kind of resizing as we are on the smaller device and then as it gets to a bigger one it's going to stop right now it's 238 pixels but once it reaches 300 it's going to stop getting bigger so right there it reached 300 stops getting bigger and it stays centered so that's what this little trick is doing right here now we want to display flex and basically align everything Center so let's get rid of these comments and now this right here should basically Center everything so now you can see player one wins and play again it's all centered so that looks good and then finally we want to give it a flex gap of 20 pixels so that the content within it has some spacing we want the content to have text color of white and then we want the whole thing to have a margin of 10 pixels so let me comment that out for a second here's our spacing white text and then you'll notice on the mobile device once it gets too small it pushes right up against the edge so if we just add a margin of 10 pixels you can see it adds that little Gap there so that's only for mobile device then the last thing we just need to style this button so you can see that I've targeted any button button within the modal contents and just giving it a padding of 10 pixels background color of turquoise text color of something a little darker than that and then some rounded borders so if we save that you can see that the button now has these nice Styles so our modal is complete and if we just give it that hidden class back so if we put hidden on there it's going to be completely gone and then we comment that out and it's back so you can see how our JavaScript is basically going to take that hidden class and it's going to remove it add it back remove it add it back based on when someone wins the game and then the play again button will also trigger a JavaScript action all right so I know I said that I was going to kind of gloss over a lot of the HTML and CSS which I sort of did we did a lot of copy pasting but hopefully that was a good blend of you know how did we get to this final state but not typing every last little letter so if you just toggle between the final one final game right here and our current game everything looks pretty much the same so HTML CSS that's done but obviously when you click anything on this board nothing is going to happen because we haven't hooked up JavaScript which is going to actually control the game um so we want to be able to you know make plays and reset the game and do things like that so at this point I would recommend if you're watching this video to take a little break um because we're going to switch from uh HTML and CSS mode to JavaScript mode which requires a little bit different type of thinking so we're in the JavaScript section but something that happened to me when I was first starting out is I would always just be asking this simple question of when we're looking at JavaScript where do you even start like what's the first thing that you think about when you're trying to connect up some JavaScript functionality to a static HTML and CSS application so looking at this we can click stuff but it's not going to do anything and so the question is where do we even start thinking about adding this these event listeners and you know all the different State Management that happens to make this game work so in asking this question I think the next question that we need to ask is what actions can a user take in my app so we're building a game and there's really three actions that a user can take let's go back and look at the finished game this is the the refactor that I've done that's actually working and if we let's reset everything new round get everything cleared out and the first action that a user can take is they can click on one of these squares on the game board so this is just you know a Player move that is happening so that is the first thing that we need to jot down a player can make a game move now the second thing that they can do once someone actually wins the game so player one wins we play again and you can see down here player one has one win zero ties player two has zero wins so the next action that they can do is hit new round and that's going to clear out this scoreboard down here at the bottom so we can say clear or actually new round and then finally the last thing that they can do is if they started a game and just want to reset it you can go to the reset button and that will clear things out and it won't touch the scoreboard so we can make a new round or reset the current gain so I think with any application any you know frontend project like this that we do this is a great first question to ask yourself just so that you can get a better understanding of these requirements now of course once we have this question answered you obviously have to start writing code to make this happen within your static HTML and CSS so there's a lot of different ways to approach that and ultimately where we're headed by the end of this video is to have some sort of model view controller pattern that's going to help us organize our code to make this stuff happen and handle these events correctly so model view controller is just a pretty common architectural pattern that's commonly used for developing user interfaces so this is actually me from the future I was editing this video and realizing that I had created I had created this diagram to kind of give an overview of the MVC pattern and I didn't actually go through it so this is the MVC pattern model view controller and I wanted to just walk through kind of the the flow of this so as we're building our application there's three separate concerns basically we have the view which as you'll see this is um event listeners that handle either UI only events so like toggling a menu as we'll see here just toggling this actions menu or we can manipulate the Dom and respond to State changes and what happens is the store over here is kind of the the model and this is responsible for getting State and saving State and emitting State change events and this app in the middle is the controller and this is responsible for kind of orchestrating between State and the view and making sure that you know State updates and the view updates all in one concise Consolidated place so I know this probably doesn't make a whole lot of sense so I'll stop here but just keep this in mind come back to it as we go through this build and hopefully this gives you a little visual representation of this pattern we're using now this is going to be a very challenging pattern to implement straight off you know right off the bat and it's not going to make a whole lot of sense so what I've decided to do is almost a contrived example where we basically start with a more naive approach where everything kind of sits in one file and we don't have really any architectural patterns behind this and we're going to progressively iterate on that and get to that MVC pattern that's a little bit more stable so we'll call this the video progression we're going to start with you know a naive approach all in one file then we're going to refactor and iterate as we go and then finally we're going to end up with MVC pattern that is and this is very important it is going to be easy or easier to debug later and it's going to be easier to extend and add features to later now these are really important parts of building software because anytime you're building software you're going to have users that expect things to be improved and fixed and extended you want to add more features so for example in our basic tictactoe game you might want to add some leaderboard over here to the left side or the right side and you might want to be able to add user logins and you know registration and whatnot and being able to do that is going to be very difficult if we haven't planned out a little bit of architecture in a little bit of software design behind what we're doing in other words everything in one file is going to quickly become unmanageable with that said I think we can go ahead and get started now just thinking about this a little bit um let's enter this down so we got some more room what actions can a user take in my app we've defined these and what I want to kind of point out is that these pretty directly oops did not mean to do that these pretty directly map to event listeners on HTML elements so in each case when we look at this we have individual elements so reset is going to be some sort of button new round is going to be a button and then each of these squares on the game board are going to be like a button or a div or something like that in every HTML element has event listeners that you can hook up and then when that event happens you'll put in some JavaScript logic that will maybe manipulate the Dom and update some sort of persistent state in local storage or session storage so on and so forth all right so I think that's enough planning for the moment we're going to kind of come back to this whiteboard a little bit to to plan out some more features in the as we build this out but I want to get started just to kind of jump in so if we're looking at our HTML document we have to ask the question how are we going to add JavaScript to this well theoretically you can put Javascript pretty much anywhere in this document but you will always see a best practice of putting that JavaScript at the end of the body tag in almost all cases and the reason for that is because when we are loading an HTML document in a browser the browser has a bunch of code that's running in the background that actually has to read through this HTML document and parse it and parse all of the elements there and all the Styles attaching those to the elements and it has to actually paint that to the screen now this is called the critical rendering path and I would say this is a more intermediate to Advanced concept that you can kind of check out on your own but the point of this is to say that when we load this HTML document in the browser it's actually going to make a network request to get the document you can see that over in the network tab you'll see this first 200 get request let's make this a little bit larger this is the initiator is the document and it's a type HTML and when we click this it's going to render the HTML here but if we look at the raw response that we're getting this is the HTML document that has been sent over to the browser and the browser has to go through and parse that now why is this significant well the reason being is if we have JavaScript that happens or is placed here at the top of the body what that means is that before the browser can parse any of the HTML and show that to the user they have to run all of that JavaScript that is sitting there at the top of the body and if you've got a large enough JavaScript bundle that's going to block things and the user's not going to see anything in the browser until that's done so that's just a poor user experience and that's the reason that we'll generally put a script tag at the bottom of the body so once we've got the script tag here we can run arbitrary JavaScript in it so we can say hello world and save that and then our live server is going to reload go to the console and you'll see Hello World and just a side note you'll see this get request that's airing out on the favicon we don't even have this in our HTML document the browser just by default is going to look for this because it's kind of a standard so we can safely ignore that but anyways you can see we've got JavaScript running but obviously we don't want to do all of our JavaScript inline here because we're going to have to write enough of it to where this will get pretty cumbersome so ideally what we need to do is make a script that has a source tag and that Source tag is going to point to a Javascript file that we're going to add to our directory so we'll come over here to the live vanilla build add a new folder called Js it could be anywhere but we can put this in and we'll call it app.js you can call it whatever you want main.js index.js any of those work so here let's go ahead and put our console.log hello world save that and at the moment it's not going to do anything if we refresh well I guess we haven't saved the HTML yet so let's save that refresh and you're not going to see anything you'll just see the source attribute of script is empty and that's because we need to populate that with a path to our app.js Javascript file so once we save this you should see everything's hooked up we get Hello World in the browser and we have our basic Javascript file so at this point now that we've got a basic Javascript file set up I want to go ahead and start on these user actions that can happen so remember we've got these three user actions and there's actually a fourth one that we are going to start with because it's probably the simplest implementation and that one is toggle the menu so this new round and reset current game these are part of the menu but we actually have to implement that so that this menu pops open and closes every time it's clicked and that can't happen with just HTML and CSS at least without something crazy going on so that's the first thing that I want to do because it's rather simple to implement and then we'll start working on those user actions and how do we track the state of the game so the first thing that we're going to do is kind of scaffold out our actions and to do that we need to identify the elements that we are going to select so I'll show you a better way to do this in a couple of minutes but we're going to start with kind of as I said the naive approach of what you might think to do first so if we're looking for that menu you're going to come to the drop down menu section of our HTML and you'll see that we've got a div with the class of menu so probably the easiest way to select this element with JavaScript is going to be let's call it menu and we're going to select the document which should be globally available to us in the browser runtime so that should be available and you can see vs code has already kind of detected that this is available to us so it's giving us all this auto complete stuff of the browser apis so we can say document.queryselector and we can select by a class and select any element that has the menu class which we know just to be one div element now from this menu what we can do is add an event listener and we want to listen for the click event and then on that callback we're going to get an event object which has a Target which represents this element right here so if we were to console.log event dot Target we should see when that is clicked in the user interface we're going to see the element itself printed to the console and you can see that we've got the button and if you open this up you'll see all of these different attributes and these are all the things that we can read off of this element Target now to get this to actually toggle down that menu if you remember from our HTML all we needed to do here is go down I'm sorry not there right here this is the menu items and you can see that we've put a hidden class on there so if we were to go back to the browser and select this element and go find that div that is hidden and then we can uncheck this hidden CSS class you'll see that well this actually shows the modal because we're sharing this hidden class with that modal as well so let me refresh and just remove that class for a moment and you'll see that now by default it is showing so really all we need to do with JavaScript is toggle that class on and off every time that button is clicked so this is the class we're targeting but in order to do that we need the ability to select this item so that we can manipulate it so there's multiple ways that we can do this but you can see we've already selected this div element that has a class of menu so we've already got that context within JavaScript in the menu variable now we can use that and select any div that has the items class within it so a simple way to do this is to say menu items and we can say menu dot query selector and then look for the items class and from there we can then manipulate that so when we see that the button on the menu has been clicked we can come down and say menu items and we can say class list and then we have this method available called toggle and we can pass in a class of hidden and that's going to toggle the hidden class back and forth every time the button is clicked so let's see if that works we click this click it again click it again and you can see over here on the right that hidden class is just being added and removed each time so the question is how did I know to do that that's always a good good question to ask and let's go ahead and go to mdn which is our favorite documentation for the web and what are we going to search we want to look for class let's start with element so element is a base class it's the most General base class from which all element objects in document inherit in other words what that's saying is when we do a query selector and get an element back then all of those are going to have are going to inherit the instance properties in instance methods of the element and if you look at instance properties you'll see that we have a class list available to us and from that class list if you look at the value you can see that we have a toggle method so the toggle method of Dom token list removes an existing token from the list and returns false if the token doesn't exist it's added and the function returns true so that's how I would go to find that this is available to us and that's how I knew that we had a class list on the menu items which basically is going to map to this right here that's what we're dealing with in JavaScript and then the toggle method is just a convenience method that allows us to add and remove this class or whatever class we pass in as an argument so just with a couple lines of code we now have some functionality in our application we can toggle this actions menu now of course we can't click we can't click the new round to reset and expect it to do anything because we haven't set click listeners on those yet but what we do know is that we can toggle it now there's already something wrong here and there's nothing terribly wrong but I'm going to start making a list over here if we can remember where this is we'll say let's zoom in a little bit make this a better font so best practices when developing user interfaces all right so the first one that we're going to talk about here is global scope and namespaces so if we go back to our application there's something that's a little bit wrong here and could cause you problems in the future if your app gets bigger and you start splitting this across multiple script files and using similar variables so let's say that we went ahead and added another script to our index.html so let's copy this down we'll say second app.js and over here we're going to add a new file called second app.js that will delete in just a minute and I'm going to Define a variable called menu and this is just going to be some object some JavaScript object Okay so we've got in our second app.js a variable called menu in our in our first app.js we also have menu but they represent two different values so the question becomes which one's going to win which one's going to take precedent or precedence so let's go in here and click our button again and it seems to be working okay so let's go back here and flip the order of these scripts and save it now let's click here and this is no longer working and the reason being is because we have a redeclaration of the menu variable and so it no longer knows what to do because we're trying to set an event listener on a constant object variable because they're conflicting so as you can see this is already a bit of a problem and the problem here is not that we're defining two variables of the same name that's totally acceptable within you know programming it's the fact that we're declaring the same name in the same scope furthermore we're putting it all in the global scope so believe it or not if we would go to this console here and type menu you can see that that value is an empty object and then if we type menu items let's see menu items will be undefined because we're deriving That Base Time menu but let's go ahead and flip this script um oops okay so we're flipping them in the different order so now this menu will work okay and if we type menu it's now back to that element and menu items is going to be another element so you can see that these are available in the global scope which is usually not a great idea so something that your o is going to want to do when you're developing applications is make it into a namespace so when I say namespace all I'm referring to is a one variable that a single name that we can Encompass and store basically put a closure over all of our other variables so that it's not going to expose all these different variable names in the global scope so a way that we can do that is just defining a variable called app and this will just be a basic object to start with and within this app we're going to store some of our selected items and then we're also going to add an initialization method so the first thing we'll do let's get these the menu and menu items on this within this namespace and something that's really nice to do is put a prefix in front of that so we'll just put a dollar sign that's a pretty standard convention that people would use and so this will be a property of this namespace and this is where we're going to put all of our selected HTML elements okay so right here we're going to call it menu and we can say document.queryselector looking for the menu class and then we will also put menu items but now we no longer can derive this based on menu because at this point in the initialization of this object we don't have menu available to us now you could try to do something like app.menu in reference or sorry app dot dollar sign dot menu and then query selector and then look for items so you could try that but if we save that and go to the document here it's going to say unclot reference error can't access lexical declaration app before initialization so in other words we can't reference it here because it hasn't initialized yet so a quick solution to that is to just replace this instead of deriving it based on that element we'll just look for it in the document there's only one element with a class of items so that should not conflict with anything so we've got our selected elements we're looking a lot better here and now if we go back and let's go back down in our index.html and flip the order to where it was broken before and now if we refresh um it's going to say menu is not defined where did we what are we doing here oh I'm sorry that's because the event listener is no longer going to work so let's comment that out for just a second and things should work now you're not going to get any namespace errors this menu is not going to conflict with this menu because this is uh has a closure over it with app as the namespace so let's get rid of second app that was just for demonstration we'll delete that and then in the HTML we can delete that reference so we're back to where we started and now what you'll see is if we go to try to access the menu variable it's not going to be available so I guess there's a builtin called menu bar but menu is not available but if we go to app dot dollar sign dot menu that is how we could access that element that we've selected so now all we have is a single namespace called app and theoretically we could Define that same variable in a different file and it would conflict but it's much less likely and much easier to track all the variables we're defining when we only have one namespace that's covering everything else that we're defining so the next thing that we'll do to make this a little bit better we could of course uncomment this down here and say app dot dollar sign dot menu dot add event listener and save that and then we come here and it's going to say menu items is not defined I'm sorry because I have to reference app.dollarsign dot menu items as well and we're going to toggle this and it'll work just fine now there's one Improvement we can make because right here we're doing this in the global scope so a better way to do this is to make an init method within our app namespace so the init method is going to be where we're going to add event listeners to our application and just to note this is es6 syntax this is just a shorthand way to define a function property on an object that we're calling app so another way to do this would just be a property and then you could add like an anonymous function just like that or you could do an anonymous function like that so on and so forth you could even Define a function up here and assign it there but this is just a quick way to do that shorthand and then what we're going to do is move this initialization logic into that method right here and what that does for us is now it allows us to control when our app is initialized and what we can do here is if we save this this is no longer going to work because we haven't initialized our app but a nice way to do this is say document dot add event listener and we'll wait for the document to fully load and you can see in the documentation vs code populates um actually this is not for the load event but this is basically waiting for the entire document to load so we know things are safe to use and select and then from here we can have a callback function that we'll call app.anit so another way of doing that we could call it like this so app dot init and save it and if we do this it's not going to work and I believe the reason is this should be window instead of document so let's try that looks like it works let's go ahead and look at the reference here so mdn document so we can look at the um document here and then let's look at the events reference so listen to these events using add event listener on the document and it looks like the load event is not available there but if we look at the window if we can find that so let's look at window and then events here and this is where we're going to find the loaded event I believe and you can see here in the load in unload events reference here's the load event we're listening to and that's fired when the whole page has loaded including all dependent resources such as stylesheet images in other words this happens when all the HTML is in the document and we can start selecting it safely so that's why we're listening on the window here and basically we're just listening for the load and then we're initializing our application which will select these elements and add that click listener to our menu now a shorthand way to refactor this rather than this syntax we can just remove this and remove the call and that's a more concise way to write that and we'll have the same exact functionality just like this all right so we have a basic toggle menu that's working but the next thing that we need to do is kind of start on this game and and working on the state of tracking the different moves that a player can do so let's first scaffold out kind of the events that we're going to have to listen to and the elements that we're going to have to select and then we will come back and fill in that logic with an actual implementation so as you know init is where we're going to register all of these event listeners to handle these um user events so what we can do is first Define the elements that we are going to trigger those events on so let's go back to the game and the first two are pretty easy we need to Target the reset button in the new round button so one way that we could do that you can see that we've got two buttons reset in new round so there's no selectors on either of these buttons so what you could do is just add a class but one thing that I'm going to show you here to refactor and we're going to do this as we go is add a data ID so this is a much more stable way to select elements when you're querying them in the Dom so if you go to mdn and type data dash star you will see this attribute which is global attributes form a class of attributes called custom data attributes this allows you to add proprietary information to be exchanged between HTML and its Dom representation in other words we can give data ID or data whatever we want to Define and that's going to allow us to have a stable selector so let's come back first to Excalibur uh Excalibur here so we've got Global scope and namespaces and now let's talk about stable selectors data star attributes okay so what do I mean by that if we go to index.html you know we could select these buttons indirectly by looking for the menu div and then looking for items and then getting the index of the button to select which one we want but a more stable way to do this let's start with menu up here is to just add a data ID and we're going to call this menu so let's save this document and go back to app.js and update our query selector here for menu so instead of selecting the class we're going to select something we'll put some brackets which says we're selecting an attribute called Data Dash ID and that will be equal to menu so let's save that and see if things are working okay in our app and it looks like they are we're allowed to select that and let's break it on purpose so take out that U just to break things and now it's going to say uncaught type air app dot menu is null so you know that this is working and we could also call this whatever we wanted so data custom selector just to demonstrate and you could update this to say custom selector and that's going to work just fine we'll still have that being selected appropriately so data ID is just a convention that Avo has used and I think it's a good succinct one that you can use as well so we're going to put a data ID on each of these elements that we want to select and the main reason for doing this is to have stability so if you changed the name of this class for menu or if you rearranged the HTML elements in the future you don't want all of your JavaScript to all of a sudden break because you changed a style element of your document you don't want to couple those two pieces together and so this is a way to keep things a lot more stable so we'll come down here and add a data ID for this of menu items and then we'll add a data ID for this reset button same thing here oops new round button okay so now we have selectors that are a lot more stable for all those and we're going to register them here so we need two more we need a reset button in the new round button and we're going to just copy these query selectors so we don't have to rewrite that every time and then we'll replace this with menu Dash items is what we named it this one we called it reset button and this one was new round button so if we got that right we should have all of these being selected and we should see no errors within the document and you don't see any errors other than this one we know about and this is working fine so this has been updated correctly at this point it should be relatively simple to add the rest of our actions here so we've already got the event listener for the menu toggling now we're going to select the reset button and add an event listener we want to wait for a click on that and then open up a callback function that receives the event and we'll just say reset the game that'll be our placeholder for now we can just copy this down almost do it verbatim instead of reset button it will be new round button and we'll say add a new round so we've registered those click listeners and now if we open up the actions it'll toggle if we hit reset it will reset the game and if we hit new round it will add a new round so we've got these hooked up okay and then the last thing that we need to do is register a click listener on each of these squares now there's a better way to do this than what I'm about to show you but the way that I'm about to show you is probably the most intuitive in the simplest way to do it so what we will do is let's look at the index.html and find these game board squares that we're trying to select so the quickest way to do to do this is look let's go ahead and add a data ID and I believe we can duplicate these data IDs so let's just call it square and then we'll add that for all of these properties here so I'll hold down option and just click in vs code you can highlight a bunch at once and then we'll add data Dash ID equal to Square okay so now we have a stable selector on all of these and what we can do here in our selectors is say let's say squares and we'll say document but instead of query selector we're going to do query selector all so we want all of the elements that have a data ID of the square and if we go to the init method and just console.log app dot dollar sign dot squares and look at that in the Dom you can see that we have the node a node list which has all nine of those squares represented here now the last thing we don't have a unique ID on each of these we of course have an index to our array but it would be nice if we just had an ID so that we had kind of a coordinate to map this to so one way we can do that is to just click here and go down to each of these and give it a basic HTML ID property or attribute okay so I'll start every all of them with one and then we'll just go down and replace all these so now when we select these the node list is going to have an ID on each of them so we know when they're clicked which ID that we're dealing with so going back we can add an event listener to all of these but since it's a node list we need to iterate through them so we can say app.dollarsine dot squares and then we'll just do a four each so for each Square this should be a node in the Dom so we should be able to say Square dot add event listener and then add a click listener and then the event that is returned from there should give us an ID so let's go ahead and console log square with ID and then we'll interpolate event dot Target dot ID was clicked so we can remove this console log and now what we would expect is every time we click them we will get the ID back of the square that was clicked so this one should be square id1 this should be nine so we're going one two three four five six seven eight nine so let's click one and you can see square with id1 was clicked go down here square with id9 was clicked so that's a pretty simple way to register an event listener there for each of those squares so now going back to our initial question that we had asked let's go over to what actions can the user take in the app we came up with four of them a player can make a game move new round reset current game and toggle menu and if we now look at our init method we have four events that are being listened to on different Dom elements so one organization method that we can use instead of putting this all in the init method we'll leave the init method there and Define a new one and let's just call this register uh register events or event listeners or something like that and this is just going to be an organizational uh technique here where we can just put all of that same type of functionality within that method and then we'll keep the init method pretty clean so all we'll say is app.register event listeners so now what's happening is when the window loads the document we're going to call init and a knit is going to register all of those event listeners for us and if we go back to our app we should be able to toggle this reset the game new round and then click any of these squares and get an ID returned from the squares so at this point we have a template for our application and we've stubbed out some methods that we're going to need to implement so as you can see here we basically we've got this one done this is toggling the menu so we'll call that done I'll just add some comments here so we can track this one is going to be a to do item because we have not implemented what happens when we reset the game or add a new round and then this bottom one is also to do um but this is probably what we're going to work on next but speaking of what to work on next that is a really good question as you're building an app like this how do you know what comes next well in this case we can kind of go through the process of elimination with these actions reset and new round those are not going to be possible to implement until we have a functioning tictactoe game that we can actually reset so let's go back to our notes here and I want to take a minute to go off of this point here let me get my arrows worked out here not super familiar with how to use this quite yet so we're going off of this point of player can make a game move so the next question we've got to ask is what is a game move well there's a couple considerations that we'll have to think about here one being how do we determine who is up who is the player that is up next so let me add that as a requirement here um who is currently up the next thing we want to know is did the latest move cause a tie or a game win and then we also want to know who won or was it a tie and then what else can we think about here let's go to our final refactor the one that's actually working here up here this is our question of whose turn is it we need to know that so we can display that we also need to know that so we know which icon to display when it's clicked and then as you see we have a modal that pop up pops up when someone actually wins the game so we need to know when that happens and then at that point when we click play again we need to be able to reset all of the state to a blank fresh game so those are the main questions that we have to ask um so who is currently up this is for the turn indicator icon to play um and I think that's pretty much it so we'll take these step by step because um it's kind of tough to think through all of this at once as you get more advanced in building these things you can probably map all this stuff out from the beginning and that's kind of my first step when I'm building this is trying to map out what does the state of this application require and what do I need to track um one thing I'll add here is also the question of what state do I need to track so we'll talk about this concept a little bit here in a minute but I'm going to kind of organically talk about this throughout the rest of the video because it's quite challenging at times if you're not super familiar so when I say state I'm really just talking about you know what does the current state of the game look like so that might be things like um current player might be total wins by player we can also track total type here total ties and then prior game history those kind of things are the things that we'll want to track and to do that we're going to just build this you know step by step and we'll eventually come to some sort of model that we'll use to track that state so not going to talk too much about that at the moment let's dive in and start building this out and you'll start to see how this makes more sense in a minute so the first thing that I'm going to do is try to implement a basic move so in other words I want to display an icon in these squares when they're clicked we're obviously already registering event and getting the ID of the square that was clicked so that is useful to us but we need to change the Dom or the UI when that happens and to do that the first thing I will generally do is go to the HTML and just mock something up so just figure out how to statically display that for the first time so I believe all we're going to need to do is put in an I tag with a class and then that's going to be one of our font awesome icons so let me just check my references right here to see which icon we're dealing with okay so it really should just be fa solid is the base class and then it's going to be fax or FAO so we'll uh simulate both of those here just to make sure that our game board is going to display things correctly so fax and FAO and you can see that we've got those displaying correctly so this is the right size obviously these are not the right colors if we were to open up our CSS if you remember from earlier in the video we had some of these shared classes here at the top somewhere and in these shared utility classes I gave us a yellow and a turquoise class just so that things are a little bit easier to deal with and easier to remember so what we can do is just pass in yellow and then turquoise into that class list and then our X's and O's will be the right color now obviously you can see we've got mismatches just about everywhere we'll get that worked out in just a moment so if we're trying to do this with JavaScript obviously we can't just statically put in these different icons we're going to basically build these elements and add them as children to the appropriate div that has been clicked so what I'm going to do is open up app.js again and right down here in our event listeners for each of the squares I'm going to just copy over this HTML and add it as a comment and that's just for reference so that we can look at it and translate it into JavaScript so we've got fax and then FAO these are the two that we're dealing with so we can get rid of those here in the HTML and then in app.js we know which ID was clicked and the event itself carries a Target which represents the individual square that was clicked so what we could do just to start us out is actually derive that or not derived but create this I tag so let's call it an icon and we can say document.create element is one of the builtin browser API or Dom methods and we just need to give that a tag of I so we've created the element and then we can say icon I'm sorry not redefining it we can say icon.class list and then I believe we can just um add an array of tokens and what that would be the classes themselves so we would want to add f a solid f a x and then let's say yellow so we're just kind of hard coding an element we'll hard code a yellow X in this case and then from here we've created the element but we need to insert it into the Target that was clicked so really what we could do is just say event.target dot replace children and then I think we can just pass in the icon so that should work let's go ahead and click and you can see something's going on it's not working so let's inspect you can see there's some sort of content in these div elements and it looks like our icon class or icon element has been added but the class list has commas so we need to not do it that way we're not supposed to pass an array I guess maybe we're just supposed to pass um multiple arguments let's try that okay so that's working better and now you can see that the content within here or where did we go the content within the one we clicked has the correct class list now so now anytime we click any of these we're going to get a yellow X and obviously this is not useful yet we're just filling them up with x's and if we click them twice we also can have problematic Behavior because we're not checking to see if there's an X already there we're just adding it no matter what so that is problematic but at least we've got something working here so ideally what we want to do is know whose turn it is and then depending on that turn we'll choose either fax or FAO and then the yellow or turquoise color and at this point we've finally reached a place where we can start talking about what state is and what state management really represents here for us so to do that I'm going to pop over to the Whiteboard again and we're talking about game moves and what state do I need to track well I think the next question really is what is state well there's really two types of state that we can talk about so we have client State and then we have server State and these are very loose terms so there's a little bit of an overlap between the two but these are the two kind of categorizations that I would be using so when we're talking about client state the way that I think about that is any sort of um uh state that we have within the Dom that does not need to change anything that is persisted long term so I guess that's a complicated way of saying something like this actions menu popping open and closed every time we open and close this the clientside state is changing but we're not actually doing anything you know to persist that change so if we opened this actions menu up and then refreshed the page it's going to close every time because we're not tracking that state across browser refreshes it's just temporary inmemory state that we're tracking so in other words client state a good example of that let's just make an example over here let's add some code here so let's say client state equal to and make this a hopefully was going to get that a little smaller but let's open up some brackets so client State might be something like is menu open and we'll start that with false and so as you can see when we click this menu that state variable is going to update it's going to be either open or closed true or false and that's not going to persist across browser refreshes now server State and server again is kind of a loose term here because we don't actually have a server we're going to be working with local storage to kind of emulate that but generally server state is kind of what you would think of as a database so it's a snapshot in time it's a snapshot of what the current data looks like so this would be more conducive to something like a game move so we could copy this down foreign State could be something like a current player and let's just put an ID in there let's say player one is the current player and then we could also add things like we've got the current player how about the history of games so we might have an array filled with all the different games that we had played in the past we could also track things like um we can also track things like the current game so this might be an array of game moves that have happened and that way we can track across browser refreshes you know who has moved in which Square so these two types of State we're going to need to track and we're going to eventually refactor this to be a little bit more stable but as I said in our kind of game plan over here in this video progression we're doing everything in one file as a naive approach and then we're going to refactor it to be a little bit more stable so what that looks like for us in terms of state I'm just going to create a state property on the app okay and to start out state is not going to be persistent across browser refreshes because this is just a variable and every time we refresh this is going to be reinitialized and reassigned so the first piece of state that we want to track is current player and for now I'm just going to keep things very simple and we're going to say that each player is represented by a number it's going to be either one or two so we'll say that player one is going to always start the game so we'll track the current player and that alone will allow us to decide down here in our event listener which icon that we need to put in the Square so obviously we need to update that state each time a move happens so if we were to um we'll leave this console log here but every time something is clicked what we're going to need to do is say the current player is going to be equal to app.state.current player now you don't need to save that to a variable I'm just doing that to kind of be a little more clear here and then we're going to say if the current player equals one we're going to add a certain element to the Dom otherwise we'll just assume there's only two players here we'll add a different one so in this case let's just say that player one is going to be a yellow X so we can create the icon no matter what because it doesn't matter that's not styled at all but the class list is what we're going to use based on the player so if it's player one we're going to have a yellow X and if it's player 2 we're going to have a turquoise o so we'll put in turquoise right there but the thing is we need to of course update that state every time this move happens so we'll go ahead and create this icon add the class list and then what we're going to do here is say app dot state DOT currentplayer is going to be set equal to whoever is not playing this move so in other words if let's say the current player is one and has created you know this class list so we're going to say if the app dot state that current player equals one then we're going to set the current player equal to two otherwise we're going to set it equal to one so in other words it's sort of just a toggle on who's playing the game and then finally we'll take the event Target which is the square and replace the contents of that square with the appropriate icon and so next time this is clicked we'll know which player to use so I'm going to also log this up top we'll say the current player is and then we'll say app.state.current player so we can get rid of these down here and then there's one more important thing as you saw earlier we can't play in a square twice so we need to know if the square already has some sort of element within it let's go ahead and just save this and see what we're dealing with now in our game so we'll click a square and then the next one should be an o and it is and that's because we've updated the state every time we see a new play now I think if I'm not mistaken what's going to happen if we click this twice so let's say that we click this Square again it's going to add an X to next to the O which is obviously invalid and now it's going to think that the O's turn is up even though X should still be up because they played in the wrong spot so that's obviously a problem and the way that we fix that is basically putting a check within this click event and we're just going to say is there something in that square and if so we're going to return early and we're not going to allow the player to actually play and this will prevent us from updating the current player in state and it will force them to replay before the next player can go so the question is how do we check that well we're going to eventually do this to be um we're going to eventually check this in a much more stable way but for now I'm just going to keep things simple we're going to go to mdn and go back to the element reference so elements reference oops I clicked the wrong one I just want literally the element class so which one is that I think this will work so we've got element.get attribute now we can look through all of the different methods that are available on an element and there should be one to check if there are children already within that element I'm not finding it here so I'm just going to search what I know here has child nodes and we're not finding it on element because it exists on the base class of node this is like the abstract Base Class pun which many other Dom API objects are based so basically any element as it mentions here will inherit all the methods of node so we can use this has child nodes method and this returns a Boolean value indicating whether the given node has child nodes or not in other words what we can do here is the first thing we do is say if event.target dot has child nodes so if there's any X or o in there we're just going to return we're not going to update anything we're not going to update the state we'll just return from that function early so by adding that I believe we should get the desired Behavior here so we'll click one click two and then try to click this one again and it's not working let's see why so I had to pause the video to figure out what was going wrong here and it's a little bit tricky bad programming on my part but basically what happened here is when we clicked on the icon itself you can see if I like specifically click on one of these icons it's going to continue adding icons now if I click somewhere else in the Square it's going to have the correct behavior and what's actually happening here is the event Target so right here is going to represent what was actually clicked so the element that was actually clicked in the Dom now the square up here is going to represent the square that we're actually looking to Target for this Behavior so if I were to console log this let's go ahead and say um console log we'll say the square and then we'll pass in the Square itself and then we'll console log the event Target and then we'll pass in event dot Target now what you're going to see is as we click right here the square is going to represent that div and the event Target represents the div because we clicked on the same thing now if I put the mouse in the middle of that icon remember we now have a new HTML element right here if I click that it's going to register the event Target as that I tag rather than the div so what you'll see here is that the square and the event Target will not match up when I click this and we'll have that weird Behavior so you see the square is the div and the event Target is the actual icon to make this Behavior more stable and just better programming practice in general we should be updating the square element itself and not relying on the event Target because we can't control whether the user is going to click the icon or the square we need it to work no matter what so let's remove these console logs and then instead of checking whether the event target has child nodes we're going to check if the square has child nodes and then furthermore where we're replacing the children down here we don't want to replace the event targets children we want to replace the square so that will make all of this Behavior a lot more stable and when we save this we should be able to click in any Square as many times as we want and you can see our console log is going to say the current player is one still so if I'm clicking any of these the turn is not changing the Turn Only changes when we the player clicks a valid square and then we're going to have a different current player so we've got this working this is kind of some boilerplate for what we're going for we will refactor this to be a little bit more stable some better practices but for now this works just fine I'm going to clean this up we don't need these console logs anymore um the next thing that we're going to need to do is if we just keep clicking these and playing the game you can see when the O player I think that's player two when they win the game nothing happens and that's because we haven't programmed anything to happen so we need a way to detect when this game ends and there's going to be different patterns that represent a winning game and then of course we can also if we refresh reset everything we can also end up in a tie so I believe if we let's see if I can even produce a tie here um requires a little bit of thinking to do that so in this case the game should be a tie and we should be able to recognize that now they're in the original project that I'm I was refactoring here they had a pretty nice way of handling this and they'll want to highlight that so if we open up main.js from the original project um what they were doing to check whether the game was won is they had an uh basically an array of winning patterns and they were basically just checking which squares were currently um had plays in them and did they match these winning patterns and that's how they would determine whether the game was a winning game so I'm going to copy this array here and I'll show you how we're going to use this so let's start writing some comments here because our method is getting a little bit large so check if there is already a play if so return early because we don't want any turns to change or anything like that then we'll come down here and we'll get the current player we'll create the icon and we will add that icon to the div right down here and then the next thing that we need to do is let's let's actually put a comment here determine which player icon to add to the square and then finally check if there is a winner or tie game once again we're going to refactor all this so I know it's getting pretty busy in this method we're going to refactor it I'll show you a better way to do this for now we're going to paste in those winning patterns and so the question becomes how do we know the current state of this game how do we know what squares have been played in and which ones have not been and furthermore which player has played in each of the squares now we could of course do some elaborate check where we basically say you know we search the current Square we check if it has anything in it and then we could maybe check the class list and check if it's an fax or an FAO and then basically Loop through all of the squares on the board to determine what the current state of the game is but what's a lot easier to do is to just track that and State as we go so rather than doing this sort of check we can just check the state but first we need to Define what that state is so what we'll say is that we need to track an array of game moves and those game moves are just going to be the player that has played so what it might look like is something like this where we have um I'm sorry we we need to track the square itself too so we're going to say the square ID is going to be 1 and then the player is going to be one so that move right there would represent if player one clicks this top left Square so we basically are just tracking a square ID and a player ID in the moves array so let's empty that out that's going to be our default state is an empty game and then down here within this event listener as you can see we're updating the current player in state but what we also want to do is we want to push a move to state so app.state dot moves and then we want to push a new move that is going to be an object with a square ID and let's just um reference the square itself or we could also say the yeah we'll just say the square dot ID and this needs to be a number so we'll add a little coercion there to make that a number type and then the player we'll just call it the player ID just for consistency that's going to be equal to the current player of the game so we've already updated the current player right here to be the next player so we need to actually put this state update right above that so that the current player is right so we'll say um I don't know why we're checking this right here we've already extracted that there so let me refactor that real quick and then we can put current player right there and then just for us to see what's going on here I'm going to console log app.state after those updates have happened at the moment this isn't going to change any of the behavior we're just tracking another state variable so let's click something click another click another and you can start to see we're building up State we're building up an array of moves and you can see that square id1 has a move from player id1 so the x square 2 has a player ID of 2 an O and square 3 has a player ID of 1 and an X so you can see as we add moves we are adding to that array of moves now what's interesting about this is that we can also derive some State here we can simplify things a little bit so if we go back up to our state you got to ask yourself well who is currently up based on the number of moves that are in that array we actually don't need to track the current player because we will be able to derive that based on the moves that have been played so let's actually delete the current player from State all we really need to track is moves and I'll show you how to derive that right here so the first thing that we want to update um is let's see the current player variable right here so what we can do is we can say if app.state.moves um that length equals zero so if there's been no plays at all then we're going to say the current player is one we'll just always say that the current player is one they start the game every time if it is not equal to zero then we're going to check for the last move of the game so the last element of that array and then grab the player who is opposite of that player so this is going to require a little bit more logic than we have right here um so I'm going to break that out so we'll say the last move is app.state.moves and then you can use a little convenience method you could of course check it by saying app.state.moves dot length minus one that's a typical way that you could grab the last element of the array but there's a more concise way with JavaScript you can just say at negative one which will grab the last element of that array now of course we don't know if that array has anything in it so that could be I believe undefined if there's nothing in the array so now we can come down to the current player we can say if the length of the array is zero we'll go with one otherwise we're going to grab the last move and that move has a player ID in it so it's going to not be the player ID of the last move it's actually going to be the opposite of that so what we can say is a little convenience method get opposite player and we'll just pass in a player ID and we'll say if player ID equals one then we're going to pass in player two otherwise one so we'll say get opposite player of the last move sorry this is getting a little complicated we'll break this out into some helper methods later but basically what we're doing is we're finding the last move we've got a helper method that gets the opposite player and then we're checking to see if there's any moves if there is if there's not any moves then player one is up because it's the beginning of the game otherwise we're going to get the opposite player to the last move that was played and that will give us our current player and that way we don't have to track any of that state and that should flow down to here where we're checking and adding moves to the game so let's save that and see if it works you can see that we're alternating and we can click on these as many times as we want and it's pretty stable now there's one more thing that we can do now that we're tracking the game moves we don't really need to check whether the square has child nodes because that's really relying on the Dom itself it would be better just to express what we're trying to do to check the state of the game so let's say um we need a helper method called has move and what we're going to do is just Define a function that takes a square actually a square ID so it'll be a number and then we're going to just basically return or we're going to say existing move is equal to app.state.moves and then we're going to look for that square ID in that array so we're going to call find and we're going to look at the move and check if the square ID matches the square ID that we're passing into this helper function and then we're going to return the existing move does not equal null and that's another way of saying does not equal undefined or null so we could also say does not equal double equals undefined okay and that will give us whether there's a move so now we can replace this with has move and then we can just pass in the Square dot ID and make sure that's a number so that it's comparing the same type I think if we got this right we should be able to click squares multiple times and it will not do anything which is telling us that our check has worked okay so at this point I know that we've done a lot of refactoring and it seems like for nothing but the goal of this is whenever you're tracking state within an application you want to keep it as simple as humanly possible and the reason being is as we've seen down here where we're actually updating the state to the current player which by the way we can get rid of now because we're deriving that information but when we update State as we're doing here in the moves pushing a move to the array every time you track something in state you also have to update it somewhere and the more things you track in state the more updates you're responsible for and therefore the more possible errors that you're going to introduce to your application so the goal with tracking state is to keep it as simple as possible so that you have the least number of variables to keep track of over the life cycle of your application in this case all we're doing is tracking an array of moves and then from that little piece of information we're able to then derive who is the current player and from that we can then you know update state to to make another move within the game at this point we've refactored our state and we're updating it to just have an array of moves which is a lot it allows us to derive pretty much everything that we need to know about the current game now the next thing that we need to do that we can now actually do with this state is find whether someone has won the game or if it's a tie or if it's still in progress so what we're going to do is actually make a utility function for this and I'm going to add this just at the top and this is not going to be the final destination of it um actually we could even just put it within the app but we'll probably rearrange this in the future so what we want to do is call it something like get game status and this function is going to take an argument here so what are we going to pass in will be an array of moves and then we also probably need well I think that's pretty much all we need we just need an array of moves which is tracked in state so with that array of moves we should be able to give a couple pieces of information so we'll Define the return value of this just to start the first thing is going to be the status which this can either be um we'll call it in progress or complete so we will put a placeholder in there for right now but this will become dynamic and then we will also give a winner which again will put a placeholder in there but this is going to either be one or two so player one or player two and then also it could be null which would represent a tie so that's kind of how we're going to um represent this and based on these two pieces of information we should be able to know whether the game you know what to show in the UI whether we show the modal that pops up and gives the result or we keep playing so to do this the first thing we need to do is get player one moves and the moves array that we're going to be passing is the entire game so all we need to do is filter that and then check on each move whether the player ID is equal to one so that will give us player one moves and then we can copy that down and change the ID to get player 2 moves from there we should be able to bring up our winning patterns so this will now come up in that utility method we'll paste that right there and what we want to do is Loop through each of these winning patterns and check if either of the player moves have all three of these within their array and if all three of them match then we know that one of the players has actually won the game so the way we can do that is start out by saying the winner equals null so we'll just assume to start that it's there's no winner and what we'll do is map through the winning patterns so we'll do a loop for each Loop and we'll call each of them a pattern because this variable will represent one of these arrays and then we'll break that down into a function that will check for this condition so we'll say player one wins and that is only going to be true if every value within the pattern so we'll just say V for value we'll say player one moves includes that value so again we've got player one's moves the array of moves they've made and then we have an individual pattern and if there's a hundred percent overlap between player one's moves and a given pattern we know that they've won so the same thing can be said about player two so we can copy that down again and just update that array and that should tell us whether each of the players have won so then we can write an if statement and we'll say if player one wins then we just update the winner to be equal to one so that's their ID um and then if player 2 wins we'll update the winner to be equal to So in theory this should only be one player that can win and if we don't hit a true condition for either of these then the winner will stay equal to null and we'll just assume that's a tie if the game is complete so we come down here and instead of hard coding that we can just remove that and winner will be assigned to this variable right here so that's either going to be null for a tie one or two and then the status of the game is going to be in progress if there are either no winner or the game moves does not equal nine so if we look at our game there's nine squares so if all of them have a move then we know that the game is over so that will be our first check we'll say if the moves dot length is equal to nine then we can say that is going to be a complete Game otherwise it will be in progress now we of course need one more check here so if the moves that length equals nine or the winner does not equal no yeah so we're checking whether the winner does not equal null because that would represent that someone has won before the game reached a final state of nine plays which would be a tie so that will help us figure out what the status is so now with this utility function get game status we can come down here and where we're checking if there's a winner or a tie game let's just assign that to a variable called status so we'll say app.getgame status and then we will pass in the app.state.moves and that's going to represent the newest array of moves that has been played let's console.log that status just to see what we're dealing with and let's play a couple moves so you can see the status is going to print every time so our game's in progress there's no winner still in progress and then this click right here should change the status and you see that it doesn't and we'll have to check out why because that should have updated to complete and populated a winner of player one so let's go ahead and check that see what is happening here just to debug this let's go ahead and just do a classic console log this will be quite a few logs because we're going to be printing on every pattern here so let's just console log the pattern and then player one moves in player 2 moves just so we can get that in one big object and then we'll play all these moves and then right here this is where we should be getting a different result than we're getting oh and I can already see what's happening here so what we did wrong what I missed is when I was filtering the player one moves this is just going to give me the entire move so if we print that out to the console what you'll see is in this array we're printing an object with a square ID and a player ID and when we're comparing that down here in the every utility method we're actually comparing a number which is the key of the square to that object which will never equal each other so what we really need to do is actually add a map utility at the end and we're going to map that move to be a number value that is equal to the square ID of those moves so now if we print this out into the console player one moves this should represent an array of numbers now as you can see representing the coordinate um of this of the place so this should be one two and then one two three and now you can see that the status is complete and the winner is equal to player one so our utility method seems to be working let's reset the game and try to tie the game so let's mix this up here oops I accidentally won it's kind of hard to tie this game okay so now we've got a tie game and you can see that the status is complete and the winner is null so that should tell us that it was a tie game so now we can Implement that logic down in our event listener so down here at the bottom where we're just console logging the status what we'll say is if the status equals complete then what I'm going to do is just make an alert in the in the browser so we'll say if the status I'm sorry this should really be status dot status so we should probably rename this variable we'll say game and this will be game dot status and now we'll say if the game um if the game has a winner then we're going to alert player winner wins otherwise we know that it's a tie so we'll say tie let's try this out so let's go ahead and make player one a winner says Winner's not defined for some reason and that's because I'm not referencing it correctly try that one more time and there we go player one wins so kind of small but you can see now we've got the essential functionality hooked up and at this point I think the next step is to trigger that modal to open when someone has won the game or there's a tie but before we do that let's just recap what this big long event listener is doing so first We're looping through each of the squares on the game board and we are adding a click listener to that square when that square is clicked all this code is going to run so the first thing we'll do is check if there's a move already present within that square if there is we're going to exit early and not do anything because someone can never play twice in the same square once we get past that we know that there is a valid move so we're going to check who Moved last based on the state we're going to then get the opposite player of that last move and set the current player of the game we will then take and create an icon and based on the player who is up we'll add an X or an O as an icon and then we'll put that in the Dom and we'll add that icon to the square we'll also push a move a new move to the state so that we're tracking the history of moves in the game we'll then check the game's status after that move has happened and if the status is complete we then know we can do something and open a modal to explain whether someone has won or if the game was a tie and now our goal is to open that modal and give the user an action to actually reset the game and start over if you remember from our index.html when we built this a couple hours ago you'll see down here with the modal we just have that hidden class sitting on there and if we remove that and save the file you'll see that we get this dialog to open and it's going to cover the screen with a play again button so the things that we have to do is number one we have to trigger this to actually open and then close when we're done with it and number two we have to add a click listener to this button right here so that when someone clicks play again the game state has reset and you know everything goes back to the beginning so let me add this hidden class back because that's our default state and as I said this is going to be refactored at some point we've got a lot of code all sitting in one place which is going to be hard to follow long term but at the moment we're just putting everything in one method keeping it simple so that we don't have to refactor anything quite yet so the way that we're going to do this is First add a selector to this modal so just like we've done up here with let's see we've given data IDs to the elements that we're going to select and control with JavaScript so we'll do the same thing with this modal let's just call it modal and then the modal contents will also give it a data ID and we'll set that equal to modal contents and what we're going to do here let's see or actually we're not going to put it there because we don't really need to control that we need to control this text element so data ID equals modal text and then this will be the data ID modal button so you don't really need to add these data IDs to all of them because really you could just select the modal and then grab those elements dynamically I'm just being pretty explicit about it just for clarity so let's go ahead and select these within our app because that's kind of what we've been doing I'm just collecting all of these elements that we've selected so let's copy this down and we'll name this one modal this data ID will be modal and then we'll say modal text and modal button and as you can see we're doing a lot of repetitive stuff here so if you're thinking this will be refactored too to be a little bit simpler and to eliminate the need to write all of this boiler played out but I'm leaving it here now because it's it's pretty clear what's happening so now that we've got these three we can pretty much control them down here in this check on the game status so if the game status is complete and we have a winner the one thing that we know we need to do is print to the modal who has won that game so let's just say app dot dollar sign because that's our namespace for all of those elements um actually first we need to open the modal I'm sorry so if the game's complete we know that we need to open the modal so modal and then what we're what we're going to do is look at the class list in toggle the hidden class on that but to be a little bit more explicit since we know that we're opening it here rather than toggling the hidden class which could work there what we're going to do is actually remove what is the yeah we should be able to say classlist.remove that hidden class so let's try that first let's make sure that that's working so someone wins the game here and says modal.classlist is undefined so we mess something up here oh and that the problem is we're using query selector all because that's what we had for squares this should just be a basic query selector so now I believe this part should work so let's win the game for someone and we get the alert but we also get the modal so let's remove this alert um for the moment because it's kind of getting in the way but now that we know there's a game winner what we can do is we can say that the text is going to be equal to player and then give the game.winner so that'll be the ID so that's the message that we want to put so let's call that message actually and here our message is going to be tie game and then all we have to do we can actually extract that to a message up here um and then assign that there and then no matter what we're going to say app dot dollar sign dot modaltext dot inner text or is it inner HTML I can't remember uh it's not in or anything it's text content is equal to the message so let's save that and see if that works so someone's going to win the game here and it's player one now let's refresh the page and this time let's let player 2 win so player 2 wins and you can see that dynamically will populate now the last thing that we need to do is put that click listener on the play again button we're not going to do that in this method because remember we're registering our event listeners all at the top level of this function so let's just put that right here we'll say app dot dollar sign dot modal button add event listener we're going to listen for a click event and then with that event all we're going to do is set set the state DOT moves equal to an empty array because we want to reset the game and then we also want to close the modal if it's open so the way that we'll do that is app.d dollar sign dot modal and then classlist dot actually not remove we want to add the hidden class back so that will hide the modal so now that should be hooked up and if we go through the game someone wins and we click this button it closes it and you can see there's still game moves here because resetting the state doesn't actually change the UI quite yet we will refactor that at some point but at the moment it does not so not only do we have to reset the state but we also have to Loop through each of those squares and empty out their contents so let's see how we would do that is we'd say app.dollarsign squares and then we'll say for each Square we're going to say Square dot replace children and just leave that empty and that's just a shortcut to clear everything out of the squares so now let's go back and try it one more time someone wins the game we click play again and everything has cleared so we now have a functioning tictactoe game player one wins again see if we can get a tie here you have to really think about this one to get a tie um let's see that should work okay there's a tie game play again clears it out the last thing that is not working here is this turn indicator you can see that no matter what we play it's just staying the same and we obviously want to update that now a great place to do that is going to be within this super long event listener for each of the square clicks where we're updating the current player so we'll actually do that in this if else statement but first we have to grab those elements that we want to update so let's find the turn indicator and you can see right here this is where we're doing it and we've got an icon that we need to update and some text that we need to update so here what we're going to do is add a data ID and call that turn so we'll now go select that in our list of elements so we'll say turn and then just copy this down again and one thing that we need to do here that I kind of missed is we've got the turquoise class set on the individual icon but we want these both to match so it would be a little bit easier if we just put that up here on the turn element and we also need to match things up so the first player is player one which we're just determining is going to be X and that's going to be yellow so we need to match those up let's save that and just make sure that this is matching now which it is so this is what we're looking for as a starting point and now all we need to do is just toggle this from yellow to turquoise and back and then we'll toggle the elements within it to indicate the turn so we can do that here um one thing we'll need to check is get a little bit more clear on who's up next so the current player represents who's actually clicking right now the next player is going to be the one that we want to change the turn indicator for so you've got the current player and then we can say next player and reuse that get opposite player I know we're a little redundant here um but we'll go ahead and use it so this should represent it in the ID of the next player now we can come down here and say the turn label is going to be a new element you could have replaced the element that's already there but I'm just going to create a p element and then that turn label dot inner text is going to be equal to player next player what we determined up there you are up and we'll copy that down um actually we can just put that right there and then from here we can just say app.d dollar sign and select the turn element so remember we're just selecting this entire div and we want to replace the contents of it so all we need to do is say replace children and then we can pass as it shows here we can spread out parameters as individual nodes so it will replace them in order so if we want the icon to go first we just pass that there and then we'll pass the turn label when we save this let's see if we get the correct result so I'll go here and you can see that we're getting the correct text but the color is not updating and we're not getting the icon to also be added I believe the problem here is we're actually adding this same icon to two different places so we probably need to break that out into two separate elements so we'll say turn icon and then this will be the square icon so those will be two separate elements and down here we'll pass the square icon and then here we'll pass the turn icon and we of course want the same exact colors here I believe or actually no these need to be opposite because once again we have the next player is going to be the opposite color of the current player so we'll say the Square icon and then we'll copy this down and this will be the turn icon and this will be the exact opposite so this will be the o and it will be turquoise this will be turn icon with an X that is yellow once again we are going to refactor this it's not going to be this confusing and verbose here in the future so hopefully this works now we're getting a lot closer we have everything correct except for it looks like this text is O is yellow and it's because we're not setting the color of that so we need to say the turn label dot class list and let's go ahead and do that down here so turn babel.class list and we'll set that equal to turquoise to match what we're making the turn icon right here and then we'll copy that down and make this one yellow if it's player two so now it looks like we're getting everything correct so if we play in O now X player one is up if we play an X well we've got to play again but you can see that that is updating correctly now as you noticed if we end the game and player one wins you'll see up here player 2 has it is up next and that's their turn and if we click play again that's not going to reset so we need to remember to reset the turn and since we've coupled all of that turn logic within this event listener we have no easy way to do that up here when we're resetting everything so at this point we've reached a place in our code where we've got a lot of stuff going on right in this method that we would like to be able to reuse in different places to like reset the state and whatnot but right now it's very hard to do that so the next segment of this video is going to be taking this code and refactoring it to look a little bit cleaner and be more reusable and easy to follow so we'll go through that but as of right now we have a working game for the most part as long as we refresh things and we can determine who wins the game so once again we'll refactor things then we'll start talking about keeping this state for the scoreboard and then moving into the MVC pattern so as we talked about we've got the naive approach all in one file that's what we're still on we've been refactoring iterating as we go and then we'll end up with something pretty clean that we can reuse and extend into the future so we've reached a point where our code is getting a bit confusing and if we continued to add this functionality so if we were trying to reset this turn indicator when the game ends remember we've got a problem here it doesn't reset and then we also have to be able to reset the whole game and reset the round track all of this state you know the history of the games there's a lot to do here and given our current code it's going to be very confusing to do because we've got all this stuff in one method there's all sorts of stuff we're updating State we're updating the view all in one spot so this is where a pattern comes in and helps us out a bit I waited until this point um to mainly simulate a real life scenario where generally you're going to start off in one file just to understand the logic that you need within your application and then as you go you you have to refactor to keep things clear in your head and to make the code maintainable so at this point we understand what patterns we actually need here and that makes it a lot easier to introduce something like an MVC or model view controller pattern just as a side note the MVC pattern is really relevant to something like Ruby on Rails so if you typed Ruby on Rails and you go to the documentation you'll start to see a lot of these patterns and if we were I'm introducing this not because I think you need to use Ruby on Rails but more so because it's kind of the Premier example of a framework that leverages this model view controller pattern and has gained a lot of popularity so if we go to the docs let's see if we go to the API Maybe that's probably not where we want to go so as we're scrolling through the docs you can already see there's a header section called models then there's views and then there's controllers so they very explicitly build out this pattern so this is just a good reference you don't need to check this out I just wanted to point it out so enough Theory here let's get into this the way that we're going to build this model view controller pattern is actually by breaking this single file out into those three different responsibilities and that kind of brings us back to our best practices so whether or not you're using a model view controller pattern there's other patterns that you could use the main point here is that we want to separate um logic by um responsibility in other words this is the separation of concerns principle that is just a good programming principle in general it's something that you would always want to try to aim for no matter what pattern you're using so let's jump back over we've obviously got quite a bit of functionality here that we don't want to have to completely redo a lot of this is good stuff that we've worked out but we do need to refactor this into a couple files so in our JS directory I'm going to add a new file one called the view.js one is going to be called store.js and this will actually represent the model I'm just calling it store because it kind of represents the storage that we're using you could call it whatever you want um so we'll call that store and then app.js this is really going to be our quote unquote controller it's not a super explicit um adherence to the pattern but we're getting very close and the goal of a design pattern is to make things easier for you so you don't need to follow it so rigidly that everything matches up one to one as long as it's useful it is going to be okay so as we go and build this out I'm going to be kind of looking up here um to my other screen because I've actually as you know I've already built this app out in preparation for this video and I just want to make sure that this live build that we're doing matches up with the final code that you're going to see in the GitHub repository that is linked in the video description so that's all I'm doing I'm just making sure that I'm naming the methods the same so on and so forth so what we need to start with I think is going to be um let's go ahead and do the view because that is what most of this logic we have in our application is pertaining to at the moment so let's open up View and we're going to be jumping into some objectoriented programming Concepts here so that's just another way of saying we're going to be working with some JavaScript classes and specifically es6 syntax 4 classes I'll try to point out some of the syntax that I'm using and what it means but if you are not at all familiar with classes and what they are and how they work I would recommend brushing up on that pausing the video and just reading a couple you know overview guides just to get yourself a little bit up to speed that said I will try to explain things as we go and I'm not going to assume that you have any sort of advanced knowledge here so we'll we'll walk through it together so the first thing that we need to do in our view is Define that class that we're we're going to be using now we can call this a class of view and that's really all the syntax that we need we of course will use a Constructor this is kind of the initialization of the class and it belongs on it's available on any class that you use and then furthermore we're going to start to bring over our methods so there are things um that are available on the class instances um called class properties and that's where we're going to store those elements that we had defined earlier so we'll just initialize the dollar sign to an empty object and we'll start populating that here in a second so the first thing that we want to do in our class and we'll do this in the Constructor because we want all of these elements to be selected when the class is initialized so we'll go back to our app.js and we'll take all of these selectors that we've used and we will assign them in the Constructor so we'll have to update some of the syntax here but really we'll just click down and select a bunch at once and what we'll say is this dot dollar sign dot whatever the variable is because we are basically referencing when we say this we're referencing the class instance itself and on that class instance we have defined a property uh which is the dollar sign this could be any variable we're just using a short name space for easy easy way to access and so what we're doing is we're saying the class instance the property that we want and then the um another nested property that will represent the element itself so now instead of colons we'll need to set those to equal signs and then we'll hit command s to format things and save it although we've got some commas here at the end that we need to get rid of first now we can save it in a prettier we'll format this for us remember as I mentioned earlier in the video I've got format on Save setup with the prettier extension in vs code so that's why it's saving like that and formatting everything so at this point we've got our basic class and when it initializes we're going to select all the elements in the document but just having this alone it's not going to actually work quite yet we need to connect this to our app.js furthermore we're not going to really need this namespace anymore because we're going to be working with um or we we may use the namespace but we're going to be moving pretty much all of this code out but in order to do that without completely breaking everything I'm going to leave all the code intact it's just a good way to do it when you're refactoring something you want to leave the original code intact and just build the new code side by side and then you'll replace it at the end but since we're not going to have any of this code here anymore what I'm going to do is build this side by side and we're going to just make a standalone function called init and yes this is in the global namespace but this should could really be the only thing this and maybe one other variable that we'll put in the global scope so that should be fine and what we'll do in the init method is basically initialize the class itself so we'll say the view is going to be equal to New View so that is going to make a class instance of this class right here and then what I'm going to do just to test things is console.log view dot dollar sign and then let's just say turn because that was one of the elements that we selected in other words we're just testing to make sure that this was initialized correctly furthermore we want to duplicate this event listener we will eventually remove this once we've refactored everything but for now we just want to use this knit method when the the window loads so let's save that and then go back to our browser let me get these tabs organized again okay so we'll go to our browser here and go to the console and it's going to say uncut reference error the view is not defined and there's a good reason for this it's because we have not imported that script now obviously app.js has been imported right here at the bottom but we would also need to import the view.js for that to be defined and if we come back now you'll see that our console log worked because that's now defined but let's go back and flip these let's put them in a different order so we first load the view and then we load the app does it still work well the answer is yes and I believe that's because of hoisting that happens with JavaScript um but what's confusing about this is we've got these two separate files with different variables and they kind of reference each other but that can get confusing when you have more and more files so one solution to this that will help us out quite a bit and allows us to just import one script is to use es6 modules so instead of adding this additional script import which gets messy once you have five or six Scripts we're just going to import app.js and then we're going to set a type attribute on the script and we're going to name it module what this is going to do is it's going to tell the browser that this script is an es6 module and now in pretty much every major browser es6 syntax is supported as well as modules so this is a nice way to handle imports and exports so now in app.js rather than just referencing this view class variable we can import that so at the very top of our file what we'll do is we'll say import view from view.js now right now this is not going to work and it's not going to work because we haven't exported anything from this module what we need to do is put an export and then we want to export this as the default export so that we can reference it in our file just like this now if we left out this keyword of default we would need to put this in Brackets in reference it just like this so if we did that this should work if we go to the browser you'll see that this is being printed out which is what we're doing here at the bottom right here that's the console log but I think it's a little cleaner if we just export the default go back to app and then remove these brackets save it and then we'll check to make sure this console log is working and it is now another property um or feature of using modules is that by default they use strict so if you've ever seen use strict in JavaScript use strict we'll look that up strict mode is something in JavaScript that used to be really relevant as you had different files that would have different modes nowadays you'll pretty much see strict mode on every file that you ever write but this has a lot of useful defaults to kind of protect your code from all sorts of problematic patterns so by default these es6 modules or in strict mode which means that in the view.js you might say well oh this view is in the global scope but that's not the case we haven't actually attached it to the window so if we were to go to our console and type view it's going to say view is not defined the only way that that would be possible as if we said if we explicitly attached it to the window like this so window.view equals View and now we should be able to see the class that we've defined but this is not what we want and I just wanted to point that out as a feature of es6 modules by default they're going to behave this way and we're going to protect the global scope that way what this also means is that our init method if you remember from earlier scrolling up we had defined this app variable as the namespace around our entire app so that we didn't litter the global scope with all of these variable declarations but now if we try to access app at all um we're not going to be able to because it's in an es6 module and by default that is not exposed to the global namespace so that's basically why I'm okay adding this init method in the global scope because I know that's not going to be exposed in the in the browser unnecessarily so that's just a little tidbit but let's keep moving here on our refactor so looking through our app let's also find other things that relate to The View one of those things that is very relevant to just a view class is these event listeners we want the event we want the view to register event listeners initially so we can copy all of this over in my final code I want to see how I which method I put this under so in my final code each of these event listeners has its own method in the view so I'm going to open up two code Windows here and make it a little bit smaller for us hopefully you can still see that and what we'll do is we'll basically take each of these event listeners and make it its own method within the view class so just to stay consistent with my naming we will call the first one bind game reset event so that is the game reset and this is actually a new pattern that we're introducing rather than handling the event listeners within the view we want to do that in the controller and the reason being is because the controller is going to read the current state of the application and based on that state it may have to do different things to the view so you don't want to leave it just to the view itself to handle these events so we're going to put a Handler callback function passed as an argument to each of these event listeners so we'll use some es6 syntax to Define this function and then here we're going to actually register those event listeners so I'll type out the first one just so you can see it slowly and then we'll copy things over so for example let's look at this one um or no that's not a good example we'll use the reset game here so all we're going to do is reference these initialized selected elements that we have so this dot dollar sign dot which one are we selecting here reset button and then just like we're doing over here we're going to add the event listener listening for a click event and then in the Callback we're going to do something but the difference here is instead of handling this in the view we're just going to pass the Handler itself so we can just pass that Handler from here down to this event listener and then all of that is going to be handled in app.js so let me add the rest of them so bind new round event pass that Handler and then bind Player move event with a Handler and here what we can do is basically just copy this over so this is the um the move event so we'll just copy this over so this is the new round so we just add this dot dollar sign and that should work okay but of course we want to handle this elsewhere so we'll pass the Handler from the function parameters or arguments I mean and then for the player move event this is the one where We're looping through each of the squares and adding those listeners so at this point I don't want to just copy everything over because we're going to do this a little bit differently moving forward so we're going to start to diverge from our original implementation and just start to use it as a reference only not trying to copy things verbatim so what we want to do here is Select those squares and for each of those squares similar to how we're doing it here we'll want to bind an event listener so we'll say Square dot add event listener listening for a click and then we're passing this Handler right here now let's talk about um event listeners that are going to be view only things so you'll notice that I skipped over here on the left I skipped over this one right here where we are clicking on the button to reset the game although that should probably be added here but specifically let's look at this one where we're just toggling something in the UI so remember we just have this actions menu That's opening and closing this is not going to affect the state of the game whatsoever it's purely a view um client only piece of state that we're tracking and therefore in terms of responsibilities The View can handle a hundred percent of that it doesn't need to change any state or anything so we can actually register that in the Constructor and keep it entirely encapsulated here so we'll call this section UI only event listeners and here what we're going to say is this dot dollar sign that menu items I'm sorry we need the modal button for menu button menu items and then we're just going to toggle the class list so we'll say menu items that add event listener listening for a click and then we'll go back in that callback and we're handling this in the view itself so we'll say this dot dollar sign dot menu items dot class list that toggle hidden and we're going to actually improve this Handler just a little bit for some reusability but let's start with that and at this point I think it's time to kind of comment out this app that we had before so we're going to be resetting a good amount of functionality for the time being oops so we'll just go through this whole app here the whole thing including the uh load event you can comment that out we'll keep it here for reference but it's all commented out at this point so all we have now is just the view so let me collapse all that because it's just going to be easier to see and we'll save this and now let's see what the UI looks like so right now I can't really do anything I can click stuff but nothing is going to actually happen now the reason nothing is working is because I actually grabbed the wrong thing here on the right let's bring this over so we have a full screen um in our new view class I'm actually actually adding a click listener on menu items it should just be menu because if we go back to our index.html and look for that we want to register register The Listener on menu or probably more specifically we want to add a data ID and call this menu button so let's go back to our view we've got the menu menu items and let's add one more menu button and then we'll add the selector here and now we're listening for a click on the menu button and then when that happens we're toggling the hidden class on many items so going back we should now be able to toggle the menu open and closed but that's just about it we can't do anything clicking the reset button new round a square it doesn't do anything anymore and we need to start wiring up those events just to show you the pattern that we'll be using you can see that we are we have methods to bind these event listeners but remember by default when this class is initialized um are instantiated these methods are not going to run because they're just methods of the class someone needs to actually call these for these event listeners to be added so that's what we're going to do in the apps init method so right here below the class initialization we now have a class instance called View which we should be able to bind all of these events so we'll bind the game reset event and you can see that our autocomplete tells us that we need to pass a Handler in there and that Handler is going to give us an event so we can stub it out just like this and we can consult that log the event will also console.log the name so reset event so we'll copy this down for all of them we just had three of them so let's see what we call bind new round event and then bind Player move event so now we're actually calling those methods that are registering the event listeners so now when we go back to our UI we should be able to at least click things and see things happening so new round event or if I click the first Square it says Player move event and you'll see the click Target is um the square with the ID of one so div ID equals one or if we click down here we'll see in the ID of nine now with this pattern we want to keep our controller logic which is in this app as simple as possible we want this to really just orchestrate what happens to the state in the view but we don't want to add a lot of logic to this file most of the logic needs to happen in view.js or store.js which we haven't created quite yet I will get to this and show you why we have this but let's continue with the view and start implementing some of these methods here I think a good place to start is to go back to our app open up our original implementation and let's let's go ahead and go down to this big event listener that we have or no we'll start with these these littler ones and just so that we can see this better I'm going to uncomment everything and we're just not going to initialize it so I'll uncomment the whole app but because we're not initializing it here we can delete that this is just going to be a variable that's initialized it's not going to actually do anything or register any sort of event listeners so this is just for reference so if we go down and look at some of the code that we've already written we've implemented this toggle method over here in view as a UI only event that doesn't need to happen anywhere else now these have not been implemented we have a click listener on the modal button which allows us to hide the modal once the game ends we'll get to that in a second but really what we want to start looking at is all of this logic because it's a little bit messy and we could probably create individual methods to achieve what we're doing here let's start by improving our menu toggle right now in the UI what you'll see is that it opens and closes but this little Chevron down icon it's not going to change and generally when you have something like this the icon will rotate 180 degrees and go up when it's open and down when it's closed or vice versa I can't even remember which one is the correct design the correct way to do it from a design perspective but anyways we can improve this a little bit and we can also add like a selected state so that there's like a border when it's open so this will help us to kind of ease into this new pattern so as you can see I'm handling this UI only event in the Constructor and directly toggling that hidden class but what we'll do is break out this view into a couple sections so this section is going to be register all the event listeners then the next section is going to be some utility methods so uh Dom helper methods and that just means we're going to have some methods to change the UI in some way in the first one we'll Define is toggle menu and that's going to be called we're going to move this logic into that method and then we will just say this dot toggle menu and call that so we've just refactored it a little bit and we're going to add some stuff to this so let's make sure it works if we click this it toggles the menu okay and we're set but now we want to add something a little bit better to this so what I want to do is First add a border when the menu is selected so we're going to say this dot menu button because that's what we're going to put the border around and then let's toggle on the class list a border which if you remember from our styles index.css we have the shared utility classes and we've got this border class so we can just toggle that to get a border on it so now if we click you'll see that when it's open we have a border and when it's closed there's no border so that's just kind of a nice addition you could probably achieve this with CSS but I thought it'd be um nice to just demonstrate some JavaScript um and then furthermore we want that little icon to flip up and down depending on the open or closed state so to do that we need to actually um create a different icon based on that state and what I'll do is Define that in a variable and from here I'm going to let's see I'm going to grab from the menu button so the menu button is going to be this right here and you can see that I've got an icon down here at the bottom so basically what I'm doing is I'm selecting the button itself and then I'm grabbing any eye tag that is within it so we'll say query selector and we're going to look for any I tag that we can find which should represent that icon and then what we're going to do is look at the class list of that and since we're using font awesome we can just toggle fa Chevron down and then also Chevron up and this should basically just flip it every time the menu is toggled so if we click here you'll see this little icon just flips every time it opens and closes so that's just a nice addition to polish that up but more importantly it demonstrates in a pretty simple way how we can Define all of these Dom helper methods and then within our event listeners we'll just call those to basically change the Dom and change what the user is seeing from A View perspective before we uh go to the next set of event listeners I want to do one little refactor here and add a utility method for selecting elements as you can see we're using a lot of markup here just to select kind of basically using the same syntax and more importantly this is the the better reason to do this refactor we're not entirely certain whether this is going to result in a element being selected we can put these selectors in and check them over and over again but we really have no assurances that what we have attached to this list of elements is going to actually be valid selected elements so what we can do is at the very bottom of this class we can add a few helper methods what I'm going to call this is a Qs for that's short for query selector and then you should be able to pass in a string selector to that method and all I'm going to do is look for the element and that's going to be on the document dot query selector and then we'll pass in that selector that was in the parameters and then what we're going to do is make a check so we're going to say if there is no element that was selected so in other words we passed the wrong selector something went wrong we're going to throw a new error and the reason for that is we don't really want to continue um with our application and trying to perform all the additional logic if these selectors don't work in the first place because that will just mess up everything so we're going to say could not find elements and this will just give us as the developer some confidence that we're passing in the right selectors and here we can just return the element which we know is defined now so there's a few improvements we'll make to this but let's go ahead and try this out so with the menu we can just say this dot Qs and then we pass in the data ID and that should select the menu so let's go back to the UI you can see that there's no errors I'm going to get rid of this for for the moment because that was something left over from right here so let's get rid of that so we're not confused but this worked and so now what we can do is go down with the query selectors and replace these now you'll notice we've got a query selector all which will not work with our utility method so we'll leave that one alone for the time being so this dot Qs and then we'll replace all of these and save and as you'll see it all works there's no errors let's just demonstrate in air so let's pass an invalid selector now you're going to see unclawed error could not find elements we want this error to happen so that we know that we should go back to our code and fix it now just a few improve improvements that we can make with es6 class syntax the way that you define a private class method which is something that we don't want to expose to the outside world of this class you can put a dollar sign or not a dollar sign but a hashtag in front of the method so let me just demonstrate the difference here right now we have this as a public method on the class so if we go to app.js and we call the instance view dot Qs you're going to see in autocomplete on in vs code because it thinks that this is a public method but we really don't want to be calling this query selector from anywhere outside of The View um we don't want to be doing that from our controller so to make that private we'll put that hashtag save it and now when we try to grab this on The View you won't see it as a possible method that we can use now you could I think you can override this I'm not sure if it's enforced at runtime but it's just a good practice to keep everything private that you don't need outside that class we can also do that for the toggle menu so we'll put a hashtag there and we need to Now update the calls to this so this dot toggle menu or actually we may not let me let me check this let's go to the UI yep okay we need to update that so we'll say #toggle menu don't know what just happened and then query selector so this dot query selector just highlighting them all and let's grab the right one there and then the last thing we need to do is implement this query selector all as a safe method so one thing I want to do with the query selector is enable us to add like a parent element that we can pass so basically this will just give us some flexibility so we don't always have to search on the document so we'll say if there's a parent argument we're going to search from the parent otherwise we're going to search from the document so just a quick little refactor there then we're going to copy this whole method down we probably don't need the parent for this one but we'll call this query selector all and in this one it's going to be the same thing we're passing a selector but now we're just going to use a different Dom method so if there's not an element list we're gonna throw could not find elements otherwise we're going to return it so now we can replace that query selector all with this dot query selector all save it and make sure we don't have any errors which we don't and then finally let's just make a different name space for for um squares because it represents a node list well these just represent individual elements so we'll just make another namespace a double dollar sign which will represent the ones that we're picking as a node list so we'll assign the squares to that one just so that we have some separation a little bit of organization there all right let's continue our refactor looking at our app.js in the original implementation here the next thing that I want to cover and break out into a more concise method is some of this stuff right here so if you remember what we're doing here is we are adding an icon with a certain color to the square that was clicked and we're also updating this turn indicator up here in the top left so I think what we can do looks like we actually have an error here this dollar sign squares is undefined let's fix that before we keep going and the problem is is we've reassigned the squares to that double dollar sign but we did not update that down here in our event handler so let's save that and we should have that working again all right back to it we need to update this turn indicator and then of course when we click something we need to turn that event into an element in the Dom so we can break these out into two separate functions I think the first one is going to be setting a turn indicator so down here in our helper methods let's add a method called set turn indicator and for right now since we're not really we don't have the context of what player has actually made the move um we're just going to hard code something and then we'll fill it in later with something more dynamic so the first thing that we need to do is just look back at what what we're doing before we were basically creating a turn icon and a label and then giving some inner text to the label and setting a color on the icon so we'll do that same logic in the set turn indicator I will put a player as an argument but we're not going to leverage that just quite yet it'll just be kind of a placeholder so what we need to do is create an icon we can say document dot create element we want an i element and then we want a label which is going to be a paragraph element for now let's just assume that player is going to be either equal to one or two and we'll style it according to that we're going to update that in the future but just for now we'll assume that so for the icon we're going to look at the class list and we're going to add a certain color class based on the player so if player equals one we're going to call that yellow otherwise it's going to be turquoise that is similar to our logic here so if the current player is one we were calling the I'm sorry the square icon was the yellow and we're doing the opposite for the turn icon but this gets a bit simpler because right here we're tracking basically two pieces of State we're trying to see who was the current player that made the move and then for the next turn um we're trying to decide who's the player after that so we're mixing a lot of things and it's a little confusing really over here in the view we want to be more declarative and explicit we're just saying that player one is associated with yellow in player 2 is associated with turquoise same thing goes for the label we'll add the class list player equals one that's yellow otherwise turquoise now I think in our original implementation we weren't updating the color of the label or were we let's look at our HTML you can see we have an element called Turn which we really could just select this and add the color class to that so that's what we're already doing so let's stay consistent and do that here so instead of setting the color based on the player let's just say player one is fax and then for the message that were sent that we're adding we need to set the text content so let's delete that so if it's player one fax otherwise FAO we need to select one more element so turn div and I think we already have this it should be at the top here so right here we've selected the turn element so we'll say this dot dollar sign dot turn dot class list and we are going to add the color based on the player now there could be an existing color so we'll have to do two calls here so add and remove so we'll say if the player equals one we're going to add a yellow color otherwise we're going to add a turquoise and then what we're going to remove is if it's the player is one then we want to remove any turquoise class and otherwise we want to remove any yellow class so let's just make sure that we remove The Unwanted one and add The Wanted class this down here we're setting the actual icon that we're rendering and then the label we can set the inner text of that and we'll basically say if it is player one we'll say player one you're up otherwise we will say player 2. you're up now at this point this isn't going to do anything because we just kind of created these elements in memory we actually have to commit those to the Dom so what we need to do is select the turn div that we had modified up here with the classes and we need to replace children so that will just replace the child elements with first the icon and then the label that we created right here so let's save that and right now set turn indicator is not hooked up to anything but let's put that in our controller logic so if you remember we are binding a Player move event right here and we're just uh printing that to the console at the moment but what we can do now is reference The View and grab that utility method that we used now it is a private method by default so let me check if we need to make that public yeah let's go ahead let's make that public for now so that we can use it here so we'll say set turn indicator and for now we're just going to hard code the player ID we're not tracking any state yet so we're going to always say that we're going to pass in player one so let's save that and see what happens if we click a square it's not doing anything and we need to find out why so let's inspect the HTML if we click this Square just looks like it's not doing anything okay so now every time we click one of the squares we'd expect this to update to player one now it's already player one so you won't see a change so let's go back and instead of setting it to player one we'll set it to player two and when we click it now changes that to an O but we're not getting the right colors we're getting the right text getting the right icon but not the right Colors oh okay so our problem here is that by default our class of turn so this one right here is setting the color and then we're adding this turquoise class later which is not getting over it's not overriding that so a better way to probably approach this we'll go back to our CSS and instead of making that turn have this initial color we will handle that with the class so let me show you what I mean so I'll remove that from turn in CSS and then if we go to the HTML you'll see I'm just passing yellow as a class to style the initial icon and message and so now we're not coupling the color to the turn class so this should work you can see player two you're up um and it's going to set that every single time let's refresh so player one you're up and now we're going to hard code that to player two one other thing that you'll notice that I think I've kind of messed up is this icon has almost like italics to it um and that's because we're not adding the fa solid class so with font awesome you have to add fa solid and when we hit enter on that now it looks a lot better so we need to remember to add that let's go to our view and when we create this icon um let's make sure and add that class so classlist dot add f a solid and what you can actually do is pass this as two arguments so instead of doing that twice we can just pass f a solid and then give it a comma to do another argument and then we'll give it the actual icon to render so now you see we start with that X it's yellow it's player one and when we click we are hard coding it to be player two so we click and now it's an O player two and everything is that turquoise color so we know that our set turn indicator method is working correctly the next thing that we need to do is actually populate the square so we have to put an icon within the square and you can see in our original app logic somewhere right here we are adding the square icon and doing something pretty similar so let's go back to the view and this one is going to be called handle Player move and for this function we're going to pass the square element that was clicked so the reference to that and then the player that made the move so that we know which icon to put in there so this one will be rather simple we just need to create an icon similar to how we're doing here so we'll copy that logic so we're creating a new icon HTML element we are then adding a class list which we are going to put the fa solid remember we did that right here and then we can use the same logic to figure out whether it's going to be an X or an O so depending on the player and then finally we're going to reference the square element so whatever Square was actually clicked and we're going to replace children with that new icon that we have just set now of course we don't have a color specified so we can just group that here so if it's player one it's going to be an X and that's going to be yellow if it's player 2 it's going to be an O and that will be turquoise so let's save that and now we will call handle Player move in our controller so now you can start to see what the controller is supposed to be doing it's supposed to be kind of orchestrating the events that take place so we're going to set the turn indicator and then we are going to handle the player move and let's hard code player two so those are synced up so now when I click this Square we would expect that this turn indicator will turn turquoise with an O and this Square will um or actually now that I'm thinking through this we want the player move to be player one and then the turn will be set to the next player which will be player two once again we will refactor this so it's dynamic in the future we're just trying to get our view logic to work so let's save that and we'll click here and this should be a yellow X and then this will turn to a turquoise o and you can see it has not done anything and it says Dom token list add the token cannot contain white space so let's see what I did here okay so I cannot do this I actually messed that one up we need to duplicate this logic so that we're just doing one token per argument so just two little just a little refactor there and that should probably work so make sure we're refreshed and click Square element replace children's not a function because I'm just getting tired here um we can't just pass in that one we need to pass in the event Target so this will represent the square that was clicked and so we want to pass that into our method and hopefully third time's a charm as you can see it did work finally and just going to put X's everywhere yellow X's because we've hardcoded that in player two Zoe is going to be up obviously we want to make this a little better experience so at this point we have reached a place where we need to address this file store.js because we are doing some you know view logic but right now we're hard coding which player is up and if you remember from the earlier implementation we had the state variable right here where we're tracking the moves and then based on those moves we're getting a game status if there's a winner and we're also using that information to determine you know what's the current player and which you know icon and which colors am I going to add looking at our previous implementation this is kind of a critical moment in the refactor where we start to see things separating into different concerns so separation of concerns as you can see in our event listener for the player move we're doing multiple things we are changing what the user is seeing in the Dom so we're updating classes HTML elements so on and so forth and that's happening in logic just like this where we're replacing the children with some new elements now we're also doing something completely separate and that is reading and updating the state of our game so as you can see uh sprinkled throughout this uh listener we are doing things like checking if the square has a move and we're reading the state of the application to figure that out furthermore we're coming down here and we're actually mutating or changing the state of the application right alongside the changes to the view these two things are separate concerns and that's why we need this store.js file so similar to the view.js we're going to create a default class and Export it so we'll copy the syntax and this one's going to be called the store we of course need a Constructor and now one new thing that I'm going to introduce we're going to set two private methods we're going to add a get State method and a Save State method and what these are going to represent for us is a way to get a readonly copy of our current game State and then save state is going to change um and basically transition to the next state of the application now there's some really good articles online about State Management one of those is the Redux documentation Redux is I guess probably better to say it was the leading State Management solution for clientside apps for a long time now that react has kind of refactored and moved towards a functional component approach with use State and stuff like that it hasn't been used quite as much but there are some best practices that they have written over years of managing state within an application and they're very good to read through the one that I'm going to point us to is the Do Not mutate State best practice so mutating state is the most common cause of bugs in Redux applications or in applications in general including components failing to rerender properly and will also break time travel debugging in the Redux Dev tools so that's kind of specific to Redux um but actual mutation of State value should be avoided and we're going to stick to this approach because it's generally just a good idea and reduces the surface area for bugs to occur if you see from our original implementation we are directly mutating state so we're reading it up here where we're checking for something like the last move and then we're directly updating it here there's nothing terribly wrong with this at for the size of our application but it's just better to make sure that we're not doing that so what we're going to do here is actually add a private State variable and that's going to be equal to an array of moves so that's very similar to what we had up here right here but it's going to be private so only this class itself can read the state and write to it and we have to use an intermediate method to actually retrieve the state as I'll show in just a second so when we get the state all we're going to do is return this Dot State now this is kind of a redundant method you'll see why this is useful for us later in this video when we refactor this to use a little bit more persistent State Storage so we'll be looking into local storage right now that's not um needed so we're going to keep it like this but the get State method will just return this private State variable or property and then the save state is going to set it so we'll say this dot hashtag State and then that's going to be equal to whatever new state is passed in now something that's very useful when you have a Save State method is being able to reference the prior state within that method so rather than just passing a hardcoded object as new state I'm going to make a parameter called state or function and this can be passed as one of two things you can pass just a raw object or you can pass a callback function that we are going to give the previous value of state to so let me just walk through this it's a little bit confusing if you're not familiar but this will really help us out later so we'll say the previous state is equal to this dot get state so that's the previous state we're dealing with that's reading here and then we need to check what kind of argument that we're actually dealing with so we'll say let new state that's going to be just a variable that we're going to initialize but not assign yet and now we're going to say switch on the type of state or function so we've got a switch statement and we're going to look for a function type and we'll break from that or a object type because our state is an object and we'll break from that and then the default is going to be throw a new error invalid param or invalid argument passed to save state because we only want to handle these two cases so it's pretty simple from here if it's a function all we're going to do is say the new state is equal to the state or function which we know is a function here and then we're going to pass in the previous state so that whoever calls this has access to that now if it's an object we're just going to set the new state is equal to the um not the previous state but the state or function so in this case we've just passed a literal object and we just want to assign that to state then from here all we're going to do is basically later we'll save this to local storage but for now it's all good we'll just say this dot state is equal to the new state that we had just assigned right here so let's save that now we've got our get State and save State functions implemented and now we need to actually initialize this so we'll have a default value that we're passing into this store and this default value is going to we'll just call it initial value and we'll set that equal to moves and that will be an empty array so as you can see we've initialized it right there but really we can just refactor that to say initial value once again I know this is a bit contrived we're doing a little bit of indirect stuff but you'll see later why this makes sense once we start getting into local storage at this point if you're paying attention you'll probably notice that everything that we've defined here is a private method or property and therefore this class is not very useful so what we want to do is expose a getter method that allows us to read the state and then our application can take that state that we've read and do something with it so if you'll see in app.js one of the things that we had defined was get game status and we just passed in the moves that was you know in state and that's going to give us things like the status of the game if it's complete or in progress and then if there's a winner it will Define that so this is something that we'll need and we can Define that in the store now something I like to use when we're just reading a readonly value from a class is to add a getter method so if we add the get keyword followed by something like game and then we Define a method this is going to be evaluated at runtime and basically what we can do here where we initialize the store which we still need to do so store equals new store and that should have Auto imported things for us so import store from store.js so when we initialize that now store.game is a property that is available so let's just console.log store.game right now and we'll just return dummy value so let's go back to our UI and you can see that it prints dummy value now just to demonstrate if we remove that getter it's going to break we're just going to get a function called game so we would need to go over here and actually call that as a function to get the dummy value that we're looking for so that's why I like to just use a getter because you don't have to call anything you can just add that get keyword and then this acts as a property on the class instance so as you can see in our Handler for a Player move we are hard coding right now the player that is up so we obviously want to get that from the state of our game or from the store so to do that we're going to update this class property to basically derive some state so the goal with saving State as we talked about earlier is to keep it as simple as humanly possible and then we're going to derive as much as we can at runtime from that so that just makes it so that we only have to update a small piece of state and then we can just dynamically get the rest so I'm going to basically take this method that we had defined earlier get game status and I'm going to kind of refactor this make it a little bit simpler and the first thing that I'll do here is Define our list of players this is going to make things a lot easier for us and I'm just going to copy in from the completed app so we don't have to type things out and then I'll explain what we're doing here so down here I think at this point I'm going to collapse our app because we're once again not using this we're just using it as a reference so here we're going to define the players of the game how I've decided to represent these players is just a tuple or an array of players and we'll just know that the zero index is player one and the one index is player two now what we're doing is basically adding some configuration here so this is a configuration array that's saying we have got two players this is the name of player one they are going to be the X icon and they're going to have a color class of turquoise likewise player 2 O in color of yellow so this is going to help us with our internal logic quite a bit and I'll show you what I mean uh here in a second so before we even touch the store anymore let me just pass in uh players and then the first index so that would represent player two obviously this is going to break that method because we're not expecting an object so if we click stuff it's just not going to work correctly but if we go to The View and go down to that method that we had defined so set turn indicator this player now represents that object so now that we're passing an object as the player this logic here gets a bit simpler but the problem is if you look at our index.html we're defining the color on that top level which means we have to add and remove classes so really we would need to pass in player and then opponent and then here what we would do is say player dot let's see color class and then this one would be opponent dot color class so we're adding the players the current players color class and then we're removing the opponent's color class now a bit simpler way to handle this I know I'm kind of going back and forth here um but let's go back to index.html and remove the color property from this outer div and instead let's just initialize the color property of this each element Within so to start the game out we're going to have a yellow X for player one because that will be o is the first player so let's save that and then here in the view that means that we no longer have to remove classes and instead of looking at the turn we can just directly add these to the icon so icon.class list dot add and then we'll say player dot color class and then label dot um class list will also be color class we can remove the opponent here and then if we come down here let's just kind of group these icon classes together this is where we're defining which icon it is and rather than doing this switch here we can just say player dot icon class so remember we defined an icon class and a color class on each player so here we're adding the color class here we're adding the icon class and since we're doing the doing this to the same icon we can actually combine all of this so we'll say f a solid then a color class and then an icon class and we can delete this line so this will pass to all three of those then finally the label gets a color class and then we need to update the label inner text but instead of these static strings once again we've made it easy for ourselves in our configuration so we can just say player.name as you can see right here we've defined a player name so we can just add some string interpolation here and we'll say player one you're up and then finally we're getting the container and we're replacing it with the icon in the label so now that we've done that we should be able to uh see this working so we don't need to pass that opponent anymore just the player so let's go back and click something so this should be turquoise not yellow so let's see what's happening here we're passing in players index of one so we're basically passing this object we'll bring that over to The View just so that we have a reference to see what we're passing so that's the object that is being passed in this case and we are grabbing the color class which is defined as yellow and the icon class which is O so that's our problem our configuration object is actually different let's check the final implementation so the vanilla refactor you can see that the x is turquoise and the O is yellow so I actually had things backwards this whole time I apologize the O should be yellow and the X should be turquoise so I think this is intended Behavior let's delete that and then instead of player two we'll pass in player one and let's see that is working a little bit better we've got a blue X and then if we load by default we need to update that as well so this should start as turquoise this should start is turquoise so player one you're up a turquoise X is that the same thing we get here let's reset yep we get a turquoise X so we're starting in the right State and then as we click something we should be getting that to change so let's click for player two and there we go we've got a yellow o with player two text added in there and then the last thing we can kind of refactor here is the handle Player move instead of just hard coding in one we can hard code in players at one so we'll go back to handle Player move and this player is now an object so we can replace this here with player dot icon class and then player.color class save that make sure our icons are going in correctly and it looks like they are so that is refactored that makes things a little bit easier for us to handle and now we can go to the store and start defining this readonly game State variable right now we're just returning a dummy value which is not useful to us but the purpose of this getter method is to basically take the raw State object which is just an array of game moves and calculate all sorts of useful information from that you can already see we've done that um with our get game stats right here or get game status so the the things that we're really doing here is checking for a winner and then also at some point we're going to have to figure out who's the current move um or who's up to play so we can Encompass all of that within a single method here and we're going to build this uh kind of piece by piece until we have something to read from so that we can determine down here in our controller method where we're setting the turn indicator and handling the player move that way we can just pass in that derived state so that these methods know what to actually do with the UI so let's start out by getting the current player so we will First grab state which can be read with the get State method so this is just a assignment we could just read this directly but nice to have a variable to work with here so that is the first step and then we're going to derive the current player with a little trick and I believe the original creators of this game that I'm refactoring here already had this little trick and they were using it but we can use the modulus operator to basically determine the current player so what that looks like is we'll say the current player is equal to um the list of players which we do not have access to here but really just a list of players and then we can grab the index of that based on um how many moves have been made within the game but like I said we don't have the list of players so one thing that we need to do is pass that to the store so that it has access to that so we'll pass that array of players and then we'll set a player's property on the class and so that way we can access it right here and then grab whichever player we want so we'll put in zero for now as a hardcoded value let's go back to app and where we initialize the store since we have the list of players right here we can just pass that array down to the store via the Constructor so at this point what we can do is we can say State DOT moves dot length so that will tell us how many moves are in this current game and we can use the modulus operator and use it modulo 2 which will basically give us either a 1 or a zero based on the the number of moves so if we just open up a terminal here and open up a little playground with node.js you can see that if we have let's say an array of moves and let's just say it's one two one two just to fill it up so we currently have a moves.length of four So based on this if player one is the starting player then we know that player one made this move player two made this move one made this move and two made this move so who's up next well the way that we can determine that is basically just doing moves.linked modulo 2. and that will give us a zero and since our players array is just two objects the zero index is going to be player one and the one index is going to be player two so if we were to push a new move to that array so let's say player one moves now if we do moves.length modulo two we get one which is the index of player two so you can see how based on the length of this array we can quickly determine who the current move belongs to so we'll go to the store and we will do this operation to get the current player and then from there we can also derive the next player in the game so we'll say but we actually might not need that let's hold off on that one for the moment so let's go ahead and return the current player as part of an object so we now have that as part of our game state and then we can come down here to the set turn indicator and we're going to reverse this because first we need to actually handle the player move and I'm going to make a variable to keep things clear we will say that the clicked square is equal to the event.target because that's what that actually represents if you go back to the view where we are binding that move we're just looping through the squares and adding that event listener listener which is going to pass the individual Square to that Handler that was clicked so that's what that represents and just for clarity we can pass it like that and then for the current player that we want to move now we have some game state so we can say store Dot Game Dot currentplayer and that should satisfy the stub of this method so we are now passing the current player in and at this point we need to update some of our state because we of course have made a move by this player and now we want to set the turn indicator but we don't want to set that for the current player because they have just moved we want to do it for the next player so we need a way to update the state to advance it to the next play so the way we can do that is make a method in store a public method called let's see what I called it in the final project I think I just called it Player move and what we're doing here is passing a square ID so that's one through nine based on which one was clicked and to follow our Convention of not mutating State directly we first need to grab state from the getter method that we've defined right here so we're returning that private variable then we need to make a clone of it so we're going to go ahead and call that state clone and there's a builtin method to browsers called structured clone which you can pass an array an object pretty much anything and it will give you a clone of that object so we're no longer referencing we're no longer passing a value by reference where we've got a completely different object that we're able to mutate here so from this point we can go ahead and take the state clone and push a new move to this array um actually we don't want to push it directly there because the the state object has an array of moves but that is a property so what we're really saying is State clone dot moves dot push and then we need to pass in the Square ID right here and then also the player ID so or not the ID we'll just pass in the player that is currently up so that would be state or not state but this Dot Game remember we just derived that up here so we can actually access that property within the class and we can pass it the current player so when we call Player move it's going to take the square ID that was clicked and the current player that was up and push that as a move to the state object so that's going to actually update our state for us um but the last step we need to call is this dot Save State in this case our state object's pretty simple so we can just pass in that literal object rather than a callback function but we'll come back and refactor this as we develop our state handling a little bit further later on so let's save that and then back in app.js all we need to do now is call store dot Player move in here we just need to pass the click square but we need to pass an ID so really what that is is going to be dot ID and we need to cast that to a number because uh the event ID or the event targets ID will come as a string by default so we're passing in a number ID and we're updating state so at this point we're allowed to Now set the turn indicator to the current player because that has been updated with this method so we can go back to the store.game dot currentplayer and set the turn indicator now the important thing to notice here is that this store.game.current player is a different player than this store.game.current player and that is because we have made a state change happen in between the two and every time that state changes that getter value that we've defined right here is going to automatically reevaluate and update so if all worked when we click a square it should update things dynamically so it says player one you're up and we click and now we've played with player one with that X and you can see player 2 is now up now we should be able to click and we get an O and now player one is up so now we have this working again but if you remember from the original implementation we had one big problem and that's if you click twice on a square so we need to make sure that we are not updating a square twice and that should be relatively simple to handle so let me comment some things in here we will say um place an icon of the current player in a square advance to the next state by pushing a move to the moves array and then set the next players turn indicator now up here at the top this is where we need to check whether there's an existing move so you can see in our original implementation what we did here was we made a little helper method that says whether a square ID has an existing move and then we checked if that current Target matched that and if it did we returned early so we can actually we could make a helper method to do this within the store or we could just check it inline I'm going to go ahead and just check this inline as you'll see in just a second so let's collapse the app and let's say the existing move is going to be equal to the store dot game that moves dot find and so we're looking for a specific move that has a square ID equal to the clicked Square dot ID and we need to make sure that that is a number so we're comparing the same thing so if there's an existing move if that's not undefined basically we're going to return early and we're not going to handle that Player move save the state or set the turn indicator let's save that and now let's play and it looks like we've got a problem and you can see that we're getting an error here by reading the store.game.moves it says that it is undefined and that makes sense because we have not actually added that to our getter so let's go back to the store and remember game is only returning the current player so it would be nice if we also just gave it uh the moves array just so we have access to that so we'll save that and now things should work a lot better so now if we click something twice it's actually still messing up and I believe this is because of the same reason we ran into earlier that I failed to recognize once again when we're binding to this Player move event if you look in the view we are basically just passing um the event uh to the Handler and that event could have been an icon that was clicked so instead of just blindly passing the Handler right here what we really need to do is break this out into a function and pass the square itself that we are setting the event listener on rather than the event Target which was the default that was passed so let's update that go back and see if that fixed things for us Square element is undefined we just need to make one adjustment here it is no longer an event that's being passed it's a square reference so this is actually more expressive anyways so we will check Square and then update these references and hopefully finally this will work so we're clicking clicking click it again and it does not do anything as we expected so now we've got a lot more stable behavior and we're almost back to where we started but of course we've got a tictactoe in two places and the game has not recognized that yet and that's because we need to once again build up our derived state which is in this method right here the last piece of state that we need to derive in this game property or getter is who has won the game we've already done this in our previous implementation we did this right here where we were checking the player moves the winning patterns and then checking the player moves against those winning patterns we were then deriving it as a status and a winner so I'm going to do something similar to this but we're going to simplify just a little bit in this new derived State method so the first thing we'll do is copy in those winning patterns because those are just static and then we'll initialize the winner to be equal to null just to get a variable in place and then what we're going to say is four we're going to do a for Loop we're going to Loop through each player so for player of this dot players so remember we initialized the list of players which is just two people in the Constructor so we can Loop through each player and then within that Loop we can get the selected Square IDs of that player so we'll say this dot game dot moves and remember this is just the current state of the game so this.game.moves or I'm sorry we should probably not do that because we're referencing this method from itself so what we need to reference is this state uh variable right here where we're getting the raw state so we'll say state DOT moves and we're going to filter those moves to only be the moves of the current player that we are looking at so just walking through this logic a little bit we've got the array of raw state of moves and we're going to filter out any player that does not match the current player in our Loop furthermore we're going to map that resulting array and just grab the square ID off of the individual move so if you remember we're pushing a square ID and a player to that moves array so that's basically what we're reading off of this right here so we've got a list of selected Square IDs for the current user and now we're going to do an inner loop and we're going to say for pattern of winning patterns now we're going to check check if the pattern matches every one of those selected Square IDs or actually I should probably say if the square IDs has every element of the pattern so we'll say selected Square IDs includes that value and so this will check if there is a winning pattern and if that's the case we're going to set that winner variable that we initialized up here to whatever player we're in during that Loop in other words we're going to go through this Loop and if no winning patterns are found the winner is going to be left equal to null which is going to tell us that this was a tie game along with the status of the game so we'll come down here and add a status property and we're going to say is the game complete this is going to be true if the winner does not equal null so if the if there is a winner populated we know the game's complete or if the state.moves.length is equal to nine because we know that that's the maximum number of moves that can be be played in a given game and then finally we'll pass the winner variable right here which will either be null or set equal to some player so now we have some derived State and I'll just remind you that we are deriving all of this information the current player the status whether it's complete whether there's a winner we're driving all that off of one simple array of game moves so that's going along with our pattern of trying to keep State as simple as possible and then deriving what we need to know from it later on dynamically now that we have this information populated we should be able to come back to our app.js or our controller and this is where we will check whether there's a winner and if there is we're going to open up some sort of modal to show that status to the user if you remember from our first implementation we had um let me collapse some of this stuff we're not using so if you remember from here at the very bottom this is where we're checking the game status and if the game is complete we're going to remove the hidden class on that modal so that it opens up and then we're going to set a message so we can make some utility classes or some Dom helper methods within our view class to achieve this so let's go back to the view class and hook up some of those methods we can put them pretty much anywhere I'll just put them at the top here the first one that we'll want is an open modal method and we're going to pass in a message and what we'll do with that is select the modal itself and that's going to be the one that we removed the class from so there's the modal in our index.html that is this entire div that's got hidden on it so let's remove that real quick and you can see how it pops that up so really what we're trying to do is just toggle that class in the way we'll do that so we'll come down to our helper method and we'll look at the class list and we will remove the hidden class so very similar to what we were doing before so let's just try this little um helper out right now to make sure that it's working and then we'll come back and improve it with an actual message that we can show so we're coming down here we've set the turn indicator for the next player and now it's probably time to check whether someone has won the game so really we need to do this before we set the turn indicator because this will update that text up here and if the game's over we don't really want that to change so here's where we check that state we're going to say if the store dot game dot status is complete this is where we're going to perform this logic and we're going to add a return statement here because if it's complete we know we don't want to run this logic so we always want to return at this point we'll call View Dot openmodal and that should open things up for us so let's go to the game and play it and see if it recognizes this winning pattern and it does so we see player one wins if we click play again it's not going to do anything because we haven't updated that event listener so let's refresh the game start over and at this point we need to pass in some a message to say who won the game and we can go ahead and derive that so we'll put in a variable here or actually we should probably not do that yet we want to say if the store.game dot status dot is complete or no we already know that dot winner if there is a winner then we want to say store.game.status.winner dot name because that's a player that we're referring to and then we'll say wins otherwise it's going to be Thai so that should be the correct Logic for opening the message in the modal we still don't have any listener for resetting the game but player one wins let's reset real quick in this case let's make sure that player 2 wins and it's still saying that player one has won the game so we've got a little bit of a problem here and it's actually not a problem I'm just getting tired and forgetting things in our view when we're opening the modal we have to actually update the text within it so this dot modal text dot inner text is going to be equal to the message so let's try that again let's make sure player 2 wins so here we go we got player two wins refresh and then if we have player one wins that'll show up there so the last thing we need to do is register an event listener on this play again button which will reset the game State since we're resetting the state we need to do this event listener outside of the view this bind game reset event is meant to be um a Handler for whenever we click this reset button but we can also overlap and use it for when the game is complete so not only do we want to register that on the reset uh button we also want to register that on the modal button because that is going to also reset the game and do the same exact thing so we'll pass in the same event and the same Handler and make sure that's hooked up then when we go back to app and we go to the bind game reset event this is what we need to now fill in so whenever this pops up and we have an end State when we click this we want everything to close and reset so one thing we need to implement is the close modal helper method so right next to open modal we'll make one that says close modal and this will be very simple we will just add the hidden class this time so let's go ahead and call that close modal and see if that works so we should be bound to this button here and when we click it it should now close the modal which it does but you can see the state has not reset which we want to have happen so this is a job for the store class and we need to just Implement a method let's put it under Player move and I think I called this just reset in the final implementation so we'll say reset within this method we're basically going to read or we're going to just set the state to be empty so we can just call Save State and we'll set it to the initial value so initial value is referencing this right here so this is basically resetting the game now if you'll notice we're not saving any history of past games we'll eventually add that but for right now we just want to get things to reset correctly so over in app.js we are closing the modal and then we're calling from the store we want to reset the game and then the one last thing we need to do just to make sure that player one is going to be up at the beginning of the next game is say view dot set turn indicator and you remember we can just pass a player there so we should be able to just pass players zero because that represents player one and we always want to reset to player one now another way to do this is we know that the after we've reset the state we know that if we access store.game.current player that's going to also give us player one so that's probably a more semantic way to do that so let's command s to save so we're going to close the modal reset the state and set the next turn indicator so everything should be cleared out at that point the only thing that we're probably missing is we don't have a method to clear the game board so we're resetting this state itself but we're not clearing the game board so let's go to the view and we'll say clear moves and what we're going to do is just look at these squares how did I access this hold on yep so I'm just accessing it like this so for each Square I just want to clear things out so Square dot replace children and leave that empty to basically just clear everything out so we need to clear the moves after we've reset the store so view dot clear moves and then we'll set the turn indicator and this should pretty sufficiently clear everything from the state and The View so let's refresh and play the game player one wins and when we click play again everything clears and player one is going to be up so if we do the same thing for player two player two wins you can see player two is up but that will reset to player one you are up at the end but obviously at this point we have a working game but if we started to play then we refresh the browser it's going to reset if we play and player one wins and we click play again none of this stuff is being tracked down here we have no history of games of the past so if we wanted to implement that that's going to basically be the next phase of this video and it's going to get into some really cool concepts with local storage and finally we will kind of refactor this to be a little bit more declarative so that we can just kind of react to all of these State changes and render whatever UI should be based on that current state one last thing I wanted to test let's make a move on the game board and I believe we should be able to click reset and everything resets okay now this does not close which we're going to want to implement but just wanted to show you that because we actually indirectly implemented this reset method when we were working on handling a winning game and how we did that remember when we binded to the game reset event that is actually linked to both the reset button and the modal reset button so it's running the same Handler regardless now as you saw that doesn't close everything so in app.js where we are closing the modal let's refactor this to not do closed modal but close all and we need to implement that method we'll put that right under close modal and we'll say close all and this is basically going to um call the close modal so we're going to close the modal and then we want to close the menu we currently have a toggle menu method but we also want to have a close menu method so this is going to look pretty similar to this method we're just going to say this dot dollar sign dot menu items and then on that class list we're going to add hidden to make sure that it's closed we're going to also remove the Border so remove the border on the menu button because when that's closed we know that should not be there and then we'll reselect the icon because we always want to make sure that that is going to be the icon that points down so let's just copy these two and instead of toggle we're going to add this one and remove this one so when we call close menu it's just going to make sure that everything is in its closed state and then we'll add that to the close all method and at this point we can make this close menu a private method because that's only being called here we can also make closed modal it's put that down here and make that a private method because it's only being called here so now we have a helper method close all that is being called when the game is reset and that should clear all the state so if we make a move open this actions and reset it's going to say closed modal is not a function and that's because we are not referencing it from its private declaration so now that should work so make a move reset that closes this resets game board is cleared and everything is working great so as I mentioned we're not tracking down here the history of all the games that have been played and we also don't have anything happening here when we click new round so in order to track that we need to update our state object so right now this is the initial value we're just tracking an array of moves but really what we need to be doing is tracking an array of moves and a history object that has the current round gains and that should be an array and then all games which is just basically all the history from you know all the time so with this information right here we should be able to calculate some statistics of how many wins each player has so just for clarity I'm going to also update update this to current um or current game moves so this will still represent the same thing we just need to update our references to here so current game moves current game moves do we have it anywhere else okay I think that's it so if that worked um we should be able to see the same functionality things should still be working and it looks like it is and so now all we need to do to start tracking this is when we reset the game instead of just saving the state back to the initial value we should update the state to basically take that finished game that we just completed push that to the history and then start a new game so what does that look like so to start tracking the history here let's just refactor a little bit right up here so we don't really need two variables let's just pass get State into structured clone and we'll just call this one state clone so that's for the player move and that should remain the same the reset method is where we're really going to do some updating in the reset method we're going to have to check for a very specific condition and that is if this dot game so we're reading that getter up here that we've defined um dot status is complete if it's complete we want to push this game that we're resetting to the history object or the history array and if it's not complete then we just want to reset it totally because remember in the view we're adding this reset to two different places we're adding it to this drop down right here which could reset the game even if it's incomplete we're also adding it to this button right here when the game is complete so we need to make sure that we're checking that before we push an incomplete game to the history so all we need to do is check for um the moves we can destructure that from this Dot Game really we should just destructure all of this stuff so we'll say status moves and then I think that's it so now we can reference status that is complete and we should also make a state clone because we're not going to mutate State directly so in here we'll say state clone and then remember our state now looks like this so we can grab the history and then current round games array is where we want to Target this so State clone dot history dot current round games and we're going to push the final game here so I believe that would just look like um let's see we probably just want to push the moves in the status we don't want to just push the moves because we want a easy way to Loop through all the history of games and see the status on those which is that derived state right here so we want to kind of archive that as well now after we get past this block this is where we're going to look at the state clone and set the current game moves equal to an empty array because we want to reset that and then instead of saving it to the initial value we're going to State save it to the state clone that we've just mutated here in these two places so at this point if we've done everything correctly here we should be able to add a new getter so we've got the current game and then let's also make a stat skidder so this will be responsible for getting us the total number of wins by player and to start us off let's just console log this Dot um get state so we'll go back to our game let's play at least one round and reset and so right there that should have pushed um a few or it should have pushed a game to history and since we're not actually calling this anywhere it's not showing up um so we need to call that somewhere we'll just call it at the end of the game reset so console log store dot stats we'll remove that in just a second but let's play one more game so I think player one should have two wins at this point when we reset so you can see in history we have current round games is an array of one and it shows all the moves from that game and then the status showing that the winner was player one and if we play this again I'm hoping things will update correctly yep so now in history we have two games in history so if we keep playing these that's basically what's going to happen so at this point player one has won three games and you can retrieve all of those in history right here so now our job is to go back to the stats method on our store class and actually derive some useful state that we can use to update those that scoreboard down here at the bottom so what I want to return from this it should be pretty simple so player with stats um what I'm going to do here is map through the players array which remember we initialized the Constructor with players and then assigned that as a property of the class so we have that and we can map through and look at each player and then all we're going to do is add whether they have a win or add how many wins they have so we'll calculate wins by looking at the current state so this Dot Game or I'm sorry not this dot game but we will look at the history so we need to grab the current state which is this Dot oops get state so we'll say state DOT history we're looking in the history of the current round games and we're going to filter that and we're going to look at the game and check for the status of that and see if there's a winner and if there's a winner we'll use a an operator here that JavaScript has available to basically coalesce any undefined values uh when we're accessing this property so we can pass ID and check if that's equal to the current player.id so we're checking the player we're mapping through against the game status of the current game we're mapping and at the end of that we should be able to get the length of that array so that will give us the number of wins that this player has we will then from this map function we will then spread the player object to this object and then we'll pass the number of wins so essentially this is giving us a list of players where it has this additional property called wins that will tell tell us later how many wins that player has furthermore we then have ties and that one's pretty easy we'll just look through the history again and this time we're going to filter it for games where the game.status dot winner is equal to null so that will tell us when we have a tie if there's no winner and we'll give it the length there as well so now when we read the stats object we should be getting a much different picture so let's go ahead and play another game and now we've got the stats object we've got player with stats and you can see that's an array of two players and if we open up those players we get all of their attributes of course and then we also get how many wins that they've had so far in history we get the ties is equal to zero and you can all already see that we can basically take this information and just update the HTML to show that in these three boxes down here so populating these will be relatively quick I think we just need to go to view and make one more helper method I'll just keep putting it here at the top let's go ahead and say update scoreboard is the method that we're going to use and I think we might need to put a data ID on some of these yep so I'm going to put a data ID and we're going to call this one uh player one scoreboard or let's let's actually just make it shorter P1 wins so we'll copy that one down to player two so P2 wins and then we already have a data ID because I guess I forgot to pull that out during our HTML build so that's already there for ties so if we go to our view we just need to select these elements um we could just do it in this method we really could do all this in that method I just like to consolidate stuff up here so we're going to select the player one wins and this is going to be selected P1 wins let's make sure that's right okay then let's copy that down player two wins and then ties and then now we have these three elements to work with so we can update the scoreboard by saying this dot dollar sign that player one wins and we'll set the inner text equal to and then we'll get the number there and we'll say that number of wins so that'll be this dot game I'm sorry this dot stats nope never mind we are in the view I was gotta gotta be careful where you're putting stuff we don't have access to that information yet so we're just going to pass that information directly to the method so player one wins player two wins and ties so we'll just pass that in and then we'll take care of actually getting these values into this method later okay so that method should update the scoreboard we just need to call it from somewhere so just checking looks good so we just need to call that from somewhere and I think the best place to do that at the moment is to do it in the game reset event because that's the only place that we are actually cataloging the end of the game so after we have set the turn indicator we're going to call from The View to update the scoreboard and at this point we're going to pass in store dot stats Dot player with stats we're going to select the first player and pass the number of wins we'll do the same thing for player two and then finally with the ties we can get rid of this console log and hopefully if that worked correctly this will update things and our game will be sort of done we've gotten error it says it cannot find elements and that's because we did not save the index.html so now it's finding it and you can see player one has one win player two to win one there's a win and then if we can somehow get a tie going here um I guess that one's not gonna work ah I can't get a tie going so we got player two with three wins player one with one win so that is the current history now the very last thing that we need to do um when we reset right here it's not going to clear any of this the only thing that's going to clear this scoreboard is the new round so we need to implement that method and let's go ahead and do that in the store first because that's pretty close to the reset so we'll say new round and what we want to do with the new round is basically take all of the games that are in the current round games and push them to this all games array and we're basically going to clear out this one and clear this one so one way that we can do that since we know that a new round is going to also be a reset what we can first do is call this dot reset so that will take any completed games put them into the current round games in clear everything out and after we've reset we need a state clone because we can't update State directly just to best practice as we talked about and what we're going to do is take the state clone grab the history and we're going to populate the all games um with the most recent current round games so one quick way that we can do this because this is going to be an array is we can spread that out to the push method so State clone dot history dot current round games so that will just push that to all games and then at last we will take that current round games and set that to an empty array and then finally we will save the state pass in that state clone that we have modified now there's one thing that's going to be messed up and it's probably not super apparent so if we go through and play some games and then we go and reset everything let me see and at this point we really just need to hook this up to the view so we have bound the new round event and in app.js we just have a placeholder here so what we need to do is basically call the store call for a new round and then I think we'll want to clear everything so similar to the the reset we'll want to close everything we will want to clear the moves so this is the UI not the store we'll want to set the turn indicator and then we'll want to update the scoreboard so this call actually needs to go first so that the state is updated and then all of these will read from that state to appropriately populate the um the UI so let's go try this we've got so far um let's populate some state so player one has two wins if we click something and reset it'll just clear the board but keep this if we go and hit new round you can see that it clears everything and now the scoreboard is also cleared so at this point we have a fully functioning game and everything works everything's being updated the last thing that we're going to look at here is persisting State across refreshes as you can see if we play a game and you get player one having one win and then you refresh the page this is all cleared out and ideally we would want to be able to refresh the page and still keep a record of the games in history and the only way that we can really do that is by using local storage now to make our game more persistent across browser refreshes and additionally to allow two users to basically play at the same time in different browser tabs we can use local storage so if we go to the documentation for local storage you can see that it is a property of the window interface allows you to access a storage object for the document's origin so it's similar to session storage except that while local storage data has no expiration session storage data gets cleared when the page session ends that is when the page is closed local storage does not do that so you can actually close the page entirely and reopen it it will still be there so it's just a little bit more persistent and it's also available across browser tabs so if we go to the event reference let me see if I can find that let's click on storage Maybe and then look at storage event alright so this is what we're looking for in Wool eventually implement this but the storage event is implemented by or the storage event interface is implemented by the storage event which is sent to a window when a storage area the window has access to is changed within the context of another document that is a long way of saying that basically you can add an event listener on the window for this storage event and if you have one tab sitting open with our tictactoe game and a player is clicking in it then that's going to trigger this event and you can have another tab listening for this event and it will recognize when that player has played in a different tab so that will allow us to sync the two tabs together and allow us to basically have two players in simulate a more realistic game so we're going to implement local storage but as we know with local storage you need a key so we will Implement that but first let's get rid of our previous app we can finally hit the delete button on that because everything's working in our refactor everything's a lot cleaner and now it's time to go over to the store and in the Constructor to this store rather than just passing players we're going to also pass a key and this key is going to represent the key of local storage that we're going to actually keep the data so if we go to storage and we go to the local storage right there you'll see I've already populated this because it's happening in the the finished game over here but the key is what's going to be referenced to get it and save it and then here's all the game state that we're tracking so let's go ahead and go back to our app and we will give this a special key so in app.js where we initialize the store right here we'll say live um tictactoe so T3 storage key it could literally be anything so we're passing that key and now what we need to do is save that so we'll say this dot storage key is equal to key and then this dot players is equal to players so that should be working and then the last thing that we need to actually do is go down to our get get State and save State and now instead of saving this in memory on a property of the class instance we're going to replace this with local storage so that's why as I was talking about earlier this seemed a little redundant why would we access this through another method well it's so that we can refactor it to this a lot easier so we'll get rid of that instance property and in the get State this is where we're going to retrieve from local storage but as we know uh if the local storage is empty it's going to give us undefined so remember at the top we have this initial value and that's go that's what will return if there's nothing found within local storage for that key so what we'll do is we'll first try to grab an item and we'll say window dot local storage dot get item that's a builtin method and then we will pass the storage key that we initialized in the Constructor of this class so this is going to return us either undefined or the string representation of this value so basically what we're going to return here is we're going to say if we have found an item that is defined we're going to parse it because it's a string otherwise we're going to return the initial value as a JavaScript object so in other words we're going to return the same type we're just falling back to this value so that's the get State implementation and then for the Save State we'll replace this call down here and we will say window.localstorage that's set item and this is going to um be the storage key and then we need to actually do the opposite of json.parse and we need to stringify our object so you can see here this is where we're storing the new state after we've saved it so we can just pass that raw object right here and that should persist things to local storage just fine let's go back to our game and see if things are working better so we'll play the game player one wins you can see it's tracked down here in the scoreboard let's get player 2 to win a game that's tracked down here and now for the the big tell all let's refresh the browser when we refresh the browser it looks like there's zero wins but in reality we're actually tracking this state we just have one big problem here and that problem is that on the initialization of the page so let's go to our app at the bottom when we were waiting for the load event we are not actually updating the Dom with the latest state so you can see in the reset we the reset and the new round we're calling all of these changes to the view well we really need to call this on the first load of the page as well and as you can see we're repeating things quite a lot so it would be best to put this in a little helper method so we'll say init View we can put that right there and basically when we init The View let's make sure everything's closed let's clear all the moves let's set the turn indicator to whatever the current player is in state and that state value is now coming from local storage so we have we have some things that we need to update in addition to this in a second so last we'll update the scoreboard to be the current stats and now we can basically call this down here in the reset so we can get rid of all this and a knit View after we've reset the store so that's just a little helper method for us let's check to make sure we didn't break anything so we'll play in the game someone wins and we reset so it looks like everything worked now we've got two wins for player one one win for player two and if we refresh the page still nothing is going to happen but if we go down to um basically if we call this a knit View from the scope of the init method then that's going to populate things because we're doing that on page load so now the next time we refresh we're gonna stick with those two wins and one wins we can refresh it as many times as we want it's O is going to end up in the same thing but we have one last problem to to Really solve here and that is what happens if there's like three moves on the game board when we refresh the page it's going to clear that but you can see in state player 2 is up not player one so we need a way to actually reconstruct the moves that have been made on the game board on the initialization of the page so if you remember from our view we had some helper methods and one of those helper methods was handle a Player move and what that does is creates an icon and it replaces the square that that belongs in and all you have to do is pass it the square element that you want to replace so one thing that we could do is we could Loop through all the squares and basically update it in state so we really need to implement this method so initialize moves and what we're going to be doing is calling this dot squares so let's take a look at a previous implementation so we're clearing the moves here so let's let's move this up closer to that because it kind of relates so when we're clearing the moves we're just replacing children like that but when we're adding the moves we need to go through each Square and we basically need to check if there's an existing move in state so this needs to pass a moves array of the current game moves and then what we'll do is we'll check moves dot find and we'll look on that move for a square ID that is equal to the square dot ID which is what We're looping through right here and if there is an existing move we're going to call this dot handle Player move and now we can pass in the square and then we can pass in the player that made the move which is going to be the existing move dot player so that should initialize the moves let's go back to our app and right after we init The View um we want to call view dot initialize moves and these seem pretty similar but um when we init the view in the reset we don't want to actually it should be okay because the state would be cleared so let's go ahead and put that as as the last method here so we'll reinitialize the moves and since we've cleared the moves right here um or I'm sorry not not because of that but in the reset event we're resetting the store or new round on the store so that should clear all the current moves and this will basically be an empty call because it's not going to find any existing elements so let's go ahead and save that and let's refresh the page looks like we've broken something moves is undefined oh because I haven't passed in the current state so we cannot just call this with an empty function call we need to pass in the store.game dot moves and now you can see that it's initialized so no matter how how many times we refresh it's always going to reconstruct the latest moves of the game let's reset that so it resets up here and now we refresh and it's empty let's put a play down here refresh keeps that there and you can see how we can just recreate the state every single time so let's set this to a new round which clears everything including the scoreboard and just play through one more time player one wins player 2 wins got one win on each side and then Place something there refresh reset refresh everything looks like it's working great now the real test as I talked about earlier is we should be able to play this in two separate tabs so let me copy this URL and paste it here so we are now looking at the same exact game running but if we update in this tab and put an X there and then go to this tab you will not see it update and that's going to cause all sorts of problems because when we click here it's really going to be out of sync with the other Tab and you don't really have a way to play this game we have a pretty quick way to fix this as I mentioned with this storage event we just need to go to the app.js and in our initialization we can just listen for that event so let's go ahead let's find a good spot for that so right here this is where we're listening for The View events we're knitting initializing The View here let's put this at the very top or actually let's put it right here next to a net View so we'll say window dot add event listener and we're listening for the storage event so this is when the other tab updates it's not when the current tab updates where the other tab updates we'll put a console log in here we'll say State changed from another tab let's just see what that looks like first okay so we click and go to the other Tab and you can see the state change from another tab we'll click here and then see that state change from another tab over here so basically every time the opposite tab changes you'll get this event fired we'll leave that there and what we basically need to do is when that happens we need to initialize the view again so we're initializing The View on the first page load and we're initializing The View when the storage changes let's go back refresh the page and like reset everything so we'll make a move let's first look at this board this is empty this tab is empty and if we make a move in the top left corner what I would expect now is that we'll get a console log on this tab and we'll also see this x recreated and you can see when I clicked there we got it let's put an o in the bottom right and you'll see when I clicked over to this tab it showed up here and we got that console log so that's just a cool little trick so that you can play in multiple tabs now the last thing that I want to do before we go into the optional typescript refactor that's totally optional this has been obviously a long enough video at this point but hopefully you've learned a lot and maybe give a subscribe to the channel or something um but if you're still here we're going to now kind of connect some dots if you have not used react you've probably heard of it and react is what they call a reactive UI framework although that is only partially true if you really look under the hood but the idea the overarching idea is that in react you program declaratively I have a blog post on my website so let's go to my website and go search for some Concepts and I've written about imperative versus declarative programming and if you come down to the middle of this you'll see a section called react declarative versus jQuery imperative so far what we have done is been programming imperatively in other words what that means you can go ahead and read over these examples but I'm about to explain it here in this video when we program imperatively that means that we are saying okay here's the outcome that I want and here are the seven different steps that you have to take to get to that outcome now declarative programming is basically saying here's the outcome I want go figure out how to make that happen and I think I have an example in this blog post about building a house imperatively versus declaratively so if you're doing this imperatively you're going to specify the steps you build the foundation you put in the framework install the utilities add the walls finishing touches so on and so forth if you're building a house declaratively the only step is basically saying I don't care how you build it but I want a nice fireplace a Lakefront View and a big kitchen so these are the outcomes that you are declaring that you want and you let the Builder of that house determine the best way to make that happen so the same thing happens with the react Library some people would call it a framework even react is basically looking at the state of your application and based on that state and based on The View that you have defined that links that state it's going to figure out how to render the page to the screen and if we look back at our program we have a lot of imperative stuff going on so we are binding to all of these different clicks so when when these buttons are clicked we have a lot of very explicit steps written out of how we want the UI and this state to actually update now we can do a rather small it's not going to be huge refactor where we can basically take all of these individual steps and we can wrap them in a render method from there then the idea is that the render method is all that you need to call on The View and then you need to pass the state of the application so remember the store gives us that state of the game um the game right here and then the stats so that's basically our state and all we need to do is pass all of that information to the Views render method and then we can basically Define all those steps to figure out how to show the page to the user so let's try to do that I think this will be um a really nice way to clean this thing up for once and for all and will kind of get us to our final state of this application finally believe it or not this init view method actually represents a lot of what we're trying to do so we will be copying a lot of this stuff so let's make this a little smaller open up the view over here to the right actually we'll make it a little bigger that's kind of tough to see so now that I've you know talked about all this stuff in the render method basically what we can do at this point is we can put a hashtag in front of pretty much all of these methods because they're all going to be called from within the render method so these are all internal implementation details of our view class and nobody needs to know about them except for the view itself so you can think of all of these methods as basically just Dom helpers that we're going to call from the main render method so these event listeners are going to be public methods that can be called from the app or the controller and then we will have one render method here at the top so we're going to call that render nothing significant about this name necessarily other than convention this is generally what you would call it in when react was using classbased components that was the method that you had to put all of your jsx into and whatnot so this is more of a convention naming convention than anything so what we're going to pass into this is the store itself in that store as we know has those getter methods on it but I'm going to be more explicit actually I want to pass the game and the stats you could pass the entire store object and I think maybe in the final implementation that's what I've done but we'll be explicit with this so that we know exactly what we're dealing with so in other words the game and the stats are represented by this method stats in this method the game and based on this information we should be able to build our UI entirely so let's start building this up the first thing that we know needs to happen no matter what no matter what the state of this application we know that we want to populate this scoreboard based on the current state of the game so that'll be the first thing we'll do we'll call this dot update scoreboard and we have to pass in player one wins player two wins and number of ties and as we know we have all of that state available to the render method so we'll come back to app.js and you can see this is where we're extracting that stuff but we can actually do some destructuring to make this a little easier to deal with so from the stats we can grab the player with stats and the ties and then from the game what can we grab we can grab let's take a look we can grab moves the current player and the status which we can also destructure that is complete and the winner property so that's from the game so all of these this is just destructuring with es6 to get these variable references so we don't have to Define all of them or have this you know nested object property access going on so with the update scoreboard let's go back to our app and see how we did that we basically basically just looked at the stats dot player with stats so this will be the first player and we're finding the first player's number of wins player with stats one so that would be the second player their wins and then the ties will pass straight into that so right there we are rendering rendering the scoreboard and we can go ahead and start pulling all of this initialize functionality out of this method so we can remove this or actually we're going to replace a knit View with view.render and this is where we're going to pass the store dot game in store.stats we will also pass this right here to that storage event listener and now we can also pass it down here in these event listeners so let's save that and let's go back to our app and refresh the page and you can see that at least the scoreboard has been updated because we implemented that one method within render so the next thing that we need to do um let's see is probably reconstruct the game board we can really just follow this init view so we're updating the scoreboard we need to close everything and clear the moves so let's let's actually put that right above this so this Dot close all this dot clear all the moves we're going to update the scoreboard then we're going to initialize the moves so that's going to cover a lot of ground just there we need to set the turn indicator I missed that one so that one will come right here and that one takes a player so we need to pass in the current player that we're grabbing from the state so that will grab the current player and set that so now if we refresh and go back we should see a good amount of stuff being updated I don't think we'll be able to play quite yet and we've got a moves is undefined and once again I've forgotten to pass the correct data to this so we need to pass the moves from here down to the initialize method let's make sure we're not missing anything here okay we'll save that and right now we can't click anything because we have removed all of the functionality from the main app but we can get rid of this we'll keep this event listener because that's going to listen for changes on a different tab this is our initialization where on the first page load it's going to render The View then on each of our reset and new round events we're going to update the store and then render the new view our last thing to handle is that click event that happens on each Square so I think this logic can stay because this is just a check against the state and it's going to return early if it finds there's an existing move on the Square so that's not view related at all but right here we are handling the player move which um this should be covered every time we call render because all we have to do now is update the state and then the render method will then figure out how to recreate the moves that the next state represents so we can actually comment this out we can also comment out the player move I believe or I'm sorry we should not do that this is where we are updating State this is very important we need to update state with that Player move so that the render method gets the latest version of the state to actually recreate the game with so we can remove this view.handle Player move this is fine then we check if the game is complete and if it is we'll open the modal but we can actually do this check within the render method so let's see where's the best place to do that though so we've we're closing everything clear and move send the turn indicator update the scoreboard so we can really just do this at the end so we're really just checking to see if the status Let's see we can just grab that Inc is complete variable that we've destructured so if everything is complete the game's complete we will call this dot open modal and then from there we will grab the winner and check if there's a winner and if there is we will pass in this string otherwise we will pass in a tie so this check right here basically takes care of all of this right here and then at the end we're setting the turn indicator so maybe we should bring this one down to the very end of this render method because we don't want to set the turn indicator until um we know that the game is not complete so we're going to return early if we see that the game is complete okay so I think we can remove all of this from our method so at this point the player move event is really just checking State and updating it so we're checking for an existing move if we find it we're not going to do anything with the UI we're not going to rerender it if that doesn't if there is not an existing move that means it's a valid play and we're going to update state by making a Player move and then once we have updated State we can render The View with the new state that we have retrieved let's go back to our game it says this dot handle Player move is not a function so let's figure out where we're trying to call that I believe that's happening in the initialize moves yep so right here we just need since we made this a private method we just need to add that hashtag so that it can handle the player move just like this let's go back see if we got any errors and it looks like things are being populated so let's try to play again all right so when it detected a win it says the store is not defined so we're referencing something here in incorrectly oh okay so over here in the render method you can see I'm grabbing the winner name from the store except that's not available to us we really just need to grab this value right here so we can get rid of all this and just grab winner.name and so now we don't have any invalid references and it looks like player one wins so we can play again and it clears things to play through the game once more and you can see player one is racking up the wins here we can reset to a new round that works we can reset the game board that seems to work and I think we should see everything populating across these two tabs which appears to be the case so that is also working I know it's been a complete Marathon here um but we just have two more things to improve on this application and I think they're just really cool additions to this app um the first one is somewhat easy to grasp the second one is maybe not so easy so you can feel free to kind of skip over either of these but I wanted to add them in as a supplement to this video as you can see in our app.js we are calling view.render in a lot of different places so you can see we're calling this like what five six times five times there's probably an easier way to do this and one thing that we can do is go back to our store class and make one little update to this and it will make our lives a lot easier and automate a lot so right now this is just a plain es6 class but if we put the keyword extends we can extend an event Target so if we go and look on mdn for event Target you can look and see that this is an interface that's implemented by objects that can receive events and may have listeners for them in other words any Target of events implements the three methods associated with this interface and if you look at the instance methods we have add event listener remove event listener and dispatch event this is basically what we've been doing with all of our elements and by default all of these Dom elements are going to inherit this class from this class so we can also create a store that extends this in that way we can send a custom event every time that store changes so the first thing we need to do is and I'm sorry I think I extended The View which is I'm getting tired here let's remove this from The View and instead we're putting this on store so this becomes an event Target and then at the top of the Constructor we just need to call Super and super is the keyword that will basically allow us to inherit from this event Target so this is kind of some objectoriented programming Concepts but in other words once we add super we should be able to get access to those three methods so let's comment out super and go to app.js and go to store um let's see it says that we can add event add an event listener but I think that's probably just confused let's reload oh I'm sorry that's because we we called super there but we need to remove this so if we remove this for one second and then go to store you're going to see that we these are the available properties in methods and you don't see ad event listener anywhere because vs code has not detected that as part of the interface but the second we add this back and extend the event Target and then call Super we will now have access to an event listener and we want to listen to a specific event and this event we're going to Define as a state change so we'll say State change is the custom event we're going to be listening for and then in the Callback to that we're going to render The View so we'll render The View with the store.game and store.stats and that will allow us to basically remove the view.render from pretty much all of these so we can remove it from here because when we call store.reset that's going to trigger this event and it's going to call view.render we can remove it from here same thing we're updating the store so it's going to trigger this event and then finally down here we are updating the store so it will trigger that event as we stand right now it's not going to do anything because we haven't actually dispatched any sort of event but since we've Consolidated everything into the Save State method we know that this is the only place in the entire class where state is actually being updated so if we come down to the set item call for local storage all we have to do is call this which represents the store which extends an event emitter which has these properties available we can dispatch an event and what we can do is pass a new event so event right here is just let's go to the reference let me just type this in mdn event so the event interface represents an event which takes place in the Dom an event can be triggered by the user action clicking the mouse blah blah blah and you can basically customize this with whatever method you want so let's look at the Constructor the event Constructor creates a new event object and you can pass a type to it which is a string with the name of the event so that's what we're doing and we're calling it State change so when state has changed we're going to dispatch this new event and therefore our event listener for the state change key is going to be fired and we're going to render The View now of course we need to keep view.render in this event listener because that's not going to be fired here these are two very separate events this one is when the current tab State changes and this is when a different tab State changes and then finally this one is the first load of the document so let's save this and see if things are working correctly so we refresh it looks like we've got a problem I don't know what happened it looks like our live server timed out or something so let's refresh that page reset the game and you can see on all of these actions that we're clicking it's rerendering the page so clicking all these actions player one wins we play again it resets we get a scoreboard update and let's keep playing player one wins again and now we can reset the game we can reset the round and then if we click here we can see that populated in the other tab actually we cannot says must call Super Constructor before using this in the derived class Constructor let's see what that's all about okay I think that might have just been old I just needed to refresh yeah okay that was just old that was from when live server cut out so now things are being kept in sync and we can play from multiple tabs so let's win the game from this tab player 2 wins and we should see over in this tab the same message when we reset this is reset as well so at this point everything is pretty much complete um there's just one helper method that we can refactor that will make things a little more performant and I'm going to just plug this in and you can kind of study it on your own time so let's go ahead and look at the view so I'm going back to the view here and at the very bottom I'm going to add something called delegate now this is a pattern that I did not come up with on my own this kind of a wellknown pattern when you're working with the Dom and the purpose of this helper method is so that we don't have to do what we're doing up here and that is looping through each of the squares um not that not those specifically but right here where we're binding an event listener to every single Square element this results in a lot of event listeners and it's a little bit more performant and efficient to just register an event listener on the parent element and then we can kind of match match up which child element was clicked on that event and figure out which Square we're dealing with for this so if we look at the index.html you can see that we have this entire grid and then we have these squares so wouldn't it be nice if we could just register an event listener on this grid and then we can basically figure out which element was clicked within it um based on that you know helper method so we can go back to view and instead of doing this dot squares for each we can just call this dot delegate and the element that we pass is going to be this dot dollar sign dot grid let's see if we've selected that it looks like we have not so we'll say this dot dollar sign dot grid and we will select the data ID of grid let's make sure that we add that right here so now we're adding the event listener to this parent div the selector that we're looking for is going to be a class called Square or a data ID called Square so this will be a little bit more stable so we'll use that so we'll just grab an example here and then pass this as a square and then the event that we're listening to is a click event in the Handler is going to be handled by the controller so instead of looping through all of them adding an event listener to each we're just going to do it once with the delegate method and I believe this should work for us let's go back to app.js and just get a sense of what's being passed here so console log Square and when we click it's going to give us a div with an ID equal to the square that we have clicked so as we're clicking through this everything works just the same and that little refactor just made things a little bit more performant and we're using kind of a pattern that you'll see quite often is kind of the main reason I wanted to expose it here is you'll see this out in the wild and it's just good to know kind of what it's trying to achieve all right so there you have it we've got a tictactoe game that is working and most importantly we learned a lot along the way so if you're looking for some next steps um to kind of continue Connecting the Dots here I'm going to be creating a couple more videos that kind of play along from this original build so put in the work to get this built and now I promised what we would do at the end of this video is refactor this with typescript which is a pretty popular superset of JavaScript that a lot of employers are looking for at the moment here in early 2023 but I realized that this is kind of a diverging concept from what we've just worked on so I thought it deserved its own Standalone video so I will link in the description to that video and then after that we will actually do a refactor to react so how do we take this vanilla game and make it into a react app and then the last video there I'm hoping to do the same thing and take the vanilla react app and make it into typescript so I made a video where I refactored subscribers code and we worked on this tictactoe game and we built this in vanilla JavaScript it took us quite a while because I went through a lot of uh different concepts and patterns to build this out but now it's time to refactor this to typescript and the question is why am I doing this what is the point of using typescript in the first place so this video is going to be a refactor where we take a vanilla JavaScript tictactoe game and we refactor it to use typescript and along the way I'm going to explain and point out why typescript is so helpful and why so many employers look for this skill in developers let me start by saying that this video is specifically Geared for people who either have not used typescript and are trying to understand what the hype is about or are just a beginner developer you're looking to land a job and you're trying to understand what that path to getting that job looks like and I can assure you there are many companies out there using typescript today I write it in my daytoday job and it's an awesome thing if you learn how to use it correctly so with that said we're going to just jump into this video I recommend that if you want the most out of this video you should probably watch the original build so like I said we built or we refactored some subscriber code and built this tictactoe game and took several hours so I know it's it's a bit of a pain to go rewatch all of that but this is going to be a much clearer video if you have that background and you understand the steps that we took to get here at the very very least be sure to go to my GitHub repository I've linked to it in the video description um but let me just show you the one that I'm talking about here um so let's go nope that's not the right one so tictactoe subscriber refactor at the very very least you need to go through and open up this vanilla refactor and then read through all of the code here okay and we have a second branch called typescript which this is the final version of the video that I'm doing right now so we're going to head towards this right here and we're going to start with the vanilla JavaScript so without further Ado let's jump in and get this refactored to typescript all right so the first thing I'm going to do is just copy this entire folder um so let's see paste all right and then we're going to call this a uh typescript actually let's say live TS refactor okay so here forget about this for one second we'll get to that that's very important for this refactor it was just in my git ignore so just to overview we've got an index.html file that's got some Styles and it has this script down here that connects to these the App Store and Views so the MVC pattern that we talked about in that prior video once again Linked In the video description and here's the CSS file nothing crazy going on here like I said you need to be familiar with this application because I'm not going to explain uh it in any detail here so the question is if you want to move towards a typescript code base and you've got a vanilla JS code base to start with how do you go about migrating it if you are dealing with a very large vanilla JavaScript code base this is not the video to teach you how to migrate that this video is basically going to walk you through the the most simple steps the initial setup of a typescript app so the first thing that we need to do and to understand is that when we're writing typescript we will now need developer dependencies so talking about like a package.json if you notice in our original build we don't have a package Json or node modules or anything like that because we don't need them we can just write uh vanilla JavaScript es6 syntax and run that directly in the browser so there's no developer dependencies there's no build steps transpiling any of that stuff so the biggest thing you need to understand to start out is that we need some dependencies and the dependency we need is typescript um itself as well as the typescript compiler now I'll be honest I don't set up uh blank typescript projects from scratch every day it's not a very common thing because once you get your stuff set up you don't really think about it so I'm going to imagine that you know you're starting from scratch trying to figure out how to get this started and we're going to just use documentation to get ourselves there so let's go to the typescript documentation this is the first place that you would obviously go to figure this out so there's a get started a handbook and a reference these are going to come in once you're kind of well into things the get started is where we want to start so let's go ahead and look maybe typescript Tooling in five minutes looks like a good starting place so if we look at this page it's going to tell us how to get started so we can install typescript in two main ways through npm or yarn or pnpm or whatever we're using or by installing the visual studio plugins now I believe this is talking about Visual Studio the full on IDE not necessarily Visual Studio code I think there's a there's a big difference between those two we'll get to that though and it says you can install it just like this but what I want to find out vs code typescript let's see how it pairs with Visual Studio code which is what we are using here it says you know typescript is a superset of JavaScript blah blah and it says it comes with the language support but it does not come with the TSC or typescript compiler so just zooming out for a second remember typescript is a superset of JavaScript it does not natively run in any browser in other words you have a build step um or not not necessarily a build step but a compile step where you have to transpile that typescript syntax to plain JavaScript and once it's compiled to plain JavaScript then it can run in a browser so that's kind of our goal here and to do that we need the typescript compiler or TSC so here it's telling us to do the same thing as over here so if we go back to visual studio code I am using the yarn package manager you can also use npm but we'll just say yarn Global add this is the same as npm G or npm install Dash G and I'm going to add typescript and I already have it installed but it will install the latest version and there's the compiler and then the TS server as well now Visual Studio code I believe comes with this server so if you hit command p and you hit the little carrot and then type typescript let's see uh it's not going to show up quite yet because we don't have a typescript file open so let's just try something here Okay so we've created a TS file and just I've added a basic type just to fill something up and what you'll see down here in the the bottom right is that vs code has detected that we're using typescript and it's kind of kicked off the TS server I believe that's how it works uh leave a comment if I'm wrong on that but if we hit command p and then type a little carrot you can see that we can search for typescript and restart the TS server or reload the project so just know that in the background typescript vs code is working and actively looking through your code and recognizing the different types that are added so let's go back to the documentation it says building your first typescript file and it's giving you basic typescript and then it's saying you can compile it by passing the file name to the typescript compiler and then I think it just goes through some like basic introduction to typescript which this tutorial is not going to be necessarily an introduction to typescript but more of a like why would I need typescript and what does it solve for me so it'll be a light introduction but we're not going to really get into the meat of of typescript so let's go back and clear the terminal here and with our index.ts let's just Define some variable equal to 20 and then um let's give it a custom object type okay so we'll we'll say that some variable is a number another variable is a string and then if we assign this type to our object now typescript is going to kick in and it's going to start telling you um you know that you've missed certain typings so we've got these red squigglies because vs code has detected that you are typing this object as a custom object type which has these two properties so we need to actually fill these in with their matching types so if we put these in just like that and then finish off the object now this is matching the type that we've assigned it and if we tried to add an extra prop it's going to yell at us because that does not exist in the type that we gave it so anyways the point of this is to just give a Bare Bones introduction to what typescript is doing and we'll see how this kind of plays out to benefit us in the refactor for right now I'm just going to compile this so we've got the TSC or the typescript compiler installed globally let's go ahead and check so we'll pass the version it gives us 4.9.5 and now let's go and call for help so this will basically give you all the options which is pretty overwhelming to start with but you can see that if we just run TSC it compiles the current project so let's pass this file to it so TSC uh app or I'm sorry JS and then no we need to get into our live TS refactor first now we'll say TSC Js index.ts and you can see that we ran that command and now we have an index.js sitting over here which is the compiled version of index.ts so let's open up the two files next to each other and what you're going to see here is typescript in action over on the left is our DOT TS file this is what we're writing our source code in and we're able to use custom typings and assigning those typings to a variable now looks like something is going wrong here and it looks like the two files are actually conflicting so let's uh name this let's put something at the end there and it will solve this error for us so just know that because they're in the same directory and vs code is pretty smart it's detecting that we have two variables that are the same name now this is not going to happen in our final code because we're going to configure it not to but just know that that's what's happening here but anyways the point is that we've got a type here which is actually not valid JavaScript code you can't run that in a browser or node.js or any JavaScript or runtime so what the typescript compiler does is it removes this type and it removes this type annotation right here and it gets us to this just vanilla JavaScript object that can actually run in the browser so there's really two questions that come out of this number one why would we want to do this this what is the purpose of adding these types and then number two how do we get more control over how this compiles to this because there's going to be different um options that we can use to make that transformation happen and furthermore you know we don't want them going in the same directory because obviously that screws things up with you know variable declarations happening twice and so on and so forth so there's some configuration that we can do to make this better for us so let's go back to Excalibur here and come down here and say benefits of typescript so you could definitely go through a laundry list of things that typescript helps with and you know there's plenty of people that go and do that but I'm going to keep it simple here and just give one or two reasons why it is beneficial for your code base the first one is just um code checking in general so in other words it's going to if you're using visual studio code and you're using typescript visual studio code is basically walking through all of your code base and making sure that everything talks to each other appropriately so we will see this in action as we start to refactor but if we go back to our original application let me delete this index.ts file um and then the index.js if we go back to our original project which once again if you haven't seen this already if you didn't watch the prior video at least make sure that you've skimmed over the code and know what's there if we go to app.js um and let's try to find a good example of this so here's a good one when we are calling view dot render and we are passing in all of our state of the application these State objects have a certain type and as you can see Visual Studio code is giving you some you know suggestions as to what types these are already even though we're not using typescript and it's just inferring this from the function definitions over here in store so it can read through the functions and it can see you know what we are returning so the return type here and then it kind of infers okay what properties are on this object that was returned so on and so forth but if we go back to app.js it doesn't really know what type anything really is it can figure out the Boolean type but the moves in the current player in the winner these are all any types because because it can't really figure that out with plain vanilla JavaScript and what's Difficult about this and hard to maintain as your project grows is as you're typing things um quite literally as you're like typing on the keyboard and passing variables around in your application it's very useful to know are you passing something valid into a function and typescript allows you to do this very easily you'll really start to see this benefit as we start to refactor so the second benefit that I've personally found with typescript is refactoring so very soon you know for this video since we're refactoring stuff but if you have a big code base and you're trying to go through and refactor an entire feature it is extremely difficult to do so if you just have vanilla JavaScript and you don't have any strong typings throughout your application with typescript it's a lot easier because as you change things you know Visual Studio code or your editor that runs the typescript server is going to be able to tell hey did you move things around correctly and are you passing you know is your refactor going to break the compilation of the code but enough talk let's get started um so the first thing that we need to do now that we've got typescript installed and we kind of understand the general concept of what's going on is get it set up for this specific application so I know we've got it installed globally if you use TSC and you know type the version that's that binary is installed on our computer globally but it's always a good practice to install it as a developer dependency within your project and the reason being is you know the the global version is going to be different on each developer's computer so if you're collaborating on a project it's good to pin that typescript version for the application so that you have predictable builds in compiles when you when you compile that code to plain JavaScript so to do that I'm going to type yarn init and pass the dash Y flag just to say yes to all the options and just get a package.json file created so here's our package Json and we've got live TS refactor blah blah and the first thing we'll do is um yarn add and then patch a dash dash D for developer dependency and then I want to install typescript so now you can see dev dependencies has typescript now why is this a developer dependency and not a regular dependency well this is super important and the reason being is because as we talked about typescript is only going to happen before you deploy your application so you write all your code in typescript but obviously that's not correct or it is correct it's not valid for running in the browser or a node.js runtime so before you deploy your application you know out on some server like AWS or render or digitalocean what what have you you need to First build it to the appropriate runtime that you're using which is probably going to be common JS or es6 so the point of having this as a Dev dependency is to express the fact that you're not going to need this to actually run the application you just need it to to build the application to the point where then it can run the next thing that we need to do is initialize a TS config so this file is going to be a special file that sits in the root directory of your project and it tells this compiler so remember TSC is the compiler we don't want to use the global version anymore so in this case we can run yarn TSC to grab it specifically from the project and then just run that and it's going to try to compile stuff but it doesn't find any typescript files to actually compile so anyways we need to set up a TS config to tell it how to compile things so how we do that is we say yarn TSC I think init is the right thing so let's go to help and let's read through the options okay so here's the start of the options and you can see TSC dash dash init creates a tsconfig.json with the recommended settings in the working directory so that is what we want to do so we'll run yarn TSC dash dash init and you can see that it created a nuke tsconfig.json which we can open up up here and this these are the options that it gave it by default so let's go read through this and right off the bat you can see that there's quite a lot going on so by default it's going to have everything commented out and we're going to get rid of all this these are just kind of all the different options and you can go to this link here to view the reference for this so the TS config and it basically just takes you through all the different compiler options you can click on these links to to figure out what they do but most of these options are not going to be relevant starting out especially for a beginner these are more of just options to control you know your developer experience as you're building in a typescript code base and also of course how it actually builds and compiles the typescript to JavaScript so let's go ahead and get rid of all the comments just to see what it gave us so these are the defaults that you're going to get and we'll go from the kind of least important to most starting from the bottom skip lib check this just tells uh typescript to ignore kind of the node modules dot d dot TS files um that's not super relevant here strict true this is always going to be a good thing to turn on because as you go through your code and write typescript the intellisense that's provided by Visual Studio code will make sure that everything checks out and all the types are consistent so this is always good to have on these two options are just related to some maintenance of your code base so forces you know file naming consistency this allows you to um have interoperability between common JS modules and es6 modules so I actually wrote a whole post on this if you go to my site scripts versus common JS versus UMD AMD and es6 modules so this is a mouthful but this kind of explains what that is talking about and then most importantly is the Target and the module options so this is telling the typescript compiler what kind of code that needs to be output into you know code that can actually run within a browser and that's our goal is to get our typescript files to run regular JavaScript files so that we can just write our code and typescript and then the compiler deals with getting that to a place where it can run in the browser so let's go to the reference um we'll go to the the reference guide here so we'll start with the first one which is the target now I believe this is going to be in the um let's see where is this so just to orient ourselves it's in this is the compiler options uh field so if you you'll notice all this is defined in compiler options and here in the language and environment section you'll find Target right here let's click on that it'll scroll down and it says modern browsers support all es6 features as we've been talking about and we wrote our original project in so es6 is a good choice you might choose to set a lower Target if your code is deployed to older environments or a higher Target if your code is guaranteed to run in newer ones so in other words what Target represents is the end state of the code that is going to be compiled so we are going to Target es6 because that is going to mirror what we did the original refactor the Vino the vanilla JS one um so you can see we've already got that es2016 um you can pass a couple different options I think it yeah it gives you all the options right here um but es6 es2015 yes 2016 um all the way up to es next so let's just grab es6 because we know that that's available in all browsers um I'm not sure why they did es 2016 when they say es6 is a good choice kind of mismatching their defaults but anyways this is what the code compiles to the next one is module so let's go look at that we'll go back to the top and if you see modules you will find the module property this sets the module system for the program and um see the modules reference you very likely want common JS for node projects so not to backtrack at all but going back to that post that I wrote here scripts common JS es6 modules this really talks about these different module systems but basically if we look at let me do a sample file so sample.ts basically if we look at you know this syntax import something from some uh Library this is what we would consider es6 module syntax now if we did something like this const something equals require some lib this is going to be common JS syntax so the require syntax and then also module dot exports at the bottom of your file this is all going to be common JS syntax now if we do es6 once again it's import something from some web and then you can come down and you can export um you know some object or export default and this will export things from your file which is uh one to one with a module so that's what that is talking about and you'll see that it defaults to Common JS which again is a little bit of a mismatch it says the default is common JS if the target is ES3 or es5 es6 otherwise I'm not really sure given this documentation and the fact that we're on the latest version of typescript why it defaulted to that but we really want to just have es6 because we want to deal with that nice module syntax um that es6 comes with and then going down the list es module interoperability as I said is the ability to basically combine the syntax that we just went through and have files from multiple module systems being able to compile together this is going to be important especially if you have certain you know libraries that still use old common JS module systems or newer ones that you know use es6 modules and don't support common JS so having that interoperability is really nice especially in larger projects so at this point we've gone through most of this and once again you can read through the documentation if you have questions on any other properties but for now I want to build a sample project just to get our our bearings here so let's make a folder called test TS and this is just going to have a test TS file just something to work with and in this file we're going to just you know Define a sample type and the sample type is going to have a name which is a string and an age which is a number and then we will say let's actually call this a person type and then we'll say const person is a variable and this will be of person type and then we will just give it a string so Bob and then age so something like that so this is our basic TS file let's save our TS config and now we should be able to compile some things so the first question is well how does it know where to look how does it know that we want to compile that test.ts file well let's go ahead and try it so yarn TSC and run it and it says done in 0.73 seconds and it obviously found the correct file to compile so the question is how did it actually know that well let's go to the documentation and look outside of the compiler options at the top level options let's go to include and this is an array that specifies an array of file names or patterns to include in the program and then over here in the default the array if files is specified all otherwise so as you can see in our code base we ran the TSC compiler and it automatically just looked for any dot TS file in the entire folder and compiled it and that's because it's got this default glob that is including everything so given that behavior I think we're fine now the um the problem with compiling your TS files in the same directory as where they're written is it just starts to get really messy and then furthermore you really want to Output them into their own build folder now there's a lot more to this subject in general like uh creating a bundle and that involves things like webpack or parcel or whatever have you whatever now there's a lot more to this specific subject we could talk all day about you know how things are compiled where they're stored all that kind of stuff this gets into bundling and code splitting and you know build tools like webpack or roll up or parcel or whatever we're not going to get into that because we don't need it for this simple of a project our goal is to basically take all of our TS files and put them in one spot and then that will be imported to the index.html and it will run just like our vanilla project would so to do that we have a option that we can specify and let's see where it is so looking under a mitt this is probably where we want to look and yes here's the out directory this is if it's specified dot JS files will be emitted into this directory the directory structure of the original source files is preserved see root directory if the computed root is not what you intended so that's probably not going to apply for us um but you can see it gives an example where it outputs to a dist directory or distribution which is a very common directory to Output compiled files so that's what we're going to do we'll come back to compiler options and give it a out directory you can see vs code knows all these options gives you some autocomplete so if we specify out directory gives us the documentation which is very useful and we're going to say that we want to put this to the dist folder so we're getting some errors here and that's because we need a comma and once we save this and we rerun the compilation now it's going to Output everything into dist and there's our test.js file so you can see use strict is put in there and we've got a person compiled you'll notice that from earlier in the video this is a different syntax than we saw earlier earlier we saw this was a VAR and there wasn't any use strict going on at the top and that's because we didn't have a TS config we didn't have all of these targets and modules that were specifying how we wanted things to be output so anyways this is the basics of compiling a typescript project now our next order of business here is to look in our JS directory from our original refactor and convert these files to typescript so I'll leave this test TS folder for us let me get rid of the dot JS compiled file because that's now going to be over in dist um one thing that you would want to do here before we get too far is add a git ignore if you're working with Git and put the dist directory as well as node modules because we've added both of those neither of those need to be uploaded to Source control because node modules obviously can be installed by yarn and then the dist directory is the build itself which is going to be created with yarn TSC so let's close out TS config and let's start in the app.js file so now that we're working with typescript we can just rename this to dot TS and now vs code is going to automatically recognize that this is a typescript file and it's going to start underlining things and it's going to yell at us for all sorts of stuff because nothing is typed here now there are some strategies that you can use to migrate a JS project to typescript but in our case things are small enough that the best strategy here is to just rename all of these to TS so that we're dealing with typescript across the board now if we were to go through and just try to compile this right now it's going to throw all sorts of errors and the reason that it does that is kind of the whole purpose of typescript and that is it's going to check the types and make sure that they're all compatible across all the files with the Imports exports you know function calls parameters all of that stuff and that's a good thing that's what you want but when we first start out and everything has these red squiggly underlines and typescript is really mad at us it's not so fun but I'm going to work through this it's not as um it's not as intimidating as you'll think um and we'll get this thing worked out shortly so just as a reminder um the current project is no longer going to work because in index.html we are importing app.js and that does not exist any longer we have app.ts if we tried to replace this it's just not going to work because typescript is not valid in our JS runtimes so what we really need to adjust here I'm just going to do this right off the bat so that we don't forget is now that everything's being compiled to the dist directory we need to now specify instead of JS we're going to look in the dist directory and import app.js so same thing as the original project it's just going and looking in a different directory instead of the source code that you know in our prior refactor was able to run in the browser now we have to use the compiled code and you can see in dist it's going to maintain that folder structure so we actually need to say dist slash JS slash app.js and you can see that it will you know this this has been compiled um it through a bunch of errors but it still compiled it so we could probably get this to work actually let's just see real quick the way that we'll do this is we already have live server running just I had this before the video so it's on Port 5500 and we're looking in dist Js app.js so let's go to the vanilla refactor and instead we'll go to the live TS or let's just go to let's go to localhost localhost 5500 live TS refactor and let's see it seems to be working so even though there was all those type errors um it still compiled the JavaScript and this makes sense because typescript is just a superset of JavaScript so while not all typescript is valid JavaScript all JavaScript is valid typescript so in other words when we went to compile these vanilla JS files just in a different form it still knew how to do it it just was complaining about all the types so in this case where we're migrating an existing vanilla JS project this behavior is actually good because we can you know gradually migrate our code over and not break everything from the start so there are some options though once we get to a more final state if we go to the documentation let's close some things out here if we go back to this reference there should be some sort of configuration property that allows us to basically fail the build if there are any errors so we ran yarn TSC and it it's going to give us all of these errors if we just look through them um but it's going to still compile all those files to our output directory but just to demonstrate how you can change this behavior I'm going to get rid of the test TS directory now just so that that's not clouding anything up and then I'm going to completely delete the dist directory so that's okay because remember we can just run yarn TSC and it's going to create the disk directory interestingly enough now that we deleted that other directory that had typescript this Now does not maintain the JS directory structure so before I forget I'm sure there's an option to change that but before I forget let's go and remove that path and if we go back to our browser um let me get rid of this let's refresh and we can still play our game so this is looking at the live TS refactor so it's still working but if we go to the options reference there should be some options in the emit so if we're scrolling through there's this option called No emit on air and I think that's um what we want let's just scroll through a few more things okay so let's click on no omit on air this says do not emit compiler output files like JavaScript source code Source Maps or declarations if any errors were reported this defaults to false making it easier to work with typescript in a watchlike environment where you may want to see results of changes to your code in another environment before making sure all errors are resolved so let's just take this property no emit on air we'll open up our TS config and we'll throw this at the end so no emit on air and this defaults to false but we're going to say true now let's once again delete the dist directory and let's try the yarn TSC to compile our typescript files and now you'll see that even though we ran this there's no dist directory because we've said if there are errors do not emit any you know output files now once again we don't really want this because when we are converting our project over we want the ability to you know just compile the typescript files with errors so that we get a build output and then in a final State you might you know once you've converted your project over you might add that back or have other sort of build checks to make sure that you know you get a clean build before you deploy your application so now that we have everything set up and we've got the app working with this disk directory we will just jump into this JS folder it's probably you know not the best name for it anymore JS but technically typescript is a superset of JavaScript so it's somewhat valid but what we'll do is we will start um I think rather than starting an app which kind of consumes both the store and The View let's just start with the store because um it's always good to Define the types of your state at the beginning that just kind of helps you inform you know the rest of the files in the project design in general so this is just in general a good place to start now in this folder I'm also going to make a new file called types dot TS and this is going to be a module that exports a bunch of types that the rest of our files are going to consume and pass around to keep things more clear in our heads and to also satisfy the compiler so let me just reference um my final to make sure I'm getting the right types here okay so let's close this out our types will go on the left and then we'll put our store on the right so the first thing that we'll see as we're going through aside from all the red squigglies is this initial state so this is the um the shape of the object that we're storing in local storage as you can see here so if we open up our app and inspect and we go over to storage and local storage you'll see that I've already played the game and you can see this updates on every move and if we open this up you can see the parsed value so we've got the current game moves the history all games current round games and then you can go through and just see all the moves that have been made by the different players so that is the shape of that object that we're storing in state now the benefit of typescript is to just have confidence over you know the types we're passing around so it would be a great idea to Define that state so in typescript you define a typing with either the type keyword or the interface keyword the difference between the two is a discussion for another day I generally prefer types um but you know some people will get very in you know heated with a discussion about which one is better in which situation but we'll start with just a type and I'm going to call this the game state so game state is an arbitrary name I'm giving this type similar to how we would you know Define a variable name and the type is defined using you know basic object syntax so I'm just going to match this so let me copy this shape over and get rid of this comment so right now this is not really a valid type um it's not really complaining about anything but this is not a valid type let's go ahead and give this a type of let's see current game moves let's just say it's any for right now and it's going to be an array so it's going to be an array that has objects that are have any shape so this is just our starting point now we need to Define all of these types right here so this is kind of our final thing that we need to get to but we need to decompose our types into you know smaller units so that we can pass them around our files a little bit easier so the first thing I want to do is Define a player so you can see that we've got squiggly lines under the players param or argument that we're passing into the class Constructor and if we were to open up the app.ts you can see the player's array that we've defined so let's give a type to these objects you can see that they have the same exact object shape so we can give this a representation of player and a player is going to have an ID a name an icon class and a color class now these are the actual values but we want to give these a type so a 1 is going to be a number type player one is going to be a string type the icon class is also a string type and the color class is a string type so here we have defined a player type now you'll notice that all of these just have regular you know primitive typings and they don't have anything crazy going on here now with typescript you can make a property optional by adding a little question mark after the property or I guess not sure if you'd call that a property but you put this question mark here and now the color class would be an optional property so you can hover over it and it says it's either string a string or undefined and if we remove that it is just going to be a string for our game since this is a configuration property we want this to be all required properties so this is the correct shape so now what we can do is go back to stored.ts and move on to the next type that we'll need this does not satisfy anything that we've got going on here but it will be a building block for us to work from so the first thing I want to do is Define the current game moves so what is a move in our game if you we scroll down to Player move you can see that what we're pushing to state is a property with a square ID and a player so we just defined the player interface or type but what is square ID well this is just going to be a number and we can Define this as a move so let's call it a move and it's going to have a square ID which is a number and then a player which will basically be this type right here so if we hover over move you can see that this is the type that we've given it we can now take this move type and replace the any type in the current game moves with move so now the current gave game moves is an array of moves and that lines up with what we've done here where we are pushing a move to the array of current game moves which is our state now to figure out what we're going to type the history object with we need to go down into the store class and figure out what we're doing so in the reset method what we are doing is pushing games to the history object under the current round games property so this is the type that we're looking for we are pushing an object that has a moves property and a status property now it's pretty clear what moves represents moves is going to be what we just defined an array of moves so we can start with that and we're going to call this a game so a game is going to be represented by an array of moves and then we have a status property we don't really know what that is yet so let's give it a type of any to start with and now we can kind of go look through our code base and Define what that type is so if we track backwards and look at status it's coming from a destructured property off of this Dot Game and if we look what this dot game is that is a getter method on the class and the return type of that getter method is all of this stuff so we have a moves array we have a current player and we have a status this object right here the status is what we are trying to Define so let's make one more type called game status and that's going to be an object with an is complete property which is going to be a Boolean value value as you can see and then the winner is going to be a player so the winner is going to be represented by a player which we defined right up here so now we can take this game status and this is going to be the representation of status within the game type so once again we're coming down here and this is where we're pushing a game to the history of current round games we've got a moves property which is now represented by an array of moves and we have a status property which is now represented by a game status which has this type and now we're finally ready to replace some things here so we have a game and a game status let's put game right here for current round games now the last thing we have to fill in is the all games we have to figure out what type of array that is and I'll just save us some pain of looking through this and just say it's going to be the same thing so the current round games in all games going to have the same exact type at this point we have defined all of these supporting types for our game and in this case we had just looked at our reference code our JavaScript and we're basically just looking at you know what kind of objects are we passing around what are we returning from our different functions and we're just looking and analyzing our code to see that information if you're starting this project from scratch and you intended to use typescript all the way through this is actually a great exercise to go through before you even write any code defining the types of your game is a great way to define the functionality behind it without writing any code it's actually one of the first things that I will do when I'm building a new feature is just map out the different types that I'm going to be dealing with and then I'll figure out what functions do I need what types are going to be accepted as arguments to each of these functions what are the return types of these functions so on and so forth so as you can see typescript is already making us think a lot more clearly about what types of objects we're passing you know objects arrays so on and so forth what types were passing through our code and it makes us a lot more explicit about that and more organized so if we go back to our Excalibur where I was briefly listing out the benefits of typescript um I think one of the other benefits is makes you think more clearly and explicitly about your code so that's what we just experienced we're we're having to explicitly type out our game now at this point we still have squiggly lines and that is because we have not assigned these types to anything here so I will keep both of these open I'm going to just collapse this a little bit and let's just start working from the top of our file so the first thing let's look at is the Constructor with typescript we can add types to things by adding a colon and then giving it a type in in this case the key is our local storage key and that's just a primitive string type so we can just pass that in directly we don't need to do anything over in our types file because you know we don't need to redefine a string now players is going to be an array of players so we'll give it a colon and then we will say player and then array so that is going to be the type we're dealing with now you can see that it figured out that type already even though we didn't import it now this is not always going to be the case it works works okay here but generally what you'd want to do is import that type explicitly so with es6 modules what we can do is import a type and then that type will be called player and that type will come from the types file so types.ts is what we're looking for now you're going to see an import path cannot end with a TS extension consider importing types.js instead let's Google this it's probably some configuration property that we missed this person is just saying that we can just remove the extension let's just try that I don't think that worked now it's saying that types.ts is not a module oh I actually know what's going on here I'm sorry I messed this up so these are all just scoped to the types.ts file and it's also not saved so that that would be a big problem that we cannot import that so the first thing we do is save this file that will help us out quite a bit it will not solve this error because we have not exported any of these from the file so to use them throughout our code we need to export them just like we would export you know if we had some variable equals 20 and then we export some variable or export default something like that or we could just export it like this and it would do the same thing and now we can you know import some variable from the types file so that's just a regular JavaScript variable I will get rid of this and let's keep exporting all of these Okay so we've exported all of our types let's save it and now we should not get so much uh grief from the typescript server now there's no red squigglies we've got the player type and you can see we can hover over it and you can see that type which is really nice to just be able to hover over this you can also hover over it down here and now we have a strongly typed Constructor and it knows exactly what's being passed in but at this point we get these problems storage key and players these are instance properties of the store class and since we have not explicitly typed those it's complaining now one way that we could do this is come up here at the top and say that storage key is a string and that will satisfy it because we're passing in this key and then in the Constructor we are assigning this to a string so there's actually a shortcut to doing this a more concise way to do it and instead of calling this key and then this storage key and having that mismatch there we can short circuit this delete that rename this to storage key and so far it's not going to do anything so if we tried to assign this dot storage key equal to storage key it's not going to work we can remove that entirely now this is not going to work but if we say this is a readonly property of the class it will Define it so that we can access it later in the class so if we go to the bottom where we are saving the state you can see we're accessing this dot storage key in these two places and if we hover over that it's going to know that it's a string now if we come to the top and we get rid of that read only and just leave it to storage key it will complain about that because it says it does not exist on the type store so all we need to do is give it a readonly and you can also give it either a public or private just to define whether it's accessible in from outside the class or not we'll call it private because only the internal methods of this class can access this and then same goes with players so once again we can delete all of this and this can just become a private readonly array of players and so right here this is basically the shortcut for passing in these um parameters and then assigning it to the class all in one step and you can see if we look for this dot players it knows that it's of type player all right so we're getting closer we're seeing a lot less little squiggly red lines we just have a few more things to work out in this file um let's go ahead and start here at the bottom this is pretty isolated so this state or function has an implicit any type which basically means typescript is yelling at us because we haven't defined any type one thing that we could do if we really wanted to as we are refactoring this and migrating our code base if we change strict to false and save that and then restart the TS server you'll see that this no longer complains about this at all we can Define this as an any type and typescript's not going to be mad about it this of course comes with the detriment that now you don't have any red squiggly lines to tell you where you've messed up that is why most people would encourage you to put on strict mode restart the TS server here but I just wanted to show you that just so you can see now let's start at the bottom Here Again State or function this is a great use case for typescript this is where your life becomes a lot easier and that is because in this case we are allowing um someone that is using this function to pass either an object that represents state or a function that we will pass the previous state to and then it returns a new state so two different types of parameters that you can expect here and so we can type this a lot better now that we know or now that we're using typescript so saving the state we are going to be passing game state so that is the type that we're looking to pass in there so we'll say game state and it's going to complain about this because it cannot find that name let's go to the top and let's import game state from our types so we're importing that type now it's not complaining anymore but it complains right here because it thinks this function thinks that state or function is just an object that is represented by game State and right here we are trying to call it as a function so the problem here is that we've only defined one of the possible types so here we can define a typescript union let's go to the documentation and briefly look at this so let me make a new tab and typescript docs let's start over and let's go to either the reference or the handbook I'm a little surprised that we don't see unions um starting out but let's go to the basics that's not what we're looking for let's just search the docs so Union typescript unions uh looks like typescript for functional programmers is where we found that one um but anyways in typescript Union types are untagged in other words they're not discriminated unions like data and Haskell I I don't use Haskell so I don't know what that means um but what this is trying to basically say is that if you put this little pipe character that means that the type can be you know either this or that so it's kind of like an or um an or operator but for types so you can read more about that but let me just show you what this looks like it's going to be game state or and then this is where we Define our function that we're looking for so the function is going to be a separate type and I'm going to actually add this to um let's add it to the top of the file so since we're in typescript we can just add types within our files so we'll say Save State CB for callback and to define a function there's a couple ways you can do it but one quick way is to basically just give it an arrow function and tell it what it needs to return so in this case we want to return the game State and we're going to pass the previous state which is going to be a game state so basically I talked about this in the previous video when we did this build but it's always nice in your Save State function to be able to access the previous state so that you can derive that next state so that's why we're passing this but this is the type that we can Define and if we took this key right here the type and we passed it right here Save State callback you'll see that there's no more complaints from the typescript server compiler because state or function matches the type that we gave in previous state um is not typed yet but it satisfies that constraint so I can actually take this to be a little more concise and copy that type itself and just pass it in right here and then you need to put some parentheses around it and that should work just fine now we can get rid of this I just wanted to break it out so that it was more clear now everything's working here but if we hover over previous state that's going to have an any type which no one's complaining about this here with typescript but it would be nice to know what that is one way that we can do this and this is a little bit tricky with typescript it's um not super obvious but when we do local storage dot get item and set item it's not going to return a type so get item is going to by default return in any type um or actually sorry a string or null and the Json parse method this is where it's going to return in any type so what we want to do if we want to actually give this a strong typing is we will cast the type so we can say json.parse item and then this is going to be as game state so now get state is going to have a return type of game State and you can actually explicitly Define that on the function itself and if we remove this now um and we say as string or something like that it's going to yell at us because we're not returning the correct type that this function was declared as now that's for a whole nother day we're not going to be typing all of our functions explicitly with return types some programmers really like that to be explicit about typing all the functions this is just a refactor and I just want to get this working so for the moment I'm not going to worry about that but just know that you can Define the return Types on your functions so now that we have done this we can come back here in previous state will be a type of game State and it still works to pass it into state or function the game State can go into state or function because that is what we typed it as all right let's keep scrolling up I think we have one or two more errors the square ID this should be very easy let's just give this a number that's the expected type now if we hover over current game moves we would expect that to have the um move type but it does not it has an any type and I believe we can fix that where would we fix that one thing we can do is give this initial state a game State type so now anywhere we pass that it's going to recognize it so right here the initial state is of type game state so if we look here the structured clone method is actually similar to local storage where it's a a browser API and by default it's not going to type anything so in this case we're going to cast this to a game State object because we know that this state is going to be represented there so now where we're pushing to all games it's going to recognize that current round games is of type game so you can start to see how this comes together and how we are starting to get stronger types across our code okay so I think the only thing we have left here is that red squiggly not saying that the red squiggles are your map necessarily you obviously need to check other things but just given the fact that we know that this code worked before and we have strict mode on we can really use those as a guide for our refactor to to find areas that we have not strongly typed things so let's dig in into this error it says property includes does not exist on type number array do you need to change your target Library try changing the lib compiler option to es2016 or later all right so it's going to say 2016 or later so this is es7 I believe so let's target es2016 and then restart the TS server and now you can see that will go away because that builtin method on an array is available in the ecmascript 2016 spec so we are let me be clear about this we are using es6 modules which tells us how we can export and import things from modules and then we're compiling our typescript code to this standard of JavaScript so that standard of JavaScript has this method and at this point we have completed this file we've imported our types that we need and there are no red squiggly lines so that's a good indication that we're pretty much done with this file let's save that and go to the next one so we are done with the store let's go to The View this one will be slightly more difficult because we're going to have to deal with um Dom element types which are a little bit more confusing so we've got a bunch of red squiggly lines here but they're all coming from this query selector helper method that we defined let's go straight down to that and let's start typing it so the selector itself is just going to be a string that's like the class or you know selector that we're passing into the query selector method and then when we're typing things with typescript something useful you can do is just hover over these methods um it's not going to work because we're using it on the parent but if we go to the document there's some builtin types for the Dom methods and Global types so document is of type document and query selector this will give you a stub giving you the types that are available here you can see the selectors are string that's how I knew to give that a string and then element is what's going to be returned from it so we're going to pass a parent which is of type element and now we should see that's of element and then query selector is now available on that and we're passing in a string so let's let's retype this to a number real quick and you'll see that that's an invalid thing to pass to a query selector so that's how we know that string is going to be the correct thing and then furthermore we can go to query selector all and just give that a string type as well so these two methods are now strongly typed and if we come to the top it's still going to be yelling at us just a little bit it's saying it expected two arguments but it got one so what we have to do is come down to our methods and in this case the parent element is totally optional so what we can do is pass a question mark right after that and that will now make this an element or undefined and that's okay because we are first checking with our ternary operator whether that parent argument is has a value and if it does have a value we're going to use it otherwise we're going to fall back to the document so if we were to refactor this a little bit and intentionally break it if we just tried to access the parent element and grab a query selector off of it and then pass the selector it's going to work because Visual Studio code already knew what we were trying to do but if we remove that right there it's going to yell at us because it says parent is possibly undefined and you can't access a method like this on an undefined parameter now you'll see that vs code added this question mark here which is the optional chaining so let's type that in optional chaining this is actually not a typescript concept this is an operator in newer versions of JavaScript which we're using that accesses an object's property or calls a function and if it cannot find what it's looking for if the if the type is undefined or null as shown here it will short circuit and evaluate to undefined so the reason that that works to do this is because we're first this operator right here is just checking hey is the parent element defined if it is let me call this method otherwise let's turn element to undefined and then as you can see here we're checking if element is defined throwing an error and if it's not or if it is defined we're returning it so that technically does work but in this case we want to use this logic just to be explicit and say if it exists grab from the parent otherwise fall back back to the document and that gives us assurance that we're going to find that element so we've fixed all these red squiggly lines but now we have a problem here and it says property menu does not exist on type object and you can see here we've defined this as an object what we really want to do is retype this and we're going to use a builtin typescript utility let me make sure I'm doing this the same as my example or my final so if we go to the documentation for typescript let's go back and find ourselves the utility types so in the reference there's this utility types and if you come over here to record this constructs an object type whose property keys are keys right here in whose property values are type right here so this is actually leveraging something called generics in typescript which is kind of beyond the scope of this video you can look it up and and read about it but keys and type are going to be generics and record is going to be the type that allows us to define something so in other words this is just basically defining a basic object so right here this is where we will type this so remember dollar sign is just a property an instance property of the class you could have named this pretty much anything um so you could have named this element object store or something like that but we're just doing this for a shortcut and if we want to type it we can type record and then this is where we pass our generic values so we want to pass a string because we're defining arbitrary strings as the properties of this object and then the value is all going to be the same it's going to be a an element type so if we pass an element now things are satisfied satisfied here because we are passing an arbitrary string property name right here and then the value is going to return an element which as you can see down here we are returning a type of element so that is satisfied so all these are happy now but we need to type the double dollar sign which is the node list now if you come down here to query selector all let's just take a peek at what this element list is it is typed as a node list of elements so that is the native typing that the query selector all builtin method is returning and you can see that's defined right here so let's just copy that because we'll need it come back to the top and now let's define this as a record where we can give it an arbitrary string so squares is an arbitrary string property name and then the type that we're going to give it we'll just paste that in so it's a node list of elements and we'll initialize that to an empty object and now the element list is happy because query selector all returns that node list of in squares is that arbitrary property value so it satisfies this type so that's just a use of a builtin utility type in typescript using some generics I just want to show you another way that you could have done this so if you wanted to not use a utility type what you could do is Define a custom type so let's say um element object uh dictionary that's just our type name that we're giving it and here what we can do is pass in a key of string and this can be an element value and then we'll pass this element object dictionary I'm sorry it should not be of it should be in string so what this is basically saying is I want an object that can have an arbitrary number of properties in the key of that property so menu menu button menu items is a string and then the value of that property is an element as assigned here so this type right here is really the equivalent to what we did earlier where we said record string element and then closed it off and if you really really wanted to get fancy you could do this with generics so sorry I'm going on a little bit of a tangent here but this is just to give you an idea of the power of typescript so we could say custom record utility so what we're trying to produce here is the builtin utility record and just recreating that from scratch what we can do is pass in a generic so a key and a value and usually with generics you're going to put a t in front of it that's just kind of a convention that I use to kind of signify or you know Express this is a generic and then we'll use the same syntax so the key is in t key and then the value is T value now we know in JavaScript the only valid type of property you can give an object is really a string you can't just Define an object like this and start adding numbers to it like this is I guess this might be valid is this valid JavaScript oh that's funny I I guess I don't know I don't think this is valid but let's let's just try it out because now I'm curious I wouldn't be surprised so we'll say this is a test and it looks like it is that is interesting I didn't know that you could do that I don't know why you would ever do this other than maybe a map which is kind of similar to what that does but anyways um I guess I'll learn something new today while making a tutorial about coding that's probably not the best thing but anyways let's just be honest so anyways we want this to be a string so let's just say it extends a string type and now that's going to be fine and then we can just replace this record with custom record utility and it's going to work fine everything's going to be happy because we've basically just implemented that builtin utility type that typescript provides so just a interesting tidbit that you can kind of roll over a little bit so let's get rid of that because that is unnecessarily complex you can see at the top here I had imported the store just for JS doc typings when we had of the vanilla JavaScript project so now that we're using typescript we really don't need to do that so we'll get rid of that so moving down we can now implement the rest of these okay so we'll move on to the render method um the render method takes two State objects and the reason I originally passed this as two separate objects is because we were not working in typescript now that we are working in typescript I probably would just pass the entire State object as one parameter but we'll we'll stay consistent here so if we look at our types that we've defined we have a game type so that one's pretty easy we'll just type that as a game and we need to import that but instead of going to the top of the file in doing it there I'll show you a little trick so if you hold down on a Mac or on a command or on Windows control so command and then period in vs code will give you a suggestion and usually it can find out where it's looking now it's looking for types.js um not types.ts I'm not quite sure what's going on there um why it's saying that I don't even know if there's a there isn't a types JS I'm not sure what it did there but anyways we'll add the type uh import just so it's not importing anything but typescript types and then we can remove that extension and that should work so now that's working let's see if it works on this one so we need to do stats where we I don't know if we have typed that yet okay so I've actually um in my final copy of this that you'll see on GitHub I've used a slightly different strategy so we do not have a type already defined for stats if we go to store.ts the object we're looking for is this one and specifically we're looking for this return type which has a player with stats which is an array of players with this wins property added and then we have ties which is just a number now if we hover over stats it will give us this inferred type which is correct and furthermore the store class is in has an inferred type that has all of the methods on it so something that we can do is derive types from other types and in this case since we don't have a stats type what we can do is go back to the view and we can import type store from store and that will give us the store class that we had defined and then here what we can do is say store and then we can actually access properties on that so you can scroll down just like we're accessing you know properties of an array we can scroll down and see all the methods and properties that we can grab from the store and stats is one of those so now stats is defined because we derived it from the store now someone argued that this is maybe not the best way to do this and I would probably recommend um having stronger types and actually defining a stats type but for now this does work and it's a easy way to get that type without having to define it we can also grab the game uh getter from the store which will properly type our game and that is going to give us the correct types for the render method and again I'm using this to demonstrate something in reality you'd probably want to Define these as actual types over here and we do have that for game so we could use game ready oops scrolling around we could just use game right there but actually it will yell at us because this game is slightly different this is derived state so this game is this the state that we're storing in local storage and then the game that we're trying to represent in this method is derive state so in our store remember we have this method called game and we are reading the state the raw State and we are deriving some useful properties that we're returning for our game to use right here at the bottom so obviously current player is not saved in local storage and not represented in this type so I guess that's another reason why just using the store game is a good way to do it but yeah basically I would say that you'd want to type this function now coming down to the the bind events all these methods the Handler is of type any right now but basically what we're passing to the Handler is the Callback of add event listener so if you look at the stub for this add event listener you'll see it's got some overloads which is kind of an advanced typescript concept but one thing you can do to kind of zoom in on some types let's command click on add event listener and this will take us to lib.dom.d.ts these are the typings for the Dom that are basically provided already um to us and if we open up this in the file pane um I don't even think you're going to see it because this is kind of I believe this is built into vs code just to give you these typings um I could be wrong on that but anyways at event listener it gives you a couple types that you can deal with here and then you can hit command click on this and then you just kind of go until you find the type that you're looking for so event listener and now you can see event listener is actually a type that we can use so we don't even need to define it we can just use event listener which you can see is populated and pass that right there so event listener it's always best to use builtin types if you can if they're not defined then you obviously have to type them yourself but with something as common as an event listener Handler like this you can always expect that there's going to be a type already defined for you that you can use so those are done update scoreboard I believe these are all just numbers say number number and number here it's going to tell us something inner text does not exist on type element I might have used this wrong in my original actually I think this should be text content yeah so that that's actually the right thing to use I don't know why I was using inner text it seemed to work though so let's update all those open modal message is just going to be a string because we're passing a string of who won and then we have the same error here that needs to be changed to text content coming down to initialize moves this one is somewhat simple we've already defined the move type over here so it's going to be a move but right now it's going to complain because it cannot find it so hit command period and we'll update the import and you can see that that actually added the move right there and we're not using game anymore so we can get rid of that but now it's going to complain right here and that's because I've intentionally messed this type up we want an array of moves not just a move so to specify that we can either say array which is a helper utility of typescript or you can just do it shorthand and pass the brackets at the end of it which specifies that moves is now a moves array so now this is valid and you can see everything's working just to start demonstrating the value of typescript let's say that we removed this plus sign so in the original build I remembered to do this but it's pretty easy to forget to cast the ID that you extract from the the element Target to a number so what if I got rid of that now it's going to yell at me because it's an unintentional because types number and string have no overlap and what that's saying is we are doing a triple equals equality which types or which checks the type and the value and we're looking at a move which has a square ID of number and then the default event Target ID is going to be a string so element.id is going to type to a string so these will never evaluate to true now we can of course remove the triple equals and that would technically work because things would be cast but you always want to use triple equals if you can so here that's just a very explicit example of where typescript comes in handy is it reminds you of these little details that you might have kind of glossed over before all right so let's keep going you can see that it's complaining here about icon possibly being null and this is just a case where we could do better so remember earlier in the prior video actually not this video we Define query selector and this is like a safe query selector where we are checking uh whether the element exists and if it doesn't we're throwing in error which is kind of the behavior that we want we don't we don't want to proceed if we can't find the element so one solution to this problem is to put a question mark there because that will be the the optional chaining that we talked about earlier where we're saying hey let's check the icon and if it's an element grab the class list and add this to the class list if it's not an element and it's null let's just uh evaluate this to undefined and not throw any errors now that works you could add that there and it solves your problems but this is kind of an antipattern a little bit because you know you throw this in here and all of a sudden you know your app is not grabbing this correctly and you're clicking your toggle menu and it's not working well how do you find that error it's better to be explicit about this kind of thing so let's leave that and take some Clues from typescript and refactor this to instead um let's comment this out and say icon is equal to this and we'll use our safe query selector method in this case we're going to look for an I tag and the parent is going to be this dot dollar sign dot menu button and that is basically how we can safely select that and now icon is definitely an element because we're going to throw an error if it's not so these calls down here are now valid this is actually a concept called type narrowing um that you can read more about in the typescript documentation so I wonder if this is actually somewhere I can show you okay yeah so narrowing and this whole page kind of describes that process of of narrowing the types that I just explained here same thing goes right here we can just copy this down and replace this let's get rid of this and these two functions are good now a couple more the square element you can see that we are replacing the children on it so we know that that should be an element and then the player is going to be a player and command period to update that import at the top same thing here this is going to be a player and then finally we get this fun delegate method that we really it's tough to understand in the first place and now we have to type it but let's just walk you know parameter by parameter and get this done so element pretty selfexplanatory this is going to be an element the selector is going to be a string the event key is going to be a string and then the Handler is going to be an event uh what do we call this we have an example of this right up here event listener now we've got a little bit of a tricky situation so you can see right here event Target is possibly null so okay let's put that question mark the optional chaining but we still have this problem property matches does not exist on type event Target so we're going to use this narrowing concept again to narrow these types and get rid of these errors so this is where typescript is actually helping us in a way it's kind of making us more explicitly check things that we otherwise probably wouldn't so the first thing that I want to do let's get rid of this question mark or no we'll leave it there for now and we'll say if the event dot Target is an instance of element so this is a way that we can check if the target is an element so if that's an instance of the element and we actually want to negate this so if it's not an instance of an element then we want to throw a new error and we say event Target not found so this is just a guard that basically says Hey the purpose of the delegate method is um to delegate an event Target and find something within it and if we can't find that in the first place and it's not an element then the rest of this method is useless like we can't really proceed safely so we might as well throw an error exit early and then the developer is you know responsible for fixing that so that solves one of our problems the matches keyword or function Now does not complain about anything now in the Handler it says argument of type element is not assignable to parameter of type event and that is actually because I typed this incorrectly in this Handler we're actually passing the element itself so I have typed this as if we were passing the event but really what we're passing is the element so I need to type it accordingly so we're just passing a function that is called with the element as the first argument and it doesn't return anything so now there's nothing wrong here and we're okay but let's remove this question mark and see what happens so looks like we're okay all right so we're we're good here this works it's typed okay I think this whole file is now strongly typed and we're ready to move on to the final one app.ts and we're going to tie it all together and get it working now just as a reminder this is this app really we haven't done anything structurally to it other than a few things so it should still be working and if we open things up and ran yarn TSC let's look at the disk directory it outputs everything and then if we go to our page let's inspect the page and go to the end of the body and you can see the script is looking in dist Dash app.js and if we click things we can play the game still so there's really nothing that we've changed and it's been working this whole time we're just trying to make our project more maintainable with typescript so that if we want to extend it in the future it's easier to do so want to debug it easier to debug all that kind of stuff okay at this point by fixing those other files we basically fixed a lot of the typings here in in these files now it's always nice to just be pretty explicit about your typings some would argue that you want to infer types as much as possible but let's just go ahead and add a player type to this array and once again it's trying to go to typestop JS for some reason so we've got type player and this is a array of players now remember the store we've typed that so you can hover over it and you can see the storage key should be a string and the players should be a player array so this is a player array and this is a string let's say that we passed in a number it's not going to be happy with that it'll say numbers not assignable to type string so that's kind of the assurance that we're getting here now coming down here let's see what it says property ID does not exist on type event so this is actually I think a mistyping that we had from the bind Player move event let's go back to the view and you can see this is where we're using our delegate and then our Handler we've typed that as an event listener and if you remember down here I made that same mistake um where I was incorrectly typing the Handler so let's copy this handle or type and instead of event listener for the Handler it's just going to pass a function with the element that it's selected so now we come back and these type errors are fixed so this you know fixing type error is really about just reading the error message and being able to you know respond to it and know what it's trying to say which comes with time it's not easy to start and figure that out when you're first starting with typescript all right so at this point everything is strongly typed and our app is working so our last step here is to compile things let's make sure that we're not getting any errors so yarn TSC and there's no errors we're done in a second and the disk directory now has our compiled code and as you'll see as you read through this none of it's really minified or anything like that um and our Target was es2016 so you'll actually see all of these methods that we are using let's see if we can find the includes method here's some interesting stuff this is uh typescript dealing with like the class syntax and private fields and properties it has like a helper method to deal with that so that is kind of interesting so let me just show you if we downgraded this to like ES3 a prior spec of JavaScript as our Target I just want to show you how that plays out with the output it'll be tough to see so let's open up view.js and just kind of watch the code as we recompile this to a different Target you can see that all of this stuff changed and if we go back to es 2016 and then recompile and you can also see we get all these errors because we're using things we're using language features that were not available back in that ES3 spec so the compiler is going to give errors so now let's go back to our valid syntax and you'll see like this will update so you can see the modules that we're using but anyways that's just a kind of fun little tidbit to kind of explain that TS config a little bit more but I want to wrap this up by just walking through why this was so important to refactor to typescripts and why someone would go to the effort to do this the value in typescript does not really come as you are you know retyping things it comes when you're trying to refactor things or add new features so if we went to the JS folder and we went to let's say the store and let's say that we came down and we wanted to I don't know change the type that stats uh returned or something like that well if we went through here and let's say we updated this property wins to like win count okay so it's not going to complain at all right here but what you'll see is that if we try to recompile this so yarn TSC it's going to give us errors that were no longer there and the reason being is in our view on line 59 so let's open The View and go to line 59 you'll see that we have this underline because we are referencing the output of this stats getter from another place in the code base and we are using the original property so we would need to update that to win count before it's going to stop complaining and what typescript has done for us there is you know as the developer you're going through and you're changing a method and this method is dependent on by other methods in other parts of the code base and so typescript is smart enough to know like hey if you change this and it does not match up with the rest of the code base we're going to not compile this code base because it's just not going to work so otherwise if you had a vanilla JavaScript code base and you try to do something like this nothing would happen you you would just think oh I I'm okay I changed that that's fine and then you would find out that you had errors in your project once you started playing the game and it was not working as intended so that's kind of the benefit of typescript is you get that proactive checking of your code and you find out about errors a lot sooner so rather than pushing a bunch of code up to GitHub and deploying it and finding out that something's broken in your app you just don't it it just does not get deployed correctly and it doesn't build correctly if it's not correct code so that's kind of the the appeal of typescript I'm going to put this back to wins now now like I was saying you would probably want to type this A Little Bit Stronger so if you were going back to the stats getter what you can also do is set a return type on this so if we wanted to open up our types.ts file let's bring that over here to the right and maybe we wanted to actually annotate the expected return of this function which is usually a good idea with functions it's it's better to be explicit and I'll show you exactly why in a second so let's say this type is called derived game state or something like that and you don't have to Define this here you could Define it in this file itself and I would actually say that that's probably the better place for it because it's specific to this file so let's actually get rid of types.ts and we'll open this same file twice just so we can edit it in different places and I'll usually throw types at the top of the file so derived game state and that is what um or actually we don't want to call it that we'll say derived stats is what we want to call it and now I'm going to assign the return value of stats to derive stats and as we see it right now looks like nobody's complaining and that's because we've defined this as an empty object but let's say that we defined it as a string now this is going to complain because our return type does not match the explicitly annotated return type that we had assigned it so now our job is to Define this and we can see that ties is an easy one that's going to be a number so you can see that immediately we get this feedback where this looks okay but player with stats does not so we can come up and say player with stats and you could just say any that satisfies it but what does that get you it doesn't really help you throughout your code base because now anything can be passed here you don't get that explicit type checking so what we want to do is say that this is going to be a player array now let's see it doesn't seem to be complaining about that because this does satisfy player array it also has this wins property so we need to document that too so really what we need to do is make another type that is player with wins and that is going to be an intersection type or a union type I should say and we can actually use this and symbol to add properties so we can say wins and that will be a number so now player with wins represents what we're returning here and we can pass that in right here now if we would call this once again um win count now it's going to be mad because we're calling this wins here but our actual type is Win count so let's match this back up and now let me show you why explicitly uh making these types is advantageous the first thing is if we go over to The View dot TS where we had originally referenced these stats you can see that we can now import the derived stats and we'll import that from the store so we no longer need this right here we'll get rid of that entirely and then we'll add a type annotation so we're just importing the types so now stats is derived stats and then let's also say derived game this has not been defined yet but we can export that as derived game and then we'll import that from the store now it's complaining because we're trying to destructure properties off of derived game which at the moment is just an empty object now we know looking at the store that what we're returning from the game method is going to be the derived game and if we look at the return type here it has a array of moves so we can import that here it has a current player so we can assign it a player and then a status which is an object that has we've actually already defined that too so that is the game status from our types so remember if we go to types.ts we had the move type already defined so we just use that there we had the player type right here so we defined it here and then we had the game status right here which we passed to status so using these types we composed a derived game which is returned from this game getter method we've explicitly typed that as well and you can see winner is not correct here because I think we have a mismatch and I think I pointed this out earlier but I I don't know let's see ah so explicitly typing this actually um exposed I believe a little problem here it says player or null is not assignable to type player um so we're allowing the winner to be equal to null so if we go to our original types and go to game status this should actually be player or null it should not just be player because if it's null that means we have a tie a tie game so that was something that we fixed by being more explicit which is a good thing and why you should always explicitly you know Define your types where where appropriate so now it's not yelling at us for this anymore uh we're looking good let's see if that broke anything elsewhere so now we have explicitly typed the render method to pass in a derived game and derived stats and now the benefit of doing this if we come back to store and we go back to this game method or let's say stats earlier we were looking at Stats and we changed a property on stats so remember we previously had no explicit return type so we just passed win count just like that and nothing highlighted here so if I was a developer and this was a big project and someone else had written this function it's not very clear to me what the contract of this function is how it's being used outside or anything like that so I could come in and change this name to win count and not have any clue that that affected something in another file until I compile it so if we explicitly say derived stats now when we change it it's going to complain because it the wins is declared here but we are calling that win count so if we put that back to wins now it's going to be happy and it gives us the assurance that we didn't break something elsewhere within our code base so having done these additional typings let's close things out and run TSC and everything compiled and if we come back our game is working just fine so that's kind of the benefit um kind of bringing this full circle got the benefits of typescript I've demonstrated a lot of this but really I hope that this video has given you a brief introduction to typescript um just giving you some practical examples and kind of a code along um to to get your feet wet with this and also to kind of see how we can take a vanilla project and Port it over to typescript and get that setup done so if you like this video give it a like subscribe to the channel and I will see you in the next video which is going to be the same project but we're going to build it in react so we're going to take that vanilla JS and make it you know into a react app and then eventually we'll actually do another typescript refactor where we'll take that react app and do this same process of typing things so I'll see you in those next couple videos in this video I'm going to be rebuilding a vanilla JavaScript application to a react application and the purpose of this video is to show you how you transition from that vanilla to react and what problems react is basically solving for you why you would want to do this in the first place and just some basic introduction to you know building with react in general the app that we're going to be rebuilding is this tictactoe game and this is actually a game that I had created in a prior video and I'd shown you how to go from complete scratch nothing on paper to a fully working vanilla HTML CSS in JavaScript tictactoe game so the first thing we're going to do is learn how to set up a react so what that means we're going to learn how to take a vanilla react app so just regular JavaScript and set it up from scratch so from scratch let me zoom out a little bit this step right here is going to take I think it's going to be like over an hour so if you want to skip that if you don't care how it's set up I would highly suggest that you learn this if you haven't dug into it on your own but if you already know how this all works and you know what's going on under the hood to set up react app you can skip this the next chapter is going to be convert from JS to typescript so we're going to take that react app and implement it in typescript before we even write anything and the reason being is I just want to do this project in typescript because it's you know just the best best way to write a react app in my opinion just that you have strong type safety and then finally we're going to take the vanilla Javascript app and convert it to a react typescript app so I'm going to basically show you how you take the ideas that we put together in that prior video that you should have watched or at least gone over we take that MVC model view controller pattern and we translate that to the paradigms that react actually works with so you'll get to see how that translation looks and what problems react is trying to solve for us so that'll be a really fun conversion that we'll be doing and I will just highlight that this conversion is not me walking you through how to build stepbystep this app it's really to just recognize those patterns we're not going to be going through like okay now we're putting this element in and styling it adding this event listener we're going to be doing a lot of lifting and shifting you know copy pasting and reorganization so that's kind of what you should expect for this video let me be a abundantly clear from the beginning if you are looking for a video that is going to hold your hand to create a react app from scratch this is not the video to watch you should not be watching this video I'll say this a couple times but if you really want the best introduction to react go to the new react docs and go to the tictactoe tutorial no relation necessarily to the one that we're doing here and go through this step by step and build this react app this is going to be the best and most straightforward way to learn that there are just a couple prerequisites to this video number one and most importantly make sure you're familiar with the code base for the tictactoe game and the reason I say that is because I'm going to be glossing over a lot of the implementation details in the logic of like how the game works so if you haven't seen the prior videos which will be in the description as links or at least read through the code base to the point where you understand the control flow and understand the goals of what we're doing with this game right here so you can play the game you can reset it you can reset the scoreboard down here with a new round it's a relatively simple game but definitely need to understand what's going on so that's the first prerequisite then HTML CSS and JavaScript you need to be at least a basic Proficiency in them I have a 21 hour course in the description that you can go through if you need to get up to speed with that so go check that out if you feel behind on those three and then finally a basic understanding of react and understanding what jsx is in the first place you know the idea of a functional component those basic concepts and to do that I would go to the react documentation and make sure that you're on the beta react docs not the old ones because this these documentation or this documentation is way better it was completely Rewritten over the course of like two years and they did an excellent job with this so I would actually go to the tictactoe tutorial this is kind of funny that this is the example that they give and this is what we're building I actually did not mean to do that but anyways go through this tictactoe tutorial and just skim through it you don't need to you know build it all from scratch but the goal here is to just get a basic understanding because I'm not going to be going through all the like really basic concepts like react props or component props and passing props down that kind of stuff we're just going to kind of jump into things so that'll be great for you if you've already kind of gone through the basics you just need to see a real life example built live and that way you know you can just follow along and try to pick things up as we go and when I say a basic understanding of react what does that actually mean well I would expect that anyone watching this video has can at least get some sort of react App working they understand you know what jsx is all about so let's just write this down understand what jsx is you should understand what a prop is so this is just a property that you are passing to a component that that component reads as part of their render cycle so these are some pretty basic Bare Bones concepts of react and then finally you should understand what a functional component is so just at a very basic level and in the react documentation make sure that you're on the new beta or at least at the time of this video it's in beta but make sure you're on these docs the new ones they're great they were Rewritten over the course of two years and lots of effort was put into to this and they're just awesome so you can learn a lot from this and I honestly part of the reason I'm not making a beginner level react tutorial is because of these docs right here I think that this is the best place to go learn how to build a react application and specifically before you start in this video if you have no react experience I would go to the Quick Start and at least skim through the tutorial on building a tictactoe game this is actually kind of ironic I did not mean to replicate the same thing as the react docs I actually didn't know that this was the example so that'll be good you can kind of read through their implementation and how they approach this problem and then how I approached it in this video because I was not looking at this when I originally built it so skim through this build it if you want to can't hurt and most importantly go to thinking and react and make sure that you've understood kind of the ideas here and then finally this will just help you along the tutorial that we're doing here I would go down to managing state or actually let's see so adding interactivity and go to the article or page that's called State a components memory and just skim through this just so that you have a basic understanding of the use State hook which is linked right here because we will be using this throughout the video and it'll be good to just have a basic understanding of it now I could sit here and say go read this go read that but ultimately we're gonna just jump into some code and the best way to learn is to just do things so I will be sure to point out different parts of this documentation as we approach those specific Concepts within the build obviously you're welcome to read through any of this and I would recommend reading the entire react docs at some point because it's just a good learning experience but with that you don't want to waste any more time if you meet these prerequisites we will go ahead and get started okay so we're going to look at react here and specifically where do we start so as a beginner or honestly even as an intermediate level developer the question of where do you start when you're building a react application is actually more valid than you might think seems like a silly question but there's a lot of ways that you can start building a react application you could start as simple as just including a script tag in your HTML and using react like that you could even include Babel or Babel however you say that which takes the jsx and turns it into JavaScript and you could use that all within the HTML document so if we went over to our our refactor here what I'm talking about is literally just putting scripts right here and you could serve react from a CDN and you have react in your project so that's one option another option is you could use like a code sandbox so if we went to code sandbox and here you can go new from template and you've got these templates react typescript or react and if you click react it will just spin up react application for you it's working and you can go ahead go ahead and add additional things to it so hello again and you're already programming in react so this is probably the quickest way now you could also go to things like as which is kind of a meta framework sitting around react you can go to create react app I'm not even going to go through all the possibilities just know that there's a lot of different options here and the one that I'm going to choose is actually not recommended by really any documentation that you would see if you go to the react quick start it's going to give you an idea of where to start so start a new react project and if you go down to this section it says if you're learning react we recommend create react app now the unfortunate thing about create react app and you know other Alternatives that kind of just spin it up for you is that you don't get to understand what's happening behind the scenes you don't really understand what what react really is at its core so the approach that I'm going to take here is actually a lot more similar to how code sandbox sets this up so as you can see in code sandbox if you go to index.js you'll see this file right here where we're actually creating a root element in the Dom and then we're using some react helper methods to basically render that react application in the root element that we've specified for react to use this gets us a lot closer to what react is doing at its core and so this is where I'm going to start now you might notice over here in the files pane I know this is kind of small let me make it bigger you're not going to see any sort of build tools going on so you're not going to see webpack or anything like that it just works and unfortunately this also makes an abstraction over react that makes you not really understand what's going on so not only are we going to start right here at its most basic level we're also going to kind of spin up our own to build tools so that we understand how we're taking the jsx converting it to JavaScript bundling it into one file and then including that in our index.html again the purpose of this video is primarily to show you how you take a vanilla JavaScript application and Port that over to react and to show the problems that react is solving for you and to do that we need to basically do everything from scratch so consider this a learning opportunity not so much hey how do I most quickly get a react application working furthermore the approach we're going to take in this video is not what I would recommend you use to create a production ready app that you're gonna you know deploy and work on with a ton of people this is kind of the most minimal setup that you could possibly have and is great for smaller projects some people would probably disagree but I think next.js is probably your best bet in terms of a production ready react framework this is basically a react meta framework that takes a lot of the common things that you might have to do in react such as like managing images and routing and all that kind of stuff different rendering methods and it just comes out of the box ready to go so this is what I would check out if you're wanting to build something in production anyways not going to get too distracted there let's get started building our react app so the first step with any project is to set up the initial you know index.html and get it working in development development mode so that you can basically just go over to the browser and anytime the code changes it will update the application so that is the first step and the way that we'll do that with react is let's go ahead and create a new folder called live react refactor and then our folder structure here is going to be the public folder which is going to have like public static assets that will serve and then we'll also have an SRC or Source folder this is where our react application and components are going to go so in the public folder this is actually where the index.html file is going to go because this is a static file there's really nothing Dynamic about HTML so we can just serve that directly so let's go ahead and just copy that we'll go back to the vanilla refactor once again you should be familiar with this before watching this video so we'll copy index.html and we will paste it over to the public directory now with react we are building things with different paradigms we are not including all of this HTML in this index file we're going to be creating components to deal with this HTML so therefore we can actually strip a lot of this stuff out so let's take pretty much all of the body content and delete it the second thing that we're going to do is change the title this is going to be the react refactor and then just for the moment we're going to comment out the script and save this we'll put a little text in here hello world so this should be a basic HTML document now you'll see in the bottom right corner I'm using live server so I talked about this in Prior videos it's a vs code extension that you can set up it's running on Port 5500 and that's actually what we're looking at here with the vanilla refactor but if we go back to the base of this you'll see that we now can look at the live react refactor and go to the public directory and now we have a Hello World document now if we wanted to connect some styles to this you can see we have this style sheet left over from the previous project but it is referencing the CSS directory index.css now for this react refactor I'm going to name this something a little differently we're going to put a new file in here called globals.css and the reason that I call it globals is because with react we're able to kind of scope our CSS per component rather than per the whole project and so this is just a naming convention that I'm using to make it explicit that anything that we put in global CSS is going to apply to everything that we use in every component that we make and that's because we're putting it in the index.html to start us out I'm going to go to the vanilla refactor and just copy everything from that index.css and paste it here and we will eventually move some of this stuff out of this globals file into component specific CSS files but for now it's just going to all be there and now we have to update our path and this is going to be globals.css and if we save this and go back to the browser you can see that here's our hello world pretty small there but then we also have the correct background color so we know that the CSS file is connected now if we're just looking at this document this is not a react application yet there's nothing here that tells us that this is react in order to actually convert this to a react application we need the JavaScript to be controlled by react and therefore we need a script tag so what we're going to do is create something called an entry point you might see this called index.js or you know entry point or it could be named pretty much whatever but in our source folder I'm going to be very explicit and just call this entrypoint.js and in this file this is where we're going to initialize react now going back to the code sandbox that I had shown you a little bit earlier you can see this pattern right here where the code sandbox is basically importing react and importing the react Dom client and then doing something you can actually find this in the react documentation if you go to add react to a website and then I think at the bottom run the jss jsx preprocessor let's see so somewhere right here you can see where it's you know calling create root and then root dot render it's not really called out explicitly which is a little bit unfortunate but it kind of shows you how you know you might know to do this but anyways we're going to write this out in our file so the first thing that we'll do is we will import the strict mode for react and the reason we'll do this is because it basically parses through your code and it finds all sorts of mistakes that you might make when writing a react application it's just a good practice to get into to have that in strict mode but you might say well how are we importing from react when we don't even have that included in our index.html or node modules and the answer is we're really not if we tried this it's going to break so at this point we're going to install some dependencies for our project so let's CD into the live react refactor then I'm going to run yarn init Dash y to accept all the defaults this will save a package Json to our our folder here now what I'm going to do is add the required react dependencies so really the only things that you need from react yarn add react and then react Dom so let's go ahead and add those you'll see those populate in our dependencies this is all we need to create a react application so now we can go back to our entry point and this should work okay now we need to import the create root method and this will be from react Dom slash client and now here is where we basically insert react into our HTML document remember react is just a bunch of JavaScript that knows how to basically manipulate the Dom and render things it doesn't actually you know create HTML files for you you have to have an index.html to put it in so what we'll do is we will Define a root element and this is going to be a element that we select from the Dom so if you remember from our vanilla refactor if we go to the JS and go to view.js where we are selecting all of these elements via the query selector and then we're in the query selector we're basically just looking at the document and selecting an element well we're going to do the same exact thing here we're going to say document dot get element by ID this is the same as doing query selector with a hashtag in front to select an ID it's just a little bit more specific if you have an ID assigned to an element so we're going to get an element by ID and we're going to call this the react root now where did I get this name well I made it up and we're going to connect it here over in the body so what you need to do is make a div and then you're going to give it an ID and call it react root so what this is doing is it's saying hey here's a container div now react find this container div and put all of your application code right here inside of it so basically we're giving it a container to render into and at this point we've just selected the root element this is just going to be an element now we have to create the react root so we'll call that root and we will call the create root function that we imported from the react Dom client and we're going to pass in that root element that we had selected so that is the react root and then finally we can now call a react Dom specific method called render and what we're going to render is a strict mode container so now we're using jsx and we're going to render strict mode and then we're going to say hello World react and this is just arbitrary jsx code now what you might notice is that this is a DOT JS file we could call this dot jsx because we're using jsx in here and then we'll get JavaScript react down here in the vs code language mode so it will just give us some better syntax highlight highlighting in addition to that when we go to basically transpile these from jsx to JS this file extension will allow us to kind of Target this file to do that for so let's save this entry point now let's go to index.html we will for now keep this script out of here and save this at this point you might say well okay all right we're done with the initial setup for react we've got this react root div and then we've got this entry point.jsx which is selecting it and rendering the react application within it but if we were to go to the index.html in the browser so our live refactor and let's inspect this if you inspect this it's just going to show you the react root but there's not going to be anything within it and this makes sense if you really think about it because what's happening when we re request this right here from like some server in this case our local computer is the server that is serving that index.html file to the browser but basically what's going to happen is the browser is going to load some path and that path is going to make a get request to some server the server is going to send back an index.html document then what the browser is going to do is it's going to read through the document and it's going to parse through all of the HTML and it's going to also parse through any script tag that it sees you can see that we've got a script tag here but that's just injected by live server that's not anything to do with the application that we've built so what's missing well as you can see in our HTML document aside from this live server script we don't have any script so this code that we wrote in the entry point.jsx this is just living in isolation right now it's not actually imported and run within our index.html document yet and so therefore it has no way to select that route and render anything so your next option your next guess might be okay let's just uncomment this script script and then we'll go to the source slash entry point dot jsx all right so we're trying to import that script but if we go to the browser that's obviously not going to work if you go to the console you're going to get loading module from blah blah because the mime type was wrong there's just going to be all sorts of problems here and the reason is because a jsx file one that has actual jsx in it is not going to natively run inside the browser you might get this stuff to run we could probably see if that worked so let's console log the root element looks like even that's not going to work and I don't really care to debug that because we know that this is just not a good strategy in the first place so pause the video and just ask yourself if we can't do this then what can we do how do we actually get that JavaScript to run inside the browser in a script tag and the answer is that we need to transform the code that we have written the jsx code into vanilla JavaScript script and then put that into another file and then import that other file right here if you watch the prior video also linked in the description where we took the vanilla JavaScript build and we refactored it to typescript you might remember that we had some sort of build step where we had to take the typescript code that was not valid in the browser and we had to compile that with the typescript compiler into valid JavaScript that we could run in the browser this is no different what we have to do here is we have to not necessarily compile I think the correct term here is to transpile so let's actually go look that up so transpile versus compile I should know this so compiling is the process of taking the source code written in one language and transforming it to another transpiling is the process of taking source code written in one language and transforming it into another language that has a similar level of abstraction so in other words it's not a real huge difference and we don't need to get hung up on the the differences there but what I want to take you to now is a website some documentation for Babel or Babel I never know how to say this and on the home page if we just zoom in a little bit what you'll see is that it gives you an example of how you put in some Next Generation JavaScript and then you get browser compatible JavaScript out in other words Babble I'm just going to go with Babel is a tool that will take some sort of JavaScript some a flavor of it that doesn't work in a browser and make it work in a browser one of those things that it can do is jsx so if we come down to the presets this is just the the playground you can see that it's using the react preset so it knows you know that we can write jsx code and if we were to write you know something like just a regular P tag hello world and then close that P tag off what you'll see on the right is that it's using the react library to create a new element in the Dom and then render the hello world text within it we could also wrap this in say a div so we're just writing what looks like HTML but really this is jsx so now we're creating elements and we could probably I think in this playground even write a component so this will be a function component and instead of just this isolated jsx we will return that from the function and oops format this a little bit better so you can see that worked and it's returning a JavaScript function that returns these create element calls and then we could even render that so let's make our app and then we want to return the component as a jsx component and now you can see that all of this is going to be valid JavaScript so this is just a DOT JS file that we could include in that index.html file so this right here is totally valid to put in this script tag this right here is not valid and it will not work now Babel under the hood is running a bunch of code against this to get it to this state and therefore we're going to need some intermediate step to get it to this point now once again just like there's many ways to create a react application there's also many ways to transpile code and Babel is not your only option another option is you could use if you're writing this in typescript which hint we are actually going to convert this to typescript in just a few minutes you could use the typescript compiler to do this because the typescript compiler actually supports jsx you could use Babel and you could also use something like webpack which is a build tool so that's what we're going to do I know it's not it this is not the latest and greatest tool chain this is mainly for educational purposes but if we go to some more documentation let's go to webpack docs and now we're dealing with a bundler so it does more than just bundle code but the purpose of using webpack is to take a bunch of different JavaScript files and squash them into one Javascript file that we call a bundle if you really want to understand why we need a bundler I've written a post that I've referenced a couple times at this point throughout this video series and it's the Scripps versus common JS UMD AMD es6 modules and if you come down to the bottom let's see so the last step module bundlers this is where I go through and explain why do we need a module bundler in the first place so I'd recommend reading this short post just to get a better understanding there but our goal is to basically take this entry point jsx file and then we're going to have many many other jsx files that will have all our different components and instead of coming to index.html and copying this down and importing every single script that's been transpiled from jsx to JS this is going to get very confusing our goal is to just do this we're going to have one file and it's going to come from the public directory and it's going to be called bundle.js and we don't need the type module anymore because we're using react code and we don't need to worry about that but this is our end State and I actually need to update this because remember index.html is actually in the public directory so we just need to reference it relatively so the bundle.js will be output keyword output it's not created yet into this public folder and will sit next to globals.css and index.html so the question becomes how do we get it there how do we get this bundle.js to compile into the public folder the answer is webpack or something similar once again this has kind of gone a little bit out of style but that doesn't matter our purposes here are educational to understand what's going on under the hood of react when we set it up in the first place and you'll hear all sorts of things like oh webpacks so outdated but ultimately tons of projects are still highly dependent on this and will be for many years to come so don't get spooked by you know anyone saying that this is irrelevant this is very relevant and the concepts that we'll learn through it are even more relevant so let's get started there's a lot to this documentation lots of different configuration Concepts and I'm not going to go through these because you really don't need 90 of this for our purposes so what I will do is just start writing the configuration and we'll come back to the documentation to point out the individual options that we're using so in order to start a webpack a project we need to initialize it with a configuration file now if you go to the documentation there should be something about the configuration here so introductory configuration and you can see it's called webpack.config.js so let's just copy this let's copy that default and we will make in the base of our directory a webpack.config.js file and let's just copy that basic example in there now bear with me a little bit for the next couple minutes this is going to get slightly confusing and you're welcome to skip over this section if you want I have time for this video so if you want to skip over these details and just get started building the react application you can do so but I would highly recommend going through this section it's really a good thing to understand what's going on here and we'll serve you for the rest of you know your developer lifetime just understanding this stuff you probably won't have to touch it again but it's good to just know what's going on under the hood so let's take this line by line first off the mode this is in development and if you go to the concepts let's go to environment and right here it says the mode is an option that can be development production or none and this is going to enable certain optimizations that are done in production so webpack will do certain things I believe it's like like minifying the code and stuff like that depending on your environment so we are in development what we can do to make sure that this runs depending on our actual environment let's say that we were deploying this somewhere what we know is that the process.env.node EnV is going to equal production when we deploy it on some server this is just a default that you know any deployment site or Cloud host is going to assign so if there is a process node EnV we're going to use that otherwise we're going to use development so in other words development is our fallback but we're going to look at the node EnV to determine what to use for this mode now this of course assumes that you're only allowed to assign development or production to node EnV if you were you know had like a staging environment then this wouldn't work but most of the time it's either production or development so this should work now our entry this is a little selfexplanatory so we don't need to go to the docs for this this is going to be the file that webpack will start from it will start reading that file and then it will Trace all of the Imports that have come into that file and kind of just walk down the code tree to find all the relevant files that it needs to basically bundle up so in our case entrypoint.jsx is going to be that and we are in the root of our folder so we need to look in the source folder entry point jsx so we'll say relative to source entrypoint.jsx that's going to be our entry point and then output is also somewhat selfexplanatory it's going to Output a single file we're going to call this just bundle.js and it's going to put it into the dist director now we're going to just rename this instead of dist which is stands for distribution and it's a very common place to Output your your build output we'll just call this public and the reason being is we've got this public folder and what we want is that bundle.js file to get output to public now some would argue that you kind of want to separate these concerns and maybe you want to Output this to dist and then copy over your index.html and CSS to dist so that it's all kind of isolated into this you know build output but for our project it's pretty simple this makes sense and we can just output this to the public directory so let's save this we will save entry point and now the question becomes well how do we actually use webpack well you could install webpack globally in your path or better than that you can install webpack pin it to a specific version for this project that's what we're going to do we're going to say yarn add then we're going to add a Dash D because this is a development dependency remember webpack is just here to look at all of our code and bundle it up into something that can actually run in the browser we don't need it after it has done its job we can just run the code that output and not deal with anything else so what we can do is just add webpack so go ahead and do that and now what I'm going to do is go to package Json and we're going to add some Scripts not necessary but it's just convenience here and something that I want to add is a build script so this will run when we say yarn build is it's going to run this script right here and what I want it to do is look in the development dependencies and just run webpack so we'll save that and now what's going to happen if we run yarn build so yarn build it's going to invoke the webpack binary that we just installed and webpack automatically knows to look for the webpack.config.js file in the root directory and then this config has basically told the the binary to look at this entry point read through all the code and output it to this bundle.js but if we were to run this we really haven't given it any instructions as to like how to do this so let's just try to run yarn build and it's saying that we need to install the webpack client I guess I had forgotten to do that so we'll say yes that's going to actually update our package Json you can see that here in Dev dependencies or I'm sorry we're in the final one there live react refactor so now we have webpack and webpack client so at this point we run yarn build and you can see that we're going to get an air of some sort and it says module parse failed unexpected token you may need an appropriate loader to handle this file type currently no loaders are configured to process this file and what it's complaining about is this jsx that we have written so if we go to entry point by default webpack does not know how to deal with jsx it doesn't know how to transpile this right here and this is where Babel will come in so going back to Babel we talked about how its job is to take this code and turn it into this code and so therefore we need to add something called a loader to webpack so if we go to the documentation there it says loaders are transformations that are applied to the source code of a module they allow you to preprocess files as you import or load them so I'm going to save us quite a bit of pain here and I'm just going to show you how to get this working with react I'll be completely honest this is confusing stuff I would not spend a whole lot of time beating your head against the wall to try to understand it at a super deep level the overall goal here is to just understand the process that our code is going through not necessarily all of these implementation details so what we need to do is add a module property and this module is a valid on the config and then we'll say rules and then we give it an array of rules now each of these rules is going to basically say like hey once you see this certain type of file in you know coming from the entry point here's how you actually you know look at it and transpile it and bundle it so the first rule that we're going to do is we're going to test so this is going to be a regular expression that we're handing it and we're going to say if you see any file that has a jsx extension at the end of it then go ahead and apply this rule but if you see anything in node modules exclude it because we don't want to put that into our bundle and then finally here's where we're going to use a specific loader and that loader is going to be called the Babel loader okay so right here we're importing something that's external so we need to install that as a Dev dependency if you go to Babel let's we're getting got a lot of tabs open here at this point let's open one more so Babble docs and then let's just go down if you go to presets you can see there's a preset for react and it gives you all this really confusing stuff okay so here we get a list of all the different loaders that we can use so let's start with the babble loader so we click on that and it says disclaimer it's a thirdparty package maintained by community members so this will need to be installed and here's the install command you need to install the babble loader Babble core and preset now I also happen to know that if we go to the preset react we'll need this as well so we're going to just kind of combine all this into one command so we will clear the terminal here and then these are all going to be developer dependencies remember because we're just transpiling code so we need to grab the Babel loader so that's for webpack then we're going to grab Babel specific packages so we need the core module we need the preset M this is basically to just kind of normalize all the different ecmascript versions and whatnot so that we can run JavaScript in all browsers and then finally Babel preset react so we'll install all of those and we go to our package Json you'll see that they're all added right there and now we can come back to our webpack config and this is going to work because we have that installed and then we'll give it some options now this I'm not going to go into a lot of depth because it's more on the advanced side and we'll just assume that this is going to work so what we first need to give it as a preset is the Babel preset M and once again this is just to make sure that you know all the different versions of ecmascript so ES3 456 2016 blah blah all of those it kind of normalizes it so that the JS that is loaded is going to work in all browsers and then we're going to give it an array where we give it the Babel or Babel preset react and then this is really important we need to give it a run time of automatic and the reason that we need that is because when we come to entry point over here we are going to need that so that it automatically infers that react is part of this application and we don't have to explicitly import react every time we want to use it so that's the loader that we've set up I know that this whole blob is a a bit confusing but just zooming out the point of this is saying like hey anytime you see a jsx file that came you know as a result of looking in entry point so in other words anytime you see a jsx file in our project go ahead and use the babble loader and make sure you use the preset react which is basically what we were looking at here in this sandbox so that it takes this and creates this out of it so now we might be able to build our apps so yarn build remember that's going to run our webpack script and you can see that we got no errors so that's a good thing now we're not 100 sure that this worked yet but you can see in the public folder we now have a bundle.js and it's a bunch of ugly code that has been you know transpiled and this is not something that you want to actually read through before we get any further let's add a DOT get ignore to our project because we've added some developer dependencies and build output and all that stuff does not belong in source code so first let's look for node modules and ignore that and then I'm going to do this but this is probably not a best practice in any way we're going to look in the public directory and ignore anything called bundle.js and that's just because if you look at this this is a lot of gibberish that doesn't not belong in Source control this is an output of a build and that includes pretty much the whole react library in it so we do not want to put that in our GitHub repository so we'll ignore that let's make sure that that is working so we should not see any bundle.js sorry there's actually some leftover code from my typescript refactor from the prior video but the the main point is there's no bundle.js and if you look in Visual Studio code when it's ignored it's actually grayed out a little bit compared to the other files and folders so that's just a quick trick to know whether your your file's been ignored correct so the ultimate test is if we visit this index.html which is importing the bundle.js that we just output using entry point as the source does it work so let's go to the browser we can close this out I'll leave it open just so that we have reference to it and now you can see right here I gotta zoom in a bunch hello worldreact so something worked here because if you look at entry point you can see that that's where we're rendering the hello world react and so we know that our webpack config worked and we are able to render jsx in our browser and if we go ahead and inspect this now you can see in the react root that's where that P tag has been added but there is one problem still and that is if we go back to our code and we say by Zach or something like that and then we save this entrypoint.jsx well let's refresh the page and uh oh it's not actually working and the reason being is because every time we want to add something we need to rebuild the application so we need to run yarn build again that's going to compile everything and bundle it up and now you'll see Hello World by Zach obviously this is a poor experience as a developer we do not want this to you know we don't want to have to come and say yarn build every time we make a change so this is where the webpack dev server comes in and that is basically going to look at your webpack config and on any change to any file that is included there it's going to rerun this build step and output it to the bundle which is then going to be served to index.html and believe it or not this didn't used to be this easy but now you can basically just add one extra command here so instead of build we're going to give a Dev command which is our development only command and we're going to say webpacks serve and while we're here I'm also going to add a build production script and you know how we talked about over in the config we've got this process node EnV if we want to build it to production we could just pass something like this so set the environment variable and then call webpack so if we ran yarn build prod it's going to just apply some optimizations to everything and if we look at the bundle.js you'll also see that there's a license emitted here that would probably be good to include so let's let's go ahead and just say bundle all and that will include the license as well but if you look at this now it's optimized where like everything is minified it's all you know squashed together which makes it a smaller bundle to load over the wire over an HTTP request so yarn build is going to create something with lots of spaces and it's not optimized and then yarn build prod is going to optimize that but anyways we want to run this in development mode so let's run yarn Dev which is going to run the webpack serve command and this is going to say for using this command we need the webpack dev server package so we'll accept that you'll see that that was added down here at the bottom and now you can see that it's a running process that is just waiting for changes so we'll go back to our our index.html you can see Hello World by Zach and then if we go to the entry point jsx let's remove that and save it you'll see that this just refreshed Reloaded and if we refresh this page it's not doing anything ah so I am just not thinking whatsoever and totally totally messed this up so if we try to go directly to index.html in the browser and we are running this over live server so localhost 5500 we're just going to get the static contents of the public directory now if we look at the output of the webpack dev server it says that the project is running at localhost 8080. so we can kill the live server at this point so we'll close that server now if you reload this page we got it way zoomed in but if you reload this page it's going to say unable to connect but if we go to localhost 8080 now you'll see here's our hello world react is working again and then if we go back and make a change and save that it's going to hot reload and update in the browser automatically so the mistake I made I just I was trying to look at the static contents from live server we need to go to a different port here the next step here is to replace this content with our app so we can come over to our files and next to entry point let's call it app.jsx and this is just going to return a basic application wrapper that we're just going to consolidate all of that logic to we can go ahead and use es6 modules so we'll export a default function called app and then this will return some div and then say my app now we can import that into the entry point so import app from app and then replace this content with the jsx element just like that and we're getting an error I think we might need to say app.jsx yep that's all we needed to do it couldn't resolve that without the extension and I believe that happens because our webpack config doesn't know how to kind of parse through and import that if we don't have the extension on it so now this entry point is basically done we don't have to look at this anymore because it's all set up and now we're going to be working from this app.jsx so let's go make sure that it works my app now let's connect some per component styles so we're going to use just vanilla CSS and one way that we can do that is by using CSS modules so we can say app.css and let's go ahead and select everything in this app and make it the color red so this is not going to work by default if we just look at our app but all we have to do is import and then we just import the app.css now you'll see that there's some errors down here and we're not able to compile and that is because we have not specified a CSS loader right now we're in we have an entry point of this which is going to eventually make it to app.jsx then it's going to import app.css but we don't have any rule for that right now we're only looking for jsx files so if we go back to the documentation for webpack right here and we go back to loaders you'll see that there's some different different categories and one of them is styling so we have the style loader add exports of a module as style to adopt to the Dom or css loader load CSS file with resolved Imports in return CSS code we're going to need both of these and these are thirdparty packages so we'll have to install them so let's come down to our terminal open up another one actually we'll let's just cut this cut the server for now and we'll add this as a developer dependency we'll call it we got to get the style loader and the CSS loader once we've done that we can add another rule so remember rules is going to be an array and we can specify a CSS rule so here we're going to test and look for any dot CSS files so that's what we're looking for and if we find them we're going to use the style loader and the CSS loader so let's save that that's our final rule that we'll add and let's run yarn Dev and now you'll see everything compiled successfully and if we go back to the react refactor in refresh we had to refresh that first time because we had restarted the server so it's red and now if we change this to Green it's going to hot reload and everything is going to be green so at this point we have our entire webpack configuration done we have our entry point to the react app setup and our index.html is importing that bundle that we are you know basically compiling and bundling together with the help of webpack and Babel I know we've spent a solid amount of time just setting up this react app in the first place but I hope that it has been educational and given you a better sense of what's going on under the hood this is basically what the create react app and all of the other you know Frameworks that lets you set up a react app they're all doing some version of this under the hood but that's abstracted away from you and so oftentimes you don't understand what react actually is at its core level so there's one more thing that we're going to do and I kind of debated this a little bit but I want to build this react app with typescript rather than you know doing a whole another additional video where we refactor it to typescript I think using typescript is really awesome especially with react apps and across the stack and it's not going to be too difficult to translate what we have here to typescript and it will also give you a better idea of how we translate vanilla to typescript from a build step perspective if you're not interested in this and you just can't wait to get started once again timestamps are in this video skip to the build where we actually start building out this application and you know translating it from that vanilla JavaScript to react so let's cut this server and I will also add that there is a typescript branch and then a main branch for the repository in the description that follows and basically has all the final code here this is a combined video so you can find the vanilla JavaScript react app in the main branch and then the one that we're building in this video will end up in the typescript branch so I'll leave that in the description and kind of label it so that it's clear so if you haven't watched the prior video where I converted a vanilla Javascript app to a basically vanilla typescript app go watch that because it will cover a lot of the basic concepts that I'm going to gloss over in the next few minutes so I'll leave that in this the description but the first thing we need to do is install typescript so we'll add that as a developer dependency once we have that then we can run yarn TSC which is the compiler and we can run init this will create a TS config although I missed something here it's not a knit it is dash dash init so that creates a tsconfig DOT Json file now there's all these different options here I'm going to go ahead and just copy the final one just because it's going to save us some time okay so this is the basics um the things that I'll point out here this is pretty much the same as that prior video that we did but just to point out we're targeting es6 so that's the version of JavaScript that the build output will be and there's one thing that I've left out on purpose here and that is a property called jsx so let's go to the typescript documentation so typescript and then docs and then go to the reference for the configuration file so I'm not really sure where this would be typescript tooling reference let's just search it config writing a configuration file gosh this is very indirect I want to just go to the reference for this let's go typescript config reference not sure why that's not searchable easier but maybe I'm doing something wrong so anyways let's look at the let's find that jsx property that we had just talked about so that's down in language and environment so jsx and it says controls how jss jsx construct constructs are emitted in JavaScript files This only affects output of JS files that started in TSX files so we have a couple of options here we have react react.jsx jsx Dev preserve and Native this preserve option would be good if we were wanting to basically compile our typescript to JavaScript but leave the jsx as it was and then use Babel to take jsx and convert it to JS now for this simple of a project we don't really need all that in direction we can just use react jsx and get all of that to happen for us so let's give it to the jsx pro property and we'll pass in react jsx and so now the typescript compiler is not only going to look at our typescript and convert it to JavaScript it's also going to recognize jsx and convert that to JavaScript so it's kind of an allinone solution which means that we can remove all of the Babel stuff that we had just added that was good to understand you know how you would do something with a vanilla application but if you're using typescript we can remove a lot of this complexity so instead of using all of this Babble stuff we're going to use the TS loader and if we and we're also going to need to change this to TSX so it only searches for TSX files finally we'll need to update all our file extensions to TSX so that it knows to grab those we'll come back to these errors in a second those are type errors that we're getting let's just save this for now so now we have all TSX files and let's go back to this TS loader if we find this in the loaders it's right here for transpiling it says it loads typescript 2.0 like JavaScript so this is also going to be an external one I believe so we'll need to install it so let's open up our terminal here and look at our package Json right now we've got all these Dev dependencies we have Babel core preset M you know all of these Babel stuff and we don't really need it anymore because typescript has taken over the typescript compiler is taken over and done all of that job in addition to compiling typescript for us so we can yarn remove all of that stuff I'm just gonna take a little shortcut and just delete all that we still need the CSS and style loader and then we of course need webpack because we're still using that so let me save that and just yarn install so that's gonna refresh everything and then let's go ahead and add a developer dependency called TS loader so now we have the CSS style in TS loaders in our project and that should work for the webpack config now if we try to build this we're going to get some errors oh okay duh I need to update this to TSX because we're not able to read the entry point all right so now we're getting some errors but it's a much better error it's looking for type files for everything for react and all that stuff and so now we just need to install those you'll see an entry point it's going to say try npm save Dev types react so that's all we're going to do is save the react types and then I believe we also need the react Dom types and you can see this goes away root elements just complaining that it could possibly be null so one thing we could do is we could say if there's no root element then throw new air react to app configured incorrectly and now that's going to solve that because we know that that will exist I tend to just put a exclamation at the end to say like hey we know that this root element is going to be found that's okay to do in this case I think but yeah if you wanted to be safe you'd throw an air or log something or whatever to make sure that that root element was selected correctly let's try one more time yarn build and now it's successfully built things into the public bundle.js so that compiled typescript to JS and jsx to JS so everything can now run in the browser and let's make sure that that worked by going not to localhost 8080 but to the static app that we had so localhost 5500 we cannot connect to that because live server is not running but if we hit go live on live server and then refresh and go to live react RE Factor and then the public directory you can see that we have an app running with some styled green text so that means that our our final build worked okay and then if we were to go to yarn Dev and run that Dev server at localhost 8080. and refresh you'll see that it refreshes and once again we can go change this to you know red again and that should hot reload and change the the CSS of this app let me close a bunch of stuff out we'll close all the save files collapse all this and I'm going to collapse this terminal it's just going to be running in the background and if we run into some errors we'll we'll pull it up again so if you remember from the prior video that we did where we refactored everything the live TS refactor we basically took the tictactoe game and we turned it to a typescript code base so we've got the app we've got the store and we've got the view and then we have our types file this is what we're going to be referencing and we're going to be just lifting it over and putting it into react code while we're doing this I'm going to run a live server and that's going to be over here on this tab we'll just grab localhost 5500 and I'm just going to run the vanilla refactor just so that we have a working final version of the game so this is just vanilla JS nothing fancy this was from the first video this is just our reference point and we will eventually reach that same point over here in the react refactor the first thing I want to do is bring over our types file so let's copy this file of our types and put that in source and looking at the types we just have a player a move game status game and game State the next thing that I want to do is copy over the HTML so we had index.html that had all of this structure for us and we had the main tag as well as the footer and then finally a modal that opens when the game ends I'm going to go ahead and copy all of this and just to start us out we're in the live react refactor again and we'll go to app.tsx and instead of my app we're going to return all of this HTML so all that HTML is going in there it's going to yell at you because we need to put a fragment around this because we have no parent element to all of these and then of course we need to update all of our class attributes to be react compatible or jsx compatible attributes which will be class name so let's add that as a class name so that should fix a few things then all of our comments we'll just get rid of them right now those are not valid jsx and then finally you'll see that the style needs to be converted this one will be will be a little bit annoying to do so let me just kind of speed through this real quick so I'm just copy pasting everything from the final version Okay so we've converted the HTML to valid jsx no errors going on here so we should remember we have this server I'm just I guess I'll keep it open here just so we can see a little bit of it so that should be reloading every time we save and now you can see in our react refactor we've got something working we have red text everywhere because I have not removed from our globals or no not globals it was app.css where we added this let's get rid of that because that's annoying and you can see now we have all of the structure and style to our application but if we try to click anything it's not going to do much because we don't have any event listeners or anything hooked up let me go ahead and just close all these tabs we don't really need them anymore so the first thing that you'll want to do when you convert something over to a react application or you're just building a react app from scratch is look through your structure of your HTML and find what parts of this will be best as an individual component so the first one that's pretty obvious that I'd like to kind of rebuild is the footer this could be its own component and so what I'll do is I'll just start using this convention let's add a new folder called components and then in components I will just add a footer.tsx and then the styles for that footer will be footer.css one could argue that you know this organization is not the best but it'll work for now so the template that we're going to work with here is basically we're going to export the default function from each of these component files and I'm trying to do this in the CSS file oops okay so that looks a little bit better so we're going to export a default function and then return some jsx from that and then we're going to import the footer.css at the top so it gets all of the component specific styles and then here we can just go back to our app.tsx and let's just copy the footer entirely and paste it right in here so this will selfcontain the footer and I don't think there's anything that we need to modify here so we can just leave that as is and I don't actually think that we yes we do have some styles for that so in our globals.css where we have all of our Styles right now that applies to everything we want to come down and find the footer Styles so right here this is where all the footer styles are let's rip those out and add those to footer.css and then save both of those and so now the Styles and the HTML should be scoped to this one component and we can finally come back to app.tsx and remove the footer and replace it with our footer component and if you hit command period it will add that import for us as you can see right here so it's added the footer and our webpack is going to hot reload and you'll see the footer right here down at the bottom it's working and if you go to your developer tools let's actually look at Firefox extensions and let's look for react and grab some grab the react developer tools all right so now we have some react developer tools and I think if we refresh this yep we can now see the components so you can see that the footer is one of our components now so this is let's zoom in a little bit I guess I can't zoom in unfortunately I don't think I can zoom on the developer tools too much it's pretty small okay the next thing that we can do is break out the modal itself so this right here is the modal that we will pop open when someone wins the game we can bring this over to the components and call it modal.tsx with modal.css as the styles and I'm just going to use this template again so export default function remember to import our CSS and now what we'll do is we'll grab all of this right here and return it from this component we'll go to globals.css and find all the modal Styles which we've organized is another reason to organize your CSS so that when you refactor it's pretty easy to know what goes where so we put the modal CSS here we'll save Global Styles we'll save that component and then we will once again add the modal oops we need to import that from our components and you're going to notice that this is going to mess things up a little bit so if we come to our refactor well actually it doesn't mess anything up because we still have that hidden class so if you'll see the modal hidden class we're going to now control these sorts of things with react rather than classes so I'm going to get rid of that I'm also going to start removing all these data IDs because we're no longer having to select the elements we can just grab them directly from react so now once we remove those classes you'll see down here at the bottom you get this weird modal happening and let me see what's going on there so if we look at these Styles I think what's happening is we are setting the position to be fixed but we're not giving it a reference point of where it should start so let's give it left to zero and top zero and now that should work okay once again you can't click anything there's no JavaScript functionality quite yet but that should be styled correctly and then if we come to app.tsx now instead of using a hidden class that will toggle with some in you know implicit event listener we can just be more declarative about this and keep a state of whether the modal is open or not and then render it conditionally here so I'm going to just create a variable right now you'll see how this comes into play a little bit later but we'll just make a static variable called show modal and we'll set that to false to start once again you'll see how this changes in the future so don't get caught up on how I'm not using State correctly and stuff like that so show modal we're just going to wrap it in this just like that so now we will be able to conditionally show the modal and then furthermore what we might want to do is add some props to modals so we can pass what we want to show remember we are going to control this text right here with JavaScript so it would be good to add a message as props and then we can define a props type up here that has a message of type string so right here we're destructuring from the props object and we're typing it right here and now instead of player one wins we can say that is set to the message that we passed to the modal as props now since this is a required message if we go back it's going to complain because we haven't given it all of the props for now we're just going to say player one wins because we don't have anything Dynamic to pass quite yet but now you can see if we were to toggle this from false to true it's going to show the modal in pass in player one wins and just to check we can look at our components again and now we have a footer and a modal in our app so let's put this back to false for now so that's not going to show and move on to the next part that we're going to refactor into components all right so looking through the rest of this we could of course make a scoreboard component but this is not a whole lot of HTML I think we'll just leave this here that's really a style preference whether you'd split that out this right here we can simplify using some react conventions so this will be rather simple to do so we'll just open up some brackets here and I'm going to make an array that goes one through nine and you could of course create this with some JavaScript but let's just be expressive about what we're doing it's a lot easier to follow and then from here we're just going to map and we're going to call this the square ID is what each of those numbers will represent and then for each of the square IDs we're going to one of these div elements now whenever you map across multiple you know elements in an array react needs to know the key that you're giving it and the reason is so that it has a predictable order that it can put these elements in and when it goes to rerender and figure out whether each element has changed and it needs to rerender in the Dom it will look at that key to tell tell it that so we don't need this ID anymore we also don't need this data ID because we're not using that old vanilla syntax we do need the key here as I just described and we can pass it the square ID which is basically going to be the number on that square and then furthermore clean our vanilla application we were using JavaScript to render an i element or basically an icon in this div so if we look back when we click something or sorry this is the react app we have if we click something in the finished app it will put one of those icons within the Box so what we can do in react is instead of implicitly doing this we can be or imperatively doing this we can be more declarative and just say let's just put an i tag in there give it a class name and we know this is going to be fa solid now we're going to have conditional classes based on which player is currently up we haven't implemented that quite yet but for now I'm just going to pass in fax and then we'll say I think that was yellow was X or no I think it was turquoise is what we had for player one we will of course come back to this but if we render this now and then at this point we can get rid of all of these so just reducing that amount of code now you'll see there's an X rendered into each of those so we'll leave that there for now we'll come back and make that Dynamic later scrolling through we've got the menu this could actually be a good use case for another component so we'll make it a menu component and we'll export the default menu function oops and then this menu is going to have some props so we'll initialize that and then we also want to import the menu.css which we need to add over here so there's your menu CSS let me close a bunch of these clean this up and we'll just open oops this is from the final so there's our menu and our menu CSS now the first thing we'll do is let's go over to globals and look for those menu styles so it looks like we got them right here so let's copy all of those I think that's all that we need throw those in menu CSS save globals and then we'll go to index.html or I'm sorry not index app.tsx and at this point we can grab all that HTML whoops did that wrong so we'll cut that out of there and then in our component we'll just render that div right there let's clean all of these data IDs up because once again we don't need that since we're working in react now but pretty much anywhere that we have one of these data IDs means that we're registering it for a click listener so we'll have to set up those click listeners here so what I'm going to do for this menu is give it an on action property which is going to have an action type which will either be a reset or it's going to be a new round you could of course do this differently however you want I'm just simplifying things so that all we have to do is check the action type and then we know which of these buttons was clicked so we'll come down to the buttons themselves and we'll say on click and this one will be an on action oops we haven't passed the props yet so let's initialize these so there's your on action and then there's your props so that's grabbing from here and typing it out so now we can say on action and this will be a reset as you can see we get this typescript support because we have this Union type so there's your reset and then here's another click listener we'll say this one is going to be the new round so once again you could split this into two it's just stylistic you could comment this out and say on reset void and then on new round void and then replace these with those two different ones and then come down here and instead of passing the key we'll just say on reset and on new round and that would be the same so same thing just a stylistic concern so I'm going to go back to my original I like that a little bit so now we can throw the menu here where we took that jsx out so there's your menu and then we of course need the on action we'll fill that out in a second so let's import the menu command period to get vs code to do that for you you can see it got imported right there and then the on action for right now we're going to just put a placeholder in there and it's going to pass us an action because that's what we defined and we're just going to console log it for right now we'll eventually hook that up to something now if we go to our app when you click the actions menu you're going to see in the console it should and let's refresh oh we're not getting anything because we set those listeners on the menu items but we also need to listen for a click to the topmost menu so what we're going to do is put a click listener on the actions button and we'll handle this internal to the menu so we'll say whether this is menu open will be a piece of state that we're going to introduce using the use State hook and then what we'll do is we will look at the let's see we've got a function and we're going to set menu open and basically we're going to implement toggle functionality by looking at the previous state and returning the opposite of that so it's complaining about this because we haven't initialized this to anything so by giving it a false default State that's going to type our use State and this is Boolean because it's going to use type inference and it's going to initialize this to be closed but when we click that actions button it's going to basically toggle the menu open and closed we can verify this by going to the UI and clicking this and it's not going to do anything because we're not actually reading this menu open state we want to conditionally render this piece of jsx based on whether the menu is open now we have this leftover hidden class which we need to get rid of because that will override this Behavior so now let's open this up click actions and you can see we can toggle this back and forth the last thing is we need to look at this icon and remember in the the vanilla app we had this flipping depending on the open state so we can come down here where we're rendering that icon and basically say hey if the menu is open we're going to render something otherwise we'll render this so I'll copy this to both of them so right now it's going to be down on both but let's go ahead and put menu or Chevron up when the menu is open and Chevron down when it is closed so there you can see it flips now there's a slightly better way to do this and while we don't necessarily need this dependency it's something that I use and it's pretty helpful so we're going to add something called class names so we'll say yarn add class names this is just a utility really just a utility function is all this represents and if we use that we can refactor this code right here and in our class name we can import class names so we'll go to the top and say import class names from class names and you can see this is just a utility a simple JavaScript utility for conditionally joining class names together pretty common that you'll see this within react so now what we can do is we can say we always know it's going to be f a solid so that's similar across the two the two and then depending on whether the menu is open we will either use the Chevron up or the Chevron down and delete all this so now rather than conditionally rendering the entire element we're just conditionally rendering the class names which is similar to our original implementation so this is a good one for me to pause on and kind of show you what react is doing for you versus what you'd have to do in a vanilla app so if you remember so this is just the menu and if you remember in our vanilla refactor or actually let's go to the live TS refactors the latest one we did and we go to JS and look at the view and then let's go to the event listeners where we binded the click on the menu so this first one is where we're binding The Click event on the menu button and that let me let me just do this side by side so you can see it better so here's our react on the on the right and then vanilla is going to be on the left so vanilla react and you can see that let me zoom out just a little bit here's our actions button and here is our click listener on that button then here's the state that controls whether it's open or closed now that right there is the same as registering an event listener on the button over here in The View and then we're calling the toggle menu class which is down here somewhere in the toggle menu class is going to select the items in the button and toggle some Styles in a border and then figure out which icon to throw on that and that is being implemented right here where we're deciding which one which icon to put and then whether to show it as open or closed then furthermore when we come down here to the menu being open or closed here we're conditionally rendering the menu items based on whether it's open and you can see we have to implement this whole toggle menu and entire close menu to do that when it's pretty easy to just say like hey if that state is true then render it otherwise don't so that's just kind of how we can simplify our lives a little bit and then finally we have the action handlers where we register something that happens when the game resets or there's a new round and you can see that we will register that on the game reset right here so that's what we're doing with these on click listeners so just kind of a before and after look to see how We're translating things so at this point we can come back to our game and we can open and close the menu and if we click one of these we'll get something printed to the console telling us which one was clicked now we haven't actually handled those events yet but we will do those shortly at this point our app.tsx is pretty much done you could of course refactor this even a little more and add more components to clean this up but this is pretty readable at this point and I don't really want to try to go any further because there's no reason to so now we need to add the concept of state to our application and if you remember from the TS refactor we had this entire store class which was responsible for at the very bottom basically saving our state to local storage and then dispatching an event that said hey this state has actually changed and then the app.ts was listening for that event here and when it heard that event it would rerender The View with the new state now this whole process is totally native to react it is in if you think about it what this is really doing is the view is reacting to a state change in rerendering something so the pattern that we've used here is a very simplified oversimplified version of what react is doing and what the purpose of react is we just had to do it in a much more indirect imperative fashion rather than the declarative fashion that we're doing it in by just you know saying like hey if this state exists like if show modal is true render the modal we really don't need to do anything more complex than that but because we're using react now just because we're using react does not mean that our state is going to like change its shape or anything we're still tracking the same fundamental types as defined here so all we can all we really need to do is redefine a use State hook that will keep track of that game state in the main app and then we'll read that state in our jsx to conditionally render things and make things happen and make it interactive since all of the state works together and none of it's like isolated from one another it makes sense that we would throw this in a single state variable so we're going to call it State and then just use the convention for a use State hook and we'll import that to react and we of course need an initial state that will pass here if you remember from the original so let's go back to the store the initial state that we passed was this right here so what we can do is just copy this object and paste it into the default or basically the the function parameter is going to be the default State now because we're passing this object shape to the use State hook use state is going to use typescript generics to infer the type of state and if you hover over State it's going to give you that object shape so we could explicitly Define that right here and put it in the generic and Define the type of state that we're dealing with but it's just easier to let it infer that and so now we have a strongly typed State object now this is where things get interesting so we have this state object and if you remember from store we are just mutating this state or changing it in a couple of places so when a player moves we are pushing a move to the current game moves array and when we reset the game we are pushing current round games to the history and then when we do a new round we're pushing to all the all games array so those are really the only places that we're changing the state and then the rest of it is going to be something called derived State and that is basically where you are constructing a different or you're constructing a set of information that you have derived from that raw State object and two good examples of this would be our stats getter and our game getter and in the previous refactor that's why I called that derived stats and derived game is because we're basically in both of these we're reading the current raw State and then we are calculating things and returning that to our application so that it can use that information to do things so same thing here we're grabbing the raw State and then calculating all this stuff we're calculating if there's a game winner the current player in the status of everything so this is all derived State and we can actually you know what you might be tempted to do is put you know derived State and then set derived state in some use State call but really you don't need to do that there's no point in doing that because now you have to keep these two State variables in sync with each other if you read through the react documentation it will kind of explain to you why that's a bad idea all we really need to do since this is a pure function is come down here and Define our game object and then we need to make a method to derive that so let's call it derive game and then we also need to derive stats not State we need stats so these are two empty functions that we've defined and here we're going to derive the game and then stats we're going to derive the stats now of course we need to pass the state object into each of these and it's going to yell at us because we haven't defined that as a argument so all we need to do here is say State and then we need to define the state shape now this is where we need to start typing it if we go back to our types.ts that we had defined at the very beginning we have this game State key that we can use so we can pass that here as game state and then import that as a type we'll also put it right here so state is game state and now when we pass the state object into derived game and derived stats it's going to accept it and at this point it's just a copy paste exercise we'll go back to our store which was again let me remind you this is from our prior refactor this is our vanilla application not our react one all we need to do is grab from stats we can copy the return type of stats and then in our derived stats we'll just return that and now we're no longer referencing this dot player that is going to be we need to Define that so we'll do that up here so if we go back to store I think we have a players array or no this was in our original app is where we put that so here's our players config so let's copy that to the top of our app.tsx file so there's our players config and then now we can just grab that from that scope the global scope here and map through it and we have a derived stats object so before we get any further let's just console that log this so console log stats because we've implemented that function and if you go to the console here and refresh you'll see that we have printed this here twice and the reason that it gets printed twice is because we are in strict mode so if you go back to entry point and see this wrapper right here when we're in strict mode react is going to rerender each component two times and that is to catch bugs that happen and I'm not going to go too far into that but that's why we're getting both of these rerenders not just one but anyways we get the player with stats and this derived object where it says player one has zero wins and player two has zero wins and there are zero ties so just with that information we can start to populate our react application so if you go down here to the bottom you can see that we have this static numbers down here denoting who has what number of wins so what I'm going to do is grab the stats array and we know from our config that player one is the zero index and player two is the one index of that array so all I'm going to do is interpolate a variable here and we're going to grab the stats derived state and we're going to look at the players with stats and grab the first player and then we're going to print the number of wins in that slot right there then we can also throw the number of ties so stats dot ties and then finally stats.players with stats we'll grab the first index which is player 2. and pass in wins right there so at this point our player one ties and player 2 are getting dynamically populated and that part is done so the last thing that we need to do is Implement our derived game function right here and we can do that by another copy paste so store.ts from our original project not the react one we had this getter called game and that was basically just recalculating some things and returning some derived state so let's paste that in there we need to reference players from the global scope here and there you have it I think that should be pretty much it we're referencing state right here and that should work so now if we print the game so console log game and refresh here's the game we've got the current player which is player one there are no moves yet and the status is complete is false there's a couple things we can do now let's get rid of this console log and let's also get rid of this show modal static variable so get rid of that we can grab that from the game derived State now so instead of show modal what we can say is hey is the game dot status complete and if the status is complete then we're going to open up the modal and instead of a static message we will say game dot status I think we're going to need to do this dynamically so if there is a winner we're going to say game.status.winner dot name wins otherwise it's going to be a tie so you can see how we're just reading directly from the state to get what we need whether we need to render this and open it up and what the message should be when it happens but of course this isn't going to matter if we're not rendering it within the game itself so now what we can do is read the current state in the current game and figure out which squares need to be populated so right here remember this is where we are looping through all nine of our squares on the game board and rendering an icon if there's a move in that slot so what we can do is grab an existing move so let me show you where this originated from so if we go to our original project and we go to the app.ts I believe that's here you can see that when a player moves we are checking for an existing move and if there's an existing move we are returning because a player can't click that twice and then we are calling Player move furthermore in The View to figure out you know which squares need to have icons we have this initialize moves method and what it's doing is it's saying for each Square on the game board see if there's an existing move and if there is an existing move then we're going to basically simulate a move and populate that square so with react all of this logic is way easier to do so we can basically just copy that logic right here and we're not looking at moves we're looking at we need to look at the current game moves and now the square ID is already a number so we can just replace this entirely with square ID So within this map function we're figuring out if there's an existing move and if there is an existing move we're going to render that icon there now also remember on each move we are we have the player object available to us so let's refactor this right here the class name on this icon rather than a Static X that is turquoise we can use class names so we'll wrap that and let's just start over here so it'll be fa solid no matter what and then we're going to take the existing move grab the player and then give it the color class and then we'll also take the existing move dot player dot icon class and that will tell us what color and what icon to render right here if there is an existing move so now if we go back to our game the board is going to be empty and we still can't click anything because we haven't listened for that event so the last thing that we have to do to make this game interactive is add a click listener on this div for this square that we're listening for so we will attach a callback function to this and we'll say if there's an existing move we're going to return early so we're reusing this that we established up here so if there's an existing move don't do anything otherwise we need to handle the player move and this is going to require all the logic for handling a Player move so I'm going to separate this out into a hand handle Player move function and then I'm going to pass it the square ID of the clicked Square and then I'm going to grab the game dot current player and then we need to Define this function now so we'll come up here and we'll say function handle Player move it's going to take a square ID which is a number and then it will take the what do we say the current player so player is a player so now what happens is if there's an existing move return early otherwise handle the player move and that's going to be defined in this function right here so thinking back to our prior game how did we handle a Player move well let's go to the view this is our original game not a react app anymore and looking at the view this is actually not what we should be looking at because this is all handled by react we already implemented that so we need to look at the store so here is the player move Handler basically what we're doing is we're getting a copy of State we are pushing a move to the current game moves and then we are saving that state so let's go ahead and just copy that paste it here and instead of this dot get state we will just grab actually let's comment this out for just a second when a player moves we know that we need to set the state so let's call set State and to get the prior state that we need to deal with we can pass a callback and this previous will represent the prior state from the prior render snapshot so we can access that here so if we wanted to now place this logic in the set State callback and uncomment it we can do a structured clone of the previous state right here then we can push something to the current game moves and then instead of saving State we will just return the state clone from this set State callback and then the only thing we update here is we're grabbing this from the argument so player goes directly here and then what's it complaining about this argument is not assignable to parameter of type never and it's saying that current game moves is of type never array and that's because we did not explicitly type this as a game move so now we'll come through and actually type this out a little bit and if we wanted to what we could do is just cast this we can say as game State and game state is from our types.ts right here so we can cast that to a game State object and that's going to fix this because now it knows that the current game moves is a move array you could either do that or a better way to do it is just say use state is of type game State and now that will explicitly say like hey the object I'm assigning here is of type game state so now if we handle the player move we should start to see some interactivity here so you can see that our app is starting to work and it detects a player win now if we click play again it's not going to do anything and that's because we haven't set an event listener on the modal so if we command click the modal to open that file you can see that we're going to need an on click Handler and that's going to happen when the user clicks play again so on click and then we'll pass it that on click Handler which is going to be in props so this is really just a way of us to basically tell the outside world that's consuming this modal component hey there's an event and it's an on click event that means that the user wants to play again so now we'll come down here and we'll say on click and we need to do something to close the modal and update the state so in this case we need to reset the game so reset game but the problem is we don't have this implemented yet so similar to how we implemented the handle Player move we will also say reset game oops and now this is going to be a function that we'll call when that modal is clicked so similar to how we are just calling set State and using the previous state to find our next state we can do that here in reset game so set state will grab the previous state and now we have to do something with that previous state and derive something and return the new state that we want the game to be in once again we have already implemented implemented this in our prior refactor so let's go back to store.ts which is where we implemented this and you can see that we have a reset method and then we have a new round method we can pretty much combine these into the same method and just have like a Boolean check to see whether it's a reset or new round so let's first copy over the reset so we'll paste that in and instead of get State we're just going to pass the previous Right Here and Now what we're going to do is we're going to read from the game which is our derived state and we're going to destructure the status in the moves from there and then finally we'll return the state clone which will set that new state for us now like I said in our original we had a reset in a new round so all we have to do is conditionally let's just add a prop or not a prop but a parameter up here and say is this a new round and have that as a Boolean so if we come down here to this reset game we're going to say that's false it is not a new round it's just a game reset and then if you remember from our menu we have this on action so what we can say here is we want to reset the game and then to detect whether this is a new round or not we'll just say does the action equal new Round And if that evaluates to true then we have reset the game otherwise it will evaluate to false and that'll just be a plain old reset so we've hooked up this listener we just have to implement that have to actually use this variable to figure out what to do so all we need to do is come down here after we've reset the current game moves and we'll say if this is a new round so is new round we also want to push to the history so we'll say State clone dot history and then all games and then we'll basically just push and spread the state clone dot history dot current round games and then we will set that current round games equal to an empty array so if there's a new round we're also going to reset that so at this point we've got the reset game completed and I think this is the majority of the logic so let's go try our game out so it detects a win and if we click play again it closes things everything resets and down here player one has one win let's get player two to win one so player two wins we play again player two has one win let's click a square reset that it seems to work let's go ahead and reset the scoreboard down here and that seems to work as well so I think we're pretty much done let me just kind of pause the video here and go through and see if there's any cleanup that we need to do and then we'll be on our way okay so there's actually one big thing that I forgot to come back to and that is local storage at the moment we're not persisting this game across browser refreshes so let me let me collapse some things we'll collapse the players derived game and derive stats we will collapse reset game and handle Player move just to hide them from our view and you can see with our use State hook this is where we're storing the state of the game so if we were to play a couple moves and then refresh this browser it's going to basically reset everything because we're not storing this to local storage any longer and then furthermore I realized that this turn indicator is not implemented so let's go ahead and do that we'll get rid of these data IDs because we don't need those anymore and then this becomes pretty easy so we just add class names around this so fa solid and then we will just figure out whose turn it is by saying the game dot currentplayer.color class game.currentplayer.icon class save that and so now this will be dynamic and then finally we need to just replace this right here with the game Dot currentplayer.name so this should make the color the icon and the name Dynamic let's make sure that that's correct looks like everything's working except for that part because we have this as a static style I think maybe an easier way to do this is just remove this class name altogether remove that from there and then use the entire div to specify the color so we'll say game.currentplayer.color class is going to apply to the entire div which will style its child elements and then we're toggling on the icon so player one player two player one and seems to be working now and once again the last thing is local storage and this is something that I'm not going to spend a ton of time on the implementation to but there is a way that you can extract the local storage function to a react hook so we can basically make a replica of use state but instead of just using state it will also keep it in sync with local storage and in that manner we can use we can basically have the same interface while getting that additional functionality so just so that we're not getting into crazy detail or anything we already did we already do that in these videos I'm going to go into source and make a hook called uselocalstorage.ts this is a react hook you can learn more about this if you are in the react Docs and go to the beta docs then the new ones and then you can go to should be some hooks a hooks reference somewhere let's go to the reference so you've got the builtin react hooks I don't know if it does say anything about like custom Hooks and how you would do that oh here reusing logic with custom hooks this is a good place to check out what I'm about to do and understand why we would do this but I'm just going to copy paste everything in here to this file this is a use local storage hook you know basically what we're doing is we are adopting the same interface as the use State except we are also keeping it in sync with local storage and you'll see right here this is where we're like setting a value to local storage this is where we are getting the value from local storage and then in the parameters we'll pass the key that we'll use to track that in local storage so I've documented this a little bit you can read through it on your own time it's not necessarily super important to understand all the internals here I'll also note that I've added this effect right here that basically keeps track of other tabs that change so if you were let me close some things out and if you went back to our original implementation app.ts this is not the react app this is the prior videos you can see that we're listening for the state change this has pretty much become irrelevant now that we're using react because that is kind of built into the Paradigm of react but we also have this where we're listening to the local storage of another Tab and rerendering the view if that changes so I've created this effect here which does the same thing and it will update the state variable every time another tab changes its state so I will close this and you'll see how easy this is we'll go back to our app.tsx and we'll just comment out this original state and all we need to do we can name it the same thing so set state state and set State and now instead of use State we're going to use local storage and import that now it's going to ask us for a key so we'll say game State key and then it will ask us for our initial value which is going to be this right here the same thing that we passed earlier so we'll uncomment that so you're going to see how quick and easy this is to update so remember if we go to our react game play some moves and refresh not going to work but all we have to do is replace use state with use local storage and import that from our file and then we need to give it a game State key that's just the key that will be used in local storage as that first argument and then our default value is the second and that should do it that will keep the state in sync with local storage and we don't even have to think about it so we can play the game refresh and it will find the state that we're in after a refresh you can also duplicate the tab play something over here and then that's going to sync up over on this side and vice versa so now that we've got it synced up with a local storage I think we have replicated that original application in full so the last part of this is just going to be some cleanup and making things easier to kind of find and read through so let's go through and look for any like data IDs we don't need any of these because that was a paradigm from the original implementation where we needed a stable way to select a Dom element so we'll get rid of all those let's go through our components should be okay there on the menu no data IDs there and we're good and then furthermore we can just extract some of these things out so let's make a file called utils.ts this will just be some utility functions and if you remember we have this derived derived game and derived stats and then we also have the players up here outside of our component itself so we can take all of this stuff you could leave it here there's no problem with that either but I can throw all that into a utils file and then we can export them from it okay and then we just need to import a few types from the types file so we'll import the player and then the game state and that should satisfy these functions so those are now isolated to the utils file and then we of course need to import them so command period to import from utils do that again here and you can see we've got that import and that should work okay so that kind of cleans up our app file we no longer need use State because we're doing the use local storage hook which uses State under the hood so we'll expand this out and this is pretty much the final game once again you can find all of this code in the repository I've left in the video description be sure to look at the typescript branch to find this exact implementation I just did there's also a nontypescript version of the same app so now that we're done we can close out this develop developer server the webpack dev server and a good thing to do is always to just check to make sure that it builds correctly so we have these build scripts and let's just run yarn build and what this will do is basically check all your types type checking compile everything bundle it up and output it to the public directory with bundle.js and we can also try the build prod to make sure that it does its optimizations okay and it doesn't complain about anything so there you go and then finally we've got live server running on Port 5500 already and since we just built this app it's totally static and you can actually view this directly from the public directory rather than using the webpack dev server so you can think of it as webpack came in did its job compiled everything transpiled everything and gave us one nice clean bundle output and now we're just ready to go we've got what we need and the browser knows how to load the app so let's go back to the browser and we'll go to localhost 5500 close everything out and I know we've got a lot of folders here but let's go to the live react refactor and then if we click public it should give us the game and we should be able to use it just like we were with the dev server so we can reset we can get a new round going and just play the game so just wanted to show you that's a good thing to do check your build make sure it works and then you could really just you could deploy that this game right here over any CDN because it's static assets so you could put it on cloudflare you know whatever you want and it can be served to your users thrown on GitHub Pages what have you so hopefully this was an educational video that hopefully you enjoyed seeing how we can go from a vanilla JavaScript application and Port that over to react and kind of see the benefits of using react it makes a lot of our code a lot simpler we basically went from let's just kind of recap we went from this live TS refactor where we had an app let's just close all this out you can just scroll through this is our main app file where we're registering all the event listeners controlling everything this is our state where we have our store class and this is our view where we are handling selecting all the elements up here we are rendering here so this basically what react is doing for us and then we're binding event listeners got all of our helper methods here and all of this stuff it's pretty verbose what we've had to write here we even have the delegate method so that we could figure out which Square was clicked and that was pretty confusing so we've gone from this over to our react application which as you can tell if we go to app.tsx it's pretty concise what we've got here we don't have any delegate methods we can just handle everything basically right here with some event handlers we've got a hook that helps us deal with local storage and then we have our components split out by their separate concerns also with their separate CSS so that's just a much cleaner way to write an application and it's a lot easier to extend into the future let me know what you thought of this video be sure to give it a like And subscribe to the channel and I will see you next time
