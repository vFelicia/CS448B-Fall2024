With timestamps:

00:00 - Neo4j is a powerful graph database that enables organizations to model, store, and analyze
00:06 - complex relationships between data points.
00:09 - Its intuitive, graph-based structure offers a flexible and efficient solution for diverse
00:14 - applications, making it a leading choice for managing connected data.
00:20 - This course is taught by FreeCoCamp team members Farhan Chaudhary and Gavin Lon.
00:25 - First, you will learn about Neo4j and graph database management systems, as well as how
00:31 - you can benefit from incorporating them into your applications.
00:35 - Next, you will learn how to use a Neo4j graph database management system as the backend
00:41 - storage for a real-world application created with Java and Spring Boot.
00:46 - Finally, you will learn how to create a front-end with React to interact with the data stored
00:51 - with Neo4j.
00:52 - Neo4j provided a grant to make this course possible.
00:57 - So let's get started.
01:00 - Hi and welcome.
01:01 - I'm Gavin Lon.
01:02 - So, I finally got my FreeCoCamp t-shirt.
01:05 - I traveled all the way from the east coast of South Africa to Amsterdam and met the founder
01:09 - of FreeCoCamp, Quincy Larson, and he gave me my own FreeCoCamp t-shirt.
01:14 - Really great.
01:17 - So the point of the trip was to meet Quincy and some of the core team members of FreeCoCamp.
01:22 - In person.
01:24 - It was about team building and solidifying relationships between coworkers.
01:29 - The key concept in this course is, in fact, relationships.
01:34 - Relationships between data.
01:36 - The relationships could be between people, between car parts, between a t-shirt and a
01:40 - human being.
01:42 - So relationships between homogenous data or lack data, for example, between human beings,
01:48 - or relationships between heterogenous data or different types of data.
01:52 - These relationships can be very effectively represented within a graph database management
01:58 - system.
01:59 - Neo4j is a graph database management system.
02:03 - In this part of the course, I want to present to you a brief overview highlighting the significance
02:08 - of a graph database management system.
02:10 - Before we look at Neo4j, let's contextualize the significance of a graph database management
02:15 - system by looking at some of the other popular types of database management systems commonly
02:20 - used today.
02:21 - So let's look at three other commonly used types of database management systems before
02:26 - we discuss the graph database management system and why we would want to use a graph database
02:31 - management system in our applications.
02:34 - The most well-known used database management system type is a relational database management
02:40 - system.
02:41 - The relational database management systems are SQL Server, Postgres, and MySQL.
02:47 - In this type of database, tables represent entities.
02:49 - For example, a table named employee contains rows of data.
02:53 - Each row of data is divided into columns or fields containing employee information.
02:58 - For example, the name field contains the employee name.
03:01 - The age field contains the employee's age, etc.
03:05 - Another data entity could be implemented in a table named department.
03:09 - Each row in the department's table denotes an individual department.
03:13 - For example, one row stores information for the human resources department and another
03:18 - row stores information for the finance department.
03:22 - These data entities or database tables within a relational database can be explicitly related
03:27 - to one another within the relational database management system.
03:30 - For example, an entity may have a one-to-one relationship with another entity.
03:36 - So say employees and the cars they drive, a specific employee is related to a specific
03:42 - car, one employee to one car.
03:45 - So for example, the employee entity in this case has a one-to-one relationship with the
03:49 - car entity.
03:51 - Two database tables can have a many-to-many relationship.
03:55 - For example, an employee could be a member of multiple teams.
04:00 - And each team can contain multiple employees.
04:03 - So this means an employee can be a member of more than one team, and each team can have
04:08 - many employees.
04:10 - So in this scenario, the employee entity has a many-to-many relationship with the team
04:15 - entity.
04:16 - A database entity can have a one-to-many relationship with another database entity.
04:22 - For example, the department table has a one-to-many relationship with the employee table, meaning
04:28 - each department can contain one or many employees, and an employee can only be a member of one
04:33 - department at a given time.
04:36 - So this one-to-many relationship can be established within the relational database management system
04:42 - through an appropriate schema design.
04:45 - A database schema defines how data is organized within a relational database, which includes
04:49 - constraints such as table names, fields, data types, and the relationships between the relevant
04:56 - entities.
04:57 - So for example, the one-to-many relationship between the department table and the employee
05:01 - table can be implemented by including a primary key, which is a unique identifier for a row
05:08 - of data in the department table, and a foreign key field within the employee table, which
05:14 - relates to the primary key value within the department table.
05:18 - The main advantages of a relational database design is that it helps facilitate data integrity,
05:24 - so the data is not easily corrupted.
05:27 - As well as reduces data redundancy, storage for repeated values are reduced.
05:32 - For example, if you stored department data within the employee table, you can see here,
05:38 - the department short name field and long name field values are repeated across rows in the
05:43 - employee table, whereas separating the data into an employee table and a department table
05:49 - means these values are not repeated, resulting in saving storage space.
05:55 - As the data scales, this storage saving can be quite significant.
06:01 - A technique known as normalization is employed to design a relational database.
06:05 - I won't go into the details of normalization here, but please look up normalization, which
06:10 - is a key concept in relational database design.
06:13 - So the technique of normalization can increase data integrity, minimizing data corruption
06:18 - and also significantly reducing data redundancy, i.e. unnecessarily storing values repeatedly.
06:24 - The downside to relational databases is the speed of retrieving data when multiple joins
06:29 - or deep joins between entities are necessary.
06:32 - For example, if you want to retrieve analytical data that summarizes data from multiple entities,
06:39 - a normalized database design can cause the retrieval of such data to be a slow process.
06:45 - So the way to speed up data retrieval can be to use a schema-less database management
06:49 - system like, for example, MongoDB.
06:52 - This is a document-based database management system.
06:55 - The fact that the database design is not bound by a schema like with a relational database
07:00 - management system can result in increased speed of data retrieval as well as allow for
07:06 - better design flexibility.
07:09 - So you can see that each of these database management systems have their purpose and
07:13 - advantages.
07:15 - Another type of database management system may use a name-value pair storage structure
07:20 - like, for example, Redis.
07:22 - This database management system is great for caching frequently retrieved data and therefore
07:27 - can help speed up a system.
07:29 - So we have briefly looked at three common types of database management systems.
07:34 - Relational database management systems like, for example, SQL Server or Postgres, schema-less
07:39 - database management systems like, for example, MongoDB, and name-value pair database management
07:45 - systems like Redis.
07:47 - So let's look at the significance of a graph database management system.
07:51 - Neo4j is a graph database management system.
07:55 - This type of database management system is based on the graph data structure.
07:59 - All of these social media platforms use graph databases, Twitter, Facebook, and Instagram.
08:05 - As we all know, these platforms have millions of users.
08:08 - A relational database management system would not be ideal as the only storage facility
08:13 - for such data.
08:15 - Because of the way the data is structured would mean multiple joints between entities
08:18 - would need to be made.
08:20 - When relevance data is retrieved, which would drastically slow down the data retrieval process
08:25 - ultimately causing a poor UX user experience because the whole system is slowed down by
08:32 - these joints that need to be made between data.
08:35 - So note that when designing a particular system like a social media platform, you could incorporate
08:40 - both a graph database management system and a relational database management system into
08:45 - your overall system design.
08:47 - This type of solution could combine the enforced data integrity inherent in relational database
08:52 - management systems with the complex relationships between data entities or nodes that can be
08:57 - facilitated using a graph database management system.
09:01 - For example, the master database could be a relational database where data integrity
09:05 - and data redundancy concerns are addressed by the inherent benefits that we have discussed
09:10 - regarding a relational database management system.
09:13 - A graph database management system that is appropriately synchronized with the relevant
09:17 - relational database management system can be leveraged to increase the retrieval speed
09:22 - of data that, for example, has complex relationships.
09:26 - If data that requires complex relationships was retrieved directly from the relational
09:31 - database management system, the joints required when retrieving the relevant data could significantly
09:36 - slow down the system and ultimately result in a very poor UX user experience.
09:42 - So by including a graph database management system in the overall system where it sits
09:46 - on top of the relational database management system, as it were, and is used to speed up
09:51 - the retrieval of data with complex relationships, this could significantly speed up the data
09:56 - retrieval process resulting in a far better UX user experience.
10:01 - So this sort of system would require that the data stored in the relevant graph database
10:05 - management system and the relevant relational database management system be synchronized
10:10 - so as to ensure that the data is consistent across the two disparate database management
10:15 - systems.
10:16 - So a system like this, when designed properly, can leverage the benefits of both types of
10:20 - database management systems.
10:22 - For graph-based data structures, a database management system that focuses on the facilitation
10:28 - of relationships between entities or nodes is essential, and a graph database management
10:33 - system provides a way to store data based on the graph data structure, which is ideal
10:37 - for applications that consume data where entities have multiple relationships and complex relationships
10:44 - with one another.
10:45 - Think about social media platforms where you have relationships between users and posts,
10:50 - likes, friendships, etc., and you have millions of people using these platforms.
10:55 - A database management system is needed that appropriately facilitates the storage of data
10:59 - for a large number of different types of relationships.
11:02 - A graph database management system allows for relationships to be stored as data within
11:07 - the graph database.
11:09 - With a relational database management system, the emphasis is on the entities, and generally
11:14 - the relationships between the entities are not stored in the database, but rather general
11:18 - relationships are established at the design level.
11:21 - For example, you can see by the foreign key field value that the employee is a member
11:26 - of the HR department, but there are no details about the relationship itself between the
11:32 - relevant department and employee, saved in the database.
11:37 - This is something you could easily do within a graph database management system.
11:42 - You could create a more detailed relationship.
11:46 - You can easily save data regarding individual relationships between entities or nodes, for
11:51 - example between an employee node and a department node.
11:55 - So here is a whiteboard presentation that shows how the relationships between individual
12:00 - employees and employees and departments could be represented within a graph database.
12:06 - So here we see a node that represents a department.
12:09 - This node is appropriately labeled department.
12:13 - Details related to this department node can be saved to the database as properties and
12:18 - related values.
12:20 - So this department contains a short name property with a value of HR, and a long name property
12:25 - with a value of human resources.
12:28 - Here is our first employee node.
12:30 - This node is appropriately labeled employee.
12:33 - The employee node contains properties and relevant values representing the employee's
12:38 - name and age.
12:40 - Here we see our first relationship.
12:42 - This relationship explicitly shows that the employee whose name is Brad Jenkins is part
12:48 - of the HR department.
12:50 - This relationship is appropriately labeled member of.
12:54 - So you can see that this is a very human readable representation of data.
12:58 - The fact that this employee is a member of the HR department is clear through appropriate
13:04 - labeling and properties.
13:06 - So Brad Jenkins is a member of the HR department.
13:10 - We are able to add properties to the relationships themselves.
13:14 - So the member of relationship has a join date property as well as an employee type property.
13:21 - You can see by this data when this employee joined the department and that this employee
13:27 - has a permanent role and is not for example a contractor.
13:31 - Here we have the second employee node who has the name Jenny Lane.
13:35 - Jenny is also a member of the HR department.
13:39 - We can save relationships between employees within our graph database.
13:43 - So Jenny works with Brad.
13:45 - We can also create another works with relationship in the opposite direction where Brad works
13:51 - with Jenny.
13:53 - So you can see that we have a one department to many employees relationship just like what
13:57 - was shown earlier in the relational database but a graph database is far more flexible
14:02 - in terms of design when establishing relationships between data points or nodes.
14:07 - Not only can the entities contain associated data but the relationships themselves can
14:12 - also contain data i.e. through properties and associated values.
14:18 - So we could create even more complex relationships between nodes.
14:21 - For example a chain of command hierarchical structure related to our employee nodes.
14:28 - So here is an example of this where employee James Stokes reports to another employee Jenny
14:33 - Lane.
14:34 - This is just a simple example and of course this hierarchical data structure could become
14:39 - far more complex.
14:41 - So this presentation was only intended to give you a basic idea of how much more flexible
14:46 - the design of relationships between entities can be within a graph database and how complex
14:51 - relationships between entities can be easily implemented within a graph database.
14:58 - I want to show you a brief demonstration of using Cypher to query a graph database and
15:03 - to do this I'll firstly create a Neo4j database on my local machine.
15:08 - I'll use my Mac platform to demonstrate this.
15:10 - I'll contrast using Cypher and Neo4j with using SQL in the SQL Server database which
15:17 - of course is a relational database management system.
15:20 - Firstly what is Cypher?
15:21 - Cypher can be likened to SQL or Structured Query Language.
15:26 - Cypher is a text-based declarative language used for querying a Neo4j database.
15:31 - What is meant by a declarative language?
15:33 - A declarative language is a high level language that describes what a computation should perform.
15:39 - These languages must follow strict semantic rules, must be structured in a particular
15:43 - way.
15:45 - In order to be valid and for desired results to be returned from the relevant database
15:49 - management system, for example using SQL in order to bring back all employee records from
15:55 - the employee table, you would appropriately execute the following SQL code.
16:00 - This SQL statement simply returns all rows and all columns from the employee table.
16:08 - Using Cypher if you wanted to return all employee data, you would use a query like this.
16:14 - This query would return all employee nodes and relevant relationships.
16:19 - Although when comparing these two query languages, they are of course semantically different,
16:24 - but principally they are the same in that the relevant declarative text-based code is
16:29 - parsed by the appropriate database management system converted into appropriate instructions
16:35 - that are executed under the hood as it were.
16:38 - The relevant results are then returned from the relevant database.
16:41 - I'd like to demonstrate using Cypher within a Neo4j database.
16:45 - I'll contrast executing Cypher against the Neo4j database with executing similar queries
16:51 - against a similar database implemented in a SQL Server database.
16:56 - You don't need to follow along with this part of the course, but of course you can if you
17:00 - want to.
17:01 - So if you want to follow along, you can install Neo4j on your Mac or Windows platforms by
17:06 - following the instructions at this URL.
17:08 - I have already installed Neo4j on my Mac platform.
17:12 - If you want to install a free version of SQL Server, please navigate to this URL.
17:17 - But as discussed, this part of the course is only intended to be an overview and not
17:22 - a detailed explanation, so it's not necessary to follow along with this part of the course.
17:26 - I've created these scripts on GitHub for this part of the demonstration, so I'm going to
17:31 - copy this script from GitHub and run it in Neo4j to generate my Neo4j graph database.
17:38 - So within Neo4j Desktop, let's create a new project.
17:42 - I'm going to call this project Sample Project.
17:46 - Then let's create a new database.
17:50 - I'm going to name my Neo4j Database Company DB.
17:57 - Let's give our database a password.
17:59 - Then let's press the Create button.
18:02 - And now we need to start the database, so let's press the Start button to do this.
18:15 - Then to execute our Cypher queries, let's click this Open button and open the appropriate
18:20 - window from which we can execute our Cypher queries.
18:24 - So the first thing we need to do is copy the code for creating our graph database.
18:29 - So let's navigate to this appropriate GitHub URL.
18:32 - Let's copy this code from GitHub and appropriately paste the code within the window that we can
18:38 - use to run our queries through Neo4j Desktop.
18:45 - Great.
18:50 - And let's click the Play button to create our graph database.
18:53 - Excellent.
18:54 - And we are presented with appropriate status information, telling us that our graph database
18:59 - has been created successfully.
19:03 - I'm going to run this script within SQL Server to generate a similar database, the difference
19:08 - of course being that this database is designed as a relational database.
19:18 - So let's appropriately copy this SQL code from GitHub.
19:22 - Let's launch SQL Server Management Studio.
19:27 - Let's run our SQL code to create our database.
19:30 - I've already created a database named the CompanyDB test.
19:35 - So I'm going to create a new database named the CompanyDB test2.
19:54 - Then I need to change the relevant SQL script to point to the new database that I've just
19:59 - created.
20:00 - So let's press the Play button to run the script and create our database tables and
20:05 - relevant data.
20:09 - Great.
20:30 - So I'm going to run a few queries so that you can get a basic understanding of the differences
20:34 - and similarities regarding Cypher and SQL.
20:38 - So let's run this query against the Neo4j database.
20:48 - Great.
20:55 - This query brings back all the employee nodes and relevant relationships.
21:04 - In order to retrieve all employee data from within the relevant SQL Server database, you
21:09 - could run a SQL query like this.
21:30 - And let's say we wanted to retrieve particular data about a particular employee.
21:34 - So you could run this Cypher query like this.
21:51 - Within the SQL Server database, you could run a SQL query like this.
22:05 - Okay, so now the next query I'd like to run is a little bit more interesting.
22:15 - So in both these two databases, we have expressed a hierarchical relationship between employees.
22:21 - In the Neo4j database, this is implemented through the report to relationship established
22:27 - between employees.
22:29 - In the SQL Server database, the same hierarchical relationship between employees is expressed
22:34 - but through the use of what's known as a self-joining table.
22:38 - So in this case, the employee table joins to itself through the relationship between
22:43 - the report to ID field and the ID field, which stores each employee's ID.
22:51 - So in the employee table, the hierarchical relationship between employees is established
22:56 - through the use of the report to ID field, which stores the employee ID of the relevant
23:01 - employee's immediate boss, if you like.
23:04 - So employee Brad Jenkins is at the bottom of the hierarchy, as it were.
23:08 - So if you wanted to query the SQL database to get the chain of command from Brad Jenkins
23:13 - to the top of the hierarchy, you need to run a query like this.
23:41 - As you can see, this query is really difficult to understand at first glance, and recursion
23:46 - is used to get the desired results.
23:55 - A graph database is far easier to understand in terms of retrieving such tree data structures
24:01 - from the relevance database.
24:03 - So to use cipher code to retrieve the relevant hierarchical data, starting with an employee
24:09 - at the bottom of the hierarchy, Brad Jenkins, you would run cipher code like this against
24:14 - this particular database.
24:20 - Great.
24:23 - Okay, so I hope this part of the course has given you at least a basic understanding of
24:30 - a graph database management system, and how you can benefit from incorporating a graph
24:35 - database management system into your applications.
24:39 - Farhan will now go into more detail, where he'll use a Neo4j graph database management
24:44 - system as the backend storage facility for the server-side part of a real-world web-based
24:50 - application.
24:51 - I will then follow Farhan and create the front-end code for this application using React.
24:56 - Hello everyone, welcome to this course.
25:02 - I am Farhan Hassan Choudhury, one of the instructors, and I will walk you through the entire process
25:08 - of working with a Neo4j database, as well as the development of an API powered by Springboot
25:16 - Framework.
25:17 - Now, at this point of the course, I will show you how you can create a new account for the
25:24 - Neo4j Aura cloud database service, how to create a new database, and run some simple
25:30 - queries.
25:31 - Now, keep in mind that this is not going to be an exhaustive list of all the commands
25:39 - and queries that you can run inside a Neo4j database.
25:43 - What I am going to do is I will show you how you can create a node, how you can create
25:48 - relationships, how you can delete a node, update a node, and some other basic grad operations.
25:55 - In a word, I will teach you whatever is necessary to create the API.
25:59 - Now, to begin with, we will navigate to Neo4j's website.
26:03 - I will leave the link in the description so you can follow along.
26:08 - And once you are here, you will use the Get Started Free button to create a new account.
26:14 - Now start free.
26:16 - And if you wish, you can sign up for a new account using your email address, but what
26:20 - I am going to do is I will just use my Google account to log in.
26:25 - Now, I have successfully logged into Neo4j Aura, and I hope you have done that too.
26:31 - So this is the dashboard that they give us.
26:33 - You can see there are the instances that we are going to create.
26:36 - Now, to create a new instance of a database, just click on the New Instance button, and
26:43 - it will give you a free template.
26:45 - Like if you are a beginner, you can start here, and it will give you some data to start
26:49 - with.
26:50 - What we are going to pick is an empty instance, because I want to show you how you can create
26:56 - new nodes, relationships, labels, and things like that.
27:00 - So we will hit Create, then they will generate a password for us.
27:05 - Now you can copy that password using this button, or even better, you can use this Download
27:11 - button to download all the credentials as a text format.
27:16 - I am not going to do that yet, but I will show you later on how that works out.
27:22 - So once you have copied the credentials, click on Confirm.
27:25 - I have copied or downloaded the above credentials so that they will know that you have the credentials,
27:32 - because you cannot get it once you have gone past this step.
27:37 - Now we will do Continue.
27:42 - Now the creation process of a new instance is a bit long.
27:46 - It can take around a minute or so.
27:49 - So what I am going to do is I am going to pause the recording and come back once the
27:53 - instance has been created.
27:56 - So it looks like that the database has been created.
28:01 - It's running on GCP or Google Cloud Platform, and since I am from Asia, I am from Bangladesh,
28:08 - the region closest to me was Singapore.
28:10 - Now we also have a connection URI.
28:13 - Now to connect to this instance, all you have to do is click on the open button.
28:17 - But before that, just in case you want to rename your instance, you can go here and
28:24 - you can use rename.
28:26 - I am not going to do that though, so I will just open it and they will ask for a password.
28:34 - So I will just paste in my password and the database user will be Neo4j.
28:41 - You don't have to change any of these things, just click connect.
28:46 - Now once you have landed on your workspace, you will see that there are no nodes and relationships
28:51 - whatsoever.
28:52 - But I would like to show you how you can create new nodes, how you can create new relationships
28:57 - between them, how you can update a node.
29:01 - Now the Cypher query language is really expressive and this is really easy to learn if you have
29:08 - experience with some other query languages like SQL.
29:11 - But even if you do not have any experience with that, Cypher is not that hard to learn.
29:16 - The Cypher documentation is an excellent piece of resource.
29:21 - They also have a cheat sheet.
29:24 - Now I will leave a link to this cheat sheet in the description of this video.
29:28 - You can visit these and you can essentially learn about how to read all the nodes in a
29:34 - database using the match clause or how to filter them using where return variables.
29:43 - And under write queries, you can also learn about creating new nodes, labels and relationships.
29:50 - Set for updating them, delete and remove for getting rid of nodes and labels and things
29:55 - like that.
29:56 - So let's suggest that you bookmark this Cypher cheat sheet in your browser so that you can
30:02 - refer back to it whenever you need and also the documentation.
30:06 - Now I will go back to our workspace and I will start creating a bunch of node and I
30:11 - will explain how you can do that as well.
30:14 - So let's switch back to our workspace.
30:16 - And the first thing that we want to do is we want to create a new node.
30:20 - So we will begin with the create clause and a set of parentheses.
30:25 - Then we will put a colon here and we will write the label of the node.
30:31 - So a node is an independent or a single entity inside your database and it has to be labeled
30:38 - something.
30:40 - For example, if we create a node in our database with the name Farhan Hassan Choudhury, it
30:44 - would be hard to say what this node represents.
30:48 - Does it represent a user?
30:50 - Does it represent someone's pet cat?
30:52 - What is it?
30:54 - So we are labeling our node with the label user.
30:58 - And then we will put some properties here.
31:01 - The first thing I want to put is a name for this user.
31:04 - So Farhan name colon Farhan Singh Choudhury, then I will put a comma.
31:17 - The next is a username.
31:19 - This is a unique username and we will use it to uniquely identify every single user.
31:25 - So we will say username is just Farhan.
31:29 - And that's all I am going to put here.
31:31 - Now I will execute the command using the play button.
31:38 - And looks like we have a new label here.
31:41 - And if I click on this, it will return everything under this label to us.
31:46 - Now instead of clicking on this label, we can also use the match class.
31:51 - So we will say match.
31:54 - And we want to match for all the nodes in our database.
31:57 - We will say return all the nodes.
32:01 - Now this is just a variable by the way.
32:03 - If you want to call it nodes, nodes, you can do that as well.
32:09 - Just make sure you are not using any of the reserved keywords.
32:12 - For example, if I remove the S here, you will see it becomes red, which means it's a keyword.
32:18 - Like match and return, we cannot use it.
32:21 - So I will change it back to nodes.
32:23 - I will run the query.
32:25 - And as you can see, we have all our nodes here.
32:28 - Now let's go ahead and create two more users.
32:32 - So I will say create.
32:38 - And this time I want to actually create multiple users with a single create call.
32:43 - So I will keep pressing shift and press enter to come on the next line.
32:49 - I will start a set of parentheses.
32:51 - I will create a new user with the name John.
33:00 - And his username will be just John.
33:06 - Then outside of the last parentheses, I will put a comma and I will again keep pressing
33:13 - shift and press enter to come to the second line.
33:17 - And I will open another set of parentheses.
33:19 - I will create another user and her name will be Jane and username will be just Jane.
33:32 - It has to be string.
33:35 - Now if I end this query with a semicolon at the end, I can just press on this play button.
33:43 - And as you can see, I have successfully created two new nodes and four sets of properties.
33:48 - So if I say match n for nodes and return n, I can get all the nodes in our database.
34:00 - So I have for instance, I have John and I have Jane.
34:03 - Now the thing is all these three nodes are of the user label.
34:09 - So it would be nice to have another label on our system.
34:13 - So let's go ahead and create a bunch of courses.
34:17 - Now to create a course, we will use the same syntax as before and you can use your up arrow
34:25 - to bring back your old queries.
34:28 - And I will just make some changes to this query.
34:31 - I will switch user with course in both cases.
34:37 - I will replace title with C++ course and the username with identifier.
34:49 - This is an unique identifier for the course, which is CPP.
34:54 - And the next course we will have is title JavaScript course and we can call it JS.
35:06 - Finally, we can have another course called C sharp course and its identifier will be
35:27 - C sharp.
35:28 - Whether I have made a mistake here, it should be identifier and not username.
35:34 - So let's look at our query.
35:35 - We are creating three courses with titles C++ course, JavaScript course and C sharp course.
35:40 - They all have a unique identifier, CPP JS and C sharp.
35:45 - So I execute this command.
35:49 - Looks like I have a mistake, which is I did not put a comma at the end.
35:53 - And how did I know that?
35:55 - So it, as you can see Neo4j is actually telling me that there is some problem in the beginning
36:03 - of the course title C sharp line, but I can see that it's totally fine.
36:08 - So it's highly likely that the mistake is actually at the end of the previous line.
36:13 - So that's how I thought that maybe I have missed a comma.
36:17 - So I will run this query again and I have created three new nodes and I will say match
36:24 - n and I will return n.
36:30 - So as you can see, I have all my nodes here.
36:34 - There is Jane, John and Farhan has seen chosen these are the users and C++, JavaScript and
36:40 - C sharp.
36:41 - These are my courses.
36:43 - Now it would be nice if I could create a relationship between Jane and the C++ course, John and
36:50 - JavaScript and Farhan has seen on C sharp course.
36:53 - So I want to essentially enroll them in this course, but before that I would like to show
36:58 - you a few variation of the match clause.
37:03 - So right now when we say match n return n, it actually returns all the nodes in our database.
37:10 - What if I want to only get the course nodes or the user nodes?
37:14 - We can do that by defining a label after this variable like this.
37:21 - So I want all the users return n as users.
37:28 - You can actually do that.
37:29 - If you use as, you can actually rename your variables to make them more user friendly.
37:36 - So I am matching all the node of label user and I returning them as users.
37:44 - I will press play.
37:46 - As you can see, I am now getting only the users and not the courses.
37:51 - Likewise, I can replace n with C or let's just keep it n since that's just a variable.
38:01 - I am picking the course as instead of users, I will say courses.
38:08 - By the way, you can press Ctrl Enter to execute your query without pressing the play button.
38:14 - So right now I am getting only the courses.
38:17 - But what if I only want to get one user?
38:21 - For example, I only want to match for the user with username for HAN.
38:27 - So I can do that.
38:28 - I can say match u for user.
38:33 - So I will put user then I will use the where clause.
38:37 - This is used for filtering or query results.
38:40 - So I will say where u.username is equals for HAN return u as for HAN.
38:54 - So what I am doing essentially here is I am matching for a user type that has the username
39:01 - for HAN.
39:02 - I am putting it inside u and I am returning u as for HAN.
39:07 - Let's run this query.
39:10 - And as you can see, I am getting for HAN since you three back.
39:15 - Now let's add a course to the mix.
39:18 - So after I am saying u colon user, I can put a comma start another set of parentheses.
39:25 - I can say C course.
39:30 - So where u.username equals for HAN and C.identifier is equals CPP return u comma C.
39:44 - So this time I am removing the as keyword.
39:48 - And what I am doing here, I am matching for a user and a course where the username is
39:54 - equals for HAN and course.identifier is equals CPP.
40:00 - Finally I am returning u and C. Let's see if it works.
40:09 - As you can see, we have successfully found the C++ course and the for HAN has into three
40:14 - user.
40:15 - Now we are actually ready to create a relationship between these two nodes.
40:22 - So I will bring back my old query and instead of returning them, I want to say create because
40:31 - I want to create a new relationship and I will first take the user.
40:38 - So here I have the user.
40:41 - Then I will put a dash, then a set of square braces and inside I will say colon enrolled
40:49 - in.
40:50 - This is the type of relationship this user is going to have with the course.
40:58 - So what we are doing, we are matching for a user and a course where the username is
41:02 - for HAN and course identifier is CPP.
41:05 - Then we are creating a relationship.
41:08 - What kind of relationship you say?
41:10 - We are creating an outgoing relationship from the user.
41:14 - And how do I know that, as you can see, there is an arrow going out from the user towards
41:21 - the course.
41:22 - So this is an outgoing relationship from the user.
41:27 - And what is the type of this relationship?
41:29 - The type is actually enrolled in.
41:33 - Now we can actually save this relationship inside a variable called R.
41:40 - And I can say return R.
41:46 - So if I press the play button again, it just looks like I have successfully created a relationship.
41:56 - So the relationship actually starts at node 1 and ends at node 4, which means that the
42:04 - ID of HAN has been showed here is 1 and ID of CPP is 4.
42:10 - If I go to user, you can see for HAN has been showed here has the ID 1.
42:15 - And if I go to course, C++ course has the ID of 4.
42:23 - Okay and the type of relationship is enrolled in, there are no properties whatsoever.
42:28 - There are the element ID, start node element ID and things like that.
42:31 - We do not have to worry about them.
42:34 - So that's how you can create a relationship between these two nodes.
42:40 - So that's how you can create relationships inside of Neo4j.
42:45 - Now let's see how you can update a property of a node.
42:49 - So if I want to update the name of John to John Doe and John to John Doe, I can do that.
42:57 - First we have to find John in our database, so we will send match a variable u of type
43:06 - user where u.username equals John.
43:14 - So now we are matching for a user with the username John.
43:20 - Then we want to use set, this is another clause in Neo4j cipher language.
43:27 - So I will say set u.name equals John Doe.
43:38 - And if I execute this query, looks like it has done its job.
43:45 - So if I go back and instead of setting it, if I return u, John has now become John Doe.
43:56 - We can do the same thing with Jane because why not, they are related.
44:03 - Jane and we can say Jane Doe.
44:08 - Okay, so I want to return Jane, return u.
44:16 - There you have it.
44:17 - So now you have learned how to match nodes in the database.
44:21 - You have learned how to create new relationships, update values of an existing node.
44:27 - Now that's pretty much all you are going to need for the API development process.
44:32 - But I would like to show you one last clause from the cipher query language.
44:37 - And that is the exist clause.
44:41 - For example, if you ever want to check if Farhan has introduced is enrolled in the C++
44:49 - course or not, you can do that using the exist clause.
44:54 - So we will begin with match and what do we want to match?
44:58 - We want to match for an user and we want to match for a course where u.username is equals
45:10 - Farhan and c.identifier is equals cpp.
45:19 - Now we have an user with the username Farhan and we also have a course with the identifier
45:29 - cpp.
45:30 - Next, what we want to do is we want to say return and we will call the exists function.
45:41 - This is a function and that's why we have these two parentheses and inside these parentheses
45:45 - we want to describe a relationship.
45:48 - So the relationship we are looking for or checking for is whether user is enrolled in
46:03 - the course or not.
46:07 - So we will finish our query.
46:08 - What we are doing, we are matching for a user with the username Farhan and we are matching
46:12 - for a course with the identifier cpp.
46:15 - Then we are checking whether a relationship between them of type enrolled in exists or
46:21 - not.
46:22 - So I will press the play button and it says true.
46:27 - Now if I switch cpp for something else like JS, we have the JavaScript course and I hit
46:36 - the play button, you will see I am getting false.
46:42 - Now to be honest that's all you need to know to go through this entire course but Cypher
46:46 - is a really excellent query language and if you have plans to learn a lot more Neo4j than
46:52 - I have showed you in this course, I would suggest that you go through their documentation,
46:57 - you go through their cheat sheet and you practice making your own databases, querying them in
47:04 - a lot of different scenarios and learn as much as you can about this database system.
47:10 - Now I am going to finish this lesson here but in the next lesson you will see me using
47:15 - an initializer Cypher script to create a new database for our API and from there we will
47:23 - begin working on our Java code.
47:26 - In this part of the course, we are finally going to start working on our Spring Boot
47:31 - API but before that we need to set a few things up.
47:36 - First thing first, go back to your Neo4j Aura database dashboard and delete any old instances
47:43 - that you may have created.
47:45 - While working with the API, we want to start with a clean slate so that we can be sure
47:52 - of the fact that some old data will not mess up our API.
47:56 - To delete an old instance, you can use the delete button here and then you will have
48:05 - to write the name of the instance.
48:10 - It's just to make sure that you are in your right senses and you are not sleeping or anything.
48:16 - Click on the Destroy button and wait until the instance is being destroyed.
48:25 - Now to create a new instance, use the New Instance button, choose Empty Instance and
48:35 - click on the Create button.
48:39 - Make sure you download the credentials file because we are going to need it later on and
48:45 - also let them know that you have downloaded the credential file by clicking on this check
48:51 - box.
48:52 - Click on Continue.
48:53 - Now creating a new instance may take a few minutes, so what I am going to do is I am
49:00 - just going to speed up the process in this video so that you don't have to wait around
49:05 - for long.
49:08 - Once the instance has been created, click the Open button, accept their terms and conditions
49:17 - and when they ask for the password, open up the credentials file you just downloaded.
49:25 - Just highlight the password here, copy it and paste it on the empty password field.
49:33 - Click on Connect and we have successfully connected to our new instance.
49:42 - Now as you can see, this instance is completely empty but we will need some data to work on
49:48 - our API.
49:50 - For that, I have already created an initializer script that you can use to initialize the
49:57 - database.
49:58 - For that, go to the code repository on GitHub, I will leave the link on the description below.
50:08 - Then go inside the data folder, you will find a file called initializer.cypher.
50:19 - Open up this file and go to Raw, highlight all the lines and copy with Ctrl C. Then go
50:31 - back to your RRDB dashboard, paste the code that you just copied and then press the play
50:41 - button to execute the code.
50:45 - As you can see, the code has successfully created some nodes, relationships and property
50:52 - keys.
50:53 - Now the first node that I would like to show you is the user node.
50:58 - Now this represents all the users in our database.
51:04 - For example, if we open up John Price, you can see that it has an ID, it has a name John
51:13 - Price, it has an encrypted password hash, it has roles and it has username.
51:21 - Now the significance of each of these properties will become more clear as you start working
51:30 - on the API.
51:31 - For now, just keep in mind that all these properties are important for our application.
51:39 - Next up, we have course.
51:43 - This represents each of the courses that will be available on our system.
51:50 - So if I click on the Blazor Shopping Cart course, you can see that it has an ID of 10.
51:59 - It has a string identifier that we are going to use to uniquely identify this course.
52:06 - It has the name of the teacher and a title.
52:09 - Now you may argue that we can use the ID to uniquely identify this course while that's
52:15 - correct.
52:17 - I prefer using some other unique string or identifier to identify my course or entities.
52:25 - I just do not like to rely on the auto-generated ID fields in any database at all.
52:34 - Finally, we have the lessons.
52:37 - These are the individual lessons that belongs to some course.
52:43 - For example, if we click on the Blazor WebAssembly and WebAPI on.NET 6 lesson, you can see it
52:53 - has an identifier just like the courses.
52:57 - It has a title and it also has an ID.
53:01 - Now this lessons here has a belongs to relationship with the courses, which means each of these
53:09 - lessons belongs to a certain course.
53:13 - For example, if I zoom in on the Blazor course, as you can see, all these four lessons belongs
53:22 - to the Blazor Shopping Cart course.
53:25 - Finally, there is the enrolled in relationship, which is between the individual users and
53:32 - courses.
53:34 - So for example, John W here is enrolled in the Blazor Shopping Cart course.
53:43 - Now that we are done with our database, we can finally start working with our API.
53:49 - For that, you will need JDK pre-installed on your computer.
53:55 - Now you can download the JDK from Oracle's website.
53:58 - I am going to use JDK 17 since that's the latest long-term support release.
54:06 - But you can also go with JDK 20, it's totally up to you.
54:10 - One more thing for those who are watching this course on Linux, it's totally fine to
54:16 - use any of the open JDK builds.
54:19 - For example, I myself am using the Microsoft build of open JDK instead of Oracle's official
54:26 - build, and given the complexity of our API, it's not going to make any change or it will
54:35 - not break anything whatsoever.
54:37 - So feel free to use any open JDK build that you like.
54:42 - You will also need a good IDE to make your programming process more fun.
54:49 - I'm going to use IntelliJ IDEA Ultimate here.
54:52 - I have a student license, so I'm going to use that.
54:57 - But if you want, you can also use the community edition.
55:00 - To be honest, if you look at the feature comparison here, most of the essentials are available
55:06 - under the community edition.
55:08 - We do not need the HTTP client thing since we are going to use a third-party client anyway.
55:15 - We do not need database tools or SQL or any of these things for this project at least.
55:21 - Finally, we need to initialize our project.
55:26 - For that, we are of course going to use the Spring Initializer.
55:31 - Now I will leave the link to Spring Initializer down in the description.
55:35 - So once you have navigated to this page, we will make some choices here and we will generate
55:42 - our project boilerplate.
55:45 - First, make sure that you are picking Maven under project here.
55:51 - You can also use Gradle if you have previous experience with the tool, but I'm just going
55:56 - to pick Maven.
55:58 - The language will remain Java.
56:01 - For the Spring Boot version, I'm going to use 3.1.0 since that's the latest at the time
56:06 - of recording.
56:07 - But if some other version comes out later on while you are watching this course, feel
56:11 - free to use that.
56:13 - Just do not pick any of the snapshots.
56:15 - Pick unstable release.
56:18 - Now under group, you will have to type or you should type some domain in reverse order.
56:25 - For example, my own domain is Farhan.dev, so I will just type in dev.farhan.
56:34 - Then artifact is just the project name.
56:37 - So I'm going to call it Spring Boot Neo4j.
56:44 - You may call it anything that you like.
56:46 - I will also put a sensible description like a simple API powered by Neo4j.
56:58 - Finally, make sure that you are picking the correct Java version from down here.
57:03 - I'm going to pick 17 since that's what I have installed on my computer.
57:07 - But if you have installed 20, make sure that you are switching to 20.
57:12 - For packaging format, we will go with jar since that a lot widely used than wire format.
57:19 - So let's not change that.
57:21 - Now the most important part, adding dependencies.
57:24 - Now this is needless to say that we will need a number of different dependencies for our
57:30 - project.
57:31 - But for starters, I will just pick Spring Web and the dev tools.
57:42 - Now you may think that why not pick the Neo4j dependencies while we are here?
57:48 - Well, I could have picked them, but one thing that I have noticed in the past is that many
57:54 - people face difficulties while they try to add new dependencies to a project that they
58:00 - have already initialized.
58:03 - So I thought why not start the project with just the bare bones, you know, essential dependencies
58:10 - only and then as we go forward, we will keep adding new dependencies to our project.
58:16 - That way it will represent a much more realistic development workflow and it will also teach
58:23 - you how you can search for new dependencies and add them on the flag.
58:28 - So take a good look at all the choices you have made.
58:33 - And once you are happy with them, click on generate.
58:39 - It will download a little zip file to your computer that contains all the project file.
58:47 - So I'm going to just open up the zip file using no Windows Explorer or WinRAR or whatever
58:56 - you like, copy the project folder, go to a place where you usually put your codes in.
59:05 - I usually put them in individual directories.
59:08 - So I'm going to paste it here.
59:12 - And once I have done that, I will just open up my IDE, which is IntelliJ IDEA.
59:21 - I will open up my project, input Neo4j, okay, yes, we trust the project.
59:37 - And once you have opened the project for first time, I would say give it some time to cache
59:44 - all your dependencies, read the source files and things like that so the IDE knows about
59:50 - your project and it can help you along the way.
59:55 - Hello everyone, I'm your instructor Farhan, but I'm from future.
60:00 - Now in the next lessons, you may see a little problem with the video in some cases when
60:06 - I'm trying to create a new class or maybe a new package, you may see that this menu
60:14 - is not showing up.
60:16 - Now this is because my recorder was only recording one window in my computer, so all the sub
60:25 - menus were invisible.
60:28 - So whenever you see me creating a new package, all you have to do is right click on your
60:35 - main package, go to new and then package.
60:39 - Likewise, when I'm creating a new class, you have to pick Java class from here and you
60:45 - can switch between interfaces and classes right from this menu.
60:50 - Another thing that didn't work in my previous recording was the code generation thing.
60:56 - So whenever you are creating a new model, you can use the alt insert key combination,
61:04 - sorry, inside that class of course, let's get rid of the constructor and you can use
61:12 - alt insert and you can then generate a constructor, you can generate getters and setters and equals
61:19 - and hash code, two strings and all those boilerplate methods.
61:23 - So what I did in those videos is I picked constructor and then I just ignored all these
61:32 - properties since you are trying to create an empty constructor and then press OK.
61:38 - So a good chunk of the course, if you see all these sub menus are invisible, just don't
61:44 - be alarmed, it was some problem with my recorder, everything should work as is in your computer.
61:52 - Now back to the past.
61:55 - As you can see, IntelliJ idea has finally finished resolving all the dependencies in
62:00 - my project, so I am finally ready to write some code.
62:04 - Now before we start writing Java code, I'd like to address something really important.
62:09 - I hope that you remember back when we are generating our project, we didn't add all
62:14 - the dependencies to our project because I wanted to show you how you can manually add
62:19 - dependencies later on.
62:22 - So this is the time we do that.
62:24 - First open up your pom.xml and find this dependencies part.
62:30 - Like that, you can see that there are three dependencies already described.
62:36 - You may recognize the Spring Boot starter web and Spring Boot dev tools dependencies
62:42 - from a few moments ago when we added them to our project.
62:47 - But there is also another thing called Spring Boot starter test.
62:51 - Now this is for testing our code and in this course we are not going to talk about that.
62:56 - Now the first dependency that we need to add to our project is called the Spring Boot starter
63:08 - data Neo4j and the group ID will be org.springframework.boot.
63:15 - Now IntelliJ idea is being really generous here and helping us out with writing the dependencies,
63:21 - but I suggest that you make sure that you are typing them out correctly because if you
63:26 - make a typo or write wrong name then you may end up not getting a dependency or even worse
63:33 - getting the wrong dependency.
63:36 - Now the second dependency that we need is called the Neo4j Java driver and the group
63:45 - is org.neo4j.driver.
63:49 - Now whenever you add or remove a dependency from your pom.xml file you have to right click
63:56 - on the pom.xml file, find maven and reload project.
64:04 - Depending on how many dependencies you have added or removed from your project the resolving
64:10 - process may take a while but in my case it has finished in a flash.
64:15 - Now I will close the pom.xml file and start creating the packages that we will need.
64:23 - Now inside our main package def.faham.springboot.neo4j it may be something else in your case but inside
64:31 - our main package we will create four new packages.
64:36 - The first one will be called config then we will create another package called models
64:53 - then we will have the repositories then we will have the services and our controllers.
65:15 - Now these are not the only packages that we are going to need we will also need some packages
65:20 - to hold our query results, our data transfer objects, our requests and things like that
65:27 - but we will work on them later.
65:29 - For now these are the ones that we need.
65:31 - Now once you have all the package ready to go let's create the model for our first node
65:37 - which in this case will be the course.
65:41 - So let's create a new java class and call it course then inside we will define all the
65:52 - necessary properties of this class.
65:55 - So the first one is an id and it has to be of type long then we will have private string
66:06 - identifier which we used uniquely identifier our courses then private string title and
66:19 - private string teacher then we will create a constructor now you may write the constructor
66:31 - by hand but inside IntelliJ you can just press on alt and then insert to bring up this nice
66:40 - generate menu from here you can select constructor and for our constructor we will not select
66:47 - any of the properties.
66:51 - Now for spring data Neo4j this is one of the requirements that you create an empty constructor
66:58 - inside your model classes so this is what we are going to do then we will say alt insert
67:06 - and we will select getters and setters and we will highlight identifier title and teacher
67:14 - we will not highlight id and why you will understand in a bit click OK and now we have
67:22 - all the getters and setters for our private properties.
67:28 - Now creating a class like this will not suffice we will also have to annotate this class with
67:34 - a node annotation this way spring boot will know that this class is actually a Neo4j node
67:43 - and has to be managed by the dependency injection system then inside the class we will also
67:53 - annotate the id with two separate annotations the first one has to be the id annotation
67:59 - to let a spring boot know that this is the id for the node and then we will say generated
68:08 - value which means we want this value to be automatically generated and we do not want
68:14 - to write it by hand.
68:17 - Now since this id is an automatically generated value we do not need a setter for it and since
68:24 - we are not going to use this to uniquely identify our course we are going to use this string
68:30 - identifier instead we can just get rid of the getter as well.
68:36 - So now that we have a course class the next thing to create is a repository so let's go
68:45 - inside the repositories package go to new java class and we will call this course repository
68:57 - and it has to be an interface by the way once you have created the interface it is going
69:03 - to extend the Neo4j repository interface which comes with our dependency and this is a generic
69:13 - and inside we will write the name of the class that we are working with which is course and
69:21 - we will also write the data type of the id of this course so in our case it will be lot.
69:30 - Now this way of creating a new repository is nothing unique to Neo4j actually if you
69:38 - have experience with Spring Boot in the past and you have worked with databases like MongoDB
69:44 - or MySQL you may have created interfaces like this.
69:48 - Now let's close our repository and model and let's go inside our service we will create
69:59 - another java class called course service and we will have to annotate this class with the
70:09 - service annotation and inside this class we will need a reference to our course repository
70:17 - so we will say private final course repository course repository you can name it anything
70:26 - and then we will generate a new constructor where we will take the repository now that's
70:33 - it now since we have annotated this service class with the service annotation and also
70:39 - the repository extends the base Neo4j repository this will be automatically injected into our
70:47 - class.
70:48 - Now inside here we will create another public method we will say public and it is going
70:54 - to return a list of courses get all courses you can name it anything by the way then we
71:04 - will say return course repository dot find all that's it finally we will create a controller
71:13 - by the way if you think that I'm going to fast just be patient once I have created the
71:20 - model repository service and controller for the course I will explain the entire workflow
71:26 - or the architecture of the application what I am planning to do and what you should do
71:30 - in any of your Spring Boot applications.
71:33 - So finally I will create a controller new java class and it will be called course controller
71:43 - now I need to annotate this class with the rest controller annotation so Spring Boot knows
71:50 - that this is actually a rest controller and this is going to describe a few endpoints
71:58 - then I will say request mapping this another annotation and I will describe the general
72:05 - endpoint so I will say slash API slash v1 slash courses excellent now inside this public
72:16 - class I will create a private reference to our service class so I will say private final
72:28 - course service course service then I will generate my constructor and I will create
72:38 - my first method which will be public and it will return our response entity yes response
72:49 - entity of type list course I will explain what it is in a bit just just hold on for
72:59 - a little longer and I will call my method course index you can call it anything this
73:05 - is just going to list out all the courses in our application and then we will say return
73:16 - new response entity and inside here I will call course service dot get all courses then
73:27 - comma HTTP status dot ok and with a semicolon then I will also have to annotate this class
73:38 - with a get mapping call and this let's let's take a final look at our application and make
73:47 - sure that the code is working fine yeah that that looks ok now we have a model that describes
73:59 - the course node in our database and as I have said few times already in our database the
74:07 - courses have an ID which is an auto generated field we have a string identifier a title
74:14 - and teacher then we will need an empty constructor for all our models then we have some getters
74:22 - and setters to work with this model we create a repository interface which in turn extends
74:30 - the Neo4j repository interface now what is this interface actually to see what this contains
74:37 - we can press on the control button and then click on this repository once you are inside
74:43 - the source code you can see it gives us a few useful methods and one of them is find
74:49 - all so whenever I am going to call find all in this repository it will actually return
74:55 - all the courses in our database in a list format as you can see it says list t there
75:02 - is also find all by ID there is also find all with a sort functionality so we can sort
75:09 - the courses so this is what a repository supports there is also a save all method but let's
75:15 - ignore that for now now since we have a repository we can use it inside a service you do not
75:24 - want to use your repositories inside a controller directly because that's not a good thing to
75:30 - do you should always create a service layer that talks to the repositories and use that
75:36 - service inside your controller layer always remember that controllers should be responsible
75:41 - for taking and giving back data they should not worry themselves about the underlying
75:49 - architecture of your database or your models or anything like that so in this case we have
75:56 - a service class that makes a reference to our course repository and we have a single method
76:03 - that gets all the courses for us one thing that I'd like to mention here that you may have seen
76:10 - the auto wired annotation that comes with the spring boot and maybe instead of creating a
76:19 - constructor like this I could have just annotated this field with auto wired but in some cases
76:26 - that's not the best thing to do now since we have our service we will go to our controller
76:32 - that describes a single endpoint which is api slash v1 slash courses inside this method we
76:41 - are just returning a new response entity this is one of the classes that comes with spring boot
76:48 - and you can use it to return a response to the user and this response entity thing takes two
76:56 - things one is body and the other is the status code now for body we are giving it the list of
77:04 - the course since it's a response entity of type list course and for status code maybe we have
77:12 - written 200 by by hand but instead of using some magic number what we are doing here we are using
77:21 - the value of ok inside HTTP status this is actually an enum this enum here actually describes a lot
77:29 - of other status codes as you can see it has continue it has switching protocol processing
77:36 - checkpoint ok created accepted we are going to use created very soon no content and a lot of
77:42 - other things we are going to make use of this enumerator a lot in our application
77:47 - so technically our application is ready to run and give us the list of courses but we have to
77:56 - make one final adjuster and that is we have to let the application know about our database that
78:05 - we have created earlier for that we will need another dependency now the dependency that we
78:15 - need is called spring dot env so we will say dependency and inside artifact id we will write
78:27 - spring dot env and inside group id we will say ne dot all words s c h w a r z ok and we will also
78:48 - describe a version for this dependency subversion 3.0.2 we will save the form dot XML file and use
79:00 - this little button here to load the Maven changes let's click that and wait until the dependencies
79:07 - are being loaded so as you can see it has turned white from red which means the dependencies have
79:14 - been loaded successfully next up we will create a very simple env file inside src main resources
79:28 - and we will just right click on the resources folder new and file we will call it dot env
79:36 - now this env file will contain three values the first one is ora URI the second one is ora
79:50 - user and the third one is ora password now as you may have already guessed the ora URI
79:59 - is a URI to our neo4j server on the cloud the ora user is the name of the user or the username
80:08 - and finally the password is for the password for the database now the ora user is going to be always
80:14 - neo4j and i will just quickly copy that URI and password from my neo4j credentials file
80:26 - okay so i have copied my URI and password from my credentials file and these are going to be
80:32 - different in your case since your instance is different from mine now once you have created
80:38 - this dot env file next up you will need to open the application dot properties file now inside
80:46 - we are going to reference the three env values that we have so i will just say spring dot neo4j
80:58 - dot URI and then a dollar sign curly braces and ora URI
81:10 - next up is spring dot neo4j dot authentication dot username
81:26 - again another dollar sign curly braces and ora user finally we say spring dot neo4j dot
81:38 - authentication dot password it's a dollar sign curly braces or a password now why did we do this
81:49 - why we didn't just put all these values inside our application dot properties class now the thing is
81:57 - these values that URI to your instance the user password and the user name are secret values
82:05 - these are things that you should never put on your github repository since the application
82:11 - dot properties file is a part of your application we will not put our secrets directly into this
82:20 - file instead we are going to create an env file and these three variables will be loaded into
82:28 - our local environment and then the application properties will be able to find them using this
82:36 - dollar sign and curly braces index this is how you actually access any of the environment variable
82:43 - inside your application now i would suggest that you also make a copy of this file
82:50 - and call it dot env dot example then get rid of these values
83:07 - save the example file and make sure that your dot env file is being ignored inside your git ignore
83:17 - file so inside here i will say dot env and i'll say dot env so this will make sure that the dot
83:28 - env file is not added to your github repository instead you will have an example file that you
83:35 - can use a reference to create a new env file okay so since we have our model controller
83:43 - repositories and services in place and we also have our env file created our application should
83:52 - be ready to connect to our database and give us a list of the courses let's test it out now to do
84:00 - so you will have to click on the play button so far it looks like that the application is running
84:15 - fine so what we are going to do is we are going to switch to an http client called insomnia and
84:25 - we will test out our application by sending a request to it now inside insomnia the first
84:31 - thing that you should do is create a new folder because we want to keep our requests organized
84:38 - now i will call it spring boot neo4j
84:44 - and i will move or just just let's get rid of this request now inside this folder
84:56 - i will create a new http request this is going to be a git request of course
85:01 - and this is going to http localhost 8080 slash api slash v1 slash courses i hope that you remember
85:19 - and let's also rename this to
85:21 - git all courses or something like that git all courses it really doesn't matter the difference
85:33 - now let's send a request
85:39 - yeah it looks like we have our list of courses as you can see we had four courses in our database
85:47 - and all of those are being taught by gavin law and the list contains all of them and we also
85:55 - have a 200 okay status code i hope you remember that we had added that little status http status
86:03 - dot okay at the end so that's why you are getting the nice 200 okay responses so congratulations
86:10 - on creating your first api endpoint in this application next up we are going to work on
86:16 - the lessons and we will implement the relationship between the lessons and the courses and we will
86:23 - also make sure that we can see the details of these individual courses along with the list of
86:31 - the lessons so i am back at intelligia idea once again and now we are going to start working on
86:38 - another endpoint for our application so let's go back to controllers now the next endpoint that i
86:45 - want to work on is an endpoint that's going to return the details of a single course so if i go
86:53 - back to insomnia let's make a copy of this request get single course and we will just pick an
87:07 - identifier from all courses request we will put it inside the single request and we want to make
87:17 - something like this now i actually like to start working from the lowest level of our application
87:25 - which in our case are the repositories so i will go back to course repository and inside we are
87:33 - finally going to create a custom method now this custom method will return an optional course
87:43 - and we will call this method find course by identifier and then we'll take a string identifier
87:57 - now the nice thing about these neo4j repositories is the fact that they are really smart
88:08 - so just by the name of this method find course by identifier spring boot will know that we are
88:16 - trying to find a course by using identifier property and we will also need to pass the
88:25 - identifier by string now if i remove this part and i write it again i will say find
88:33 - and as you can see integer idea actually recommends me that find course by so it can
88:41 - sense that maybe we are trying to find a course by some parameter so i'm going to pick find course
88:47 - by and then now it started to suggest me the possible property names and from this list i
88:54 - am going to pick identifier and inside of course we are going to pass the identifier
89:01 - let's say string identifier okay now we have the repository method we will go back to our service
89:12 - which is the one step higher level of a repository and we will say public course
89:25 - and we will call it get course by identifier and we will take the identifier as a string
89:39 - now inside the method we will say return course repository dot find course by identifier
89:51 - identify i hope that you remember that the method actually returns an optional type
89:58 - and we are trying to return a course object from this method so what we are going to do
90:03 - in the second line we will say or else throw so if you do not find this course or if you do not
90:14 - find a course by this identifier throw side there we create a new lambda and we'll say new
90:24 - new response status exception and we'll say HTTP status quote dot value of 404
90:44 - so what we are saying is first use the find course by identifier method inside the course
90:51 - repository and try to find a course by this identifier the identifier that i have passed
90:58 - and in case you do not find a course using this identifier please throw a 404 not found
91:07 - response exception status that's what we are doing let's close this service
91:14 - and inside our controller we will create a new get mapping public
91:26 - spawns entity of type course and we can call it course details
91:35 - it has to be a get mapping and it will give us an identifier so we are we will get the
91:49 - identifier from here and inside course details i will say path variable
91:55 - which means we are going to get a variable from the path and it will be string identifier
92:10 - yeah that's it you can call it anything else if you want
92:14 - now inside the method what we are going to do is we will say return or or let's just create a course
92:22 - course equals or service dot get course by identifier we will pass our identifier right here
92:33 - and then we'll return a new response entity and we are going to say the course is the body
92:43 - and HTTP status dot okay yeah so that's it what we are doing here is we are getting an identifier
92:54 - in our path we are passing that identifier to our service layer that service layer in turn
93:03 - we'll call our repository and get us the course that we are looking for now essentially this
93:09 - should work so let's try out let's rerun our application go back to insomnia and let's
93:21 - execute the get method that we created a bit earlier let's hit send
93:30 - so as you can see it actually returns the course that we are looking for
93:34 - and if we try to look for a course that doesn't exist for example if I add some garbage here
93:46 - as you can see we are getting a 404 status now we are also getting a trace with it we may
93:54 - configure our exceptional responses later on but for now we will just leave it like that
94:00 - so let's get rid of the garbage let's send once again and yes we are getting the course details
94:08 - now the thing is the response in the course detailed request and the course list request
94:15 - is pretty much the same I think it would be nice if we could get the list of the lessons
94:23 - that belongs to this course inside this details response right let's do that let's finally start
94:32 - working on our lessons so I'll come back to intelligent I will create a new model
94:42 - new
94:50 - java class and it's going to be called lesson
94:57 - this is going to be a node just like before it will have a long id
95:06 - it is going to be the id and also a generated value
95:14 - okay so I will have to import the I think there's something wrong with the id
95:21 - yeah id sorry it didn't get imported first yeah next we would say private string title
95:30 - and private string identifier so these are the three properties that we need
95:40 - next up we will generate our empty constructor and our getter sunsetters
95:49 - yes now before we try to implement our relationship between the lesson and courses
96:01 - let's go back to our database and have a look at how it was mapped now if we focus on a single
96:09 - course here as you can see this course has four lessons and each of these lessons has a belongs
96:16 - to relationship with the course now from the point of view of a single lesson it has an outgoing
96:26 - relationship of type belongs to with its parent course and from the point of view of the course
96:34 - it has an incoming relationship of type belongs to with the lesson now with that information we
96:43 - can actually implement these relationships in our models now back in our code we will open the
96:50 - source code for the course model and we will describe a new property private list list of
97:00 - lesson called lessons plus new error list now this list here is going to be a relationship this is
97:13 - another annotation that comes with the dependency that we have used
97:18 - and the type of the relationship is belongs to like we just saw in our database and the direction
97:33 - from the point of view of the course it's an incoming direction
97:38 - or an incoming relationship so the type of the relationship is belongs to and the direction
97:44 - is relationship dot direction dot incoming now we will need a getter
97:54 - we do not need a setter since we are not going to set this relationship manual we just need a getter
98:01 - now since we have implemented the relationship we have implemented the
98:04 - getter it should work let's rerun the application come back to insomnia make the request once again
98:21 - and as you can see now the course comes back with the list of the lessons as you can see
98:29 - this blazer shopping cart course has four lessons now this is all nice and cool but
98:37 - there is a simple problem so if i go back to the get all courses and make a request
98:46 - as you can see all the courses are coming back with the lessons now depending on what you want
98:53 - from your application this may be something that you expect or you do not expect for example
99:01 - in some places in my application i may not want the list of the lessons at all
99:07 - because whenever a course is coming back with the list of lessons it's actually querying for
99:13 - all these lessons so if i do not use the lessons this did that entire query time that that that
99:21 - time my server is working is going to waste unfortunately there is no way that i know of
99:30 - to leave out a relationship from a query so if you describe a relationship like that
99:40 - you cannot actually lazy load it every time you will query for the courses you will also
99:46 - get the relationship back now this is something that's not that hard to solve actually we can
99:56 - write custom cipher queries to query for the lessons when they are needed and leave them out
100:04 - when we don't to do that first let's get rid of the relationships from the model
100:21 - also remove these because we are not going to use them
100:26 - now at this moment in our code base the courses and lessons are totally unrelated to each other
100:33 - but we have to implement some sort of relationships between them
100:39 - now my idea is that we can have them unrelated in our code base but what we can do is we can
100:50 - actually create another repository it will be another interface
100:56 - let's call it lesson repository it extends the Neo4j repository the object will be lesson
101:13 - and the id will be long and inside this repository we will implement another function that is list
101:22 - lesson this is going to be the return type find lessons
101:34 - by course identifier and we get the identifier as a string
101:44 - okay now we have a method that is going to find a bunch of lessons using a course identifier now
101:57 - the course identifier part is not a property of lesson so we cannot have an automatically built
102:07 - method like this instead what we will do is we will write a very simple cipher query
102:18 - so we'll say query then inside let's begin we'll say match and inside a set of parentheses
102:30 - I will say colon course so we are looking for all the nodes of type course
102:41 - inside I will say identifier
102:47 - identifier so we are looking for a course node that has the same identifier as we have passed
102:56 - to this method now once we have found this course we will need to get an incoming relationship
103:07 - R of type belongs to and the related node should be lessons lesson and finally we have to return
103:29 - the lessons let me explain what we are doing first we are trying to find a course node that
103:39 - has the same identifier as the one we have passed to this method then we are looking for all the
103:48 - lessons that are related to this course using an incoming belongs to relationship now once we have
103:57 - found all the lessons we are putting them inside another variable called lessons and finally we
104:04 - are returning the lessons in fact we can we can get rid of this R variable here since that's not
104:11 - being used anywhere so the only piece of variable that we need is this one here once again we are
104:21 - finding a course by the identifier that we have then we are looking for all the lessons that has
104:29 - an incoming relationship with this course of type belongs to then we are putting those lessons
104:35 - inside the lessons variable and returning them to the user so this is the query that we have
104:42 - here now if everything goes fine it should return a list of the lessons okay the repository
104:51 - is all set let's create a service lesson service this is going to be a service class
105:05 - and inside the class we want a private final lesson repository lesson repository
105:19 - we will have our constructor and we will have public first a list of lesson
105:30 - and the name of the method should be get all lessons by course identifier
105:45 - we will get a string identifier
105:50 - and then inside the method we will say lesson repository dot find lessons by course identifier
105:59 - and we will say identifier that's it and we can just return this directly
106:10 - and yeah that's it that that's all we need in the lesson service
106:16 - then inside the controllers as you can see right now we are returning a course
106:24 - now this is all right but what would be better is if we return a dto or a data transfer object
106:35 - so i'll just rename my config package to objects because we are not going to use the config right
106:45 - now refactor and we will create a new class called course dto so this is a plain java class
106:58 - inside i'll say private string identifier because i want the identifier for the course
107:05 - i want private string and title i want the title for the course private string teacher
107:18 - and private list list of lesson called lessons equals new error list excellent
107:37 - oh it looks like we have to import the lesson class yes
107:42 - finally we will have our constructor an empty constructor for that because we are going to
107:54 - insert all these values later on or you know what we can get all this like this
108:06 - constructor identified yes let's let's take these three and leave out the lessons because we are
108:15 - going to fill it up later next we want to create some getters we need getters for everything
108:24 - and we need a setter for the lesson
108:27 - yes so that's that's all we need for the moment now let's go back to the course controller
108:38 - inside this method instead of returning a course i will set course tto
108:45 - and i have the course here then i will create course tto response course another object equals
108:59 - to new course tto first i will need course dot get identifier next i need the title so course
109:09 - dot get title comma finally course dot get teacher yeah those are the three
109:24 - and then i will say response course dot set lessons and now we need to bring in our private
109:35 - final lesson service lesson service here we need to add lesson service lesson service
109:48 - and inside our constructor I will set this dot lesson service equals lesson service
109:59 - yes we we have that initialized this looks fine to me now inside response course dot set lessons
110:13 - I will say lesson service dot get all lessons by course identifier and course dot get identifier
110:21 - so I will get all the lessons inside this course finally in the return statement instead of course
110:28 - I will just set response course now technically if we have written everything correctly
110:35 - this should give us the list of lessons along with the other course details
110:41 - so I'll just restart my application
110:43 - it has been restarted let's go back to insomnia send a request for a single course
110:58 - and as it looks like we are still getting the list of the lessons but if I go back to get all
111:04 - courses as you can see now there are no lessons at all so inside single course I can get the
111:11 - lessons because I want them to be there and inside get all courses I do not need them so I don't have
111:18 - them at all I hope you have understood how you can write a simple custom cipher query inside
111:27 - java and this is going to be really helpful now creating this course dto class and later on we
111:34 - are going to also create query results class these all things may seem like a lot of work to you but
111:43 - to be honest once you have everything set up you have the code ready to go you will see how easy
111:50 - it is to make changes because you are making sure that you are going you are abiding by the
111:58 - separation of concerns and things like that so okay we have done that now one thing that I'd like
112:06 - to say that the way the front end of our application has been created we actually
112:13 - need the list of lessons in the list of courses as well so what I'm going to do is I'm going to
112:22 - make some changes to it this list or the course index method and make sure that we are getting
112:31 - the list of lessons there as well so I will change it to a course dto and yes the return
112:41 - code return statement won't work anymore so I will copy this I'll say list course
112:54 - once courses sorry courses and I'm getting a list of all the courses in our database
113:05 - then what I'm going to do is I'm going to create another list of the course dto type
113:15 - and this will be the response courses equals I will say courses dot string so I'm going to use
113:27 - the stream API of java then I will call map inside map I will say course
113:39 - it's going to be lambda actually
113:45 - and here I will create a new course dto
113:49 - course dto response course equals two I can actually copy this entire line
114:03 - yes that I can also copy this line
114:10 - after this yes response course dot lessons dot service so now I have a new course dto
114:17 - and I need to return this so I'll say return response course and finally dot
114:31 - collect characters dot to list so what I'm doing here I am getting the list of courses
114:39 - from my database without the lessons then I am mapping through that list accessing
114:46 - each course inside that list of courses I am creating a new dto object I am getting all
114:54 - the lessons for that course and setting that inside my dto object and finally I'm returning
115:01 - that response course from inside this lambda function and once I have returned that I am
115:09 - creating a new list and adding that new response course to that list this is how it goes
115:15 - so finally inside response entity I will just replace this part with response courses
115:24 - HTTP status okay let's save our code and let's restart and see if it works fine or not
115:39 - let's go back to insomnia
115:40 - make a request for all the courses
115:50 - and as you can see all the lessons are back in the course class so this far we have finally
116:00 - implemented the courses we have implemented the lessons we have written some custom cipher query
116:06 - so I think you have done a lot of work already to be honest now next up we are going to implement
116:17 - the user model we will introduce an authentication system to this application so that users can
116:23 - log in and once that done we can finally work on the course enrollments so let's continue working
116:32 - on it now that we have finished implementing the courses and lessons it's time to finally
116:40 - work on the user now before we start writing our code for the user related functionalities
116:46 - we will need to add a new dependency so open up your pom.xml file
116:53 - then write after a spring.env add a new dependency now the name of this dependency will be
117:06 - spring boot starter security and its group id will be simply org.spring framework.boot
117:30 - like all the other starter packages in fact let's do one thing let's cut this chunk of code from here
117:39 - and put it right after the starter data new port shared that way we will have all our starter
117:46 - packs inner in a line and then we will have the other dependencies so once you have added
117:52 - this dependency to your project just hit this load maven changes button
118:02 - okay it looks like the dependency has been resolved now let's try to restart our application
118:23 - and you should see something like this using generated security password the generated
118:29 - password is for development use only and things like that so this means that
118:36 - spring security is actually working now to test it out we can go back to insomnia
118:45 - we can send one of our old requests
118:48 - and you will see that it says 401 unauthorized which means that the spring security system
118:59 - is stopping us from accessing this endpoint now this is totally normal by default spring security
119:07 - stops all the requests to the server but you can use an username and password to get access
119:15 - to the data you want now for that let's go back to our IDE look for your application.properties
119:23 - file inside src main and resources now after the three lines that we added before
119:33 - we will have to add two more lines these are spring.security.user.name
119:42 - and I will set it to Farhan spring.security.user.password equals to password
119:54 - now let's go back to insomnia here you can see there is the auth menu right beside body so I
120:04 - will go inside auth I will click on this arrow and pick basic auth now inside here I will add
120:14 - the username Farhan and password is password then I will send the request
120:20 - okay it looks like we forgot to restart our application so let's do that
120:35 - now insomnia send the request
120:41 - and it worked out just fine but I know what you are thinking this is not the right way to authenticate
120:52 - any request we want to use the users in our database right don't worry we are going to do
120:58 - that but before I just wanted to show you how you can make your request go through the spring
121:05 - security gate now let's disable the authentication okay let's go back to our IDE and start working on
121:18 - a proper authentication system first let's remove these two values
121:25 - close the properties stop our application and minimize the terminal now we will start by
121:33 - creating a new model named user now unlike the models that we have worked on before the user
121:45 - is going to implement an interface so we will write implements user details now this interface
121:57 - is actually part of the security package that we just added and it describes a few
122:05 - methods and properties that makes this model usable for our authentication system so we can hover
122:13 - over it and it says implement methods we will click that and it it shows us a bunch of methods
122:22 - we will say okay and now we have a lot of overrides let's just close this sidebar for
122:30 - more space okay so these are the methods that we want to implement so let's start with
122:40 - get password and get username because those are the easiest one we will say private string
122:48 - username private string password then inside get password we will return password and inside
123:04 - username we will return username excellent now those two have been taken care of next we will add
123:13 - the roles so it's a private string roles i hope that you remember from our database view from
123:25 - before that every single users has a bunch of roles so this is what we are going to do here
123:33 - now once you have added the roles we want to implement the get authorities method which is
123:41 - this one now this is sort of an special kind of method that actually returns all the authorities
123:50 - or roles for this user now you may have seen that i had added a role user value to our
124:01 - users in our database but you can have something like role admin role teacher and so on you can
124:09 - also have role admin comma role teacher role moderator and so on but for now we are dealing
124:24 - with a single role now this method here it returns a collection and that extends the granted authority
124:34 - interface so what we need to do is we will say return we need the arrays class from java.util
124:46 - and then we will say dot stream inside the stream method we need our roles so the roles
124:54 - that we have defined here we'll say roles.split and we want to split it by a comma because remember
125:06 - we can have roles like this role admin role teacher so we want to split it using this comma
125:18 - after splitting let's come to the next line and we will say map we will say simple
125:29 - granted authority which is a class and we will add new at the end and dot to list
125:40 - see and we are returning this list so what we are doing here we are getting the value
125:49 - of the roles string from this user we are splitting the string using the commas so just
125:56 - in case you decide to add multiple roles to this user and then we are mapping through that new
126:05 - you know splitted string and creating new simple granted authorities using the string value that
126:13 - we get from our map call finally once we have multiple or a single simple granted authority
126:23 - instance we are adding them to a list and returning that list from this method so since
126:29 - list are part of collections this checks out now if you are confused about this method i
126:39 - would suggest that you do some more study on how spring security works and how you can implement
126:47 - multiple roles for users so that's a bit out of the scope of this course so this is what we have
126:54 - to do now next up let's go inside is account non-expire we want to return true here
127:06 - then is account non-locked yes we want to return true is credentials non-expired true
127:14 - and also is the account enabled yes true so that's it we have successfully implemented the
127:21 - user details interface but other than these three we also need an id and we need a private string
127:37 - name for the user now like the other models this id is going to be an id and it is going
127:44 - to be a generated value and we will need a getter and setter for our name
127:53 - so let's come at the end of all these overrides or maybe
128:02 - maybe here let's come to this place and we'll say alt insert we will generate a getter
128:10 - for our id no i mean our name we will also need a setter for our name
128:26 - there you go now in the case of this user model we will actually use our id field
128:33 - so we will also add a getter for that and since we are going to create new users we will also
128:43 - need setters for our username and password and roles so let's scroll down and come to get password
128:55 - and i will come after it and insert a setter for our password there we have it next after the get
129:06 - username i will insert a setter for our username and finally we do not have a get roles method
129:17 - but we have this one so i will just come after this and i will put a setter for our roles
129:27 - there you go it looks like the model is ready to be used and you know what let's just generate
129:37 - a getter for our roles as well because even though we have this get authorities method
129:43 - we may also need a plain old getter for our roles string so let's just add the getter and it looks
129:54 - like everything has been set up finally i i would just like to check the generate menu once again
130:01 - to see if we have anything left yeah we have left id setter but we are not going to need that
130:08 - so once you are done with that let's just close this and we will now create a new package
130:18 - called config
130:26 - next up let's create a new repository so i will right click on the repositories package
130:33 - creating a java class it has to be an interface and name it user repository
130:41 - like the other repositories i want to extend new 4j repository and that's all we need for now
130:51 - we will come back to this because we will add two more custom queries to this repository but
130:57 - those are not needed at the moment finally we will go inside service and we are going to create an
131:06 - special service for our authentication system so we will create a new class called
131:15 - neo user details service you may call it something else like neo4j user details service the thing is
131:25 - this is going to be an user detail service that we will in turn use with spring security
131:32 - so we have this class and it's going to implement another interface called user details service
131:43 - and just like the model we will implement the methods there is only one method load user by
131:49 - username and that's pretty much it so as you can say from the name of this method these can return
132:00 - a user using its username so for that we will go back to our user repository
132:07 - we will create a method that returns an optional user and we will call it find
132:22 - user sorry i have made a mistake we will have to tell it the name of the model
132:28 - as well as the type of id we are using all right now we can say find user by username
132:40 - we will receive the username as and string this is very simple method and that's all we need
132:48 - now inside our new user details service i will explain why we need this class in a bit but
132:53 - for now just write the class along with me so i will create a private final user repository
133:08 - then i will have a constructor there you go and then as you can see this method here returns
133:18 - the type user details this is one of the interfaces that comes with the spring security framework
133:27 - so instead of returning null what we are going to do is return
133:35 - sorry user repository dot or let's come to the next line find user by username
133:44 - we will pass the username that we have here and then on the third line we will say or else throw
133:55 - and inside the method we will create a new lambda new username not found exception
134:05 - and we will pass a message username not found then can just add the username to the message
134:20 - yeah so that's what we have so as you can see the user details service interface implements
134:26 - a method called load user by username so what we are doing here we are using our repository
134:34 - instance and we are calling the find user by username method now it returns an optional
134:40 - user so if we have the user then we will return it and if we do not have the user then we will
134:48 - throw a new username not found exception and we have to throw this exception because
134:56 - by the definition of this interface this method has to throw a username not found exception
135:02 - in cases where the username is not found so that's all we need here now finally we are
135:10 - going to write the big chunk of authentication code that we will need to use our database
135:16 - instead of some preset user so go inside project i will collapse everything then go inside
135:24 - source main java and as you can see i have a package called config so i will right click
135:33 - and create a new class called security config by the way the service class that we created
135:45 - has to be annotated with the service annotation yeah so all the service classes have been
135:54 - annotated okay so inside the security config class we have to annotate it with configuration
136:03 - then enable web security okay then inside the class we will create a private final
136:21 - new user details service we will have a constructor and then we are going to create
136:33 - a bin and that bin is of type security filter chain new security filter chain
136:48 - it will receive HTTP security this one we will call it HTTP security and this throws
137:04 - an exception okay let's annotate with the bin annotation so that
137:13 - neo4j will handle the task of instantiating this class and everything inside this method
137:22 - we will create a new security filter chain once we have finished working on it you will
137:28 - understand what it actually does so we'll say return HTTP security this one then dot session
137:39 - management inside we will say session create a new lambda session dot session creation policy
137:55 - then session creation policy dot stateless because since we are creating an API the
138:03 - authentication has to be stateless then we are going to disable CSRF protection because
138:12 - we don't need that for that we will use abstract HTTP configurator yes this one
138:24 - and disable okay then on the next line we will say course because we are going to
138:31 - customize our course customizer dot with defaults so course will be configured with the default
138:43 - settings finally we'll say authorize HTTP requests inside we'll say auth and auth dot
138:57 - it will say request matchers yes and inside the request matchers we will say
139:08 - api slash v1 slash auth slash me okay let's leave it to that for now we will add more routes to it
139:20 - later i'll say dot authenticated and dot any request dot permit off finally we will finish
139:37 - this by saying user details service neo user details service dot HTTP basic customizer dot with
139:50 - defaults and dot built ah that's a lot of code right so let us take a look and try to understand
140:03 - what's happening here so by default the spring security framework uses a security filter chain
140:12 - that logs any request to your server you will have to authenticate for every single request
140:19 - to the server and we do not want that also in the default security filter chain it uses your
140:27 - application dot properties file or a randomly generated user as an authenticable user we also
140:35 - do not want that we want to use the users in our database so for that we will need to create a new
140:43 - security filter chain that will essentially define how we want to secure our application
140:50 - so inside this bin i hope you understand what beans are beans are just java classes that are
140:58 - managed by the spring boot framework so we are creating a new bin that is of type security
141:05 - filter chain and it throws an exception okay so inside this bin we are saying return HTTP security
141:13 - which is of type HTTP security this is one of the classes that comes with the spring security
141:22 - framework and the first thing that we are doing is we are making the session stateless i know
141:30 - this is a long line but all this does is it makes the sessions stateless so we do not hold any
141:37 - session data whatsoever then we are disabling the CSRF securities because since it is an API and
141:47 - we essentially do not have any web interfaces within this particular application or service
141:54 - we can successfully disable the CSRF protection then we are configuring cores so in an application
142:02 - where there is no spring boot security framework you have to customize your core settings somewhere
142:09 - else but since we are using spring boot security this framework is going to intercept the request
142:17 - first and then it will pass it to the application or other configures so we have to configure the
142:23 - cores right in the security filter chain configuration thing so right now we are
142:29 - customizing the core settings with the default ones but we are going to change it very soon
142:37 - then we are saying authorize HTTP request so this is the method where we will define
142:43 - which routes has to be protected by our application and which routes do not need to be protected
142:51 - so inside we have an auth object and we are using the request matchers method to say that
143:00 - hey spring boot security you have to protect any request to this particular endpoint we haven't
143:09 - created this endpoint here and you only need to stop any request coming to this endpoint and
143:15 - all the other requesters any requests just permit them to connect so when we get a request
143:25 - in this particular endpoint it needs to be authenticated any other request should be
143:31 - permitted now next up we will actually configure our parse configurations so we will say
143:39 - parse configure or cause configuration source yes this one we want this one
143:51 - and then we will say cause configuration source we will start the method and we will
144:01 - annotate with a bin now inside this bin we will say parse configuration
144:13 - parse configurations equals to new parse configuration so we are creating a new
144:19 - course configuration then we are going to change things in this configuration so we will say
144:26 - course configuration dot set allowed origins so which origins are we allowing so i will just say
144:40 - array let's check what it takes so it looks like
144:46 - it takes a list of the strings so i will say array
144:50 - okay dot as list arrays dot as list and i will create a string HTTP local host 3000
145:08 - and also just in case HTTP
145:12 - 127.0.0.1 which is localhost as well 3000 so i have been made aware by Gavin Long that the
145:24 - react application that he will be working on will run on localhost 3000 or 127.0.0.1 port 3000 so
145:33 - what i have done i have allowed these two origins to connect to my to my application
145:43 - now this is one way of doing things to be honest these two values these should be resided inside
145:49 - our.env file but i am not going to do that since i have shown you how to use a.env file
145:56 - i will just add a todo here which says make sure that the origin list comes from an environment
146:12 - file so i would suggest that the viewers or you essentially take this as a challenge and implement
146:21 - this part using an.env file put your code on github and share the link in the comment section
146:29 - i will take my time to go through every single code shared in the comment section and i will
146:34 - make sure that everything is right so this is one of the challenges i will add that as a todo and
146:40 - you can actually click on this button here todo and you can see what challenges i have set
146:47 - so that's one challenge then the second one is cause configuration dot set
146:57 - allowed methods and what methods are we allowing arrays dot as list this also takes a list so
147:08 - this is how you are going to do get and we will do post we will do patch
147:14 - patch then put delete
147:25 - options
147:29 - and hit these are all allowed methods then we'll say cause configuration dot
147:37 - set allowed credentials yes this one and we'll set true nice then we will say cause configuration
147:48 - dot set allowed headers and arrays dot as list authorization request type content
148:14 - and so these are the three headers that we want to allow
148:21 - finally we'll say configuration dot set exposed headers and it will be called arrays dot as list
148:33 - next inside here we will say x get header and lastly we will have cause configuration dot set
148:47 - max h we will let's say let's do it 3600 l so l for long next let's let's just create an url
149:00 - based course configuration source so we'll say url based course configuration source and url
149:08 - based course configuration source calls to new url based course configuration source here try
149:16 - saying that 10 times faster right url based course configuration source yeah i can do that
149:21 - and we will say URL based course configuration source yes dot register
149:29 - course configuration and we want to apply this configuration to all the
149:36 - routes in our application so that's what this pattern means so this is the root
149:40 - and anything that comes up at that then we'll say comma and course configuration
149:46 - yeah nice finally we have to return our URL based course configuration source
149:55 - okay so now we have our course configured one last thing that we have to
150:01 - configure is actually a password encoder so I believe you remember when I showed
150:07 - you our database architecture that we are saving the password for the users as
150:14 - big script encrypted hashes we are not saving plain text passwords because you
150:20 - should never do that so we will need to let the Spring Boot security to know what
150:25 - encoder we are using but to do that I will say password encoder password
150:34 - encoder this is another bean I will annotate this one with bean and then
150:44 - inside the method I will say return new be ripped password encoder and end it
150:54 - there so yes we have done most of things oh by the way I think I have missed this
151:04 - three lines so what we are saying here is we need to let the security filter
151:09 - chain know which user details service are we going to use and in our case we
151:15 - have a custom user details service which is the new user details service and what
151:20 - we have inside this class we have implemented a single method that helps
151:26 - us to use or look for the user so every time some user tries to log into our
151:31 - application the spring security filter chain will use these details service
151:37 - look for the user and then check the password against the hash that we have
151:44 - saved in our database using this password encoder and if it matches it
151:49 - will let the request pass through and if it doesn't it will throw a username not
151:55 - found exception so finally we are going to use an HTTP basic authentication I
152:01 - know this is pretty insecure but for the scope of this project or this application
152:07 - this is totally fine I could have implemented a more sophisticated JWT
152:13 - based authentication but that will take a lot more time and a lot more code so I
152:19 - want to focus more on the on the Neo4j and spring boot connectivity rather
152:24 - than the authentication and security part of the application so this is what
152:28 - we are going for so now that we have configured our security thing let's let's
152:33 - just go ahead and create this endpoint so we will go to project and we will
152:43 - create a new controller and it will be called user controller let's annotate
152:56 - this one as a REST controller and request mapping to API slash p1 slash auth
153:13 - inside we will have a single method for now which will be public logged in user
153:27 - and we will create an endpoint which will be a get mapping and it will be
153:36 - called me finally inside this logged in user we have to define our return type
153:45 - which will be string for now and we will get something called the principal I will
153:52 - explain what principal is and we will say return principal dot get name so
154:01 - okay let's make sure that this endpoint is right so let's go back to our config
154:06 - API v1 auth me so everything checks out hmm okay then let's start our
154:18 - application and try to log in using one of the users in our database
154:27 - right now we are inside our Neo4j dashboard and we can see all the users
154:34 - in our database so I am going to just select John price and the user name is
154:39 - just price now the password for all these users such as Mirza Mikhail or
154:44 - Mac Milan the password is actually password I have already encoded the
154:50 - password using big script and saved the hash so I will just copy the username of
154:56 - John price price and let's go back to our insomnia then right now if I make a
155:03 - request without any authentication it should work because the single course
155:11 - and get all courses endpoints have not been protected I hope that you remember
155:17 - that the only endpoint that is protected right now is the me endpoint so I create
155:23 - a new HTTP request I will call this me HTTP localhost 8080
155:39 - API slash v1 slash auth slash me and if I send a request as you can see I am
155:49 - getting 401 unauthorized but if I go inside auth select basic auth and as the
155:55 - username I will say price price and for password I will say password let's see
156:04 - if it works or not so as you can see this time we are getting 200 so what's
156:10 - happening here let's go back to our code and let me explain it to you now right
156:16 - now we have a single endpoint called slash API v1 auth me and according to
156:22 - our security configuration this is one of the protected route and we have to be
156:27 - authenticated to hit this route inside this method we are getting a principal
156:32 - object and this principal object usually contains information about what user is
156:41 - authenticated right now so once you send in your username and password our
156:47 - security config will intercept that and pass that to the user details service
156:54 - the user details service in turn will look for an user using the username that
157:01 - we have got from the user and if it finds the username it will give it back
157:06 - otherwise it will throw a username not found exception once the filter chain
157:14 - has found an user it will get the password from that user and check its
157:22 - hash against the password submitted by the user using this password encoder and
157:28 - you may ask how does the filter chain gets the password well if I go back to
157:35 - models user and you will see we have a getter for the password get password and
157:42 - this is a part of the user details interface so that's how it gets the
157:50 - password hash and if the user is giving the right username and password he will
157:58 - pass otherwise he will not pass so that's how this entire authentication
158:03 - system works and if you have done anything right you should be able to
158:08 - authenticate new users to your application now that we have our user we
158:15 - can finally begin working on the enrollment part so if user can actually
158:22 - look at our courses and enroll in the ones that they like so that's what we
158:28 - are going to do now now that our users can log into our system we want to
158:35 - create a way for them to register in our system so we have a way to log in now we
158:41 - need a way to register so before we start writing the code for registering
158:47 - the user I would like to create a few packages and classes now the first one
158:55 - is a package called requests and inside here I will create a new Java class
159:04 - called create user request now I will explain what it will do but just follow
159:12 - along for now then inside this class we will say private string name private
159:24 - string user name private string password private string roads so everything that
159:37 - the user model has except the ID field next up we will create a constructor and
159:44 - this time we will pick all of them and after that I will just create some
159:50 - getters and setters okay the request class is ready let's close that next what
160:00 - we need is a user DTO object so user DTO and this one is going to be really
160:10 - simple private string name private string user name private string roads we
160:25 - do not want to return the password in our responses so we will just leave that
160:30 - out next we want to create the constructor and the getters and setters there
160:41 - you go we have a user DTO now next we need to create a service called user
160:52 - service user service and this one has to be annotated as a new service for sure
161:04 - then we will need a private user repository user repository let's let's
161:11 - make it final and then we will have private final password encoder password
161:22 - encoder because we want to encode our users password then I will have my
161:28 - constructor and a function public and this is going to return a user create
161:40 - user and this will take a create user request not any request but create user
161:50 - request and create a new user so I will say user user equals to new user then I
162:01 - will say user dot set name request dot get name and I hope you remember that we
162:11 - just implemented this get name method inside the create user class so that's
162:16 - why we can use that then user dot set username request dot get username nice
162:26 - user dot set roles request dot get roles user dot set password and this is
162:38 - where the encoder will come in and I will say password encoder dot encode
162:45 - inside there I will say request dot get password so this will take what the
162:51 - password is that we got from the user and then encode it and set it as the
162:57 - user's password finally we would say user repository dot save user the safe
163:06 - method comes with all the repositories and we will return the user that's it we
163:12 - have our service method ready to go let's go to the controller now and here
163:21 - I will say public and then response entity of type user DTO
163:35 - sign up and this will take request body and map that to create user request we'll
163:52 - call it request let's go inside the method and I will say oh I will also
164:01 - need a reference to our private final user service user service and I need my
164:11 - constructor then I can say user service dot create user and I can just pass the
164:20 - request to it and it returns a user then I will create a user DTO response user
164:32 - equals to new user DTO now first I need the name so user dot get name then user
164:42 - dot get user name and user dot get roles that's all I need then I can just
164:50 - return a new response entity and the body will be the response user and the
164:58 - status will be created because we have just created a new user so yeah that's
165:05 - all we need to sign up a new user and this is really easy to do I will have to
165:12 - create a post mapping or register yeah that's all we need now we can go back to
165:25 - insomnia and check if this works so I'll just start my application then I will
165:35 - switch to insomnia and I will create a new request vault register
165:49 - okay this will have a body first we need a name so I will do for home
166:01 - a scene children comma I need an username
166:12 - for home then I need a password
166:18 - and I will need a role string so it will be the whole user make sure you are
166:31 - writing the role like this and then I send the request to HTTP local host API
166:41 - slash v1 slash auth slash register that's it I believe
166:52 - okay let's change it to post and we do not need any authentication for this and
167:01 - let's hit send so looks like a new user has been registered it says 201 and the
167:13 - username is Farhan now there are two ways to verify if the registration has
167:17 - gone through correctly or not first I can go to my me request I can go to
167:24 - basic and instead of price I can say Farhan and the password is password I
167:29 - will say send and it looks like it gives me back Farhan which means the user has
167:36 - been registered to database but still if we quickly switch to our database
167:41 - dashboard then click on user once again
167:48 - it got me back all the users and as you can see Farhan has in show 3 is right
167:54 - here but right now Farhan or me I am NOT enrolled in any of the courses so next
168:01 - we are going to work with the enrollment process and we are make we are going to
168:05 - make sure that all the users can actually enroll in a class but before
168:10 - that I would like to give another challenge for you so if I go back to the
168:15 - user service as you can see right now I am NOT checking if this username has
168:22 - been already registered or not so I will leave it to you so that you can figure
168:29 - out how to check if a thing exists on the database using spring boot data or
168:36 - spring data repositories and make a decision on that so I will add another
168:42 - to do and I will say make sure that these username does assist and let's
168:55 - just come back from here and I put that over the username so this is another to
169:01 - do that I am leaving out for you I will look forward to any submission in in the
169:06 - comment section and I will actually let you know if anything is wrong with the
169:10 - code so let's close that and start working on our enrollment process now
169:19 - before I write anything in my services or in my controllers I would like to
169:24 - make sure that we have all the necessary queries in our repositories for example
169:31 - in order to enroll user in a new course we will have to create a new
169:38 - relationship between the user and the course so like I showed you before you
169:44 - can actually do that through the models but in this case I am going to create a
169:50 - custom query that will have a custom query result and you can use that to
169:56 - create a new enrollment relationship so for that I will go to my repositories
170:05 - and then user repositories and I will write two methods here the first one is
170:12 - going to be a boolean and it will be called find enrollment status so you can
170:23 - use this method to check whether a user is already enrolled in a course or not
170:30 - and I will take a string username and I will also take a string identifier which
170:40 - is the course identifier in our case so we are going to write a custom query
170:45 - just like we did before and it will go something like match user user or this
170:56 - has to be a string of course comma there'll be a course course and then
171:05 - fire user dot username equals dollar sign username so this variable right
171:14 - here and user sorry course dot identifier equals dollar sign identifier
171:25 - right here this variable so what we are doing is we are querying for a user that
171:32 - has the same user name as we have passed to this method and then we are looking
171:38 - for a course that has the same identifier as we have passed in this
171:41 - method and we are saving the user in a variable called user and the course in a
171:46 - variable called course next we want to give a space and then enter so that we
171:52 - can begin on the next line and then we'll say return exists
172:00 - we will say user
172:06 - and rolled in
172:17 - yeah that's pretty much it so what we are doing is we are looking for a user
172:22 - and course against the username and identifier that we have and then we are
172:28 - checking if there is any outgoing relationship from the user with the
172:34 - course of type enrolled in so I believe you remember that back when we are
172:40 - designing our database we had a relationship called enrolled in and it
172:46 - was an outgoing relationship from the point of view of the user and an
172:50 - incoming relationship from the point of view of the course so there we go we can
172:55 - use this use this method to check whether a user is already enrolled in a
173:00 - course next up we want to create a query that we can use to create a new
173:05 - enrollment now before we do that we need another class so we will create a new
173:14 - package query results and inside that we will create a new class called course
173:30 - enrollment query request or query result sorry query result now this is a very
173:40 - simple class we will say private user user private course course and we need
173:51 - to import these classes obviously yes
173:59 - okay we have both the classes then we will have an empty constructor like
174:13 - that and we will have some getters and setters so alt insert and getter and
174:19 - setter both of these so there you go we have a course enrollment query result
174:25 - object now if I come back and I create a new method and this is going to return a
174:36 - course enrollment query result I would call it create enrollment relationship
174:47 - basically you want to be explicit with your names and I will need a username
174:54 - also I will need an identifier now the first bit of this query is identical to
175:03 - this one so what I am going to do is I will copy this entire match part come
175:11 - inside this method I will say query put it in space and then enter now on the
175:21 - next line I would like to say create user in fact you can just copy this this part
175:30 - here so we are going to we are going to create a new outgoing relationship from
175:40 - the user to the course of type enrolled in then finally we'd like to return the
175:46 - user and the course now as you can see this query returns a really complex data
175:54 - it returns an user object and it also returns a course object so like other
175:59 - custom queries like this one we cannot just say that these returns a boolean
176:04 - type instead we had to create our own custom class that has an user object and
176:12 - a course object and use that as the result of this query so this is how you
176:18 - can map complex queries to custom meant classes okay so our user repository is
176:25 - now ready to go I believe we can enroll our users to classes now but we cannot
176:35 - just put the code for course enrollment inside the user service or user
176:42 - controller or the course controller at all instead what we are going to do is
176:47 - we will create a new service called course enrollment service and it will be
176:59 - a class a service class then inside there we will have a few methods now the
177:09 - first method that we have but before that we will need a private final course
177:19 - repository course repository and private final user repository user repository now
177:29 - this service can access both repositories because we are going to
177:33 - work with both courses and enrollment but if we had to put this code inside
177:39 - the core service then we would need to unnecessarily refer to the user
177:43 - repository inside the course core service that doesn't feel good at all
177:49 - that's why we have a separate service for you know creating the enrollments
177:54 - so inside we will have a constructor
177:59 - and we will have a few methods now the first method would be public boolean get
178:12 - enrollment status and for that we will need a username and a course identifier
178:26 - then inside the method we will just say return course repository dot check sorry
178:39 - user repository dot find enrollment status and we will pass it the user name
178:48 - and the course identifier so this way we can use this method to check if a
178:54 - given username is enrolled in a course or not now the next thing we need is
179:02 - public and this is going to return a course enrollment query result and it
179:11 - will be called enroll in and it will also need a username and a course
179:20 - identifier okay we will return user repository dot create enrollment
179:34 - relationship username and identify okay so yeah we are done with these two
179:42 - methods we will need one last method that is we need public list of courses
179:52 - and we will call it get all enrolled course by user name a string username
180:06 - and a string identifier okay so what this method is going to do is if we
180:14 - give it a username it will give us back the list of courses that user is enrolled
180:22 - in and I just realized we really do not need the identifier now we do not have
180:27 - a repository method for this so let's go to our course repository and create a new
180:35 - method this will return a list of courses and we will call it find all
180:43 - enrolled courses by username and we receive a string username and then we
180:58 - can say query match we are trying to match a user
181:09 - where the username is username so this is another way of doing a query or
181:18 - query clause so we will have a user with the same username that has been passed
181:23 - to this method then once we have that node we want to get enrolled in
181:39 - courses course so we want to get all the courses that has an outgoing relationship
181:47 - with this user of type enrolled in and I'm saving all those courses in the
181:53 - forces variable and I will just return forces and we will also import the list
182:02 - method java.util of course and yet that's it so let's go back here and we
182:08 - will say return course repository dot find all enrolled course by username and
182:18 - we'll just pass the username so that's it we have our course enrollment
182:22 - service ready to go we can use it to enroll our users in a new course we can
182:29 - get the enrollment status of a user and we can also get all the enrolled courses
182:35 - by username and I just realized it should be courses and not just course so
182:43 - there you go okay now I think we are ready to create a new controller the
182:55 - controller will be named course enrollment controller like the other ones
183:03 - it's going to be a rest controller for sure okay let's just go back to our
183:08 - service class for a bit course enrollment service and yeah we have
183:11 - annotated it yeah and we will do a request mapping API slash v1 slash
183:21 - enrollment now this enrollments endpoint these need to be protected because if
183:30 - you go back to our service for example course enrollment service you can see
183:35 - all these methods needs to know that username of the currently authenticated
183:41 - user so for that we need to protect this route so we will leave the controller
183:48 - open and get back to config and security config let's let's close this and come
183:56 - to the request matchers part I will put a comma and I will say API slash v1 slash
184:11 - enrollments slash double star which means anything that comes after API
184:19 - slash v1 slash enrollment slash anything should be authenticated or protected
184:27 - let's close that and inside our controller class we will need a few
184:36 - services so I will say private final course enrollment service course
184:49 - enrollment service and we will also need private final lesson service lesson
185:02 - service because we will need to know what lessons are part of a certain course
185:07 - now I will have my constructor and we can start working on the endpoints now
185:17 - the first one I want to do is I want to let the user enroll in a course so for
185:24 - that I will say public response entity of type course enrollment DTO and we
185:39 - need to create this class create class course enrollment DTO and we want to put
185:45 - it inside the objects package and here we have our DTO
186:00 - we need string
186:05 - private string user name so the user name of the user that has just enrolled
186:13 - in the course private is string name of the user private course and the course
186:21 - that the user just enrolled in then we will have a constructor and we will have
186:31 - the getters and setters yeah that's pretty much it so you want to return a
186:39 - course enrollment DTO and we will call our method enroll in now what we are
186:49 - going to take we are going to take the request body request body and we will
186:57 - create another request called course enrollment request let's hover over it
187:06 - and create type parameter course enrollment request you know what let's
187:14 - just copy the name go to project go to requests create a new class or course
187:25 - enrollment request and inside this we need
187:37 - private string identifier this is the course identifier of course and we will
187:48 - generate a constructor and the getters and setters okay let's go back to our
187:59 - code request body course enrollment request so we will have our course
188:05 - enrollment request comma another thing that we need is the principal sorry I
188:12 - forgot to name this so I will get principal principal because this is how
188:17 - you get the username of the authenticated user now inside this
188:22 - method we will say course enrollment query result let's call it enrollment
188:33 - query result yes equals we will say course enrollment service dot enroll in
188:42 - what is the user name the principal dot get name and what is the identifier
188:48 - request dot get identifier terrible we have a new enrollment request query
188:54 - right query result now we cannot just return this query result for a button or
189:01 - verbatim rather we will need a new DTO called course enrollment DTO now I will
189:13 - over operate some more action okay let's again just copy this photo project go
189:25 - inside objects how it looks like we have a course enrollment DTO create I just
189:30 - forgot about this so what I will do is course enrollment DTO we have that yeah
189:40 - I just forgot that we created this so response enrollment equals new the first
189:52 - thing that we need to pass is the username so we will say enrollment query
189:56 - result dot get user dot get username because our query result has a get user
190:07 - method that in turn returns a get username method and we can use that to
190:13 - get the name of the user or the username of the user next up we have the name of
190:20 - the user so enrollment query result dot get user once again dot get name and you
190:28 - know what this line is getting too big so I will just put it in the next line
190:32 - comma let's bring down here yeah much better enrollment query request dot get
190:42 - course that's pretty much it or we need the username name and the course finally
190:51 - we can say return new response entity the body will be the response enrollment
191:03 - and the HTTP status should be okay but it really depends upon you since we have
191:10 - created a new relationship you could have also returned created here but I'm
191:15 - going to just return okay now this is going to be a post mapping let's try and
191:22 - enroll our user in a course okay let's check our request once again we just
191:28 - need an identifier so that's what we are going to do I will go back to my
191:36 - insomnia client I will create a new request called
191:45 - enroll this is going to be HTTP localhost 8080 slash API slash v1 slash
191:59 - enrollments and inside this has to be a post request by the way and inside the
192:12 - body we need an identifier so let's go inside get single course this one go
192:30 - back to enroll and we'll put it here let's click on send
192:38 - yeah I just remembered I didn't restart my code so let's go back to IDEA and do
192:45 - that
192:56 - and I will send
192:59 - nice we are getting a 401 unauthorized response because we are not
193:04 - authenticating any user so I will go to basic auth I add Farhan and password is
193:10 - password let's send the request so it looks like that we should leave the
193:18 - course enrollment request as an empty constructor instead of taking the
193:24 - identifier as one of its parameters because if we do that the request may
193:30 - or not work so I am keeping it empty and now when I try to create an enrollment
193:38 - from insomnia it just works as you can see Farhan has been enrolled in Blazor
193:45 - shopping cart application course so to verify we can quickly go to our RDD
193:51 - dashboard and if we click on enrolled in we should see that Farhan has seen
193:58 - cho3 is now enrolled in the Blazor shopping cart course now other than
194:05 - verifying from the database itself we also want a way to get the list of all
194:12 - the courses a user has been enrolled in so we have already created a service
194:18 - method for that so let's just go back to our controller and implement that so
194:25 - here inside our controller we will create a new gate mapping method so
194:31 - public response entity this is going to be a list of the course DTO and we will
194:43 - call it enrollments we will take the principal because we need the username
194:49 - and inside this method we will say list course so courses equals course
195:02 - enrollment service dot get all enrolled course by username and we will say
195:08 - principal dot get name now we have a list of courses that the user has been
195:14 - enrolled in on the next line we will say just like before a list of course DTO
195:26 - and response courses equals courses dot stream dot map inside the map method we
195:43 - will say course this is a lambda course sorry course DTO response course
195:57 - equals new course DTO and we need an identifier title and teacher name so I
196:06 - will say course dot get identifier course dot get title and course dot get
196:15 - teacher and then I can just return response course and finally after this
196:30 - curly brace and the last parentheses I will say collect collectors dot to list
196:37 - so this is just like we did before with the courses list so I'm not going to
196:42 - again explain this and I will say return new response entity response courses
196:51 - comma HTTP status dot okay all right we this is a get mapping of course there
197:03 - you go let's restart our application
197:08 - go back to insomnia make a copy of the enroll request and call it in roll
197:21 - meant turn it into a get request get rid of the identifier make sure that we are
197:29 - authenticating and let's hit send okay so looks like we have a list of the
197:39 - courses that this user has been enrolled in what we need is we need the list of
197:45 - lessons too so let's go back to our controller I'm going to steal some code
197:53 - from the course controller class I hope you remember inside this one we actually
198:02 - made use of the lesson service so I'll copy this line I will go back to course
198:10 - enrollment controller
198:13 - and put it down here
198:21 - course enrollment dot set lesson and then return the response course we will
198:28 - rerun the application
198:31 - we will go back to insomnia resend our request and this time we are actually
198:44 - getting the list of all the lessons as well now that's pretty much it we have
198:51 - done a lot with our applications except I want to implement one last thing in
198:57 - in our code so I you may remember that we have implemented the code necessary
199:04 - for a service and repository method that returns a boolean based on whether an
199:12 - user is enrolled in a course or not so in our list of courses I would like to
199:19 - add a new boolean variable here that says enrolled in and that will return
199:26 - true if the user is enrolled in a course and false in case he or she is not
199:32 - enrolled in a course so let's go back to our code what we can do is we will go
199:40 - back to our course DTO and inside we want to add a new boolean so private boolean
199:57 - let's use a primitive type and is in rolled that's it now we will need a
200:09 - getter and setter for this one
200:19 - yes we got that now let's go back to course enrollment controller and we will
200:29 - say response course dot set enrolled and we are going to hard code it to true
200:37 - since the user just enrolled in this course we know for sure that this is
200:42 - going to be true so we will not make another database request and just write
200:47 - it as true but inside our course controller
200:55 - we will actually have to do a database call for that we will take the
201:05 - principal and we will add a check here we will say if principal is not null
201:20 - then response course dot set enrolled inside we will say we need another
201:34 - service private final course enrollment service course enrollment service and
201:45 - we'll say course enrollment service yes that's a lot of boilerplate to be honest
201:56 - course enrollment service yeah so inside set enrolled we will say course
202:02 - enrollment service dot get enrollment status and principal dot get name and
202:14 - course dot get identifier so we are checking whether the user has enrolled
202:22 - in the course or not now why we are checking for principal is null or not I
202:27 - hope you remember that in our course index anyone can see the list of our
202:32 - courses because it's an open directory so in case we do not get any principal
202:40 - or authenticated user we will just set it to false a set enrolled and if we get
202:45 - a principal we will set it to whatever the database returns so I will rerun
202:50 - the application and show you how it works
202:56 - let's quickly switch to insomnia and get all courses
203:04 - but as you can see it says enrolled false in all of these because I am NOT
203:11 - logged in but if I log into my account for Han password and hit send
203:24 - you will see that it says true on the blazer shopping cart application and
203:29 - falls in all of the other ones now why we are here I thought I will make one
203:35 - little adjustment to our code that is in enroll we are sending something called
203:42 - an identifier now this is not clear I think what would be better if we could
203:48 - call it course identity fire this is a lot better I think so I will go back to
203:55 - my code go inside the course enrollment request right click on the identifier
204:02 - and go inside refactor rename so instead of identifier I would like to call it
204:12 - course identifier I'll hit enter yeah these are all the references and get
204:21 - course identifier course and yes we are going to let's make sure that these are
204:29 - right
204:36 - yeah let's see it okay let's rerun our application and see everything works
204:44 - fine or not okay it looks fine so that's pretty much it we have successfully
204:52 - implemented the ability to enroll in a new course the user can get the list of
204:57 - enrollments the user can register the user can sign in and see the lessons in
205:04 - the course now on the next part of this course Gavin long will walk you through
205:11 - the entire process of creating and react app based on this API he will show how
205:17 - you can use the identifiers to get the corresponding YouTube videos and how you
205:23 - can basically create a course management system front-end for yourself powered by
205:29 - my API now one last challenge that I would like to leave for the user is
205:37 - inside the services and course enrollment service before we enroll our
205:44 - user in a course we need to make sure that the user has not been enrolled in
205:57 - the course already so this is something that we have to make sure right now if
206:04 - you try to enroll the same user twice in a course you will create two
206:09 - relationships to the same course so it will get you will get double results so
206:15 - what you should do is you should check whether the user has already been
206:19 - enrolled in the course using the game enrollment status maybe I don't know I'm
206:24 - giving a hint and then you should enroll the user in the course or return
206:31 - something else now this is another challenge that I'm leaving up to you so
206:36 - if you go inside to do you will get three to-dos and one is in the config
206:43 - and two is in the services so make sure that you are completing your challenges
206:48 - it will give you a lot more confidence to be honest and you will learn a lot
206:55 - from your researchers make sure that you leave the link to your repository in the
207:01 - comment section below I will come there I will check the core submissions and I
207:06 - think it would be a nice conversation between us so I hope that throughout
207:12 - this entire course or this part of the course you have learned something about
207:15 - the Neo4j database which truly is an amazing technology you have learned how
207:22 - to create an API powered by Neo4j on Spring Boot and a few other things here
207:29 - and there on how to structure your application how to use an IDE and things
207:33 - like that so if you ever need any help just give me a shout out in the comment
207:39 - section I would love to help and best of luck for the rest of the course Gavin
207:43 - Lon is an amazing instructor and I can say for sure that you will have a great
207:48 - time so until the next time take care and be careful bye before we get
207:56 - started with coding this react application I need to let you know that
208:01 - I've had to make a few assumptions regarding the knowledge and experience
208:04 - of the viewers of this part of the course so ideally the viewer of this
208:09 - part of the course should have at least a basic knowledge of react JavaScript
208:13 - HTML and CSS so let's start with the very basics we of course need a code
208:20 - editor for writing our react code I will be using Visual Studio code for
208:25 - Windows for this purpose you can download Visual Studio code for Windows
208:29 - from this URL in order to run our code locally we need to install node.js
208:37 - you can install node.js from this URL node.js is an open source cross-platform
208:43 - JavaScript runtime environment
208:47 - we need a local working directory to house our applications code
209:01 - so please create a working folder in a location of your choosing on your
209:05 - computer and let's give our working folder a sensible name my working folder
209:10 - for this project is curriculum mngt management client so curriculum mngt client
209:17 - then let's open the working directory for our project within Visual Studio
209:21 - code note we can check what version of node we have installed while we're in
209:27 - Visual Studio code we can do this by first launching the terminal window
209:31 - launch the terminal window by pressing control and the tilde character then at
209:37 - the command prompt type node-v and press enter great and we can see what version
209:44 - of node we have installed on our computers an easy way to set up a react
209:50 - project is to use the create-react-app command we can use this command to
209:57 - generate the infrastructure for our react application when I say
210:01 - infrastructure I mean the node modules that are necessary for harnessing
210:05 - foundational react functionality is generated through the use of the
210:09 - create react app command there are other ways perhaps better ways of creating the
210:14 - foundations for a react project like for example using a technology named VIT for
210:20 - this purpose if you are interested please read more about VIT at this
210:24 - location using the create react app command provides a simple way to create
210:30 - a react project so I'm going to use the create react app command for this
210:34 - purpose at the command prompt type npx create react app followed by a sensible
210:41 - name for your react application I'm going to name my react application
210:45 - curriculum dash mngt mngt of course stands for management then let's press
210:52 - the enter key this process may take a while so this will give you an
210:55 - opportunity to contemplate life the universe okay you don't have to do that
210:59 - but you may want to get yourself a cup of tea or something like that while you
211:03 - wait
211:27 - okay great and you can see that the foundation for our react project has been
211:33 - generated the node modules directory has been created which contains all the
211:39 - react dependencies and packages needed to build and run a react project as you
211:45 - can see a new route directory for our project has been generated that is of
211:49 - the name that we gave our application when we ran the create react app command
211:53 - so for better clarity let's open another instance of visual studio code where the
211:59 - newly created project directory is the root directory within visual studio code
212:03 - to do this let's make sure the terminal window is launched remember you can do
212:07 - this by pressing the control key and the tilde key then at the command prompt
212:13 - make sure the current projects working directory is the current directory at
212:18 - the command prompt then type CD space and then the root directory of the react
212:24 - project then press the enter key now at the command prompt type code followed by
212:32 - space and then the period character then press the enter key this will result in
212:37 - a new instance of visual studio code being presented and now the react
212:42 - project folder is the root directory
212:46 - now let's close the previously launched instance of visual studio code the
212:51 - create react app command has generated the infrastructure for our react project
212:56 - but has also generated a few files that we don't need so let's delete the
213:01 - following files that we don't need report web vitals.js set up tests.js and
213:07 - app.test.js
213:11 - we must also delete the ESLint config setting from the package.json file
213:23 - here
213:29 - let's save our changes then lastly let's open the index.js file and delete the
213:35 - code regarding report web vitals great
213:45 - so we are now ready to develop our react application so at the moment we have very
213:50 - basic functionality that has been generated for us by default through the
213:54 - use of the create react app command so let's ensure that we start off on a good
214:00 - footing as it were this lets us know that all is working as it should be
214:05 - before we start developing our application so to launch the react app
214:10 - in our default browsers we can type npm space start at the command prompt and
214:15 - press the enter key
214:20 - great and we can see the react logo spinning which means we are good to go
214:26 - so let's start creating the code for our application within the SRC directory
214:31 - where the source code will reside let's create a subdirectory named components
214:36 - as you have probably guessed we are going to create our react components
214:41 - within the components directory let's also create a directory within the SRC
214:45 - directory named images
214:57 - please download this image from this location on github and ensure that this
215:03 - image file resides within the images directory we are going to use this image
215:08 - as our hero image on our home page so this image will be referenced from
215:12 - within the home component the first react component we are going to create is
215:16 - the home component this component denotes the page that will first be
215:21 - displayed when our application is first launched so let's create a directory
215:26 - within the components folder named home the first letter of this folder name
215:30 - should be in lowercase within the home folder let's create a file named home.js
215:37 - the first letter of this file should be an uppercase so we can use a shortcut to
215:46 - generate boilerplate code for our home component to do this type rafce like
215:52 - this within the code editor and press the enter key note that in order to
215:56 - utilize the rafce shortcut you must first install the appropriate react
216:02 - snippets extension if this extension is currently not installed this installation
216:07 - can easily be done through the extensions tab within visual studio code
216:16 - at the top of the home.js file let's import the hero image from within the
216:21 - images directory like this let's include an image tag within the JSX code
216:26 - returned from the home component
216:30 - then let's open the app.js file let's import the home component into the app
216:37 - component with this line of code
216:50 - let's delete the code that we don't need but ensure that we leave the div root
216:55 - element that contains the class name attribute that references the app.css
216:59 - class then let's appropriately reference the home element by including the home
217:06 - tag within the div parent tag like this
217:11 - let's type npm start to fire up our application
217:20 - great but the image looks huge and is not displayed appropriately for our hero
217:26 - image so we are going to use bootstrap to style this hero image so to install
217:31 - bootstrap type this command at your command prompt and press enter
217:44 - to have access throughout our application to relevant bootstrap classes
217:48 - we must include this import statement within the index.js file
218:06 - now within the root div tag of the home component let's include the class name
218:11 - attribute and set it to the bootstrap class named container like this let's
218:16 - run our code
218:29 - what's happening here is the image is still too large for its container
218:33 - element so to remedy this let's create a scoped CSS style sheet for the home
218:40 - component so let's create a file within the home directory named home.css
218:46 - within the home.css file let's create a reference to the relevant image within
218:52 - the container div tag like this and let's set the image width to 100% within
218:58 - the home component let's create a reference to the home.css file with
219:02 - this line of code
219:05 - let's type NPM start at the terminal prompt to launch our application
219:17 - and that is much better great
219:22 - so that is a great start but we are also going to need some other third-party
219:27 - packages dependencies in order to integrate certain functionality into our
219:31 - application for example we want to install the react root to DOM package
219:36 - that will be instrumental in the global management of our menu and link
219:40 - functionality our navigation functionality we are going to use the
219:44 - react player component for displaying videos that denote lessons for our
219:49 - courses to our users we'll use Axios to manage our client interactions with a
219:55 - server-side web API component so here we have used bootstraps container class to
220:00 - house our hero image so that it is appropriately displayed within our home
220:04 - component as a hero image we can also leverage bootstrap by using components
220:09 - that reside within the react bootstrap package we will look at using such
220:14 - components a bit later in this video for now let's install react bootstrap to
220:21 - install react bootstrap type NPM space I space react dash bootstrap and press the
220:27 - enter key
220:38 - great let's install the Axios library we are going to use Axios for making our
220:44 - HTTP client requests to the relevant server-side endpoints so as to return
220:50 - the relevant data from the Neo4j database that hosts the relevant
220:55 - curriculum data that we want to display to our users we'll also use Axios to
221:01 - implement the enroll functionality ie this is functionality whereby a user can
221:06 - enroll in a particular course we could use the windows.fetch function which is
221:12 - available by default within our browsers for this purpose instead of Axios but
221:16 - Axios provides us with key advantages please navigate to this URL if you'd
221:21 - like to learn more about these key advantages this link is available below
221:25 - in the description of this video to install Axios type NPM space install
221:31 - space Axios and then press the enter key the next packages I would like to
221:36 - install allow us to leverage font awesome from within our react
221:40 - applications so at the command prompt please type NPM space I space at
221:45 - Fort Awesome forward slash react dash font awesome and then press the enter key
221:58 - let's install one more font awesome related package to do this type NPM
222:04 - space I space at Fort Awesome forward slash free dash solid dash SVG dash
222:09 - icons and then press the enter key great we'll look at the details of using the
222:19 - relevant font dash awesome functionality a little bit later in this video the
222:24 - next component I want to install is react player this will allow us to play
222:30 - YouTube videos from within our react application the individual lessons
222:34 - within the courses in which our user is enrolled will be presented to the user
222:38 - as videos these videos reside on the YouTube platform so to install react
222:45 - player type NPM space I space react dash player at the command prompt and then
222:50 - press the enter key
222:57 - then let's install react router Dom which allows us to leverage rich
223:02 - navigation and routing functionality from within our react application to
223:07 - install react router Dom at your command prompt please type NPM space I space
223:14 - react dash router Dom and then press the enter key
223:27 - if we open the package dot JSON file you can see the relevant dependencies that
223:33 - we have just installed great so let's create the navigation bar that will
223:38 - appear at the top of our applications UI so this can be referred to as the header
223:43 - for our application the navigation bar will contain a register and login button
223:50 - and relevant navigation menu options so let's create a folder within the
223:55 - components directory named header
223:59 - please ensure that the H in header used to name our folder is in lowercase let's
224:08 - create the file for the header component and let's name it header dot JS where
224:13 - the H is an uppercase so we are going to use font awesome in this component to
224:20 - display a graduation cap as the logo for our application which will appear in the
224:25 - top left hand corner of the user's screen so let's write code to import the
224:31 - relevant font awesome components
224:38 - then we are going to use react bootstrap for our buttons so let's import the
224:42 - button component from the react bootstrap package with this line of code
224:49 - we are going to use the container component for layout purposes let's
224:57 - import the nav component from react bootstrap which will be used for layout
225:02 - and styling purposes let's also import the navbar component for the purpose of
225:07 - styling our navigation display lastly let's import the use navigate hook and
225:12 - the nav link component from the react rootadom package so that we can leverage
225:18 - the relevant react rootadom functionality for navigation purposes
225:21 - let's change this div tag to be a navbar tag within the navbar element let's
225:28 - include a container element let's include the fluid keyword within the
225:33 - container element this will ensure that the navigation bar spans the entire
225:38 - width of the web page rather than placed centrally within the web page let's
225:43 - reference the navbar dot brand react bootstrap element and set its class name
225:48 - property to the menu dash link bootstrap class like this then let's include the
225:54 - graduation cap font awesome icon like this as a child element of the navbar
226:00 - dot brand element this icon serves as our applications logo let's include the
226:05 - navbar dot toggle element here which will allow the navigation to be shown
226:09 - and hidden through a toggle mechanism made available to the user on smaller
226:14 - screen sizes so as you can see bootstrap is great for responsive layouts so let's
226:21 - include the nav element and let's style the nav element appropriately
226:26 - let's include the button component to represent our login button the variant
226:44 - property is set to info as a style choice let's set the class name property
226:50 - to a bootstrap class named me-2 this is so that our buttons are spaced
226:55 - appropriately let's include the register button which will appear to the right of
227:00 - the login button on our navigation bar and let's style the register button in
227:05 - the same way that we have styled the login button right let's open the app
227:11 - dot JS file and firstly make sure that we are importing the header component
227:16 - into the app component then let's include the header element reference
227:22 - just above the home tag within the JSX code that will be returned from the app
227:28 - component let's use npm start to launch the application so that we can view what
227:34 - our navigation bar currently looks like great okay because our navigation bar is
227:40 - currently white our brand icon is also white so we can't currently see our
227:47 - graduation cap brand so let's change the color to red for now
228:01 - great okay so I want to make the background for our application as black
228:08 - and address styling features that I'd like to apply to all of our components
228:14 - one way we can do this is to include the relevant styling code within the app dot
228:19 - CSS file which is referenced by the app component the app component is the
228:24 - parent component for all our bespoke child components so the styles included
228:29 - within the app dot CSS file will propagate to all the app components
228:33 - child components so let's firstly import the quicksand font from Google through
228:39 - this line of code we want the quicksand font to be applied for our entire web
228:44 - application
228:51 - let's use the star like this to indicate the following CSS properties apply to the
228:57 - root tag for our single page application so let's first set the border dash
229:03 - sizing property to border box if you set the box dash sizing property to border
229:10 - box on elements like this the padding and border values are included in the
229:15 - width and height properties for the relevant elements let's set the font dash
229:20 - family property to quicksand
229:24 - right let's create the styling for the app element let's set the app root
229:30 - elements background color to black let's set the color for our text to white
229:35 - let's set the top margin for the app element to 10 pixels
229:42 - let's launch the app
229:45 - you
229:53 - great
229:56 - you
230:12 - okay so let's create the component that will house the registration functionality
230:17 - this component will contain a form that the user can fill out to register the
230:22 - user's relevant details with the system including the user's name username and
230:28 - password the fields on the form will be name username password and confirm
230:33 - password
230:37 - we'll incorporate regular expressions into this dialogue for the purpose of
230:41 - validating each of these fields each of these fields will be validated in real
230:47 - time ie as the user enters the relevant information into the relevant text box
230:52 - controls so let's start by creating a folder named register within the
230:58 - components folder
231:00 - let's add a file named register.js within the register folder
231:19 - and let's also create a file named register CSS
231:25 - let's go to the register component
231:33 - let's import the use state hook and the use ref hook into our component so the
231:38 - use state hook is used to track the state of relevant variables when the
231:42 - state for a particular variable changes reacts detects this and re-renders the
231:48 - relevant component in the user's browser this use ref hook will be used to
231:54 - reference a text box form control let's import relevant react bootstrap
232:00 - components
232:03 - you
232:15 - let's import relevant font awesome components
232:20 - let's use rafce to generate the boilerplate code for our register
232:35 - component let's declare a constant named name ref which will be used to reference
232:41 - the name text box control let's use the use state hook to monitor a variable
232:53 - named name the set name function will be used to change the state of the name
232:59 - variable the name variable will be bound as it were to the relevant text box
233:04 - control where the user will enter the user's name let's include a boolean
233:10 - variable for the purpose of monitoring the valid or invalid state of the text
233:14 - value entered into the name control by the user let's create two variables that
233:19 - are used for the same functionality as the previous two variables that we have
233:25 - created but are applied to the username text box control so when the username
233:30 - is deemed as valid the valid username variable is set to true conversely when
233:35 - the username variables value is deemed as invalid the valid username value is
233:40 - set to false let's do the same for the password or pwd field ie create two
233:47 - appropriate variables where their state is tracked
233:59 - let's do the same regarding the confirm password field which is used to validate
234:04 - if the confirm password field matches the password field
234:13 - so I've already prepared the regular expressions for the relevant fields off
234:17 - screen please feel free to copy the relevant regular expressions from this
234:22 - location on github
234:27 - so let's set a constant to the regular expression that will be used for
234:31 - validating the name field please remember if you get stuck or you wish to
234:36 - copy and paste the code rather than following along with creating the code
234:40 - line by line with me you are able to copy the relevant code from a github
234:44 - repository available at this location so this regular expression will ensure that
234:49 - the name field has at least two characters and no numbers are included
234:54 - so let's include the regular expression for the username field the validation
234:59 - criterion for this regular expression means that the username must be between
235:04 - 8 to 20 characters long no underscore or period characters are
235:09 - included at the beginning no double underscore or underscore period
235:14 - characters or period underscore characters or dot dot characters are
235:20 - included within the field and no underscore or dot characters appear at
235:25 - the end of the word
235:31 - so this regular expression is used for the password field this regular
235:35 - expression means that in order for the password field to be deemed as valid a
235:38 - minimum of eight characters must be included the password must include at
235:43 - least one letter one number and one special character so let's apply the use
235:50 - effect hook so that a function that we'll write that is passed as an
235:55 - argument to the use effect hook is fired when the register component first loads
235:59 - so the use effect hook accepts two arguments the first argument is the
236:04 - function to be fired and the second argument determines when the function is
236:08 - fired so we want the function passed in as the first argument to be fired when
236:13 - the register component is first loaded so we can achieve this by passing in
236:17 - empty square brackets as an argument to the second parameter of the use effect
236:21 - hook so we want the name control to receive focus when the register
236:27 - component first loads we can achieve this with this line of code we'll write
236:31 - the code to create the relevant form controls including the name control in
236:35 - just a bit and this will of course be implemented within the JSX section of
236:41 - this component let's use the use effect hook to monitor the state of the name
236:46 - variable which will be changed with every key press that the user makes
236:50 - within the name text box which as I've said will be created soon so to do this
236:57 - we pass a function as the first arguments to the use effect hook that we
237:03 - want fired when the state of the name variable changes then in order to tell
237:07 - react as it were that we only want the relevant function to fire when the name
237:12 - variable state changes we can pass the name variable within square brackets as
237:17 - the second arguments to the use effect hook
237:29 - note that the test method is executed on the relevant regular expression to
237:33 - ascertain whether or not the name entered by the user is valid or not the
237:38 - result returned from this line of code will either be true or false
237:44 - we can then set the state of the valid name boolean variable to the result
237:49 - returned from the test function we'll create UI functionality to show that the
237:56 - name field is valid or invalid in just a bit so we are providing the user with
238:00 - real-time validation feedback as the user types the user's name into the name
238:04 - field then let's apply another use effect hook to perform similar
238:09 - functionality for the user name
238:21 - let's apply another use effect hook to check that the password is valid or
238:26 - invalid based on the relevant regular expression
238:39 - then we must also check whether the password field matches the confirm
238:43 - password field note that within the array passed in as an arguments to the
238:49 - second parameter of the use effect hook is the variable representing the
238:54 - password field and the variable representing the confirm password field
238:59 - so this means that each time the password or confirm password fields
239:04 - change the relevant validation functionality is executed we'll wire up
239:10 - the relevant variables to their counterpart text box form controls in
239:14 - just a bit you'll see that the on change event of the relevant form controls is
239:18 - used for this purpose right so let's create the JSX code within the relevant
239:23 - section of the register component let's create a container component
239:32 - let's create an appropriate heading
239:39 - let's create a main element and a div element within the main element please
239:44 - include the relevant class name attributes and values within the
239:48 - relevant elements let's include the react bootstrap form element so each text box
239:56 - control will reside within a form dot group element which will also include a
240:01 - label control so let's create the relevant code for the name text box control
240:31 - the form dot label element contains a span element here we have a ternary
240:36 - operator that shows all hides either a font awesome times icon or a tick icon
240:42 - based on whether the valid name variable is true or false so this span element
240:47 - will be shown to the user based on whether the span elements class name
240:52 - property references the CSS class named valid or the CSS class named hide we'll
240:58 - create these CSS classes in just a bit so if the valid name value is true the
241:04 - FA check icon is displayed next to the name text box control conversely if the
241:11 - valid name variable is set to false this span element is displayed to the user
241:15 - which means the FA times or a cross icon is displayed to the user indicating that
241:21 - what the user has entered into the name field is currently invalid then let's
241:25 - create the text box control for the name field like this
241:36 - note that we are setting the ref property to the name ref const this
241:40 - allows us to reference the text box within the relevant use effect hook
241:44 - where we have created code so that the name text box is given focus when the
241:49 - register component first loads then the on change event is wired up to an arrow
241:54 - function that sets the tracked name variable every time the user changes the
242:00 - text entered within the name text box let's create the form control code for
242:06 - the username field which contains similar functionality
242:28 - let's create the form control code for the password field
242:58 - and the confirm password field
243:22 - let's create the code for a submit button so we want to disable this submit
243:28 - button while any of the relevant form fields are not valid so let's set the
243:32 - relevant disabled property to this boolean expression
243:39 - so before we test the validation code for our register form let's set up the
243:43 - roots for our application so that we can navigate to the register component
243:48 - through the navigation bar that has been created within our header component so
243:53 - let's open the app.js file let's import the roots component and the root
243:58 - component from within the React router DOM package let's include the roots
244:02 - element below the header element we want the header element to appear regardless
244:06 - of where the user navigates to within our application so we need the header
244:11 - appropriately displayed outside the roots element
244:16 - within the roots element let's include the relevant roots where we can tell
244:20 - React router DOM as it were about the paths of our components
244:50 - we haven't yet created the layout component so let's do that now the
245:03 - layout component provides instructions to react as it were regarding the
245:07 - overall layout of the relevant components that are mapped to relevant
245:11 - roots
245:31 - let's import the layout component
245:35 - we also need to create a root for the app component and we must do this within
245:45 - the index.js file
245:53 - we need to wrap this route within the browser router component as well as the
245:59 - roots component like this
246:16 - let's go back to the header component and create code so that when the register
246:21 - button is clicked that the register component is appropriately loaded let's
246:27 - create a const named navigate that is assigned a function returned from the
246:31 - use navigate hook let's create a reusable function named handle nav
246:37 - let's use the navigate function to navigate the user to a path passed in to
246:42 - the handle nav function let's pass in the relevant path to the register
246:48 - components to the handle nav function so when the register button is clicked the
246:52 - register component is loaded
247:03 - let's test the code
247:21 - okay so to fix this issue we need to correct a typo here where we have
247:26 - incorrectly named the regular expression const pertaining to the username field
247:31 - great but in order for our validation to work as expected we need to create the
247:36 - relevant CSS classes let's make sure that we import the register.css file into
247:43 - the register component let's open the register.css file and create the code
247:48 - for the relevant CSS classes let's create the CSS code for the register
247:53 - dash container class which will make sure the layout for the register dialog is
247:58 - appropriate we are using the flexgrid functionality to appropriately handle
248:04 - the layout let's include the register dash layout class to handle the layout
248:09 - for the register form
248:25 - let's include the valid class so that the elements referencing this class are
248:29 - appropriately displayed
248:34 - let's include the hide class so the elements referencing this class are
248:39 - appropriately hidden
248:48 - let's include a class named invalid dash icon to display the times or cross
248:54 - font awesome icon in red let's include a class named valid dash icon to display
249:00 - the checked icon or tick font awesome icon in green let's include a class
249:05 - named register dash message which will style a displayed message to the user
249:11 - that is centrally aligned and in white text the appropriate text will display
249:16 - once a user has successfully registered
249:22 - let's test the UI validation functionality for the name field
249:28 - let's test the UI validation functionality for the user name field
249:35 - okay so we have an issue the name field is also being affected this should not
249:42 - be happening let's look at the code
249:49 - okay so within this user fact hook lies the problem we are currently using
249:54 - the set valid name function here whereas we should of course be using the set
249:59 - valid user name function here so let's fix this
250:24 - great let's test the password field and the confirm password field validation
250:29 - functionality oops and of course the password control should be of type
250:34 - password and not text
250:38 - we must of course also make the same fix for the confirm password control
251:08 - excellent so let's go back to the register CSS file and make sure our
251:18 - register form is responsive on smaller screen sizes so let's use an
251:23 - appropriate media query for this purpose
251:27 - excellent so now we want to interface with the Neo4j database hosted in the
251:39 - cloud so we are going to download the code for the HTTP based web API
251:45 - component written in Java to our local machine so we are going to host the web
251:49 - API component on our local machines just to make the development of our
251:53 - application a bit easier this web API component is hosted using spring boot in
251:59 - order to be able to run this code locally on a Windows computer you must
252:04 - ensure that you have the Java JDK installed on your local machine if you
252:09 - don't yet have the Java JDK installed please navigate to this URL then follow
252:14 - the instructions for installing the Java JDK Java JDK version 20 or version 17
252:21 - should be fine the next step is to clone the GitHub repository at this URL onto
252:27 - your local machine this GitHub repository contains the Java code for the relevant
252:32 - web API so we are hosting the server-side code on our local machines
252:37 - we are connecting to a Neo4j database hosted in the cloud from our local
252:42 - machines please remember the local directory that contains the cloned GitHub
252:48 - repository code we need to run a command at the command line later on to run the
252:53 - relevant web API component as stated before this will be run locally
252:59 - please ensure that you have configured the web API component correctly to point
253:04 - to the Neo4j database that you have created if you are unsure of how to do
253:09 - this please follow the relevant instructions provided in the previous
253:12 - part of this course the values I'm showing you here will of course not
253:17 - apply to your particular environment
253:21 - for now let's create the client-side react code to connect to the locally
253:26 - hosted web API component so let's create a folder within the SRC folder named API
253:32 - within the API folder let's create a file named axios-config.js
253:50 - let's first write code for importing axios let's create the code to set up
253:56 - the axios-client component
254:02 - so let's add the base URL property and set it to localhost port 8080 which is
254:09 - where we will be able to connect to the relevant web API endpoints this web API
254:15 - component of course handles calls to the relevant Neo4j database that is hosted
254:21 - in the cloud let's create appropriate code for the headers property
254:43 - now let's go to the register component and import the axios-client component
255:00 - let's create a JavaScript function named post data we must include the E dot
255:06 - prevent default line of code for when submitting a form from within a react
255:11 - component because we'll be using the on submit event for the submission of the
255:16 - register form then let's create an object that encapsulates the data entered
255:20 - by the user I'm going to hard code the roles value here which is okay for demo
255:25 - purposes but you'd want to handle this field more appropriately for a
255:28 - production environment for example you could have a list of roles presented to
255:32 - the user in a list box control and the user can select the relevant role from
255:37 - the list box control right so we can write code for post requests using the
255:42 - axios-client component like this so we are simply posting the object we have
255:47 - just created to an appropriate endpoint created for handling the register post
255:52 - request we can include basic error handling code through the use of try
256:00 - catch code and we can output an appropriate message to the user
256:04 - regarding whether the user has been registered successfully or not let's
256:09 - include code at the bottom of the form to display this registration status
256:12 - information let's first set the submit success message appropriately based on
256:20 - the response returned from the server side code and at the bottom of the
256:24 - register form let's write the code to display the relevant message saved
256:29 - within the submit success variable
256:59 - so let's set the min height property of the app parent component so that it
257:27 - extends to the bottom of the web page and we can do this by setting the min
257:32 - height property here so that its minimum height is 100 VH so the result of this
257:39 - is that the background color will be black regardless of which component is
257:43 - loaded because the relevant components are all child components of the app
257:47 - parent component and of course we must wire up the on submit event to an
257:55 - appropriate event handler so we are wiring up the on submit event to the
258:01 - post data method within the form element like this okay so to run the web API
258:07 - component on your computer you can run this command at your command prompt so
258:14 - launch the command prompt as administrator change the current
258:18 - directory to the root directory of where you cloned the relevant Java code
258:22 - locally just a reminder the relevance Java code can be found at this location
258:32 - on github so once you have done that type this command at your command prompt
258:39 - and press enter after you press the enter key you should see similar
258:44 - information to the information displayed on my screen logged to your screen
258:54 - let's run the react code and see if we can register a user
259:07 - oops we have a bug here
259:11 - we are referencing a control named PWD with the object that we are attempting
259:17 - to post
259:21 - the PWD field doesn't exist because we named the relevant field password so
259:26 - let's fix this
259:32 - we have successfully registered a user so we are now successfully communicating
259:37 - from the react client code with the Java server-side code which for development
259:42 - purposes we are currently hosting on our local machines so we have successfully
259:47 - registered a user the next logical step is to create the login functionality
259:53 - let's create a folder named login and let's ensure that the first character
259:58 - is lowercase within the login folder let's create a file named login.js and
260:03 - let's ensure that the first character of the file name is an uppercase let's
260:08 - create the file within the login folder named login.css
260:17 - right let's write the code for the login component let's reference the
260:21 - login.css file let's import the relevant dependencies
260:27 - let's import the use state, use effect and use ref hooks from react let's
260:34 - import the container component from the react bootstrap package
260:42 - let's import the button component from the react bootstrap package
260:48 - let's import the form component from the react bootstrap package
261:01 - let's appropriately import the axios client component
261:11 - let's import the use navigate hook the link component and the use location hook
261:16 - from react root to DOM
261:21 - let's create the boilerplate code for our component by appropriately typing
261:25 - rafce and pressing the enter key
261:29 - great let's create a const named navigate and assign it a value returned
261:37 - from the use navigate hook
261:41 - we will be able to use the function assigned to the navigate const in code
261:45 - for navigation purposes
261:50 - let's assign a value returned from the use ref hook to the user ref const
261:56 - this will allow us to reference a specific form control within a function
262:01 - we'll look at this functionality in just a bit in order to track the state of the
262:06 - username let's use the use state hook for this purpose so user is a variable
262:12 - we want tracked by react and we must use the set user function to change the
262:18 - state of the user variable let's use the use state hook to track the state of the
262:23 - entered password
262:26 - let's use the use effect hook so that a function executes when the login
262:45 - component first loads the code for this function simply sets the username field
262:50 - to have the focus and this happens when the login component is first loaded
262:55 - let's create the UI code for our login component within the JSX section of our
263:00 - component so let's first reference the react bootstrap container component so
263:06 - that our login form is housed as it were within an element that references the
263:11 - container bootstrap style let's create a heading for our login form
263:18 - for styling purposes let's create a main element and within that a div
263:27 - element within these elements our references to appropriate CSS classes
263:33 - we will create the code for these CSS classes in just a bit so like with the
263:38 - registration dialog we create a form element and within the form element the
263:42 - relevant form controls within form dot group elements these components are
263:48 - imported from the react bootstrap package and we are using them for layout
263:53 - and styling purposes so each of the form groups contain a label and a text box so
264:01 - we have the username field and the password field within the login form
264:05 - note how we are using the on change event to change the state of relevant
264:11 - variables as the user changes the text within the relevant text box controls
264:33 - let's reference the button component and this button will serve as the login
264:37 - forms submit button please remember if you get lost at any point while
264:44 - following along the full code is available at this location on github the
264:50 - link to this github repository is available in the description of this
264:53 - video
264:55 - let's create an arrow function to handle the submit functionality
265:09 - so let's use this code to reference the values that the user has entered into
265:14 - the username field and the password field
265:30 - let's implement basic exception handling through the use of try catch
265:34 - functionality basic authentication has been implemented in the web API
265:38 - component please navigate to this URL if you'd like to learn more about basic
265:44 - authentication so in terms of basic authentication we must encode the
265:50 - username and password values in a particular format before we submit a
265:55 - particular HTTP request to the server-side code in order to implement
266:00 - basic authentication on the client we are going to pass the username and
266:04 - password in a particular format through the header of a HTTP GET request for
266:10 - this particular login component the relevant format for the username and
266:14 - password is username colon password
266:20 - this is essential for basic authentication we must also encode the
266:25 - username colon password value in base 64 encoding we can use JavaScript's BTOA
266:32 - function for this purpose so let's create a const named B64 encode and
266:39 - assign it the value of username colon password that is base 64 encoded using
266:47 - the BTOA JavaScript function the next step is to create an object representing
266:54 - the header information that will be passed to the relevant web API endpoint
266:59 - so let's create a const named config and set it to an object to represent
267:05 - appropriate HTTP header information this object contains a property named headers
267:11 - which is set to an object with a property named authorization the
267:17 - authorization property is set to the text value basic followed by a space
267:22 - followed by the base 64 encoded username colon password text value note we are
267:30 - wrapping the value assigned to the authorization property in backtick
267:34 - characters so that we can interpolate the relevant text value this means we can
267:40 - include a variable within the backtick characters by wrapping the variable
267:45 - within curly brackets and preceding the curly brackets with the dollar symbol
267:51 - let's create a request to the relevant endpoint using axios note we are
267:57 - passing in the username and password through a HTTP GET request made to the
268:02 - relevant endpoint through the config object the config object contains the
268:08 - authentication details for the user which is appropriately added to the
268:12 - header of the relevant HTTP GET request
268:23 - so before we test the login functionality let's make sure that an
268:28 - appropriate route is set up for the login component so let's open the app
268:34 - dot JS file and include the code for the relevant route let's import the login
268:40 - component into the app component and include code that represents the route
268:47 - for the login component
269:01 - let's open the header dot JS file and include navigation functionality in this
269:06 - component so that the user can navigate to the login component by clicking the
269:11 - login button displayed on the navigation bar
269:24 - let's test the code
269:27 - we have a few issues here so let's fix these issues please see the relevant
269:41 - GitHub code at this location if you get stuck on any issues
269:46 - this is the main issue here this should be used state and not use ref
269:57 - there are also a few other issues that need to be fixed so let's fix these
270:01 - issues
270:03 - let's run the code
270:25 - so we have our login form presented to the user but it doesn't look great
270:30 - we'll fix this in just a bit so off screen I registered a user named Henry
270:36 - Jameson please feel free to register your own users while testing I'm going
270:41 - to test the login functionality using Henry Jameson's credentials I'm going to
270:47 - use a simple JavaScript alert to ensure that the HTTP status sent back from the
270:52 - relevant endpoint is 200 meaning that the HTTP request has been successfully
270:57 - processed on the server
271:00 - excellent we have received a response with a status code of 200 so we've
271:06 - received a HTTP response with a status code of 200 meaning success so next
271:13 - let's style the login screen appropriately let's open the login dot
271:18 - CSS file let's style the CSS class named login dash container
271:34 - we are using the flex grid for styling and layout purposes the flex grid is
271:39 - great for creating responsive UI code for various screen sizes let's create
271:44 - the login dash layout CSS class we are also using the flex grid functionality
271:51 - here note that we are setting the flex direction property to column which means
271:56 - the relevant elements will stack one on top of the other in a column layout by
272:01 - default if the flex direction property is not set this setting defaults to row
272:06 - this means the relevant elements are presented one next to the other in a row
272:11 - layout let's give each of these form dot group elements suitable margin bottom
272:19 - settings using bootstrap so that we are creating appropriate spacing between the
272:25 - form groups so that our layout here is a bit neater
272:31 - great
272:44 - let's include an error message at the bottom of our form for if something goes
272:50 - wrong during the authentication process
273:05 - so let's set the state of an appropriate error message based on the response
273:10 - provided by the server so if a status code of 200 is returned from the server
273:16 - the state of the error message variable can be set to an empty string or if the
273:22 - status code does not indicate success or an error is thrown we can set the error
273:28 - message variable appropriately to indicate that the login has failed on
273:32 - the server if an exception is thrown we can include the error message that has
273:37 - been caught within the try catch block then let's output the value stored in
273:42 - the error message variable to the screen at the bottom of the login form
273:48 - you
273:52 - you
274:09 - let's dial the error message display appropriately
274:14 - so to test this I'm going to force a 404 exception meaning that the relevant
274:26 - endpoint is not found by changing the endpoint path to something that is
274:31 - incorrect great lastly let's ensure that our login form looks good on smaller
274:39 - screens so to do this within the login CSS file let's include appropriate media
274:46 - query functionality
274:49 - you
275:06 - let's include code here to automatically navigate the user to the home page once
275:11 - the user has successfully logged in
275:31 - excellent great so once the user has been authenticated we want our other
275:36 - components to know as it were that the user is logged into the system so the
275:42 - best way to do this is through the use of context react context is a way to
275:48 - manage state globally so very basically we use react context so that other
275:55 - components will be able to retrieve a value from a global store and assess
276:01 - whether a user is logged into the system or not logged into the system for more
276:06 - information about react context please navigate to this URL so in order to
276:13 - create context let's create a folder named context within the SRC folder
276:24 - within the context folder let's create a file named auth provider.js let's
276:30 - import the create context function and the use state hook from react let's set
276:36 - a const named auth context to a value returned from the create context method
276:41 - like this note that we are passing an empty object to the create context
276:47 - function let's write code to export a component named auth provider note that
276:52 - this code simply means that the auth variable and set auth function will be
276:57 - passed down to all components that are wrapped by the auth provider component
277:02 - so this makes these accessible to the relevant child components that are wrapped
277:07 - by the auth provider parent component we'll look at this in just a bit so what
277:12 - this means is that all relevant components will be able to access the
277:15 - auth variable within all relevant child components if the auth variable is not
277:20 - null this means that the relevant user has been authenticated ie logged onto
277:25 - the system of course the state of the auth variable is managed through the
277:31 - use of the use state hook implemented within the auth provider component
277:36 - let's create a folder named hooks within the SRC folder within the hooks folder
277:42 - let's create a hook named use auth this code basically allows relevant
277:48 - components to access the auth context which means access is provided to the
277:54 - auth variable and the set auth function the set auth function of course is used
278:00 - for changing the state of the auth variable so to log in you change the
278:04 - state of the auth variable and to log out you appropriately change the state
278:07 - of the auth variable by setting it to null the auth variable state indicates
278:12 - whether the user is logged into the system and the set auth function can be
278:16 - used to change the state of the auth variable so the set auth function can
278:21 - essentially be used to log the user into the system or out of the system let's
278:27 - Let's create a hook named Use Axios Private.
278:30 - So the code for the hook is created so that the client code can retrieve an appropriate
278:36 - Axios client object that automatically includes an appropriate HTTP header containing the
278:42 - logged-on user's credentials.
278:44 - These credentials are appropriately formatted for basic authentication.
278:49 - So the returned Axios client object from this hook must be used for accessing protected
278:55 - resources on the server, i.e. retrieved through the relevant API endpoints.
279:01 - These protected resources require basic authentication to be performed before returning relevant
279:06 - data to the client.
279:10 - Now the code here creates what's known as an interceptor, so if the Use Axios Private
279:15 - hook is used from within client code to reference the Axios client, the login credentials are
279:21 - automatically injected into the header of the relevant HTTP request.
279:26 - So this means that the client code doesn't need to inject this authentication header
279:31 - information every time a HTTP request is made to an endpoint.
279:36 - This interceptor code does this automatically.
279:39 - Just a reminder, if you get stuck creating this code, please reference the relevant code
279:44 - at this GitHub repository location.
280:14 - So, the next step is to open the index.js file and wrap all the relevant components
280:30 - within the auth provider parent component.
280:33 - As discussed, this allows the child components, or makes provisions for the child components,
280:39 - to easily access the auth variable so that the relevant component can access whether
280:45 - the user is logged into the system or not logged into the system.
280:50 - So let's look at how this works.
280:52 - Let's open the home.js file.
280:55 - Let's import the use auth hook.
281:09 - Let's use the use auth hook to return the auth variable and the set auth function from
281:14 - the relevant context global store.
281:26 - Now within the UI.jsx code section of the home component, we can check the auth variable
281:31 - to see if the user is logged into the system, like this.
281:38 - So if the user is logged into the system, the code displays a message on the screen.
281:42 - You are logged in.
281:43 - If the user is not logged into the system, the code displays the hero image to the screen.
281:49 - So let's open the login.js file and use the use auth hook to return the set auth function
281:56 - from the context.
282:06 - Let's use the set auth function to assign an appropriate object to the auth variable.
282:11 - This object contains the username and password.
282:17 - So once the user is successfully authenticated, an object containing the user's username
282:23 - and password is passed into the set auth function, which effectively changes the state of the
282:29 - auth variable, which indicates, of course, that the user is logged into the system.
282:35 - So you can see that now this global context can be used to retrieve the username and password
282:41 - from this object, ie the object that we have just passed in to the set auth function to
282:46 - change the state of the auth variable.
282:49 - The username and password can now be injected into the header of HTTP requests through the
282:55 - interceptor functionality that we have implemented in the use Axios private hook.
283:02 - Let's run the code.
283:04 - Let's register a new user named Brandon Lowe.
283:09 - Okay, the password here is password one exclamation mark.
283:21 - Let's then log into the system.
283:26 - Excellent.
283:33 - So let's create our logout functionality within the header component.
283:43 - Let's retrieve the auth variable and the set auth function from the use auth hook.
283:48 - So if the auth dot user property is not null, this means that the user is logged into the
283:54 - system.
283:58 - So we want a logout button to be displayed in the navigation bar rather than the login
284:04 - and registration buttons.
284:06 - When a user is logged into the system, we only want the login and registration buttons presented
284:11 - to the user when the user is not logged into the system.
284:15 - Let's create a function for when the logout button is clicked.
284:19 - So let's create this logout function.
284:23 - Within this function, we can simply set the auth variable to null by using the set auth
284:27 - function for this purpose.
284:29 - This effectively means that the user is now logged out of the system.
284:35 - Then let's also implement code to navigate the user to the home component.
284:41 - Right, let's log into the system.
284:46 - Great.
284:50 - Let's log out of the system.
284:54 - Excellent.
285:07 - So let's create the code within the home component so that when the user is authenticated, a
285:12 - list of courses is displayed to the user rather than the hero image.
285:17 - Let's create code using the use state hook so that React monitors the state of a variable
285:23 - named course data.
285:26 - We can change the state of the course data variable using the set course data function
285:31 - returned from the use state hook.
285:34 - Let's use the use Axios private hook to return a reference to the Axios client that we are
285:40 - going to use to request a list of courses from the server.
285:44 - Note, we are getting a reference to the Axios client using the use Axios private hook.
285:50 - Because the use Axios private hook contains functionality that will automatically inject
285:55 - the logged on user's credentials into the header of the relevant HTTP request.
286:01 - So each request to the server requires the user's credentials so that basic authentication
286:06 - can be appropriately performed.
286:09 - This is because the course data is a protected resource.
286:12 - So the user must be authenticated before this course information is passed from server to
286:18 - client.
286:19 - Remember, implemented within the use Axios private hook is interceptor functionality.
286:25 - So the HTTP request is intercepted and the relevant authentication information is injected
286:31 - into the header of the HTTP request before the relevant HTTP request is made to the server.
286:40 - So let's create a JavaScript arrow function named fetch courses.
286:45 - So here a get request is made.
287:03 - And once the results are returned, we are using the set course data function to appropriately
287:10 - change the state of the course data variable.
287:13 - This results in the home component re-rendering, which means a list of courses will be displayed
287:19 - on the UI once the data becomes available and the set course data function is appropriately
287:24 - called to change the state of the course data variable.
287:28 - We'll implement the code for displaying the course data on the UI in just a bit.
287:33 - Let's use the use a fet hook to call the fetch data function when the home component first
287:39 - loads.
287:40 - But we only want the fetch data function to be called if the user is logged into the system.
287:52 - Let's display the course data value in an alert to test our HTTP GET request.
288:05 - Let's run the code.
288:11 - Oops, we currently are not importing the use state hook.
288:15 - Let's fix this.
288:38 - We now have a 404 error.
288:40 - This is occurring because we need to include a forward slash at the end of the endpoint
288:44 - path here.
288:51 - Let's try again.
289:06 - And we are getting the expected JSON results with a now alert.
289:11 - This means our HTTP request is working as expected.
289:15 - Right, so let's write the code for displaying the course data on the UI.
289:20 - So in the return section of the home component, let's implement the code for displaying the
289:24 - course data.
289:26 - I'm going to create this code fairly quickly with minimal explanation.
289:32 - So we are using the map function here to iterate through the courses list returned from the
289:38 - server.
289:39 - This courses list is stored within the course data variable.
289:44 - So I'm deliberately not providing a lot of explanation here.
289:48 - Please note that this part of the course is not a detailed guide on Bootstrap or even
289:53 - React for that matter.
289:55 - This part of the course has been created for the purpose of placing the advantages provided
290:00 - through the use of the Neo4j graph database management system in the context of a web-based
290:06 - application.
290:07 - Please feel free to copy the relevant code from GitHub.
290:11 - The first map function, let's refer to this as the parent map function, traverses the
290:15 - list of courses.
290:20 - Note that we are outputting the title for each course within the parent map function.
290:25 - This title property will be returned from the relevant endpoint.
290:33 - Within the parent map function, another map function is implemented that traverses a list
290:38 - of lessons.
290:39 - The lessons make up the relevant course.
290:54 - So we are outputting the title of the course as a heading.
290:58 - A list of lessons is outputted for each of the relevant courses underneath the relevant
291:03 - heading.
291:04 - So essentially the data is grouped by course.
291:08 - The title for each course and the course's lessons are outputted to the UI.
291:14 - Bootstrap is being used for layout and styling purposes.
291:24 - Note that we are setting the key property for this element to the identifier property
291:28 - for each course.
291:30 - When using the map function, it is always a good idea to appropriately set the React
291:35 - key property for the relevant element like this.
291:38 - This helps React to be more efficient when considering the component.
291:44 - We are also appropriately setting the key property for the element here related to each
291:49 - lesson.
291:50 - We are setting the key property here to the identifier of each lesson.
292:00 - Let's test the code.
292:05 - Okay, we have an issue here.
292:18 - So to fix this issue, we need to import the link component from the React Rooted DOM package.
292:26 - We are using the link component to wrap the title for each course.
292:30 - This is because we are going to create a component responsible for displaying course details
292:35 - for each individual course in a bit.
292:38 - Once this is done, we will point this link to the relevant course component, where the
292:43 - details for the relevant individual course will be outputted.
292:47 - This will allow a user to click the header for a course and for the course details for
292:52 - the relevant course to be displayed after the user clicks the relevant link on the homepage.
293:00 - You can see we have four courses currently saved to the system.
293:04 - So let's create a component that displays the course details for a particular course.
293:12 - So from a UX user experience perspective, the user will click on the course heading
293:19 - on the homepage and will be navigated to a component that displays the course details
293:25 - for the relevant course.
293:27 - Let's create a folder named course and a file within the course folder named course.js.
293:46 - Let's generate the boilerplate code for the course component.
293:50 - Let's open the app.js file and include an appropriate route for our course component.
294:03 - Note that this component accepts a parameter passed into the course component, which is
294:08 - an identifier for a particular course.
294:13 - So to tell the React router DOM system as it were about the relevant identifier parameter,
294:18 - we can include a colon followed by the name of the parameter, identifier, at the end of
294:24 - the relevant route path, like this.
294:39 - Let's go back to the course.js file.
294:42 - Let's include the relevant imports.
294:45 - I'm not going to explain this import code as we have already covered this while creating
294:50 - code for the other components, all except for the use params hook.
295:08 - We are going to use the use params hook to extract a parameter value that will be passed
295:13 - into this component from the home component when a user clicks on a course heading.
295:19 - So let's create a value from the use params hook.
295:24 - We can then use the params object to retrieve the name of the parameter that we named identifier.
295:31 - Let's create a tracked variable named course data.
295:35 - We can use the set course data function to change the state of the course data variable.
295:40 - Of course, when the state of the variable returned from the use state hook is changed,
295:44 - this results in the relevant component being re-rendered.
295:49 - Let's use the use Axios private hook to get a reference to the Axios client where an interceptor
295:55 - is employed to inject the user's authentication details into the HTTP header for any HTTP
296:03 - request made using the Axios client returned from the use Axios private hook.
296:09 - Let's use the use effect hook so that we can execute code that retrieves data for the relevant
296:15 - course when the course component first loads.
296:41 - Let's use an alert to output the results returned from the relevant get request.
296:51 - Within the home.js file, let's include the appropriate path to the course component within
296:56 - the relevant link component like this.
296:59 - Note we are including the course identifier as part of the path assigned to the to property
297:05 - of the link element.
297:08 - Let's test the code.
297:38 - Great, the results are outputted through a JavaScript alert.
297:45 - The JavaScript alert is of course just used for testing purposes.
297:49 - Let's create the UI code in the part of the course component that returns JSX code.
297:55 - So the code is very similar to the code within the JSX section of the home component.
298:01 - So to speed things up, I'm just going to copy and paste the relevant code from the home
298:04 - component into the course component.
298:08 - And let's adapt the code appropriately for the course component.
298:11 - So the difference between the relevant code in the home component and the relevant code
298:15 - in the course component is that only one specific course is displayed in the course component,
298:20 - whereas a list of all courses are outputted from the home component.
298:25 - Just a reminder, if you get lost while creating the code for any part of this application,
298:30 - please reference the code that can be found at this location on GitHub.
298:35 - Note that for our course component, we are also including the instructor that teaches
298:39 - the relevant course.
298:42 - This data is returned from the server in the teacher property.
299:12 - So the course component only ever returns one course rather than a list of courses that
299:25 - are displayed within the home component.
299:28 - So we copy this code from the home component, which is currently incorrect for the course
299:32 - component.
299:33 - We need to replace the D variable here with course data because the D references an item
299:41 - in a list of courses in the home component.
299:44 - This course data variable represents one particular course.
300:14 - Excellent.
300:18 - The next component that I want to create is used for the purpose of displaying only the
300:23 - list of courses in which the logged on user is enrolled.
300:30 - So let's create a folder within the components folder named enrolled courses.
300:42 - Within the enrolled courses folder, let's create a JavaScript file named enrolled courses.js.
300:56 - Let's copy and paste the relevant imports from the home component.
301:02 - So for this component, I'm going to copy most of the code from the home component as the
301:06 - code is very similar.
301:09 - The only difference is that we are calling a different endpoint on the server to get
301:13 - the relevant course data.
301:16 - In this case, only a list of courses in which the logged on user is enrolled will be displayed
301:20 - to the user.
301:23 - Just a reminder, you can of course get the finished code from the relevant GitHub repository.
301:53 - Let's include an appropriate root component for the enrolled courses component within
302:19 - the app.js file like this.
302:29 - Now let's open the header.js file and include code so that a link to the home component
302:35 - and the enrolled courses component will appear within the navigation bar at the top of the UI.
303:05 - In order for our links to be displayed in white text, let's include the following properties
303:11 - within the navbar element like this.
303:25 - So on smaller screens, this navigation bar doesn't currently look very good.
303:41 - So let's wrap the relevant navigation elements within the nav collapse element so that on
303:51 - smaller screens the navigation bar responds appropriately.
304:11 - Great!
304:22 - We copy this code from the home component and we of course don't need this code that
304:27 - outputs the hero image in the enrolled courses component.
304:30 - So let's delete this code here.
305:00 - Currently, when we click on the enrolled courses link, no data is displayed.
305:08 - And this is an expected result because the logged on user has not enrolled in any courses.
305:14 - So let's create the functionality so that a user can enroll in courses.
305:22 - We'll implement this functionality from within the course component.
305:29 - So let's create code that displays a button within the course component that is labeled
305:33 - enroll.
305:35 - This button must only display if the enrolled property for a particular course object returns
305:42 - false, which denotes that the logged on user is not currently enrolled in the relevant
305:51 - course.
305:53 - So when this button is clicked, we want a function named enroll to be executed.
305:58 - The code for this enroll function will of course enroll the logged on user into the
306:03 - relevant course.
306:04 - So let's create the enroll function.
306:34 - You can see that we are using a HTTP POST request to post the course identifier wrapped
306:41 - in an object to a specific endpoint.
306:44 - The server side functionality written in Java interacts with the Neo4j database management
306:49 - system appropriately in order to create the appropriate relationship between the user
306:56 - and the relevant course.
306:58 - So if the endpoint returns a status response of 200, meaning success, let's display this
307:05 - message to the user, which simply thanks the user for enrolling in the chosen course.
307:19 - And let's include codes to navigate the user to the enrolled courses component.
307:49 - Let's test this functionality.
308:07 - So each of the lessons listed for the enrolled courses must have a play button icon next
308:35 - to it.
308:36 - When the user clicks the play button icon, the lesson that has been created as a YouTube
308:40 - video will be displayed to the user through the video component that we are about to create.
308:47 - So the play button is implemented using the fund awesome icon component.
309:09 - The
309:30 - font awesome icon element is wrapped by the link element, the link elements to property
309:36 - is set to the path of the video component that we will create.
309:44 - The lessons identifier is passed in as a parameter to the video component.
309:49 - When the relevant video link is clicked, the play button icon denotes this link on the
309:54 - front end.
310:18 - So in the home component, we are currently handling what to output to the screen, the
310:24 - hero image is displayed when the user is not logged into the system, and a list of courses
310:28 - is displayed when the user is logged into the system.
310:32 - When the user clicks the enrolled courses link, this is currently not being handled
310:36 - appropriately.
310:38 - We want the login screen presented to the user if the enrolled courses link is clicked,
310:44 - while the user is not logged into the system, then when the user logs into the system, we
310:49 - want the user to be navigated to the enrolled courses component rather than the home component.
310:56 - So let's implement the code to handle this scenario.
311:01 - Let's first create a component within the components folder named required auth.
311:10 - This component is responsible for navigating the user to the login screen if auth is null,
311:15 - i.e. the user is not logged into the system.
311:43 - And let's open the app.js file and wrap the enrolled courses route with the required auth
311:49 - element like this.
311:59 - So the user will not be able to access the enrolled courses component unless the user
312:04 - is logged into the system.
312:05 - If the user tries to click the relevant link, the user will be presented with the login
312:09 - screen so this forces the user to log in in order to see the user's enrolled courses.
312:15 - And once the user logs in, the user is navigated directly to the enrolled courses component,
312:21 - which means the user can see the list of courses in which the user has been enrolled.
312:26 - Within the login component, we need to create the navigation code so that when the user
312:33 - logs in, the user is navigated to the component that the user tried to access prior to being
312:39 - redirected to the login screen.
312:41 - In this particular case, this would be the enrolled courses component.
313:07 - Let's test this code, great!
313:26 - So the last component that I want to create is of course the video component.
313:30 - This component uses the react player component to play the lessons that have been created
313:35 - as videos on YouTube to the user.
313:39 - Let's create a folder named video.
313:47 - Let's create a file within this folder named video.js.
313:51 - And let's create another file within the video folder named video.css.
314:01 - The code for implementing the play video functionality is very basic.
314:20 - Let's use the use param hook so that we can retrieve the YouTube video ID that will be
314:25 - passed into the component, like this.
314:42 - Let's open the app.js file and include the appropriate route so that the react router
314:48 - DOM system as it were knows how to navigate the user to the video component as well as
314:53 - pass in the appropriate parameter to the video component.
314:57 - The parameter value will be the YouTube video ID pertaining to the relevant lesson.
315:21 - This includes the react player element appropriately within the video component so that the relevant
315:26 - YouTube video plays immediately.
315:29 - We are setting the playing property to true for the react player element for this purpose.
315:38 - Then let's set the URL property appropriately to point to the relevant video on YouTube.
315:44 - Note that the URL includes the YouTube ID that is passed in as a parameter to this component.
316:01 - Let's style the video component appropriately.
316:14 - In fact, let's test the code.
316:28 - I'd like to introduce you to this exciting new Unity for Beginners course, where we'll
316:33 - create a game using Unity and C sharp over a series of videos.
316:38 - All the software that we'll use including Unity and VS Code can be downloaded free of
316:44 - charge.
316:45 - This course is totally free.
316:50 - Hi and welcome.
316:51 - I'm Gavin Lon.
316:52 - The rigid body component allows us to apply physics to a game object, for example gravity.
316:58 - But we are going to write code in the update method to apply a forward force to the player
317:03 - game object in response to the user pressing down.
317:07 - The W key on the user's keyboard.
317:15 - So to improve the user's experience, you can include a spinner that appears to the user
317:20 - while data is being loaded.
317:23 - So in fact, the last component that we'll create could be the spinner component.
317:28 - So when the data is loading, we present the user with a spinner.
317:32 - And then when the relevant data becomes available, the spinner component disappears and the data
317:37 - is displayed to the user.
317:40 - So for this purpose, I've created a spinner component.
317:45 - Please reference the relevant code on GitHub if you'd like to include this spinner functionality
317:50 - within your application.
317:53 - I'm going to fast forward the creation of the spinner component, as this is purely a
317:57 - bonus piece of code that you can study at your own pace if you are interested.
318:02 - To implement the spinner, we are simply creating a React component, relevant CSS code to style
318:18 - and animate the spinner.
318:48 - And functionality within the relevant components to appropriately show and hide the spinner.
319:00 - The showing and hiding of the spinner is implemented using a boolean variable, where the state
319:05 - of the relevant variable is tracked through the use of the use state hook from within
319:10 - the relevant components showing or hiding the spinner.
319:15 - Please review the code in detail at the relevant GitHub repository location.
319:20 - The link to the relevant repository is available below in the description of this video.
319:25 - We can pass in the relevant boolean value as a prop to the spinner component to indicate
319:31 - to the spinner component to be visible or hidden, like this.
320:01 - Let's integrate the spinner component into the enrolled courses component.
320:23 - Thank you.
320:53 - you
321:24 - you
321:50 - Hi and welcome! I'm Gavin Lawn.
321:53 - This is part two in a course where we'll create a game using C-sharp in Unity.
321:58 - In part one, I demonstrated the...
322:11 - ...actually making the game, at runtime, more robust.
322:14 - For details on C-sharp data types, I've included a link to a C-sharp tutorial on C-sharp data.
322:20 - So, I'm going to finish the code for this application by styling the header of the courses displayed in the home component.
322:28 - The course component and the enrolled courses component.
322:32 - I'm including the relevant CSS classes within the app.css file, so that the classes affect all of these components.
323:02 - I know the UI for this application is not beautiful.
323:29 - But the purpose of this part of the course is to place an application that takes advantage of a Neo4j graph database management system
323:36 - for the purpose of managing relationships between data entities in the context of a web-based application.
323:46 - My challenge to you is to fork the GitHub repository that contains the code that I've demonstrated in this part of the course
323:53 - and abstract the common parts of the JSX code contained in the home component, the course component and the enrolled courses component
324:01 - into relevant child components.
324:04 - One suggestion is to create a reusable child component for an individual course.
324:09 - You can then use appropriate props to dynamically customize the new child course component based on its context, i.e. its parent component.
324:18 - For example, in the enrolled courses component, a play button appears next to every lesson for each course.
324:25 - Whereas in the home component, these play buttons are not included next to any of the lessons for each course.
324:31 - So the new course child component will need to account for these two scenarios and dynamically output the appropriate JSX code.
324:41 - I hope that you've enjoyed this part of the course and have learned a little bit about creating a client react application
324:48 - that interfaces with a web API component through Axios where basic authentication is employed.
324:54 - Thank you and take care.

Cleaned transcript:

Neo4j is a powerful graph database that enables organizations to model, store, and analyze complex relationships between data points. Its intuitive, graphbased structure offers a flexible and efficient solution for diverse applications, making it a leading choice for managing connected data. This course is taught by FreeCoCamp team members Farhan Chaudhary and Gavin Lon. First, you will learn about Neo4j and graph database management systems, as well as how you can benefit from incorporating them into your applications. Next, you will learn how to use a Neo4j graph database management system as the backend storage for a realworld application created with Java and Spring Boot. Finally, you will learn how to create a frontend with React to interact with the data stored with Neo4j. Neo4j provided a grant to make this course possible. So let's get started. Hi and welcome. I'm Gavin Lon. So, I finally got my FreeCoCamp tshirt. I traveled all the way from the east coast of South Africa to Amsterdam and met the founder of FreeCoCamp, Quincy Larson, and he gave me my own FreeCoCamp tshirt. Really great. So the point of the trip was to meet Quincy and some of the core team members of FreeCoCamp. In person. It was about team building and solidifying relationships between coworkers. The key concept in this course is, in fact, relationships. Relationships between data. The relationships could be between people, between car parts, between a tshirt and a human being. So relationships between homogenous data or lack data, for example, between human beings, or relationships between heterogenous data or different types of data. These relationships can be very effectively represented within a graph database management system. Neo4j is a graph database management system. In this part of the course, I want to present to you a brief overview highlighting the significance of a graph database management system. Before we look at Neo4j, let's contextualize the significance of a graph database management system by looking at some of the other popular types of database management systems commonly used today. So let's look at three other commonly used types of database management systems before we discuss the graph database management system and why we would want to use a graph database management system in our applications. The most wellknown used database management system type is a relational database management system. The relational database management systems are SQL Server, Postgres, and MySQL. In this type of database, tables represent entities. For example, a table named employee contains rows of data. Each row of data is divided into columns or fields containing employee information. For example, the name field contains the employee name. The age field contains the employee's age, etc. Another data entity could be implemented in a table named department. Each row in the department's table denotes an individual department. For example, one row stores information for the human resources department and another row stores information for the finance department. These data entities or database tables within a relational database can be explicitly related to one another within the relational database management system. For example, an entity may have a onetoone relationship with another entity. So say employees and the cars they drive, a specific employee is related to a specific car, one employee to one car. So for example, the employee entity in this case has a onetoone relationship with the car entity. Two database tables can have a manytomany relationship. For example, an employee could be a member of multiple teams. And each team can contain multiple employees. So this means an employee can be a member of more than one team, and each team can have many employees. So in this scenario, the employee entity has a manytomany relationship with the team entity. A database entity can have a onetomany relationship with another database entity. For example, the department table has a onetomany relationship with the employee table, meaning each department can contain one or many employees, and an employee can only be a member of one department at a given time. So this onetomany relationship can be established within the relational database management system through an appropriate schema design. A database schema defines how data is organized within a relational database, which includes constraints such as table names, fields, data types, and the relationships between the relevant entities. So for example, the onetomany relationship between the department table and the employee table can be implemented by including a primary key, which is a unique identifier for a row of data in the department table, and a foreign key field within the employee table, which relates to the primary key value within the department table. The main advantages of a relational database design is that it helps facilitate data integrity, so the data is not easily corrupted. As well as reduces data redundancy, storage for repeated values are reduced. For example, if you stored department data within the employee table, you can see here, the department short name field and long name field values are repeated across rows in the employee table, whereas separating the data into an employee table and a department table means these values are not repeated, resulting in saving storage space. As the data scales, this storage saving can be quite significant. A technique known as normalization is employed to design a relational database. I won't go into the details of normalization here, but please look up normalization, which is a key concept in relational database design. So the technique of normalization can increase data integrity, minimizing data corruption and also significantly reducing data redundancy, i.e. unnecessarily storing values repeatedly. The downside to relational databases is the speed of retrieving data when multiple joins or deep joins between entities are necessary. For example, if you want to retrieve analytical data that summarizes data from multiple entities, a normalized database design can cause the retrieval of such data to be a slow process. So the way to speed up data retrieval can be to use a schemaless database management system like, for example, MongoDB. This is a documentbased database management system. The fact that the database design is not bound by a schema like with a relational database management system can result in increased speed of data retrieval as well as allow for better design flexibility. So you can see that each of these database management systems have their purpose and advantages. Another type of database management system may use a namevalue pair storage structure like, for example, Redis. This database management system is great for caching frequently retrieved data and therefore can help speed up a system. So we have briefly looked at three common types of database management systems. Relational database management systems like, for example, SQL Server or Postgres, schemaless database management systems like, for example, MongoDB, and namevalue pair database management systems like Redis. So let's look at the significance of a graph database management system. Neo4j is a graph database management system. This type of database management system is based on the graph data structure. All of these social media platforms use graph databases, Twitter, Facebook, and Instagram. As we all know, these platforms have millions of users. A relational database management system would not be ideal as the only storage facility for such data. Because of the way the data is structured would mean multiple joints between entities would need to be made. When relevance data is retrieved, which would drastically slow down the data retrieval process ultimately causing a poor UX user experience because the whole system is slowed down by these joints that need to be made between data. So note that when designing a particular system like a social media platform, you could incorporate both a graph database management system and a relational database management system into your overall system design. This type of solution could combine the enforced data integrity inherent in relational database management systems with the complex relationships between data entities or nodes that can be facilitated using a graph database management system. For example, the master database could be a relational database where data integrity and data redundancy concerns are addressed by the inherent benefits that we have discussed regarding a relational database management system. A graph database management system that is appropriately synchronized with the relevant relational database management system can be leveraged to increase the retrieval speed of data that, for example, has complex relationships. If data that requires complex relationships was retrieved directly from the relational database management system, the joints required when retrieving the relevant data could significantly slow down the system and ultimately result in a very poor UX user experience. So by including a graph database management system in the overall system where it sits on top of the relational database management system, as it were, and is used to speed up the retrieval of data with complex relationships, this could significantly speed up the data retrieval process resulting in a far better UX user experience. So this sort of system would require that the data stored in the relevant graph database management system and the relevant relational database management system be synchronized so as to ensure that the data is consistent across the two disparate database management systems. So a system like this, when designed properly, can leverage the benefits of both types of database management systems. For graphbased data structures, a database management system that focuses on the facilitation of relationships between entities or nodes is essential, and a graph database management system provides a way to store data based on the graph data structure, which is ideal for applications that consume data where entities have multiple relationships and complex relationships with one another. Think about social media platforms where you have relationships between users and posts, likes, friendships, etc., and you have millions of people using these platforms. A database management system is needed that appropriately facilitates the storage of data for a large number of different types of relationships. A graph database management system allows for relationships to be stored as data within the graph database. With a relational database management system, the emphasis is on the entities, and generally the relationships between the entities are not stored in the database, but rather general relationships are established at the design level. For example, you can see by the foreign key field value that the employee is a member of the HR department, but there are no details about the relationship itself between the relevant department and employee, saved in the database. This is something you could easily do within a graph database management system. You could create a more detailed relationship. You can easily save data regarding individual relationships between entities or nodes, for example between an employee node and a department node. So here is a whiteboard presentation that shows how the relationships between individual employees and employees and departments could be represented within a graph database. So here we see a node that represents a department. This node is appropriately labeled department. Details related to this department node can be saved to the database as properties and related values. So this department contains a short name property with a value of HR, and a long name property with a value of human resources. Here is our first employee node. This node is appropriately labeled employee. The employee node contains properties and relevant values representing the employee's name and age. Here we see our first relationship. This relationship explicitly shows that the employee whose name is Brad Jenkins is part of the HR department. This relationship is appropriately labeled member of. So you can see that this is a very human readable representation of data. The fact that this employee is a member of the HR department is clear through appropriate labeling and properties. So Brad Jenkins is a member of the HR department. We are able to add properties to the relationships themselves. So the member of relationship has a join date property as well as an employee type property. You can see by this data when this employee joined the department and that this employee has a permanent role and is not for example a contractor. Here we have the second employee node who has the name Jenny Lane. Jenny is also a member of the HR department. We can save relationships between employees within our graph database. So Jenny works with Brad. We can also create another works with relationship in the opposite direction where Brad works with Jenny. So you can see that we have a one department to many employees relationship just like what was shown earlier in the relational database but a graph database is far more flexible in terms of design when establishing relationships between data points or nodes. Not only can the entities contain associated data but the relationships themselves can also contain data i.e. through properties and associated values. So we could create even more complex relationships between nodes. For example a chain of command hierarchical structure related to our employee nodes. So here is an example of this where employee James Stokes reports to another employee Jenny Lane. This is just a simple example and of course this hierarchical data structure could become far more complex. So this presentation was only intended to give you a basic idea of how much more flexible the design of relationships between entities can be within a graph database and how complex relationships between entities can be easily implemented within a graph database. I want to show you a brief demonstration of using Cypher to query a graph database and to do this I'll firstly create a Neo4j database on my local machine. I'll use my Mac platform to demonstrate this. I'll contrast using Cypher and Neo4j with using SQL in the SQL Server database which of course is a relational database management system. Firstly what is Cypher? Cypher can be likened to SQL or Structured Query Language. Cypher is a textbased declarative language used for querying a Neo4j database. What is meant by a declarative language? A declarative language is a high level language that describes what a computation should perform. These languages must follow strict semantic rules, must be structured in a particular way. In order to be valid and for desired results to be returned from the relevant database management system, for example using SQL in order to bring back all employee records from the employee table, you would appropriately execute the following SQL code. This SQL statement simply returns all rows and all columns from the employee table. Using Cypher if you wanted to return all employee data, you would use a query like this. This query would return all employee nodes and relevant relationships. Although when comparing these two query languages, they are of course semantically different, but principally they are the same in that the relevant declarative textbased code is parsed by the appropriate database management system converted into appropriate instructions that are executed under the hood as it were. The relevant results are then returned from the relevant database. I'd like to demonstrate using Cypher within a Neo4j database. I'll contrast executing Cypher against the Neo4j database with executing similar queries against a similar database implemented in a SQL Server database. You don't need to follow along with this part of the course, but of course you can if you want to. So if you want to follow along, you can install Neo4j on your Mac or Windows platforms by following the instructions at this URL. I have already installed Neo4j on my Mac platform. If you want to install a free version of SQL Server, please navigate to this URL. But as discussed, this part of the course is only intended to be an overview and not a detailed explanation, so it's not necessary to follow along with this part of the course. I've created these scripts on GitHub for this part of the demonstration, so I'm going to copy this script from GitHub and run it in Neo4j to generate my Neo4j graph database. So within Neo4j Desktop, let's create a new project. I'm going to call this project Sample Project. Then let's create a new database. I'm going to name my Neo4j Database Company DB. Let's give our database a password. Then let's press the Create button. And now we need to start the database, so let's press the Start button to do this. Then to execute our Cypher queries, let's click this Open button and open the appropriate window from which we can execute our Cypher queries. So the first thing we need to do is copy the code for creating our graph database. So let's navigate to this appropriate GitHub URL. Let's copy this code from GitHub and appropriately paste the code within the window that we can use to run our queries through Neo4j Desktop. Great. And let's click the Play button to create our graph database. Excellent. And we are presented with appropriate status information, telling us that our graph database has been created successfully. I'm going to run this script within SQL Server to generate a similar database, the difference of course being that this database is designed as a relational database. So let's appropriately copy this SQL code from GitHub. Let's launch SQL Server Management Studio. Let's run our SQL code to create our database. I've already created a database named the CompanyDB test. So I'm going to create a new database named the CompanyDB test2. Then I need to change the relevant SQL script to point to the new database that I've just created. So let's press the Play button to run the script and create our database tables and relevant data. Great. So I'm going to run a few queries so that you can get a basic understanding of the differences and similarities regarding Cypher and SQL. So let's run this query against the Neo4j database. Great. This query brings back all the employee nodes and relevant relationships. In order to retrieve all employee data from within the relevant SQL Server database, you could run a SQL query like this. And let's say we wanted to retrieve particular data about a particular employee. So you could run this Cypher query like this. Within the SQL Server database, you could run a SQL query like this. Okay, so now the next query I'd like to run is a little bit more interesting. So in both these two databases, we have expressed a hierarchical relationship between employees. In the Neo4j database, this is implemented through the report to relationship established between employees. In the SQL Server database, the same hierarchical relationship between employees is expressed but through the use of what's known as a selfjoining table. So in this case, the employee table joins to itself through the relationship between the report to ID field and the ID field, which stores each employee's ID. So in the employee table, the hierarchical relationship between employees is established through the use of the report to ID field, which stores the employee ID of the relevant employee's immediate boss, if you like. So employee Brad Jenkins is at the bottom of the hierarchy, as it were. So if you wanted to query the SQL database to get the chain of command from Brad Jenkins to the top of the hierarchy, you need to run a query like this. As you can see, this query is really difficult to understand at first glance, and recursion is used to get the desired results. A graph database is far easier to understand in terms of retrieving such tree data structures from the relevance database. So to use cipher code to retrieve the relevant hierarchical data, starting with an employee at the bottom of the hierarchy, Brad Jenkins, you would run cipher code like this against this particular database. Great. Okay, so I hope this part of the course has given you at least a basic understanding of a graph database management system, and how you can benefit from incorporating a graph database management system into your applications. Farhan will now go into more detail, where he'll use a Neo4j graph database management system as the backend storage facility for the serverside part of a realworld webbased application. I will then follow Farhan and create the frontend code for this application using React. Hello everyone, welcome to this course. I am Farhan Hassan Choudhury, one of the instructors, and I will walk you through the entire process of working with a Neo4j database, as well as the development of an API powered by Springboot Framework. Now, at this point of the course, I will show you how you can create a new account for the Neo4j Aura cloud database service, how to create a new database, and run some simple queries. Now, keep in mind that this is not going to be an exhaustive list of all the commands and queries that you can run inside a Neo4j database. What I am going to do is I will show you how you can create a node, how you can create relationships, how you can delete a node, update a node, and some other basic grad operations. In a word, I will teach you whatever is necessary to create the API. Now, to begin with, we will navigate to Neo4j's website. I will leave the link in the description so you can follow along. And once you are here, you will use the Get Started Free button to create a new account. Now start free. And if you wish, you can sign up for a new account using your email address, but what I am going to do is I will just use my Google account to log in. Now, I have successfully logged into Neo4j Aura, and I hope you have done that too. So this is the dashboard that they give us. You can see there are the instances that we are going to create. Now, to create a new instance of a database, just click on the New Instance button, and it will give you a free template. Like if you are a beginner, you can start here, and it will give you some data to start with. What we are going to pick is an empty instance, because I want to show you how you can create new nodes, relationships, labels, and things like that. So we will hit Create, then they will generate a password for us. Now you can copy that password using this button, or even better, you can use this Download button to download all the credentials as a text format. I am not going to do that yet, but I will show you later on how that works out. So once you have copied the credentials, click on Confirm. I have copied or downloaded the above credentials so that they will know that you have the credentials, because you cannot get it once you have gone past this step. Now we will do Continue. Now the creation process of a new instance is a bit long. It can take around a minute or so. So what I am going to do is I am going to pause the recording and come back once the instance has been created. So it looks like that the database has been created. It's running on GCP or Google Cloud Platform, and since I am from Asia, I am from Bangladesh, the region closest to me was Singapore. Now we also have a connection URI. Now to connect to this instance, all you have to do is click on the open button. But before that, just in case you want to rename your instance, you can go here and you can use rename. I am not going to do that though, so I will just open it and they will ask for a password. So I will just paste in my password and the database user will be Neo4j. You don't have to change any of these things, just click connect. Now once you have landed on your workspace, you will see that there are no nodes and relationships whatsoever. But I would like to show you how you can create new nodes, how you can create new relationships between them, how you can update a node. Now the Cypher query language is really expressive and this is really easy to learn if you have experience with some other query languages like SQL. But even if you do not have any experience with that, Cypher is not that hard to learn. The Cypher documentation is an excellent piece of resource. They also have a cheat sheet. Now I will leave a link to this cheat sheet in the description of this video. You can visit these and you can essentially learn about how to read all the nodes in a database using the match clause or how to filter them using where return variables. And under write queries, you can also learn about creating new nodes, labels and relationships. Set for updating them, delete and remove for getting rid of nodes and labels and things like that. So let's suggest that you bookmark this Cypher cheat sheet in your browser so that you can refer back to it whenever you need and also the documentation. Now I will go back to our workspace and I will start creating a bunch of node and I will explain how you can do that as well. So let's switch back to our workspace. And the first thing that we want to do is we want to create a new node. So we will begin with the create clause and a set of parentheses. Then we will put a colon here and we will write the label of the node. So a node is an independent or a single entity inside your database and it has to be labeled something. For example, if we create a node in our database with the name Farhan Hassan Choudhury, it would be hard to say what this node represents. Does it represent a user? Does it represent someone's pet cat? What is it? So we are labeling our node with the label user. And then we will put some properties here. The first thing I want to put is a name for this user. So Farhan name colon Farhan Singh Choudhury, then I will put a comma. The next is a username. This is a unique username and we will use it to uniquely identify every single user. So we will say username is just Farhan. And that's all I am going to put here. Now I will execute the command using the play button. And looks like we have a new label here. And if I click on this, it will return everything under this label to us. Now instead of clicking on this label, we can also use the match class. So we will say match. And we want to match for all the nodes in our database. We will say return all the nodes. Now this is just a variable by the way. If you want to call it nodes, nodes, you can do that as well. Just make sure you are not using any of the reserved keywords. For example, if I remove the S here, you will see it becomes red, which means it's a keyword. Like match and return, we cannot use it. So I will change it back to nodes. I will run the query. And as you can see, we have all our nodes here. Now let's go ahead and create two more users. So I will say create. And this time I want to actually create multiple users with a single create call. So I will keep pressing shift and press enter to come on the next line. I will start a set of parentheses. I will create a new user with the name John. And his username will be just John. Then outside of the last parentheses, I will put a comma and I will again keep pressing shift and press enter to come to the second line. And I will open another set of parentheses. I will create another user and her name will be Jane and username will be just Jane. It has to be string. Now if I end this query with a semicolon at the end, I can just press on this play button. And as you can see, I have successfully created two new nodes and four sets of properties. So if I say match n for nodes and return n, I can get all the nodes in our database. So I have for instance, I have John and I have Jane. Now the thing is all these three nodes are of the user label. So it would be nice to have another label on our system. So let's go ahead and create a bunch of courses. Now to create a course, we will use the same syntax as before and you can use your up arrow to bring back your old queries. And I will just make some changes to this query. I will switch user with course in both cases. I will replace title with C++ course and the username with identifier. This is an unique identifier for the course, which is CPP. And the next course we will have is title JavaScript course and we can call it JS. Finally, we can have another course called C sharp course and its identifier will be C sharp. Whether I have made a mistake here, it should be identifier and not username. So let's look at our query. We are creating three courses with titles C++ course, JavaScript course and C sharp course. They all have a unique identifier, CPP JS and C sharp. So I execute this command. Looks like I have a mistake, which is I did not put a comma at the end. And how did I know that? So it, as you can see Neo4j is actually telling me that there is some problem in the beginning of the course title C sharp line, but I can see that it's totally fine. So it's highly likely that the mistake is actually at the end of the previous line. So that's how I thought that maybe I have missed a comma. So I will run this query again and I have created three new nodes and I will say match n and I will return n. So as you can see, I have all my nodes here. There is Jane, John and Farhan has seen chosen these are the users and C++, JavaScript and C sharp. These are my courses. Now it would be nice if I could create a relationship between Jane and the C++ course, John and JavaScript and Farhan has seen on C sharp course. So I want to essentially enroll them in this course, but before that I would like to show you a few variation of the match clause. So right now when we say match n return n, it actually returns all the nodes in our database. What if I want to only get the course nodes or the user nodes? We can do that by defining a label after this variable like this. So I want all the users return n as users. You can actually do that. If you use as, you can actually rename your variables to make them more user friendly. So I am matching all the node of label user and I returning them as users. I will press play. As you can see, I am now getting only the users and not the courses. Likewise, I can replace n with C or let's just keep it n since that's just a variable. I am picking the course as instead of users, I will say courses. By the way, you can press Ctrl Enter to execute your query without pressing the play button. So right now I am getting only the courses. But what if I only want to get one user? For example, I only want to match for the user with username for HAN. So I can do that. I can say match u for user. So I will put user then I will use the where clause. This is used for filtering or query results. So I will say where u.username is equals for HAN return u as for HAN. So what I am doing essentially here is I am matching for a user type that has the username for HAN. I am putting it inside u and I am returning u as for HAN. Let's run this query. And as you can see, I am getting for HAN since you three back. Now let's add a course to the mix. So after I am saying u colon user, I can put a comma start another set of parentheses. I can say C course. So where u.username equals for HAN and C.identifier is equals CPP return u comma C. So this time I am removing the as keyword. And what I am doing here, I am matching for a user and a course where the username is equals for HAN and course.identifier is equals CPP. Finally I am returning u and C. Let's see if it works. As you can see, we have successfully found the C++ course and the for HAN has into three user. Now we are actually ready to create a relationship between these two nodes. So I will bring back my old query and instead of returning them, I want to say create because I want to create a new relationship and I will first take the user. So here I have the user. Then I will put a dash, then a set of square braces and inside I will say colon enrolled in. This is the type of relationship this user is going to have with the course. So what we are doing, we are matching for a user and a course where the username is for HAN and course identifier is CPP. Then we are creating a relationship. What kind of relationship you say? We are creating an outgoing relationship from the user. And how do I know that, as you can see, there is an arrow going out from the user towards the course. So this is an outgoing relationship from the user. And what is the type of this relationship? The type is actually enrolled in. Now we can actually save this relationship inside a variable called R. And I can say return R. So if I press the play button again, it just looks like I have successfully created a relationship. So the relationship actually starts at node 1 and ends at node 4, which means that the ID of HAN has been showed here is 1 and ID of CPP is 4. If I go to user, you can see for HAN has been showed here has the ID 1. And if I go to course, C++ course has the ID of 4. Okay and the type of relationship is enrolled in, there are no properties whatsoever. There are the element ID, start node element ID and things like that. We do not have to worry about them. So that's how you can create a relationship between these two nodes. So that's how you can create relationships inside of Neo4j. Now let's see how you can update a property of a node. So if I want to update the name of John to John Doe and John to John Doe, I can do that. First we have to find John in our database, so we will send match a variable u of type user where u.username equals John. So now we are matching for a user with the username John. Then we want to use set, this is another clause in Neo4j cipher language. So I will say set u.name equals John Doe. And if I execute this query, looks like it has done its job. So if I go back and instead of setting it, if I return u, John has now become John Doe. We can do the same thing with Jane because why not, they are related. Jane and we can say Jane Doe. Okay, so I want to return Jane, return u. There you have it. So now you have learned how to match nodes in the database. You have learned how to create new relationships, update values of an existing node. Now that's pretty much all you are going to need for the API development process. But I would like to show you one last clause from the cipher query language. And that is the exist clause. For example, if you ever want to check if Farhan has introduced is enrolled in the C++ course or not, you can do that using the exist clause. So we will begin with match and what do we want to match? We want to match for an user and we want to match for a course where u.username is equals Farhan and c.identifier is equals cpp. Now we have an user with the username Farhan and we also have a course with the identifier cpp. Next, what we want to do is we want to say return and we will call the exists function. This is a function and that's why we have these two parentheses and inside these parentheses we want to describe a relationship. So the relationship we are looking for or checking for is whether user is enrolled in the course or not. So we will finish our query. What we are doing, we are matching for a user with the username Farhan and we are matching for a course with the identifier cpp. Then we are checking whether a relationship between them of type enrolled in exists or not. So I will press the play button and it says true. Now if I switch cpp for something else like JS, we have the JavaScript course and I hit the play button, you will see I am getting false. Now to be honest that's all you need to know to go through this entire course but Cypher is a really excellent query language and if you have plans to learn a lot more Neo4j than I have showed you in this course, I would suggest that you go through their documentation, you go through their cheat sheet and you practice making your own databases, querying them in a lot of different scenarios and learn as much as you can about this database system. Now I am going to finish this lesson here but in the next lesson you will see me using an initializer Cypher script to create a new database for our API and from there we will begin working on our Java code. In this part of the course, we are finally going to start working on our Spring Boot API but before that we need to set a few things up. First thing first, go back to your Neo4j Aura database dashboard and delete any old instances that you may have created. While working with the API, we want to start with a clean slate so that we can be sure of the fact that some old data will not mess up our API. To delete an old instance, you can use the delete button here and then you will have to write the name of the instance. It's just to make sure that you are in your right senses and you are not sleeping or anything. Click on the Destroy button and wait until the instance is being destroyed. Now to create a new instance, use the New Instance button, choose Empty Instance and click on the Create button. Make sure you download the credentials file because we are going to need it later on and also let them know that you have downloaded the credential file by clicking on this check box. Click on Continue. Now creating a new instance may take a few minutes, so what I am going to do is I am just going to speed up the process in this video so that you don't have to wait around for long. Once the instance has been created, click the Open button, accept their terms and conditions and when they ask for the password, open up the credentials file you just downloaded. Just highlight the password here, copy it and paste it on the empty password field. Click on Connect and we have successfully connected to our new instance. Now as you can see, this instance is completely empty but we will need some data to work on our API. For that, I have already created an initializer script that you can use to initialize the database. For that, go to the code repository on GitHub, I will leave the link on the description below. Then go inside the data folder, you will find a file called initializer.cypher. Open up this file and go to Raw, highlight all the lines and copy with Ctrl C. Then go back to your RRDB dashboard, paste the code that you just copied and then press the play button to execute the code. As you can see, the code has successfully created some nodes, relationships and property keys. Now the first node that I would like to show you is the user node. Now this represents all the users in our database. For example, if we open up John Price, you can see that it has an ID, it has a name John Price, it has an encrypted password hash, it has roles and it has username. Now the significance of each of these properties will become more clear as you start working on the API. For now, just keep in mind that all these properties are important for our application. Next up, we have course. This represents each of the courses that will be available on our system. So if I click on the Blazor Shopping Cart course, you can see that it has an ID of 10. It has a string identifier that we are going to use to uniquely identify this course. It has the name of the teacher and a title. Now you may argue that we can use the ID to uniquely identify this course while that's correct. I prefer using some other unique string or identifier to identify my course or entities. I just do not like to rely on the autogenerated ID fields in any database at all. Finally, we have the lessons. These are the individual lessons that belongs to some course. For example, if we click on the Blazor WebAssembly and WebAPI on.NET 6 lesson, you can see it has an identifier just like the courses. It has a title and it also has an ID. Now this lessons here has a belongs to relationship with the courses, which means each of these lessons belongs to a certain course. For example, if I zoom in on the Blazor course, as you can see, all these four lessons belongs to the Blazor Shopping Cart course. Finally, there is the enrolled in relationship, which is between the individual users and courses. So for example, John W here is enrolled in the Blazor Shopping Cart course. Now that we are done with our database, we can finally start working with our API. For that, you will need JDK preinstalled on your computer. Now you can download the JDK from Oracle's website. I am going to use JDK 17 since that's the latest longterm support release. But you can also go with JDK 20, it's totally up to you. One more thing for those who are watching this course on Linux, it's totally fine to use any of the open JDK builds. For example, I myself am using the Microsoft build of open JDK instead of Oracle's official build, and given the complexity of our API, it's not going to make any change or it will not break anything whatsoever. So feel free to use any open JDK build that you like. You will also need a good IDE to make your programming process more fun. I'm going to use IntelliJ IDEA Ultimate here. I have a student license, so I'm going to use that. But if you want, you can also use the community edition. To be honest, if you look at the feature comparison here, most of the essentials are available under the community edition. We do not need the HTTP client thing since we are going to use a thirdparty client anyway. We do not need database tools or SQL or any of these things for this project at least. Finally, we need to initialize our project. For that, we are of course going to use the Spring Initializer. Now I will leave the link to Spring Initializer down in the description. So once you have navigated to this page, we will make some choices here and we will generate our project boilerplate. First, make sure that you are picking Maven under project here. You can also use Gradle if you have previous experience with the tool, but I'm just going to pick Maven. The language will remain Java. For the Spring Boot version, I'm going to use 3.1.0 since that's the latest at the time of recording. But if some other version comes out later on while you are watching this course, feel free to use that. Just do not pick any of the snapshots. Pick unstable release. Now under group, you will have to type or you should type some domain in reverse order. For example, my own domain is Farhan.dev, so I will just type in dev.farhan. Then artifact is just the project name. So I'm going to call it Spring Boot Neo4j. You may call it anything that you like. I will also put a sensible description like a simple API powered by Neo4j. Finally, make sure that you are picking the correct Java version from down here. I'm going to pick 17 since that's what I have installed on my computer. But if you have installed 20, make sure that you are switching to 20. For packaging format, we will go with jar since that a lot widely used than wire format. So let's not change that. Now the most important part, adding dependencies. Now this is needless to say that we will need a number of different dependencies for our project. But for starters, I will just pick Spring Web and the dev tools. Now you may think that why not pick the Neo4j dependencies while we are here? Well, I could have picked them, but one thing that I have noticed in the past is that many people face difficulties while they try to add new dependencies to a project that they have already initialized. So I thought why not start the project with just the bare bones, you know, essential dependencies only and then as we go forward, we will keep adding new dependencies to our project. That way it will represent a much more realistic development workflow and it will also teach you how you can search for new dependencies and add them on the flag. So take a good look at all the choices you have made. And once you are happy with them, click on generate. It will download a little zip file to your computer that contains all the project file. So I'm going to just open up the zip file using no Windows Explorer or WinRAR or whatever you like, copy the project folder, go to a place where you usually put your codes in. I usually put them in individual directories. So I'm going to paste it here. And once I have done that, I will just open up my IDE, which is IntelliJ IDEA. I will open up my project, input Neo4j, okay, yes, we trust the project. And once you have opened the project for first time, I would say give it some time to cache all your dependencies, read the source files and things like that so the IDE knows about your project and it can help you along the way. Hello everyone, I'm your instructor Farhan, but I'm from future. Now in the next lessons, you may see a little problem with the video in some cases when I'm trying to create a new class or maybe a new package, you may see that this menu is not showing up. Now this is because my recorder was only recording one window in my computer, so all the sub menus were invisible. So whenever you see me creating a new package, all you have to do is right click on your main package, go to new and then package. Likewise, when I'm creating a new class, you have to pick Java class from here and you can switch between interfaces and classes right from this menu. Another thing that didn't work in my previous recording was the code generation thing. So whenever you are creating a new model, you can use the alt insert key combination, sorry, inside that class of course, let's get rid of the constructor and you can use alt insert and you can then generate a constructor, you can generate getters and setters and equals and hash code, two strings and all those boilerplate methods. So what I did in those videos is I picked constructor and then I just ignored all these properties since you are trying to create an empty constructor and then press OK. So a good chunk of the course, if you see all these sub menus are invisible, just don't be alarmed, it was some problem with my recorder, everything should work as is in your computer. Now back to the past. As you can see, IntelliJ idea has finally finished resolving all the dependencies in my project, so I am finally ready to write some code. Now before we start writing Java code, I'd like to address something really important. I hope that you remember back when we are generating our project, we didn't add all the dependencies to our project because I wanted to show you how you can manually add dependencies later on. So this is the time we do that. First open up your pom.xml and find this dependencies part. Like that, you can see that there are three dependencies already described. You may recognize the Spring Boot starter web and Spring Boot dev tools dependencies from a few moments ago when we added them to our project. But there is also another thing called Spring Boot starter test. Now this is for testing our code and in this course we are not going to talk about that. Now the first dependency that we need to add to our project is called the Spring Boot starter data Neo4j and the group ID will be org.springframework.boot. Now IntelliJ idea is being really generous here and helping us out with writing the dependencies, but I suggest that you make sure that you are typing them out correctly because if you make a typo or write wrong name then you may end up not getting a dependency or even worse getting the wrong dependency. Now the second dependency that we need is called the Neo4j Java driver and the group is org.neo4j.driver. Now whenever you add or remove a dependency from your pom.xml file you have to right click on the pom.xml file, find maven and reload project. Depending on how many dependencies you have added or removed from your project the resolving process may take a while but in my case it has finished in a flash. Now I will close the pom.xml file and start creating the packages that we will need. Now inside our main package def.faham.springboot.neo4j it may be something else in your case but inside our main package we will create four new packages. The first one will be called config then we will create another package called models then we will have the repositories then we will have the services and our controllers. Now these are not the only packages that we are going to need we will also need some packages to hold our query results, our data transfer objects, our requests and things like that but we will work on them later. For now these are the ones that we need. Now once you have all the package ready to go let's create the model for our first node which in this case will be the course. So let's create a new java class and call it course then inside we will define all the necessary properties of this class. So the first one is an id and it has to be of type long then we will have private string identifier which we used uniquely identifier our courses then private string title and private string teacher then we will create a constructor now you may write the constructor by hand but inside IntelliJ you can just press on alt and then insert to bring up this nice generate menu from here you can select constructor and for our constructor we will not select any of the properties. Now for spring data Neo4j this is one of the requirements that you create an empty constructor inside your model classes so this is what we are going to do then we will say alt insert and we will select getters and setters and we will highlight identifier title and teacher we will not highlight id and why you will understand in a bit click OK and now we have all the getters and setters for our private properties. Now creating a class like this will not suffice we will also have to annotate this class with a node annotation this way spring boot will know that this class is actually a Neo4j node and has to be managed by the dependency injection system then inside the class we will also annotate the id with two separate annotations the first one has to be the id annotation to let a spring boot know that this is the id for the node and then we will say generated value which means we want this value to be automatically generated and we do not want to write it by hand. Now since this id is an automatically generated value we do not need a setter for it and since we are not going to use this to uniquely identify our course we are going to use this string identifier instead we can just get rid of the getter as well. So now that we have a course class the next thing to create is a repository so let's go inside the repositories package go to new java class and we will call this course repository and it has to be an interface by the way once you have created the interface it is going to extend the Neo4j repository interface which comes with our dependency and this is a generic and inside we will write the name of the class that we are working with which is course and we will also write the data type of the id of this course so in our case it will be lot. Now this way of creating a new repository is nothing unique to Neo4j actually if you have experience with Spring Boot in the past and you have worked with databases like MongoDB or MySQL you may have created interfaces like this. Now let's close our repository and model and let's go inside our service we will create another java class called course service and we will have to annotate this class with the service annotation and inside this class we will need a reference to our course repository so we will say private final course repository course repository you can name it anything and then we will generate a new constructor where we will take the repository now that's it now since we have annotated this service class with the service annotation and also the repository extends the base Neo4j repository this will be automatically injected into our class. Now inside here we will create another public method we will say public and it is going to return a list of courses get all courses you can name it anything by the way then we will say return course repository dot find all that's it finally we will create a controller by the way if you think that I'm going to fast just be patient once I have created the model repository service and controller for the course I will explain the entire workflow or the architecture of the application what I am planning to do and what you should do in any of your Spring Boot applications. So finally I will create a controller new java class and it will be called course controller now I need to annotate this class with the rest controller annotation so Spring Boot knows that this is actually a rest controller and this is going to describe a few endpoints then I will say request mapping this another annotation and I will describe the general endpoint so I will say slash API slash v1 slash courses excellent now inside this public class I will create a private reference to our service class so I will say private final course service course service then I will generate my constructor and I will create my first method which will be public and it will return our response entity yes response entity of type list course I will explain what it is in a bit just just hold on for a little longer and I will call my method course index you can call it anything this is just going to list out all the courses in our application and then we will say return new response entity and inside here I will call course service dot get all courses then comma HTTP status dot ok and with a semicolon then I will also have to annotate this class with a get mapping call and this let's let's take a final look at our application and make sure that the code is working fine yeah that that looks ok now we have a model that describes the course node in our database and as I have said few times already in our database the courses have an ID which is an auto generated field we have a string identifier a title and teacher then we will need an empty constructor for all our models then we have some getters and setters to work with this model we create a repository interface which in turn extends the Neo4j repository interface now what is this interface actually to see what this contains we can press on the control button and then click on this repository once you are inside the source code you can see it gives us a few useful methods and one of them is find all so whenever I am going to call find all in this repository it will actually return all the courses in our database in a list format as you can see it says list t there is also find all by ID there is also find all with a sort functionality so we can sort the courses so this is what a repository supports there is also a save all method but let's ignore that for now now since we have a repository we can use it inside a service you do not want to use your repositories inside a controller directly because that's not a good thing to do you should always create a service layer that talks to the repositories and use that service inside your controller layer always remember that controllers should be responsible for taking and giving back data they should not worry themselves about the underlying architecture of your database or your models or anything like that so in this case we have a service class that makes a reference to our course repository and we have a single method that gets all the courses for us one thing that I'd like to mention here that you may have seen the auto wired annotation that comes with the spring boot and maybe instead of creating a constructor like this I could have just annotated this field with auto wired but in some cases that's not the best thing to do now since we have our service we will go to our controller that describes a single endpoint which is api slash v1 slash courses inside this method we are just returning a new response entity this is one of the classes that comes with spring boot and you can use it to return a response to the user and this response entity thing takes two things one is body and the other is the status code now for body we are giving it the list of the course since it's a response entity of type list course and for status code maybe we have written 200 by by hand but instead of using some magic number what we are doing here we are using the value of ok inside HTTP status this is actually an enum this enum here actually describes a lot of other status codes as you can see it has continue it has switching protocol processing checkpoint ok created accepted we are going to use created very soon no content and a lot of other things we are going to make use of this enumerator a lot in our application so technically our application is ready to run and give us the list of courses but we have to make one final adjuster and that is we have to let the application know about our database that we have created earlier for that we will need another dependency now the dependency that we need is called spring dot env so we will say dependency and inside artifact id we will write spring dot env and inside group id we will say ne dot all words s c h w a r z ok and we will also describe a version for this dependency subversion 3.0.2 we will save the form dot XML file and use this little button here to load the Maven changes let's click that and wait until the dependencies are being loaded so as you can see it has turned white from red which means the dependencies have been loaded successfully next up we will create a very simple env file inside src main resources and we will just right click on the resources folder new and file we will call it dot env now this env file will contain three values the first one is ora URI the second one is ora user and the third one is ora password now as you may have already guessed the ora URI is a URI to our neo4j server on the cloud the ora user is the name of the user or the username and finally the password is for the password for the database now the ora user is going to be always neo4j and i will just quickly copy that URI and password from my neo4j credentials file okay so i have copied my URI and password from my credentials file and these are going to be different in your case since your instance is different from mine now once you have created this dot env file next up you will need to open the application dot properties file now inside we are going to reference the three env values that we have so i will just say spring dot neo4j dot URI and then a dollar sign curly braces and ora URI next up is spring dot neo4j dot authentication dot username again another dollar sign curly braces and ora user finally we say spring dot neo4j dot authentication dot password it's a dollar sign curly braces or a password now why did we do this why we didn't just put all these values inside our application dot properties class now the thing is these values that URI to your instance the user password and the user name are secret values these are things that you should never put on your github repository since the application dot properties file is a part of your application we will not put our secrets directly into this file instead we are going to create an env file and these three variables will be loaded into our local environment and then the application properties will be able to find them using this dollar sign and curly braces index this is how you actually access any of the environment variable inside your application now i would suggest that you also make a copy of this file and call it dot env dot example then get rid of these values save the example file and make sure that your dot env file is being ignored inside your git ignore file so inside here i will say dot env and i'll say dot env so this will make sure that the dot env file is not added to your github repository instead you will have an example file that you can use a reference to create a new env file okay so since we have our model controller repositories and services in place and we also have our env file created our application should be ready to connect to our database and give us a list of the courses let's test it out now to do so you will have to click on the play button so far it looks like that the application is running fine so what we are going to do is we are going to switch to an http client called insomnia and we will test out our application by sending a request to it now inside insomnia the first thing that you should do is create a new folder because we want to keep our requests organized now i will call it spring boot neo4j and i will move or just just let's get rid of this request now inside this folder i will create a new http request this is going to be a git request of course and this is going to http localhost 8080 slash api slash v1 slash courses i hope that you remember and let's also rename this to git all courses or something like that git all courses it really doesn't matter the difference now let's send a request yeah it looks like we have our list of courses as you can see we had four courses in our database and all of those are being taught by gavin law and the list contains all of them and we also have a 200 okay status code i hope you remember that we had added that little status http status dot okay at the end so that's why you are getting the nice 200 okay responses so congratulations on creating your first api endpoint in this application next up we are going to work on the lessons and we will implement the relationship between the lessons and the courses and we will also make sure that we can see the details of these individual courses along with the list of the lessons so i am back at intelligia idea once again and now we are going to start working on another endpoint for our application so let's go back to controllers now the next endpoint that i want to work on is an endpoint that's going to return the details of a single course so if i go back to insomnia let's make a copy of this request get single course and we will just pick an identifier from all courses request we will put it inside the single request and we want to make something like this now i actually like to start working from the lowest level of our application which in our case are the repositories so i will go back to course repository and inside we are finally going to create a custom method now this custom method will return an optional course and we will call this method find course by identifier and then we'll take a string identifier now the nice thing about these neo4j repositories is the fact that they are really smart so just by the name of this method find course by identifier spring boot will know that we are trying to find a course by using identifier property and we will also need to pass the identifier by string now if i remove this part and i write it again i will say find and as you can see integer idea actually recommends me that find course by so it can sense that maybe we are trying to find a course by some parameter so i'm going to pick find course by and then now it started to suggest me the possible property names and from this list i am going to pick identifier and inside of course we are going to pass the identifier let's say string identifier okay now we have the repository method we will go back to our service which is the one step higher level of a repository and we will say public course and we will call it get course by identifier and we will take the identifier as a string now inside the method we will say return course repository dot find course by identifier identify i hope that you remember that the method actually returns an optional type and we are trying to return a course object from this method so what we are going to do in the second line we will say or else throw so if you do not find this course or if you do not find a course by this identifier throw side there we create a new lambda and we'll say new new response status exception and we'll say HTTP status quote dot value of 404 so what we are saying is first use the find course by identifier method inside the course repository and try to find a course by this identifier the identifier that i have passed and in case you do not find a course using this identifier please throw a 404 not found response exception status that's what we are doing let's close this service and inside our controller we will create a new get mapping public spawns entity of type course and we can call it course details it has to be a get mapping and it will give us an identifier so we are we will get the identifier from here and inside course details i will say path variable which means we are going to get a variable from the path and it will be string identifier yeah that's it you can call it anything else if you want now inside the method what we are going to do is we will say return or or let's just create a course course equals or service dot get course by identifier we will pass our identifier right here and then we'll return a new response entity and we are going to say the course is the body and HTTP status dot okay yeah so that's it what we are doing here is we are getting an identifier in our path we are passing that identifier to our service layer that service layer in turn we'll call our repository and get us the course that we are looking for now essentially this should work so let's try out let's rerun our application go back to insomnia and let's execute the get method that we created a bit earlier let's hit send so as you can see it actually returns the course that we are looking for and if we try to look for a course that doesn't exist for example if I add some garbage here as you can see we are getting a 404 status now we are also getting a trace with it we may configure our exceptional responses later on but for now we will just leave it like that so let's get rid of the garbage let's send once again and yes we are getting the course details now the thing is the response in the course detailed request and the course list request is pretty much the same I think it would be nice if we could get the list of the lessons that belongs to this course inside this details response right let's do that let's finally start working on our lessons so I'll come back to intelligent I will create a new model new java class and it's going to be called lesson this is going to be a node just like before it will have a long id it is going to be the id and also a generated value okay so I will have to import the I think there's something wrong with the id yeah id sorry it didn't get imported first yeah next we would say private string title and private string identifier so these are the three properties that we need next up we will generate our empty constructor and our getter sunsetters yes now before we try to implement our relationship between the lesson and courses let's go back to our database and have a look at how it was mapped now if we focus on a single course here as you can see this course has four lessons and each of these lessons has a belongs to relationship with the course now from the point of view of a single lesson it has an outgoing relationship of type belongs to with its parent course and from the point of view of the course it has an incoming relationship of type belongs to with the lesson now with that information we can actually implement these relationships in our models now back in our code we will open the source code for the course model and we will describe a new property private list list of lesson called lessons plus new error list now this list here is going to be a relationship this is another annotation that comes with the dependency that we have used and the type of the relationship is belongs to like we just saw in our database and the direction from the point of view of the course it's an incoming direction or an incoming relationship so the type of the relationship is belongs to and the direction is relationship dot direction dot incoming now we will need a getter we do not need a setter since we are not going to set this relationship manual we just need a getter now since we have implemented the relationship we have implemented the getter it should work let's rerun the application come back to insomnia make the request once again and as you can see now the course comes back with the list of the lessons as you can see this blazer shopping cart course has four lessons now this is all nice and cool but there is a simple problem so if i go back to the get all courses and make a request as you can see all the courses are coming back with the lessons now depending on what you want from your application this may be something that you expect or you do not expect for example in some places in my application i may not want the list of the lessons at all because whenever a course is coming back with the list of lessons it's actually querying for all these lessons so if i do not use the lessons this did that entire query time that that that time my server is working is going to waste unfortunately there is no way that i know of to leave out a relationship from a query so if you describe a relationship like that you cannot actually lazy load it every time you will query for the courses you will also get the relationship back now this is something that's not that hard to solve actually we can write custom cipher queries to query for the lessons when they are needed and leave them out when we don't to do that first let's get rid of the relationships from the model also remove these because we are not going to use them now at this moment in our code base the courses and lessons are totally unrelated to each other but we have to implement some sort of relationships between them now my idea is that we can have them unrelated in our code base but what we can do is we can actually create another repository it will be another interface let's call it lesson repository it extends the Neo4j repository the object will be lesson and the id will be long and inside this repository we will implement another function that is list lesson this is going to be the return type find lessons by course identifier and we get the identifier as a string okay now we have a method that is going to find a bunch of lessons using a course identifier now the course identifier part is not a property of lesson so we cannot have an automatically built method like this instead what we will do is we will write a very simple cipher query so we'll say query then inside let's begin we'll say match and inside a set of parentheses I will say colon course so we are looking for all the nodes of type course inside I will say identifier identifier so we are looking for a course node that has the same identifier as we have passed to this method now once we have found this course we will need to get an incoming relationship R of type belongs to and the related node should be lessons lesson and finally we have to return the lessons let me explain what we are doing first we are trying to find a course node that has the same identifier as the one we have passed to this method then we are looking for all the lessons that are related to this course using an incoming belongs to relationship now once we have found all the lessons we are putting them inside another variable called lessons and finally we are returning the lessons in fact we can we can get rid of this R variable here since that's not being used anywhere so the only piece of variable that we need is this one here once again we are finding a course by the identifier that we have then we are looking for all the lessons that has an incoming relationship with this course of type belongs to then we are putting those lessons inside the lessons variable and returning them to the user so this is the query that we have here now if everything goes fine it should return a list of the lessons okay the repository is all set let's create a service lesson service this is going to be a service class and inside the class we want a private final lesson repository lesson repository we will have our constructor and we will have public first a list of lesson and the name of the method should be get all lessons by course identifier we will get a string identifier and then inside the method we will say lesson repository dot find lessons by course identifier and we will say identifier that's it and we can just return this directly and yeah that's it that that's all we need in the lesson service then inside the controllers as you can see right now we are returning a course now this is all right but what would be better is if we return a dto or a data transfer object so i'll just rename my config package to objects because we are not going to use the config right now refactor and we will create a new class called course dto so this is a plain java class inside i'll say private string identifier because i want the identifier for the course i want private string and title i want the title for the course private string teacher and private list list of lesson called lessons equals new error list excellent oh it looks like we have to import the lesson class yes finally we will have our constructor an empty constructor for that because we are going to insert all these values later on or you know what we can get all this like this constructor identified yes let's let's take these three and leave out the lessons because we are going to fill it up later next we want to create some getters we need getters for everything and we need a setter for the lesson yes so that's that's all we need for the moment now let's go back to the course controller inside this method instead of returning a course i will set course tto and i have the course here then i will create course tto response course another object equals to new course tto first i will need course dot get identifier next i need the title so course dot get title comma finally course dot get teacher yeah those are the three and then i will say response course dot set lessons and now we need to bring in our private final lesson service lesson service here we need to add lesson service lesson service and inside our constructor I will set this dot lesson service equals lesson service yes we we have that initialized this looks fine to me now inside response course dot set lessons I will say lesson service dot get all lessons by course identifier and course dot get identifier so I will get all the lessons inside this course finally in the return statement instead of course I will just set response course now technically if we have written everything correctly this should give us the list of lessons along with the other course details so I'll just restart my application it has been restarted let's go back to insomnia send a request for a single course and as it looks like we are still getting the list of the lessons but if I go back to get all courses as you can see now there are no lessons at all so inside single course I can get the lessons because I want them to be there and inside get all courses I do not need them so I don't have them at all I hope you have understood how you can write a simple custom cipher query inside java and this is going to be really helpful now creating this course dto class and later on we are going to also create query results class these all things may seem like a lot of work to you but to be honest once you have everything set up you have the code ready to go you will see how easy it is to make changes because you are making sure that you are going you are abiding by the separation of concerns and things like that so okay we have done that now one thing that I'd like to say that the way the front end of our application has been created we actually need the list of lessons in the list of courses as well so what I'm going to do is I'm going to make some changes to it this list or the course index method and make sure that we are getting the list of lessons there as well so I will change it to a course dto and yes the return code return statement won't work anymore so I will copy this I'll say list course once courses sorry courses and I'm getting a list of all the courses in our database then what I'm going to do is I'm going to create another list of the course dto type and this will be the response courses equals I will say courses dot string so I'm going to use the stream API of java then I will call map inside map I will say course it's going to be lambda actually and here I will create a new course dto course dto response course equals two I can actually copy this entire line yes that I can also copy this line after this yes response course dot lessons dot service so now I have a new course dto and I need to return this so I'll say return response course and finally dot collect characters dot to list so what I'm doing here I am getting the list of courses from my database without the lessons then I am mapping through that list accessing each course inside that list of courses I am creating a new dto object I am getting all the lessons for that course and setting that inside my dto object and finally I'm returning that response course from inside this lambda function and once I have returned that I am creating a new list and adding that new response course to that list this is how it goes so finally inside response entity I will just replace this part with response courses HTTP status okay let's save our code and let's restart and see if it works fine or not let's go back to insomnia make a request for all the courses and as you can see all the lessons are back in the course class so this far we have finally implemented the courses we have implemented the lessons we have written some custom cipher query so I think you have done a lot of work already to be honest now next up we are going to implement the user model we will introduce an authentication system to this application so that users can log in and once that done we can finally work on the course enrollments so let's continue working on it now that we have finished implementing the courses and lessons it's time to finally work on the user now before we start writing our code for the user related functionalities we will need to add a new dependency so open up your pom.xml file then write after a spring.env add a new dependency now the name of this dependency will be spring boot starter security and its group id will be simply org.spring framework.boot like all the other starter packages in fact let's do one thing let's cut this chunk of code from here and put it right after the starter data new port shared that way we will have all our starter packs inner in a line and then we will have the other dependencies so once you have added this dependency to your project just hit this load maven changes button okay it looks like the dependency has been resolved now let's try to restart our application and you should see something like this using generated security password the generated password is for development use only and things like that so this means that spring security is actually working now to test it out we can go back to insomnia we can send one of our old requests and you will see that it says 401 unauthorized which means that the spring security system is stopping us from accessing this endpoint now this is totally normal by default spring security stops all the requests to the server but you can use an username and password to get access to the data you want now for that let's go back to our IDE look for your application.properties file inside src main and resources now after the three lines that we added before we will have to add two more lines these are spring.security.user.name and I will set it to Farhan spring.security.user.password equals to password now let's go back to insomnia here you can see there is the auth menu right beside body so I will go inside auth I will click on this arrow and pick basic auth now inside here I will add the username Farhan and password is password then I will send the request okay it looks like we forgot to restart our application so let's do that now insomnia send the request and it worked out just fine but I know what you are thinking this is not the right way to authenticate any request we want to use the users in our database right don't worry we are going to do that but before I just wanted to show you how you can make your request go through the spring security gate now let's disable the authentication okay let's go back to our IDE and start working on a proper authentication system first let's remove these two values close the properties stop our application and minimize the terminal now we will start by creating a new model named user now unlike the models that we have worked on before the user is going to implement an interface so we will write implements user details now this interface is actually part of the security package that we just added and it describes a few methods and properties that makes this model usable for our authentication system so we can hover over it and it says implement methods we will click that and it it shows us a bunch of methods we will say okay and now we have a lot of overrides let's just close this sidebar for more space okay so these are the methods that we want to implement so let's start with get password and get username because those are the easiest one we will say private string username private string password then inside get password we will return password and inside username we will return username excellent now those two have been taken care of next we will add the roles so it's a private string roles i hope that you remember from our database view from before that every single users has a bunch of roles so this is what we are going to do here now once you have added the roles we want to implement the get authorities method which is this one now this is sort of an special kind of method that actually returns all the authorities or roles for this user now you may have seen that i had added a role user value to our users in our database but you can have something like role admin role teacher and so on you can also have role admin comma role teacher role moderator and so on but for now we are dealing with a single role now this method here it returns a collection and that extends the granted authority interface so what we need to do is we will say return we need the arrays class from java.util and then we will say dot stream inside the stream method we need our roles so the roles that we have defined here we'll say roles.split and we want to split it by a comma because remember we can have roles like this role admin role teacher so we want to split it using this comma after splitting let's come to the next line and we will say map we will say simple granted authority which is a class and we will add new at the end and dot to list see and we are returning this list so what we are doing here we are getting the value of the roles string from this user we are splitting the string using the commas so just in case you decide to add multiple roles to this user and then we are mapping through that new you know splitted string and creating new simple granted authorities using the string value that we get from our map call finally once we have multiple or a single simple granted authority instance we are adding them to a list and returning that list from this method so since list are part of collections this checks out now if you are confused about this method i would suggest that you do some more study on how spring security works and how you can implement multiple roles for users so that's a bit out of the scope of this course so this is what we have to do now next up let's go inside is account nonexpire we want to return true here then is account nonlocked yes we want to return true is credentials nonexpired true and also is the account enabled yes true so that's it we have successfully implemented the user details interface but other than these three we also need an id and we need a private string name for the user now like the other models this id is going to be an id and it is going to be a generated value and we will need a getter and setter for our name so let's come at the end of all these overrides or maybe maybe here let's come to this place and we'll say alt insert we will generate a getter for our id no i mean our name we will also need a setter for our name there you go now in the case of this user model we will actually use our id field so we will also add a getter for that and since we are going to create new users we will also need setters for our username and password and roles so let's scroll down and come to get password and i will come after it and insert a setter for our password there we have it next after the get username i will insert a setter for our username and finally we do not have a get roles method but we have this one so i will just come after this and i will put a setter for our roles there you go it looks like the model is ready to be used and you know what let's just generate a getter for our roles as well because even though we have this get authorities method we may also need a plain old getter for our roles string so let's just add the getter and it looks like everything has been set up finally i i would just like to check the generate menu once again to see if we have anything left yeah we have left id setter but we are not going to need that so once you are done with that let's just close this and we will now create a new package called config next up let's create a new repository so i will right click on the repositories package creating a java class it has to be an interface and name it user repository like the other repositories i want to extend new 4j repository and that's all we need for now we will come back to this because we will add two more custom queries to this repository but those are not needed at the moment finally we will go inside service and we are going to create an special service for our authentication system so we will create a new class called neo user details service you may call it something else like neo4j user details service the thing is this is going to be an user detail service that we will in turn use with spring security so we have this class and it's going to implement another interface called user details service and just like the model we will implement the methods there is only one method load user by username and that's pretty much it so as you can say from the name of this method these can return a user using its username so for that we will go back to our user repository we will create a method that returns an optional user and we will call it find user sorry i have made a mistake we will have to tell it the name of the model as well as the type of id we are using all right now we can say find user by username we will receive the username as and string this is very simple method and that's all we need now inside our new user details service i will explain why we need this class in a bit but for now just write the class along with me so i will create a private final user repository then i will have a constructor there you go and then as you can see this method here returns the type user details this is one of the interfaces that comes with the spring security framework so instead of returning null what we are going to do is return sorry user repository dot or let's come to the next line find user by username we will pass the username that we have here and then on the third line we will say or else throw and inside the method we will create a new lambda new username not found exception and we will pass a message username not found then can just add the username to the message yeah so that's what we have so as you can see the user details service interface implements a method called load user by username so what we are doing here we are using our repository instance and we are calling the find user by username method now it returns an optional user so if we have the user then we will return it and if we do not have the user then we will throw a new username not found exception and we have to throw this exception because by the definition of this interface this method has to throw a username not found exception in cases where the username is not found so that's all we need here now finally we are going to write the big chunk of authentication code that we will need to use our database instead of some preset user so go inside project i will collapse everything then go inside source main java and as you can see i have a package called config so i will right click and create a new class called security config by the way the service class that we created has to be annotated with the service annotation yeah so all the service classes have been annotated okay so inside the security config class we have to annotate it with configuration then enable web security okay then inside the class we will create a private final new user details service we will have a constructor and then we are going to create a bin and that bin is of type security filter chain new security filter chain it will receive HTTP security this one we will call it HTTP security and this throws an exception okay let's annotate with the bin annotation so that neo4j will handle the task of instantiating this class and everything inside this method we will create a new security filter chain once we have finished working on it you will understand what it actually does so we'll say return HTTP security this one then dot session management inside we will say session create a new lambda session dot session creation policy then session creation policy dot stateless because since we are creating an API the authentication has to be stateless then we are going to disable CSRF protection because we don't need that for that we will use abstract HTTP configurator yes this one and disable okay then on the next line we will say course because we are going to customize our course customizer dot with defaults so course will be configured with the default settings finally we'll say authorize HTTP requests inside we'll say auth and auth dot it will say request matchers yes and inside the request matchers we will say api slash v1 slash auth slash me okay let's leave it to that for now we will add more routes to it later i'll say dot authenticated and dot any request dot permit off finally we will finish this by saying user details service neo user details service dot HTTP basic customizer dot with defaults and dot built ah that's a lot of code right so let us take a look and try to understand what's happening here so by default the spring security framework uses a security filter chain that logs any request to your server you will have to authenticate for every single request to the server and we do not want that also in the default security filter chain it uses your application dot properties file or a randomly generated user as an authenticable user we also do not want that we want to use the users in our database so for that we will need to create a new security filter chain that will essentially define how we want to secure our application so inside this bin i hope you understand what beans are beans are just java classes that are managed by the spring boot framework so we are creating a new bin that is of type security filter chain and it throws an exception okay so inside this bin we are saying return HTTP security which is of type HTTP security this is one of the classes that comes with the spring security framework and the first thing that we are doing is we are making the session stateless i know this is a long line but all this does is it makes the sessions stateless so we do not hold any session data whatsoever then we are disabling the CSRF securities because since it is an API and we essentially do not have any web interfaces within this particular application or service we can successfully disable the CSRF protection then we are configuring cores so in an application where there is no spring boot security framework you have to customize your core settings somewhere else but since we are using spring boot security this framework is going to intercept the request first and then it will pass it to the application or other configures so we have to configure the cores right in the security filter chain configuration thing so right now we are customizing the core settings with the default ones but we are going to change it very soon then we are saying authorize HTTP request so this is the method where we will define which routes has to be protected by our application and which routes do not need to be protected so inside we have an auth object and we are using the request matchers method to say that hey spring boot security you have to protect any request to this particular endpoint we haven't created this endpoint here and you only need to stop any request coming to this endpoint and all the other requesters any requests just permit them to connect so when we get a request in this particular endpoint it needs to be authenticated any other request should be permitted now next up we will actually configure our parse configurations so we will say parse configure or cause configuration source yes this one we want this one and then we will say cause configuration source we will start the method and we will annotate with a bin now inside this bin we will say parse configuration parse configurations equals to new parse configuration so we are creating a new course configuration then we are going to change things in this configuration so we will say course configuration dot set allowed origins so which origins are we allowing so i will just say array let's check what it takes so it looks like it takes a list of the strings so i will say array okay dot as list arrays dot as list and i will create a string HTTP local host 3000 and also just in case HTTP 127.0.0.1 which is localhost as well 3000 so i have been made aware by Gavin Long that the react application that he will be working on will run on localhost 3000 or 127.0.0.1 port 3000 so what i have done i have allowed these two origins to connect to my to my application now this is one way of doing things to be honest these two values these should be resided inside our.env file but i am not going to do that since i have shown you how to use a.env file i will just add a todo here which says make sure that the origin list comes from an environment file so i would suggest that the viewers or you essentially take this as a challenge and implement this part using an.env file put your code on github and share the link in the comment section i will take my time to go through every single code shared in the comment section and i will make sure that everything is right so this is one of the challenges i will add that as a todo and you can actually click on this button here todo and you can see what challenges i have set so that's one challenge then the second one is cause configuration dot set allowed methods and what methods are we allowing arrays dot as list this also takes a list so this is how you are going to do get and we will do post we will do patch patch then put delete options and hit these are all allowed methods then we'll say cause configuration dot set allowed credentials yes this one and we'll set true nice then we will say cause configuration dot set allowed headers and arrays dot as list authorization request type content and so these are the three headers that we want to allow finally we'll say configuration dot set exposed headers and it will be called arrays dot as list next inside here we will say x get header and lastly we will have cause configuration dot set max h we will let's say let's do it 3600 l so l for long next let's let's just create an url based course configuration source so we'll say url based course configuration source and url based course configuration source calls to new url based course configuration source here try saying that 10 times faster right url based course configuration source yeah i can do that and we will say URL based course configuration source yes dot register course configuration and we want to apply this configuration to all the routes in our application so that's what this pattern means so this is the root and anything that comes up at that then we'll say comma and course configuration yeah nice finally we have to return our URL based course configuration source okay so now we have our course configured one last thing that we have to configure is actually a password encoder so I believe you remember when I showed you our database architecture that we are saving the password for the users as big script encrypted hashes we are not saving plain text passwords because you should never do that so we will need to let the Spring Boot security to know what encoder we are using but to do that I will say password encoder password encoder this is another bean I will annotate this one with bean and then inside the method I will say return new be ripped password encoder and end it there so yes we have done most of things oh by the way I think I have missed this three lines so what we are saying here is we need to let the security filter chain know which user details service are we going to use and in our case we have a custom user details service which is the new user details service and what we have inside this class we have implemented a single method that helps us to use or look for the user so every time some user tries to log into our application the spring security filter chain will use these details service look for the user and then check the password against the hash that we have saved in our database using this password encoder and if it matches it will let the request pass through and if it doesn't it will throw a username not found exception so finally we are going to use an HTTP basic authentication I know this is pretty insecure but for the scope of this project or this application this is totally fine I could have implemented a more sophisticated JWT based authentication but that will take a lot more time and a lot more code so I want to focus more on the on the Neo4j and spring boot connectivity rather than the authentication and security part of the application so this is what we are going for so now that we have configured our security thing let's let's just go ahead and create this endpoint so we will go to project and we will create a new controller and it will be called user controller let's annotate this one as a REST controller and request mapping to API slash p1 slash auth inside we will have a single method for now which will be public logged in user and we will create an endpoint which will be a get mapping and it will be called me finally inside this logged in user we have to define our return type which will be string for now and we will get something called the principal I will explain what principal is and we will say return principal dot get name so okay let's make sure that this endpoint is right so let's go back to our config API v1 auth me so everything checks out hmm okay then let's start our application and try to log in using one of the users in our database right now we are inside our Neo4j dashboard and we can see all the users in our database so I am going to just select John price and the user name is just price now the password for all these users such as Mirza Mikhail or Mac Milan the password is actually password I have already encoded the password using big script and saved the hash so I will just copy the username of John price price and let's go back to our insomnia then right now if I make a request without any authentication it should work because the single course and get all courses endpoints have not been protected I hope that you remember that the only endpoint that is protected right now is the me endpoint so I create a new HTTP request I will call this me HTTP localhost 8080 API slash v1 slash auth slash me and if I send a request as you can see I am getting 401 unauthorized but if I go inside auth select basic auth and as the username I will say price price and for password I will say password let's see if it works or not so as you can see this time we are getting 200 so what's happening here let's go back to our code and let me explain it to you now right now we have a single endpoint called slash API v1 auth me and according to our security configuration this is one of the protected route and we have to be authenticated to hit this route inside this method we are getting a principal object and this principal object usually contains information about what user is authenticated right now so once you send in your username and password our security config will intercept that and pass that to the user details service the user details service in turn will look for an user using the username that we have got from the user and if it finds the username it will give it back otherwise it will throw a username not found exception once the filter chain has found an user it will get the password from that user and check its hash against the password submitted by the user using this password encoder and you may ask how does the filter chain gets the password well if I go back to models user and you will see we have a getter for the password get password and this is a part of the user details interface so that's how it gets the password hash and if the user is giving the right username and password he will pass otherwise he will not pass so that's how this entire authentication system works and if you have done anything right you should be able to authenticate new users to your application now that we have our user we can finally begin working on the enrollment part so if user can actually look at our courses and enroll in the ones that they like so that's what we are going to do now now that our users can log into our system we want to create a way for them to register in our system so we have a way to log in now we need a way to register so before we start writing the code for registering the user I would like to create a few packages and classes now the first one is a package called requests and inside here I will create a new Java class called create user request now I will explain what it will do but just follow along for now then inside this class we will say private string name private string user name private string password private string roads so everything that the user model has except the ID field next up we will create a constructor and this time we will pick all of them and after that I will just create some getters and setters okay the request class is ready let's close that next what we need is a user DTO object so user DTO and this one is going to be really simple private string name private string user name private string roads we do not want to return the password in our responses so we will just leave that out next we want to create the constructor and the getters and setters there you go we have a user DTO now next we need to create a service called user service user service and this one has to be annotated as a new service for sure then we will need a private user repository user repository let's let's make it final and then we will have private final password encoder password encoder because we want to encode our users password then I will have my constructor and a function public and this is going to return a user create user and this will take a create user request not any request but create user request and create a new user so I will say user user equals to new user then I will say user dot set name request dot get name and I hope you remember that we just implemented this get name method inside the create user class so that's why we can use that then user dot set username request dot get username nice user dot set roles request dot get roles user dot set password and this is where the encoder will come in and I will say password encoder dot encode inside there I will say request dot get password so this will take what the password is that we got from the user and then encode it and set it as the user's password finally we would say user repository dot save user the safe method comes with all the repositories and we will return the user that's it we have our service method ready to go let's go to the controller now and here I will say public and then response entity of type user DTO sign up and this will take request body and map that to create user request we'll call it request let's go inside the method and I will say oh I will also need a reference to our private final user service user service and I need my constructor then I can say user service dot create user and I can just pass the request to it and it returns a user then I will create a user DTO response user equals to new user DTO now first I need the name so user dot get name then user dot get user name and user dot get roles that's all I need then I can just return a new response entity and the body will be the response user and the status will be created because we have just created a new user so yeah that's all we need to sign up a new user and this is really easy to do I will have to create a post mapping or register yeah that's all we need now we can go back to insomnia and check if this works so I'll just start my application then I will switch to insomnia and I will create a new request vault register okay this will have a body first we need a name so I will do for home a scene children comma I need an username for home then I need a password and I will need a role string so it will be the whole user make sure you are writing the role like this and then I send the request to HTTP local host API slash v1 slash auth slash register that's it I believe okay let's change it to post and we do not need any authentication for this and let's hit send so looks like a new user has been registered it says 201 and the username is Farhan now there are two ways to verify if the registration has gone through correctly or not first I can go to my me request I can go to basic and instead of price I can say Farhan and the password is password I will say send and it looks like it gives me back Farhan which means the user has been registered to database but still if we quickly switch to our database dashboard then click on user once again it got me back all the users and as you can see Farhan has in show 3 is right here but right now Farhan or me I am NOT enrolled in any of the courses so next we are going to work with the enrollment process and we are make we are going to make sure that all the users can actually enroll in a class but before that I would like to give another challenge for you so if I go back to the user service as you can see right now I am NOT checking if this username has been already registered or not so I will leave it to you so that you can figure out how to check if a thing exists on the database using spring boot data or spring data repositories and make a decision on that so I will add another to do and I will say make sure that these username does assist and let's just come back from here and I put that over the username so this is another to do that I am leaving out for you I will look forward to any submission in in the comment section and I will actually let you know if anything is wrong with the code so let's close that and start working on our enrollment process now before I write anything in my services or in my controllers I would like to make sure that we have all the necessary queries in our repositories for example in order to enroll user in a new course we will have to create a new relationship between the user and the course so like I showed you before you can actually do that through the models but in this case I am going to create a custom query that will have a custom query result and you can use that to create a new enrollment relationship so for that I will go to my repositories and then user repositories and I will write two methods here the first one is going to be a boolean and it will be called find enrollment status so you can use this method to check whether a user is already enrolled in a course or not and I will take a string username and I will also take a string identifier which is the course identifier in our case so we are going to write a custom query just like we did before and it will go something like match user user or this has to be a string of course comma there'll be a course course and then fire user dot username equals dollar sign username so this variable right here and user sorry course dot identifier equals dollar sign identifier right here this variable so what we are doing is we are querying for a user that has the same user name as we have passed to this method and then we are looking for a course that has the same identifier as we have passed in this method and we are saving the user in a variable called user and the course in a variable called course next we want to give a space and then enter so that we can begin on the next line and then we'll say return exists we will say user and rolled in yeah that's pretty much it so what we are doing is we are looking for a user and course against the username and identifier that we have and then we are checking if there is any outgoing relationship from the user with the course of type enrolled in so I believe you remember that back when we are designing our database we had a relationship called enrolled in and it was an outgoing relationship from the point of view of the user and an incoming relationship from the point of view of the course so there we go we can use this use this method to check whether a user is already enrolled in a course next up we want to create a query that we can use to create a new enrollment now before we do that we need another class so we will create a new package query results and inside that we will create a new class called course enrollment query request or query result sorry query result now this is a very simple class we will say private user user private course course and we need to import these classes obviously yes okay we have both the classes then we will have an empty constructor like that and we will have some getters and setters so alt insert and getter and setter both of these so there you go we have a course enrollment query result object now if I come back and I create a new method and this is going to return a course enrollment query result I would call it create enrollment relationship basically you want to be explicit with your names and I will need a username also I will need an identifier now the first bit of this query is identical to this one so what I am going to do is I will copy this entire match part come inside this method I will say query put it in space and then enter now on the next line I would like to say create user in fact you can just copy this this part here so we are going to we are going to create a new outgoing relationship from the user to the course of type enrolled in then finally we'd like to return the user and the course now as you can see this query returns a really complex data it returns an user object and it also returns a course object so like other custom queries like this one we cannot just say that these returns a boolean type instead we had to create our own custom class that has an user object and a course object and use that as the result of this query so this is how you can map complex queries to custom meant classes okay so our user repository is now ready to go I believe we can enroll our users to classes now but we cannot just put the code for course enrollment inside the user service or user controller or the course controller at all instead what we are going to do is we will create a new service called course enrollment service and it will be a class a service class then inside there we will have a few methods now the first method that we have but before that we will need a private final course repository course repository and private final user repository user repository now this service can access both repositories because we are going to work with both courses and enrollment but if we had to put this code inside the core service then we would need to unnecessarily refer to the user repository inside the course core service that doesn't feel good at all that's why we have a separate service for you know creating the enrollments so inside we will have a constructor and we will have a few methods now the first method would be public boolean get enrollment status and for that we will need a username and a course identifier then inside the method we will just say return course repository dot check sorry user repository dot find enrollment status and we will pass it the user name and the course identifier so this way we can use this method to check if a given username is enrolled in a course or not now the next thing we need is public and this is going to return a course enrollment query result and it will be called enroll in and it will also need a username and a course identifier okay we will return user repository dot create enrollment relationship username and identify okay so yeah we are done with these two methods we will need one last method that is we need public list of courses and we will call it get all enrolled course by user name a string username and a string identifier okay so what this method is going to do is if we give it a username it will give us back the list of courses that user is enrolled in and I just realized we really do not need the identifier now we do not have a repository method for this so let's go to our course repository and create a new method this will return a list of courses and we will call it find all enrolled courses by username and we receive a string username and then we can say query match we are trying to match a user where the username is username so this is another way of doing a query or query clause so we will have a user with the same username that has been passed to this method then once we have that node we want to get enrolled in courses course so we want to get all the courses that has an outgoing relationship with this user of type enrolled in and I'm saving all those courses in the forces variable and I will just return forces and we will also import the list method java.util of course and yet that's it so let's go back here and we will say return course repository dot find all enrolled course by username and we'll just pass the username so that's it we have our course enrollment service ready to go we can use it to enroll our users in a new course we can get the enrollment status of a user and we can also get all the enrolled courses by username and I just realized it should be courses and not just course so there you go okay now I think we are ready to create a new controller the controller will be named course enrollment controller like the other ones it's going to be a rest controller for sure okay let's just go back to our service class for a bit course enrollment service and yeah we have annotated it yeah and we will do a request mapping API slash v1 slash enrollment now this enrollments endpoint these need to be protected because if you go back to our service for example course enrollment service you can see all these methods needs to know that username of the currently authenticated user so for that we need to protect this route so we will leave the controller open and get back to config and security config let's let's close this and come to the request matchers part I will put a comma and I will say API slash v1 slash enrollments slash double star which means anything that comes after API slash v1 slash enrollment slash anything should be authenticated or protected let's close that and inside our controller class we will need a few services so I will say private final course enrollment service course enrollment service and we will also need private final lesson service lesson service because we will need to know what lessons are part of a certain course now I will have my constructor and we can start working on the endpoints now the first one I want to do is I want to let the user enroll in a course so for that I will say public response entity of type course enrollment DTO and we need to create this class create class course enrollment DTO and we want to put it inside the objects package and here we have our DTO we need string private string user name so the user name of the user that has just enrolled in the course private is string name of the user private course and the course that the user just enrolled in then we will have a constructor and we will have the getters and setters yeah that's pretty much it so you want to return a course enrollment DTO and we will call our method enroll in now what we are going to take we are going to take the request body request body and we will create another request called course enrollment request let's hover over it and create type parameter course enrollment request you know what let's just copy the name go to project go to requests create a new class or course enrollment request and inside this we need private string identifier this is the course identifier of course and we will generate a constructor and the getters and setters okay let's go back to our code request body course enrollment request so we will have our course enrollment request comma another thing that we need is the principal sorry I forgot to name this so I will get principal principal because this is how you get the username of the authenticated user now inside this method we will say course enrollment query result let's call it enrollment query result yes equals we will say course enrollment service dot enroll in what is the user name the principal dot get name and what is the identifier request dot get identifier terrible we have a new enrollment request query right query result now we cannot just return this query result for a button or verbatim rather we will need a new DTO called course enrollment DTO now I will over operate some more action okay let's again just copy this photo project go inside objects how it looks like we have a course enrollment DTO create I just forgot about this so what I will do is course enrollment DTO we have that yeah I just forgot that we created this so response enrollment equals new the first thing that we need to pass is the username so we will say enrollment query result dot get user dot get username because our query result has a get user method that in turn returns a get username method and we can use that to get the name of the user or the username of the user next up we have the name of the user so enrollment query result dot get user once again dot get name and you know what this line is getting too big so I will just put it in the next line comma let's bring down here yeah much better enrollment query request dot get course that's pretty much it or we need the username name and the course finally we can say return new response entity the body will be the response enrollment and the HTTP status should be okay but it really depends upon you since we have created a new relationship you could have also returned created here but I'm going to just return okay now this is going to be a post mapping let's try and enroll our user in a course okay let's check our request once again we just need an identifier so that's what we are going to do I will go back to my insomnia client I will create a new request called enroll this is going to be HTTP localhost 8080 slash API slash v1 slash enrollments and inside this has to be a post request by the way and inside the body we need an identifier so let's go inside get single course this one go back to enroll and we'll put it here let's click on send yeah I just remembered I didn't restart my code so let's go back to IDEA and do that and I will send nice we are getting a 401 unauthorized response because we are not authenticating any user so I will go to basic auth I add Farhan and password is password let's send the request so it looks like that we should leave the course enrollment request as an empty constructor instead of taking the identifier as one of its parameters because if we do that the request may or not work so I am keeping it empty and now when I try to create an enrollment from insomnia it just works as you can see Farhan has been enrolled in Blazor shopping cart application course so to verify we can quickly go to our RDD dashboard and if we click on enrolled in we should see that Farhan has seen cho3 is now enrolled in the Blazor shopping cart course now other than verifying from the database itself we also want a way to get the list of all the courses a user has been enrolled in so we have already created a service method for that so let's just go back to our controller and implement that so here inside our controller we will create a new gate mapping method so public response entity this is going to be a list of the course DTO and we will call it enrollments we will take the principal because we need the username and inside this method we will say list course so courses equals course enrollment service dot get all enrolled course by username and we will say principal dot get name now we have a list of courses that the user has been enrolled in on the next line we will say just like before a list of course DTO and response courses equals courses dot stream dot map inside the map method we will say course this is a lambda course sorry course DTO response course equals new course DTO and we need an identifier title and teacher name so I will say course dot get identifier course dot get title and course dot get teacher and then I can just return response course and finally after this curly brace and the last parentheses I will say collect collectors dot to list so this is just like we did before with the courses list so I'm not going to again explain this and I will say return new response entity response courses comma HTTP status dot okay all right we this is a get mapping of course there you go let's restart our application go back to insomnia make a copy of the enroll request and call it in roll meant turn it into a get request get rid of the identifier make sure that we are authenticating and let's hit send okay so looks like we have a list of the courses that this user has been enrolled in what we need is we need the list of lessons too so let's go back to our controller I'm going to steal some code from the course controller class I hope you remember inside this one we actually made use of the lesson service so I'll copy this line I will go back to course enrollment controller and put it down here course enrollment dot set lesson and then return the response course we will rerun the application we will go back to insomnia resend our request and this time we are actually getting the list of all the lessons as well now that's pretty much it we have done a lot with our applications except I want to implement one last thing in in our code so I you may remember that we have implemented the code necessary for a service and repository method that returns a boolean based on whether an user is enrolled in a course or not so in our list of courses I would like to add a new boolean variable here that says enrolled in and that will return true if the user is enrolled in a course and false in case he or she is not enrolled in a course so let's go back to our code what we can do is we will go back to our course DTO and inside we want to add a new boolean so private boolean let's use a primitive type and is in rolled that's it now we will need a getter and setter for this one yes we got that now let's go back to course enrollment controller and we will say response course dot set enrolled and we are going to hard code it to true since the user just enrolled in this course we know for sure that this is going to be true so we will not make another database request and just write it as true but inside our course controller we will actually have to do a database call for that we will take the principal and we will add a check here we will say if principal is not null then response course dot set enrolled inside we will say we need another service private final course enrollment service course enrollment service and we'll say course enrollment service yes that's a lot of boilerplate to be honest course enrollment service yeah so inside set enrolled we will say course enrollment service dot get enrollment status and principal dot get name and course dot get identifier so we are checking whether the user has enrolled in the course or not now why we are checking for principal is null or not I hope you remember that in our course index anyone can see the list of our courses because it's an open directory so in case we do not get any principal or authenticated user we will just set it to false a set enrolled and if we get a principal we will set it to whatever the database returns so I will rerun the application and show you how it works let's quickly switch to insomnia and get all courses but as you can see it says enrolled false in all of these because I am NOT logged in but if I log into my account for Han password and hit send you will see that it says true on the blazer shopping cart application and falls in all of the other ones now why we are here I thought I will make one little adjustment to our code that is in enroll we are sending something called an identifier now this is not clear I think what would be better if we could call it course identity fire this is a lot better I think so I will go back to my code go inside the course enrollment request right click on the identifier and go inside refactor rename so instead of identifier I would like to call it course identifier I'll hit enter yeah these are all the references and get course identifier course and yes we are going to let's make sure that these are right yeah let's see it okay let's rerun our application and see everything works fine or not okay it looks fine so that's pretty much it we have successfully implemented the ability to enroll in a new course the user can get the list of enrollments the user can register the user can sign in and see the lessons in the course now on the next part of this course Gavin long will walk you through the entire process of creating and react app based on this API he will show how you can use the identifiers to get the corresponding YouTube videos and how you can basically create a course management system frontend for yourself powered by my API now one last challenge that I would like to leave for the user is inside the services and course enrollment service before we enroll our user in a course we need to make sure that the user has not been enrolled in the course already so this is something that we have to make sure right now if you try to enroll the same user twice in a course you will create two relationships to the same course so it will get you will get double results so what you should do is you should check whether the user has already been enrolled in the course using the game enrollment status maybe I don't know I'm giving a hint and then you should enroll the user in the course or return something else now this is another challenge that I'm leaving up to you so if you go inside to do you will get three todos and one is in the config and two is in the services so make sure that you are completing your challenges it will give you a lot more confidence to be honest and you will learn a lot from your researchers make sure that you leave the link to your repository in the comment section below I will come there I will check the core submissions and I think it would be a nice conversation between us so I hope that throughout this entire course or this part of the course you have learned something about the Neo4j database which truly is an amazing technology you have learned how to create an API powered by Neo4j on Spring Boot and a few other things here and there on how to structure your application how to use an IDE and things like that so if you ever need any help just give me a shout out in the comment section I would love to help and best of luck for the rest of the course Gavin Lon is an amazing instructor and I can say for sure that you will have a great time so until the next time take care and be careful bye before we get started with coding this react application I need to let you know that I've had to make a few assumptions regarding the knowledge and experience of the viewers of this part of the course so ideally the viewer of this part of the course should have at least a basic knowledge of react JavaScript HTML and CSS so let's start with the very basics we of course need a code editor for writing our react code I will be using Visual Studio code for Windows for this purpose you can download Visual Studio code for Windows from this URL in order to run our code locally we need to install node.js you can install node.js from this URL node.js is an open source crossplatform JavaScript runtime environment we need a local working directory to house our applications code so please create a working folder in a location of your choosing on your computer and let's give our working folder a sensible name my working folder for this project is curriculum mngt management client so curriculum mngt client then let's open the working directory for our project within Visual Studio code note we can check what version of node we have installed while we're in Visual Studio code we can do this by first launching the terminal window launch the terminal window by pressing control and the tilde character then at the command prompt type nodev and press enter great and we can see what version of node we have installed on our computers an easy way to set up a react project is to use the createreactapp command we can use this command to generate the infrastructure for our react application when I say infrastructure I mean the node modules that are necessary for harnessing foundational react functionality is generated through the use of the create react app command there are other ways perhaps better ways of creating the foundations for a react project like for example using a technology named VIT for this purpose if you are interested please read more about VIT at this location using the create react app command provides a simple way to create a react project so I'm going to use the create react app command for this purpose at the command prompt type npx create react app followed by a sensible name for your react application I'm going to name my react application curriculum dash mngt mngt of course stands for management then let's press the enter key this process may take a while so this will give you an opportunity to contemplate life the universe okay you don't have to do that but you may want to get yourself a cup of tea or something like that while you wait okay great and you can see that the foundation for our react project has been generated the node modules directory has been created which contains all the react dependencies and packages needed to build and run a react project as you can see a new route directory for our project has been generated that is of the name that we gave our application when we ran the create react app command so for better clarity let's open another instance of visual studio code where the newly created project directory is the root directory within visual studio code to do this let's make sure the terminal window is launched remember you can do this by pressing the control key and the tilde key then at the command prompt make sure the current projects working directory is the current directory at the command prompt then type CD space and then the root directory of the react project then press the enter key now at the command prompt type code followed by space and then the period character then press the enter key this will result in a new instance of visual studio code being presented and now the react project folder is the root directory now let's close the previously launched instance of visual studio code the create react app command has generated the infrastructure for our react project but has also generated a few files that we don't need so let's delete the following files that we don't need report web vitals.js set up tests.js and app.test.js we must also delete the ESLint config setting from the package.json file here let's save our changes then lastly let's open the index.js file and delete the code regarding report web vitals great so we are now ready to develop our react application so at the moment we have very basic functionality that has been generated for us by default through the use of the create react app command so let's ensure that we start off on a good footing as it were this lets us know that all is working as it should be before we start developing our application so to launch the react app in our default browsers we can type npm space start at the command prompt and press the enter key great and we can see the react logo spinning which means we are good to go so let's start creating the code for our application within the SRC directory where the source code will reside let's create a subdirectory named components as you have probably guessed we are going to create our react components within the components directory let's also create a directory within the SRC directory named images please download this image from this location on github and ensure that this image file resides within the images directory we are going to use this image as our hero image on our home page so this image will be referenced from within the home component the first react component we are going to create is the home component this component denotes the page that will first be displayed when our application is first launched so let's create a directory within the components folder named home the first letter of this folder name should be in lowercase within the home folder let's create a file named home.js the first letter of this file should be an uppercase so we can use a shortcut to generate boilerplate code for our home component to do this type rafce like this within the code editor and press the enter key note that in order to utilize the rafce shortcut you must first install the appropriate react snippets extension if this extension is currently not installed this installation can easily be done through the extensions tab within visual studio code at the top of the home.js file let's import the hero image from within the images directory like this let's include an image tag within the JSX code returned from the home component then let's open the app.js file let's import the home component into the app component with this line of code let's delete the code that we don't need but ensure that we leave the div root element that contains the class name attribute that references the app.css class then let's appropriately reference the home element by including the home tag within the div parent tag like this let's type npm start to fire up our application great but the image looks huge and is not displayed appropriately for our hero image so we are going to use bootstrap to style this hero image so to install bootstrap type this command at your command prompt and press enter to have access throughout our application to relevant bootstrap classes we must include this import statement within the index.js file now within the root div tag of the home component let's include the class name attribute and set it to the bootstrap class named container like this let's run our code what's happening here is the image is still too large for its container element so to remedy this let's create a scoped CSS style sheet for the home component so let's create a file within the home directory named home.css within the home.css file let's create a reference to the relevant image within the container div tag like this and let's set the image width to 100% within the home component let's create a reference to the home.css file with this line of code let's type NPM start at the terminal prompt to launch our application and that is much better great so that is a great start but we are also going to need some other thirdparty packages dependencies in order to integrate certain functionality into our application for example we want to install the react root to DOM package that will be instrumental in the global management of our menu and link functionality our navigation functionality we are going to use the react player component for displaying videos that denote lessons for our courses to our users we'll use Axios to manage our client interactions with a serverside web API component so here we have used bootstraps container class to house our hero image so that it is appropriately displayed within our home component as a hero image we can also leverage bootstrap by using components that reside within the react bootstrap package we will look at using such components a bit later in this video for now let's install react bootstrap to install react bootstrap type NPM space I space react dash bootstrap and press the enter key great let's install the Axios library we are going to use Axios for making our HTTP client requests to the relevant serverside endpoints so as to return the relevant data from the Neo4j database that hosts the relevant curriculum data that we want to display to our users we'll also use Axios to implement the enroll functionality ie this is functionality whereby a user can enroll in a particular course we could use the windows.fetch function which is available by default within our browsers for this purpose instead of Axios but Axios provides us with key advantages please navigate to this URL if you'd like to learn more about these key advantages this link is available below in the description of this video to install Axios type NPM space install space Axios and then press the enter key the next packages I would like to install allow us to leverage font awesome from within our react applications so at the command prompt please type NPM space I space at Fort Awesome forward slash react dash font awesome and then press the enter key let's install one more font awesome related package to do this type NPM space I space at Fort Awesome forward slash free dash solid dash SVG dash icons and then press the enter key great we'll look at the details of using the relevant font dash awesome functionality a little bit later in this video the next component I want to install is react player this will allow us to play YouTube videos from within our react application the individual lessons within the courses in which our user is enrolled will be presented to the user as videos these videos reside on the YouTube platform so to install react player type NPM space I space react dash player at the command prompt and then press the enter key then let's install react router Dom which allows us to leverage rich navigation and routing functionality from within our react application to install react router Dom at your command prompt please type NPM space I space react dash router Dom and then press the enter key if we open the package dot JSON file you can see the relevant dependencies that we have just installed great so let's create the navigation bar that will appear at the top of our applications UI so this can be referred to as the header for our application the navigation bar will contain a register and login button and relevant navigation menu options so let's create a folder within the components directory named header please ensure that the H in header used to name our folder is in lowercase let's create the file for the header component and let's name it header dot JS where the H is an uppercase so we are going to use font awesome in this component to display a graduation cap as the logo for our application which will appear in the top left hand corner of the user's screen so let's write code to import the relevant font awesome components then we are going to use react bootstrap for our buttons so let's import the button component from the react bootstrap package with this line of code we are going to use the container component for layout purposes let's import the nav component from react bootstrap which will be used for layout and styling purposes let's also import the navbar component for the purpose of styling our navigation display lastly let's import the use navigate hook and the nav link component from the react rootadom package so that we can leverage the relevant react rootadom functionality for navigation purposes let's change this div tag to be a navbar tag within the navbar element let's include a container element let's include the fluid keyword within the container element this will ensure that the navigation bar spans the entire width of the web page rather than placed centrally within the web page let's reference the navbar dot brand react bootstrap element and set its class name property to the menu dash link bootstrap class like this then let's include the graduation cap font awesome icon like this as a child element of the navbar dot brand element this icon serves as our applications logo let's include the navbar dot toggle element here which will allow the navigation to be shown and hidden through a toggle mechanism made available to the user on smaller screen sizes so as you can see bootstrap is great for responsive layouts so let's include the nav element and let's style the nav element appropriately let's include the button component to represent our login button the variant property is set to info as a style choice let's set the class name property to a bootstrap class named me2 this is so that our buttons are spaced appropriately let's include the register button which will appear to the right of the login button on our navigation bar and let's style the register button in the same way that we have styled the login button right let's open the app dot JS file and firstly make sure that we are importing the header component into the app component then let's include the header element reference just above the home tag within the JSX code that will be returned from the app component let's use npm start to launch the application so that we can view what our navigation bar currently looks like great okay because our navigation bar is currently white our brand icon is also white so we can't currently see our graduation cap brand so let's change the color to red for now great okay so I want to make the background for our application as black and address styling features that I'd like to apply to all of our components one way we can do this is to include the relevant styling code within the app dot CSS file which is referenced by the app component the app component is the parent component for all our bespoke child components so the styles included within the app dot CSS file will propagate to all the app components child components so let's firstly import the quicksand font from Google through this line of code we want the quicksand font to be applied for our entire web application let's use the star like this to indicate the following CSS properties apply to the root tag for our single page application so let's first set the border dash sizing property to border box if you set the box dash sizing property to border box on elements like this the padding and border values are included in the width and height properties for the relevant elements let's set the font dash family property to quicksand right let's create the styling for the app element let's set the app root elements background color to black let's set the color for our text to white let's set the top margin for the app element to 10 pixels let's launch the app you great you okay so let's create the component that will house the registration functionality this component will contain a form that the user can fill out to register the user's relevant details with the system including the user's name username and password the fields on the form will be name username password and confirm password we'll incorporate regular expressions into this dialogue for the purpose of validating each of these fields each of these fields will be validated in real time ie as the user enters the relevant information into the relevant text box controls so let's start by creating a folder named register within the components folder let's add a file named register.js within the register folder and let's also create a file named register CSS let's go to the register component let's import the use state hook and the use ref hook into our component so the use state hook is used to track the state of relevant variables when the state for a particular variable changes reacts detects this and rerenders the relevant component in the user's browser this use ref hook will be used to reference a text box form control let's import relevant react bootstrap components you let's import relevant font awesome components let's use rafce to generate the boilerplate code for our register component let's declare a constant named name ref which will be used to reference the name text box control let's use the use state hook to monitor a variable named name the set name function will be used to change the state of the name variable the name variable will be bound as it were to the relevant text box control where the user will enter the user's name let's include a boolean variable for the purpose of monitoring the valid or invalid state of the text value entered into the name control by the user let's create two variables that are used for the same functionality as the previous two variables that we have created but are applied to the username text box control so when the username is deemed as valid the valid username variable is set to true conversely when the username variables value is deemed as invalid the valid username value is set to false let's do the same for the password or pwd field ie create two appropriate variables where their state is tracked let's do the same regarding the confirm password field which is used to validate if the confirm password field matches the password field so I've already prepared the regular expressions for the relevant fields off screen please feel free to copy the relevant regular expressions from this location on github so let's set a constant to the regular expression that will be used for validating the name field please remember if you get stuck or you wish to copy and paste the code rather than following along with creating the code line by line with me you are able to copy the relevant code from a github repository available at this location so this regular expression will ensure that the name field has at least two characters and no numbers are included so let's include the regular expression for the username field the validation criterion for this regular expression means that the username must be between 8 to 20 characters long no underscore or period characters are included at the beginning no double underscore or underscore period characters or period underscore characters or dot dot characters are included within the field and no underscore or dot characters appear at the end of the word so this regular expression is used for the password field this regular expression means that in order for the password field to be deemed as valid a minimum of eight characters must be included the password must include at least one letter one number and one special character so let's apply the use effect hook so that a function that we'll write that is passed as an argument to the use effect hook is fired when the register component first loads so the use effect hook accepts two arguments the first argument is the function to be fired and the second argument determines when the function is fired so we want the function passed in as the first argument to be fired when the register component is first loaded so we can achieve this by passing in empty square brackets as an argument to the second parameter of the use effect hook so we want the name control to receive focus when the register component first loads we can achieve this with this line of code we'll write the code to create the relevant form controls including the name control in just a bit and this will of course be implemented within the JSX section of this component let's use the use effect hook to monitor the state of the name variable which will be changed with every key press that the user makes within the name text box which as I've said will be created soon so to do this we pass a function as the first arguments to the use effect hook that we want fired when the state of the name variable changes then in order to tell react as it were that we only want the relevant function to fire when the name variable state changes we can pass the name variable within square brackets as the second arguments to the use effect hook note that the test method is executed on the relevant regular expression to ascertain whether or not the name entered by the user is valid or not the result returned from this line of code will either be true or false we can then set the state of the valid name boolean variable to the result returned from the test function we'll create UI functionality to show that the name field is valid or invalid in just a bit so we are providing the user with realtime validation feedback as the user types the user's name into the name field then let's apply another use effect hook to perform similar functionality for the user name let's apply another use effect hook to check that the password is valid or invalid based on the relevant regular expression then we must also check whether the password field matches the confirm password field note that within the array passed in as an arguments to the second parameter of the use effect hook is the variable representing the password field and the variable representing the confirm password field so this means that each time the password or confirm password fields change the relevant validation functionality is executed we'll wire up the relevant variables to their counterpart text box form controls in just a bit you'll see that the on change event of the relevant form controls is used for this purpose right so let's create the JSX code within the relevant section of the register component let's create a container component let's create an appropriate heading let's create a main element and a div element within the main element please include the relevant class name attributes and values within the relevant elements let's include the react bootstrap form element so each text box control will reside within a form dot group element which will also include a label control so let's create the relevant code for the name text box control the form dot label element contains a span element here we have a ternary operator that shows all hides either a font awesome times icon or a tick icon based on whether the valid name variable is true or false so this span element will be shown to the user based on whether the span elements class name property references the CSS class named valid or the CSS class named hide we'll create these CSS classes in just a bit so if the valid name value is true the FA check icon is displayed next to the name text box control conversely if the valid name variable is set to false this span element is displayed to the user which means the FA times or a cross icon is displayed to the user indicating that what the user has entered into the name field is currently invalid then let's create the text box control for the name field like this note that we are setting the ref property to the name ref const this allows us to reference the text box within the relevant use effect hook where we have created code so that the name text box is given focus when the register component first loads then the on change event is wired up to an arrow function that sets the tracked name variable every time the user changes the text entered within the name text box let's create the form control code for the username field which contains similar functionality let's create the form control code for the password field and the confirm password field let's create the code for a submit button so we want to disable this submit button while any of the relevant form fields are not valid so let's set the relevant disabled property to this boolean expression so before we test the validation code for our register form let's set up the roots for our application so that we can navigate to the register component through the navigation bar that has been created within our header component so let's open the app.js file let's import the roots component and the root component from within the React router DOM package let's include the roots element below the header element we want the header element to appear regardless of where the user navigates to within our application so we need the header appropriately displayed outside the roots element within the roots element let's include the relevant roots where we can tell React router DOM as it were about the paths of our components we haven't yet created the layout component so let's do that now the layout component provides instructions to react as it were regarding the overall layout of the relevant components that are mapped to relevant roots let's import the layout component we also need to create a root for the app component and we must do this within the index.js file we need to wrap this route within the browser router component as well as the roots component like this let's go back to the header component and create code so that when the register button is clicked that the register component is appropriately loaded let's create a const named navigate that is assigned a function returned from the use navigate hook let's create a reusable function named handle nav let's use the navigate function to navigate the user to a path passed in to the handle nav function let's pass in the relevant path to the register components to the handle nav function so when the register button is clicked the register component is loaded let's test the code okay so to fix this issue we need to correct a typo here where we have incorrectly named the regular expression const pertaining to the username field great but in order for our validation to work as expected we need to create the relevant CSS classes let's make sure that we import the register.css file into the register component let's open the register.css file and create the code for the relevant CSS classes let's create the CSS code for the register dash container class which will make sure the layout for the register dialog is appropriate we are using the flexgrid functionality to appropriately handle the layout let's include the register dash layout class to handle the layout for the register form let's include the valid class so that the elements referencing this class are appropriately displayed let's include the hide class so the elements referencing this class are appropriately hidden let's include a class named invalid dash icon to display the times or cross font awesome icon in red let's include a class named valid dash icon to display the checked icon or tick font awesome icon in green let's include a class named register dash message which will style a displayed message to the user that is centrally aligned and in white text the appropriate text will display once a user has successfully registered let's test the UI validation functionality for the name field let's test the UI validation functionality for the user name field okay so we have an issue the name field is also being affected this should not be happening let's look at the code okay so within this user fact hook lies the problem we are currently using the set valid name function here whereas we should of course be using the set valid user name function here so let's fix this great let's test the password field and the confirm password field validation functionality oops and of course the password control should be of type password and not text we must of course also make the same fix for the confirm password control excellent so let's go back to the register CSS file and make sure our register form is responsive on smaller screen sizes so let's use an appropriate media query for this purpose excellent so now we want to interface with the Neo4j database hosted in the cloud so we are going to download the code for the HTTP based web API component written in Java to our local machine so we are going to host the web API component on our local machines just to make the development of our application a bit easier this web API component is hosted using spring boot in order to be able to run this code locally on a Windows computer you must ensure that you have the Java JDK installed on your local machine if you don't yet have the Java JDK installed please navigate to this URL then follow the instructions for installing the Java JDK Java JDK version 20 or version 17 should be fine the next step is to clone the GitHub repository at this URL onto your local machine this GitHub repository contains the Java code for the relevant web API so we are hosting the serverside code on our local machines we are connecting to a Neo4j database hosted in the cloud from our local machines please remember the local directory that contains the cloned GitHub repository code we need to run a command at the command line later on to run the relevant web API component as stated before this will be run locally please ensure that you have configured the web API component correctly to point to the Neo4j database that you have created if you are unsure of how to do this please follow the relevant instructions provided in the previous part of this course the values I'm showing you here will of course not apply to your particular environment for now let's create the clientside react code to connect to the locally hosted web API component so let's create a folder within the SRC folder named API within the API folder let's create a file named axiosconfig.js let's first write code for importing axios let's create the code to set up the axiosclient component so let's add the base URL property and set it to localhost port 8080 which is where we will be able to connect to the relevant web API endpoints this web API component of course handles calls to the relevant Neo4j database that is hosted in the cloud let's create appropriate code for the headers property now let's go to the register component and import the axiosclient component let's create a JavaScript function named post data we must include the E dot prevent default line of code for when submitting a form from within a react component because we'll be using the on submit event for the submission of the register form then let's create an object that encapsulates the data entered by the user I'm going to hard code the roles value here which is okay for demo purposes but you'd want to handle this field more appropriately for a production environment for example you could have a list of roles presented to the user in a list box control and the user can select the relevant role from the list box control right so we can write code for post requests using the axiosclient component like this so we are simply posting the object we have just created to an appropriate endpoint created for handling the register post request we can include basic error handling code through the use of try catch code and we can output an appropriate message to the user regarding whether the user has been registered successfully or not let's include code at the bottom of the form to display this registration status information let's first set the submit success message appropriately based on the response returned from the server side code and at the bottom of the register form let's write the code to display the relevant message saved within the submit success variable so let's set the min height property of the app parent component so that it extends to the bottom of the web page and we can do this by setting the min height property here so that its minimum height is 100 VH so the result of this is that the background color will be black regardless of which component is loaded because the relevant components are all child components of the app parent component and of course we must wire up the on submit event to an appropriate event handler so we are wiring up the on submit event to the post data method within the form element like this okay so to run the web API component on your computer you can run this command at your command prompt so launch the command prompt as administrator change the current directory to the root directory of where you cloned the relevant Java code locally just a reminder the relevance Java code can be found at this location on github so once you have done that type this command at your command prompt and press enter after you press the enter key you should see similar information to the information displayed on my screen logged to your screen let's run the react code and see if we can register a user oops we have a bug here we are referencing a control named PWD with the object that we are attempting to post the PWD field doesn't exist because we named the relevant field password so let's fix this we have successfully registered a user so we are now successfully communicating from the react client code with the Java serverside code which for development purposes we are currently hosting on our local machines so we have successfully registered a user the next logical step is to create the login functionality let's create a folder named login and let's ensure that the first character is lowercase within the login folder let's create a file named login.js and let's ensure that the first character of the file name is an uppercase let's create the file within the login folder named login.css right let's write the code for the login component let's reference the login.css file let's import the relevant dependencies let's import the use state, use effect and use ref hooks from react let's import the container component from the react bootstrap package let's import the button component from the react bootstrap package let's import the form component from the react bootstrap package let's appropriately import the axios client component let's import the use navigate hook the link component and the use location hook from react root to DOM let's create the boilerplate code for our component by appropriately typing rafce and pressing the enter key great let's create a const named navigate and assign it a value returned from the use navigate hook we will be able to use the function assigned to the navigate const in code for navigation purposes let's assign a value returned from the use ref hook to the user ref const this will allow us to reference a specific form control within a function we'll look at this functionality in just a bit in order to track the state of the username let's use the use state hook for this purpose so user is a variable we want tracked by react and we must use the set user function to change the state of the user variable let's use the use state hook to track the state of the entered password let's use the use effect hook so that a function executes when the login component first loads the code for this function simply sets the username field to have the focus and this happens when the login component is first loaded let's create the UI code for our login component within the JSX section of our component so let's first reference the react bootstrap container component so that our login form is housed as it were within an element that references the container bootstrap style let's create a heading for our login form for styling purposes let's create a main element and within that a div element within these elements our references to appropriate CSS classes we will create the code for these CSS classes in just a bit so like with the registration dialog we create a form element and within the form element the relevant form controls within form dot group elements these components are imported from the react bootstrap package and we are using them for layout and styling purposes so each of the form groups contain a label and a text box so we have the username field and the password field within the login form note how we are using the on change event to change the state of relevant variables as the user changes the text within the relevant text box controls let's reference the button component and this button will serve as the login forms submit button please remember if you get lost at any point while following along the full code is available at this location on github the link to this github repository is available in the description of this video let's create an arrow function to handle the submit functionality so let's use this code to reference the values that the user has entered into the username field and the password field let's implement basic exception handling through the use of try catch functionality basic authentication has been implemented in the web API component please navigate to this URL if you'd like to learn more about basic authentication so in terms of basic authentication we must encode the username and password values in a particular format before we submit a particular HTTP request to the serverside code in order to implement basic authentication on the client we are going to pass the username and password in a particular format through the header of a HTTP GET request for this particular login component the relevant format for the username and password is username colon password this is essential for basic authentication we must also encode the username colon password value in base 64 encoding we can use JavaScript's BTOA function for this purpose so let's create a const named B64 encode and assign it the value of username colon password that is base 64 encoded using the BTOA JavaScript function the next step is to create an object representing the header information that will be passed to the relevant web API endpoint so let's create a const named config and set it to an object to represent appropriate HTTP header information this object contains a property named headers which is set to an object with a property named authorization the authorization property is set to the text value basic followed by a space followed by the base 64 encoded username colon password text value note we are wrapping the value assigned to the authorization property in backtick characters so that we can interpolate the relevant text value this means we can include a variable within the backtick characters by wrapping the variable within curly brackets and preceding the curly brackets with the dollar symbol let's create a request to the relevant endpoint using axios note we are passing in the username and password through a HTTP GET request made to the relevant endpoint through the config object the config object contains the authentication details for the user which is appropriately added to the header of the relevant HTTP GET request so before we test the login functionality let's make sure that an appropriate route is set up for the login component so let's open the app dot JS file and include the code for the relevant route let's import the login component into the app component and include code that represents the route for the login component let's open the header dot JS file and include navigation functionality in this component so that the user can navigate to the login component by clicking the login button displayed on the navigation bar let's test the code we have a few issues here so let's fix these issues please see the relevant GitHub code at this location if you get stuck on any issues this is the main issue here this should be used state and not use ref there are also a few other issues that need to be fixed so let's fix these issues let's run the code so we have our login form presented to the user but it doesn't look great we'll fix this in just a bit so off screen I registered a user named Henry Jameson please feel free to register your own users while testing I'm going to test the login functionality using Henry Jameson's credentials I'm going to use a simple JavaScript alert to ensure that the HTTP status sent back from the relevant endpoint is 200 meaning that the HTTP request has been successfully processed on the server excellent we have received a response with a status code of 200 so we've received a HTTP response with a status code of 200 meaning success so next let's style the login screen appropriately let's open the login dot CSS file let's style the CSS class named login dash container we are using the flex grid for styling and layout purposes the flex grid is great for creating responsive UI code for various screen sizes let's create the login dash layout CSS class we are also using the flex grid functionality here note that we are setting the flex direction property to column which means the relevant elements will stack one on top of the other in a column layout by default if the flex direction property is not set this setting defaults to row this means the relevant elements are presented one next to the other in a row layout let's give each of these form dot group elements suitable margin bottom settings using bootstrap so that we are creating appropriate spacing between the form groups so that our layout here is a bit neater great let's include an error message at the bottom of our form for if something goes wrong during the authentication process so let's set the state of an appropriate error message based on the response provided by the server so if a status code of 200 is returned from the server the state of the error message variable can be set to an empty string or if the status code does not indicate success or an error is thrown we can set the error message variable appropriately to indicate that the login has failed on the server if an exception is thrown we can include the error message that has been caught within the try catch block then let's output the value stored in the error message variable to the screen at the bottom of the login form you you let's dial the error message display appropriately so to test this I'm going to force a 404 exception meaning that the relevant endpoint is not found by changing the endpoint path to something that is incorrect great lastly let's ensure that our login form looks good on smaller screens so to do this within the login CSS file let's include appropriate media query functionality you let's include code here to automatically navigate the user to the home page once the user has successfully logged in excellent great so once the user has been authenticated we want our other components to know as it were that the user is logged into the system so the best way to do this is through the use of context react context is a way to manage state globally so very basically we use react context so that other components will be able to retrieve a value from a global store and assess whether a user is logged into the system or not logged into the system for more information about react context please navigate to this URL so in order to create context let's create a folder named context within the SRC folder within the context folder let's create a file named auth provider.js let's import the create context function and the use state hook from react let's set a const named auth context to a value returned from the create context method like this note that we are passing an empty object to the create context function let's write code to export a component named auth provider note that this code simply means that the auth variable and set auth function will be passed down to all components that are wrapped by the auth provider component so this makes these accessible to the relevant child components that are wrapped by the auth provider parent component we'll look at this in just a bit so what this means is that all relevant components will be able to access the auth variable within all relevant child components if the auth variable is not null this means that the relevant user has been authenticated ie logged onto the system of course the state of the auth variable is managed through the use of the use state hook implemented within the auth provider component let's create a folder named hooks within the SRC folder within the hooks folder let's create a hook named use auth this code basically allows relevant components to access the auth context which means access is provided to the auth variable and the set auth function the set auth function of course is used for changing the state of the auth variable so to log in you change the state of the auth variable and to log out you appropriately change the state of the auth variable by setting it to null the auth variable state indicates whether the user is logged into the system and the set auth function can be used to change the state of the auth variable so the set auth function can essentially be used to log the user into the system or out of the system let's Let's create a hook named Use Axios Private. So the code for the hook is created so that the client code can retrieve an appropriate Axios client object that automatically includes an appropriate HTTP header containing the loggedon user's credentials. These credentials are appropriately formatted for basic authentication. So the returned Axios client object from this hook must be used for accessing protected resources on the server, i.e. retrieved through the relevant API endpoints. These protected resources require basic authentication to be performed before returning relevant data to the client. Now the code here creates what's known as an interceptor, so if the Use Axios Private hook is used from within client code to reference the Axios client, the login credentials are automatically injected into the header of the relevant HTTP request. So this means that the client code doesn't need to inject this authentication header information every time a HTTP request is made to an endpoint. This interceptor code does this automatically. Just a reminder, if you get stuck creating this code, please reference the relevant code at this GitHub repository location. So, the next step is to open the index.js file and wrap all the relevant components within the auth provider parent component. As discussed, this allows the child components, or makes provisions for the child components, to easily access the auth variable so that the relevant component can access whether the user is logged into the system or not logged into the system. So let's look at how this works. Let's open the home.js file. Let's import the use auth hook. Let's use the use auth hook to return the auth variable and the set auth function from the relevant context global store. Now within the UI.jsx code section of the home component, we can check the auth variable to see if the user is logged into the system, like this. So if the user is logged into the system, the code displays a message on the screen. You are logged in. If the user is not logged into the system, the code displays the hero image to the screen. So let's open the login.js file and use the use auth hook to return the set auth function from the context. Let's use the set auth function to assign an appropriate object to the auth variable. This object contains the username and password. So once the user is successfully authenticated, an object containing the user's username and password is passed into the set auth function, which effectively changes the state of the auth variable, which indicates, of course, that the user is logged into the system. So you can see that now this global context can be used to retrieve the username and password from this object, ie the object that we have just passed in to the set auth function to change the state of the auth variable. The username and password can now be injected into the header of HTTP requests through the interceptor functionality that we have implemented in the use Axios private hook. Let's run the code. Let's register a new user named Brandon Lowe. Okay, the password here is password one exclamation mark. Let's then log into the system. Excellent. So let's create our logout functionality within the header component. Let's retrieve the auth variable and the set auth function from the use auth hook. So if the auth dot user property is not null, this means that the user is logged into the system. So we want a logout button to be displayed in the navigation bar rather than the login and registration buttons. When a user is logged into the system, we only want the login and registration buttons presented to the user when the user is not logged into the system. Let's create a function for when the logout button is clicked. So let's create this logout function. Within this function, we can simply set the auth variable to null by using the set auth function for this purpose. This effectively means that the user is now logged out of the system. Then let's also implement code to navigate the user to the home component. Right, let's log into the system. Great. Let's log out of the system. Excellent. So let's create the code within the home component so that when the user is authenticated, a list of courses is displayed to the user rather than the hero image. Let's create code using the use state hook so that React monitors the state of a variable named course data. We can change the state of the course data variable using the set course data function returned from the use state hook. Let's use the use Axios private hook to return a reference to the Axios client that we are going to use to request a list of courses from the server. Note, we are getting a reference to the Axios client using the use Axios private hook. Because the use Axios private hook contains functionality that will automatically inject the logged on user's credentials into the header of the relevant HTTP request. So each request to the server requires the user's credentials so that basic authentication can be appropriately performed. This is because the course data is a protected resource. So the user must be authenticated before this course information is passed from server to client. Remember, implemented within the use Axios private hook is interceptor functionality. So the HTTP request is intercepted and the relevant authentication information is injected into the header of the HTTP request before the relevant HTTP request is made to the server. So let's create a JavaScript arrow function named fetch courses. So here a get request is made. And once the results are returned, we are using the set course data function to appropriately change the state of the course data variable. This results in the home component rerendering, which means a list of courses will be displayed on the UI once the data becomes available and the set course data function is appropriately called to change the state of the course data variable. We'll implement the code for displaying the course data on the UI in just a bit. Let's use the use a fet hook to call the fetch data function when the home component first loads. But we only want the fetch data function to be called if the user is logged into the system. Let's display the course data value in an alert to test our HTTP GET request. Let's run the code. Oops, we currently are not importing the use state hook. Let's fix this. We now have a 404 error. This is occurring because we need to include a forward slash at the end of the endpoint path here. Let's try again. And we are getting the expected JSON results with a now alert. This means our HTTP request is working as expected. Right, so let's write the code for displaying the course data on the UI. So in the return section of the home component, let's implement the code for displaying the course data. I'm going to create this code fairly quickly with minimal explanation. So we are using the map function here to iterate through the courses list returned from the server. This courses list is stored within the course data variable. So I'm deliberately not providing a lot of explanation here. Please note that this part of the course is not a detailed guide on Bootstrap or even React for that matter. This part of the course has been created for the purpose of placing the advantages provided through the use of the Neo4j graph database management system in the context of a webbased application. Please feel free to copy the relevant code from GitHub. The first map function, let's refer to this as the parent map function, traverses the list of courses. Note that we are outputting the title for each course within the parent map function. This title property will be returned from the relevant endpoint. Within the parent map function, another map function is implemented that traverses a list of lessons. The lessons make up the relevant course. So we are outputting the title of the course as a heading. A list of lessons is outputted for each of the relevant courses underneath the relevant heading. So essentially the data is grouped by course. The title for each course and the course's lessons are outputted to the UI. Bootstrap is being used for layout and styling purposes. Note that we are setting the key property for this element to the identifier property for each course. When using the map function, it is always a good idea to appropriately set the React key property for the relevant element like this. This helps React to be more efficient when considering the component. We are also appropriately setting the key property for the element here related to each lesson. We are setting the key property here to the identifier of each lesson. Let's test the code. Okay, we have an issue here. So to fix this issue, we need to import the link component from the React Rooted DOM package. We are using the link component to wrap the title for each course. This is because we are going to create a component responsible for displaying course details for each individual course in a bit. Once this is done, we will point this link to the relevant course component, where the details for the relevant individual course will be outputted. This will allow a user to click the header for a course and for the course details for the relevant course to be displayed after the user clicks the relevant link on the homepage. You can see we have four courses currently saved to the system. So let's create a component that displays the course details for a particular course. So from a UX user experience perspective, the user will click on the course heading on the homepage and will be navigated to a component that displays the course details for the relevant course. Let's create a folder named course and a file within the course folder named course.js. Let's generate the boilerplate code for the course component. Let's open the app.js file and include an appropriate route for our course component. Note that this component accepts a parameter passed into the course component, which is an identifier for a particular course. So to tell the React router DOM system as it were about the relevant identifier parameter, we can include a colon followed by the name of the parameter, identifier, at the end of the relevant route path, like this. Let's go back to the course.js file. Let's include the relevant imports. I'm not going to explain this import code as we have already covered this while creating code for the other components, all except for the use params hook. We are going to use the use params hook to extract a parameter value that will be passed into this component from the home component when a user clicks on a course heading. So let's create a value from the use params hook. We can then use the params object to retrieve the name of the parameter that we named identifier. Let's create a tracked variable named course data. We can use the set course data function to change the state of the course data variable. Of course, when the state of the variable returned from the use state hook is changed, this results in the relevant component being rerendered. Let's use the use Axios private hook to get a reference to the Axios client where an interceptor is employed to inject the user's authentication details into the HTTP header for any HTTP request made using the Axios client returned from the use Axios private hook. Let's use the use effect hook so that we can execute code that retrieves data for the relevant course when the course component first loads. Let's use an alert to output the results returned from the relevant get request. Within the home.js file, let's include the appropriate path to the course component within the relevant link component like this. Note we are including the course identifier as part of the path assigned to the to property of the link element. Let's test the code. Great, the results are outputted through a JavaScript alert. The JavaScript alert is of course just used for testing purposes. Let's create the UI code in the part of the course component that returns JSX code. So the code is very similar to the code within the JSX section of the home component. So to speed things up, I'm just going to copy and paste the relevant code from the home component into the course component. And let's adapt the code appropriately for the course component. So the difference between the relevant code in the home component and the relevant code in the course component is that only one specific course is displayed in the course component, whereas a list of all courses are outputted from the home component. Just a reminder, if you get lost while creating the code for any part of this application, please reference the code that can be found at this location on GitHub. Note that for our course component, we are also including the instructor that teaches the relevant course. This data is returned from the server in the teacher property. So the course component only ever returns one course rather than a list of courses that are displayed within the home component. So we copy this code from the home component, which is currently incorrect for the course component. We need to replace the D variable here with course data because the D references an item in a list of courses in the home component. This course data variable represents one particular course. Excellent. The next component that I want to create is used for the purpose of displaying only the list of courses in which the logged on user is enrolled. So let's create a folder within the components folder named enrolled courses. Within the enrolled courses folder, let's create a JavaScript file named enrolled courses.js. Let's copy and paste the relevant imports from the home component. So for this component, I'm going to copy most of the code from the home component as the code is very similar. The only difference is that we are calling a different endpoint on the server to get the relevant course data. In this case, only a list of courses in which the logged on user is enrolled will be displayed to the user. Just a reminder, you can of course get the finished code from the relevant GitHub repository. Let's include an appropriate root component for the enrolled courses component within the app.js file like this. Now let's open the header.js file and include code so that a link to the home component and the enrolled courses component will appear within the navigation bar at the top of the UI. In order for our links to be displayed in white text, let's include the following properties within the navbar element like this. So on smaller screens, this navigation bar doesn't currently look very good. So let's wrap the relevant navigation elements within the nav collapse element so that on smaller screens the navigation bar responds appropriately. Great! We copy this code from the home component and we of course don't need this code that outputs the hero image in the enrolled courses component. So let's delete this code here. Currently, when we click on the enrolled courses link, no data is displayed. And this is an expected result because the logged on user has not enrolled in any courses. So let's create the functionality so that a user can enroll in courses. We'll implement this functionality from within the course component. So let's create code that displays a button within the course component that is labeled enroll. This button must only display if the enrolled property for a particular course object returns false, which denotes that the logged on user is not currently enrolled in the relevant course. So when this button is clicked, we want a function named enroll to be executed. The code for this enroll function will of course enroll the logged on user into the relevant course. So let's create the enroll function. You can see that we are using a HTTP POST request to post the course identifier wrapped in an object to a specific endpoint. The server side functionality written in Java interacts with the Neo4j database management system appropriately in order to create the appropriate relationship between the user and the relevant course. So if the endpoint returns a status response of 200, meaning success, let's display this message to the user, which simply thanks the user for enrolling in the chosen course. And let's include codes to navigate the user to the enrolled courses component. Let's test this functionality. So each of the lessons listed for the enrolled courses must have a play button icon next to it. When the user clicks the play button icon, the lesson that has been created as a YouTube video will be displayed to the user through the video component that we are about to create. So the play button is implemented using the fund awesome icon component. The font awesome icon element is wrapped by the link element, the link elements to property is set to the path of the video component that we will create. The lessons identifier is passed in as a parameter to the video component. When the relevant video link is clicked, the play button icon denotes this link on the front end. So in the home component, we are currently handling what to output to the screen, the hero image is displayed when the user is not logged into the system, and a list of courses is displayed when the user is logged into the system. When the user clicks the enrolled courses link, this is currently not being handled appropriately. We want the login screen presented to the user if the enrolled courses link is clicked, while the user is not logged into the system, then when the user logs into the system, we want the user to be navigated to the enrolled courses component rather than the home component. So let's implement the code to handle this scenario. Let's first create a component within the components folder named required auth. This component is responsible for navigating the user to the login screen if auth is null, i.e. the user is not logged into the system. And let's open the app.js file and wrap the enrolled courses route with the required auth element like this. So the user will not be able to access the enrolled courses component unless the user is logged into the system. If the user tries to click the relevant link, the user will be presented with the login screen so this forces the user to log in in order to see the user's enrolled courses. And once the user logs in, the user is navigated directly to the enrolled courses component, which means the user can see the list of courses in which the user has been enrolled. Within the login component, we need to create the navigation code so that when the user logs in, the user is navigated to the component that the user tried to access prior to being redirected to the login screen. In this particular case, this would be the enrolled courses component. Let's test this code, great! So the last component that I want to create is of course the video component. This component uses the react player component to play the lessons that have been created as videos on YouTube to the user. Let's create a folder named video. Let's create a file within this folder named video.js. And let's create another file within the video folder named video.css. The code for implementing the play video functionality is very basic. Let's use the use param hook so that we can retrieve the YouTube video ID that will be passed into the component, like this. Let's open the app.js file and include the appropriate route so that the react router DOM system as it were knows how to navigate the user to the video component as well as pass in the appropriate parameter to the video component. The parameter value will be the YouTube video ID pertaining to the relevant lesson. This includes the react player element appropriately within the video component so that the relevant YouTube video plays immediately. We are setting the playing property to true for the react player element for this purpose. Then let's set the URL property appropriately to point to the relevant video on YouTube. Note that the URL includes the YouTube ID that is passed in as a parameter to this component. Let's style the video component appropriately. In fact, let's test the code. I'd like to introduce you to this exciting new Unity for Beginners course, where we'll create a game using Unity and C sharp over a series of videos. All the software that we'll use including Unity and VS Code can be downloaded free of charge. This course is totally free. Hi and welcome. I'm Gavin Lon. The rigid body component allows us to apply physics to a game object, for example gravity. But we are going to write code in the update method to apply a forward force to the player game object in response to the user pressing down. The W key on the user's keyboard. So to improve the user's experience, you can include a spinner that appears to the user while data is being loaded. So in fact, the last component that we'll create could be the spinner component. So when the data is loading, we present the user with a spinner. And then when the relevant data becomes available, the spinner component disappears and the data is displayed to the user. So for this purpose, I've created a spinner component. Please reference the relevant code on GitHub if you'd like to include this spinner functionality within your application. I'm going to fast forward the creation of the spinner component, as this is purely a bonus piece of code that you can study at your own pace if you are interested. To implement the spinner, we are simply creating a React component, relevant CSS code to style and animate the spinner. And functionality within the relevant components to appropriately show and hide the spinner. The showing and hiding of the spinner is implemented using a boolean variable, where the state of the relevant variable is tracked through the use of the use state hook from within the relevant components showing or hiding the spinner. Please review the code in detail at the relevant GitHub repository location. The link to the relevant repository is available below in the description of this video. We can pass in the relevant boolean value as a prop to the spinner component to indicate to the spinner component to be visible or hidden, like this. Let's integrate the spinner component into the enrolled courses component. Thank you. you you Hi and welcome! I'm Gavin Lawn. This is part two in a course where we'll create a game using Csharp in Unity. In part one, I demonstrated the... ...actually making the game, at runtime, more robust. For details on Csharp data types, I've included a link to a Csharp tutorial on Csharp data. So, I'm going to finish the code for this application by styling the header of the courses displayed in the home component. The course component and the enrolled courses component. I'm including the relevant CSS classes within the app.css file, so that the classes affect all of these components. I know the UI for this application is not beautiful. But the purpose of this part of the course is to place an application that takes advantage of a Neo4j graph database management system for the purpose of managing relationships between data entities in the context of a webbased application. My challenge to you is to fork the GitHub repository that contains the code that I've demonstrated in this part of the course and abstract the common parts of the JSX code contained in the home component, the course component and the enrolled courses component into relevant child components. One suggestion is to create a reusable child component for an individual course. You can then use appropriate props to dynamically customize the new child course component based on its context, i.e. its parent component. For example, in the enrolled courses component, a play button appears next to every lesson for each course. Whereas in the home component, these play buttons are not included next to any of the lessons for each course. So the new course child component will need to account for these two scenarios and dynamically output the appropriate JSX code. I hope that you've enjoyed this part of the course and have learned a little bit about creating a client react application that interfaces with a web API component through Axios where basic authentication is employed. Thank you and take care.
