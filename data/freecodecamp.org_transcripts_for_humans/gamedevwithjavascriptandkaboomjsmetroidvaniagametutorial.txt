With timestamps:

00:00 - learn to use JavaScript and Kaboom JS to
00:02 - build a metrov Vania Style game in this
00:05 - tutorial from JS Legend Dev you'll learn
00:08 - everything from setting up your
00:09 - development environment to implementing
00:12 - complex game mechanics like enemy Ai and
00:15 - boss battles you'll learn how to load
00:17 - assets Define scenes manage game objects
00:20 - and more all while creating a dynamic
00:22 - and engaging Game World by the end of
00:25 - this course you'll have the skills and
00:27 - knowledge to bring your own metrov Vania
00:29 - game to life and deploy it for others to
00:32 - enjoy hi everyone welcome to this new
00:34 - tutorial today we're going to build a
00:37 - Metroid Venia Style game so Metroid
00:41 - Venia is a style of game where mostly
00:44 - there are they're usually
00:47 - Platformers and uh the difference
00:50 - between a normal platformer and a
00:52 - Metroid Venia Style game is that in a
00:54 - Metroid Vania you don't have levels you
00:57 - explore one big map and some parts of
01:00 - the map are not are cut off or not
01:02 - available to you if you don't have
01:04 - certain abilities so the whole point is
01:06 - to explore the map unlock new abilities
01:08 - or find new items as you explore and
01:11 - this will unlock certain parts of the
01:13 - map that you weren't able to access
01:15 - before and here is the simple version of
01:18 - that so here we have a little robot with
01:20 - a sword attack and for now we cannot go
01:23 - to the right uh because we don't have
01:24 - the double jump ability so as you
01:27 - explore the game so here is a health
01:29 - pack uh as you explore the game for
01:31 - example I go here the goal of the game
01:33 - is to exit find the exit which is uh so
01:37 - basically if I start the game from
01:38 - scratch you have this um escape the
01:41 - factory use the arrow kease to move X to
01:43 - jump and Z to attack so here if I
01:46 - explore you can see for example the
01:48 - second room and there's something down
01:50 - below we want to see what it what it is
01:52 - so I'm going to go to uh continue my
01:55 - exploration and here we have drones so
01:57 - drones uh will follow you and
01:59 - self-destruct
02:00 - so I'm going to teach you how to code
02:01 - that as well so here I have so just to
02:06 - show you a full overview of the game
02:08 - before we start building it so here's
02:10 - the layout Etc and now here I
02:14 - have I don't cannot double jump here if
02:16 - I do I'm going to
02:18 - die so now let's beat the boss which is
02:21 - going to allow us to unlock this ability
02:24 - so the boss we're going to build uh beat
02:27 - is this one so as you enter the boss
02:30 - room you cannot exit out of it so so
02:33 - that's a bit like the souls games and
02:35 - then this little boss has a frame a
02:38 - flamethrower and uh basically the way is
02:41 - we just avoid his flames and we hit it
02:45 - so I'm just going to do this this very
02:47 - quick
02:49 - quickly and then after that going to see
02:51 - that we're going to unlock a a power up
02:55 - which is you unlocked a new ability you
02:57 - can now double jump and then here
03:00 - I can go here and this was previously
03:02 - unaccessible it's a shortcut and I I
03:05 - should not die here I just died anyway
03:08 - uh the game will save uh so you still
03:11 - have the double jump ability and now
03:15 - that we have unlocked this we can go go
03:17 - back to where we couldn't
03:20 - proceed and then I'm just going to beat
03:22 - this one and here get access to the
03:25 - second room and as you see like the
03:27 - camera is dynamic uh it will follow uh
03:30 - when when the player uh passes through
03:33 - certain things it's going to follow I
03:35 - just died here it's going to follow the
03:37 - player or not not follow but just change
03:40 - angles and positions to better show the
03:43 - rest of the level and that's the game
03:47 - now to draw this level to so actually to
03:49 - make this game I'm going to use Kaboom
03:50 - which is a library for making games in
03:53 - JavaScript it's very easy to use and yep
03:56 - so I'm going to teach it to you as well
03:58 - so the prerequisite for this course is
04:00 - or this tutorial is that you know at
04:03 - least the basics of
04:05 - JavaScript we're also going to use til
04:08 - which is this program I have here to
04:09 - draw our level layout so because we're
04:13 - not using a traditional game engine uh
04:15 - that means that we don't have access to
04:17 - a level editor like in gdo and that
04:20 - means we need to use an external program
04:22 - for that otherwise it would be too
04:23 - tedious to draw the level layout in code
04:27 - so here tiled is a nice program that
04:29 - fills this Gap so I'm going to teach you
04:32 - how to how it works basically but I will
04:34 - not go into too much details so I'm
04:37 - going to teach you how to how this map
04:39 - that I made works so the these two rooms
04:42 - uh what are all these colliders Etc but
04:44 - I will not like I did in previous
04:46 - tutorials redraw the map from scratch
04:48 - and show you how it's done uh because
04:50 - it's going to be too tedious to
04:52 - replicate the exact same layout so
04:55 - consider those these Maps as assets
04:57 - they're going to be Json file
05:00 - in the description that you can download
05:02 - and you basically going to import them
05:04 - into your game however I have written a
05:07 - guide so I'm going to spend some time to
05:10 - explain how to um draw maps in tiles in
05:14 - til at a higher level but I'm not going
05:17 - to do go into the needy greedy details
05:19 - for this specific project however if you
05:22 - want to have a written written content I
05:24 - have written recently a blog post on how
05:26 - to use child with Kaboom JS so here is
05:29 - my substack it's where I write content
05:33 - um this is where I I do written
05:35 - tutorials so my YouTube channel is
05:37 - really good fit for Project based
05:38 - tutorials but sometimes you just want to
05:40 - know how to do a specific thing or you
05:42 - want to reference something that you
05:44 - found in my tutorials and referencing a
05:47 - video a specific part of a video is
05:49 - usually tedious so having a blog post
05:52 - nicely written like this is uh how I do
05:55 - things to like I I use this as well for
05:58 - myself so so I can reference back uh
06:01 - when I need it how to do uh how to
06:04 - import uh maps from til how to use til
06:07 - and then use them in
06:08 - kabong so if you're interested uh give
06:11 - me a subscribe here to not miss on
06:13 - future written content so the link will
06:15 - be in the description all right so now
06:17 - for this setup I'm going to use vs code
06:20 - for this project and I recommend that
06:22 - you also do uh because we're going to
06:25 - use the go the live server extension
06:27 - which can be found in the extensions
06:28 - Marketplace live server and then install
06:30 - it here uh it's written uninstalled uh
06:33 - because I've already installed it and
06:35 - this allows us to start a local server
06:37 - for a project and it's very easy uh
06:40 - however if you you have your own setup
06:42 - feel free to use it you can start
06:44 - servers in other ways one one example
06:46 - would be through python uh you can start
06:48 - a local HTTP server with it so let's
06:52 - jump right into the project so I have my
06:55 - workspace here I created a folder I
06:56 - called it Metro Vania tutorial but feel
06:58 - free to call it however you'd like all
07:01 - right so now I'm going to create an
07:03 - assets folder and this is where we're
07:04 - going to put the assets for our game so
07:06 - the ass assets are more mostly coming
07:08 - from an asset pack on .io so I'm going
07:10 - to provide the link for that in the
07:12 - description uh however there are two
07:14 - sprad sheets within that I'm going to
07:16 - replace with my own and those two will
07:19 - be in the description as well the reason
07:22 - I'm replacing them with my own is I just
07:24 - reformatted them so they fit better and
07:26 - can be imported in Kaboom easily
07:30 - all right so let's create an assets
07:31 - folder here if not already I'm going to
07:33 - also create another one which is going
07:35 - to be the lip folder which is where I'm
07:37 - going to put the version of KaBoom so
07:39 - for this tutorial I'm not going to use
07:41 - nodejs I'm just going to use the
07:43 - simplest setup you can for uh Kaboom
07:46 - which is just taking a the GS file and
07:49 - then importing it into your project
07:50 - using native JavaScript modules so if
07:53 - you're if you want to use V for example
07:56 - or or a nodejs based uh setup feel free
08:00 - to do so and if you're not sure how to
08:02 - do that look at my previous tutorial
08:04 - where I made a 2d developer portfolio
08:07 - this is where I used vit and uh npm so
08:11 - you can just take the setup portion and
08:13 - then follow along the rest for this
08:15 - tutorial all right so I have the lip
08:18 - folder here I'm going to put later on
08:20 - the the library here that I'm going to
08:21 - download this also will be linked in the
08:23 - description I'm going to create a Maps
08:25 - folder which is where we're going to put
08:26 - the maps so the two Json files that I I
08:29 - show I've shown you earlier here then
08:33 - I'm going to have the
08:35 - source folder which is going to contain
08:38 - most of our code an
08:41 - index.html which is important because
08:43 - it's the entry point of our program and
08:45 - that's basically it so for the
08:46 - index.html I'm just going to write the
08:48 - code uh start writing the code so I'm
08:50 - going to write the HTML tag a body tag
08:53 - it's not very important for a game to
08:55 - have this
08:57 - uh markup to have like really deep
09:00 - markup uh like uh a lot of boiler plate
09:03 - Etc so I'm just going to use a simple
09:05 - markup HTML body tag and then within we
09:09 - import our script from The Source folder
09:12 - so I'm going to do dot source. main it's
09:15 - important to use a relative path because
09:19 - if you're going to put this on h. it it
09:22 - uses relative path uh paths to be able
09:25 - to load your game so that's why I use a
09:28 - DOT here instead of just writing the
09:30 - absolute path uh this file does not yet
09:33 - exist so let's create it so
09:37 - main.js and then here in index.html we
09:40 - need to also add the type of it to be
09:44 - module the reason we're doing this is
09:46 - because we can without this we cannot
09:48 - use the import syntax we cannot use
09:51 - import X from y this is called native
09:55 - JavaScript uh modules I think
10:00 - all right so now that we have this let's
10:03 - um save
10:06 - everything all right and then I'm going
10:09 - to import the files now so let's see if
10:12 - this work can I just drag and
10:16 - drop can
10:18 - I cannot okay so I'm GNA have to do this
10:21 - differently so I'm going to drag and
10:23 - drop the versions so here what I like to
10:26 - do when I'm not using npm is just to
10:27 - have a a simple text text version that
10:30 - tells you where to get the library and
10:32 - the version of it and here the MGs file
10:35 - is what you need to install uh to
10:36 - download so the way you do that is you
10:38 - go to this link it's going to be in the
10:40 - description hopefully and then you're
10:42 - going to be brought to a page with
10:45 - random code so let me just open it
10:48 - up uh it's not random code actually it's
10:50 - the the code for the library what you do
10:53 - here is you right click and you click
10:55 - save page as and it's going to save it
10:57 - as in Kaboom mg GS file then put it that
11:00 - put that file into your
11:03 - project all
11:05 - right now for the assets I'm going to do
11:09 - the same thing so I'm just going to
11:11 - import everything so uh we're also going
11:14 - to have some Sounds by the way uh those
11:16 - sounds are free uh of use but there is
11:19 - one sound that I put the credits of so
11:23 - yeah every for the sounds a link will be
11:25 - in the description as well so the two
11:28 - Sprites the two Sprite sheets that I've
11:30 - personally modified myself is the burner
11:33 - which is the boss and the u.png which is
11:36 - the player I had to tweak uh the jump
11:39 - animation and uh the placement of the
11:41 - jump animation and for the burner I had
11:43 - to Center everything otherwise that the
11:47 - the character that the spreadsheet
11:48 - wouldn't uh be displayed properly the
11:50 - animation were
11:52 - weird yeah so it's a bit hard a bit hard
11:54 - to explain what the issue was but if you
11:56 - have the original and you try with the
11:58 - original you're going to soon realize
12:00 - the issue we also have this glyph ms.
12:03 - ttf which is the font we're going to use
12:04 - this is provided by the asset pack so
12:06 - everything here is provided by the asset
12:08 - pack in the description but as I said
12:11 - for burner and u.png replace these with
12:16 - my custom ones all right so here you
12:20 - have the sounds Etc okay now let's go to
12:24 - the maps and let's import them as well
12:28 - so
12:30 - there's actually there's four things so
12:33 - I need to explain something here so here
12:35 - room. one. Json is the the file uh
12:39 - basically with all the data needed to
12:41 - draw the map this is from til there's
12:45 - also room
12:46 - 1.png and room 2.png and the reason we
12:50 - have room one and room two here is
12:52 - because in Kaboom Jazz strangely enough
12:55 - it is more performant to just go to
12:58 - tille
12:59 - and then export the map as an image and
13:02 - then just uh it would be one single
13:04 - Sprite and display it as a single Sprite
13:06 - rather than drawing every tile as like
13:09 - as in your logic from the Sprite sheet
13:12 - that's why I have exported both a room
13:16 - one and room two as pgs and the reason
13:20 - and what the Json is for now is just to
13:22 - know where the colliders are so that's
13:25 - the the use for that so usually in game
13:28 - development libraries you would just
13:31 - only need the Json file and you can do
13:34 - that in Kaboom JS you just need that and
13:36 - not the the you wouldn't need the other
13:38 - ones but it would be less performant
13:40 - because the way you would draw is you
13:42 - would take your original asset so your
13:44 - Sprite sheet your tile set here and then
13:46 - draw from there but for some reason in
13:48 - Kaboom Jaz if you do that it's less
13:50 - performant than just having baking all
13:53 - your um your world your map into a
13:56 - single image and then just displaying it
13:59 - so with pixel art it isn't that big of
14:02 - an image but you also need to think um
14:05 - of the network considerations so since
14:08 - this this is web game uh maybe you don't
14:10 - want people to have to download two
14:12 - bigger images and if you could only use
14:16 - um a single small uh image it would be
14:20 - nice better in terms of like uh loading
14:23 - but I think with games people are more
14:26 - uh forgiving when it comes to these
14:28 - stuff rather than a normal website you
14:30 - shouldn't exaggerate but I think that's
14:33 - the usually the case you're usually more
14:35 - willing to wait a bit before playing the
14:37 - game rather than if it were a website
14:39 - that you need to use
14:41 - immediately all right uh now that we
14:43 - have that um I think we can get started
14:47 - with importing Kaboom into our project
14:49 - the way we're going to do this is I'm
14:51 - going to use a file I'm going to create
14:53 - a new file I'm going to call it the
14:55 - Kaboom loader. JS this file is going to
14:59 - to be the one importing Kaboom because
15:01 - okay so I'm just going to do it and then
15:03 - you're going to see why uh it's going to
15:05 - make more sense like
15:07 - that so what we're going to do here is
15:09 - I'm going to write an import statement
15:11 - I'm going to import Kaboom from and the
15:14 - nice thing with JavaScript modules is
15:16 - that you can just do um lib you can
15:19 - import the MGs file immediately like
15:21 - that without any script Tes so once you
15:25 - do this uh so just the path is from the
15:28 - lip folder so here we are in the source
15:30 - folder having dot dot that means we go
15:32 - up to the root of the project and then
15:34 - we go back in lib uh the lib folder and
15:38 - then Kaboom
15:40 - MJS and then here I'm going to have um a
15:46 - constant I'm going to call it the scale
15:48 - I going to scale probably the game two
15:50 - times I'm not sure actually if I use
15:52 - yeah yeah this is going to be a fix
15:54 - around an issue that's going to come up
15:56 - later so for now just uh have this
15:59 - constant up as the
16:01 - scaling and then
16:03 - here export const K is going to be the
16:08 - Kaboom context and the way you
16:10 - initialize the Kaboom canvas is by
16:11 - calling the Kaboom function and then
16:14 - passing it an object which is which can
16:16 - contains a bunch of properties you want
16:19 - uh for for example I can specify the
16:21 - width of my game I want it to be 6 uh
16:25 - 40 uh and the height I want it to be
16:31 - 360 and I want it to have the letter box
16:35 - option to being true so here if for now
16:40 - nothing happens but uh I also need to
16:43 - for I forgot something very important
16:46 - Global should be false so Global the
16:49 - reason is by default if you import
16:51 - Kaboom you just can use start using the
16:53 - Kaboom functions uh immediately but what
16:56 - I want what I prefer to do is to store
16:59 - the Kaboom context in a constant and and
17:03 - uh here K and all Kaboom function will
17:05 - have to be prefixed by this K Dot and
17:08 - then you call the Kaboom function you
17:10 - this makes the code
17:11 - cleaner uh in my
17:14 - opinion so
17:16 - now uh yep so now if I go to
17:19 - main.js and
17:22 - import the um yes so you need yeah so
17:27 - I'm I'm going to import k so import K
17:31 - from Kaboom loader because we're using
17:33 - JavaScript modules and not using an npm
17:36 - based workflow we need to specify the
17:39 - file extensions otherwise it's not going
17:41 - to work so kabum loader loader. JS and
17:45 - then here just by doing this if I click
17:48 - on the go live button which is at the
17:50 - bottom right of vs
17:52 - code you should be able to see the
17:56 - canvas being initialized now one thing I
17:59 - want to add for this project is in the
18:03 - index.html um I'm going to add a bit of
18:07 - styling I want the background to be
18:09 - black basically I think it it's going to
18:11 - be better than white so
18:14 - body and then I add the background not
18:17 - necessar color just background and then
18:20 - black and now if I go back and look at
18:22 - the result you have a black bar so it we
18:25 - can we nicely like see the difference
18:27 - between the canvas and the rest now
18:30 - there's one thing I wanted to do before
18:32 - and the reason I had the scale here is
18:35 - because I want the canvas to be scaled
18:37 - as well so this is a shorthand in
18:39 - JavaScript when you have a property that
18:42 - is the same name of a variable you don't
18:44 - have to do scale not scale you can just
18:48 - use scale like that as a short hand now
18:51 - and also I need to multiply by the scale
18:53 - here the reason I'm doing this is that
18:55 - in kabas uh the pixels certain pix pixs
18:59 - can um it's a bit hard to explain so I'm
19:04 - going to make a
19:08 - schematic
19:13 - XC all right so we have excal draw maybe
19:16 - dark mode here as well uh do we have
19:19 - dark mode all right so in Kaboom Jaz and
19:23 - not necessarily only in that but I've
19:26 - noticed it in Kaboom is that when you
19:28 - have pixel art so imagine this is one
19:31 - pixel okay and imagine that we have a
19:34 - drawing like that with a multiple pixels
19:38 - so let me just zoom in uh it's not going
19:41 - to be perfect
19:42 - here okay we have the this um letter I
19:47 - guess so yeah so we have this
19:52 - letter Let's see we have zero imagine
19:55 - this is a Sprite the issue is that in
19:57 - Kaboom some times a pixel will take more
20:01 - space than a pixel and you will have
20:04 - like a bit of padding like that a bit of
20:07 - padding like that and that means that
20:10 - this pixel and this pixel in theory like
20:12 - in the Sprite art should be the same
20:14 - size but somehow it's not the case and
20:17 - this issue is not entirely resolved so
20:20 - if I go back to the original game uh is
20:23 - it
20:25 - working okay I need to refresh the G
20:28 - sorry
20:30 - um so maybe you can notice it uh so this
20:34 - is with a fix even with a fix there's an
20:36 - issue but if you look
20:39 - here um here you see uh you're probably
20:43 - not going to notice it but this pixel
20:47 - right here ah I think it's better it's
20:49 - more visible here so maybe go full
20:51 - screen this pixel is not the same size
20:54 - as this pixel even though they're
20:56 - supposed to be the same and this is
20:57 - something a random during padding issue
20:59 - that Kaboom adds some padding and this
21:02 - caused this and this is the less worst
21:04 - variant of it so this is bar barely
21:06 - noticeable and it's barely noticeable
21:08 - because of the fix I I the hack I used
21:11 - here but if uh yeah so but the hack is
21:14 - basically you set a scale value which
21:16 - can be two here you multiply your width
21:18 - you multiply your height and then you
21:19 - also set the scale as well so this hack
21:22 - allows us to reduce the um to not have
21:26 - this issue but to have it less less
21:28 - visible so something in Kaboom I cannot
21:32 - I didn't want to modify the source code
21:34 - itself and even even when I tried to fix
21:37 - it didn't work so uh if you're Kaboom
21:39 - maintainer maybe I fix this that would
21:42 - be great so yeah so maybe you cannot
21:46 - unsee this anymore so yeah sorry sorry
21:50 - for making making you notice something
21:52 - like that all right let's go back to yep
21:56 - to the project
21:59 - so now in the Kaboom loader the reason I
22:01 - call this the Kaboom loader. JS is
22:03 - because not only we're going to load the
22:04 - Kaboom uh Library here but we're also
22:09 - going to load our assets from this file
22:11 - so in previous tutorial tutorials I
22:14 - would use Kaboom context and then just
22:16 - have this one and then do the loading in
22:18 - the main.js but I thought to have
22:21 - everything that relates to loading
22:23 - things from Kaboom to be in the Kaboom
22:26 - loader file all right so let's load the
22:29 - various assets we're going to need um
22:32 - I'm trying to think maybe it's not the
22:35 - best to do this
22:38 - directly um I think we we could do yeah
22:40 - if we do this once and for all and then
22:43 - we won't have to worry about anything
22:45 - related to animations so this is
22:47 - something that is very tedious to do I
22:49 - would recommend that you just copy and
22:51 - paste the source code so by the way the
22:53 - source code is available on GitHub so
22:55 - this is something I would not like to
22:57 - spend much time typ it out so I'm just
23:00 - going to explain everything so how we
23:02 - import Assets in kabo so the way assets
23:05 - are imported in Kaboom depends on the
23:07 - assets of course we have the load uh the
23:10 - way to load fonts is by using the load
23:13 - font method provided by Kaboom and
23:15 - that's why I like this pattern of having
23:18 - cab uh Kaboom as being non- Global is
23:21 - because we can you can immediately see
23:23 - that if the the method is prefixed by K
23:26 - that means it comes from kabo so so the
23:29 - way you load a font in Kaboom is by
23:30 - using the load function method here and
23:33 - then you pass in the name you want to
23:35 - use to refer to in your code for this
23:38 - specific font and then the second one
23:39 - would be the path to that font so this
23:42 - how you load a font there's also load
23:44 - bit F uh bit map font I think is another
23:47 - one where your font is an image and then
23:49 - you specify each character uh the value
23:52 - but this is not relevant to this
23:54 - tutorial uh to load Sprite uh so or
23:57 - Sprite sheet that Etc you use the load
23:59 - Sprite method and it's basically the
24:02 - same thing if it's a single image you
24:04 - want so let's say you have only one
24:07 - frame in a PNG file you would only need
24:10 - to First specify a name for your Sprite
24:12 - that you want to you uh to refer to and
24:15 - then pass in the path and that's it you
24:16 - would close the the
24:19 - parenthesis uh however in this case we
24:22 - have a spreadsheet that means that we
24:24 - have multiple frames located in the same
24:27 - image and uh to know to tell Kaboom how
24:31 - to slice it we have to pass in a third
24:34 - param which is an object that is going
24:36 - to contain all of this information with
24:38 - also the the animations we're going to
24:40 - Define so let's uh have a look at the
24:43 - Sprite so here we have the player Sprite
24:45 - um Sprite sheet which is located under
24:48 - the Sprites folder and under
24:53 - u.png and here we have a bunch of frames
24:55 - and I realized one thing is that it's
24:57 - not going to be very visible
24:59 - unfortunately because uh the colors you
25:02 - know uh okay maybe I should open a
25:05 - Sprite so this is aprite which is the or
25:08 - yeah aprite which is the software I use
25:11 - to draw pixel art so here we can better
25:13 - see the Sprite sheet uh so the way
25:16 - kaboon uh slice Sprite sheets is first
25:20 - of all you need to
25:22 - specify the slice x value property and
25:25 - the slice y property so slice X is B
25:28 - basically the amount of frames per row
25:32 - so in our uh in our spreadsheet here we
25:36 - have 1 2 3 4 five 6 7 eight we have
25:41 - eight slots uh per row so that's how we
25:45 - determine the slice x value to be eight
25:48 - by nine uh slots per column because this
25:52 - is how 1 2 3 4 5 6 7 8 and nine as you
25:58 - see there is a lot of animations here
26:00 - we're not going to use all of them uh so
26:02 - here it's slice n now for defining
26:06 - animations you specify the anims
26:08 - property and then you pass in an object
26:11 - and each of the these entries are going
26:14 - to be the various animations so for the
26:16 - idol animation so those names here are
26:20 - names that I have
26:22 - arbitrarily so those names are names
26:25 - that I have
26:26 - arbitrarily chosen for myself so you can
26:29 - decide to to name them however you'd
26:32 - like so here I decided to name it the
26:34 - idol animation and by the way it doesn't
26:36 - have to be a property like that it could
26:38 - be a string uh with uh like I don't know
26:43 - maybe uh idle uh dash player you could
26:48 - have decided to name it this way but
26:49 - we're not going to do this
26:52 - here so here Idol and then you pass in
26:57 - another object and this object needs to
27:00 - have the from Key the to key and the Lo
27:03 - whatever or not you want to Loop and
27:05 - this is optional uh but the two main
27:07 - things is these two you need to to
27:10 - basically specify that however you can
27:12 - specify an animation as being a single
27:14 - frame so for example I don't know indle
27:17 - idle um idle one I guess and then I
27:21 - would just specify frame zero like that
27:23 - you can do that one you need to just
27:25 - have one
27:26 - frame so here from 0 to 7 what does that
27:30 - mean so this animation this animation
27:32 - that we Define as Idle is going to start
27:35 - at frame 0o so the way fra uh frames are
27:38 - counted in Kaboom once the
27:41 - uh the you have specified slice X and
27:44 - slice y properties is as follow so you
27:48 - have um zero you start at the bottom uh
27:51 - the top Corner 0 1 2 3 4 5 6 7 and by
27:57 - the way you don't count the frame you
27:59 - count the slots because even this empty
28:02 - frame is considered frame so you would
28:05 - have 0 1 2 3 4 5 6 7 8 9 10 11 12 uh 13
28:13 - 14 15 16 so here for the idle animation
28:17 - it's basically 0er 0 1 2 3 4 5 6 and
28:22 - seven so the first row would be the
28:25 - animation so from 0 to 7 and here I
28:28 - specified the animation to be looping
28:30 - that means it will always play uh when
28:33 - you start playing it it will not stop
28:35 - playing until you stop it
28:39 - manually certain animations like running
28:42 - jumping falling and Idol itself are good
28:45 - to be uh we want them to be infinite
28:48 - like that and we decide when to cancel
28:51 - them but as for explode or attack when
28:54 - an enemy explode Etc it's just a
28:56 - oneandone animation and for the attack
28:59 - animation also it's a one andone we want
29:01 - the attack animation to run and
29:03 - then and then to stop when it's when the
29:06 - attack animation is done the attack is
29:08 - done and here you also see that you have
29:10 - other optional properties like the speed
29:13 - property which you can specify the frame
29:15 - rate her 16 was a good uh uh what was a
29:19 - value I thought would made the game look
29:21 - good so that's basically it um uh you
29:25 - have also another one called the load
29:27 - Sprite
29:28 - Atlas uh so the the difference between a
29:32 - load Sprite Atlas and another another a
29:35 - normal load Sprite is the following so
29:38 - with a load Sprite Atlas you're
29:41 - loading uh you're basically cutting out
29:43 - a specific portion of an image so for
29:47 - the
29:48 - UI you have this whole thing and I only
29:50 - need this part but instead of just like
29:52 - cutting it off what you can do is just
29:54 - use a load Sprite Atlas in your code you
29:58 - specify the file you want to load and
30:01 - then here you can cut out a specific uh
30:05 - sprite from it so here I decided to have
30:07 - a Sprite called health bar it's going to
30:10 - start uh from within the image at
30:13 - coordinate x uh 16 and Y6 so you take
30:17 - your image the coordinate 0 0 at the uh
30:19 - is at the bottom uh at the top Corner
30:21 - top left corner and as you move here
30:24 - 16 and then you drop down 16 here
30:28 - and from this part from this point
30:30 - onward you're going to cut it cut the
30:33 - image with a width of 60 and a height of
30:35 - 40 so this is going to cut the image
30:37 - like that and only keep this portion and
30:40 - then after having done this I'm going to
30:43 - also slice the specify slice y as being
30:46 - true three uh that means I just want to
30:50 - cut
30:51 - out the uh um basically set this as a
30:55 - Sprite sheet so first of all I cut out
30:58 - from the rest of the image only this
31:00 - portion and then I set it as a Sprite
31:02 - sheet by specifying the slice y value
31:04 - that means that every frame so there is
31:07 - only three frames in this uh in this uh
31:10 - this portion and it's going to be the
31:12 - health bar so the first frame is going
31:14 - to be frame zero frame one and frame two
31:17 - so this how you would do it uh if you
31:19 - had um for example this part if you
31:22 - wanted to cut out this part you would
31:24 - specify different X and Y values and
31:27 - then from there different width and
31:28 - height value to just keep this part and
31:30 - then here it will be slice X3 because
31:33 - there's three uh slots per row and by
31:36 - three slice y will be three by three so
31:39 - 3 by3 hope that was clear and that's
31:43 - basically it so here for the sounds it
31:46 - used the load sound uh fun uh method and
31:50 - then you specify the name and then the
31:51 - the sound as easy as it gets so copy
31:55 - this from the source code on GitHub I
31:58 - think it would be better that way than
32:00 - me typing it out so assuming you have
32:02 - this done our assets are all
32:05 - loaded so yeah I might come back here to
32:08 - tweak certain animation but I shouldn't
32:10 - have to do that because this is taking
32:12 - taken from the final project so if we go
32:15 - back to our browser
32:17 - Tab and we still have our canvas nothing
32:20 - changed and that's pretty normal all
32:23 - right now let's um wondering what we
32:26 - should do next is continue creating our
32:28 - folder structure so I'm going to
32:30 - collapse this collapse this collapse
32:32 - this and then here in our source source
32:33 - folder I'm going to create an entities
32:36 - folder this is for the player the drones
32:39 - the boss I'm going to put the logic
32:41 - there for them um also going
32:45 - to you create a scenes folder which is
32:49 - going to be the various scenes we only
32:50 - have two scenes here we have the room
32:52 - one which is the big uh map here and
32:56 - then we have the room two which is going
32:58 - to be just a smaller one so you can see
33:01 - that if you were to expand this project
33:04 - you would have a uh
33:06 - multiple um images like the multiple
33:10 - rooms like this that would comprise the
33:12 - whole
33:14 - world so after the scen folder is
33:17 - created I'm going to also create a state
33:20 - component uh State uh folder this where
33:22 - we're going to hold the global State uh
33:25 - yep so I think the finally the yeah
33:29 - sorry I forgot we need the UI folder for
33:32 - the UI so now we have a neatly organized
33:36 - uh folder structure so let's start with
33:39 - the scenes I think this is the most
33:40 - important part so for let's define our
33:43 - first scene so our scene uh I'm going to
33:46 - use the concept of rooms even though
33:49 - this is much bigger than than a room but
33:52 - I started with this initially I didn't
33:55 - think Kaboom could handle a bigger map
33:58 - so I thought that I would just have
34:00 - multiple rooms stitched together but in
34:02 - the end it was able to so that's great
34:05 - so that's why I I the name stuck because
34:09 - I it felt too much of a hassle to just
34:11 - change everything now so let's create a
34:14 - file called room room uh oops room one.
34:21 - JS and in this file I'm going to have to
34:26 - export a function
34:28 - a sync uh it's going to be a sync I'm
34:30 - going to explain why later on that's
34:32 - probably because we are going to have to
34:35 - import the map actually I don't think
34:38 - we're going to need this Inc here so you
34:40 - know what instead of writing s Inc and
34:42 - not knowing why I will just write a
34:44 - normal function and then when a time
34:46 - comes and we we see that we need it I'm
34:48 - just going to add it back so why why I'm
34:51 - doing this so for now let's create an
34:53 - empty function called room one and it's
34:56 - going to contain all the log defining
34:58 - our fun our scene this
35:01 - scene so yep and uh I'm going to leave
35:06 - it empty for now let's create another
35:08 - file in the scenes folder and I'm going
35:10 - to call it room 2.
35:12 - JS and it's going to be again the same
35:16 - pattern export const uh not const export
35:19 - function Room 2 and it's going to be
35:24 - empty not page transition sorry ah I
35:27 - messed up so export function room
35:33 - to ah come
35:35 - on I'm struggling with my own keyboard
35:39 - and I made a typo as
35:42 - well all right so another function here
35:46 - and also like with room one it's going
35:49 - to contain all the logic we need for our
35:51 - scene and then in main
35:54 - dos I think it was in main dos yeah
35:58 - so in main.js we're going to Define our
36:01 - scenes so here I'm going to create a
36:07 - function I'm going to call it main
36:10 - actually you know what let's do it
36:11 - directly so to define a scene in Kaboom
36:14 - JZ use the scene
36:16 - method and the scene method takes a name
36:19 - which is going to be the name you want
36:20 - to use for your scene to refer to that
36:24 - scene it's a key basically it can be
36:26 - anything you want
36:28 - as long as it's a string and then the
36:31 - second param is a
36:34 - function uh an arrow function but just a
36:37 - function and this function is going to
36:39 - run when the scene is
36:42 - called so here for now I'm just going to
36:45 - import room one from that file and just
36:48 - call it for now there's nothing that
36:51 - Happ that will happen from this
36:53 - optionally you could have decided to
36:55 - just pass in room one without the Arrow
36:58 - function and just the name and uh
37:00 - because we're passing because room one
37:02 - is a function definition it's going to
37:05 - call that function definition but the
37:06 - reason I'm using an arrow
37:08 - here an aror function is because we want
37:11 - to have like the previous data of the
37:13 - scene at one point which is Kaboom is
37:15 - going to pass it to the to the
37:19 - um it's going to pass it to
37:22 - the to this function and later on it's
37:25 - going to be clear so for now just I'm
37:27 - just going to uh leave it
37:30 - empty so I'm going to Define another
37:32 - scene I'm going to call it room
37:34 - two and I'm going to have an N function
37:38 - as well and room to uh I should import
37:42 - it y
37:43 - so
37:45 - bubble should the your editor should
37:49 - s here we go I have room two and I'm
37:52 - going to call it okay that's uh for now
37:56 - and let's have a the intro scene which
38:00 - is the scene you saw that just tells you
38:01 - the control I know it's a bit lazy to
38:04 - have a scene like that but because this
38:06 - is for a tutorial I felt I didn't felt
38:08 - like having a whole menu and uh yeah all
38:12 - that stuff so I just stitch together a
38:16 - simple entro scene that just tells you
38:18 - the
38:19 - controls all right and then finally we
38:22 - going to use the the go method which
38:25 - basically tells uh boom to go to a scene
38:28 - this is important when you define scenes
38:30 - you need to use that go function
38:33 - otherwise uh actually you don't have to
38:36 - I don't think you have to you could have
38:37 - a the the the the default code for
38:40 - example it could start writing your
38:42 - logic here and it's going to display but
38:45 - usually the the patterns that you define
38:46 - your scenes and and then you call the
38:48 - default one call one otherwise you're
38:51 - going to not know why your scene is not
38:53 - displaying if you don't call it within
38:56 - the main.js
38:58 - F all right so we have this here and I
39:01 - think we're ready to see if anything
39:04 - changed in our uh project I don't think
39:08 - anything changed but you see the loading
39:09 - bar that means that the assets are
39:11 - indeed being
39:13 - loaded the loading bar sorry all right
39:16 - so now let's go back to room
39:18 - one and here for room one I'm going to
39:23 - first have our first pram which is going
39:25 - to be the K instead of having to import
39:27 - k from the K Lo loader often times I
39:30 - will just you know pass this around pass
39:33 - this K around here that way I don't have
39:35 - to write this import state but I think
39:39 - uh uh I think both approach could work
39:43 - you could decide to import every every
39:44 - time you need K you just import it from
39:46 - this file but for some reason I find
39:49 - myself doing this and I think uh it uh
39:52 - it's more convenient I guess you don't
39:54 - have to import anything
39:56 - extra all right so I'm going to import
39:59 - the context here and just to test things
40:02 - out let's create our first game object
40:05 - so if you're not familiar with the game
40:06 - what game objects are in Kaboom well
40:09 - it's time to explain this so uh Kaboom
40:11 - allows you to create game objects think
40:13 - think of game objects as entities for
40:16 - your game uh they can be platforms they
40:18 - can be players enemies drones Etc but
40:22 - most importantly uh than not is that a
40:25 - game object is an array of comp
40:27 - components it's made of an array of
40:29 - components those components are all
40:31 - mostly all but you can make your custom
40:33 - components are offered by Kaboom and
40:35 - this is what one of the driving force uh
40:38 - strengths sorry of KaBoom is that it
40:40 - makes creating game objects very easy
40:44 - and it speeds up your game because
40:45 - there's ton of functionality that you
40:47 - get for free so that's why Kaboom J I
40:51 - think would could be like literally
40:53 - called a game engine rather than the
40:55 - library because it offers that that much
40:58 - uh so so to create a game object in
41:00 - Kaboom you can use two things uh two
41:02 - functions uh two methods you can either
41:04 - use the add method or you could use the
41:08 - make method uh the make method creates
41:10 - the game object but does not add it to
41:12 - the scene so it won't be visible while
41:15 - the add method creates the the game
41:18 - object and then display it on the scene
41:20 - as well so here for just testing we want
41:23 - to add to the scene so to the canvas and
41:26 - we're going to use the ad method the ad
41:29 - method takes one peram which is an array
41:31 - of components so components um so for
41:34 - example you can have the text component
41:36 - this is offered by Kaboom you can just
41:39 - pass in some text hello
41:42 - world and then you can have you pass a
41:45 - second component which is the positional
41:47 - component this is also offered by Kaboom
41:49 - and it's where you want to put this on
41:50 - the canvas let's put it at 100 by 100
41:53 - just to test things out so here we are
41:56 - we have our first game object which is a
41:58 - text basically text based game object so
42:01 - if I go to see the result and uh it's
42:05 - not going to display because we write we
42:06 - wrote this code in room the room scene
42:10 - but we first went to the endro scene so
42:14 - let's change this temporarily to room
42:17 - one so we go immediately to the room one
42:21 - scene so here we can see Hello World in
42:24 - the default font now because we already
42:27 - imported the font in here we can just
42:30 - use glyph mess here so something
42:33 - specific to the text components that can
42:36 - take a second param which is where you
42:38 - define the uh the font with font
42:42 - property glyph mess
42:45 - oops and there's a bunch of other
42:47 - properties like the size the text
42:50 - wrapping Etc but for now let's use one
42:53 - uh one
42:55 - property so now if I go here
42:57 - you can see Hello World written in the
42:59 - font we're going to use for the game so
43:02 - this how we we create a game object so
43:05 - but this is not what we actually want to
43:06 - do for for this project uh what we want
43:09 - is the actual um to actually display the
43:14 - the room
43:14 - level so this is what we're going to do
43:17 - in the next portion of this tutorial
43:19 - we're going to write the logic to
43:20 - display the maps I'm going to spend some
43:22 - time hopefully explaining how til work
43:25 - and how all these layers Etc how to make
43:27 - sense of all of this uh I also recommend
43:31 - just also reading the blog post I wrote
43:33 - which is going to which is a stripdown
43:35 - very simplified version of this just to
43:38 - explain how til work and I think it does
43:42 - a better job than I could do right now
43:45 - but I'm going to try to explain those
43:46 - also okay so now we're going to write
43:48 - the logic to load the map and the way
43:52 - you load a map well before that let's
43:54 - first color the background so
43:57 - uh the background color I usually don't
43:59 - do that in tiled so if you see the map
44:01 - here in tiled it's transparent here the
44:04 - the uttermost layer and that's because
44:07 - it's better to just do uh color the map
44:10 - uh color the background in the game
44:12 - itself so to do that I'm just going to
44:14 - create a small utility so for all logic
44:17 - that is going to be common to both room
44:19 - one and two or just rooms in general if
44:21 - you decide to expand upon the project is
44:24 - to create a room utils JS file here and
44:29 - in that file I'm going to create a
44:32 - function that I'm going to call Export
44:34 - first we're going to export that
44:36 - function I'm going to call it set
44:38 - background color and it's going to take
44:42 - the context the Kaboom context so that
44:44 - we can use Kaboom relative functions and
44:46 - the second param is going to be the hex
44:48 - color code which is going to be the
44:50 - color uh that we want to display so here
44:55 - I'm just going to create use a game
44:57 - object that is going to be a rectangle
44:59 - is going to take the whole width and
45:00 - height of the screen and color it a
45:02 - certain way uh it's better to use that
45:05 - than the set background uh method from
45:07 - Kaboom because the set background method
45:09 - from Kaboom is going to color everything
45:11 - including the rest of the body of the
45:14 - page which mean we won't have the nice
45:16 - uh looking bars here uh in the game by
45:19 - the way the game is
45:21 - responsive I mean the three sizes
45:23 - because we activated the letter box
45:25 - option in case I for got to to explain
45:28 - this sorry but letter box is really so
45:30 - that on any screen size it retain the
45:33 - same aspect ratio so here letter box
45:37 - here all right so now that we have this
45:40 - I'm going to go back here and I'm going
45:42 - to create the rectangle I'm going to use
45:44 - the rectangular component which is just
45:47 - rect specify a width and a height and
45:50 - you can get the height of the current
45:52 - canvas and the width of that canvas by
45:54 - using the height and width uh method so
45:57 - you have the width method uh width width
46:01 - method and height so like that and then
46:05 - I'm going to use the color component
46:07 - which allows us to color a given game
46:09 - object with a single color and I'm going
46:11 - to use the color I think it's an
46:14 - abstract class uh but the from heex
46:17 - method which allows us to color it by
46:20 - specifying a hexadecimal uh value which
46:23 - is used usually it's most used for
46:26 - colors it's the the thing here in aprite
46:28 - for example and uh the reason we need to
46:31 - do this is because by default the color
46:34 - component takes a uh three params which
46:37 - is the RGB values and not an hexadecimal
46:41 - value and now we have this
46:45 - more and then one thing we need to also
46:49 - use is the fixed component this will
46:51 - make sure that the camera uh not the
46:53 - camera this game object in particular is
46:56 - not affect by the camera so that means
46:58 - it will always remain at the same
47:00 - position regardless and this is what we
47:02 - want for the background we don't want
47:04 - the this rectangle to basically not
47:07 - cover the whole world because as we the
47:09 - player moves and the camera moves the
47:12 - part that cover the rectangle covered is
47:14 - not going to be there anymore it's not
47:17 - going to be um uh covered anymore
47:19 - because the camera has moved on from the
47:21 - position of the rectangle by default if
47:24 - you do not specify a positional
47:26 - component what happens is basically that
47:30 - uh the the the game object will be
47:32 - placed at 0 0 in your canvas so that's
47:36 - why I haven't specify a positional
47:38 - component here because it's not really
47:40 - needed all right I save this and I'm
47:43 - going to call that inside this um the
47:48 - room one logic so I'm going to pass in
47:50 - the K here the context and here the hexa
47:54 - decimal value we're going to use is it's
47:57 - going to be a specific value I don't
47:59 - have it uh memorized but it's this one
48:03 - uh oops I should have done this properly
48:06 - so this is the color so now if I go back
48:09 - to the game and there's an issue and the
48:13 - issue is because we forgot to add ajs in
48:16 - room U actually in the import remember
48:19 - because we're not using npm it is
48:21 - required to have the JS here because if
48:24 - we if you don't do that the error to
48:27 - have let me just see if I can zoom in
48:29 - it's going to be uh a blocked because of
48:32 - disallowed MIM type text/html by
48:37 - specifying ajs extension it basically
48:40 - tells uh tells us or tells the browser
48:43 - Etc that this is a JavaScript uh mime
48:46 - type so it will allow it to
48:51 - run now we have the the background all
48:53 - right so we're making progress and
48:55 - that's great
48:57 - okay so now the next thing we're going
48:59 - to need is to load the uh data so I'm
49:04 - going to do this outside of the room
49:06 - logic so I'm going to have a room data
49:09 - uh pram and then back in the um main.js
49:15 - file we created earlier on main.js here
49:18 - is where we're going to need to use a
49:20 - syn we and we're going to have to wrap
49:24 - both these two scenes inside inside of
49:27 - an a sync function because we cannot use
49:29 - top level weight and we cannot need that
49:32 - so I'm going to have an X not export I'm
49:35 - going to Define an async function main
49:39 - I'm going to call it this way main may
49:41 - be a better name but for now let's just
49:43 - call it main uh and I'm going to take
49:45 - those two scene definitions I'm going to
49:47 - put it here and the reason for that is
49:49 - going to be clear very early uh we don't
49:52 - really need to put the inro scene here
49:55 - uh because the reason I'm going to need
49:58 - to use a Sync here is because we want to
50:00 - first load the data from our Json file
50:03 - it contains the map data from til uh so
50:07 - let me just write the logic for that and
50:09 - then after that I'm going to explain how
50:10 - do you actually get the Json file so I
50:13 - explained earlier you can find this in
50:14 - the description but for the actual map
50:17 - like how you draw it Etc I'm just going
50:19 - to do the explanation now so A8 fetch so
50:23 - this is a similar like how you do in web
50:25 - development where you want to request an
50:27 - API but this time you just request a
50:30 - Json immediately so we're going to take
50:31 - this from the maps do uh do/ maps and
50:36 - then the name room one. Json so room
50:39 - one. Json and I'm I'm going to just do
50:43 - this on one line so usually people what
50:45 - they do when you see example how to make
50:46 - a fetch request is they first put this
50:49 - inside of a variable they call it
50:51 - response and then they Jon jsonify it
50:55 - later on but I'm just going to do this
50:56 - in one p swoop so 08 uh Fetch and then
51:01 - that means as long as the fetch call is
51:04 - not resolved we won't move further and
51:06 - this is what we want and that's why I'm
51:08 - using a s we a s weight because as long
51:11 - as we don't haven't uh loaded the data
51:14 - for the room we don't want to display
51:17 - the room data so here we have the Json
51:20 - as well so here we after you have
51:23 - fetched the data it's going to give you
51:24 - a response and then you need to actually
51:26 - convert that to Json so if I go to room
51:29 - uh the actual content of room 1. Json
51:31 - you can see this is the content we have
51:33 - for this project we don't need uh really
51:36 - to dive into the uh tile layers so tile
51:39 - layers are layers where the data is
51:42 - basically the tiles placed uh we don't
51:45 - need that because we don't actually uh
51:47 - need to render those tiles in caboom uh
51:51 - because we can just use the image that
51:53 - we have exported from til but for
51:55 - colliders you have have here uh how it
51:58 - looks like so I'm going to dive into
51:59 - this later on so now that we have this
52:02 - we have the room data we're going to do
52:03 - the exact same thing for Room 2
52:08 - data and then 08 then 08 again
52:12 - oops then I'm going to
52:14 - fetch Maps slash and
52:19 - then room to. Json and then we do this
52:25 - all right so we have have both of these
52:27 - room data collected now for the room one
52:31 - I'm going to pass in for the room one
52:33 - data so now if I go back to there is one
52:38 - issue though is that we have defined the
52:39 - main function but we actually have to
52:41 - call it so that it fetches the data so
52:45 - the reason I'm actually doing all of
52:46 - this inside of a main function as I
52:48 - explained earlier I cannot use a weight
52:50 - outside of a function in JavaScript I
52:52 - don't think that's possible so that's
52:55 - why I'm doing so I'm calling the main
52:56 - which def collects the data for both
52:59 - rooms and then Define the scenes for
53:01 - both rooms and then we Define the scene
53:03 - for the intro and then we go to the
53:06 - intro but for now I have replaced it
53:08 - with the room one for now just for to
53:10 - make our development
53:12 - easier so I go here and I have an issue
53:16 - seene not found room one okay now that's
53:19 - because it's called before this is
53:22 - resolved because it's an async function
53:25 - okay so maybe I'm going to go back to
53:28 - the
53:29 - intro and then here let's let's actually
53:33 - take some user input so the way you take
53:36 - a user input you can use the Onkey press
53:39 - method in Kaboom and then here you can
53:41 - specify as the first peram the key so
53:44 - here I'm just want the player presses
53:46 - enter I'm just going to um let me just
53:51 - do this like that so when the player
53:53 - presses enter I'm going to call the go
53:57 - to the room one now so now if I look
54:03 - back I have an empty scene because
54:06 - that's normal because that's the intro
54:07 - scene there's nothing by the way we
54:09 - should probably just uh n let's do that
54:12 - later on but for now let's leave it
54:14 - empty with just this uh event handler
54:16 - within the scene so event handlers like
54:19 - these are scoped to the scene so you
54:21 - have to reenable them recall them when
54:24 - you move on to another scene so that's
54:27 - one thing that you have to keep in mind
54:28 - if you make a for example game where you
54:30 - can move in various scenes so every time
54:33 - you load a new scene you have to recall
54:35 - those methods so yeah you can write a
54:38 - reusable function for that okay so we
54:41 - have a Onkey press when the player press
54:43 - enter we go to the room one so let's try
54:46 - it out so here press enter and then
54:49 - everything is loaded Etc everything
54:51 - works so if I refresh and do that really
54:54 - quickly does it actually work all right
54:56 - yeah it works okay nice uh so let's go
54:59 - back to room one uh now that we have the
55:02 - data it's time to print it out so uh
55:04 - actually I'm going to store the room
55:07 - layers first and I think this is a good
55:10 - time to stop writing code and start
55:13 - explaining where do I get all of these
55:16 - so I'm going to go back to til so til is
55:19 - an editor like I explain so let me
55:22 - explain what we have here so we have our
55:24 - room uh with which contains various
55:27 - layers so the layers in Spector is on
55:29 - the top right it's all the layers I have
55:31 - created you create a layer by clicking
55:33 - on this button and then selecting the
55:35 - type there are basically M two major
55:38 - types that I use are the tile layer and
55:41 - the object layer tile layers are for
55:43 - placing tiles so here down below you
55:46 - have tile um a little tile so yeah what
55:49 - I'm going to do is I'm going to explain
55:52 - uh just how the current room setup in
55:56 - work but feel free to please reference
55:59 - to the blog post which gives you a
56:01 - better picture so here um I have okay so
56:04 - I have the title sets here defined so
56:07 - the way you do this is basically when
56:08 - you create a new project new file new
56:10 - map and then you can import the I said
56:13 - this is all covered in in the blog post
56:15 - so here we have multiple layers so by
56:18 - the way this
56:19 - is
56:21 - hidden so tile layers are for placing
56:24 - tiles uh for example I'm going to hide
56:27 - everything and just show you one by one
56:30 - so the first layer I created was the
56:32 - platform layer which contains only the
56:35 - platforms Etc and the various things
56:38 - here now I should have probably created
56:41 - this inside of a props layer instead but
56:44 - sometimes mistakes happen so that's that
56:48 - and then here uh I have the SEC so those
56:52 - are tiles you basically select the tile
56:54 - you want and then you draw make sure to
56:56 - to select of course the the the layer
56:58 - you want to draw and then you can just
57:00 - start drawing like that but this so yeah
57:04 - the second layer I created was the props
57:06 - layer which adds various props and then
57:09 - here you like I said you can select
57:11 - multiple ones like that and you just
57:14 - draw place them so this is the advantage
57:18 - of tile layers is this is how this is
57:20 - what they allow you to do now I have
57:23 - background one which is again a small
57:26 - things and then background two which is
57:29 - basically some buildings Etc same logic
57:32 - here just I used this a second tile set
57:34 - you can load more than one tile set so
57:37 - to add a new tile set you click on here
57:39 - and then you browse and then you click
57:41 - on okay so that's how you do that okay
57:45 - now we are done with the tile layers so
57:49 - layers used to draw things and render
57:51 - things out now the collider the second
57:55 - type of layer is is the object layer and
57:58 - those are used for colliders so the
58:00 - platforms invisible stuff basically it's
58:03 - more efficient to do this than to um
58:06 - have every tile have their own colliders
58:09 - otherwise H it's going to be more
58:11 - performance intensive so just drawing
58:14 - the rectangles here by selecting so when
58:17 - you create a object layer you have a
58:19 - bunch of tools here above and if you
58:22 - just select the rectangle you can trace
58:25 - a a a
58:27 - collider so I'm just going to control Z
58:30 - here and one thing I want to uh also
58:32 - mention is that uh if you go to view you
58:35 - can go to snapping and make sure to have
58:37 - snap to Grid or no snapping depending on
58:40 - the situation so here for example is a
58:42 - collider where which is very small and
58:45 - the SN if the snapping is set to grid it
58:47 - won't allow you to draw a rectangle that
58:50 - is smaller than a tile so that's why
58:53 - sometimes you need to en disable to no
58:56 - snapping or snap to fine Grid or snap to
58:59 - pixels
59:00 - Etc so yeah and one thing is that when
59:03 - you draw a collider you can have so if
59:07 - you click on this uh pink white
59:11 - rectangle thing I don't know how to
59:13 - explain it if you click on that you have
59:16 - to the left side the properties tab
59:18 - which contains a bunch of properties and
59:20 - those are the actual important data the
59:22 - X and Y coordinates of where the
59:24 - collider should be placed and the width
59:26 - the height of it is important and it's
59:28 - data that is imported uh exported to
59:31 - Json and is going to be imported in our
59:33 - game and this is how we know we this is
59:36 - the data we use to draw those colliders
59:39 - in our game and to make them
59:42 - basically uh so by the way once you have
59:44 - your map you need to save as and then
59:46 - you save as to your specific uh to the
59:50 - folder where you want to use those maps
59:52 - and then you just write it a Json
59:54 - extension by default it will give gives
59:56 - you the option to uh save as a TMX but
59:59 - just doing doing it as a Json is
60:02 - fine so here one example of how this
60:06 - properties tab come in handy is that for
60:08 - example here if I click on that there's
60:11 - a dog outside barking so sorry if you
60:13 - hear that in the recording um so here
60:16 - when you click on that you can give a
60:18 - name or a class to any of your colliders
60:21 - and this is useful because I want to
60:23 - give a class of pass through this is a
60:25 - name I have this decided for myself but
60:27 - it's important to be consistent because
60:28 - you're going to use that name in your
60:30 - code to know how to uh what logic needs
60:33 - to be applied to this collider and pass
60:35 - through here is logic that I'm going to
60:37 - apply so that the player can jump
60:38 - through that platform and land on it
60:41 - which is important
60:43 - here and uh yep so we have this is the
60:46 - collider lay colliders layer the
60:48 - positions layer is a bunch of pins you
60:50 - place those pins here and basically
60:53 - those are x and y coordinate they can
60:54 - have a uh I think if I select this they
60:57 - don't have a width and height they just
60:59 - have an X and Y coordinates and they're
61:01 - mostly useful to know where to place
61:02 - things so here for example this is I'm
61:05 - going to place a drone so depending on
61:07 - the situation here when you have
61:10 - multiple pins that are going to spawn
61:13 - multip like the same enemy type I prefer
61:15 - to just use a class and call it drone
61:18 - otherwise if it's only unique thing I
61:21 - can give it a name so basically the only
61:24 - thing that changes is in your code how
61:26 - you access those those properties in
61:28 - your code you can access the name
61:30 - property by just having a DOT name on
61:32 - the object I'm going to show you the
61:33 - code for that later but for the class
61:35 - you just use a DOT type property to have
61:38 - access to the the
61:40 - class so this how it works for example
61:43 - I've placed the boss here uh there's
61:45 - only one boss so I used a name instead
61:47 - of the class and as for the uh yep those
61:52 - drones there the pins and for the health
61:54 - pack also it's a class because it's the
61:56 - same thing repeated over and over again
62:00 - and that's basically it now the cameras
62:03 - is something new to this project I
62:04 - haven't done in the previous project
62:06 - those are colliders that when the player
62:08 - will collide with them they won't cause
62:10 - a collision or anything like that but
62:12 - they will change the camera uh most
62:15 - importantly they usually change the Y
62:18 - position so something you can do in tile
62:21 - is create custom properties you do that
62:23 - by just having for example this one
62:25 - doesn't have custom properties you just
62:28 - right click add a property so here if I
62:30 - go back to the cameras layer so I've put
62:32 - this in a different layer so just to not
62:35 - confuse I'm going to hide the collider
62:37 - layer so here if I have a property I I
62:41 - want a new property I do add property
62:43 - and give it a name and a type and here I
62:45 - used the in type so this is a value so
62:49 - when the the player collides with this
62:51 - camera collider I'm going to take this
62:54 - property and the value for it and then
62:57 - set the camera y position to that value
62:59 - so that's how I can make sure that the
63:01 - camera shows specific things and slides
63:05 - Etc so there's a bunch of them here so
63:07 - for example we drop here the camera will
63:09 - move when you drop here you going to
63:11 - also move or go up Etc depending on the
63:14 - situation so here it's going to go up
63:16 - here it's going to go up so it mostly
63:20 - just affects the Y positioning so only
63:23 - the wi position of the camera so
63:25 - actually yeah so in um in uh if you're
63:28 - not familiar with game development
63:30 - usually when the Y value is high that
63:32 - means we're going up the canvas so we're
63:35 - down yeah I'm confus confused yeah
63:39 - actually the least the no the least the
63:41 - value of y is the higher on the canvas
63:44 - you are that's because the the uh yeah
63:48 - so the the higher the value of y the
63:50 - lower you get on the canvas that's
63:53 - something I've explained in previous
63:55 - tutorials
63:56 - but that's how how it's it is done in
63:59 - game
64:00 - development uh in yeah Graphics Library
64:04 - Etc okay uh now what I want to uh yeah
64:08 - so there's a bunch of colliders here and
64:11 - um yep and finally we have the exit
64:15 - collider exits collider and I think one
64:17 - thing before that for the position the
64:20 - camera collider actually the colliders
64:22 - itself there's this specific boss
64:24 - barrier which is a specific specific
64:25 - colliders so if I go back to the
64:27 - colliders here and this one I have
64:31 - specified a unique Campa X property this
64:34 - time around this is an arbitrary Name by
64:36 - the way I forgot to mention because when
64:39 - you arrive to the boss gate uh barrier I
64:42 - want to move Slide the camera to the x
64:45 - axis not necessarily the y- axis as I
64:48 - used to do with other cameras and uh
64:51 - yeah it's a collider because it's going
64:52 - to be an actual collider because the
64:54 - barrier is going to be visible
64:56 - as you fight the boss and you cannot
64:57 - move and that's why I've put it into the
65:00 - colliders
65:02 - layer and that's basically it and then
65:05 - finally so we have position I've
65:07 - explained this and then the exit exits
65:10 - uh layer which is another TI uh object
65:12 - layer and this is just to know um where
65:16 - to spawn the player in the room two so
65:18 - I've named it exit one and I've name it
65:21 - Nam named it sorry exit 2 and uh yep so
65:25 - so when you hit the player is going to
65:27 - hit that I'm going to know that the name
65:29 - of the exit and I'm just going to spawn
65:32 - you either in entrance two or actually
65:36 - this is the spawn point here entrance
65:38 - two spawn point or entrance one so
65:41 - that's how I link those scenes together
65:43 - and here again it's the basically the
65:45 - same layers uh so feel free to explore
65:47 - open those up in tiled because they were
65:50 - just Json file you can just open them up
65:53 - uh and play with them so I'm not going
65:55 - to spend more time on that but I'm just
65:57 - going to explain one thing though so to
66:00 - do the exporting as a single image what
66:03 - you do is you hide every uh object
66:06 - layer uh yeah object layer because you
66:09 - just want the graphics so and you go to
66:12 - export as image and then once you click
66:14 - on export that image you have the the
66:18 - path to it uh to it and then you can you
66:21 - you must check this to only include
66:23 - visible layers and keep all the other
66:25 - things unchecked and then you export and
66:26 - it's going to give you the room one or
66:28 - room 2. PNG uh depending on which one
66:31 - you export here and there so that's an
66:35 - overview of how to use tile so like I
66:37 - said the blog post goes into more
66:39 - details on how to do this from scratch
66:42 - so give it a read all right so now let's
66:44 - look at the export to the Json so the do
66:47 - Json that it was saved so you don't have
66:49 - to click export you just have to save
66:51 - your map as a Json and you can
66:53 - immediately access the various
66:55 - properties so I go to room 1.
66:57 - Json maybe room two is going to be
67:00 - easier to parse because it's smaller so
67:03 - uh if you were to use a tile so every
67:05 - tile layer has the data props so first
67:07 - of all let's collapse everything and
67:10 - let's go get go at it uh one step at a
67:13 - time the most important part here the
67:16 - most important property is the layers
67:18 - property the layers property contains
67:21 - all of our layers and here it is I'm
67:24 - just going to collapse everything so
67:26 - each object here is a
67:28 - layer and Y let me just collapse so we
67:32 - have one 2 3 4 five 6 7 eight layers and
67:38 - this corresponds to what we had entit
67:40 - which is 1 2 3 4 five 6 s eight
67:44 - layers but it's reversed so the first
67:46 - layer here in the the array is going to
67:49 - be the lowest layer because uh the way
67:52 - usually uh Graphics Library works is
67:55 - that the first thing drawn is the the
67:59 - the thing drawn at the lowest level the
68:02 - the lowest layer so if you have a tile
68:05 - layer and not an object layer what you
68:07 - will have is the data property so this
68:10 - data property specify for each uh tile
68:15 - which tile in the Sprite sheet to draw
68:18 - if it's zero it's going to be uh zero so
68:21 - it's going to be the absence of the tile
68:23 - so nothing and here the number it
68:25 - corresponds to the frame in the Sprite
68:28 - sheet but because we aren't
68:31 - drawing
68:33 - the the the tiles in Kaboom but rather
68:37 - just using a PNG that contains
68:39 - everything because somehow it's more
68:41 - performant and I don't know exactly why
68:43 - how K Kaboom implements this and why
68:45 - it's the case uh we don't need to parse
68:48 - this layer at all so any tile layer we
68:51 - have here we can just safely ignore it
68:54 - so we're going to ignore that
68:56 - and yep so the way I'm going to do this
68:58 - in the code later on is I'm just going
69:00 - to check the type here so you have this
69:02 - property called type that is either tile
69:04 - layer or object layer so if we see that
69:07 - we have a type of a tile layer we can
69:09 - just continue in the for Loop so we're
69:10 - going to write some code to iterate
69:12 - through that so the second layer also is
69:15 - a tile layer the third one the fourth
69:17 - one the fifth one is where things get
69:20 - interesting we are now having a object
69:23 - group so the object layer is named in
69:26 - the actual Json file as object group and
69:30 - the difference is that it does not have
69:33 - a data property like with the ti layer
69:35 - it has instead an objects property and
69:38 - it's an array that will contain every
69:40 - object so here every collider with the
69:42 - width the height and the X and Y
69:46 - coordinates however if it's a pin it's
69:48 - just going to contain the X and Y
69:50 - coordinates so Mo mostly for the
69:51 - positions layer it's going to be that
69:54 - and using this information this data
69:56 - we're going to be able to uh draw uh the
70:00 - hitboxes and place the the players
70:02 - positions Etc so here I'm going to con
70:05 - I'm going to put in a constant the
70:07 - layers of our room datas and by just
70:10 - using the layers property accessing that
70:13 - we don't need the rest and then here I'm
70:16 - going to create a game object that is
70:18 - going to act as the parent of everything
70:20 - it's going to be the map game object for
70:22 - the scene and the way I'm going to do
70:25 - that this is by having the add function
70:28 - and placing this at positional 0 0 uh
70:32 - you do not need to do that I think
70:35 - because by default if you don't specify
70:37 - it's going to put it at z0 but just you
70:39 - know if in case you want to move the map
70:42 - elsewhere like the whole map you're just
70:45 - going to modify this value anyway so I'm
70:48 - going to set it to z0 explicitly but
70:51 - feel free to not do that I don't think
70:52 - it's going to cause an issue and here
70:54 - we're going to load the room the image
70:57 - the room one so if you remember when I
71:02 - told you to copy and paste the code from
71:04 - GitHub uh we loaded the images for the
71:08 - room one and Room 2 PNG here and using
71:11 - the room one and room two uh Keys here
71:15 - and then if I go back to room 1js we can
71:18 - just use the Sprite that you have
71:20 - already loaded by using the Sprite
71:21 - component Kaboom so this will work also
71:23 - for all the other things that need
71:26 - Sprites and specify this the Sprite name
71:29 - so here we have an object that is going
71:31 - to act as the parent of all game objects
71:33 - so in Kaboom J you can create game
71:36 - objects that are going to act as
71:38 - children of other game objects so you
71:42 - have here for now this game object the
71:45 - map doesn't have any parent the reason
71:47 - we're doing this by the way is because
71:49 - the positions are relative to where the
71:52 - map starts in the tiled export so in t
71:55 - in the Json file so if you were to just
71:57 - create the game object separately you
72:00 - would have the positions of everything
72:02 - being off that's why I prefer to just
72:04 - use a map uh a parent game object which
72:07 - is represents the whole map and then put
72:09 - everything uh Rel uh relative to that as
72:13 - a child of that game
72:15 - object okay so now we can just continue
72:19 - so then the next thing is to create the
72:23 - colliders um
72:26 - to store in the constant the colliders
72:28 - which is just going to be room layers
72:30 - and then the actual number so in instead
72:34 - of like uh I'm just going to pick the
72:36 - specific layer that corresponds to
72:38 - objects uh and I'm just going to have
72:40 - the dot object so here uh if we go back
72:43 - to the
72:45 - export um I guess room
72:48 - two this is going to be index 4 so I'm
72:53 - just if I just clect everything here so
72:58 - one uh zero 1 2 3 and four zero because
73:01 - we are in an array so the fourth element
73:04 - is going to actually contain the objects
73:07 - for the colliders so the yeah the
73:09 - objects property is basically all the
73:11 - the the colliders uh data so that's why
73:14 - I use this maybe you shouldn't do this
73:18 - uh if you want more flexibility but for
73:20 - this project I don't think it's needed I
73:22 - have specifi I have decided to have
73:24 - eight layers but maybe if you decide to
73:27 - add more or less layers or replace them
73:30 - maybe you want a more flexible system
73:32 - where you just going to check you're
73:34 - going to iterate through the the layers
73:37 - and then check if the name correspond to
73:40 - colliders and then use that so actually
73:43 - we could write I could spend the time
73:44 - writing this logic like that so maybe we
73:46 - should do that actually uh yeah so if I
73:50 - were to do const for
73:53 - layer of
73:55 - uh room
73:58 - layers and then here I'm going to have
74:02 - instead
74:03 - a
74:05 - um a
74:09 - colliders I don't like that I really
74:12 - don't like that so I'm going to do this
74:15 - because you know in JavaScript an array
74:18 - even if you put it cont even if you put
74:22 - this as a const you can modify the
74:24 - content of the array it's not actually
74:27 - constant
74:28 - so if I do let here but I'm going to
74:31 - assume you you know JavaScript uh so
74:34 - here I'm going
74:36 - to have
74:38 - if the layer do name is
74:45 - colliders then I'm going to do colliders
74:49 - and I'm going to use the
74:52 - um um I'm going to put push it
74:58 - the
75:00 - room the layer itself layer dot
75:07 - objects so I'm going to spread it over
75:09 - and then push it all at
75:12 - once I think it's not going to do what I
75:14 - think it's going to do right okay let me
75:17 - just um if I put the spread operator
75:20 - it's just going to create an array
75:23 - within the array
75:26 - actually actually it should sprad it but
75:29 - anyway I'm just going to console. log
75:31 - the
75:32 - result I don't think this will work but
75:35 - yeah so this is something I think is a
75:37 - better coding
75:39 - practice layer. object uh I forgot typo
75:43 - here it's
75:45 - objects so I go
75:49 - here okay we have an array with all the
75:53 - elements in that's great so it
75:56 - works okay it
75:58 - works so here as soon as we do this
76:01 - we're just going
76:02 - to
76:05 - break and then if I make making sure the
76:08 - code actually
76:10 - works yep it works all right nice so
76:13 - this is a better way that means
76:15 - regardless of how you structure your til
76:19 - as long as you have the names right you
76:22 - can find the the layer it's more
76:25 - computationally expensive to do that
76:27 - because you have to do a for and iterate
76:29 - through the the uh the layers uh
76:32 - actually the name of the layers not
76:34 - necessarily every element in the layer
76:36 - but I think it's worth it so here we go
76:39 - and we break here because we don't need
76:40 - to do any more calculations as we go on
76:44 - okay so we have that and then now what
76:47 - we're going to do is actually we're
76:50 - going to write some UT Tails so in the
76:52 - r. UT Tails we're going to write in a if
76:55 - a reusable
76:56 - function the logic to place the
76:59 - colliders in the map so I'm going to
77:01 - call it set map
77:05 - colliders and in that I'm going to need
77:09 - a the constant of course I'm going to
77:11 - need the map Parent Game object and I'm
77:13 - going to need the colliders themselves
77:15 - to know where to place
77:16 - them and uh so here and
77:21 - then the okay so we have everything and
77:24 - then here we go we have the collider so
77:26 - for const collider of
77:33 - colliders and then so T through them so
77:38 - here we're going to have actually
77:41 - there's one thing I forgot to
77:43 - mention is that in our collider layer
77:47 - there's a specific kind of cider that is
77:49 - different from the rest it's the slope
77:51 - here it's not a normal rectangle that
77:54 - has been drawn with this and you won't
77:55 - find this in the blog post because I
77:57 - haven't mentioned it here we need to
77:59 - have a polygon so if I draw a
78:02 - polygon maybe I should U what ah so I
78:08 - need to select colliders so a polygon
78:10 - allows us to you know have slopes like
78:12 - that for example I have a triangle here
78:15 - the difference uh is the following so if
78:19 - I select that polygon we have an X and Y
78:23 - but uh wait a minute there's something
78:26 - missing it should
78:29 - uh does it actually do anything so XY
78:32 - rotation
78:34 - template there is another
78:38 - property for some reason it's not
78:40 - appearing so basically what I want to
78:42 - say is that for polygons it gives you um
78:47 - coordinates there is going to be
78:48 - coordinate a coordinates prop uh for
78:52 - some reason this is not appearing here
78:55 - uh in this
78:58 - part okay Parallax
79:04 - it okay that's strange but okay so I'm
79:07 - just going to delete
79:09 - that so if I go to the oh maybe that's
79:14 - what that was why so I'm going to redraw
79:16 - it here a
79:18 - triangle and then what happens if I do
79:21 - this okay so it doesn't seem to appear
79:24 - on its own in the inspector here but if
79:29 - we go to the title export and look for
79:32 - the slope this is not going to be in
79:34 - room 2. Json it's going to only be in
79:36 - room one so if I go to room 1.
79:41 - Json and I'm going to do a quick search
79:44 - here with contrl f and try to find
79:47 - the um polygon property you see okay so
79:51 - it's a polygon property that gives you
79:54 - an OP object an array of the coordinates
79:56 - of each of the point of that polygon
79:58 - this is a specific thing for those
80:00 - colliders that you draw using the
80:02 - polygon tool so the polygon tool if is
80:06 - this one here so that means in our room
80:09 - utils we're going to have to first
80:11 - iterate through all the colliders but
80:13 - now if the collider has the so if the
80:16 - collider has the polygon
80:19 - property then we're going to first
80:22 - create a coordinate
80:25 - um
80:28 - array and oops and then I'm going to
80:32 - have a for Loop and I'm going to iterate
80:34 - through each of the
80:36 - points of the collider do oops collider
80:42 - do
80:46 - poon so collider polygon which is the
80:49 - property that contains an array of each
80:50 - of the coordinates for each of the
80:52 - points of that polygon
80:55 - and then I'm going to push inside my
80:58 - coordinates
81:00 - array those coordinates but this time
81:02 - around I want to use a vector to so in
81:06 - Kaboom Jaz the way you specify
81:08 - positional components is by if I
81:11 - remember correctly here I I set to Z 0
81:15 - but another option is to pass in a
81:16 - vector two so you could have done Vector
81:18 - 2 and then 0 0 uh so the the reason this
81:23 - using Vector 2 is useful is that when
81:25 - you want to the set the position after
81:28 - the fact so if you want to do this map
81:31 - and then set the position it's often
81:34 - handier to just do that uh you cannot do
81:36 - other than that or have to do map.
81:40 - pause. X and then a specific value and
81:43 - then map. pause. Y and then specific
81:46 - value so that's a way to make things
81:49 - easier for us later on so that's why I I
81:52 - push them into this coordinat uh array
81:55 - then I just collect
81:56 - 0.1x
82:00 - 01y so here we go and then here I'm
82:04 - going to add them to the map so the way
82:06 - you add child game objects to the main
82:09 - game to a game object is you take the
82:11 - game object and then you use the add
82:12 - function the add method on it so to uh
82:15 - later earlier on we used the add
82:18 - function in Kaboom to create a game
82:20 - object but this but each game object has
82:23 - the add method available to them to add
82:26 - child game objects to them so not only
82:28 - this add method creates a new game
82:30 - object but it it appends it as a child
82:33 - of that map at that parent of that
82:36 - Parent Game object
82:38 - sorry so here specify the position and
82:41 - then here I can just do um okay that was
82:44 - a a bit so in the original source code I
82:48 - just did collider X collider y uh Y
82:50 - which basically defeats the purpose of
82:53 - having created a vector 2 so I'm just
82:55 - going to use a um coordinate uh wait a
83:02 - minute okay that what's the point of
83:05 - it okay maybe I have created this for
83:07 - nothing uh ah okay no never mind never
83:10 - mind this is different because we have
83:13 - the the position of the collider which
83:14 - is defined in the collider properties X
83:17 - and Y but now we also need to have the
83:21 - area component and the so there there's
83:24 - two things to explain here sorry first
83:26 - thing what is the area component so the
83:28 - area component in Kaboom JZ creates a
83:30 - hitbox for your game object by default
83:33 - it takes the shape of your Sprite
83:35 - component or the rectangle component the
83:38 - wct component or any shape you have
83:40 - already specified earlier but if you
83:42 - don't have a shape specified you can
83:44 - specify custom shape by using the shape
83:47 - property passed inside of it and here
83:50 - I'm going to create a new polygon which
83:53 - is a class
83:55 - Constructor in kabz that allows you to
83:57 - create a polygon uh based on a coordinat
84:00 - an array of coordinates and this is
84:02 - where the coordinate constant we have
84:04 - here is useful because we we can just
84:06 - pass it as directly here and actually
84:10 - this is why here it was important to
84:12 - convert this to a vector 2 because this
84:15 - Constructor takes an array of Vector 2
84:18 - that's why we had to do it as well it's
84:21 - not just because it's handy as well
84:24 - so yep we have this and another thing
84:27 - I'm going to use and this is to increase
84:29 - the performance is I'm going to have set
84:31 - the Collision ignore property which is
84:33 - something that Kaboom offers as well
84:35 - where you pass in an array of tags so
84:38 - each game object can have a tag a tag is
84:41 - basically a way to identify this game
84:43 - object um so the way you define tags is
84:47 - in your arrays of component when you
84:49 - Crea you are creating the game object
84:50 - you can just pass in a string as well
84:53 - and this is going to act as the tag and
84:54 - you can have more than one tag so here
84:56 - I'm going to pass the tag uh the tag
84:58 - collider it's just a name I have decided
85:00 - to identify all game objects that that
85:04 - are created this way uh and in the
85:07 - Collision ignore property in the area
85:09 - component I can pass in that name
85:11 - collider and it will make sure to ignore
85:13 - any collisions uh calculations Etc uh
85:17 - when two collider game objects collide
85:20 - with each other and this is useful for
85:22 - performance because we don't really want
85:25 - to calculate the collisions between this
85:27 - and this or this and this it's kind of
85:29 - useless so and it's going to be more
85:32 - performance intensive for no
85:34 - reason so that's a trick to have more
85:37 - performance and then finally we have the
85:39 - collider
85:41 - type uh here it's important to pass the
85:44 - collider type because if you remember uh
85:46 - not every collider has a type in our uh
85:49 - in our um map here but those uh oops I
85:55 - didn't want to create a new polygon so
85:57 - I'm just going to contrl Z so if I
86:00 - select it with the pink tool
86:03 - here if you select this the class here
86:06 - pass through is going to be referenced
86:08 - you can access this name through the
86:09 - type property I don't understand what
86:12 - why they're different maybe the class uh
86:15 - property is a reserved keyword in
86:17 - JavaScript I don't remember I don't know
86:19 - why exactly they decided to have
86:21 - different names but this is useful
86:23 - because now we can have create a new tag
86:26 - which basically is a string uh specific
86:30 - for the pass through platforms by just
86:32 - passing the type here so if a collider
86:35 - doesn't have a type it's just going to
86:37 - be an EMP empty string and an empty
86:39 - string is just basically not a tag not
86:41 - considered a tag in
86:43 - Kaboom so that's hope I was clear here
86:46 - feel free to ask questions by the way in
86:47 - the comment section if you have any
86:50 - issues and then we continue so the
86:53 - reason we continue continue here is
86:54 - because if it's not a polygon uh
86:57 - collider we we need to write a different
87:00 - logic so here the next case is that if
87:04 - we have a collider and the name of the
87:06 - collider is a boss barrier which is one
87:08 - of the exceptions here what we're going
87:11 - to do is
87:13 - um oops here we go so if the collider
87:16 - name is a quick boss barrier we're going
87:19 - to create the boss barrier but this time
87:21 - around we're going to store the
87:23 - reference to that game object it's still
87:24 - going to be a parent a child of the map
87:27 - game object so one thing is is Handy
87:29 - with the ad function and the make
87:31 - function as well you're going to see
87:32 - later on is that um it gives you
87:36 - reference it returns a reference to that
87:38 - game object when you use that so you can
87:40 - keep it here keep it handy here so here
87:43 - the boss
87:44 - barrier I think I'm going
87:47 - to actually you know what uh for now
87:50 - let's skip that I'm going to do to-do
87:52 - and we're going to do that later on
87:54 - and if going to continue if to the next
88:00 - iteration and then the last case
88:03 - uh yeah so all the other case are just
88:06 - normal colliders and we can just add
88:09 - them as a
88:10 - child of the map and specify collider X
88:16 - collider y but for all those normal
88:19 - colliders the shape we're going to
88:21 - Define is just going to be a normal
88:23 - rectangle you can specify this by using
88:25 - the rect Constructor here it's different
88:28 - it's different than the re component re
88:30 - component actually draws the rectangle
88:33 - while the shape the creating a
88:35 - rectangular shape is just going to make
88:37 - the hit box all hit boxes like this can
88:40 - be viewed uh if you press the F1 key and
88:43 - enter debug
88:44 - mode uh well actually enter debug mode
88:47 - by pressing the F1
88:49 - key so if I do this so so here the for
88:55 - the rectangle Constructor the way you
88:57 - create a rectangle you have to pass
88:59 - three parameters the first one is the
89:01 - position and I'm just going to pass an
89:03 - empty Vector to uh this basically tells
89:07 - that there is no difference from because
89:10 - if you were to specify values here X and
89:13 - Y coordinates it's going to draw the
89:14 - shape uh the hitbox relative to the game
89:17 - object and in certain cases you want
89:19 - that you want the the the hbox to not be
89:23 - uh directly aligned
89:24 - on the same position as the game object
89:27 - but sometimes you don't want that so you
89:29 - just specify a
89:31 - 0 uh Vector two here as the first param
89:35 - and then the second param is the
89:36 - collider
89:38 - width
89:40 - and the
89:42 - collider he
89:45 - here so here we go and uh here we're
89:50 - going to use the body component so the
89:52 - body component is a comp component that
89:54 - can only be used when you have the area
89:56 - component defined so you first need to
89:58 - have the area component defined because
90:00 - you need the headbox and the body
90:02 - components for physics so here we want
90:05 - to have the physics of so by default if
90:08 - you just call k. body the go if you just
90:10 - add the body component it's going to
90:12 - make your game object susceptible to
90:15 - gravity if you specify though inside of
90:18 - it the is static property and set it to
90:20 - true it's going to be a wall uh
90:23 - basically a itic body it won't move when
90:25 - collided with it's going to act
90:27 - basically as a wall an
90:30 - obstacle and here I'm going to also have
90:32 - the collider
90:34 - tag and I forgot to here to add the
90:37 - Collision ignore as
90:39 - well
90:41 - Collision
90:44 - ignore oops collider so I've explained
90:49 - this
90:52 - already and uh we also pass the collider
90:56 - type um as I said for the past two
90:59 - platforms this is going to be useful
91:01 - because for some of them it's going to
91:03 - actually you know what since we have
91:04 - only one slope if we go back to the
91:07 - polygon uh we actually don't need to
91:10 - pass this type here because in case you
91:13 - want to in the future to maybe have
91:15 - passed through platforms that are also
91:18 - slopes like that I I I guess we can just
91:21 - let it be so yep
91:25 - um so yep we have done this and now it's
91:28 - time to call that function in room
91:30 - 1js so in room
91:33 - one uh yeah here we have the colliders
91:36 - not so right below I'm going to call it
91:38 - set map colliders it's going to import
91:41 - it from uh room .js make sure that this
91:44 - is ajs and here okay and then pass in
91:49 - the map so okay for the context and then
91:51 - the colliders we can just pass the
91:53 - colliders
91:55 - uh colliders here we go let's let's test
91:59 - everything out so if I go to the browser
92:02 - hit enter can
92:05 - see the map being fully drawn and the
92:08 - colliders also by pressing the F1 key
92:11 - now for now the the performance isn't
92:13 - very good but you're going to see later
92:16 - on we're going to do a bunch of stuff I
92:18 - think we're going to add a few things
92:20 - that makes it I think the offscreen
92:22 - component
92:24 - actually actually I think the the
92:26 - performance is good it's just it's just
92:28 - my PC where when it's unplugged it it
92:32 - runs at a lower frame rate H yeah and
92:34 - also the fact that when you open up the
92:37 - uh the debug mode it adds a bunch of
92:39 - drawing calls to draw the the layers and
92:41 - that's why the FPS count drops but the
92:44 - actual game performance as you're
92:45 - playing should be 60 FPS so now uh
92:49 - because this is not very inviting to
92:51 - look at because it's too small I'm going
92:53 - to uh do a bunch of camera operations so
92:58 - in kabz can control the camera
93:00 - relatively easily so here H I'm just
93:03 - going to call the cam scale method
93:06 - allows us to zoom the camera I'm going
93:07 - to zoom it four four times I think this
93:09 - is what will look good for the cam
93:12 - position I'm going to put the default
93:14 - position at 170 by 100 those are all
93:17 - arbitrary values I just came up with
93:20 - them by experimenting and then I'm going
93:22 - to set the gravity to being a value of
93:25 - 1,000 uh I don't know what the metric is
93:29 - the unit for that is but U 1,000 is what
93:32 - felt good but for now it shouldn't have
93:34 - any impact because we we don't have any
93:37 - kinematic body or any player or enemies
93:40 - yet so if I go here press enter you can
93:43 - see the map so in the next part of the
93:46 - tutorial we're going to hopefully start
93:48 - working on the player and the logic for
93:50 - that and making the player move Etc all
93:53 - right now that we have the map here
93:56 - displayed uh we could proceed on and
93:58 - work on the rest of the map cameras Etc
94:01 - or we could start and work on the player
94:05 - so I think a good we should actually go
94:08 - and work on the player logic I think
94:11 - that would be the best so we can start
94:13 - implementing movement Etc and since we
94:16 - have the map it's going to be easy to
94:18 - test things out so now what what I'm
94:21 - going to do is I'm going to go to the
94:24 - folder structure and then create in the
94:27 - entities folder a new file this file is
94:30 - going to be called the player. JS and
94:33 - it's going to contain all the logic we
94:35 - need for the player so here we go so
94:39 - here what do we need so I'm just going
94:40 - to collapse this so what do we need is
94:44 - first of all I'm going to create a
94:47 - function and this function I'm going to
94:50 - call it make player so in Kaboom JS uh
94:53 - usually uh there's nothing against
94:56 - objectoriented programming but usually
94:58 - don't use classes well I usually don't
95:02 - don't use classes and if you look at the
95:03 - examples on the dogs Etc usually don't
95:06 - use classes so here the make player is
95:09 - going to act as our Constructor but uh
95:12 - yeah so it's going to uh we're going to
95:14 - use the make function this time around
95:16 - the make method so yep the make method
95:21 - is like the ad method in kaboom but
95:23 - instead of creating a game object and
95:25 - then displaying it on the screen what it
95:27 - does it only creates the game object so
95:30 - later on you can take the game object
95:33 - and then put it inside of an add call to
95:36 - really add it to the scene so here I
95:39 - prefer to use this make function to
95:41 - actually make the game object and then
95:43 - in the room logic in the the actual
95:45 - scene I'm going to make the call to
95:47 - actually put it as a child of the map so
95:50 - here we go so here what are the
95:53 - components we're going to need to make
95:54 - our player so just to Circle back on the
95:58 - reason I object oriented might not be
96:01 - really use but you can actually use it
96:03 - but the reason is that when making a
96:06 - game object you have you can pass in an
96:09 - array of components you can pass a
96:12 - string that will act as a tag but you
96:14 - can also pass an object and is it this
96:17 - object can contain basically your
96:19 - methods for your game object so you
96:21 - don't need to create a class so for
96:24 - example here let F let's first create uh
96:27 - create add sorry our game object our
96:30 - components that we're going to need for
96:32 - this uh player uh character and then as
96:36 - we go on I'm going to add a bunch of
96:38 - methods for the actual Behavior Etc
96:41 - we're going to
96:42 - need dur in inside of that object so
96:46 - first of all the positional component is
96:49 - very important now one thing I forgot to
96:52 - mention is that you need to call this
96:55 - the you need to actually use the
96:56 - positional component even though by
96:58 - default it's going to just put the
97:00 - player at the position 0 0 and that's
97:02 - because if you want to modify the
97:04 - position afterwards it's important to
97:07 - have the positional component used here
97:09 - otherwise it's not going to work now I'm
97:11 - not really sure about that but I think I
97:14 - remembered it that way so maybe try it
97:16 - out and see if you can do
97:18 - without so now I'm going to also use the
97:21 - Sprite component
97:23 - and I'm going to here use the player
97:25 - Sprite this was defined earlier on in
97:28 - the Kaboom loader so if I go here Kaboom
97:31 - loader and to the actually the first
97:33 - load Sprite call here was where we
97:35 - loaded our player so here and uh yeah we
97:39 - just load the Sprite and then later on
97:41 - we're going to pick an an animation and
97:43 - play
97:44 - them okay what do we need else is the
97:47 - hitbox so as I said as I mentioned
97:49 - earlier on hitboxes can be um created it
97:53 - by using the area component by default
97:56 - if you just uh don't do anything uh
97:59 - except just using the area component
98:01 - just calling it you're going to have a
98:03 - default hitbox that takes uh roughly the
98:05 - size of the Sprite but I want more a
98:08 - granular control over that the reason I
98:11 - want more control is because I want to
98:14 - actually the hitbox to be the constant
98:16 - and the same regardless of the various
98:18 - animations and I want to place the
98:20 - hitbox in such a way that the player is
98:23 - going to look good uh in terms of
98:26 - movement Etc so the frames should be
98:29 - well positioned so here I'm going to use
98:31 - the shape property that I've shown
98:33 - earlier on and again call the new and
98:36 - then K and here of course I forgot to
98:38 - pass in the K the Kaboom context here so
98:42 - I'm going to use the react Constructor
98:45 - as I explained here for the first pram
98:48 - we're actually going to offset the
98:50 - hitbox to be at 018 so so this 18 y
98:54 - coordinate relative to the actual
98:56 - position of the game object and here I
98:59 - forgot a comma so maybe here I should
99:02 - probably have this to have it well
99:04 - formatted so shape new k. rect and then
99:07 - as the first peram here now this is a
99:10 - value I've played with um later on when
99:12 - we're going to actually look at the
99:14 - results you're going to see that uh like
99:16 - what what looks good the second Pam is
99:18 - going to be the width and here it's
99:20 - going to be a width of 12 and the height
99:22 - is also going to be of 12 this this way
99:26 - the the actual Sprites I think are 16 or
99:30 - 32 by 32 uh the reason I'm using 12 by
99:33 - 12 here is because it's uh the hit box
99:36 - is going to be small enough so that uh
99:39 - there are still some collisions the
99:40 - player cannot move in weird places but
99:44 - it's it's also small enough so that the
99:46 - player doesn't get hit uh all the time
99:49 - so it's a a generous I guess hitbox to
99:51 - be small
99:53 - okay
99:54 - now I think that's it for this one and
99:58 - we can move on to the next one the next
100:01 - component sorry so the next component
100:03 - we're going to use is the body uh the
100:06 - anchor component so the anchor component
100:08 - it's a new component uh that I haven't
100:10 - explained yet uh this allows you to
100:14 - Center um to determine from where the
100:17 - Sprite the the game object is drawn or
100:20 - centered by default all game objects are
100:24 - are placed or centered from the top left
100:28 - from their top left corner if we don't
100:30 - want that we want actually the center of
100:32 - the game object to be the position we
100:35 - can use the anchor component to specify
100:38 - that you can specific uh Center uh top
100:42 - left top right and you can even pass I
100:44 - think a vector two as well if you want
100:46 - more control I'm not sure about that
100:48 - last one but I think in the the
100:50 - platformer tutorial um the one my 8 hour
100:54 - uh 7 hour almost 8 Hour tutorial uh I
100:58 - think I did something where I control uh
101:01 - actually uh set the anchor to be a
101:03 - specific value I'm not sure though I
101:06 - don't remember that project that much
101:09 - anyway uh once we have this um I'm going
101:12 - to also use the body component this is
101:14 - very important because since this is
101:16 - since this Metro Vania is a 2d side
101:19 - scroller it's basically a platformer so
101:21 - we need to use the body component so
101:23 - that the player is going to be affected
101:24 - by gravity that means that it's going to
101:26 - be like it's going to fall
101:29 - Etc and here we can specify a bunch of
101:32 - other properties so we can specify the
101:35 - mass of our player I'm going to use 100
101:38 - as the value how I came up with this was
101:40 - just by tweaking and we can also set the
101:43 - jump Force so this is when we're going
101:44 - to implement jumping uh you can set up
101:47 - in kabj as the jump force and here 320
101:50 - was a value which I thought was powerful
101:53 - full enough uh so that the player can
101:55 - have a nice jump but not too much so
101:58 - that they hit the the ceiling of the
102:00 - levels so here we go and
102:04 - uh also we are also going to add the
102:07 - double jump components so double jump is
102:10 - a component that is provided by kaboon
102:13 - that allows you to easily Implement
102:14 - multiple jumps it's it doesn't have to
102:16 - be double so you could have more than
102:18 - that now here for double jump it's um I
102:23 - usually so I usually set it to one
102:27 - initially so I'm going to set it to one
102:29 - and then as we
102:31 - unlock the we beat the boss it's going
102:33 - to be set to two but the logic for this
102:36 - isn't here yet and actually you know
102:38 - what it's a good time I think to start
102:41 - handling our state setting the the
102:44 - groundwork for that so we want to have
102:46 - Global state to keep track of our
102:48 - players progress and I'm just going to
102:51 - create that in a folder called GL state
102:54 - I'm going to call the file
102:56 - global global State manager. JS and the
103:02 - way the pattern I'm going to use is
103:04 - going to be very simple so here what I'm
103:07 - going to do is simply I'm going to
103:09 - create two things I'm going to create
103:11 - first a constant that is going to be the
103:12 - state props enum and you're going to see
103:17 - why in an instant and the second one is
103:19 - going to be a
103:21 - function and I'm I'm going to call it
103:23 - init State
103:26 - manager and what it does it's going to
103:28 - return uh actually first we Define a
103:32 - state object which is going to contain a
103:35 - bunch of State we want to keep track of
103:37 - for example the player HP by default we
103:40 - want the player HP to be three then the
103:42 - max player HP uh we want it to not
103:45 - exceed three because for this project
103:47 - specifically the health bar in the the
103:50 - Sprite work the assets is basically
103:52 - three and it's not very flexible uh so
103:56 - instead of you know fighting this Etc
103:57 - I'm just gonna make sure the player only
104:00 - has three lives if you were to actually
104:03 - expand upon the game I would recommend
104:05 - just uh making your own UI uh components
104:08 - uh yourself or maybe tweaking those
104:11 - Sprite for example you could uh just
104:14 - take the the outer frame of the UI here
104:19 - you could take the outter frame so for
104:21 - example you would cut out all of this
104:24 - pixel art and have the all of this part
104:28 - transparent and then you would fill it
104:31 - in with color I actually I should have
104:33 - done this with a rectangle that grows in
104:35 - strings so yeah just some ideas you can
104:39 - uh yeah try it and then here I'm going
104:41 - to have it is double jump unlocked and
104:46 - I'm going to set it as
104:47 - false player is in boss fight
104:54 - another and I'm going to also set it as
104:56 - fault uh false and then is boss
105:00 - defeated defeated and then I'm going to
105:03 - set it as false so as you uh make this
105:08 - game grow in complexity you can have a
105:11 - bunch more events here that you want to
105:12 - listen on and state you want to keep
105:15 - track of now I'm going to return here
105:19 - I'm going to return one thing a current
105:21 - method so by the way in JavaScript you
105:23 - can Define functions like this with an
105:25 - object this is a short hand or
105:29 - this which you might be more you might
105:32 - be more familiar with so I prefer to
105:35 - just do that and uh here in this current
105:40 - method we're going to return a copy a
105:44 - readon copy of the state so while the
105:48 - user of that that's so the one who calls
105:51 - the current uh method can modify the
105:55 - object here it will not affect the
105:57 - actual state so for actually setting the
106:00 - state we want to use we want to create a
106:03 - Setter I'm going to call it set here it
106:06 - takes in a property as a string and a
106:09 - value you want to change and then here
106:11 - internally it sets the actual State here
106:14 - uh for the given property property to be
106:18 - the value here oops not value one
106:23 - here you go so here we go and here it's
106:28 - where things could get messy is that
106:30 - since this is a string you could pass in
106:32 - whatever you'd like that's why I created
106:33 - this state props enum where you can
106:37 - actually maybe I'm just going to copy
106:39 - and paste this you just have names like
106:42 - that player HP refers to the player HP
106:44 - string now this is isn't ideal in in
106:48 - terms of like if we were working with
106:50 - typescript we wouldn't have to do
106:51 - something like that but I think it gives
106:53 - us a a much nicer way and less error
106:56 - prone way of setting the state so just
106:59 - to explain if here I want to only unlock
107:02 - the double jump uh for the player who
107:05 - has defeated the well actually if I want
107:08 - to only enable the double jump if the
107:11 - player has the double jump unlocked then
107:15 - what I would do here is I would do state
107:18 - and then uh did I export it sorry I
107:20 - forgot one very important stuff is to
107:23 - have another export where this is the
107:25 - just the function that we call and then
107:27 - we have export const State and then this
107:30 - is what we're going to actually export
107:31 - so we're going to initiate the state
107:33 - manager and then this is the state um
107:37 - that we export so here in the jump I'm
107:40 - going to type
107:43 - state state and then import
107:46 - it here we
107:48 - go and then don't forget to add ajs
107:53 - then once you do that you can do State
107:56 - current which is the method which is
107:58 - going to give us the current state and
108:01 - then you can immediately just have
108:02 - access to the properties here so is the
108:05 - double jump unlocked and if that's the
108:07 - case we're going to use a tary here tary
108:10 - uh condition uh expression because it's
108:14 - it's Compact and if it's the case what
108:17 - we're going to do is simply set the
108:21 - number of jumps to being two otherwise
108:23 - by default the player can only jump once
108:26 - so double jump is a component offered by
108:28 - Kaboom Jaz it allows us to really build
108:31 - this feature out very quickly and that's
108:33 - great uh another component we're going
108:36 - to need is the opacity component uh this
108:38 - allows us to control the opacity of the
108:40 - game object this is going to be useful
108:42 - when we want to make the player blink
108:43 - when they hit the they get damage that
108:47 - that way uh when that happens we can
108:49 - just control the opacity otherwise you
108:52 - cannot control the
108:53 - capacity and then that's a I think
108:56 - that's it uh the last one is the health
109:00 - component so Kaboom offers the health
109:02 - component which allows you to manage
109:04 - Health very U easily and here what I'm
109:07 - going to do is initially you initialize
109:09 - the health component with the the HP for
109:12 - the player and this we're going to pick
109:14 - this up from the state so for example in
109:18 - if in room two the player uh in room one
109:21 - the player takes damage so in room two
109:23 - we want to actually keep track of the
109:25 - the player Health that's why um we we
109:28 - recreate the game object for the player
109:31 - every scene so when we go from from
109:34 - scene one to scene two the the the make
109:36 - player function is going to be recalled
109:39 - and that's why we need actually to keep
109:41 - track of the health so that's why
109:43 - otherwise it will reset to revalue if we
109:46 - were to hardcode it here to three even
109:48 - though uh the player is just exploring
109:50 - another portion of the same world
109:53 - so state. current and then player
109:57 - HP all right and then
110:00 - finally we'll have a player tag this is
110:03 - going to be useful when we want to have
110:05 - on cied events we can just use that tag
110:08 - so that other um entities can just check
110:11 - for that all right so now that we have
110:13 - this done it's time to actually uh fill
110:17 - this object so one thing the reason why
110:19 - uh objectoriented programming in terms
110:21 - of using class es is not that necessary
110:25 - when working with Kaboom J is because
110:27 - you can specify properties within here
110:30 - so here I created the speed property I
110:32 - want my player to move at a speed of 150
110:34 - I also want the to set the is attacking
110:38 - property to being false so this is a
110:41 - property I created just to keep track of
110:44 - when the player is attacking for example
110:46 - when the player is attacking uh we want
110:48 - to make them uh un not vulnerable so
110:52 - they can't take damage where when the
110:54 - attack animation is
110:56 - running otherwise it would be um I think
110:59 - it it was a better way to go about for
111:02 - this project okay so here is our first
111:04 - meth method it's going to be set
111:06 - position now for this really I don't
111:09 - think this this one this method is
111:10 - really necessary we could just have a
111:12 - position here uh we could could call it
111:15 - initial pause I don't think I ever call
111:18 - this uh ever again except for placing
111:21 - the player so I can just do
111:23 - this like that uh so I'm not going to
111:25 - use that if if there's any issues I hope
111:28 - I will remember to just check here and
111:30 - re add it
111:32 - so okay so the first actual method we're
111:35 - going to use uh create for our player is
111:38 - the set controls set controls is going
111:41 - to be a method that is I always miss
111:44 - mistype and press the P key instead of
111:47 - the brackets which they're near each
111:49 - other so that's why and then it
111:51 - autocompletes with page
111:53 - transitions
111:55 - so um okay so this set control what is
111:58 - going to do is basically set the player
112:01 - controls one thing that's great with
112:03 - this um wait a minute yeah one thing is
112:07 - great with this creating methods within
112:10 - the object is that you can use this uh
112:12 - like in a class and create prop
112:14 - attributes that can be used by other
112:16 - methods so it's basically just
112:18 - objectoriented programming so here this
112:22 - control
112:23 - control I'm going to create a new uh
112:25 - sorry a new property and the way you
112:28 - could do that is just this and then the
112:29 - name of the new properties you want you
112:32 - want to create I'm going to call it
112:33 - control handlers and it's going to be an
112:36 - array that will contain um event
112:40 - listeners uh reference to event
112:42 - listeners for the various controls and
112:44 - the reason I create this is so that I
112:46 - can cancel all of these events event
112:50 - listeners when the player dies otherwise
112:53 - the player could die explode and then
112:56 - continue to move uh while the exploding
112:58 - animation is
113:00 - playing so here is the first call so I'm
113:05 - going to create this control handlers
113:08 - and going to push into it our first
113:09 - event listener that that I'm going to
113:11 - Define within this push call uh this
113:14 - push method I'm going to use the Onkey
113:16 - press event listener like I've shown you
113:19 - earlier and this time around I'm going
113:22 - to use a different form of the qess uh
113:25 - uh event handler from Kaboom instead of
113:27 - having specifying the key here for
113:29 - example enter like I did in the main.js
113:32 - file what I'm going to do is I just pass
113:34 - the arrow function and as the first Pam
113:36 - you can get the key uh by the way this
113:39 - is an arbitrary name the first Pam is
113:41 - going to be the key regardless of what
113:43 - it's named uh just for your information
113:47 - so here key on key press the key here so
113:50 - what I'm going to do I'm going to have
113:51 - an if statement
113:53 - and then if the key is for X let's say
113:56 - we have X and um if from within this.
114:03 - current animation so what what is this
114:06 - from so one thing is that this not only
114:09 - gives you access to the properties you
114:11 - created but gives you access to the
114:13 - whole game object and usually in kabon
114:17 - JS when you create a game object it has
114:19 - access to new methods and uh yeah new
114:22 - methods depending on the components you
114:24 - have used uh by default all game objects
114:28 - that use the that uses the Sprite
114:30 - component have access once they're
114:32 - created to the current animation Uh
114:35 - current anim method now this is Con
114:38 - that's this is going to be called when
114:39 - the game object is going to create so
114:41 - that's why we can actually start using
114:43 - them here so here this current
114:47 - anim allows us to know uh to check what
114:51 - is the current animation so if the
114:52 - current animation is not the jump
114:56 - animation then um wait a
114:59 - minute we want to play actually we can
115:02 - use the
115:03 - other uh method that is available for
115:06 - all uh game object that uses this Sprite
115:10 - component it's going to be the play
115:12 - function allows us to play the play
115:13 - Method sorry that allows us to play uh
115:16 - animations so here I'm going to play the
115:18 - jump animation all right so if you
115:20 - remember the jump animation is what we
115:22 - we defined earlier on in
115:25 - the uh where is it the Kaboom loader. JS
115:29 - so loader load Sprite player and here it
115:32 - is so from frame 51 to 51 so it's
115:36 - basically just one frame and you know
115:38 - what actually I realized this you could
115:41 - just have um set this up like that one
115:45 - frame and instead if it's one frame you
115:47 - don't need to um have all this you can
115:51 - just have one like
115:53 - that all right so let's do this if if
115:56 - the player I press the X the X key we
116:01 - first check if the current animation is
116:04 - the jump animation if it's the case if
116:07 - it's not the case we play the jump
116:09 - animation uh that's important because if
116:11 - the player press more than once the X
116:14 - key we don't want to cancel it but it
116:17 - doesn't really matter in this case
116:19 - because the animation is one frame so
116:21 - even if you spam again uh it won't
116:24 - matter because the the same frame will
116:26 - play however this would have been useful
116:28 - if the jump animation has more than one
116:30 - frame so I'm going to keep it in in case
116:33 - you want to modify the jump animation to
116:34 - have more than one frame and then
116:37 - finally we just call the double
116:40 - jump component and this is going to take
116:43 - care of either allow uh making the jump
116:45 - for the player so if the player is
116:47 - allowed to do more than one jump they're
116:49 - going to be able to do and it's the
116:51 - double jump component that takes care of
116:53 - that uh if you're new to Kaboom by
116:55 - default you also have the jump component
116:58 - so this jump component is unlimited so
117:01 - don't use it uh if you want to uh use
117:05 - this double jump mechanic
117:08 - uh uh one thing if if you use the jump
117:11 - animation uh the jump method what you
117:13 - need to do is check if the player is
117:15 - grounded so there is the is grounded
117:18 - method on every game object that uses
117:21 - the body component
117:23 - and by checking you can actually allow
117:25 - then the call for this to jump uh just
117:29 - for your information you can look at
117:31 - previous tutorials usually by default
117:33 - you implement the jump mechanic using
117:35 - the jump component but this is a special
117:37 - case where we actually want to allow
117:39 - more than one jump as part of the
117:43 - ability that the player unlocks after
117:45 - beating a
117:46 - boss here you could have decided to have
117:48 - a switch case statement but since we
117:50 - only have two cases I'm going to just go
117:53 - with one uh if statement so the next key
117:55 - is going to be the Zed key now depending
117:57 - on if you're in European keyboard uh The
118:01 - Zed and X key might not be the same in
118:03 - the same place as the quy layout so in
118:07 - that case
118:09 - uh either in Kaboom Jaz you cannot have
118:13 - the uh keyboard layout independent Keys
118:17 - you cannot set that on the on key press
118:19 - so as a as a workaround uh to this what
118:23 - I would recommend is maybe um allow the
118:26 - player to remap the keys in in a
118:29 - settings menu that that you can
118:31 - do all right so if the Z key is pressed
118:36 - and here we can also check so the reason
118:40 - this is in another if statement instead
118:44 - of being on the same one is that we want
118:46 - to allow the double jump if possible
118:49 - even if the animation was already
118:51 - playing
118:52 - but for this case if the Z key is
118:55 - pressed and the current animation is not
118:58 - on attack current anim is not the attack
119:02 - only then we will allow the attack to
119:06 - go uh otherwise yeah because the attack
119:09 - is already in motion if not the case and
119:12 - we also want to check that the the
119:15 - player is grounded so this is something
119:17 - that is particular so might it might
119:20 - sound strange why would the only be
119:23 - available on the ground well the reason
119:25 - for that is that the assets the asset
119:27 - pack doesn't have animations for jumping
119:29 - attacks and I didn't feel like adding an
119:31 - animation so uh just for the gameplay
119:34 - not to be weird uh the animation not to
119:36 - be weird I just decided you know you can
119:39 - this robot robot character that we play
119:42 - can only attack when they're grounded so
119:44 - what happens when an actual attack is
119:46 - fired so here is the logic uh we're
119:49 - going to you need to write this logic
119:50 - here so so first of all we're going to
119:53 - set the is attacking property to being
119:55 - true during the attack we are also going
119:58 - to create a new game object this this
120:01 - time around this game object is not
120:02 - going to be apparent of the map the
120:05 - reason for that is that um actually
120:08 - thinking about it it's not necessary um
120:13 - yeah I should have probably never mind
120:15 - never mind this game object is going to
120:17 - be a a CH a child of the game object the
120:21 - player which is a child of the parent so
120:23 - never mind we use the ad function the ad
120:25 - method to create a new game object it's
120:27 - going to be the hitbox for the sword
120:29 - attack so the way we're going to
120:31 - implement this is that when the player
120:33 - attacks we create an invisible hitbox
120:37 - that is uh that if the enemy it collides
120:41 - with it then we register an attack uh
120:45 - and we deal damage to the
120:47 - enemy so here I'm going to set the
120:50 - position of that game object to be this
120:54 - first flip. X I'm going to explain this
120:56 - line of going in an instant uh let me
120:59 - just or write it
121:01 - out so here we go so what does this do
121:05 - why why I'm doing this so flip X is a
121:08 - property that is available on all game
121:10 - objects that uses the Sprite component
121:14 - what it allows you to do is to flip like
121:16 - a mirror the the sprit is the sprit and
121:19 - the Sprite and uh that what that means
121:22 - is that uh instead of having a left
121:24 - facing Sprite and a right facing Sprite
121:27 - you can just get away with one and then
121:28 - just flip it around so if the flip
121:32 - animation so if the Sprite is facing
121:35 - left uh or yeah because by default the
121:38 - Sprite is facing right if you look at
121:40 - the images so if by Def if the the flip
121:43 - X attribute property is true that means
121:46 - the player is now facing left that means
121:49 - we need to move the hitbox to be to the
121:53 - left and that's why I have this Turner
121:56 - operation that does this it will
121:58 - subtract minus 25 to the current
122:00 - position of of
122:02 - the of the hitbox which is by default
122:05 - since it's a child of the player it's
122:09 - going to its position is going to be
122:11 - relative to the player so minus 25 is
122:14 - relative to the player H otherwise it's
122:17 - going to be zero and 10 so 0 10 is what
122:20 - looked good so the the hitbox is going
122:22 - to be drawn from remember the top left
122:24 - corner every game object by default is
122:27 - drawn by the top left corner it's only
122:29 - when you specify with an anchor
122:31 - component uh Center Etc that you can
122:34 - Center that instead of being drawn from
122:36 - the top left but for this uh the attack
122:39 - hit boox we don't need that all right
122:42 - then the second game object is going to
122:46 - be
122:48 - the area
122:50 - component so the area
122:53 - component is going to have a specific
122:55 - shape so here again it's the hitbox uh
122:58 - I'm going to use the rectangle it's the
123:00 - simplest shape here we don't need an
123:02 - offset for the position and we're going
123:04 - to make our uh sword hit Box 25 by 10
123:08 - this is what looked good relative to the
123:11 - animation and then finally we're going
123:14 - to
123:16 - also have a tag so the tag is going to
123:20 - be not here
123:22 - outside here sword hitbox which is going
123:27 - to be used to create event listeners
123:29 - that listens on collisions with this
123:31 - particular
123:33 - tag all right we have this and then of
123:35 - course we need to play the attack
123:38 - animation again defined in the Kaboom
123:40 - loader that we did earlier on and then
123:43 - here we're going to have a on anim on
123:46 - anim end which is a event listener
123:50 - offered method offered by Kaboom for
123:54 - every game object I probably used a
123:57 - Sprite component and what it takes is
124:00 - the it gives you actually the animation
124:03 - name and if and then you can write some
124:05 - logic if the animation
124:07 - was the
124:09 - attack
124:11 - then you could we can first get the
124:15 - sword hitbox sword hitbox the way you
124:19 - can get a game object by its taging is
124:21 - by using the get function uh method
124:25 - function actually this is a function
124:26 - from kabo and we pass in the tag and
124:31 - since this sword hitbox is a child of
124:34 - another game object that means we're
124:37 - going to have to use
124:40 - recursive
124:41 - recursive true and the get meth function
124:46 - gets all game objects with this tag that
124:49 - means if there's more than one it's
124:51 - going to get
124:52 - and return an array so because it always
124:55 - returns an array even if there's only
124:57 - one I'm going to just pick the first
125:00 - element there's only any way going to be
125:02 - one uh sword hitbox created at a time so
125:06 - if the sword hitbox we first get a
125:09 - reference to it because we don't have
125:11 - access to this actually you could have
125:13 - decided to create another property
125:16 - within the uh here within but uh since
125:20 - we destroy that game object it's better
125:22 - to just you know use the get function
125:24 - get the the current sword hit box that
125:27 - exists and then destroy it so here we do
125:30 - this and then if only if the swords the
125:35 - sword hitbox actually exists because
125:37 - sometimes uh the sword hitbox might
125:39 - already be destroyed before a new one is
125:42 - created if the player hits the attack
125:44 - key again so in that time sword hitbox
125:47 - will be undefined so that's why we need
125:49 - to guard this with an if statement
125:51 - otherwise it's going to fail so here I
125:54 - need to and then only if sorry only if
125:57 - the sword hit hitbox exists then we can
125:59 - call the destroy function offered by
126:01 - Kaboom to destroy game object and we
126:03 - pass the reference to that game object
126:06 - and that's it and one thing we want to
126:09 - do is set the is attacking attribute now
126:13 - to being false since the attack is
126:15 - finished and uh we want to play the idol
126:19 - animation Back by default the idol
126:21 - animation always
126:23 - plays uh all the time when the player
126:26 - isn't doing anything so even after an
126:28 - attack we set it back to Idol only and
126:30 - then when the player decides to move or
126:32 - do something else then we will play
126:34 - other animations so this is our first
126:36 - control Handler uh and let's do our
126:40 - second one our second one is going to be
126:44 - again I'm going to call I'm going to
126:46 - push it to the array in much the same
126:49 - way this time around what I'm going to
126:51 - to do is um do a key on key down instead
126:58 - of Onkey press Onkey
127:02 - down and Y Onkey down and then again
127:06 - pass the key
127:10 - here and now here if the key is either
127:18 - left uh if the key is left so if it's
127:22 - the left key is is down and the player
127:26 - is not attacking this again it makes no
127:29 - sense uh gameplay wise it might be
127:31 - strange a strange gameplay decision
127:34 - design decision but as I said because I
127:36 - do not have the animations for the left
127:38 - and right attack As you move and it just
127:41 - looks weird because the the player is
127:43 - basically standing still and attacking
127:46 - so that's why I made sure that uh you
127:48 - can only attack when you don't press any
127:50 - other Keys except the attack button so
127:52 - if key equal equal left and uh this is
127:56 - attacking what we're going to do is
127:58 - we're going to have another if statement
127:59 - if this. current animation so this again
128:02 - is the animation guarding logic so if
128:04 - the anim the current anim is not the Run
128:08 - animation
128:10 - and we also need to make sure that the
128:14 - player is grounded before we play any
128:16 - Running Animation because uh otherwi
128:18 - running while in air is kind of going to
128:20 - look weird
128:22 - so because of that we need to use the is
128:24 - grounded again is grounded is a method
128:26 - offered by Kaboom for all the game
128:29 - objects that have the body
128:32 - component uh okay so we have that and uh
128:36 - if that's the case we can do this play
128:38 - and then actually play The Run animation
128:40 - so we have all the conditions to play
128:42 - The Run animations but we again this is
128:44 - an if statement within an if statement
128:46 - because we can conceive of a case where
128:49 - we want the player to still move even
128:51 - though we don't want to reset the Run
128:54 - animation because it's already
128:56 - playing so here we go and I'm going to
129:00 - make sure that you need to make sure
129:02 - actually that the flip x value is is
129:04 - false because the way that flip X works
129:06 - is that if you set it to True your
129:09 - player is going to be
129:10 - mirrored all the time unless you
129:13 - actually set it back to false and
129:14 - because the by default it seems here
129:17 - that the the the player is actually
129:19 - facing left by default and not right No
129:21 - actually that's that's contrary it's
129:23 - facing right so this should be true we
129:25 - want to always make sure that the flip x
129:27 - value is true so that the player is
129:30 - flipped when they press the left key and
129:33 - in the other F statement where it's
129:35 - going to be the exact same logic but for
129:37 - the right key we're going to make sure
129:39 - that the flip X is always true always is
129:43 - false set to false so that the player
129:45 - will return back to their original
129:48 - orientation I
129:50 - guess and then finally for moving the
129:52 - character we can just call the move
129:54 - function method again this move method
129:57 - is offered by all backa Boom for all
130:00 - game objects that have the body
130:03 - component and here the move uh method
130:06 - takes two prams the first one is the
130:10 - speed in the x axis and the second one
130:13 - is the speed in the y axis you want to
130:14 - go for because we want to only move left
130:17 - and right we're only going to do a
130:19 - negative speed value and then zero for
130:22 - the y coordinate so here we have the
130:25 - speed here defined here so we can only
130:27 - only need to modify the speed in one
130:29 - place and negative because we want to go
130:32 - left so the value of the the speed
130:35 - should be
130:36 - negative all right we have that and we
130:39 - can return early we don't need to go
130:43 - further down and the rest of the logic
130:46 - is the same thing but for the right uh
130:50 - Direction
130:52 - so here's the same thing you don't
130:53 - actually need the return statement only
130:55 - if you were to want to have uh some
130:57 - extra logic here but I'm going to keep
130:59 - it just for yeah
131:01 - consistency so here it is uh the second
131:04 - one just copy the code it's the same
131:07 - logic just two values you could um maybe
131:10 - have reusable block here um yeah you
131:14 - could have some reusable logic but it
131:15 - didn't didn't feel worth it so now that
131:19 - we have this I'm going to save and then
131:20 - I'm going to have the
131:24 - last uh control Handler so this
131:30 - control Anders and then push this time
131:33 - around is for when the player releases a
131:36 - key so to do that we're going to do on
131:38 - key
131:40 - release and then we don't need to
131:42 - actually check which key is released we
131:44 - want to run this Logic for any keys that
131:46 - is released so if this current animation
131:48 - okay this is going to be uh really
131:50 - tedious to write that's kind of
131:53 - necessary so I'm just going to paste it
131:54 - here and go over it so this is the logic
131:57 - so we want to make sure as long uh when
132:00 - the a key is released any key if the
132:03 - player is not idle uh if the current
132:05 - animation is not idle the current
132:06 - animation is not jump the current
132:08 - animation do not fall and the current
132:09 - animation is not attack if if any of
132:12 - those animation are not currently
132:13 - playing then we go back to the idol
132:18 - animation and I think that's it now
132:21 - let's go back to the
132:24 - um uh yeah let's go back to the main.js
132:28 - file uh actually no to the room one. JS
132:31 - and let's create our player here just so
132:34 - we can see something on the screen so
132:37 - what I'm going to do okay I see why I
132:40 - created the set position let's create
132:42 - our method here to set the position it's
132:44 - actually going to be used so set
132:47 - position X and Y value and then ah put
132:52 - page
132:54 - transition and then here so this
132:58 - position do X we set the x new X
133:01 - position this position doy we set a new
133:06 - position all right uh here we're going
133:09 - to remove the initial position here as
133:12 - well does not need it and here we go all
133:16 - right in room one what we're going to do
133:19 - is right after setting the map colliders
133:22 - I'm going to actually Define the player
133:24 - here and add it to the scene but without
133:27 - specifying a um a position so here I'm
133:31 - just going to call actually you don't
133:33 - need that you just call the make player
133:36 - function from within pass in K like that
133:39 - so when you use the make function you
133:41 - only need to call the add method on top
133:44 - and we actually actually need to add
133:45 - this as part of the map so now that we
133:48 - have a player created let's write the
133:50 - logic for the positions so in much the
133:53 - same way here I'm going to create
133:55 - another const I'm going to call it
133:56 - positions and it's going to be an empty
133:58 - array and then here instead of breaking
134:01 - I'm going to have a continue and I will
134:05 - have a second or first if statement that
134:09 - checks the layer name for position
134:12 - positions and if that's the case then we
134:14 - going to push to the positions
134:19 - array push
134:22 - um yeah going to push the layer dot dot
134:25 - dot we're going to spread the objects
134:27 - here so the spread operator uh look it
134:30 - up it allows us to take an array and
134:33 - then spread it back
134:35 - into another array without like having
134:37 - an area in an array so you take the
134:40 - element of one array and you put that
134:43 - into the second array uh rather than
134:45 - putting the the first array inside of
134:48 - the second so it's it's the basically
134:52 - instead of having this you'll have this
134:54 - and then every element one two so
134:57 - imagine three and then one two three so
135:02 - if you were to not use the spread
135:03 - operator like this three dot this is
135:06 - what you would get but because you use
135:08 - the spread operator it takes the
135:10 - elements of the first array and puts it
135:12 - inside of the second hope this was a
135:14 - clear explanation in case you're not
135:16 - familiar with this uh syntax okay so
135:19 - positions push there objects
135:22 - okay and then we should have all of our
135:26 - objects uh so I'm going to continue here
135:30 - as well so here for now this is not
135:34 - necessary okay so now what I'm going to
135:37 - do
135:38 - is
135:40 - for const position of
135:48 - positions and then here
135:51 - if the
135:53 - position for now let's do it simple if
135:55 - the position is of the player U
135:59 - position. name is the players is how we
136:02 - detect the player pin so this one if you
136:07 - remember uh here we go so here it's
136:10 - named player so by checking for the name
136:12 - so if it's the player name what are
136:14 - we're going to do is we're going to have
136:16 - the set position call to the set
136:18 - position method and we're going to
136:21 - take the data from this positional pin
136:24 - and set it as the position for our
136:28 - player now we also going to set the
136:32 - controls by calling the set controls
136:36 - method and for now that's it so if I
136:38 - look at the result let's see what we
136:41 - get presenter and we have our player and
136:44 - our player can move can it jump it can
136:47 - jump but this time yeah you see the
136:49 - animations aren't resetting properly
136:50 - because we didn't have we didn't have a
136:52 - we didn't add yet the handlers the the
136:55 - um not the handlers the events uh we
136:59 - going to see in a moment what I mean by
137:00 - that so one thing also if I press F1 you
137:03 - can see the headbox how it is positioned
137:06 - Etc and when I use the sword you can see
137:09 - how the
137:11 - hitbox change
137:14 - direction all right now that we have
137:16 - this I'm going to go back to the player
137:18 - set the events so the events are things
137:22 - it's a new a new feature that I've
137:24 - discovered in cunas it's not actually
137:27 - new it was probably there but it's new
137:30 - uh to me so uh okay be before doing that
137:34 - yeah okay so set
137:37 - events this is the method I'm going to
137:39 - call and within this we're going to set
137:42 - a bunch of events uh so onfall is an
137:44 - event offered by Kaboom it checks for
137:47 - when the player Falls after jumping and
137:50 - and this is where we're going to just
137:52 - play the fall animation when that
137:55 - happens so the onfall is something
137:57 - offered by kabo this on fall off though
138:01 - is another event offered by Kaboom but
138:03 - this time around uh those events are all
138:06 - specific to the game object so it's not
138:08 - a Global Effect uh
138:10 - event onfall off the different is that
138:13 - it's for when the player falls off a
138:16 - platform that means there there was no
138:17 - jumping before that
138:21 - here again we need to play the fall
138:22 - animation now we also have this on
138:25 - ground which is another event offered by
138:29 - Kaboom and when the player is in on the
138:32 - ground we want to play the idol
138:36 - animation and then finally when actually
138:39 - it's not finally there's there's a bunch
138:40 - of others but for now uh there is this
138:43 - the onhe head headbut on headbut event
138:49 - which is when the player hits his head
138:52 - on a platform or uh when the player hits
138:56 - um an obstacle with its head so for
138:59 - example when the player jumps and hits
139:02 - the ceiling of a level then we can this
139:06 - event will fire and here we're going to
139:08 - play the file fall
139:11 - animation so now let's just test this
139:14 - out so I'm going to go back to Mains I'm
139:17 - going to actually room one. and here I'm
139:21 - going to set those up so player. set
139:26 - events and now if I go and check the
139:28 - result hit enter if I you see the
139:32 - animation are now perfectly correct and
139:34 - then if I hit so this is a oops we don't
139:40 - don't have the camera system working yet
139:42 - but here is the natural
139:44 - progression we go if you hit headbutt
139:48 - immediately the fall animation will play
139:51 - and that's that we we have a bunch of
139:53 - other controls and that looks good uh
139:56 - now we want to make sure that the player
139:58 - can pass through uh these platforms so
140:02 - we're going to create another method I'm
140:03 - going to call it
140:05 - um what's the name I'm going to use it's
140:07 - going to be enable pass through so maybe
140:11 - where should I put
140:12 - it
140:14 - um okay let's put it right here so
140:18 - enable enable pass
140:21 - through
140:24 - through and here we
140:27 - go and here how to do this feature is
140:31 - there is something in Kaboom a method
140:33 - called the on before physics resolve
140:38 - what it does it gives us the Collision
140:41 - that happens as the first param here and
140:45 - then you can check for that Collision so
140:47 - if this
140:48 - Collision uh is a specific Target so if
140:52 - the Collision
140:54 - is is with pass through which was the
140:58 - tag you remember we had for those
141:00 - specific uh platforms where we want them
141:02 - to pass through uh that we set up in
141:04 - tiled and then add it to when we create
141:06 - the game object in in the set colliders
141:10 - uh method
141:12 - function and then here we make sure that
141:16 - the player is jumping as well and this
141:19 - again is a method offered by Kaboom to
141:21 - know when the player is
141:23 - jumping so and then if those two
141:26 - conditions are met so that the Collision
141:29 - is supposed to be with a pass through is
141:31 - happening with a pass through and the
141:34 - player was jumping we want to prevent
141:35 - the resolution of the Collision that
141:37 - means we don't want the Collision to
141:38 - actually take effect so that's why we
141:41 - call the Collision do prevent
141:47 - resolution okay so once you call that uh
141:50 - I think that's it the the feature is
141:52 - implemented for more details I have a
141:54 - blog post regarding this uh so go to my
141:57 - substack for that so if I go here to
142:00 - room one and call the player do um set
142:06 - pass
142:08 - through through
142:11 - method
142:14 - uh uh enable pass through not set pass
142:16 - through actually enable is a better name
142:19 - but set that would have worked as
142:22 - well so if I do this press enter and
142:25 - then let's try it out even though the
142:28 - camera doesn't work you can see I can
142:29 - pass through the
142:31 - platform and even here as well but uh
142:35 - here I cannot jump enough anyway
142:39 - so so here we go but when you're going
142:41 - to be able to double jump you should be
142:43 - able to pass through that platform as
142:45 - well all right um we have everything we
142:48 - need for our basic player moov there is
142:50 - a bunch of logic when it comes to
142:52 - dealing and taking damage that we're
142:54 - going to write later on now okay let's
142:57 - do the camera system so uh for the
142:59 - camera system what I'm going to do is
143:02 - we're going to have to go back to our
143:04 - room
143:05 - 1js and the same thing with what that we
143:09 - did for the colliders and positions
143:11 - we're also going to need that uh but
143:14 - this time around uh yeah we also going
143:16 - to need to get the um the colliders for
143:21 - the
143:22 - cameras uh the way I did it in
143:25 - my uh yeah that's strange um okay it's
143:30 - going to be a bit different um so let's
143:32 - go to room. utils and write the utility
143:35 - for that because it's going to be used
143:37 - for both the um room one and room two so
143:42 - here I'm going to create export a
143:47 - function this uh always make this
143:50 - mistake function
143:53 - set um set
143:56 - camera
143:58 - controls and then here we're going to
144:00 - pass in first player first Decay the for
144:03 - for accessing all the Kaboom functions
144:06 - the player the map and the actual room
144:09 - data and then
144:11 - here we're going to need first of
144:15 - all actually never mind this is not the
144:19 - this this function is going to to be
144:20 - useful and it's going to be mostly used
144:23 - to control the camera so I'm not going
144:24 - to write the body of it right now what
144:27 - I'm going to do though is right below
144:29 - I'm going to write the function for the
144:32 - camera zones so the camera colliders I
144:35 - just call them camera zones and we need
144:38 - to just have three params which is like
144:41 - we did with the colliders it's it's
144:44 - basically the same thing so we're going
144:45 - to have three param the first one is the
144:47 - kabo context the second one is the map
144:50 - object and the third one is going to be
144:51 - the cameras in much the same way that we
144:53 - did for the colliders so let's assume
144:55 - that we have all those three for this
144:57 - for the time being and then we will um
145:01 - uh write the logic for that in room in
145:03 - the room
145:04 - one. so we have a for Loop and then we
145:08 - have we're going to get the camera of
145:11 - cameras which is our colliders our data
145:14 - for those colliders that we had entitled
145:18 - and then here for the cameras for each
145:19 - of those camera colliders uh data we
145:22 - have entitled we're going to create a
145:23 - camera zone game object that game object
145:26 - is going to of course be added as a
145:27 - child of the map and we're going to have
145:31 - basically the same exact way we did for
145:35 - the um collider so I'm just going to
145:37 - copy and paste the code here and explain
145:39 - over it so an area component which is a
145:42 - rectangle with the width and the height
145:44 - and collision ignore being the collide
145:46 - with the colliders since the camera
145:49 - really don't have inter
145:51 - in collision with themselves we don't
145:53 - need to add a tag for
145:55 - cameras um okay so now the reason I
145:58 - created this and stored it in a camera
146:01 - Zone constant is to have our set our
146:04 - first event listener which is going to
146:06 - be our camera on Collide so when so I'm
146:10 - just going to copy and explain here so
146:12 - on Collide is a method available all
146:14 - game objects that have the area
146:16 - component so here here how it actually
146:19 - works so you have the your first game
146:20 - object you have its meth method the on
146:23 - Collide and you can pass in a tag as the
146:26 - first param which is what tag you want
146:29 - uh what game object with the following
146:30 - tag you want to listen on uh when when
146:33 - when regarding collisions in regards to
146:35 - collisions sorry and the second param is
146:38 - the function that is going to fire when
146:39 - that event happens so here when the
146:42 - player collides with the camera Zone
146:45 - we're going to run this logic this logic
146:47 - is simple we get the current camera
146:49 - position by using the campuse method uh
146:53 - function offered by Kaboom uh which
146:55 - returns in Vector 2 that means we can
146:57 - have access to X and Y properties for
146:59 - the camera position so we make sure that
147:02 - if the uh the X position of the camera
147:06 - is not equal to camera properties zero.
147:11 - value so okay so what this what is this
147:13 - so this is if I go to the
147:16 - export uh okay so the room one. Json
147:20 - maybe room two so let's go to room two
147:22 - because it's smaller and easier to uh
147:25 - detect parse because of its smaller
147:29 - nature so here in not positions but
147:32 - in we have positions okay in cameras you
147:35 - see here the custom property that I
147:38 - created called cause Y is is added to a
147:42 - new properties tab here with the this
147:46 - array and in that array for each new
147:48 - property you add it adds a new object
147:51 - with the name the type and the value
147:53 - since we only have one uh new attributes
147:56 - and I don't really need to check for the
147:58 - name of it I just decided to uh access
148:01 - the first element and access directly
148:03 - the value without having to check for
148:05 - the name in case you want to expand this
148:07 - game further and want to use more proper
148:09 - custom properties make sure to check the
148:10 - name first before accessing the value
148:14 - okay so here I go and then details so we
148:17 - get the value which is going to be the
148:19 - actual new camera position if you
148:20 - remember here uh when I click on the
148:23 - camera Zone uh campas Y is the custom
148:26 - property with a value that value uh is
148:29 - basically the the value we want for the
148:30 - camera and here we're going to use a
148:32 - tween so a tween is a way for gradually
148:35 - changing the value of something uh using
148:38 - a function a mathematical function
148:41 - easing function here we using a linear
148:44 - easing function so the tween in kabon JZ
148:46 - takes a uh 1 two 3 four five pams the
148:50 - first Pam is the uh the original
148:54 - position but actually no not just that
148:56 - the reference to modify the value so the
148:58 - the original value but a reference to uh
149:02 - the game object um or the thing
149:05 - controlling that original value um
149:08 - actually never mind that's not true it's
149:10 - here we do the modification so the first
149:13 - Pam is the initial value the second Pam
149:17 - is the final value you want and the
149:19 - third Pam is on in how much time you
149:22 - want the trans the in how much time you
149:26 - want the transition to happen so here I
149:28 - want to the transition to happen 0.8
149:30 - seconds from this initial value to this
149:33 - final value and the fourth param is the
149:36 - function that will replace the uh the
149:40 - gradually to the new value so here Val
149:44 - is called multiple times as uh following
149:48 - this function's pattern the linear
149:50 - function and for each call it has an
149:53 - intermediate value between this and this
149:55 - that progressively gets closer to the
149:57 - final value and here uh in Kaboom to
150:01 - modify the camera position you can also
150:03 - call the Campa meth function and then
150:06 - pass in as the first param the x
150:09 - coordinate and the y-coordinate since we
150:11 - only want to modify the Y value of our
150:15 - uh camera we will simply put back the
150:19 - same uh x value X position for the
150:23 - camera and just tweak the the just set
150:27 - the new uh y position instead by using
150:30 - this so value here this is an arbitrary
150:34 - name you could have decided to name it
150:35 - however you'd like and then finally k.s.
150:38 - linear are the various easing functions
150:40 - you have access to if you look at the
150:42 - documentation you can have sign sign in
150:45 - sign out Etc linear is just the one I
150:47 - decided to use here uh it's the one
150:50 - looked good to me all right we have
150:53 - this and let's go to room one and here
150:57 - again we're going to do the exact same
150:59 - logic we did so const cameras and then
151:02 - empty
151:03 - array and then here we can either do it
151:08 - like that if layer. name equal equal
151:14 - cameras what you're going to do is or
151:16 - maybe you should do this on top it
151:19 - doesn't really matter that much in the
151:22 - end so if the layer. name is the cameras
151:27 - what are we going to do is we're going
151:28 - to push to the cameras
151:31 - array and spread from within layer.
151:34 - objects which is again going to give us
151:36 - the collider the the collider data for
151:38 - the
151:39 - cameras and then here uh now for the
151:43 - actual
151:45 - usage where did I use this I'm just
151:47 - going to make a call to set camera
151:51 - zones uh maybe right after this doesn't
151:54 - doesn't really matter so I'm going to do
151:58 - this here
151:59 - actually it probably is better to call
152:03 - this here so
152:06 - set camera zones from here K dot
152:14 - map
152:15 - do uh cameras here we go
152:21 - okay let's look at the results press
152:23 - enter now if I do this the camera slides
152:27 - downward if I drop down again it follows
152:31 - everywhere maybe not the left hand side
152:33 - because we only control the Y position
152:35 - we need to actually write the logic for
152:37 - the exposition so the exposition we just
152:39 - want the camera to follow the player and
152:42 - that's the role of the first utility
152:45 - function that I was about to rout uh
152:47 - right is called set camera controls
152:50 - uh so here what we do the reason we need
152:52 - also the room data because there is
152:54 - specific data that is allowed going to
152:57 - allow us to bound the camera to certain
152:59 - limits so here in room. utils let me
153:02 - just check it out okay so how we're
153:06 - going to do this is we're going to use a
153:07 - onupdate
153:09 - method Kaboom method so on update is
153:12 - called every 60 frames it's where you
153:14 - can write more granular stuff so here if
153:17 - the state. current
153:20 - and then
153:22 - player in boss
153:26 - fight then we return early why why we do
153:29 - this because when we're going to have
153:31 - the actual boss fight we want to um make
153:36 - sure that uh the camera isn't controlled
153:39 - is fixed basically uh to only the room
153:42 - the boss battle room here I'm just going
153:44 - to import the state from the global
153:47 - manager
153:51 - so player in boss fight I think that was
153:53 - this date uh let me let me
153:57 - look is boss defeated player in boss
154:00 - fight yep and here player is in boss
154:03 - fight I made a typo error later on so
154:06 - fix that in State Global manager Global
154:08 - State
154:09 - manager so
154:11 - here if state. current if players in
154:14 - boss fight we just won't run the the
154:18 - logic uh the what comes next because we
154:21 - don't want actually the camera to follow
154:22 - the player and then the next stuff that
154:25 - comes right after I'm going to copy and
154:27 - paste it is if the map position X is um
154:31 - plus 160 is inferior is superior to the
154:34 - player position then I'm going to clamp
154:36 - the camera position to be stuck at this
154:38 - value this is so that when the player
154:41 - cannot go too much to the left uh the
154:44 - camera cannot go too much to the left to
154:46 - the point that we can see outside of the
154:49 - the bomb the bounds of the
154:50 - map and then finally the
154:54 - last um yeah the last if statement here
154:57 - we need is this so if the player
154:59 - position. X is superior to the map
155:01 - position. X plus the room data. width
155:04 - this is the actual width of the the
155:06 - whole map multiply by the room data.
155:09 - tile width which is supposed to be like
155:10 - 32 or 16 minus a certain value this is
155:13 - what I looked good then we're going to
155:15 - prevent we're going to clamp the the
155:17 - camera but to the uh to the left uh to
155:20 - the right so it won't go past a certain
155:23 - point to the right and that way we will
155:26 - never allow the player to see outside
155:28 - the bounds of the map and otherwise if
155:31 - those conditions are not met so we just
155:34 - make sure that the the camera just
155:36 - follows the player uh from the x axis
155:40 - but the Y AIS is remains intact so
155:43 - that's why I only modify the x x
155:47 - coordinate and not the Y so the Y for
155:49 - the Y we just take the current camera
155:52 - position all right let's check the
155:55 - result for
155:57 - that so here we go if I move to uh maybe
156:01 - I should drop down and then okay I
156:04 - forgot to actually call the function so
156:07 - set camera controls needs to be called
156:10 - and where we're going to call it is in
156:12 - room. one. JS maybe right after here
156:16 - okay but this is an issue because the
156:17 - player isn't yet added to the Z team so
156:21 - we need to First wait for the player to
156:22 - be declared and then do this so now if I
156:26 - look at the result press enter set
156:29 - camera is not defined I forgot to import
156:31 - it
156:32 - here
156:34 - set camera
156:36 - controls now everything should work so
156:39 - let's look at the result press enter and
156:43 - now the camera follows us that's nice so
156:47 - if I drop down it also follows
156:50 - follows us on the Y
156:52 - AIS so here is we cannot go past this
156:55 - point we will never see the bounds the
156:57 - outer bounds of the C of the the map and
157:01 - then even if I go here everything works
157:04 - all right so yep uh we have the camera
157:08 - now done and H this is not done I fall
157:13 - so that's something we need to fix uh
157:17 - why let me check let me debug why why is
157:20 - this an
157:21 - issue if I go here we have a
157:25 - collider we have a collider but not no
157:28 - body component so we need to go back to
157:31 - vs
157:32 - code where we defined the in room. UTS
157:37 - the set map
157:38 - colliders if it's yep here we forgot to
157:42 - add for the
157:44 - polygon colliders the body component
157:48 - with is stat property because at the end
157:50 - of the day it's a wall type it's an
157:53 - obstacle so now if I look back at the
157:56 - result press
157:58 - enter and it should hopefully work so
158:02 - here I drop down and yep it works all
158:06 - right we have the camera system up and
158:08 - running that's great we can pass through
158:10 - those platforms as well let me see if I
158:13 - can go back here so now what is is left
158:16 - is to do the uh start implementing the
158:19 - enemies after the enemies the boss fight
158:21 - and after the boss fight the linking
158:23 - with the other scene so for now if I go
158:25 - here there's nothing that happens and I
158:28 - I'm out of bounce so now it's time to
158:31 - work on the drones so it's an enemy type
158:34 - that will follow the player and explode
158:37 - when entering in contact with the player
158:39 - so in the entities folder I'm going to
158:42 - create a new folder I'm going to call it
158:44 - enemy drone. JS here we're going to
158:47 - follow the exact same pattern I did for
158:48 - the player which is create a function
158:50 - that is going to act as a Constructor
158:53 - I'm going to call it make
158:56 - drone here I'm going to you as the first
159:00 - param set the K the context and then as
159:03 - a second param I'm going to have an
159:05 - initial position because here we're just
159:07 - going to create the Drone and set the
159:09 - position
159:10 - immediately um then here we're going to
159:13 - return a make uh call which is going to
159:16 - create the the game object but not but
159:19 - not add it to the scene and then here
159:22 - we're going to have a bunch of
159:23 - components so the the positional
159:25 - component is important here with initial
159:27 - pause uh we're going to need to have a
159:29 - Sprite
159:30 - component the Sprite component is going
159:33 - to be the Drone Sprite with the anim
159:38 - flying this was defined in the Kaboom
159:40 - loader function by the way uh kaboon
159:43 - loader file sorry and then next we're
159:47 - going to need to to have to set the hbox
159:50 - so the area component is going to be
159:53 - used here we're going to have a
159:56 - shape with a new k. rectangle and then
160:00 - k. Vector 2 we don't need an offset
160:02 - really 12 by 12 would be a good H
160:06 - box the anchor is going to be centered
160:10 - this time around as I did with I think
160:12 - we did the same thing for the player I
160:14 - don't
160:16 - remember and then here for the body here
160:20 - things are going to be different we're
160:21 - going to set the gravity scale so
160:23 - gravity scale is another property you
160:25 - can set uh within the body component and
160:29 - I'm going to set it to zero so basically
160:31 - we want our drone to have basically not
160:34 - be affected by gravity at all so it's
160:36 - going to be floating
160:38 - around I'm also going to use a a new
160:42 - component that I haven't explained yet
160:43 - called the offscreen component and set
160:46 - the distance to 400 so this what it does
160:50 - is that
160:51 - when uh the charact uh the sorry when
160:56 - the Drone is going to be off screen so
160:58 - that means as the camera is crawling and
161:00 - the player is moving around uh let's say
161:02 - we have a drone that was following the
161:04 - player and then the player was able
161:07 - to get away basically and what we want
161:11 - to do is that if the distance between
161:14 - the uh the camera the screen and the
161:17 - player uh the Drone is
161:20 - at at four 400 uh units I guess pixels
161:24 - whatever then we're going to respawn
161:28 - we're going to not respawn but
161:29 - reposition the Drone to its original
161:33 - position so here we just using the
161:35 - offscreen component then later on I
161:37 - think we're going to use some of the
161:40 - meth event listeners that comes with it
161:42 - so when you use the component you have
161:44 - access to a bunch of methods that you
161:46 - can use later on so not right now and
161:51 - then here we're going to play around
161:53 - with a state machine which is basically
161:55 - what we're going to use to uh code the
161:57 - AI so I'm going to explain what a state
161:59 - machine is in an instant but for now let
162:03 - me just teach you how to use the state
162:05 - component so the state component starts
162:07 - with a first state States here are just
162:10 - arbitrary names that you decide for
162:12 - yourself I decided to create one two
162:15 - three four five states here and I'm
162:18 - going to paste them has to not waste too
162:20 - much
162:21 - time so here are all the states I have
162:24 - decided to create and the you need to
162:28 - specify a default State and that default
162:30 - state must be one of the states you have
162:32 - decided to uh create here and the
162:34 - default state I'm going to pick is going
162:36 - to be the patrol right so what what is
162:40 - what is a state machine so a state
162:41 - machine is a way for you to code an AI
162:45 - uh so if I open up the excal draw and
162:48 - try to do a
162:50 - schematic so we have imagine you have a
162:53 - bunch of
162:55 - nodes and then for each of those nodes
162:58 - you have there are states Associated so
163:02 - Patrol Patrol right okay that's too big
163:07 - uh maybe
163:10 - um okay zooming
163:13 - out so I'm going to just here so we have
163:17 - our first state patrol right
163:20 - we have I'm going to just copy that
163:24 - around Patrol uh Patrol
163:28 - Patrol left yeah that's kind of strange
163:31 - why it's behaving this way
163:35 - Patrol okay that's that's strange okay
163:38 - my point here is that by having those
163:41 - names you're able to Define behaviors
163:44 - okay so
163:45 - here let's try to explain without the
163:48 - diagram so those are names that are
163:50 - arbitrary and for each of those names
163:53 - we're going to define a couple of events
163:55 - that happens when the entity the game
163:58 - object will enter or be in those States
164:02 - so here I have decided to name Patrol
164:05 - right Patrol left alert attack and
164:08 - Retreat and for each of those state that
164:10 - I've decided to name I'm going to write
164:13 - logic that is specific to them so when
164:16 - the the Drone enters a specific State a
164:19 - specific logic is going to run while
164:22 - they enter in the state while they're in
164:24 - the state and when they get out of the
164:26 - state depending on the state we want uh
164:30 - depending on the state we're going to do
164:31 - different things so let's just add the
164:35 - health component I'm not going to re
164:37 - explain here but basically setting the
164:39 - health one point one Health Point for
164:42 - actually we set did we set the health
164:44 - for the player um did I do that yeah we
164:47 - did okay
164:49 - so just I'm going to just set the health
164:52 - to be one and then add a tag to be of
164:55 - drone and then here is going to do the
164:58 - AI coding the state Etc so I'm going to
165:01 - you're going to understand this more in
165:02 - a in a moment okay so here are a few
165:05 - properties I want to Define so I'm I'm
165:08 - going to have a speed of 100 a Pursuit
165:11 - speed of 150 so this speed is going to
165:15 - be the one used when the player is is uh
165:19 - when the Drone is following the player
165:20 - the range is going to be 100 that's the
165:23 - range in which play the Drone is going
165:26 - to start is patrolling and is going to
165:29 - start following the player if they
165:30 - detect the player and then here I'm
165:32 - going to create a method called set
165:34 - behavior and it's where we're going to
165:36 - define the logic related to uh the state
165:40 - machine the state uh yeah the state
165:43 - machine so the first thing I want to do
165:45 - is I want to get the player because I'm
165:48 - going to have to to do a bunch of things
165:50 - compare the distance between the Drone
165:52 - and the player and one way to do that is
165:54 - just to have a constant called player
165:56 - and then use the get function to get the
165:58 - player by uh using the tag and as I
166:02 - explained earlier since the player is
166:04 - going to be added or is already added as
166:06 - a child of the map object we need to use
166:10 - recursive and true
166:13 - property and so for it to work and then
166:16 - here I'm going to set the we only want
166:18 - the first first element there is only
166:19 - one player by default get always gives
166:22 - you back an array okay this is where
166:25 - things get interesting since we used the
166:27 - state component we have access to a
166:30 - bunch of methods called the on state
166:33 - enter method it's an event uh listener
166:37 - that you pass in as the first par the
166:39 - name of the state you want to Define an
166:41 - event for here Patrol right and then the
166:44 - second param is going to be the logic
166:46 - that is going to run when the drone will
166:49 - enter this this state so here what I
166:53 - want to do I'm going to use an ASN
166:54 - weight here because what I want to do is
166:57 - I want to
166:59 - await and then call the weight function
167:03 - in kaboo so here what what it does the
167:06 - weight function basically Will Wait 3
167:09 - seconds before uh running before running
167:13 - what comes next that's that's due to the
167:14 - await so await you have to wait for it
167:18 - before you can continue
167:21 - on uh I'm I'm not going to dive deeper
167:24 - into the async weight uh I have done so
167:26 - in previous tutorial so maybe reference
167:28 - that I might write a post on this but
167:30 - the reason we're using a waight here is
167:32 - specifically so that we wait those 3
167:34 - seconds before running any other logic
167:36 - that comes after here within that
167:40 - function then we're going to have a
167:43 - check so if this do state is how you
167:46 - access the current
167:47 - state if if that that state is Patrol
167:51 - right what I'm going to do I'm going to
167:54 - call the enter State method again
167:56 - provided back aoom if you use the state
167:58 - component and I want to enter enter the
168:01 - patrol left
168:03 - State now this might sound strange
168:06 - you're already in the patrol right State
168:09 - why would you check that well actually
168:10 - you don't know because what comes after
168:12 - is another event
168:14 - listener and this one is called on state
168:16 - update and it runs every frame uh every
168:20 - 60 frames every frame 60 frames per
168:23 - second
168:24 - yeah every yeah I think every frame all
168:27 - right so here we have the onate update
168:29 - uh Patrol right so what is this it
168:32 - allows us to create an event listener on
168:35 - a specific State while that will fire
168:38 - the second param which is a function
168:40 - that is going to run all the time during
168:43 - the the time that the Drone is within
168:46 - that state so here while we are so
168:50 - imagine this is while we are on in the
168:53 - patrol right state run this logic and
168:56 - run it will run it every frame so here
169:00 - what we're going to do is to have an if
169:04 - statement that will check this position
169:07 - distance so this is a method provided by
169:11 - Kaboom for Vector 2 components it
169:15 - calculates allows us to calculate the
169:17 - distance between one positional one
169:19 - vector
169:19 - to with another so here player. is the
169:23 - position of the player and is accessible
169:26 - because we imported the player here and
169:29 - then if that distance is inferior to
169:31 - this do
169:33 - range that means we are within the range
169:36 - of the Drone and this time the the we
169:39 - want the the Drone to enter into the
169:42 - Alert state Alert
169:45 - state and then we return early
169:51 - otherwise we want the this. flip X to be
169:55 - false that means we want the make sure
169:58 - that the patrol the Drone is is facing
170:00 - right and then we want to make the Drone
170:03 - move at a normal speed so now I hope
170:07 - this makes a little bit more clear what
170:09 - we why we do the if statement here
170:12 - because when we enter the state this is
170:14 - this runs
170:16 - once and while we wait three seconds
170:18 - seconds here this is still this is
170:20 - running multiple times because it runs
170:22 - every frame so the the situation can
170:26 - change the state can change within this
170:29 - before we arrive to this line of code so
170:32 - I hope you understand
170:34 - that so just to
170:37 - repeat here it runs once when the Drone
170:41 - enters the state because it's the
170:42 - default State this is also going to run
170:45 - once without having to call an enter
170:47 - state by default and then here it's
170:50 - going to wait 3 seconds before moving on
170:53 - to this line however while we do that
170:57 - this state update is running multi every
171:00 - frame so in that time during it runs
171:04 - every frame the Drone is moving as long
171:07 - as the player is not within the range as
171:11 - soon as the player is within the range
171:13 - we enter a new state we enter the Alert
171:15 - state that means by the time that after
171:17 - the 3 seconds elapse we arrive here this
171:21 - state could potentially no longer be uh
171:25 - Patrol right now we're going to do the
171:27 - same thing but for patrol left so I'm
171:30 - just going to copy and paste and
171:32 - and do a mention a few things so here we
171:37 - have Patrol left same logic but instead
171:41 - of Patrol left here the right it's left
171:43 - and here it's left and the right and
171:46 - then here the the only difference here
171:49 - is that we want to flip because by
171:51 - default the Sprite for the Drone is
171:53 - facing right so we want to flip it to
171:55 - for it to face left and we move to the
171:58 - left by adding a negative sign to the
172:00 - speed so now it's time to define the
172:03 - logic for the Alert state so on state
172:07 - when we enter this Alert state we want
172:09 - to run the following
172:12 - logic we want to wait one second before
172:17 - initiating a Pursuit of the
172:20 - player once we have
172:23 - waited we want to check if the distance
172:27 - between the Drone and the player is
172:31 - still inferior to the
172:33 - range if that's the
172:37 - case we
172:40 - can enter the we're going to enter the
172:43 - attack state so attack is basically
172:46 - following the player you you could have
172:47 - named it suit
172:49 - instead so attack
172:52 - State and then we return early
172:56 - otherwise we're going to enter the
173:01 - patrol right again and reinitiate the
173:05 - loop of patrolling normally left right
173:07 - left right left
173:08 - right so just to diagram this imagine
173:12 - you have patol right
173:14 - here hope this works
173:17 - now we have
173:19 - have
173:21 - Patrol
173:23 - left what's the isue
173:27 - okay okay for some reason okay now it
173:30 - works so we have Patrol right Patrol
173:34 - left and then we have
173:36 - alert so here's the Alert
173:41 - state
173:46 - alert and then we have
173:48 - have the attack
173:51 - state so maybe better I put it
173:57 - here
173:59 - attack oops all right so let's diagram
174:04 - this
174:06 - out so initially we have the patrolling
174:09 - so patrolling is basically going from
174:13 - Patrol right to patrol left and from
174:15 - Patrol left to patrol right however
174:19 - sometimes if the player is too
174:21 - close we go into the Alert state so
174:25 - while patrolling right or patrolling
174:27 - left if the distance of the player is
174:31 - the the distance is the distance if is
174:34 - if the Drone is close enough to the
174:38 - player then the the Drone will enter the
174:41 - Alert state and then after one second if
174:45 - it's still the case the Drone will
174:47 - attack so hope that that illustrates the
174:52 - situation so we have that and then for
174:57 - the attack State we're not going to need
175:00 - to Define an on state enter but we only
175:04 - need to define the on state update for
175:06 - it because we just want the action to
175:08 - immediately go uh the movement the the
175:11 - following of the player so here if the
175:16 - player this position distance and then
175:20 - player position if that is superior to
175:23 - the range that means as soon as the
175:27 - player is able to get away is getting
175:31 - far enough away from the Drone we will
175:33 - enter back to the Alert state and then
175:36 - from the Alert
175:38 - state the after one second if it's still
175:42 - the case where the player is far enough
175:44 - it's going to go back to the patrol
175:46 - right State and then return early
175:51 - here now on the other hand if this.
175:57 - enter so if it's not the
176:01 - case uh wait a minute
176:04 - uh no never mind so we return early yes
176:08 - but now it's time to follow the player
176:10 - to attack him so this flip X is going to
176:14 - depend on the where the player is so we
176:17 - can just have this a Boolean expression
176:20 - where we check whenever or not the
176:21 - player position is inferior to the the
176:24 - position of the Drone if that's the case
176:26 - then it's going to to be true and if
176:28 - it's true that means the the player is
176:30 - to the left so that means the Drone
176:32 - should also be facing
176:34 - left same logic for the right so if it's
176:38 - false that means the player is to the
176:41 - right of the Drone and that means the
176:43 - Drone should be facing right and then
176:45 - here I'm going to use the move to method
176:48 - offered by Kaboom on body on objects
176:51 - that have the body
176:52 - component and you can specify
176:55 - destination so here I'm going to specify
176:57 - Vector 2 I want the player
177:00 - positionx but for the player positiony
177:04 - it's going to be+ 12 just to have a
177:06 - little bit of a gap and
177:09 - then I'm just I'm going to explain
177:11 - everything let me just finish typing and
177:13 - I'll explain things so Pursuit speed
177:16 - okay what happens here so move to is the
177:18 - function from Kaboom it takes two pams
177:20 - the first param is the destination the
177:22 - second param is at what speed you want
177:24 - the Drone to move to towards here uh
177:28 - instead of just taking the exact same
177:31 - position having a bit of an offset make
177:33 - sure that the the the the player the
177:38 - Drone will actually um how do I say will
177:43 - uh we'll try to collide into the to go
177:47 - outside of the player so um it's a bit
177:50 - hard to explain let me make a
177:53 - drawing so by having the target here so
177:56 - imagine this is a
177:59 - Target and this is the
178:05 - player by having the
178:08 - drone target this we we we are making
178:12 - sure that basically if the Drone arrives
178:14 - to the player it's going to collide with
178:16 - the player however however if we were to
178:19 - just have the exact same position here
178:22 - so depending on the situation the Drone
178:25 - could stop just right here and remain
178:28 - here so the Collision would uh would
178:31 - never end that that would be the thing
178:34 - because you have un Collide and then the
178:36 - Collision would never end well what
178:38 - actually never mind it's not the
178:40 - Collision would never end basically um I
178:43 - think that's this the reason I did it
178:45 - initially but thinking about it again
178:48 - uh maybe it doesn't make any sense so so
178:51 - you know what instead of trying to to
178:53 - justify it let's just remove it for now
178:55 - and then we'll see we'll re readit back
178:58 - when we see if uh if it causes any
179:02 - issues all right so we have this and
179:05 - then we have the attack State everything
179:09 - and then that's it that's basically
179:11 - that's the the AI logic now we also need
179:14 - to set the events for it so I'm going to
179:17 - create another method called set events
179:19 - by the way set events Etc and set
179:20 - Behavior are just methods that I created
179:23 - uh in which we use a bunch of methods
179:25 - offered by kabo so for set events I'm
179:28 - also going to have a reference to the
179:31 - player so we're going to have the exact
179:34 - same logic recursive true remember that
179:37 - because the player is a child game
179:41 - object of the
179:44 - map and then here we're going to have
179:47 - the this. on Collide which is an event
179:50 - listener provided by
179:52 - Kaboom when we collide with a player we
179:55 - want a few things so whoops not that
180:01 - if uh if the
180:04 - player is
180:06 - attacking uh that mean we want to return
180:09 - early we don't want to destroy the
180:10 - player that means it we want this un
180:12 - vulnerability to the
180:15 - player if however
180:18 - that's not the case then we first hurt
180:21 - ourselves the Drone because the Drone
180:23 - self-destructs and it has only one life
180:25 - so using the heart method which is
180:29 - provided by Kaboom if you use the health
180:31 - component and then here we're going to
180:33 - have a new feature in Kaboom called um
180:37 - well actually we can never mind it's not
180:39 - a new feature here for the player we can
180:41 - also call the heart function and reduce
180:43 - the Life by One why we do this uh how we
180:47 - can do this because remember remember
180:48 - the player also uses the health
180:49 - component that means it comes with
180:51 - methods to manage health so here by
180:54 - calling hurt it's a nice and easy way
180:55 - for you to deduct uh life uh from the
181:01 - player now here on anim and again
181:05 - another event listener provided by
181:07 - Kaboom we want specifically to check if
181:10 - the anim that ended was the explosion
181:14 - the explode anim again these animations
181:17 - are all imported at the beginning of the
181:19 - project in the Kaboom loader file if
181:22 - it's the case we just want to destroy
181:24 - the the
181:26 - Drone now here this.on explode so this
181:31 - is an a custom event and it's a feature
181:34 - in Kaboom that I discovered recently and
181:36 - makes your code very how do I say more
181:39 - clean so you can Define custom events by
181:42 - using this on function I have written a
181:44 - blog post about it again if you're
181:46 - interested I will put Link in the
181:48 - description hopefully if I don't forget
181:51 - so yeah and uh here so you the way you
181:54 - define custom events is you use the on
181:56 - method here and then you decide on a
181:58 - name and then the second param is what
182:00 - what is going to run when this event is
182:02 - triggered you can later on you use the
182:04 - trigger method to trigger a specific
182:06 - event I'm going to show it to you here
182:10 - I'm going to play a sound so you play a
182:13 - sound by using the k k. playay me
182:17 - function and passing in the name of the
182:19 - sound so here boom uh where does this
182:22 - come from it comes from the K Kaboom
182:25 - loader we imported those sounds
182:27 - initially here so here here is all the
182:30 - sound
182:33 - Imports all
182:36 - right then what we want to do is not
182:39 - only play the sounds when we have we
182:41 - trigger this explode event we want to
182:43 - also have a collision ignore we want to
182:46 - avoid the the Drone from colliding
182:48 - multiple times with the player by just
182:50 - like removing any uh making sure that
182:52 - any collisions with the player is
182:54 - avoided is negated or ignored when the
182:59 - Drone is exploded because we have
183:00 - already deducted life points one life
183:03 - from One Life Point from the player so
183:06 - we don't want to have a situation where
183:07 - we do this multiple times because the
183:09 - the Drone is is still colliding with the
183:13 - player while it
183:16 - explodes we also want to use the unus
183:19 - method which allows you to unuse a
183:21 - component uh that you added to a game
183:24 - object initially when you created that
183:26 - so here you can just use a a a string
183:29 - and refer to the name of the component
183:32 - so I want to unuse the body component
183:35 - and finally I want to play the explode
183:38 - animation so here be careful and to not
183:41 - mistake this and this this is for
183:43 - playing sound and is uh a method from
183:46 - Kaboom and this is a method offered by
183:49 - Kaboom but from the game object so this
183:53 - is for playing animation while this is
183:55 - for audio now here we're going to have
183:59 - another on
184:01 - Collide here we're going to have another
184:03 - on cide and then yeah so we have a
184:08 - sword
184:11 - hitbox so this is the logic we want to
184:13 - run when the player hits the with the
184:17 - sword the Drone and here we're going to
184:21 - do only hurt the Drone itself so by
184:25 - having the hurt one here it's going to
184:27 - reduce One Life Point basically similar
184:29 - to this but we don't have to worry about
184:31 - the player
184:33 - logic and then here
184:36 - is when we Define the so here it's not a
184:41 - custom event this the hurt event is a
184:43 - specific already existing event offered
184:46 - by kaboom what it
184:48 - does is that it offers um allows you to
184:52 - run something when you use the her
184:55 - function so when I say hurt when I call
184:58 - the hurt function it's going to trigger
185:00 - the hurt uh event also offered by kabo
185:04 - so here what I want to do is that when
185:07 - we reduce the life point of the Drone I
185:10 - want to check if this. HP HP gives you
185:12 - the current HP of the game object that
185:16 - uses the the health component if it's
185:19 - equal equal to
185:22 - zero so if it's equal to zero I want to
185:27 - trigger the explode custom EV event that
185:32 - I just created earlier on which is going
185:34 - to take care of exploding playing the
185:36 - sound and making the the Drone actually
185:39 - explode with the animation
185:42 - Etc and then that's uh that's it uh one
185:46 - thing left is this on exit
185:49 - screen on exit screen which is offered
185:54 - by
185:55 - the um the on offscreen component allows
185:59 - us to have this method available so when
186:03 - the the Drone is no longer visible on
186:06 - screen if this.
186:09 - pause. initial pause is superior to 400
186:14 - then
186:15 - this uh I'm going to explain everything
186:18 - this do pause is equal to
186:24 - initial
186:26 - pause so here what it does
186:30 - um did I have the initial pause right
186:33 - Define oh I made a mistake at typo here
186:36 - initial POS pause
186:39 - position so what does this
186:42 - do well here is that uh when the off
186:47 - this will run when the distance uh the
186:50 - player is off screen with a distance of
186:52 - 400 and then here actually I don't think
186:56 - you need to have this you can just set
187:01 - the position to being the initial
187:02 - position basically respawning the Drone
187:06 - where it originally were
187:08 - was and that's it that's the whole Logic
187:12 - for the Drone so let's actually use it
187:16 - now uh let's place the so here I'm going
187:19 - to go in room one.
187:24 - J and then room one.
187:28 - yes and then here yeah so for room one.
187:37 - yes for the positions layer so here so
187:42 - I'm going to have a continue here now if
187:46 - the position
187:49 - type was drone remember for classes
187:53 - entitled you can access them access the
187:55 - the name with the type instead which is
187:59 - kind of strange but it stopped I think
188:01 - class is probably a reserved keyword
188:05 - anyway so here position. type equal
188:08 - equal
188:09 - drone we're going to create the Drone
188:13 - game object and but place it as a child
188:17 - here I'm keeping a reference to it
188:18 - because we're going to do some going to
188:20 - call the two methods we created so here
188:23 - map add and then here make
188:27 - drone and then here pass K and then
188:31 - position and then here we need to pass a
188:33 - vector two with the position
188:37 - dox and then
188:40 - position position y
188:48 - and then
188:49 - drone. set be
188:53 - Behavior which is the method we defined
188:57 - and then draw drone. set
189:02 - events all right now that we have
189:06 - this k
189:08 - 2 I think we the Drone should appear in
189:11 - our
189:12 - game so I'm going to
189:15 - refresh hit enter and and then we have a
189:18 - a l drone so let's see if we
189:22 - can yeah you see that's the issue that
189:26 - is that the the Drone remains kind of
189:29 - stuck above the player but not exactly
189:32 - colliding fully with the player that's
189:35 - why I added a initially here instead of
189:41 - following exactly I added an offset of
189:44 - 12 and now if we look back
189:48 - if I let the the Drone come to
189:52 - me it explodes you see so yep that's a a
189:56 - quirk of the move two method in Kaboom I
189:59 - think and then we have another now let's
190:01 - see if I can attack this
190:04 - one let's see if we can attack okay it's
190:07 - a yep I I was able to attack so that's
190:10 - pretty nice uh so not now what's left is
190:12 - the boss and after the boss I think we
190:15 - going to uh display the C cartridges
190:18 - with which are health pack and then we
190:19 - link the two scenes and then the game is
190:21 - mostly done I think uh we probably have
190:24 - to just add a an intro and Etc by the
190:28 - way if you cannot hear the sounds of the
190:30 - Drone exploding that's on me that's my
190:32 - setup sorry um maybe it's too late for
190:36 - me to verify if it actually recorded it
190:38 - properly but yeah just for your
190:40 - information I on my end I can hear the
190:42 - sounds of the explosions when playing
190:45 - the game so the first thing we're going
190:46 - to implement is the boss
190:48 - barrier so for the boss barrier we're
190:51 - going to go to the room one because it's
190:54 - something that is very like exclusive to
190:57 - this room where the actual boss battle
190:59 - is uh now I think it was in the room
191:03 - etails instead and here when I left the
191:06 - tutu so for the map colliders so if we
191:09 - have the boss barrier map collider what
191:11 - we're going to do is to have the
191:14 - following
191:15 - code so here
191:21 - here so I'm I'm first going to create a
191:25 - constant where I will hold a reference
191:27 - to the boss
191:29 - barrier so first we create a the game
191:32 - object uh that of course is a child of
191:35 - the
191:36 - map now here it's not that interesting
191:40 - but okay let's yeah I'm just going to
191:43 - copy and paste most of the concepts we
191:46 - have already seene so here are the
191:49 - components we're going to use for this
191:51 - object so a rectangle with a width and
191:54 - height the reason I'm using here the W
191:56 - component instead of doing this inside
191:58 - of the the area is because at one point
192:00 - we're actually going to see the
192:02 - rectangle and we're going to set this
192:04 - color for the rectangle for the gate and
192:06 - then the collider X and Y and then
192:08 - ignore collisions with other colliders
192:10 - and set initially the opacity to zero
192:13 - and finally the boss barrier tag now
192:15 - we're going to also have an object where
192:17 - we're going to have a a few methods so
192:20 - the two methods we're going to have is
192:22 - the activate
192:24 - method so this is a method uh which
192:27 - takes care of by using twins it's going
192:30 - to make the uh gate the the boss barrier
192:34 - sorry from invisible to visible uh so
192:38 - here we're going to first set the
192:41 - opacity uh from 0 to 0.3 in 1 second
192:47 - using uh the linear here I have already
192:50 - explained how to use twins here
192:52 - previously uh now here the
192:55 - twi is going to be the camera so as we
192:59 - are changing the opacity of the gate we
193:02 - we're also moving the camera so that
193:05 - we're going to make it we're going to
193:07 - make the the the boss battle arena take
193:11 - center stage and this is the reason I'm
193:14 - not using any await here because we're
193:16 - doing this at the same time so while so
193:20 - when you run this because tween is a
193:21 - synchronous it it will run on its own
193:25 - and then the the code execution will
193:27 - continue to the next one next one even
193:29 - though this is not done yet so that's
193:33 - that and then after this activate method
193:36 - we're going to have a deactivate method
193:37 - as well and for this one I'm also going
193:41 - to paste the code here I don't think
193:43 - there's much need to manually type it so
193:47 - here we have an async deactivate method
193:49 - that takes the current exposition of the
193:52 - player it will make the uh gate uh the
193:57 - boss barrier
193:59 - disappear so here and then it will move
194:02 - back the camera to the player's
194:05 - position and then it will destroy the
194:07 - gate after uh it is uh after it has
194:11 - fully disappeared so that the player can
194:13 - move out of the
194:14 - arena and then here are some other logic
194:17 - we're going to need uh so here this is
194:20 - within the boss barrier but now we have
194:23 - also content outside of it uh I mean not
194:27 - content I mean uh logic to write outside
194:30 - of it on in an un Collide event lessener
194:33 - so when it collides with the player
194:35 - we're going to have it in a sync and
194:37 - here one thing one thing in Kaboom JS is
194:40 - that when you use an on collide with the
194:42 - tag here uh on Collide will pass to the
194:45 - function you use as the second peram the
194:48 - game object that is collided with uh
194:50 - that the tag that the the game object is
194:53 - colliding with so here it's the player
194:56 - tag so it's going to give you the player
194:57 - game object so that means we don't have
194:59 - to use k. getet here so that's pretty
195:04 - handy so here I'm going to first have a
195:07 - current state constant just just as a
195:11 - short hand for
195:14 - this actually it's barely less
195:17 - characters barely
195:19 - less anyway I'm just going to keep it
195:22 - and then here we're going to have a
195:24 - first an if statement and then if the
195:26 - current
195:27 - state is boss defeated
195:31 - true whoops if that's the case then I'm
195:36 - going to set a new state so St state.
195:40 - set and what I'm going to set is here
195:42 - I'm going to this is where it's handy to
195:44 - have the state props enum it makes
195:46 - things less error prone I can
195:49 - immediately just select the as boss
195:51 - defeated and then set that to being
195:55 - true or actually it's not uh it's not
195:57 - that we want to set if
196:01 - the um if the player is in a boss fight
196:04 - so if the player isn't if player in boss
196:07 - fight I should have named this is M but
196:10 - anyway just do not generate any
196:12 - confusion I'm going to do this like that
196:14 - so now I'm going to set that to to be
196:16 - being true uh actually false because the
196:21 - the boss has been defeated
196:22 - sorry and then we're going to make a
196:25 - call to the deactivate method and pass
196:28 - in the player position
196:33 - X now after doing all of that we return
196:37 - so when the boss is
196:39 - defeated we set back the players in boss
196:42 - fight is a player in boss fight Boolean
196:46 - to false we deactivate the boss
196:48 - barrier then if it was not the case then
196:52 - if we also need to check another case if
196:55 - the current
196:57 - state. player in boss fight so actually
197:00 - if now the player is in a boss fight we
197:03 - also need to skip so we won't process
197:09 - the logic that comes after so we have
197:11 - two cases that we want to avoid going
197:13 - further the first case is if the boss is
197:15 - defeated that means means we just want
197:17 - to destroy the gate however if the
197:19 - player is in a boss fight in the boss
197:21 - fight we just want to return early so
197:23 - colliding with the boss barrier will do
197:25 - nothing uh
197:28 - special so now the the case here that
197:31 - we're going to write now the the default
197:33 - case is when the player first enter
197:35 - collides with the boss barrier so when
197:39 - that
197:40 - happens we are going to first disable
197:43 - the player controls so this is something
197:45 - I did not write in the player logic so I
197:47 - need to do that so if I go to player. JS
197:52 - and then from player. JS let's write a
197:55 - method maybe here right disable
198:00 - controls and this is where we're going
198:02 - to use the uh the uh control handlers
198:06 - that we had initially so what I need is
198:09 - simply to have a for Loop that will
198:11 - iterate through the various handlers
198:13 - that we we stored in this Dot
198:18 - control
198:20 - handlers and then cancel them so the way
198:23 - you do that is by calling the cancel
198:25 - method by default all of these handlers
198:27 - have access to that method and then of
198:29 - course don't forget to add the comma
198:33 - here all right so now we have disable
198:36 - control and um there's also another
198:39 - logic I should uh another method I
198:41 - should probably add is called respawn if
198:45 - out of bounds so we want make sure the
198:48 - player responds if they fall uh off the
198:53 - a
198:53 - platform so here I'm going to set three
198:57 - value the B bound
198:59 - value the destination three par I'm
199:02 - sorry the destination name and then the
199:06 - previous scene
199:08 - data and by
199:11 - default it's going to be
199:15 - exit name null so this is going to make
199:20 - sense in a in a moment so actually for
199:22 - now I'm just going to leave it to to do
199:25 - it it's it's going to make sense when
199:26 - we're going to link up the various
199:28 - scenes with each other so now I'm going
199:31 - to go back to the room
199:35 - utils and then from there after having
199:39 - written the boss player Collide I can
199:43 - write um okay first I make a call to
199:47 - disable the player controls because we
199:48 - want to basically Force the player to go
199:50 - through the gate and not not arrive with
199:53 - a situation where the player doesn't uh
199:57 - avoids the gate basically as the gate is
200:00 - sucking the player in it the player is
200:03 - trying to get could avoid it and move to
200:06 - the other direction we don't want to
200:08 - have this situation otherwise you're
200:10 - going to have a bunch of bugs so by
200:13 - disabling the controls of the player and
200:15 - forcing him to go to the gate through
200:17 - the gate if they collide with it uh to
200:19 - go to the boss battle and it's a bit
200:21 - like that in the Souls game once you
200:23 - commit to going through the gate uh
200:26 - there is there is no going back
200:28 - basically and then I'm going to play the
200:30 - idol animation while while we do
200:36 - this and then here I'm going to again
200:39 - have an await for a tween which is going
200:43 - to be responsible for uh changing the
200:47 - player position from this to player Pax
200:50 - but plus 25 pixels so that we make sure
200:53 - that the player goes through the gate we
200:55 - want to do that in 0.2 seconds and here
200:58 - we have the value function that
201:01 - basically do the the adjustments of the
201:05 - value until the destination is reached
201:07 - and then here with an easings
201:12 - linear and then once this is done we are
201:16 - Sav to do player. set controls again so
201:19 - that we give back the player controls uh
201:22 - the controls to the player so this is
201:24 - await so that as long as this is not
201:26 - done we won't proceed forward otherwise
201:29 - if you were to remove that this would
201:31 - run while this would also run so that
201:33 - mean the player could escape and go out
201:35 - of the gate uh yeah out of the Boss
201:37 - Arena while the transition would
201:41 - happen all
201:43 - right now another one so after having
201:46 - the UNC collide with the
201:48 - player the boss barrier we also have the
201:51 - uncollided end so not only can we in
201:55 - Kaboom J know when collide with
201:57 - something but we can know when a
201:58 - collision ends with a game object as
202:00 - well and then here we don't really need
202:02 - to have the player game object here what
202:04 - we want to do is that once the the the
202:08 - Collision is over first I'm going
202:11 - to hold the the current state like that
202:14 - just for it it's handier I guess
202:17 - and then I'm going to have current state
202:20 - and then if the current state is a um
202:23 - player boss fight so if the player is in
202:25 - b a boss fight
202:28 - or current
202:31 - state
202:33 - do so if either the player is in boss
202:35 - fight or the boss is defeated so is boss
202:38 - defeated then we return early we don't
202:41 - do
202:43 - anything and then otherwise we're going
202:47 - to set so state do
202:51 - set so State PR enum to make things less
202:55 - error prone and what we're going to set
202:57 - is the player in boss fight and here
203:01 - we're going to set it to
203:03 - true so that the the boss fight is
203:06 - actually starts and then the boss
203:08 - barrier will activate
203:10 - preventing
203:12 - any while preventing well what actually
203:15 - the activate does is just going to show
203:17 - the the boss barrier and then we're
203:20 - going to assign to the boss barrier a
203:24 - body component so the way you add a
203:27 - component after the fact after having
203:29 - creating created an object you use the
203:31 - use method and then here we want it to
203:34 - be static because it's an obstacle and
203:37 - here we
203:38 - go and that's basically it so now if I
203:41 - go back to the
203:43 - game and hit enter and I if I just go
203:47 - back to the Boss
203:49 - Arena then this is following
203:52 - me yep you can see the Boss Arena is
203:55 - here and I cannot Escape so maybe let me
203:59 - just retry this time around without
204:01 - activating debug mode so that you can
204:03 - have a can clearly see so here we go I'm
204:08 - playing
204:08 - [Music]
204:11 - around then as soon as hit I'm
204:14 - transported and I'm stuck here so now
204:16 - it's time to code the boss battle itself
204:19 - so the boss
204:21 - itself so how we're going to do that is
204:25 - going to create a new file in the
204:28 - entities folder that file is going to be
204:30 - called enemy boss.
204:34 - JS and it's going to take the exact same
204:38 - mostly the same uh uh properties Etc so
204:43 - what I'm going to do is I'm going to
204:45 - copy and paste a bunch of stuff but for
204:47 - now let's uh first write the Constructor
204:49 - function so make boss and then pass in K
204:53 - and the initial
204:55 - position as for the components we're
204:57 - going to of course return a k. make and
205:00 - then here for the components I'm just
205:03 - going to copy and paste the first few
205:06 - components here so we have a state
205:09 - machine with different states we have
205:11 - the idle State the follow state where
205:13 - the the the boss follows the player the
205:16 - Open Fire state where the player the
205:19 - boss starts opening fire from their
205:21 - flamethrower and then the fire state
205:23 - where it's firing and then the shot fire
205:26 - when the the animation to close the
205:29 - flamethrower will play and then finally
205:32 - the explode state which is where uh when
205:36 - the player uh the boss dies and then
205:39 - here we have a mass of 100 and a jump
205:42 - Force initially I made the the the boss
205:45 - jumping as well but I haven't used this
205:48 - anymore so feel free to remove it here
205:50 - it's again the same thing here the
205:52 - animation is burner the Sprite and the
205:54 - animation by default is going to be idle
205:56 - and then the health I gave him 15 points
205:59 - of health and opacity initially it's one
206:02 - but as with a player when it gets hit
206:04 - when the boss gets hit it's FL it
206:06 - flashes so it blinks so now what we have
206:08 - here is our various methods uh so let's
206:12 - first I'm going to copy and paste the
206:13 - various properties as well soy suit
206:16 - Speed fire range and duration of the
206:18 - fire and then right below we're going to
206:22 - have the set behavior and set events so
206:24 - set
206:26 - behavior
206:27 - and set events much uh of the same
206:32 - structure as I did with the player and
206:35 - the drones and
206:36 - Etc so here we go and uh yep
206:41 - um I'm going to before going onward I'm
206:45 - going to just uh Define a reusable
206:48 - function that will make the any game
206:50 - object blink uh as I explained it's when
206:54 - the player or the bosses or the enemies
206:57 - take damage uh except for the Drone
206:59 - because they immediately die when they
207:00 - jump on when they hit you so but for the
207:03 - boss and the player there is some
207:06 - reusable logic we can write and I think
207:10 - I'm going to write a create a new file
207:12 - in the entities folder I'm going to call
207:15 - it enti T shared logic.
207:21 - JS so what does this do it
207:24 - will make uh going to have a single
207:27 - function I'm just going to copy and
207:29 - paste it here and go over it so
207:32 - basically we have a make blink function
207:34 - that takes the context The Entity the
207:37 - game object and then it's time span by
207:39 - default it is 0.1 we can specify a
207:41 - different one if you want so it's an
207:43 - optional parameter and then here
207:47 - um we use twins to make first the
207:49 - opacity go from one to zero in a certain
207:52 - time span and then the reverse so the
207:55 - first one is important to have a weight
207:57 - so that this doesn't run as this is
208:00 - running but the second one there is no
208:03 - need to have no weight because it's the
208:04 - only thing here so hope I made this
208:07 - clear all right so now for the
208:10 - boss if I go to set
208:14 - Behavior Uh I'm going to actually first
208:16 - of all let's add the blank logic to the
208:21 - player so I in the set events here I'm
208:26 - going to add a bunch of events to handle
208:29 - that so for the player remember the heal
208:33 - and hurt events so we can we can use
208:35 - that so this do on heal event listener
208:39 - is something that is offered by Kaboom
208:42 - if you use the health component on your
208:44 - game object so here what I'm going to do
208:47 - is I'm going to set the this the health
208:51 - State uh as follows so State props enum
208:55 - and then here player HP and I'm going to
208:58 - set it to the current so this. HP of the
209:05 - component and then I'm going to
209:08 - trigger uh actually hit here to do
209:12 - health bar bar
209:13 - logic so of course we're going to have a
209:16 - UI element that is going to update or uh
209:19 - yeah so here we're going to trigger a
209:21 - custom event for the health bar we
209:23 - haven't created health bar yet so that's
209:25 - why I just going to put a Todo message
209:27 - here the other one which is actually why
209:29 - I came in this file first is because we
209:32 - wanted to make the player blank when
209:33 - they get hurt so we're going to do that
209:36 - inside of the hurt event listener that
209:38 - of course is offered because we when you
209:40 - use the heart function the heart method
209:43 - to reduce the life point of the player
209:46 - the life the health of the player this
209:48 - gets fired and here this is where we're
209:51 - going to call make
209:53 - blink and should normally automatically
209:56 - import it so if you go upward it should
209:59 - be imported all
210:01 - right so make blink is going to take um
210:06 - K and then this which is the game object
210:09 - itself the player itself and then here
210:11 - in this logic if the HP as long as the
210:14 - HP is superior to zero so if the HP is
210:17 - superior to zero I'm going to set the
210:20 - State of the State props en.
210:26 - player HP and then set to the new
210:30 - updated
210:31 - HP so remember the HP method gives you
210:35 - the upto-date um HP calling the hurt on
210:39 - the player fires this event because not
210:42 - only the hurt actually changes the value
210:45 - the health value but also by having this
210:48 - event we can make the player blink but
210:50 - also make sure to set the state for the
210:52 - global state so that when we move on to
210:55 - the second room it's going to keep track
210:58 - going to have the same health value
211:00 - otherwise everything is scoped so by
211:02 - default the comp uh the the the
211:06 - component HP health is scoped on the
211:09 - scene where the the player is created um
211:12 - actually I think there is maybe a method
211:14 - called stay in boom Jazz that allows you
211:17 - to have the same uh game object stay in
211:22 - the next scene I haven't yet learned
211:25 - about it much but I just remembered that
211:27 - it exists so maybe we could have gotten
211:30 - away with not having to deal with global
211:33 - State like that so something to check if
211:36 - you want on on kabon j.com which is the
211:39 - official Doc
211:41 - site here we're GNA also have a health
211:43 - bar update so I'm just gonna
211:46 - I leave a comment
211:48 - here and then we return early because
211:53 - otherwise we will
211:56 - simply have the following code so in
212:01 - case the HP is not Superior to zero I'm
212:03 - just going to copy and paste this
212:07 - part we going to set the state of the
212:10 - player HP to be the max player HP so the
212:13 - reason for this is that we're basically
212:14 - respawning now you could put this later
212:17 - on you could put this after so that
212:20 - first you have the boom sound then the
212:23 - explosion then the the health bar the
212:27 - health of the player is set to being
212:29 - full health because they were going to
212:32 - respawn and then right below that this
212:36 - on anim
212:38 - end
212:40 - anim go so if the anim
212:46 - is equal equal to explode which was
212:48 - triggered here right
212:51 - above
212:54 - explode what's with the weird spacing
212:59 - here we're going to go back to the same
213:02 - room one scene so it's effectively
213:06 - responding so I think we have this and
213:09 - uh yep we have everything we need so
213:12 - let's save that let's of course save
213:15 - this as well well so now if I look at
213:17 - the
213:18 - game press enter can let's see if we
213:22 - take them if we blank if the player is
213:24 - going to Blink yep they
213:27 - blinked so as you can see all right so
213:30 - let's do the state machine for the boss
213:33 - so much like the Drone it's going going
213:36 - to basically have the same pattern so a
213:38 - couple of this not uh on state update or
213:42 - on state enter so let's start with the
213:45 - idol state so on state update we're
213:47 - going to need
213:48 - here and then so for the idle State what
213:52 - we're going to
213:53 - do is make sure that if the state and
213:58 - then current all right so now we need to
214:01 - check for the current state if the
214:04 - player is in a boss fight so state.
214:07 - current and then player in boss right if
214:12 - that's the case we're going to move to
214:16 - the following so enter State and then we
214:19 - move to the follow so this makes sense
214:22 - because as soon as so when the player is
214:25 - not in a boss fight so that means
214:27 - they're not they haven't passed through
214:29 - the gate we don't want the boss to do
214:31 - anything we want the want it to remain
214:34 - idle however as soon as the boss uh the
214:37 - player sorry and has enters the gate
214:40 - this is set to true and that means that
214:42 - it's time for the boss to start
214:44 - following the player
214:46 - so here we don't really need a actually
214:49 - in fact this shouldn't be a on state
214:50 - update it should be an on state enter oh
214:54 - no it's an update because when the game
214:57 - the the room is initialized the the boss
214:59 - is placed so we need to check this every
215:02 - frame until it actually happens the the
215:04 - player actually enters the
215:07 - arena all right the next uh event we
215:10 - need to listen on is on state the follow
215:13 - event so on state enter follow
215:17 - what we're going to do is we're just
215:19 - going to play the Run
215:22 - animation
215:25 - so so here um so we have the play okay
215:30 - so we play The Run animation and then
215:32 - for this on
215:35 - state update for the follow as well with
215:38 - follow
215:39 - State we're going
215:41 - to in case you didn't copy here are the
215:45 - very State we we're going to use so here
215:47 - so for the follow State uh every frame
215:50 - what we're going to do is we're going to
215:53 - first set the flip x value in much the
215:56 - same way we did for the Drone so if the
215:59 - player position is inferior to the
216:02 - boss's position that means that the
216:04 - player is to the left and that means
216:06 - that the boss should face left that's
216:08 - why we do a flip x equal true because by
216:11 - default the Sprites are drawn facing
216:14 - right now
216:16 - here this do move two so we're going to
216:19 - use the move to again as we did for the
216:23 - uh drones and we're going to again do
216:27 - exactly the same thing so move towards
216:30 - the player position with an offset of 12
216:34 - here so that uh we don't have this weird
216:36 - case where the player is the boss will
216:40 - basically be stuck with the player but
216:43 - nothing will happen so then here we're
216:46 - going to have a Pursuit speed as well
216:49 - actually in fact I don't think it's
216:51 - needed here for this specific case
216:53 - because at the end of the day even if
216:55 - the the boss gets stuck with the player
216:58 - the player can just move around so yeah
217:00 - now the pursuit speed is the same yeah
217:04 - for this boss for the boss we only have
217:06 - a Pursuit speed so we don't have a
217:08 - normal regular speed like with the
217:10 - drones and uh that's basically it for
217:14 - this logic uh we also o need to add an
217:16 - if statement which will determine if we
217:19 - move out of the follow state so if the
217:21 - position uh of the player position uh no
217:25 - if the position of the Drone um the boss
217:27 - sorry is uh if if the position of the
217:32 - player is near enough the position of
217:34 - the boss and this we we we do this by
217:37 - checking for a specific range so the
217:40 - fire range so 40 so if this distance is
217:44 - this distance is in inferior to 40 in
217:46 - this case what we're going to do is
217:49 - we're going to enter into a new state
217:51 - which is the um open fire open fire
217:59 - State and then for the Open Fire State
218:03 - on state
218:05 - enter
218:07 - open fire and then what we're going to
218:10 - do
218:11 - here is just play the Open Fire anim
218:18 - I made a mistake here it should be
218:22 - lowercase and now after this animation
218:26 - is done we're going to actually have it
218:28 - on anim end here but uh for now we're
218:33 - going to have this on anim end uh logic
218:37 - inside of the set events and not here so
218:40 - let's continue defining our various
218:42 - other states and and then we we will
218:45 - tackle this later
218:47 - on so here we could
218:51 - have um that this on state
218:57 - enter for the fire so let's define the
219:00 - logic for the fire
219:03 - state so what we're going to do
219:06 - here
219:09 - is create uh the flamethrower sound
219:14 - flamethrower sound which is going to be
219:16 - a reference to the sound of the
219:19 - flamethrower which we can play like this
219:22 - remember we imported this sound in the
219:25 - Kaboom load loader. JS
219:28 - file now what we do next here
219:33 - is to have the fire
219:37 - hitbox we need to create the hitbox for
219:39 - that and we're going to basically add it
219:42 - as a child of the boss game object and
219:46 - here again it's the same logic we did
219:48 - for the sword attack for the player just
219:51 - various different values here so I'm
219:54 - just going to copy and paste that to go
219:56 - quicker and then here for the logic for
220:02 - when the player hits the collides with
220:04 - the hitbox again this is very similar
220:07 - logic that we did with the sword attack
220:10 - but this time around we hurt the player
220:12 - and then if the P if the HP is equal to
220:14 - zero we set the state we said the the
220:19 - player in boss fight to being false that
220:21 - means that the player just died and that
220:23 - means simply that they're no longer in
220:26 - the in a boss
220:28 - fight and then here finally we have the
220:30 - K Weight which is going to wait this is
220:33 - another form of the weight variant so
220:37 - here I'm just going to put the fire
220:38 - duration so how long does the the fire
220:43 - attack lasts it's it's a property we
220:45 - created here one
220:47 - second and then we run this logic so the
220:50 - second param is the logic to run this is
220:53 - the SEC another form you could have used
220:55 - a weight here and then did your logic
220:58 - right after here but I I felt that it
221:02 - wasn't really needed to use a weight
221:04 - here because there's yeah we can just
221:07 - use this
221:09 - form and then here what happens is that
221:12 - when the fire duration so when the fire
221:15 - attack ends we will stop the sound so
221:18 - that's why I I stored the the sound here
221:22 - the sound listener reference so that I
221:25 - can easily use the stop method on it
221:28 - which is offered by Kaboom as well and
221:31 - then after we have stopped the sound the
221:34 - player uh not the player the boss will
221:36 - enter the shut fire State now for the
221:40 - Open Fire and shut fire we haven't
221:41 - defined anything for the shut fire and
221:44 - open fire we haven't defined any on
221:46 - State uh enter or stuff like that uh
221:50 - we're going to do this in the set events
221:52 - we're going to actually just in our on
221:55 - adim and event listener just run into
221:58 - like enter those States all right so now
222:00 - uh let's define those uh let's let's
222:03 - define the remainder the
222:06 - remaining uh on state enters on state
222:09 - end and on
222:10 - state update for the fire so this onate
222:15 - State end for fire
222:20 - state so this happens
222:24 - here and then inside of this the we we
222:28 - just use that state to delete the fire
222:31 - hit box so as we did with the sword
222:34 - attack you get the fire hit box and then
222:37 - you check if it exist before trying to
222:40 - destroy
222:42 - it and then finally we have actually we
222:47 - have two two things we have the Shut
222:49 - fire so sorry I was inaccurate later on
222:52 - I said we wouldn't Define a on state
222:54 - enter for shut fire but we actually do
222:56 - here we just play the shut fire
222:58 - animation here and as here the on state
223:01 - update for fire this is uh useful to
223:04 - Simply play the fire animation if it's
223:06 - not already playing as as we go here but
223:09 - here I realized that um we could have
223:12 - just defined this here so so yeah I
223:16 - think this is not a necessary State we
223:19 - can take this line of
223:20 - code I'm going to just comment this
223:24 - out and I'm going to paste it here so we
223:26 - just play the animation of fire right
223:32 - here and like that so now let's go to
223:37 - our set
223:38 - events here again we're going to get the
223:41 - player so as we
223:44 - did actually we didn't do this here so
223:48 - const
223:49 - player k. getet player and then
223:55 - recursive true and then index
224:02 - zero and then here we're going to Define
224:07 - an un Collide here so this time around
224:09 - it's the reverse it's when the boss
224:12 - collides with the sword hit box we play
224:15 - the boom sound and then we hurt the boss
224:19 - so we reduced its health and this is an
224:22 - important part that I referenced earlier
224:25 - on we're talking here
224:28 - about the this on anim end we we going
224:32 - to we're going to use a switch case
224:33 - statement here so if we are in the open
224:36 - fire State we enter the fire state so
224:40 - here open fire if I remember correctly
224:42 - we just play the Open Fire
224:45 - um animation this open fire animation
224:49 - ends it's not a infinite Loop uh the
224:51 - loop property wasn't set to true there
224:54 - if you look at the Kaboom loader. JS
224:56 - file if you
224:57 - remember so if we go here to the boss
225:01 - the burner Yep this the boss so for open
225:04 - fire there is no um Loop set to Tri so
225:09 - that means that the animation plays once
225:11 - and then when it ends it ends that's why
225:13 - we can use a in our code
225:16 - here where is it where is it
225:21 - here that's why we can
225:24 - use here um the the on anim and listener
225:30 - so we do the same thing for the shut
225:31 - fire here as well so when the shut fire
225:34 - animation ends we enter this the follow
225:36 - State and finally when the explode
225:39 - animation runs we after it runs actually
225:43 - we call the destroy method uh function
225:47 - from Kaboom to destroy the boss so the
225:49 - boss has been defeated and then right
225:53 - below that this is where we're actually
225:55 - going to define a custom event called
225:58 - this on explode this is exactly the same
226:01 - thing we did for the the Drone enemy uh
226:06 - so here we entered explode State now
226:08 - here explode State uh we haven't defined
226:12 - it I
226:13 - think uh did we do so the the purpose of
226:17 - this is just to have a state that is
226:18 - different than what is the the other
226:20 - states so it doesn't do anything really
226:24 - but yeah that's uh that's that's that uh
226:28 - it's just to if you we weren't to do
226:31 - this uh it would the the state machine
226:33 - would enter other states and then it
226:35 - would conflict so by having a dedicated
226:38 - state usess state quote unquote we were
226:41 - able to uh not enter this case and
226:44 - remember that here the explode we you
226:48 - need to add it as well here in the the
226:50 - state array at the
226:52 - beginning so what we do here we set
226:55 - Collision ignore to the player for the
226:57 - same reason we unuse the body we play
226:59 - the boom sound again uh we play the
227:02 - explode animation which after it's done
227:05 - it's going to destroy the enemy the boss
227:08 - we set the isbs defeated true state to
227:12 - true we set the is double job jump
227:15 - unlocked to true and then here I have
227:18 - enable double jump uh method we haven't
227:21 - written this so let's just write it out
227:24 - quickly
227:25 - so right it's a two one line basically
227:29 - on line method so I'm going to put it uh
227:31 - maybe at the end of the player so let me
227:35 - collapse this so it's
227:37 - clear like
227:41 - that so enable double jump uh the way
227:44 - you you have access to the num jumps
227:47 - property if you use the double jump
227:48 - component and you can set it to to a
227:50 - number you want and here we're going to
227:51 - set it to two so now if I go back to
227:54 - enemy boss it's going to do that we're
227:56 - going to play the notify sound which is
227:58 - a sound that basically will display this
228:01 - notification box now make notification
228:04 - box is does not exist yet so let's
228:06 - create it out let's create this UI
228:08 - element so I'm going to go here I'm
228:11 - going to go to the UI folder which is
228:15 - empty and I'm going to create a new
228:20 - file so this file is going to be
228:25 - called
228:28 - notification
228:30 - box.
228:35 - JS and what it's going to contain is the
228:43 - following so we first have as the first
228:46 - param the context as always and the
228:48 - second param is the content then here
228:50 - we're going to make a game object which
228:52 - is going to be a
228:53 - rectangle and with a darkish blue or
228:59 - purple
229:00 - color and then we're going to use the
229:02 - fixed component so that it is not
229:04 - affected by the camera we're going to
229:06 - Center the the position by calling k.
229:10 - Center which gives us the coordinates
229:13 - for the center of the C canvas the area
229:16 - component is important here because we
229:18 - want to set the anchor as a center and
229:21 - the method we're going to use is going
229:23 - to create is simply a close method that
229:25 - just destroys the the the notification
229:28 - box and then as a child of that
229:30 - container because initially it's a
229:32 - container we're going to put a text
229:35 - component so a child game object that is
229:37 - going to have a text component that is
229:39 - going to use the glyph mess font that I
229:42 - showed you showed you at the beginning
229:44 - of the tutorial
229:45 - and the size is going to be 32 this is
229:47 - what looked
229:48 - good as for the color of the text this
229:51 - is what looks good and fits with the
229:53 - color pallet uh here area and anchor
229:56 - Center again so that the text is
229:57 - centered and then we return the
229:59 - container so that's our notification box
230:03 - if I go to the enemy boss here we can
230:05 - see the text I have put you unlocked a
230:07 - new ability you can now double jump and
230:10 - then after 3 seconds the we going to
230:13 - call the close method the we defined
230:15 - here so that uh the the the notification
230:18 - box uh is closed so here we just add it
230:21 - to the general canvas instead of the par
230:24 - uh the map because it's a UI element and
230:27 - we just store it here so that we can
230:29 - have access to close we can call the
230:30 - close
230:32 - method all right uh now let's import
230:35 - that properly uh because it didn't do it
230:38 - for us automatically so
230:41 - here import notific make notification
230:45 - box remember to add ajs otherwise you're
230:47 - going to get a MIM type
230:49 - error and oops and that's it so now that
230:55 - we have that I think we have everything
230:57 - we need for the boss and it's now time
231:01 - to test it out so let me just make sure
231:04 - that's the case oh we have one last
231:07 - thing uh one last event so the hurt
231:10 - event for the boss so as I explained
231:14 - multiple times now the hurt event is
231:17 - something offered by Kaboom if you use
231:20 - the um health component and here we're
231:23 - going to make blink the um the boss if
231:27 - the HP is superior to zero though we
231:30 - return early as we don't want to trigger
231:32 - the explode event which will take care
231:34 - of destroying the
231:37 - boss all right and let's import that
231:41 - also
231:43 - import make
231:46 - link and uh that's it yep that's the
231:50 - whole logic so now in our room 1js so in
231:55 - room 1js if I go to the positions
231:59 - here and then here I'm just going to add
232:01 - a
232:04 - continue so the reason I'm adding a
232:06 - continue here is that if for this
232:08 - position we enter here there's no point
232:11 - in uh running the other if statement
232:14 - that comes next so because we already
232:18 - know that it's a drone here for this
232:21 - iteration so we need to go to the next
232:23 - iteration to have a to check for the
232:26 - other entities so if the position here
232:30 - name and then here I think it was
232:34 - boss yeah if we have a boss and of
232:38 - course we only spawn the boss if the
232:42 - state current
232:47 - that uh is I think
232:52 - is his boss defeated is
232:57 - false so only if the if the boss was is
233:00 - not defeated that we will spawn the
233:04 - boss and here const
233:07 - boss we add it as a child of the map and
233:12 - then we call the make boss
233:16 - now that we have the make boss we just
233:18 - put here k. Vector 2 for the position
233:25 - oops I can't seem to write it well and
233:28 - then position X position Y and here and
233:33 - then finally we call boss set Behavior
233:36 - which is going to set the AI for the
233:39 - boss and the boss set event events
233:43 - because it's going to set the the
233:44 - various events for
233:46 - it and that's it and also for the
233:49 - cartridge so the cartridge are basically
233:51 - Health uh but before doing that let's
233:54 - just test it out so if I look I
233:59 - refresh state is not defined okay where
234:02 - is that issue
234:05 - from State not room one okay we forgot
234:09 - to import the
234:11 - state so here
234:15 - uh let's import it here
234:17 - import
234:19 - State here we go now if I refresh press
234:24 - enter okay V okay I forgot Vector 2 uh
234:29 - room one line
234:31 - 64 line
234:34 - [Music]
234:35 - 64 yep I made a stupid mistake here a
234:39 - typo and then if I press enter what I
234:42 - mean state is not defined where an enemy
234:45 - boss forgot to import the state here as
234:49 - well so import
234:54 - State hopefully now it works press enter
234:58 - and yep so now let's play through the
235:03 - game all
235:05 - right all right let's see if we can
235:09 - fight the boss player is not defined
235:13 - come on
235:15 - players not defined enemy Boss line
235:17 - 35 okay line 35 where the enemy boss
235:21 - where's
235:23 - that player to position okay I guess I
235:27 - should have const player equal K do get
235:36 - player
235:39 - recursive true and then here we go
235:45 - and then now if I play the game normally
235:49 - everything should work all
235:53 - right and
235:56 - then here we
235:58 - go yeah the boss seems to
236:03 - work does he follow me
236:10 - yep H State prop enums is not defined
236:15 - so this is
236:17 - probably again in the enemy
236:21 - boss State props enum here we
236:26 - go so if I fight the boss
236:32 - again here we go and then I move
236:39 - forward there you go
236:47 - all right you unlocked a new ability you
236:49 - can now double jump and now I can indeed
236:52 - double jump so okay so the game works
236:55 - all right now what we
236:57 - need is two things we need the health
237:02 - bar and uh y we need to do the health
237:05 - bar and then after that we'll add the
237:07 - cartridge and then after that the only
237:09 - thing left is really the uh the um the
237:13 - room the second
237:15 - room so
237:17 - for uh room
237:20 - one uh actually no for the UI I'm going
237:23 - to create a new file I'm going to call
237:25 - it health bar. JS I think it would be
237:30 - better to just tackle the cartridge so
237:34 - for the cartridge what I'm going to do
237:37 - uh cartridge are basically Health packs
237:40 - and we can just go to room one. JS and
237:43 - then add a simple if statement here is
237:48 - again it's a single line if the
237:53 - position type is equal equal to cart
237:59 - rdge actually we're going to need to
238:01 - create a new entity for that map add and
238:05 - then we're going to add the cartridge
238:07 - here so in entities create a new file
238:11 - call it health C
238:15 - cart
238:16 - cartridge.
238:18 - JS and then here in health
238:23 - cartridge we're going to have a
238:25 - simple um simple component
238:29 - here let me just explain so make CD The
238:32 - Constructor K and then the position and
238:35 - then the position is just set here then
238:38 - we play use the Sprite cartridge with
238:41 - the default
238:42 - animation and then and we set the on
238:45 - collide with a player and then every
238:48 - time the player collides with the
238:51 - cartridge we play the health sound with
238:53 - a volume of 0.5 because the original
238:56 - sound was too loud and then if the
238:58 - player HP is inferior to the max player
239:01 - HP we allow a heal otherwise we do
239:05 - nothing uh we don't heal at either way
239:08 - we destroy the
239:10 - cartridge so if I go to room one now
239:13 - call make cartridge make
239:17 - cartridge pass in k pass in k. Vector
239:22 - 2 and then position
239:28 - X
239:32 - position
239:35 - Y and then that should be
239:38 - it so if I go and test this
239:42 - out we have our c Bridge here let's try
239:45 - colliding with one and you hear the
239:48 - sound so there is not much
239:52 - um let me just test something so there
239:55 - isn't much to do here to test uh without
239:58 - the health bar so the health bar is
240:00 - really key now so I'm going to go back
240:03 - to health bar. JS which we created here
240:06 - in the UI component and then health bar
240:10 - is basically simple as well in not a lot
240:14 - of line of codes so I'm just going to
240:15 - copy and explain everything so we have
240:18 - this Constructor which is makes makes
240:20 - this health bar component uses this
240:22 - health bar Sprite sets the frame to zero
240:25 - because we have three frames we don't
240:26 - have any animations for this one as I if
240:29 - you remember earlier on in Kaboom loader
240:33 - what we had here in the Sprite Atlas was
240:34 - the health bar with a slice y of
240:38 - three that means that we have three
240:42 - frames so so in Kaboom JJs you can just
240:46 - display a specific frame by using the
240:48 - frame property so that's why what I did
240:52 - here the frame zero and then here I
240:55 - scaled it four times because this we
240:57 - actually scale the camera I think four
241:00 - or two times uh but for the UI to look
241:03 - good here we need to scale this Sprite
241:05 - four times and here the HP mapping just
241:09 - tells you that for any amount of health
241:12 - so one one amount of Health we need to
241:14 - display the the frame two for two Health
241:19 - Point we need to display frame one and
241:21 - for three Health Point we need to
241:23 - display frame frame zero the reason this
241:25 - makes sense is simply that if you go to
241:28 - the ui. PNG you can see that this is
241:30 - going
241:31 - to this part whoops this is going to be
241:35 - frame zero frame one and frame two so
241:38 - when we have full health we have
241:39 - actually the frame
241:41 - zero and yeah frame two uh frame one is
241:45 - when we have two Health Point and frame
241:49 - uh three is uh frame sorry two is when
241:52 - we have one uh HP
241:55 - left and then here that's why I created
241:59 - this mapping so we can easily uh set it
242:03 - here so then I called the set events
242:07 - event listener I create I created the
242:09 - set events method sorry which is which
242:12 - is where we Define this
242:14 - custom update um method uh I mean event
242:18 - sorry and then what it does it takes the
242:21 - current HP and then if the current HP is
242:25 - equal to zero we destroy the health bar
242:27 - because we're going to just recreate it
242:30 - and regardless we set the frame the
242:32 - current frame to be using uh to be used
242:35 - to being the current HP mapping so here
242:38 - it go though this makes a bit less sense
242:41 - because you could maybe just go here if
242:45 - you're going to destroy the the health
242:47 - bar might as well uh not do that
242:52 - so it becomes pointless to to set the
242:55 - frames afterward and then we're just
242:58 - going to create one health bar here that
243:00 - we used that we use here so instead of
243:04 - creating that in our various rooms we
243:06 - just create one here and we import it
243:08 - where we need it so let's add this to
243:12 - room one. JS so we're going to add it at
243:14 - the end of our file here actually
243:18 - outside of the for
243:19 - Loop health
243:22 - bar then we set the event which is just
243:26 - one we call the trigger we actually
243:30 - trigger the update events event once
243:33 - Health bar.
243:35 - trigger the
243:39 - update and then of course remember that
243:42 - we need to actually add the health bar
243:44 - to the scene because we have only used
243:46 - it with make so we haven't added it
243:49 - anyway anyway anywhere in the canvas yet
243:53 - all right so now that we have that uh if
243:55 - you remember earlier on I had two two
243:59 - dos
244:00 - so
244:02 - to to
244:06 - do um no not not that one um health
244:15 - bar come on I had a a
244:19 - comment to
244:23 - do did I forgot about
244:30 - this seriously
244:35 - H okay never mind never mind
244:38 - so I think it was in the player
244:41 - logic in the events for
244:46 - it yeah okay so it was here health
244:49 - bar so here we're just going to have
244:53 - going to call the health bar then
244:56 - trigger an
245:00 - update we're going to do the same thing
245:03 - here as well so now if I look at the
245:05 - result press enter we have our health
245:08 - bar let's take some damage just just to
245:10 - test things
245:11 - out and then you can see our life is
245:14 - reduced and then when I get healed and
245:17 - damaged again and then let's get damaged
245:20 - again and then let's uh let let's let
245:23 - this Droid kill
245:26 - us here we
245:27 - go and then we respond all right sounds
245:32 - good to
245:33 - me and uh yep so the game is basically
245:37 - done except now we need to have the
245:39 - other
245:40 - room so yep let's work on that all right
245:44 - so one quick thing we're going to do
245:45 - before proceeding on to writing the
245:48 - logic for the other room is we're just
245:50 - going to write some logic that when the
245:52 - player Falls here so after a certain y
245:56 - position they respawn to do something
245:58 - like that we're going to fill this
245:59 - function that I left as a to-do so the
246:02 - way we're going to go about it is the
246:03 - following so if respawn if out of
246:06 - bounds so here I'm going to create a on
246:11 - update Loop
246:15 - this onupdate Loop what it's going to do
246:17 - is it's going to check every frame if
246:20 - the position of the player so here I'm
246:23 - in play.js in this method that we wrote
246:26 - but didn't write the body of previously
246:29 - and then here so if this so this is the
246:32 - player the position Y is superior to the
246:36 - bound value which is going to be the
246:38 - maximum y position we want to
246:40 - allow then um yeah Superior so
246:44 - remember
246:45 - in in a canvas in Game Dev usually the
246:49 - farther you go down the higher the value
246:52 - of y That's why we have this statement
246:54 - here so now what I do is that if I
246:57 - exceed if the player exceeds this bound
246:59 - value we can just go to the destination
247:04 - name which is going to be the the room
247:06 - you want to go to that we're going to
247:08 - Define later and then we're going to
247:11 - pass the previous scene data as the
247:15 - other by the way the go function in
247:17 - Kaboom J allows you to switch to another
247:20 - scene but it can also take uh in
247:23 - addition to the name of the scene you
247:25 - want to go to you can pass some data and
247:28 - here the data we going to pass is going
247:30 - to be the exit name so here in our what
247:35 - is exit name is going to refer to the
247:37 - exits of the
247:40 - um that we had on our map so here the
247:43 - exit layer in tiled you have exit one
247:45 - and exit two so the way we're going to
247:48 - do we're going to go about this is we're
247:50 - going to use this uh previous scene data
247:53 - to tell Kaboom when to spawn where to
247:56 - spawn in the other room in this
247:58 - particular case though what we do is
248:01 - that we're not going to add anything
248:03 - we're going to make the exit name null
248:05 - because we want to just respond in the
248:07 - current
248:08 - scene so here it doesn't make much sense
248:11 - for now uh but bear with me so here it's
248:17 - time now to use the respawn if out of
248:20 - bounds and you're going to we're going
248:22 - to call this inside of the room one.
248:26 - JS in this file I'm just going to have
248:28 - the player
248:30 - here
248:31 - [Music]
248:34 - player um
248:37 - respawn
248:39 - respawn
248:41 - if out
248:44 - of
248:46 - bounds all right so we have this respawn
248:48 - if out out of
248:52 - bounds so what that what we're going to
248:55 - do now is we need to actually pass in
248:57 - the param so I'm just going to pull the
248:59 - player. JS file for reference because I
249:04 - I need to find it just to know what to
249:07 - do so the bound value I think the bound
249:10 - value I did in my original was 1,000 so
249:14 - 1,000 will be the maximum y value want
249:17 - to
249:18 - allow otherwise we would spawn into room
249:21 - one so what we want to do here is to set
249:24 - the respawn if out of bounds uh value
249:27 - the bound value to 1,000 this is what uh
249:30 - looked good and then immediately go to
249:32 - room one if we go out of bounds so let's
249:35 - try it
249:37 - out so if I go here okay it's not a
249:41 - function why is that so here respawn if
249:45 - out of I made a mistake here in player.
249:48 - ja of
249:51 - bounds now everything should work so
249:54 - let's try it
249:58 - out now if I drop
250:02 - off I should respond all right
250:04 - everything is working nice so now we
250:06 - have finished the every like gam playay
250:10 - features and now what is left is just to
250:12 - make the scene transition to the other
250:14 - room and repeat some of the logic for
250:16 - the next room so room two so to be able
250:19 - to pass data between the scenes as I
250:21 - show show as I have shown initially by
250:25 - using this second param to the go
250:27 - function we can actually receive that
250:29 - data we haven't written the logic for it
250:31 - so if I go back to
250:33 - main.ts you can see that we just pass
250:37 - the room one data here but the room one
250:40 - data we can receive it here so if I go
250:43 - to
250:46 - main.js I can create a param here called
250:49 - previous scen data and then I can just
250:52 - decide to pass this as a third Pam to
250:55 - pre to this room one and I'm going to
250:58 - have to of course create a new pram here
251:01 - for uh for the room one function in our
251:05 - room 1js file so this can be passed by
251:09 - the go function by default we want to
251:11 - make sure that this is null
251:13 - um so you have to specify this by
251:16 - default we could have decided that here
251:19 - by default if it's not never mind never
251:21 - mind you have to so by calling
251:25 - K.O room one to go to the room and
251:29 - specifying an object as a second param
251:32 - it's going to be our previous scene data
251:34 - so this refers to this all right now you
251:38 - can see that for our case here we
251:41 - haven't had anything here so let's set
251:44 - the data we want to pass as exit name
251:47 - null we're just coming from the menu so
251:51 - there's no previous exit uh we're coming
251:54 - from but this is going to be useful for
251:57 - room two so here I'm just going to pass
251:59 - the exact same data but just in instead
252:02 - of room one it's going to be room two
252:04 - and then previous seene data here as
252:05 - well and now we need to actually write
252:08 - the code in room one or room 2. J which
252:11 - is pretty empty for now we're going to
252:13 - have to do basically the same thing so
252:16 - set the background color with the color
252:19 - I specified previously which was hasht
252:23 - A2
252:26 - A5 remember to add the doj to the uh
252:31 - import the statement uh make sure to cam
252:35 - scale four times like we did in room one
252:38 - make sure to add to set the initial
252:41 - camera position to 170
252:43 - by 100 like the initial cam uh the
252:47 - initial uh camera position we did for
252:49 - the room one and then set the gravity as
252:52 - well to being 1,000 like we did with the
252:55 - first scene the room one scene then
252:58 - we're going to get the room I'm going to
253:00 - store the room layers inside of room
253:03 - data do
253:06 - layers actually we're going to St going
253:08 - to um store the layers inside of the
253:10 - constant room layers sorry
253:13 - and then we're going to do the same
253:14 - thing we did so create a map game object
253:18 - add it to this scene and then set the
253:22 - position to being 0 0 as a reference or
253:26 - just uh you can easily modify it later
253:28 - on and then set the Sprite to being k.
253:32 - Sprite and then Room 2 remember we have
253:35 - this uh loaded from the Kaboom loader. J
253:40 - file and that's basically so now if I um
253:46 - okay yeah so that's basically it now we
253:49 - we can do the I'm just going to copy and
253:51 - paste the exact same logic we had here
253:53 - so I'm going to take room one and then
253:57 - copy all of
253:59 - these and then all of these as well and
254:03 - even the player as well so really
254:05 - everything comes except for the there
254:08 - there aren't any mobs there are
254:11 - cartridges so we're just going to modify
254:12 - a few things so let's copy all of that
254:15 - and then go here and then paste it right
254:19 - below now of course there's a bunch of
254:21 - import statements that are
254:23 - missing so we going to have to figure
254:26 - this out um I'm also going to remove the
254:29 - Drone here because there are no drone
254:31 - drones in this uh room and also the boss
254:36 - so what is left is the cartridge and the
254:37 - player and then here we're going to have
254:40 - to import everything so let's import
254:44 - um import the player the make player
254:46 - sorry function let's import the make
254:51 - cartridge
254:53 - function we also need to import um the
254:58 - state do do we use the state here not
255:01 - sure no we don't we actually need the
255:04 - health bar as well so let's import that
255:07 - as well health
255:10 - bar and then
255:13 - okay we have the health bar we
255:15 - have everything the and then the various
255:19 - set camera zone map colliders Etc so
255:22 - here again I'm just going to go here to
255:24 - room 1. JS and copy and paste this from
255:27 - room utils so take this import statement
255:30 - paste it here and then save and then I
255:34 - think we should have everything we
255:36 - need um let's try it out so so what I'm
255:40 - going to do now is I'm going to actually
255:43 - have to set the exit zones now so one
255:47 - thing that we didn't write in the room
255:48 - utils is a function to handle when you
255:52 - exit a given room Etc uh Etc
255:55 - so right below Set uh maybe at the end
255:59 - of the
256:02 - file I'm going to go to room Ms and then
256:05 - create a new function export function
256:09 - and then this function you're going to
256:10 - call it as I said set exit
256:14 - it zones and then it takes a the context
256:18 - the map game object the exits and the
256:23 - destination the destination name I'm
256:25 - going to call it this way this
256:27 - part all right so here for so where does
256:32 - this exits come from so here in our room
256:35 - two there's another layer we're going to
256:37 - look for is the exit so I'm going to add
256:41 - right above here if the layer name equal
256:45 - equal exits by the way we need to also
256:48 - add this in the room one logic because
256:51 - there are exit exits as well so let me
256:55 - just verify here so we have the exits
256:58 - layer so now we're going to push we're
257:00 - going to create a new array so you could
257:03 - uh also like make this more modular so
257:07 - all this part that we copied and paste
257:09 - from room one you could have a single
257:11 - source of Truth so a big function that
257:14 - does all of this I didn't do it for this
257:16 - project because it's a relatively small
257:18 - scope but in case you you want to push
257:21 - this further I recommend that you start
257:24 - modularizing and abstracting things from
257:26 - here so here uh we're going to have the
257:29 - exits array that I'm going to
257:33 - create and then in the exits
257:36 - array
257:38 - here I'm going to push exit. push
257:43 - do layer
257:45 - doobs just to not have an error later
257:48 - and of course continue because otherwi
257:51 - there's no point in running the last if
257:53 - statement if we arrive to this condition
257:56 - so you could have decided also to have
257:58 - this as an a um switch case statement in
258:01 - hindsight so feel free to refactor so
258:05 - I'm just going to copy that part in room
258:07 - one as
258:08 - well and now we can go back to room
258:11 - utils and then go back to the set exit
258:14 - zones so for set exit zones we're going
258:16 - to iterate through the exit so exit con
258:19 - exit of
258:22 - exits and then we're going to create the
258:24 - exit zone game object which is a child
258:28 - of
258:29 - the map game object we're going to set
258:32 - the position to be exit X exit y because
258:36 - they offer the
258:39 - position so yeah so we have the
258:41 - positional data in inside of the this
258:44 - exit
258:46 - constant and then we're going to have
258:49 - yeah now I'm just going to copy and
258:50 - paste because it's roughly the same
258:52 - thing we've you've been used to with the
258:53 - other ones so the area is specific we
258:57 - ignore call it collisions with colliders
259:00 - and then we pass in the exit name this
259:02 - is important because this tag is unique
259:04 - to the exit name so here for exit one
259:07 - this is going to be the tag for exit two
259:09 - this is going to be the tag and then for
259:12 - here room one uh room two the exit one
259:14 - here exit two and then Final Exit as
259:17 - well okay so now that we have that right
259:21 - below we can set a collider uh on
259:24 - Collide event listener so if the exit
259:27 - Zone on Collide so collides with the
259:32 - player we're going to have the following
259:35 - so we're going to use in the sync
259:38 - function
259:39 - here and uh I'm just going to copy and
259:42 - paste the code just to go a bit faster
259:45 - and then I'll explain it every
259:48 - line what do we do here so we set the
259:51 - background so this to have a a nice
259:53 - transition so we create a rectangle that
259:56 - takes the whole screen that will move
259:58 - via a tween and then if the exit name is
260:02 - the Final Exit we go to the Final Exit
260:05 - scene we haven't created that scene yet
260:07 - so just copy and paste that for now
260:09 - otherwise we go to the destination name
260:12 - uh which is either room one or room room
260:14 - two depending on where you're coming
260:15 - from and we pass in this object uh to
260:19 - that uh to that next scene which is
260:22 - going to tell us the exit name we're
260:25 - coming from that way we can know where
260:28 - to spawn the player either in entrance
260:30 - one or two so we are going going to have
260:33 - to add some some logic to room one and
260:36 - room 2. J to to control the spawning of
260:40 - the player so now that this is done done
260:43 - we are ready to use it so in room let's
260:46 - let's add it to room one and then to
260:48 - room two as well so for room
260:52 - one I have added it here so let's do it
260:57 - last or yeah we can do it last it
261:00 - doesn't matter okay let's do it right
261:02 - after
261:04 - here so right after camera control so
261:07 - set exit zones and then pass in k the
261:13 - map the exits and then the destination
261:17 - name is room two in room one we need to
261:21 - take this same logic in room two but
261:24 - instead of room
261:26 - one uh instead of room two here it's
261:28 - room
261:30 - one and now here in room one let's go
261:34 - here so for the player position actually
261:37 - it's going to be much more a bit more
261:39 - complex than only one if statement so if
261:43 - I go back to the player uh the room one
261:45 - logic so we're
261:47 - here we're going to have two others if
261:50 - statements so if the prev so for the
261:54 - first one we're going to add the
261:55 - condition that if the previous scene
261:57 - data was null does didn't exist actually
262:01 - we need to do the exit name is null so
262:06 - we would spawn the player in the
262:08 - original initial position
262:11 - otherwise if if if the position.
262:15 - name is entrance so yeah so uh we had a
262:21 - pin if I go here if I go to the
262:24 - positions
262:25 - layer in room one so I'm just going to
262:28 - make it visible we have this entrance
262:30 - one and entrance two pins this is where
262:34 - we determine where to spawn the player
262:37 - uh if they're coming back from a scene
262:40 - so for this if statement if if the pin
262:43 - was entrance one so the position was
262:45 - entrance one and we had a previous scene
262:48 - data exit name passed through this uh to
262:50 - go to arrive to room one and it's exit
262:53 - one then we would place the player into
262:57 - the the position of that pin and then
263:00 - continue on and then set the camera
263:01 - position to be the one of the new player
263:04 - position because otherwise the camera
263:05 - would still be up there in the
263:08 - level and then finally exactly the same
263:11 - logic so here again I was at the end of
263:14 - the project so I just wanted to get it
263:16 - done as quickly as possible so there's a
263:18 - bunch of repetition but at least with
263:20 - repeating code that is simple like that
263:22 - it's easy to to abstract it when when
263:24 - you need it into a more reusable version
263:27 - so here is the same
263:29 - logic all right now we do the exact same
263:33 - thing in room two so for room
263:37 - two I'm just going to copy and paste the
263:41 - logic for by the this time around we
263:43 - only access room two from either of
263:46 - those two exits that you have saw
263:49 - initially so we don't need this default
263:52 - if there's no a default spawn spawn
263:54 - point for room two so it's either
263:56 - entrance one or entrance two if you look
263:58 - in tiled room two you can see the player
264:00 - can either spawn here or or there or or
264:04 - there there is no two
264:06 - option uh two options sorry so here the
264:09 - same logic this time around we set the
264:12 - position
264:13 - as the uh never mind so why is this the
264:16 - case map
264:18 - positionx I I don't think we actually
264:20 - need that so if I go back to room one I
264:24 - just set the position normally since we
264:26 - have the player as still a child of the
264:28 - map we can remove this this was a an
264:31 - error on my part because the position is
264:33 - already relative to the to the map
264:36 - anyway so let me just remove that hope
264:40 - it will
264:41 - work and and here we go so hope I was
264:44 - clear if there is anything unclear feel
264:46 - free to comment in the comment section
264:49 - uh ask your questions there so I can see
264:52 - them all right I think we're basically
264:54 - done let's try it
264:55 - out so there's an error
264:59 - already so set background color room two
265:03 - probably missed an import
265:06 - statement uh set background
265:09 - color what's the issue
265:14 - red Declaration of import set background
265:17 - color previously declared at line one
265:20 - okay so it
265:22 - was so it was re red declared at line
265:25 - three or
265:27 - six ah okay I see I copied it twice so
265:30 - I'm just going to remove the first
265:34 - one now if I press enter exit is not
265:38 - defined uh okay line 40
265:43 - room
265:44 - one so line
265:49 - 40 it's not exits I thought the this
265:52 - layer existed let me look it up exits
265:56 - yes this layer
265:59 - exists
266:01 - uh did I mess something up layer
266:06 - name exits. push ah I forgot to create
266:10 - the original uh the array for all
266:12 - holding all the
266:14 - exits so let's do the same in room two
266:17 - because we're going to have the okay we
266:18 - did it for room two did not do it for
266:20 - room one that's
266:22 - why so if I press enter and then we have
266:24 - our game okay now let's test it out so
266:27 - I'm going to just go to the left and we
266:30 - have previous previous scene data is not
266:32 - defined okay where is this error from um
266:36 - main.js okay main.js previous in data
266:41 - okay we need to pass this here so now it
266:44 - should work let's test it out pressing
266:48 - enter here we go now let's go here and
266:52 - then K is
266:53 - undefined okay so what's the error now K
266:58 - is not defined in room two line
267:01 - 12 room two line 12 so room two line 12
267:07 - okay we didn't pass in the K here and we
267:10 - didn't pass in the room
267:12 - two data as well and we didn't pass the
267:16 - room data sorry the room data as well
267:19 - and we didn't pass in the previous scene
267:23 - data so forgot to add all of these
267:25 - params that we did for room one now it
267:28 - should work
267:30 - hopefully so I'm going to make it this
267:32 - full
267:35 - screen ah set exit zone is not defined
267:39 - again forgot this in room two
267:43 - set let's add it to set exit zones here
267:47 - did we add it for here as well okay for
267:50 - room one and room two we have
267:53 - them so now let's test it out again and
267:56 - now it should hopefully work and it does
268:00 - and then if I exit back in we're back at
268:03 - the correct position so now I'm just
268:05 - going to go to the other one so actually
268:08 - I have to beat the boss first to get
268:10 - unlock the double jump
268:16 - ability okay let me just hit
268:21 - the let me just beat it and then
268:24 - we'll all right now we should have the
268:27 - double jump
268:29 - unlocked and now I can go to the other
268:34 - side
268:36 - here and we spawn in the correct place
268:40 - and now here should it it's normal if it
268:42 - bugs here because the scene doesn't
268:44 - exist or did we actually create that
268:47 - scene yeah Final Exit we didn't create
268:49 - it so the game is mostly done now the
268:51 - only thing left is really to create
268:53 - those last scenes so the intro scene
268:55 - with a message that tells you like how
268:57 - to play and the final uh Final Exit
269:01 - scene so we're going to do this in
269:04 - main.js uh for the final scene I'm just
269:07 - going to create it
269:08 - here right below the intro scene and
269:12 - then I'm just going to make a call to
269:13 - the notification box with this message
269:16 - going to do the same thing for the entro
269:17 - scene and the project is done so here
269:20 - I'm going to
269:22 - import
269:24 - make notification
269:26 - box and then for the intro scene I'm
269:29 - just going to add the following as well
269:32 - so right
269:34 - below
269:35 - here and then one thing I also want to
269:38 - add is I'm not sure if it does anything
269:41 - but the audio on the web page unless you
269:44 - do a gesture the audio will not activate
269:47 - so if the first sound of your game is
269:50 - the sound effect from getting hit and
269:52 - before that there were no sounds played
269:55 - then it's going to have a lag between
269:58 - the the time the sounds actually play
270:00 - and what happens on the screen for the
270:02 - first sound that is uh that is heard on
270:05 - a web page so I thought this would fix
270:08 - the issue but I'm not sure if it does
270:10 - anything so I'm I'm gonna keep it here
270:12 - so so it's about creating a new audio
270:16 - context but I'm not sure if that it
270:17 - works because we should actually resume
270:20 - the the already existing audio context
270:22 - but I'm not sure how to get access to
270:24 - that so this is something with Kaboom I
270:26 - I don't know if there is a fix except
270:28 - that you start immediately playing some
270:30 - background sound when or in the menu
270:33 - playing some sounds that that way you
270:36 - wouldn't have this issue all right let's
270:39 - test it out and okay set back color is
270:42 - not
270:43 - defined import set background color all
270:48 - right we we the game should be done
270:50 - let's let's play it so escape the
270:53 - factory use the arrow keys to move X to
270:55 - jump and Z to attack and then press
270:58 - start so let's
271:00 - play Let's see if everything works all
271:02 - right so I hit the enemy all right ah I
271:05 - took some damage can I go to the left
271:08 - yep by the way this is intentional that
271:10 - the enemies respawn when you you go to
271:13 - to another room uh that's a bit like uh
271:16 - in Souls games the the enemies respawn
271:18 - like that
271:20 - but so I'm just going to beat the boss
271:23 - and once the boss is
271:25 - beaten okay that's I have unlocked the
271:29 - ability by the way you can make the boss
271:32 - more complex I made it simple on purpose
271:35 - so it's easy for me to play test so now
271:38 - I'm just going to complete the game so
271:41 - here go here
271:42 - here and then I took some damage and
271:45 - then I go to the left
271:47 - side and then I jump here and I jump
271:51 - here and uh by the way I'm just going to
271:54 - drop off here to test that the respawn
271:55 - logic Works
271:57 - yep and I'm just going to also go back
272:01 - here to make sure that the logic works
272:03 - all right it
272:05 - does and then I'm just going to finish
272:08 - the
272:09 - game you escape the factory the end
272:11 - thanks for playing and that's it that's
272:13 - the game hope you enjoyed this tutorial
272:16 - and uh by the way if you want you can
272:18 - subscribe to the channel so that you
272:19 - don't miss out on future tutorials I
272:22 - don't upload that often so it it would
272:24 - be a good idea but yeah so I hope you
272:27 - enjoyed the tutorial and you can go on
272:29 - my channel see other gamedev JavaScript
272:32 - related tutorials thanks for watching
272:35 - bye one last thing uh if you ever want
272:37 - to upload this game online what you do
272:40 - is you just zip the the whole code base
272:43 - and then drop drag and drop it on h. and
272:46 - it should be able to deploy that was one
272:48 - thing I forgot to tell you so same thing
272:51 - for GitHub Pages you just activate
272:53 - GitHub pages on the repo for this
272:55 - project and it should be up and running
272:57 - so that's the advantage of not using a A
273:00 - bundler or npm is that the deployment is
273:03 - very easy all right thanks for watching
273:06 - again bye

Cleaned transcript:

learn to use JavaScript and Kaboom JS to build a metrov Vania Style game in this tutorial from JS Legend Dev you'll learn everything from setting up your development environment to implementing complex game mechanics like enemy Ai and boss battles you'll learn how to load assets Define scenes manage game objects and more all while creating a dynamic and engaging Game World by the end of this course you'll have the skills and knowledge to bring your own metrov Vania game to life and deploy it for others to enjoy hi everyone welcome to this new tutorial today we're going to build a Metroid Venia Style game so Metroid Venia is a style of game where mostly there are they're usually Platformers and uh the difference between a normal platformer and a Metroid Venia Style game is that in a Metroid Vania you don't have levels you explore one big map and some parts of the map are not are cut off or not available to you if you don't have certain abilities so the whole point is to explore the map unlock new abilities or find new items as you explore and this will unlock certain parts of the map that you weren't able to access before and here is the simple version of that so here we have a little robot with a sword attack and for now we cannot go to the right uh because we don't have the double jump ability so as you explore the game so here is a health pack uh as you explore the game for example I go here the goal of the game is to exit find the exit which is uh so basically if I start the game from scratch you have this um escape the factory use the arrow kease to move X to jump and Z to attack so here if I explore you can see for example the second room and there's something down below we want to see what it what it is so I'm going to go to uh continue my exploration and here we have drones so drones uh will follow you and selfdestruct so I'm going to teach you how to code that as well so here I have so just to show you a full overview of the game before we start building it so here's the layout Etc and now here I have I don't cannot double jump here if I do I'm going to die so now let's beat the boss which is going to allow us to unlock this ability so the boss we're going to build uh beat is this one so as you enter the boss room you cannot exit out of it so so that's a bit like the souls games and then this little boss has a frame a flamethrower and uh basically the way is we just avoid his flames and we hit it so I'm just going to do this this very quick quickly and then after that going to see that we're going to unlock a a power up which is you unlocked a new ability you can now double jump and then here I can go here and this was previously unaccessible it's a shortcut and I I should not die here I just died anyway uh the game will save uh so you still have the double jump ability and now that we have unlocked this we can go go back to where we couldn't proceed and then I'm just going to beat this one and here get access to the second room and as you see like the camera is dynamic uh it will follow uh when when the player uh passes through certain things it's going to follow I just died here it's going to follow the player or not not follow but just change angles and positions to better show the rest of the level and that's the game now to draw this level to so actually to make this game I'm going to use Kaboom which is a library for making games in JavaScript it's very easy to use and yep so I'm going to teach it to you as well so the prerequisite for this course is or this tutorial is that you know at least the basics of JavaScript we're also going to use til which is this program I have here to draw our level layout so because we're not using a traditional game engine uh that means that we don't have access to a level editor like in gdo and that means we need to use an external program for that otherwise it would be too tedious to draw the level layout in code so here tiled is a nice program that fills this Gap so I'm going to teach you how to how it works basically but I will not go into too much details so I'm going to teach you how to how this map that I made works so the these two rooms uh what are all these colliders Etc but I will not like I did in previous tutorials redraw the map from scratch and show you how it's done uh because it's going to be too tedious to replicate the exact same layout so consider those these Maps as assets they're going to be Json file in the description that you can download and you basically going to import them into your game however I have written a guide so I'm going to spend some time to explain how to um draw maps in tiles in til at a higher level but I'm not going to do go into the needy greedy details for this specific project however if you want to have a written written content I have written recently a blog post on how to use child with Kaboom JS so here is my substack it's where I write content um this is where I I do written tutorials so my YouTube channel is really good fit for Project based tutorials but sometimes you just want to know how to do a specific thing or you want to reference something that you found in my tutorials and referencing a video a specific part of a video is usually tedious so having a blog post nicely written like this is uh how I do things to like I I use this as well for myself so so I can reference back uh when I need it how to do uh how to import uh maps from til how to use til and then use them in kabong so if you're interested uh give me a subscribe here to not miss on future written content so the link will be in the description all right so now for this setup I'm going to use vs code for this project and I recommend that you also do uh because we're going to use the go the live server extension which can be found in the extensions Marketplace live server and then install it here uh it's written uninstalled uh because I've already installed it and this allows us to start a local server for a project and it's very easy uh however if you you have your own setup feel free to use it you can start servers in other ways one one example would be through python uh you can start a local HTTP server with it so let's jump right into the project so I have my workspace here I created a folder I called it Metro Vania tutorial but feel free to call it however you'd like all right so now I'm going to create an assets folder and this is where we're going to put the assets for our game so the ass assets are more mostly coming from an asset pack on .io so I'm going to provide the link for that in the description uh however there are two sprad sheets within that I'm going to replace with my own and those two will be in the description as well the reason I'm replacing them with my own is I just reformatted them so they fit better and can be imported in Kaboom easily all right so let's create an assets folder here if not already I'm going to also create another one which is going to be the lip folder which is where I'm going to put the version of KaBoom so for this tutorial I'm not going to use nodejs I'm just going to use the simplest setup you can for uh Kaboom which is just taking a the GS file and then importing it into your project using native JavaScript modules so if you're if you want to use V for example or or a nodejs based uh setup feel free to do so and if you're not sure how to do that look at my previous tutorial where I made a 2d developer portfolio this is where I used vit and uh npm so you can just take the setup portion and then follow along the rest for this tutorial all right so I have the lip folder here I'm going to put later on the the library here that I'm going to download this also will be linked in the description I'm going to create a Maps folder which is where we're going to put the maps so the two Json files that I I show I've shown you earlier here then I'm going to have the source folder which is going to contain most of our code an index.html which is important because it's the entry point of our program and that's basically it so for the index.html I'm just going to write the code uh start writing the code so I'm going to write the HTML tag a body tag it's not very important for a game to have this uh markup to have like really deep markup uh like uh a lot of boiler plate Etc so I'm just going to use a simple markup HTML body tag and then within we import our script from The Source folder so I'm going to do dot source. main it's important to use a relative path because if you're going to put this on h. it it uses relative path uh paths to be able to load your game so that's why I use a DOT here instead of just writing the absolute path uh this file does not yet exist so let's create it so main.js and then here in index.html we need to also add the type of it to be module the reason we're doing this is because we can without this we cannot use the import syntax we cannot use import X from y this is called native JavaScript uh modules I think all right so now that we have this let's um save everything all right and then I'm going to import the files now so let's see if this work can I just drag and drop can I cannot okay so I'm GNA have to do this differently so I'm going to drag and drop the versions so here what I like to do when I'm not using npm is just to have a a simple text text version that tells you where to get the library and the version of it and here the MGs file is what you need to install uh to download so the way you do that is you go to this link it's going to be in the description hopefully and then you're going to be brought to a page with random code so let me just open it up uh it's not random code actually it's the the code for the library what you do here is you right click and you click save page as and it's going to save it as in Kaboom mg GS file then put it that put that file into your project all right now for the assets I'm going to do the same thing so I'm just going to import everything so uh we're also going to have some Sounds by the way uh those sounds are free uh of use but there is one sound that I put the credits of so yeah every for the sounds a link will be in the description as well so the two Sprites the two Sprite sheets that I've personally modified myself is the burner which is the boss and the u.png which is the player I had to tweak uh the jump animation and uh the placement of the jump animation and for the burner I had to Center everything otherwise that the the character that the spreadsheet wouldn't uh be displayed properly the animation were weird yeah so it's a bit hard a bit hard to explain what the issue was but if you have the original and you try with the original you're going to soon realize the issue we also have this glyph ms. ttf which is the font we're going to use this is provided by the asset pack so everything here is provided by the asset pack in the description but as I said for burner and u.png replace these with my custom ones all right so here you have the sounds Etc okay now let's go to the maps and let's import them as well so there's actually there's four things so I need to explain something here so here room. one. Json is the the file uh basically with all the data needed to draw the map this is from til there's also room 1.png and room 2.png and the reason we have room one and room two here is because in Kaboom Jazz strangely enough it is more performant to just go to tille and then export the map as an image and then just uh it would be one single Sprite and display it as a single Sprite rather than drawing every tile as like as in your logic from the Sprite sheet that's why I have exported both a room one and room two as pgs and the reason and what the Json is for now is just to know where the colliders are so that's the the use for that so usually in game development libraries you would just only need the Json file and you can do that in Kaboom JS you just need that and not the the you wouldn't need the other ones but it would be less performant because the way you would draw is you would take your original asset so your Sprite sheet your tile set here and then draw from there but for some reason in Kaboom Jaz if you do that it's less performant than just having baking all your um your world your map into a single image and then just displaying it so with pixel art it isn't that big of an image but you also need to think um of the network considerations so since this this is web game uh maybe you don't want people to have to download two bigger images and if you could only use um a single small uh image it would be nice better in terms of like uh loading but I think with games people are more uh forgiving when it comes to these stuff rather than a normal website you shouldn't exaggerate but I think that's the usually the case you're usually more willing to wait a bit before playing the game rather than if it were a website that you need to use immediately all right uh now that we have that um I think we can get started with importing Kaboom into our project the way we're going to do this is I'm going to use a file I'm going to create a new file I'm going to call it the Kaboom loader. JS this file is going to to be the one importing Kaboom because okay so I'm just going to do it and then you're going to see why uh it's going to make more sense like that so what we're going to do here is I'm going to write an import statement I'm going to import Kaboom from and the nice thing with JavaScript modules is that you can just do um lib you can import the MGs file immediately like that without any script Tes so once you do this uh so just the path is from the lip folder so here we are in the source folder having dot dot that means we go up to the root of the project and then we go back in lib uh the lib folder and then Kaboom MJS and then here I'm going to have um a constant I'm going to call it the scale I going to scale probably the game two times I'm not sure actually if I use yeah yeah this is going to be a fix around an issue that's going to come up later so for now just uh have this constant up as the scaling and then here export const K is going to be the Kaboom context and the way you initialize the Kaboom canvas is by calling the Kaboom function and then passing it an object which is which can contains a bunch of properties you want uh for for example I can specify the width of my game I want it to be 6 uh 40 uh and the height I want it to be 360 and I want it to have the letter box option to being true so here if for now nothing happens but uh I also need to for I forgot something very important Global should be false so Global the reason is by default if you import Kaboom you just can use start using the Kaboom functions uh immediately but what I want what I prefer to do is to store the Kaboom context in a constant and and uh here K and all Kaboom function will have to be prefixed by this K Dot and then you call the Kaboom function you this makes the code cleaner uh in my opinion so now uh yep so now if I go to main.js and import the um yes so you need yeah so I'm I'm going to import k so import K from Kaboom loader because we're using JavaScript modules and not using an npm based workflow we need to specify the file extensions otherwise it's not going to work so kabum loader loader. JS and then here just by doing this if I click on the go live button which is at the bottom right of vs code you should be able to see the canvas being initialized now one thing I want to add for this project is in the index.html um I'm going to add a bit of styling I want the background to be black basically I think it it's going to be better than white so body and then I add the background not necessar color just background and then black and now if I go back and look at the result you have a black bar so it we can we nicely like see the difference between the canvas and the rest now there's one thing I wanted to do before and the reason I had the scale here is because I want the canvas to be scaled as well so this is a shorthand in JavaScript when you have a property that is the same name of a variable you don't have to do scale not scale you can just use scale like that as a short hand now and also I need to multiply by the scale here the reason I'm doing this is that in kabas uh the pixels certain pix pixs can um it's a bit hard to explain so I'm going to make a schematic XC all right so we have excal draw maybe dark mode here as well uh do we have dark mode all right so in Kaboom Jaz and not necessarily only in that but I've noticed it in Kaboom is that when you have pixel art so imagine this is one pixel okay and imagine that we have a drawing like that with a multiple pixels so let me just zoom in uh it's not going to be perfect here okay we have the this um letter I guess so yeah so we have this letter Let's see we have zero imagine this is a Sprite the issue is that in Kaboom some times a pixel will take more space than a pixel and you will have like a bit of padding like that a bit of padding like that and that means that this pixel and this pixel in theory like in the Sprite art should be the same size but somehow it's not the case and this issue is not entirely resolved so if I go back to the original game uh is it working okay I need to refresh the G sorry um so maybe you can notice it uh so this is with a fix even with a fix there's an issue but if you look here um here you see uh you're probably not going to notice it but this pixel right here ah I think it's better it's more visible here so maybe go full screen this pixel is not the same size as this pixel even though they're supposed to be the same and this is something a random during padding issue that Kaboom adds some padding and this caused this and this is the less worst variant of it so this is bar barely noticeable and it's barely noticeable because of the fix I I the hack I used here but if uh yeah so but the hack is basically you set a scale value which can be two here you multiply your width you multiply your height and then you also set the scale as well so this hack allows us to reduce the um to not have this issue but to have it less less visible so something in Kaboom I cannot I didn't want to modify the source code itself and even even when I tried to fix it didn't work so uh if you're Kaboom maintainer maybe I fix this that would be great so yeah so maybe you cannot unsee this anymore so yeah sorry sorry for making making you notice something like that all right let's go back to yep to the project so now in the Kaboom loader the reason I call this the Kaboom loader. JS is because not only we're going to load the Kaboom uh Library here but we're also going to load our assets from this file so in previous tutorial tutorials I would use Kaboom context and then just have this one and then do the loading in the main.js but I thought to have everything that relates to loading things from Kaboom to be in the Kaboom loader file all right so let's load the various assets we're going to need um I'm trying to think maybe it's not the best to do this directly um I think we we could do yeah if we do this once and for all and then we won't have to worry about anything related to animations so this is something that is very tedious to do I would recommend that you just copy and paste the source code so by the way the source code is available on GitHub so this is something I would not like to spend much time typ it out so I'm just going to explain everything so how we import Assets in kabo so the way assets are imported in Kaboom depends on the assets of course we have the load uh the way to load fonts is by using the load font method provided by Kaboom and that's why I like this pattern of having cab uh Kaboom as being non Global is because we can you can immediately see that if the the method is prefixed by K that means it comes from kabo so so the way you load a font in Kaboom is by using the load function method here and then you pass in the name you want to use to refer to in your code for this specific font and then the second one would be the path to that font so this how you load a font there's also load bit F uh bit map font I think is another one where your font is an image and then you specify each character uh the value but this is not relevant to this tutorial uh to load Sprite uh so or Sprite sheet that Etc you use the load Sprite method and it's basically the same thing if it's a single image you want so let's say you have only one frame in a PNG file you would only need to First specify a name for your Sprite that you want to you uh to refer to and then pass in the path and that's it you would close the the parenthesis uh however in this case we have a spreadsheet that means that we have multiple frames located in the same image and uh to know to tell Kaboom how to slice it we have to pass in a third param which is an object that is going to contain all of this information with also the the animations we're going to Define so let's uh have a look at the Sprite so here we have the player Sprite um Sprite sheet which is located under the Sprites folder and under u.png and here we have a bunch of frames and I realized one thing is that it's not going to be very visible unfortunately because uh the colors you know uh okay maybe I should open a Sprite so this is aprite which is the or yeah aprite which is the software I use to draw pixel art so here we can better see the Sprite sheet uh so the way kaboon uh slice Sprite sheets is first of all you need to specify the slice x value property and the slice y property so slice X is B basically the amount of frames per row so in our uh in our spreadsheet here we have 1 2 3 4 five 6 7 eight we have eight slots uh per row so that's how we determine the slice x value to be eight by nine uh slots per column because this is how 1 2 3 4 5 6 7 8 and nine as you see there is a lot of animations here we're not going to use all of them uh so here it's slice n now for defining animations you specify the anims property and then you pass in an object and each of the these entries are going to be the various animations so for the idol animation so those names here are names that I have arbitrarily so those names are names that I have arbitrarily chosen for myself so you can decide to to name them however you'd like so here I decided to name it the idol animation and by the way it doesn't have to be a property like that it could be a string uh with uh like I don't know maybe uh idle uh dash player you could have decided to name it this way but we're not going to do this here so here Idol and then you pass in another object and this object needs to have the from Key the to key and the Lo whatever or not you want to Loop and this is optional uh but the two main things is these two you need to to basically specify that however you can specify an animation as being a single frame so for example I don't know indle idle um idle one I guess and then I would just specify frame zero like that you can do that one you need to just have one frame so here from 0 to 7 what does that mean so this animation this animation that we Define as Idle is going to start at frame 0o so the way fra uh frames are counted in Kaboom once the uh the you have specified slice X and slice y properties is as follow so you have um zero you start at the bottom uh the top Corner 0 1 2 3 4 5 6 7 and by the way you don't count the frame you count the slots because even this empty frame is considered frame so you would have 0 1 2 3 4 5 6 7 8 9 10 11 12 uh 13 14 15 16 so here for the idle animation it's basically 0er 0 1 2 3 4 5 6 and seven so the first row would be the animation so from 0 to 7 and here I specified the animation to be looping that means it will always play uh when you start playing it it will not stop playing until you stop it manually certain animations like running jumping falling and Idol itself are good to be uh we want them to be infinite like that and we decide when to cancel them but as for explode or attack when an enemy explode Etc it's just a oneandone animation and for the attack animation also it's a one andone we want the attack animation to run and then and then to stop when it's when the attack animation is done the attack is done and here you also see that you have other optional properties like the speed property which you can specify the frame rate her 16 was a good uh uh what was a value I thought would made the game look good so that's basically it um uh you have also another one called the load Sprite Atlas uh so the the difference between a load Sprite Atlas and another another a normal load Sprite is the following so with a load Sprite Atlas you're loading uh you're basically cutting out a specific portion of an image so for the UI you have this whole thing and I only need this part but instead of just like cutting it off what you can do is just use a load Sprite Atlas in your code you specify the file you want to load and then here you can cut out a specific uh sprite from it so here I decided to have a Sprite called health bar it's going to start uh from within the image at coordinate x uh 16 and Y6 so you take your image the coordinate 0 0 at the uh is at the bottom uh at the top Corner top left corner and as you move here 16 and then you drop down 16 here and from this part from this point onward you're going to cut it cut the image with a width of 60 and a height of 40 so this is going to cut the image like that and only keep this portion and then after having done this I'm going to also slice the specify slice y as being true three uh that means I just want to cut out the uh um basically set this as a Sprite sheet so first of all I cut out from the rest of the image only this portion and then I set it as a Sprite sheet by specifying the slice y value that means that every frame so there is only three frames in this uh in this uh this portion and it's going to be the health bar so the first frame is going to be frame zero frame one and frame two so this how you would do it uh if you had um for example this part if you wanted to cut out this part you would specify different X and Y values and then from there different width and height value to just keep this part and then here it will be slice X3 because there's three uh slots per row and by three slice y will be three by three so 3 by3 hope that was clear and that's basically it so here for the sounds it used the load sound uh fun uh method and then you specify the name and then the the sound as easy as it gets so copy this from the source code on GitHub I think it would be better that way than me typing it out so assuming you have this done our assets are all loaded so yeah I might come back here to tweak certain animation but I shouldn't have to do that because this is taking taken from the final project so if we go back to our browser Tab and we still have our canvas nothing changed and that's pretty normal all right now let's um wondering what we should do next is continue creating our folder structure so I'm going to collapse this collapse this collapse this and then here in our source source folder I'm going to create an entities folder this is for the player the drones the boss I'm going to put the logic there for them um also going to you create a scenes folder which is going to be the various scenes we only have two scenes here we have the room one which is the big uh map here and then we have the room two which is going to be just a smaller one so you can see that if you were to expand this project you would have a uh multiple um images like the multiple rooms like this that would comprise the whole world so after the scen folder is created I'm going to also create a state component uh State uh folder this where we're going to hold the global State uh yep so I think the finally the yeah sorry I forgot we need the UI folder for the UI so now we have a neatly organized uh folder structure so let's start with the scenes I think this is the most important part so for let's define our first scene so our scene uh I'm going to use the concept of rooms even though this is much bigger than than a room but I started with this initially I didn't think Kaboom could handle a bigger map so I thought that I would just have multiple rooms stitched together but in the end it was able to so that's great so that's why I I the name stuck because I it felt too much of a hassle to just change everything now so let's create a file called room room uh oops room one. JS and in this file I'm going to have to export a function a sync uh it's going to be a sync I'm going to explain why later on that's probably because we are going to have to import the map actually I don't think we're going to need this Inc here so you know what instead of writing s Inc and not knowing why I will just write a normal function and then when a time comes and we we see that we need it I'm just going to add it back so why why I'm doing this so for now let's create an empty function called room one and it's going to contain all the log defining our fun our scene this scene so yep and uh I'm going to leave it empty for now let's create another file in the scenes folder and I'm going to call it room 2. JS and it's going to be again the same pattern export const uh not const export function Room 2 and it's going to be empty not page transition sorry ah I messed up so export function room to ah come on I'm struggling with my own keyboard and I made a typo as well all right so another function here and also like with room one it's going to contain all the logic we need for our scene and then in main dos I think it was in main dos yeah so in main.js we're going to Define our scenes so here I'm going to create a function I'm going to call it main actually you know what let's do it directly so to define a scene in Kaboom JZ use the scene method and the scene method takes a name which is going to be the name you want to use for your scene to refer to that scene it's a key basically it can be anything you want as long as it's a string and then the second param is a function uh an arrow function but just a function and this function is going to run when the scene is called so here for now I'm just going to import room one from that file and just call it for now there's nothing that Happ that will happen from this optionally you could have decided to just pass in room one without the Arrow function and just the name and uh because we're passing because room one is a function definition it's going to call that function definition but the reason I'm using an arrow here an aror function is because we want to have like the previous data of the scene at one point which is Kaboom is going to pass it to the to the um it's going to pass it to the to this function and later on it's going to be clear so for now just I'm just going to uh leave it empty so I'm going to Define another scene I'm going to call it room two and I'm going to have an N function as well and room to uh I should import it y so bubble should the your editor should s here we go I have room two and I'm going to call it okay that's uh for now and let's have a the intro scene which is the scene you saw that just tells you the control I know it's a bit lazy to have a scene like that but because this is for a tutorial I felt I didn't felt like having a whole menu and uh yeah all that stuff so I just stitch together a simple entro scene that just tells you the controls all right and then finally we going to use the the go method which basically tells uh boom to go to a scene this is important when you define scenes you need to use that go function otherwise uh actually you don't have to I don't think you have to you could have a the the the the default code for example it could start writing your logic here and it's going to display but usually the the patterns that you define your scenes and and then you call the default one call one otherwise you're going to not know why your scene is not displaying if you don't call it within the main.js F all right so we have this here and I think we're ready to see if anything changed in our uh project I don't think anything changed but you see the loading bar that means that the assets are indeed being loaded the loading bar sorry all right so now let's go back to room one and here for room one I'm going to first have our first pram which is going to be the K instead of having to import k from the K Lo loader often times I will just you know pass this around pass this K around here that way I don't have to write this import state but I think uh uh I think both approach could work you could decide to import every every time you need K you just import it from this file but for some reason I find myself doing this and I think uh it uh it's more convenient I guess you don't have to import anything extra all right so I'm going to import the context here and just to test things out let's create our first game object so if you're not familiar with the game what game objects are in Kaboom well it's time to explain this so uh Kaboom allows you to create game objects think think of game objects as entities for your game uh they can be platforms they can be players enemies drones Etc but most importantly uh than not is that a game object is an array of comp components it's made of an array of components those components are all mostly all but you can make your custom components are offered by Kaboom and this is what one of the driving force uh strengths sorry of KaBoom is that it makes creating game objects very easy and it speeds up your game because there's ton of functionality that you get for free so that's why Kaboom J I think would could be like literally called a game engine rather than the library because it offers that that much uh so so to create a game object in Kaboom you can use two things uh two functions uh two methods you can either use the add method or you could use the make method uh the make method creates the game object but does not add it to the scene so it won't be visible while the add method creates the the game object and then display it on the scene as well so here for just testing we want to add to the scene so to the canvas and we're going to use the ad method the ad method takes one peram which is an array of components so components um so for example you can have the text component this is offered by Kaboom you can just pass in some text hello world and then you can have you pass a second component which is the positional component this is also offered by Kaboom and it's where you want to put this on the canvas let's put it at 100 by 100 just to test things out so here we are we have our first game object which is a text basically text based game object so if I go to see the result and uh it's not going to display because we write we wrote this code in room the room scene but we first went to the endro scene so let's change this temporarily to room one so we go immediately to the room one scene so here we can see Hello World in the default font now because we already imported the font in here we can just use glyph mess here so something specific to the text components that can take a second param which is where you define the uh the font with font property glyph mess oops and there's a bunch of other properties like the size the text wrapping Etc but for now let's use one uh one property so now if I go here you can see Hello World written in the font we're going to use for the game so this how we we create a game object so but this is not what we actually want to do for for this project uh what we want is the actual um to actually display the the room level so this is what we're going to do in the next portion of this tutorial we're going to write the logic to display the maps I'm going to spend some time hopefully explaining how til work and how all these layers Etc how to make sense of all of this uh I also recommend just also reading the blog post I wrote which is going to which is a stripdown very simplified version of this just to explain how til work and I think it does a better job than I could do right now but I'm going to try to explain those also okay so now we're going to write the logic to load the map and the way you load a map well before that let's first color the background so uh the background color I usually don't do that in tiled so if you see the map here in tiled it's transparent here the the uttermost layer and that's because it's better to just do uh color the map uh color the background in the game itself so to do that I'm just going to create a small utility so for all logic that is going to be common to both room one and two or just rooms in general if you decide to expand upon the project is to create a room utils JS file here and in that file I'm going to create a function that I'm going to call Export first we're going to export that function I'm going to call it set background color and it's going to take the context the Kaboom context so that we can use Kaboom relative functions and the second param is going to be the hex color code which is going to be the color uh that we want to display so here I'm just going to create use a game object that is going to be a rectangle is going to take the whole width and height of the screen and color it a certain way uh it's better to use that than the set background uh method from Kaboom because the set background method from Kaboom is going to color everything including the rest of the body of the page which mean we won't have the nice uh looking bars here uh in the game by the way the game is responsive I mean the three sizes because we activated the letter box option in case I for got to to explain this sorry but letter box is really so that on any screen size it retain the same aspect ratio so here letter box here all right so now that we have this I'm going to go back here and I'm going to create the rectangle I'm going to use the rectangular component which is just rect specify a width and a height and you can get the height of the current canvas and the width of that canvas by using the height and width uh method so you have the width method uh width width method and height so like that and then I'm going to use the color component which allows us to color a given game object with a single color and I'm going to use the color I think it's an abstract class uh but the from heex method which allows us to color it by specifying a hexadecimal uh value which is used usually it's most used for colors it's the the thing here in aprite for example and uh the reason we need to do this is because by default the color component takes a uh three params which is the RGB values and not an hexadecimal value and now we have this more and then one thing we need to also use is the fixed component this will make sure that the camera uh not the camera this game object in particular is not affect by the camera so that means it will always remain at the same position regardless and this is what we want for the background we don't want the this rectangle to basically not cover the whole world because as we the player moves and the camera moves the part that cover the rectangle covered is not going to be there anymore it's not going to be um uh covered anymore because the camera has moved on from the position of the rectangle by default if you do not specify a positional component what happens is basically that uh the the the game object will be placed at 0 0 in your canvas so that's why I haven't specify a positional component here because it's not really needed all right I save this and I'm going to call that inside this um the room one logic so I'm going to pass in the K here the context and here the hexa decimal value we're going to use is it's going to be a specific value I don't have it uh memorized but it's this one uh oops I should have done this properly so this is the color so now if I go back to the game and there's an issue and the issue is because we forgot to add ajs in room U actually in the import remember because we're not using npm it is required to have the JS here because if we if you don't do that the error to have let me just see if I can zoom in it's going to be uh a blocked because of disallowed MIM type text/html by specifying ajs extension it basically tells uh tells us or tells the browser Etc that this is a JavaScript uh mime type so it will allow it to run now we have the the background all right so we're making progress and that's great okay so now the next thing we're going to need is to load the uh data so I'm going to do this outside of the room logic so I'm going to have a room data uh pram and then back in the um main.js file we created earlier on main.js here is where we're going to need to use a syn we and we're going to have to wrap both these two scenes inside inside of an a sync function because we cannot use top level weight and we cannot need that so I'm going to have an X not export I'm going to Define an async function main I'm going to call it this way main may be a better name but for now let's just call it main uh and I'm going to take those two scene definitions I'm going to put it here and the reason for that is going to be clear very early uh we don't really need to put the inro scene here uh because the reason I'm going to need to use a Sync here is because we want to first load the data from our Json file it contains the map data from til uh so let me just write the logic for that and then after that I'm going to explain how do you actually get the Json file so I explained earlier you can find this in the description but for the actual map like how you draw it Etc I'm just going to do the explanation now so A8 fetch so this is a similar like how you do in web development where you want to request an API but this time you just request a Json immediately so we're going to take this from the maps do uh do/ maps and then the name room one. Json so room one. Json and I'm I'm going to just do this on one line so usually people what they do when you see example how to make a fetch request is they first put this inside of a variable they call it response and then they Jon jsonify it later on but I'm just going to do this in one p swoop so 08 uh Fetch and then that means as long as the fetch call is not resolved we won't move further and this is what we want and that's why I'm using a s we a s weight because as long as we don't haven't uh loaded the data for the room we don't want to display the room data so here we have the Json as well so here we after you have fetched the data it's going to give you a response and then you need to actually convert that to Json so if I go to room uh the actual content of room 1. Json you can see this is the content we have for this project we don't need uh really to dive into the uh tile layers so tile layers are layers where the data is basically the tiles placed uh we don't need that because we don't actually uh need to render those tiles in caboom uh because we can just use the image that we have exported from til but for colliders you have have here uh how it looks like so I'm going to dive into this later on so now that we have this we have the room data we're going to do the exact same thing for Room 2 data and then 08 then 08 again oops then I'm going to fetch Maps slash and then room to. Json and then we do this all right so we have have both of these room data collected now for the room one I'm going to pass in for the room one data so now if I go back to there is one issue though is that we have defined the main function but we actually have to call it so that it fetches the data so the reason I'm actually doing all of this inside of a main function as I explained earlier I cannot use a weight outside of a function in JavaScript I don't think that's possible so that's why I'm doing so I'm calling the main which def collects the data for both rooms and then Define the scenes for both rooms and then we Define the scene for the intro and then we go to the intro but for now I have replaced it with the room one for now just for to make our development easier so I go here and I have an issue seene not found room one okay now that's because it's called before this is resolved because it's an async function okay so maybe I'm going to go back to the intro and then here let's let's actually take some user input so the way you take a user input you can use the Onkey press method in Kaboom and then here you can specify as the first peram the key so here I'm just want the player presses enter I'm just going to um let me just do this like that so when the player presses enter I'm going to call the go to the room one now so now if I look back I have an empty scene because that's normal because that's the intro scene there's nothing by the way we should probably just uh n let's do that later on but for now let's leave it empty with just this uh event handler within the scene so event handlers like these are scoped to the scene so you have to reenable them recall them when you move on to another scene so that's one thing that you have to keep in mind if you make a for example game where you can move in various scenes so every time you load a new scene you have to recall those methods so yeah you can write a reusable function for that okay so we have a Onkey press when the player press enter we go to the room one so let's try it out so here press enter and then everything is loaded Etc everything works so if I refresh and do that really quickly does it actually work all right yeah it works okay nice uh so let's go back to room one uh now that we have the data it's time to print it out so uh actually I'm going to store the room layers first and I think this is a good time to stop writing code and start explaining where do I get all of these so I'm going to go back to til so til is an editor like I explain so let me explain what we have here so we have our room uh with which contains various layers so the layers in Spector is on the top right it's all the layers I have created you create a layer by clicking on this button and then selecting the type there are basically M two major types that I use are the tile layer and the object layer tile layers are for placing tiles so here down below you have tile um a little tile so yeah what I'm going to do is I'm going to explain uh just how the current room setup in work but feel free to please reference to the blog post which gives you a better picture so here um I have okay so I have the title sets here defined so the way you do this is basically when you create a new project new file new map and then you can import the I said this is all covered in in the blog post so here we have multiple layers so by the way this is hidden so tile layers are for placing tiles uh for example I'm going to hide everything and just show you one by one so the first layer I created was the platform layer which contains only the platforms Etc and the various things here now I should have probably created this inside of a props layer instead but sometimes mistakes happen so that's that and then here uh I have the SEC so those are tiles you basically select the tile you want and then you draw make sure to to select of course the the the layer you want to draw and then you can just start drawing like that but this so yeah the second layer I created was the props layer which adds various props and then here you like I said you can select multiple ones like that and you just draw place them so this is the advantage of tile layers is this is how this is what they allow you to do now I have background one which is again a small things and then background two which is basically some buildings Etc same logic here just I used this a second tile set you can load more than one tile set so to add a new tile set you click on here and then you browse and then you click on okay so that's how you do that okay now we are done with the tile layers so layers used to draw things and render things out now the collider the second type of layer is is the object layer and those are used for colliders so the platforms invisible stuff basically it's more efficient to do this than to um have every tile have their own colliders otherwise H it's going to be more performance intensive so just drawing the rectangles here by selecting so when you create a object layer you have a bunch of tools here above and if you just select the rectangle you can trace a a a collider so I'm just going to control Z here and one thing I want to uh also mention is that uh if you go to view you can go to snapping and make sure to have snap to Grid or no snapping depending on the situation so here for example is a collider where which is very small and the SN if the snapping is set to grid it won't allow you to draw a rectangle that is smaller than a tile so that's why sometimes you need to en disable to no snapping or snap to fine Grid or snap to pixels Etc so yeah and one thing is that when you draw a collider you can have so if you click on this uh pink white rectangle thing I don't know how to explain it if you click on that you have to the left side the properties tab which contains a bunch of properties and those are the actual important data the X and Y coordinates of where the collider should be placed and the width the height of it is important and it's data that is imported uh exported to Json and is going to be imported in our game and this is how we know we this is the data we use to draw those colliders in our game and to make them basically uh so by the way once you have your map you need to save as and then you save as to your specific uh to the folder where you want to use those maps and then you just write it a Json extension by default it will give gives you the option to uh save as a TMX but just doing doing it as a Json is fine so here one example of how this properties tab come in handy is that for example here if I click on that there's a dog outside barking so sorry if you hear that in the recording um so here when you click on that you can give a name or a class to any of your colliders and this is useful because I want to give a class of pass through this is a name I have this decided for myself but it's important to be consistent because you're going to use that name in your code to know how to uh what logic needs to be applied to this collider and pass through here is logic that I'm going to apply so that the player can jump through that platform and land on it which is important here and uh yep so we have this is the collider lay colliders layer the positions layer is a bunch of pins you place those pins here and basically those are x and y coordinate they can have a uh I think if I select this they don't have a width and height they just have an X and Y coordinates and they're mostly useful to know where to place things so here for example this is I'm going to place a drone so depending on the situation here when you have multiple pins that are going to spawn multip like the same enemy type I prefer to just use a class and call it drone otherwise if it's only unique thing I can give it a name so basically the only thing that changes is in your code how you access those those properties in your code you can access the name property by just having a DOT name on the object I'm going to show you the code for that later but for the class you just use a DOT type property to have access to the the class so this how it works for example I've placed the boss here uh there's only one boss so I used a name instead of the class and as for the uh yep those drones there the pins and for the health pack also it's a class because it's the same thing repeated over and over again and that's basically it now the cameras is something new to this project I haven't done in the previous project those are colliders that when the player will collide with them they won't cause a collision or anything like that but they will change the camera uh most importantly they usually change the Y position so something you can do in tile is create custom properties you do that by just having for example this one doesn't have custom properties you just right click add a property so here if I go back to the cameras layer so I've put this in a different layer so just to not confuse I'm going to hide the collider layer so here if I have a property I I want a new property I do add property and give it a name and a type and here I used the in type so this is a value so when the the player collides with this camera collider I'm going to take this property and the value for it and then set the camera y position to that value so that's how I can make sure that the camera shows specific things and slides Etc so there's a bunch of them here so for example we drop here the camera will move when you drop here you going to also move or go up Etc depending on the situation so here it's going to go up here it's going to go up so it mostly just affects the Y positioning so only the wi position of the camera so actually yeah so in um in uh if you're not familiar with game development usually when the Y value is high that means we're going up the canvas so we're down yeah I'm confus confused yeah actually the least the no the least the value of y is the higher on the canvas you are that's because the the uh yeah so the the higher the value of y the lower you get on the canvas that's something I've explained in previous tutorials but that's how how it's it is done in game development uh in yeah Graphics Library Etc okay uh now what I want to uh yeah so there's a bunch of colliders here and um yep and finally we have the exit collider exits collider and I think one thing before that for the position the camera collider actually the colliders itself there's this specific boss barrier which is a specific specific colliders so if I go back to the colliders here and this one I have specified a unique Campa X property this time around this is an arbitrary Name by the way I forgot to mention because when you arrive to the boss gate uh barrier I want to move Slide the camera to the x axis not necessarily the y axis as I used to do with other cameras and uh yeah it's a collider because it's going to be an actual collider because the barrier is going to be visible as you fight the boss and you cannot move and that's why I've put it into the colliders layer and that's basically it and then finally so we have position I've explained this and then the exit exits uh layer which is another TI uh object layer and this is just to know um where to spawn the player in the room two so I've named it exit one and I've name it Nam named it sorry exit 2 and uh yep so so when you hit the player is going to hit that I'm going to know that the name of the exit and I'm just going to spawn you either in entrance two or actually this is the spawn point here entrance two spawn point or entrance one so that's how I link those scenes together and here again it's the basically the same layers uh so feel free to explore open those up in tiled because they were just Json file you can just open them up uh and play with them so I'm not going to spend more time on that but I'm just going to explain one thing though so to do the exporting as a single image what you do is you hide every uh object layer uh yeah object layer because you just want the graphics so and you go to export as image and then once you click on export that image you have the the path to it uh to it and then you can you you must check this to only include visible layers and keep all the other things unchecked and then you export and it's going to give you the room one or room 2. PNG uh depending on which one you export here and there so that's an overview of how to use tile so like I said the blog post goes into more details on how to do this from scratch so give it a read all right so now let's look at the export to the Json so the do Json that it was saved so you don't have to click export you just have to save your map as a Json and you can immediately access the various properties so I go to room 1. Json maybe room two is going to be easier to parse because it's smaller so uh if you were to use a tile so every tile layer has the data props so first of all let's collapse everything and let's go get go at it uh one step at a time the most important part here the most important property is the layers property the layers property contains all of our layers and here it is I'm just going to collapse everything so each object here is a layer and Y let me just collapse so we have one 2 3 4 five 6 7 eight layers and this corresponds to what we had entit which is 1 2 3 4 five 6 s eight layers but it's reversed so the first layer here in the the array is going to be the lowest layer because uh the way usually uh Graphics Library works is that the first thing drawn is the the the thing drawn at the lowest level the the lowest layer so if you have a tile layer and not an object layer what you will have is the data property so this data property specify for each uh tile which tile in the Sprite sheet to draw if it's zero it's going to be uh zero so it's going to be the absence of the tile so nothing and here the number it corresponds to the frame in the Sprite sheet but because we aren't drawing the the the tiles in Kaboom but rather just using a PNG that contains everything because somehow it's more performant and I don't know exactly why how K Kaboom implements this and why it's the case uh we don't need to parse this layer at all so any tile layer we have here we can just safely ignore it so we're going to ignore that and yep so the way I'm going to do this in the code later on is I'm just going to check the type here so you have this property called type that is either tile layer or object layer so if we see that we have a type of a tile layer we can just continue in the for Loop so we're going to write some code to iterate through that so the second layer also is a tile layer the third one the fourth one the fifth one is where things get interesting we are now having a object group so the object layer is named in the actual Json file as object group and the difference is that it does not have a data property like with the ti layer it has instead an objects property and it's an array that will contain every object so here every collider with the width the height and the X and Y coordinates however if it's a pin it's just going to contain the X and Y coordinates so Mo mostly for the positions layer it's going to be that and using this information this data we're going to be able to uh draw uh the hitboxes and place the the players positions Etc so here I'm going to con I'm going to put in a constant the layers of our room datas and by just using the layers property accessing that we don't need the rest and then here I'm going to create a game object that is going to act as the parent of everything it's going to be the map game object for the scene and the way I'm going to do that this is by having the add function and placing this at positional 0 0 uh you do not need to do that I think because by default if you don't specify it's going to put it at z0 but just you know if in case you want to move the map elsewhere like the whole map you're just going to modify this value anyway so I'm going to set it to z0 explicitly but feel free to not do that I don't think it's going to cause an issue and here we're going to load the room the image the room one so if you remember when I told you to copy and paste the code from GitHub uh we loaded the images for the room one and Room 2 PNG here and using the room one and room two uh Keys here and then if I go back to room 1js we can just use the Sprite that you have already loaded by using the Sprite component Kaboom so this will work also for all the other things that need Sprites and specify this the Sprite name so here we have an object that is going to act as the parent of all game objects so in Kaboom J you can create game objects that are going to act as children of other game objects so you have here for now this game object the map doesn't have any parent the reason we're doing this by the way is because the positions are relative to where the map starts in the tiled export so in t in the Json file so if you were to just create the game object separately you would have the positions of everything being off that's why I prefer to just use a map uh a parent game object which is represents the whole map and then put everything uh Rel uh relative to that as a child of that game object okay so now we can just continue so then the next thing is to create the colliders um to store in the constant the colliders which is just going to be room layers and then the actual number so in instead of like uh I'm just going to pick the specific layer that corresponds to objects uh and I'm just going to have the dot object so here uh if we go back to the export um I guess room two this is going to be index 4 so I'm just if I just clect everything here so one uh zero 1 2 3 and four zero because we are in an array so the fourth element is going to actually contain the objects for the colliders so the yeah the objects property is basically all the the the colliders uh data so that's why I use this maybe you shouldn't do this uh if you want more flexibility but for this project I don't think it's needed I have specifi I have decided to have eight layers but maybe if you decide to add more or less layers or replace them maybe you want a more flexible system where you just going to check you're going to iterate through the the layers and then check if the name correspond to colliders and then use that so actually we could write I could spend the time writing this logic like that so maybe we should do that actually uh yeah so if I were to do const for layer of uh room layers and then here I'm going to have instead a um a colliders I don't like that I really don't like that so I'm going to do this because you know in JavaScript an array even if you put it cont even if you put this as a const you can modify the content of the array it's not actually constant so if I do let here but I'm going to assume you you know JavaScript uh so here I'm going to have if the layer do name is colliders then I'm going to do colliders and I'm going to use the um um I'm going to put push it the room the layer itself layer dot objects so I'm going to spread it over and then push it all at once I think it's not going to do what I think it's going to do right okay let me just um if I put the spread operator it's just going to create an array within the array actually actually it should sprad it but anyway I'm just going to console. log the result I don't think this will work but yeah so this is something I think is a better coding practice layer. object uh I forgot typo here it's objects so I go here okay we have an array with all the elements in that's great so it works okay it works so here as soon as we do this we're just going to break and then if I make making sure the code actually works yep it works all right nice so this is a better way that means regardless of how you structure your til as long as you have the names right you can find the the layer it's more computationally expensive to do that because you have to do a for and iterate through the the uh the layers uh actually the name of the layers not necessarily every element in the layer but I think it's worth it so here we go and we break here because we don't need to do any more calculations as we go on okay so we have that and then now what we're going to do is actually we're going to write some UT Tails so in the r. UT Tails we're going to write in a if a reusable function the logic to place the colliders in the map so I'm going to call it set map colliders and in that I'm going to need a the constant of course I'm going to need the map Parent Game object and I'm going to need the colliders themselves to know where to place them and uh so here and then the okay so we have everything and then here we go we have the collider so for const collider of colliders and then so T through them so here we're going to have actually there's one thing I forgot to mention is that in our collider layer there's a specific kind of cider that is different from the rest it's the slope here it's not a normal rectangle that has been drawn with this and you won't find this in the blog post because I haven't mentioned it here we need to have a polygon so if I draw a polygon maybe I should U what ah so I need to select colliders so a polygon allows us to you know have slopes like that for example I have a triangle here the difference uh is the following so if I select that polygon we have an X and Y but uh wait a minute there's something missing it should uh does it actually do anything so XY rotation template there is another property for some reason it's not appearing so basically what I want to say is that for polygons it gives you um coordinates there is going to be coordinate a coordinates prop uh for some reason this is not appearing here uh in this part okay Parallax it okay that's strange but okay so I'm just going to delete that so if I go to the oh maybe that's what that was why so I'm going to redraw it here a triangle and then what happens if I do this okay so it doesn't seem to appear on its own in the inspector here but if we go to the title export and look for the slope this is not going to be in room 2. Json it's going to only be in room one so if I go to room 1. Json and I'm going to do a quick search here with contrl f and try to find the um polygon property you see okay so it's a polygon property that gives you an OP object an array of the coordinates of each of the point of that polygon this is a specific thing for those colliders that you draw using the polygon tool so the polygon tool if is this one here so that means in our room utils we're going to have to first iterate through all the colliders but now if the collider has the so if the collider has the polygon property then we're going to first create a coordinate um array and oops and then I'm going to have a for Loop and I'm going to iterate through each of the points of the collider do oops collider do poon so collider polygon which is the property that contains an array of each of the coordinates for each of the points of that polygon and then I'm going to push inside my coordinates array those coordinates but this time around I want to use a vector to so in Kaboom Jaz the way you specify positional components is by if I remember correctly here I I set to Z 0 but another option is to pass in a vector two so you could have done Vector 2 and then 0 0 uh so the the reason this using Vector 2 is useful is that when you want to the set the position after the fact so if you want to do this map and then set the position it's often handier to just do that uh you cannot do other than that or have to do map. pause. X and then a specific value and then map. pause. Y and then specific value so that's a way to make things easier for us later on so that's why I I push them into this coordinat uh array then I just collect 0.1x 01y so here we go and then here I'm going to add them to the map so the way you add child game objects to the main game to a game object is you take the game object and then you use the add function the add method on it so to uh later earlier on we used the add function in Kaboom to create a game object but this but each game object has the add method available to them to add child game objects to them so not only this add method creates a new game object but it it appends it as a child of that map at that parent of that Parent Game object sorry so here specify the position and then here I can just do um okay that was a a bit so in the original source code I just did collider X collider y uh Y which basically defeats the purpose of having created a vector 2 so I'm just going to use a um coordinate uh wait a minute okay that what's the point of it okay maybe I have created this for nothing uh ah okay no never mind never mind this is different because we have the the position of the collider which is defined in the collider properties X and Y but now we also need to have the area component and the so there there's two things to explain here sorry first thing what is the area component so the area component in Kaboom JZ creates a hitbox for your game object by default it takes the shape of your Sprite component or the rectangle component the wct component or any shape you have already specified earlier but if you don't have a shape specified you can specify custom shape by using the shape property passed inside of it and here I'm going to create a new polygon which is a class Constructor in kabz that allows you to create a polygon uh based on a coordinat an array of coordinates and this is where the coordinate constant we have here is useful because we we can just pass it as directly here and actually this is why here it was important to convert this to a vector 2 because this Constructor takes an array of Vector 2 that's why we had to do it as well it's not just because it's handy as well so yep we have this and another thing I'm going to use and this is to increase the performance is I'm going to have set the Collision ignore property which is something that Kaboom offers as well where you pass in an array of tags so each game object can have a tag a tag is basically a way to identify this game object um so the way you define tags is in your arrays of component when you Crea you are creating the game object you can just pass in a string as well and this is going to act as the tag and you can have more than one tag so here I'm going to pass the tag uh the tag collider it's just a name I have decided to identify all game objects that that are created this way uh and in the Collision ignore property in the area component I can pass in that name collider and it will make sure to ignore any collisions uh calculations Etc uh when two collider game objects collide with each other and this is useful for performance because we don't really want to calculate the collisions between this and this or this and this it's kind of useless so and it's going to be more performance intensive for no reason so that's a trick to have more performance and then finally we have the collider type uh here it's important to pass the collider type because if you remember uh not every collider has a type in our uh in our um map here but those uh oops I didn't want to create a new polygon so I'm just going to contrl Z so if I select it with the pink tool here if you select this the class here pass through is going to be referenced you can access this name through the type property I don't understand what why they're different maybe the class uh property is a reserved keyword in JavaScript I don't remember I don't know why exactly they decided to have different names but this is useful because now we can have create a new tag which basically is a string uh specific for the pass through platforms by just passing the type here so if a collider doesn't have a type it's just going to be an EMP empty string and an empty string is just basically not a tag not considered a tag in Kaboom so that's hope I was clear here feel free to ask questions by the way in the comment section if you have any issues and then we continue so the reason we continue continue here is because if it's not a polygon uh collider we we need to write a different logic so here the next case is that if we have a collider and the name of the collider is a boss barrier which is one of the exceptions here what we're going to do is um oops here we go so if the collider name is a quick boss barrier we're going to create the boss barrier but this time around we're going to store the reference to that game object it's still going to be a parent a child of the map game object so one thing is is Handy with the ad function and the make function as well you're going to see later on is that um it gives you reference it returns a reference to that game object when you use that so you can keep it here keep it handy here so here the boss barrier I think I'm going to actually you know what uh for now let's skip that I'm going to do todo and we're going to do that later on and if going to continue if to the next iteration and then the last case uh yeah so all the other case are just normal colliders and we can just add them as a child of the map and specify collider X collider y but for all those normal colliders the shape we're going to Define is just going to be a normal rectangle you can specify this by using the rect Constructor here it's different it's different than the re component re component actually draws the rectangle while the shape the creating a rectangular shape is just going to make the hit box all hit boxes like this can be viewed uh if you press the F1 key and enter debug mode uh well actually enter debug mode by pressing the F1 key so if I do this so so here the for the rectangle Constructor the way you create a rectangle you have to pass three parameters the first one is the position and I'm just going to pass an empty Vector to uh this basically tells that there is no difference from because if you were to specify values here X and Y coordinates it's going to draw the shape uh the hitbox relative to the game object and in certain cases you want that you want the the the hbox to not be uh directly aligned on the same position as the game object but sometimes you don't want that so you just specify a 0 uh Vector two here as the first param and then the second param is the collider width and the collider he here so here we go and uh here we're going to use the body component so the body component is a comp component that can only be used when you have the area component defined so you first need to have the area component defined because you need the headbox and the body components for physics so here we want to have the physics of so by default if you just call k. body the go if you just add the body component it's going to make your game object susceptible to gravity if you specify though inside of it the is static property and set it to true it's going to be a wall uh basically a itic body it won't move when collided with it's going to act basically as a wall an obstacle and here I'm going to also have the collider tag and I forgot to here to add the Collision ignore as well Collision ignore oops collider so I've explained this already and uh we also pass the collider type um as I said for the past two platforms this is going to be useful because for some of them it's going to actually you know what since we have only one slope if we go back to the polygon uh we actually don't need to pass this type here because in case you want to in the future to maybe have passed through platforms that are also slopes like that I I I guess we can just let it be so yep um so yep we have done this and now it's time to call that function in room 1js so in room one uh yeah here we have the colliders not so right below I'm going to call it set map colliders it's going to import it from uh room .js make sure that this is ajs and here okay and then pass in the map so okay for the context and then the colliders we can just pass the colliders uh colliders here we go let's let's test everything out so if I go to the browser hit enter can see the map being fully drawn and the colliders also by pressing the F1 key now for now the the performance isn't very good but you're going to see later on we're going to do a bunch of stuff I think we're going to add a few things that makes it I think the offscreen component actually actually I think the the performance is good it's just it's just my PC where when it's unplugged it it runs at a lower frame rate H yeah and also the fact that when you open up the uh the debug mode it adds a bunch of drawing calls to draw the the layers and that's why the FPS count drops but the actual game performance as you're playing should be 60 FPS so now uh because this is not very inviting to look at because it's too small I'm going to uh do a bunch of camera operations so in kabz can control the camera relatively easily so here H I'm just going to call the cam scale method allows us to zoom the camera I'm going to zoom it four four times I think this is what will look good for the cam position I'm going to put the default position at 170 by 100 those are all arbitrary values I just came up with them by experimenting and then I'm going to set the gravity to being a value of 1,000 uh I don't know what the metric is the unit for that is but U 1,000 is what felt good but for now it shouldn't have any impact because we we don't have any kinematic body or any player or enemies yet so if I go here press enter you can see the map so in the next part of the tutorial we're going to hopefully start working on the player and the logic for that and making the player move Etc all right now that we have the map here displayed uh we could proceed on and work on the rest of the map cameras Etc or we could start and work on the player so I think a good we should actually go and work on the player logic I think that would be the best so we can start implementing movement Etc and since we have the map it's going to be easy to test things out so now what what I'm going to do is I'm going to go to the folder structure and then create in the entities folder a new file this file is going to be called the player. JS and it's going to contain all the logic we need for the player so here we go so here what do we need so I'm just going to collapse this so what do we need is first of all I'm going to create a function and this function I'm going to call it make player so in Kaboom JS uh usually uh there's nothing against objectoriented programming but usually don't use classes well I usually don't don't use classes and if you look at the examples on the dogs Etc usually don't use classes so here the make player is going to act as our Constructor but uh yeah so it's going to uh we're going to use the make function this time around the make method so yep the make method is like the ad method in kaboom but instead of creating a game object and then displaying it on the screen what it does it only creates the game object so later on you can take the game object and then put it inside of an add call to really add it to the scene so here I prefer to use this make function to actually make the game object and then in the room logic in the the actual scene I'm going to make the call to actually put it as a child of the map so here we go so here what are the components we're going to need to make our player so just to Circle back on the reason I object oriented might not be really use but you can actually use it but the reason is that when making a game object you have you can pass in an array of components you can pass a string that will act as a tag but you can also pass an object and is it this object can contain basically your methods for your game object so you don't need to create a class so for example here let F let's first create uh create add sorry our game object our components that we're going to need for this uh player uh character and then as we go on I'm going to add a bunch of methods for the actual Behavior Etc we're going to need dur in inside of that object so first of all the positional component is very important now one thing I forgot to mention is that you need to call this the you need to actually use the positional component even though by default it's going to just put the player at the position 0 0 and that's because if you want to modify the position afterwards it's important to have the positional component used here otherwise it's not going to work now I'm not really sure about that but I think I remembered it that way so maybe try it out and see if you can do without so now I'm going to also use the Sprite component and I'm going to here use the player Sprite this was defined earlier on in the Kaboom loader so if I go here Kaboom loader and to the actually the first load Sprite call here was where we loaded our player so here and uh yeah we just load the Sprite and then later on we're going to pick an an animation and play them okay what do we need else is the hitbox so as I said as I mentioned earlier on hitboxes can be um created it by using the area component by default if you just uh don't do anything uh except just using the area component just calling it you're going to have a default hitbox that takes uh roughly the size of the Sprite but I want more a granular control over that the reason I want more control is because I want to actually the hitbox to be the constant and the same regardless of the various animations and I want to place the hitbox in such a way that the player is going to look good uh in terms of movement Etc so the frames should be well positioned so here I'm going to use the shape property that I've shown earlier on and again call the new and then K and here of course I forgot to pass in the K the Kaboom context here so I'm going to use the react Constructor as I explained here for the first pram we're actually going to offset the hitbox to be at 018 so so this 18 y coordinate relative to the actual position of the game object and here I forgot a comma so maybe here I should probably have this to have it well formatted so shape new k. rect and then as the first peram here now this is a value I've played with um later on when we're going to actually look at the results you're going to see that uh like what what looks good the second Pam is going to be the width and here it's going to be a width of 12 and the height is also going to be of 12 this this way the the actual Sprites I think are 16 or 32 by 32 uh the reason I'm using 12 by 12 here is because it's uh the hit box is going to be small enough so that uh there are still some collisions the player cannot move in weird places but it's it's also small enough so that the player doesn't get hit uh all the time so it's a a generous I guess hitbox to be small okay now I think that's it for this one and we can move on to the next one the next component sorry so the next component we're going to use is the body uh the anchor component so the anchor component it's a new component uh that I haven't explained yet uh this allows you to Center um to determine from where the Sprite the the game object is drawn or centered by default all game objects are are placed or centered from the top left from their top left corner if we don't want that we want actually the center of the game object to be the position we can use the anchor component to specify that you can specific uh Center uh top left top right and you can even pass I think a vector two as well if you want more control I'm not sure about that last one but I think in the the platformer tutorial um the one my 8 hour uh 7 hour almost 8 Hour tutorial uh I think I did something where I control uh actually uh set the anchor to be a specific value I'm not sure though I don't remember that project that much anyway uh once we have this um I'm going to also use the body component this is very important because since this is since this Metro Vania is a 2d side scroller it's basically a platformer so we need to use the body component so that the player is going to be affected by gravity that means that it's going to be like it's going to fall Etc and here we can specify a bunch of other properties so we can specify the mass of our player I'm going to use 100 as the value how I came up with this was just by tweaking and we can also set the jump Force so this is when we're going to implement jumping uh you can set up in kabj as the jump force and here 320 was a value which I thought was powerful full enough uh so that the player can have a nice jump but not too much so that they hit the the ceiling of the levels so here we go and uh also we are also going to add the double jump components so double jump is a component that is provided by kaboon that allows you to easily Implement multiple jumps it's it doesn't have to be double so you could have more than that now here for double jump it's um I usually so I usually set it to one initially so I'm going to set it to one and then as we unlock the we beat the boss it's going to be set to two but the logic for this isn't here yet and actually you know what it's a good time I think to start handling our state setting the the groundwork for that so we want to have Global state to keep track of our players progress and I'm just going to create that in a folder called GL state I'm going to call the file global global State manager. JS and the way the pattern I'm going to use is going to be very simple so here what I'm going to do is simply I'm going to create two things I'm going to create first a constant that is going to be the state props enum and you're going to see why in an instant and the second one is going to be a function and I'm I'm going to call it init State manager and what it does it's going to return uh actually first we Define a state object which is going to contain a bunch of State we want to keep track of for example the player HP by default we want the player HP to be three then the max player HP uh we want it to not exceed three because for this project specifically the health bar in the the Sprite work the assets is basically three and it's not very flexible uh so instead of you know fighting this Etc I'm just gonna make sure the player only has three lives if you were to actually expand upon the game I would recommend just uh making your own UI uh components uh yourself or maybe tweaking those Sprite for example you could uh just take the the outer frame of the UI here you could take the outter frame so for example you would cut out all of this pixel art and have the all of this part transparent and then you would fill it in with color I actually I should have done this with a rectangle that grows in strings so yeah just some ideas you can uh yeah try it and then here I'm going to have it is double jump unlocked and I'm going to set it as false player is in boss fight another and I'm going to also set it as fault uh false and then is boss defeated defeated and then I'm going to set it as false so as you uh make this game grow in complexity you can have a bunch more events here that you want to listen on and state you want to keep track of now I'm going to return here I'm going to return one thing a current method so by the way in JavaScript you can Define functions like this with an object this is a short hand or this which you might be more you might be more familiar with so I prefer to just do that and uh here in this current method we're going to return a copy a readon copy of the state so while the user of that that's so the one who calls the current uh method can modify the object here it will not affect the actual state so for actually setting the state we want to use we want to create a Setter I'm going to call it set here it takes in a property as a string and a value you want to change and then here internally it sets the actual State here uh for the given property property to be the value here oops not value one here you go so here we go and here it's where things could get messy is that since this is a string you could pass in whatever you'd like that's why I created this state props enum where you can actually maybe I'm just going to copy and paste this you just have names like that player HP refers to the player HP string now this is isn't ideal in in terms of like if we were working with typescript we wouldn't have to do something like that but I think it gives us a a much nicer way and less error prone way of setting the state so just to explain if here I want to only unlock the double jump uh for the player who has defeated the well actually if I want to only enable the double jump if the player has the double jump unlocked then what I would do here is I would do state and then uh did I export it sorry I forgot one very important stuff is to have another export where this is the just the function that we call and then we have export const State and then this is what we're going to actually export so we're going to initiate the state manager and then this is the state um that we export so here in the jump I'm going to type state state and then import it here we go and then don't forget to add ajs then once you do that you can do State current which is the method which is going to give us the current state and then you can immediately just have access to the properties here so is the double jump unlocked and if that's the case we're going to use a tary here tary uh condition uh expression because it's it's Compact and if it's the case what we're going to do is simply set the number of jumps to being two otherwise by default the player can only jump once so double jump is a component offered by Kaboom Jaz it allows us to really build this feature out very quickly and that's great uh another component we're going to need is the opacity component uh this allows us to control the opacity of the game object this is going to be useful when we want to make the player blink when they hit the they get damage that that way uh when that happens we can just control the opacity otherwise you cannot control the capacity and then that's a I think that's it uh the last one is the health component so Kaboom offers the health component which allows you to manage Health very U easily and here what I'm going to do is initially you initialize the health component with the the HP for the player and this we're going to pick this up from the state so for example in if in room two the player uh in room one the player takes damage so in room two we want to actually keep track of the the player Health that's why um we we recreate the game object for the player every scene so when we go from from scene one to scene two the the the make player function is going to be recalled and that's why we need actually to keep track of the health so that's why otherwise it will reset to revalue if we were to hardcode it here to three even though uh the player is just exploring another portion of the same world so state. current and then player HP all right and then finally we'll have a player tag this is going to be useful when we want to have on cied events we can just use that tag so that other um entities can just check for that all right so now that we have this done it's time to actually uh fill this object so one thing the reason why uh objectoriented programming in terms of using class es is not that necessary when working with Kaboom J is because you can specify properties within here so here I created the speed property I want my player to move at a speed of 150 I also want the to set the is attacking property to being false so this is a property I created just to keep track of when the player is attacking for example when the player is attacking uh we want to make them uh un not vulnerable so they can't take damage where when the attack animation is running otherwise it would be um I think it it was a better way to go about for this project okay so here is our first meth method it's going to be set position now for this really I don't think this this one this method is really necessary we could just have a position here uh we could could call it initial pause I don't think I ever call this uh ever again except for placing the player so I can just do this like that uh so I'm not going to use that if if there's any issues I hope I will remember to just check here and re add it so okay so the first actual method we're going to use uh create for our player is the set controls set controls is going to be a method that is I always miss mistype and press the P key instead of the brackets which they're near each other so that's why and then it autocompletes with page transitions so um okay so this set control what is going to do is basically set the player controls one thing that's great with this um wait a minute yeah one thing is great with this creating methods within the object is that you can use this uh like in a class and create prop attributes that can be used by other methods so it's basically just objectoriented programming so here this control control I'm going to create a new uh sorry a new property and the way you could do that is just this and then the name of the new properties you want you want to create I'm going to call it control handlers and it's going to be an array that will contain um event listeners uh reference to event listeners for the various controls and the reason I create this is so that I can cancel all of these events event listeners when the player dies otherwise the player could die explode and then continue to move uh while the exploding animation is playing so here is the first call so I'm going to create this control handlers and going to push into it our first event listener that that I'm going to Define within this push call uh this push method I'm going to use the Onkey press event listener like I've shown you earlier and this time around I'm going to use a different form of the qess uh uh event handler from Kaboom instead of having specifying the key here for example enter like I did in the main.js file what I'm going to do is I just pass the arrow function and as the first Pam you can get the key uh by the way this is an arbitrary name the first Pam is going to be the key regardless of what it's named uh just for your information so here key on key press the key here so what I'm going to do I'm going to have an if statement and then if the key is for X let's say we have X and um if from within this. current animation so what what is this from so one thing is that this not only gives you access to the properties you created but gives you access to the whole game object and usually in kabon JS when you create a game object it has access to new methods and uh yeah new methods depending on the components you have used uh by default all game objects that use the that uses the Sprite component have access once they're created to the current animation Uh current anim method now this is Con that's this is going to be called when the game object is going to create so that's why we can actually start using them here so here this current anim allows us to know uh to check what is the current animation so if the current animation is not the jump animation then um wait a minute we want to play actually we can use the other uh method that is available for all uh game object that uses this Sprite component it's going to be the play function allows us to play the play Method sorry that allows us to play uh animations so here I'm going to play the jump animation all right so if you remember the jump animation is what we we defined earlier on in the uh where is it the Kaboom loader. JS so loader load Sprite player and here it is so from frame 51 to 51 so it's basically just one frame and you know what actually I realized this you could just have um set this up like that one frame and instead if it's one frame you don't need to um have all this you can just have one like that all right so let's do this if if the player I press the X the X key we first check if the current animation is the jump animation if it's the case if it's not the case we play the jump animation uh that's important because if the player press more than once the X key we don't want to cancel it but it doesn't really matter in this case because the animation is one frame so even if you spam again uh it won't matter because the the same frame will play however this would have been useful if the jump animation has more than one frame so I'm going to keep it in in case you want to modify the jump animation to have more than one frame and then finally we just call the double jump component and this is going to take care of either allow uh making the jump for the player so if the player is allowed to do more than one jump they're going to be able to do and it's the double jump component that takes care of that uh if you're new to Kaboom by default you also have the jump component so this jump component is unlimited so don't use it uh if you want to uh use this double jump mechanic uh uh one thing if if you use the jump animation uh the jump method what you need to do is check if the player is grounded so there is the is grounded method on every game object that uses the body component and by checking you can actually allow then the call for this to jump uh just for your information you can look at previous tutorials usually by default you implement the jump mechanic using the jump component but this is a special case where we actually want to allow more than one jump as part of the ability that the player unlocks after beating a boss here you could have decided to have a switch case statement but since we only have two cases I'm going to just go with one uh if statement so the next key is going to be the Zed key now depending on if you're in European keyboard uh The Zed and X key might not be the same in the same place as the quy layout so in that case uh either in Kaboom Jaz you cannot have the uh keyboard layout independent Keys you cannot set that on the on key press so as a as a workaround uh to this what I would recommend is maybe um allow the player to remap the keys in in a settings menu that that you can do all right so if the Z key is pressed and here we can also check so the reason this is in another if statement instead of being on the same one is that we want to allow the double jump if possible even if the animation was already playing but for this case if the Z key is pressed and the current animation is not on attack current anim is not the attack only then we will allow the attack to go uh otherwise yeah because the attack is already in motion if not the case and we also want to check that the the player is grounded so this is something that is particular so might it might sound strange why would the only be available on the ground well the reason for that is that the assets the asset pack doesn't have animations for jumping attacks and I didn't feel like adding an animation so uh just for the gameplay not to be weird uh the animation not to be weird I just decided you know you can this robot robot character that we play can only attack when they're grounded so what happens when an actual attack is fired so here is the logic uh we're going to you need to write this logic here so so first of all we're going to set the is attacking property to being true during the attack we are also going to create a new game object this this time around this game object is not going to be apparent of the map the reason for that is that um actually thinking about it it's not necessary um yeah I should have probably never mind never mind this game object is going to be a a CH a child of the game object the player which is a child of the parent so never mind we use the ad function the ad method to create a new game object it's going to be the hitbox for the sword attack so the way we're going to implement this is that when the player attacks we create an invisible hitbox that is uh that if the enemy it collides with it then we register an attack uh and we deal damage to the enemy so here I'm going to set the position of that game object to be this first flip. X I'm going to explain this line of going in an instant uh let me just or write it out so here we go so what does this do why why I'm doing this so flip X is a property that is available on all game objects that uses the Sprite component what it allows you to do is to flip like a mirror the the sprit is the sprit and the Sprite and uh that what that means is that uh instead of having a left facing Sprite and a right facing Sprite you can just get away with one and then just flip it around so if the flip animation so if the Sprite is facing left uh or yeah because by default the Sprite is facing right if you look at the images so if by Def if the the flip X attribute property is true that means the player is now facing left that means we need to move the hitbox to be to the left and that's why I have this Turner operation that does this it will subtract minus 25 to the current position of of the of the hitbox which is by default since it's a child of the player it's going to its position is going to be relative to the player so minus 25 is relative to the player H otherwise it's going to be zero and 10 so 0 10 is what looked good so the the hitbox is going to be drawn from remember the top left corner every game object by default is drawn by the top left corner it's only when you specify with an anchor component uh Center Etc that you can Center that instead of being drawn from the top left but for this uh the attack hit boox we don't need that all right then the second game object is going to be the area component so the area component is going to have a specific shape so here again it's the hitbox uh I'm going to use the rectangle it's the simplest shape here we don't need an offset for the position and we're going to make our uh sword hit Box 25 by 10 this is what looked good relative to the animation and then finally we're going to also have a tag so the tag is going to be not here outside here sword hitbox which is going to be used to create event listeners that listens on collisions with this particular tag all right we have this and then of course we need to play the attack animation again defined in the Kaboom loader that we did earlier on and then here we're going to have a on anim on anim end which is a event listener offered method offered by Kaboom for every game object I probably used a Sprite component and what it takes is the it gives you actually the animation name and if and then you can write some logic if the animation was the attack then you could we can first get the sword hitbox sword hitbox the way you can get a game object by its taging is by using the get function uh method function actually this is a function from kabo and we pass in the tag and since this sword hitbox is a child of another game object that means we're going to have to use recursive recursive true and the get meth function gets all game objects with this tag that means if there's more than one it's going to get and return an array so because it always returns an array even if there's only one I'm going to just pick the first element there's only any way going to be one uh sword hitbox created at a time so if the sword hitbox we first get a reference to it because we don't have access to this actually you could have decided to create another property within the uh here within but uh since we destroy that game object it's better to just you know use the get function get the the current sword hit box that exists and then destroy it so here we do this and then if only if the swords the sword hitbox actually exists because sometimes uh the sword hitbox might already be destroyed before a new one is created if the player hits the attack key again so in that time sword hitbox will be undefined so that's why we need to guard this with an if statement otherwise it's going to fail so here I need to and then only if sorry only if the sword hit hitbox exists then we can call the destroy function offered by Kaboom to destroy game object and we pass the reference to that game object and that's it and one thing we want to do is set the is attacking attribute now to being false since the attack is finished and uh we want to play the idol animation Back by default the idol animation always plays uh all the time when the player isn't doing anything so even after an attack we set it back to Idol only and then when the player decides to move or do something else then we will play other animations so this is our first control Handler uh and let's do our second one our second one is going to be again I'm going to call I'm going to push it to the array in much the same way this time around what I'm going to to do is um do a key on key down instead of Onkey press Onkey down and Y Onkey down and then again pass the key here and now here if the key is either left uh if the key is left so if it's the left key is is down and the player is not attacking this again it makes no sense uh gameplay wise it might be strange a strange gameplay decision design decision but as I said because I do not have the animations for the left and right attack As you move and it just looks weird because the the player is basically standing still and attacking so that's why I made sure that uh you can only attack when you don't press any other Keys except the attack button so if key equal equal left and uh this is attacking what we're going to do is we're going to have another if statement if this. current animation so this again is the animation guarding logic so if the anim the current anim is not the Run animation and we also need to make sure that the player is grounded before we play any Running Animation because uh otherwi running while in air is kind of going to look weird so because of that we need to use the is grounded again is grounded is a method offered by Kaboom for all the game objects that have the body component uh okay so we have that and uh if that's the case we can do this play and then actually play The Run animation so we have all the conditions to play The Run animations but we again this is an if statement within an if statement because we can conceive of a case where we want the player to still move even though we don't want to reset the Run animation because it's already playing so here we go and I'm going to make sure that you need to make sure actually that the flip x value is is false because the way that flip X works is that if you set it to True your player is going to be mirrored all the time unless you actually set it back to false and because the by default it seems here that the the the player is actually facing left by default and not right No actually that's that's contrary it's facing right so this should be true we want to always make sure that the flip x value is true so that the player is flipped when they press the left key and in the other F statement where it's going to be the exact same logic but for the right key we're going to make sure that the flip X is always true always is false set to false so that the player will return back to their original orientation I guess and then finally for moving the character we can just call the move function method again this move method is offered by all backa Boom for all game objects that have the body component and here the move uh method takes two prams the first one is the speed in the x axis and the second one is the speed in the y axis you want to go for because we want to only move left and right we're only going to do a negative speed value and then zero for the y coordinate so here we have the speed here defined here so we can only only need to modify the speed in one place and negative because we want to go left so the value of the the speed should be negative all right we have that and we can return early we don't need to go further down and the rest of the logic is the same thing but for the right uh Direction so here's the same thing you don't actually need the return statement only if you were to want to have uh some extra logic here but I'm going to keep it just for yeah consistency so here it is uh the second one just copy the code it's the same logic just two values you could um maybe have reusable block here um yeah you could have some reusable logic but it didn't didn't feel worth it so now that we have this I'm going to save and then I'm going to have the last uh control Handler so this control Anders and then push this time around is for when the player releases a key so to do that we're going to do on key release and then we don't need to actually check which key is released we want to run this Logic for any keys that is released so if this current animation okay this is going to be uh really tedious to write that's kind of necessary so I'm just going to paste it here and go over it so this is the logic so we want to make sure as long uh when the a key is released any key if the player is not idle uh if the current animation is not idle the current animation is not jump the current animation do not fall and the current animation is not attack if if any of those animation are not currently playing then we go back to the idol animation and I think that's it now let's go back to the um uh yeah let's go back to the main.js file uh actually no to the room one. JS and let's create our player here just so we can see something on the screen so what I'm going to do okay I see why I created the set position let's create our method here to set the position it's actually going to be used so set position X and Y value and then ah put page transition and then here so this position do X we set the x new X position this position doy we set a new position all right uh here we're going to remove the initial position here as well does not need it and here we go all right in room one what we're going to do is right after setting the map colliders I'm going to actually Define the player here and add it to the scene but without specifying a um a position so here I'm just going to call actually you don't need that you just call the make player function from within pass in K like that so when you use the make function you only need to call the add method on top and we actually actually need to add this as part of the map so now that we have a player created let's write the logic for the positions so in much the same way here I'm going to create another const I'm going to call it positions and it's going to be an empty array and then here instead of breaking I'm going to have a continue and I will have a second or first if statement that checks the layer name for position positions and if that's the case then we going to push to the positions array push um yeah going to push the layer dot dot dot we're going to spread the objects here so the spread operator uh look it up it allows us to take an array and then spread it back into another array without like having an area in an array so you take the element of one array and you put that into the second array uh rather than putting the the first array inside of the second so it's it's the basically instead of having this you'll have this and then every element one two so imagine three and then one two three so if you were to not use the spread operator like this three dot this is what you would get but because you use the spread operator it takes the elements of the first array and puts it inside of the second hope this was a clear explanation in case you're not familiar with this uh syntax okay so positions push there objects okay and then we should have all of our objects uh so I'm going to continue here as well so here for now this is not necessary okay so now what I'm going to do is for const position of positions and then here if the position for now let's do it simple if the position is of the player U position. name is the players is how we detect the player pin so this one if you remember uh here we go so here it's named player so by checking for the name so if it's the player name what are we're going to do is we're going to have the set position call to the set position method and we're going to take the data from this positional pin and set it as the position for our player now we also going to set the controls by calling the set controls method and for now that's it so if I look at the result let's see what we get presenter and we have our player and our player can move can it jump it can jump but this time yeah you see the animations aren't resetting properly because we didn't have we didn't have a we didn't add yet the handlers the the um not the handlers the events uh we going to see in a moment what I mean by that so one thing also if I press F1 you can see the headbox how it is positioned Etc and when I use the sword you can see how the hitbox change direction all right now that we have this I'm going to go back to the player set the events so the events are things it's a new a new feature that I've discovered in cunas it's not actually new it was probably there but it's new uh to me so uh okay be before doing that yeah okay so set events this is the method I'm going to call and within this we're going to set a bunch of events uh so onfall is an event offered by Kaboom it checks for when the player Falls after jumping and and this is where we're going to just play the fall animation when that happens so the onfall is something offered by kabo this on fall off though is another event offered by Kaboom but this time around uh those events are all specific to the game object so it's not a Global Effect uh event onfall off the different is that it's for when the player falls off a platform that means there there was no jumping before that here again we need to play the fall animation now we also have this on ground which is another event offered by Kaboom and when the player is in on the ground we want to play the idol animation and then finally when actually it's not finally there's there's a bunch of others but for now uh there is this the onhe head headbut on headbut event which is when the player hits his head on a platform or uh when the player hits um an obstacle with its head so for example when the player jumps and hits the ceiling of a level then we can this event will fire and here we're going to play the file fall animation so now let's just test this out so I'm going to go back to Mains I'm going to actually room one. and here I'm going to set those up so player. set events and now if I go and check the result hit enter if I you see the animation are now perfectly correct and then if I hit so this is a oops we don't don't have the camera system working yet but here is the natural progression we go if you hit headbutt immediately the fall animation will play and that's that we we have a bunch of other controls and that looks good uh now we want to make sure that the player can pass through uh these platforms so we're going to create another method I'm going to call it um what's the name I'm going to use it's going to be enable pass through so maybe where should I put it um okay let's put it right here so enable enable pass through through and here we go and here how to do this feature is there is something in Kaboom a method called the on before physics resolve what it does it gives us the Collision that happens as the first param here and then you can check for that Collision so if this Collision uh is a specific Target so if the Collision is is with pass through which was the tag you remember we had for those specific uh platforms where we want them to pass through uh that we set up in tiled and then add it to when we create the game object in in the set colliders uh method function and then here we make sure that the player is jumping as well and this again is a method offered by Kaboom to know when the player is jumping so and then if those two conditions are met so that the Collision is supposed to be with a pass through is happening with a pass through and the player was jumping we want to prevent the resolution of the Collision that means we don't want the Collision to actually take effect so that's why we call the Collision do prevent resolution okay so once you call that uh I think that's it the the feature is implemented for more details I have a blog post regarding this uh so go to my substack for that so if I go here to room one and call the player do um set pass through through method uh uh enable pass through not set pass through actually enable is a better name but set that would have worked as well so if I do this press enter and then let's try it out even though the camera doesn't work you can see I can pass through the platform and even here as well but uh here I cannot jump enough anyway so so here we go but when you're going to be able to double jump you should be able to pass through that platform as well all right um we have everything we need for our basic player moov there is a bunch of logic when it comes to dealing and taking damage that we're going to write later on now okay let's do the camera system so uh for the camera system what I'm going to do is we're going to have to go back to our room 1js and the same thing with what that we did for the colliders and positions we're also going to need that uh but this time around uh yeah we also going to need to get the um the colliders for the cameras uh the way I did it in my uh yeah that's strange um okay it's going to be a bit different um so let's go to room. utils and write the utility for that because it's going to be used for both the um room one and room two so here I'm going to create export a function this uh always make this mistake function set um set camera controls and then here we're going to pass in first player first Decay the for for accessing all the Kaboom functions the player the map and the actual room data and then here we're going to need first of all actually never mind this is not the this this function is going to to be useful and it's going to be mostly used to control the camera so I'm not going to write the body of it right now what I'm going to do though is right below I'm going to write the function for the camera zones so the camera colliders I just call them camera zones and we need to just have three params which is like we did with the colliders it's it's basically the same thing so we're going to have three param the first one is the kabo context the second one is the map object and the third one is going to be the cameras in much the same way that we did for the colliders so let's assume that we have all those three for this for the time being and then we will um uh write the logic for that in room in the room one. so we have a for Loop and then we have we're going to get the camera of cameras which is our colliders our data for those colliders that we had entitled and then here for the cameras for each of those camera colliders uh data we have entitled we're going to create a camera zone game object that game object is going to of course be added as a child of the map and we're going to have basically the same exact way we did for the um collider so I'm just going to copy and paste the code here and explain over it so an area component which is a rectangle with the width and the height and collision ignore being the collide with the colliders since the camera really don't have inter in collision with themselves we don't need to add a tag for cameras um okay so now the reason I created this and stored it in a camera Zone constant is to have our set our first event listener which is going to be our camera on Collide so when so I'm just going to copy and explain here so on Collide is a method available all game objects that have the area component so here here how it actually works so you have the your first game object you have its meth method the on Collide and you can pass in a tag as the first param which is what tag you want uh what game object with the following tag you want to listen on uh when when when regarding collisions in regards to collisions sorry and the second param is the function that is going to fire when that event happens so here when the player collides with the camera Zone we're going to run this logic this logic is simple we get the current camera position by using the campuse method uh function offered by Kaboom uh which returns in Vector 2 that means we can have access to X and Y properties for the camera position so we make sure that if the uh the X position of the camera is not equal to camera properties zero. value so okay so what this what is this so this is if I go to the export uh okay so the room one. Json maybe room two so let's go to room two because it's smaller and easier to uh detect parse because of its smaller nature so here in not positions but in we have positions okay in cameras you see here the custom property that I created called cause Y is is added to a new properties tab here with the this array and in that array for each new property you add it adds a new object with the name the type and the value since we only have one uh new attributes and I don't really need to check for the name of it I just decided to uh access the first element and access directly the value without having to check for the name in case you want to expand this game further and want to use more proper custom properties make sure to check the name first before accessing the value okay so here I go and then details so we get the value which is going to be the actual new camera position if you remember here uh when I click on the camera Zone uh campas Y is the custom property with a value that value uh is basically the the value we want for the camera and here we're going to use a tween so a tween is a way for gradually changing the value of something uh using a function a mathematical function easing function here we using a linear easing function so the tween in kabon JZ takes a uh 1 two 3 four five pams the first Pam is the uh the original position but actually no not just that the reference to modify the value so the the original value but a reference to uh the game object um or the thing controlling that original value um actually never mind that's not true it's here we do the modification so the first Pam is the initial value the second Pam is the final value you want and the third Pam is on in how much time you want the trans the in how much time you want the transition to happen so here I want to the transition to happen 0.8 seconds from this initial value to this final value and the fourth param is the function that will replace the uh the gradually to the new value so here Val is called multiple times as uh following this function's pattern the linear function and for each call it has an intermediate value between this and this that progressively gets closer to the final value and here uh in Kaboom to modify the camera position you can also call the Campa meth function and then pass in as the first param the x coordinate and the ycoordinate since we only want to modify the Y value of our uh camera we will simply put back the same uh x value X position for the camera and just tweak the the just set the new uh y position instead by using this so value here this is an arbitrary name you could have decided to name it however you'd like and then finally k.s. linear are the various easing functions you have access to if you look at the documentation you can have sign sign in sign out Etc linear is just the one I decided to use here uh it's the one looked good to me all right we have this and let's go to room one and here again we're going to do the exact same logic we did so const cameras and then empty array and then here we can either do it like that if layer. name equal equal cameras what you're going to do is or maybe you should do this on top it doesn't really matter that much in the end so if the layer. name is the cameras what are we going to do is we're going to push to the cameras array and spread from within layer. objects which is again going to give us the collider the the collider data for the cameras and then here uh now for the actual usage where did I use this I'm just going to make a call to set camera zones uh maybe right after this doesn't doesn't really matter so I'm going to do this here actually it probably is better to call this here so set camera zones from here K dot map do uh cameras here we go okay let's look at the results press enter now if I do this the camera slides downward if I drop down again it follows everywhere maybe not the left hand side because we only control the Y position we need to actually write the logic for the exposition so the exposition we just want the camera to follow the player and that's the role of the first utility function that I was about to rout uh right is called set camera controls uh so here what we do the reason we need also the room data because there is specific data that is allowed going to allow us to bound the camera to certain limits so here in room. utils let me just check it out okay so how we're going to do this is we're going to use a onupdate method Kaboom method so on update is called every 60 frames it's where you can write more granular stuff so here if the state. current and then player in boss fight then we return early why why we do this because when we're going to have the actual boss fight we want to um make sure that uh the camera isn't controlled is fixed basically uh to only the room the boss battle room here I'm just going to import the state from the global manager so player in boss fight I think that was this date uh let me let me look is boss defeated player in boss fight yep and here player is in boss fight I made a typo error later on so fix that in State Global manager Global State manager so here if state. current if players in boss fight we just won't run the the logic uh the what comes next because we don't want actually the camera to follow the player and then the next stuff that comes right after I'm going to copy and paste it is if the map position X is um plus 160 is inferior is superior to the player position then I'm going to clamp the camera position to be stuck at this value this is so that when the player cannot go too much to the left uh the camera cannot go too much to the left to the point that we can see outside of the the bomb the bounds of the map and then finally the last um yeah the last if statement here we need is this so if the player position. X is superior to the map position. X plus the room data. width this is the actual width of the the whole map multiply by the room data. tile width which is supposed to be like 32 or 16 minus a certain value this is what I looked good then we're going to prevent we're going to clamp the the camera but to the uh to the left uh to the right so it won't go past a certain point to the right and that way we will never allow the player to see outside the bounds of the map and otherwise if those conditions are not met so we just make sure that the the camera just follows the player uh from the x axis but the Y AIS is remains intact so that's why I only modify the x x coordinate and not the Y so the Y for the Y we just take the current camera position all right let's check the result for that so here we go if I move to uh maybe I should drop down and then okay I forgot to actually call the function so set camera controls needs to be called and where we're going to call it is in room. one. JS maybe right after here okay but this is an issue because the player isn't yet added to the Z team so we need to First wait for the player to be declared and then do this so now if I look at the result press enter set camera is not defined I forgot to import it here set camera controls now everything should work so let's look at the result press enter and now the camera follows us that's nice so if I drop down it also follows follows us on the Y AIS so here is we cannot go past this point we will never see the bounds the outer bounds of the C of the the map and then even if I go here everything works all right so yep uh we have the camera now done and H this is not done I fall so that's something we need to fix uh why let me check let me debug why why is this an issue if I go here we have a collider we have a collider but not no body component so we need to go back to vs code where we defined the in room. UTS the set map colliders if it's yep here we forgot to add for the polygon colliders the body component with is stat property because at the end of the day it's a wall type it's an obstacle so now if I look back at the result press enter and it should hopefully work so here I drop down and yep it works all right we have the camera system up and running that's great we can pass through those platforms as well let me see if I can go back here so now what is is left is to do the uh start implementing the enemies after the enemies the boss fight and after the boss fight the linking with the other scene so for now if I go here there's nothing that happens and I I'm out of bounce so now it's time to work on the drones so it's an enemy type that will follow the player and explode when entering in contact with the player so in the entities folder I'm going to create a new folder I'm going to call it enemy drone. JS here we're going to follow the exact same pattern I did for the player which is create a function that is going to act as a Constructor I'm going to call it make drone here I'm going to you as the first param set the K the context and then as a second param I'm going to have an initial position because here we're just going to create the Drone and set the position immediately um then here we're going to return a make uh call which is going to create the the game object but not but not add it to the scene and then here we're going to have a bunch of components so the the positional component is important here with initial pause uh we're going to need to have a Sprite component the Sprite component is going to be the Drone Sprite with the anim flying this was defined in the Kaboom loader function by the way uh kaboon loader file sorry and then next we're going to need to to have to set the hbox so the area component is going to be used here we're going to have a shape with a new k. rectangle and then k. Vector 2 we don't need an offset really 12 by 12 would be a good H box the anchor is going to be centered this time around as I did with I think we did the same thing for the player I don't remember and then here for the body here things are going to be different we're going to set the gravity scale so gravity scale is another property you can set uh within the body component and I'm going to set it to zero so basically we want our drone to have basically not be affected by gravity at all so it's going to be floating around I'm also going to use a a new component that I haven't explained yet called the offscreen component and set the distance to 400 so this what it does is that when uh the charact uh the sorry when the Drone is going to be off screen so that means as the camera is crawling and the player is moving around uh let's say we have a drone that was following the player and then the player was able to get away basically and what we want to do is that if the distance between the uh the camera the screen and the player uh the Drone is at at four 400 uh units I guess pixels whatever then we're going to respawn we're going to not respawn but reposition the Drone to its original position so here we just using the offscreen component then later on I think we're going to use some of the meth event listeners that comes with it so when you use the component you have access to a bunch of methods that you can use later on so not right now and then here we're going to play around with a state machine which is basically what we're going to use to uh code the AI so I'm going to explain what a state machine is in an instant but for now let me just teach you how to use the state component so the state component starts with a first state States here are just arbitrary names that you decide for yourself I decided to create one two three four five states here and I'm going to paste them has to not waste too much time so here are all the states I have decided to create and the you need to specify a default State and that default state must be one of the states you have decided to uh create here and the default state I'm going to pick is going to be the patrol right so what what is what is a state machine so a state machine is a way for you to code an AI uh so if I open up the excal draw and try to do a schematic so we have imagine you have a bunch of nodes and then for each of those nodes you have there are states Associated so Patrol Patrol right okay that's too big uh maybe um okay zooming out so I'm going to just here so we have our first state patrol right we have I'm going to just copy that around Patrol uh Patrol Patrol left yeah that's kind of strange why it's behaving this way Patrol okay that's that's strange okay my point here is that by having those names you're able to Define behaviors okay so here let's try to explain without the diagram so those are names that are arbitrary and for each of those names we're going to define a couple of events that happens when the entity the game object will enter or be in those States so here I have decided to name Patrol right Patrol left alert attack and Retreat and for each of those state that I've decided to name I'm going to write logic that is specific to them so when the the Drone enters a specific State a specific logic is going to run while they enter in the state while they're in the state and when they get out of the state depending on the state we want uh depending on the state we're going to do different things so let's just add the health component I'm not going to re explain here but basically setting the health one point one Health Point for actually we set did we set the health for the player um did I do that yeah we did okay so just I'm going to just set the health to be one and then add a tag to be of drone and then here is going to do the AI coding the state Etc so I'm going to you're going to understand this more in a in a moment okay so here are a few properties I want to Define so I'm I'm going to have a speed of 100 a Pursuit speed of 150 so this speed is going to be the one used when the player is is uh when the Drone is following the player the range is going to be 100 that's the range in which play the Drone is going to start is patrolling and is going to start following the player if they detect the player and then here I'm going to create a method called set behavior and it's where we're going to define the logic related to uh the state machine the state uh yeah the state machine so the first thing I want to do is I want to get the player because I'm going to have to to do a bunch of things compare the distance between the Drone and the player and one way to do that is just to have a constant called player and then use the get function to get the player by uh using the tag and as I explained earlier since the player is going to be added or is already added as a child of the map object we need to use recursive and true property and so for it to work and then here I'm going to set the we only want the first first element there is only one player by default get always gives you back an array okay this is where things get interesting since we used the state component we have access to a bunch of methods called the on state enter method it's an event uh listener that you pass in as the first par the name of the state you want to Define an event for here Patrol right and then the second param is going to be the logic that is going to run when the drone will enter this this state so here what I want to do I'm going to use an ASN weight here because what I want to do is I want to await and then call the weight function in kaboo so here what what it does the weight function basically Will Wait 3 seconds before uh running before running what comes next that's that's due to the await so await you have to wait for it before you can continue on uh I'm I'm not going to dive deeper into the async weight uh I have done so in previous tutorial so maybe reference that I might write a post on this but the reason we're using a waight here is specifically so that we wait those 3 seconds before running any other logic that comes after here within that function then we're going to have a check so if this do state is how you access the current state if if that that state is Patrol right what I'm going to do I'm going to call the enter State method again provided back aoom if you use the state component and I want to enter enter the patrol left State now this might sound strange you're already in the patrol right State why would you check that well actually you don't know because what comes after is another event listener and this one is called on state update and it runs every frame uh every 60 frames every frame 60 frames per second yeah every yeah I think every frame all right so here we have the onate update uh Patrol right so what is this it allows us to create an event listener on a specific State while that will fire the second param which is a function that is going to run all the time during the the time that the Drone is within that state so here while we are so imagine this is while we are on in the patrol right state run this logic and run it will run it every frame so here what we're going to do is to have an if statement that will check this position distance so this is a method provided by Kaboom for Vector 2 components it calculates allows us to calculate the distance between one positional one vector to with another so here player. is the position of the player and is accessible because we imported the player here and then if that distance is inferior to this do range that means we are within the range of the Drone and this time the the we want the the Drone to enter into the Alert state Alert state and then we return early otherwise we want the this. flip X to be false that means we want the make sure that the patrol the Drone is is facing right and then we want to make the Drone move at a normal speed so now I hope this makes a little bit more clear what we why we do the if statement here because when we enter the state this is this runs once and while we wait three seconds seconds here this is still this is running multiple times because it runs every frame so the the situation can change the state can change within this before we arrive to this line of code so I hope you understand that so just to repeat here it runs once when the Drone enters the state because it's the default State this is also going to run once without having to call an enter state by default and then here it's going to wait 3 seconds before moving on to this line however while we do that this state update is running multi every frame so in that time during it runs every frame the Drone is moving as long as the player is not within the range as soon as the player is within the range we enter a new state we enter the Alert state that means by the time that after the 3 seconds elapse we arrive here this state could potentially no longer be uh Patrol right now we're going to do the same thing but for patrol left so I'm just going to copy and paste and and do a mention a few things so here we have Patrol left same logic but instead of Patrol left here the right it's left and here it's left and the right and then here the the only difference here is that we want to flip because by default the Sprite for the Drone is facing right so we want to flip it to for it to face left and we move to the left by adding a negative sign to the speed so now it's time to define the logic for the Alert state so on state when we enter this Alert state we want to run the following logic we want to wait one second before initiating a Pursuit of the player once we have waited we want to check if the distance between the Drone and the player is still inferior to the range if that's the case we can enter the we're going to enter the attack state so attack is basically following the player you you could have named it suit instead so attack State and then we return early otherwise we're going to enter the patrol right again and reinitiate the loop of patrolling normally left right left right left right so just to diagram this imagine you have patol right here hope this works now we have have Patrol left what's the isue okay okay for some reason okay now it works so we have Patrol right Patrol left and then we have alert so here's the Alert state alert and then we have have the attack state so maybe better I put it here attack oops all right so let's diagram this out so initially we have the patrolling so patrolling is basically going from Patrol right to patrol left and from Patrol left to patrol right however sometimes if the player is too close we go into the Alert state so while patrolling right or patrolling left if the distance of the player is the the distance is the distance if is if the Drone is close enough to the player then the the Drone will enter the Alert state and then after one second if it's still the case the Drone will attack so hope that that illustrates the situation so we have that and then for the attack State we're not going to need to Define an on state enter but we only need to define the on state update for it because we just want the action to immediately go uh the movement the the following of the player so here if the player this position distance and then player position if that is superior to the range that means as soon as the player is able to get away is getting far enough away from the Drone we will enter back to the Alert state and then from the Alert state the after one second if it's still the case where the player is far enough it's going to go back to the patrol right State and then return early here now on the other hand if this. enter so if it's not the case uh wait a minute uh no never mind so we return early yes but now it's time to follow the player to attack him so this flip X is going to depend on the where the player is so we can just have this a Boolean expression where we check whenever or not the player position is inferior to the the position of the Drone if that's the case then it's going to to be true and if it's true that means the the player is to the left so that means the Drone should also be facing left same logic for the right so if it's false that means the player is to the right of the Drone and that means the Drone should be facing right and then here I'm going to use the move to method offered by Kaboom on body on objects that have the body component and you can specify destination so here I'm going to specify Vector 2 I want the player positionx but for the player positiony it's going to be+ 12 just to have a little bit of a gap and then I'm just I'm going to explain everything let me just finish typing and I'll explain things so Pursuit speed okay what happens here so move to is the function from Kaboom it takes two pams the first param is the destination the second param is at what speed you want the Drone to move to towards here uh instead of just taking the exact same position having a bit of an offset make sure that the the the the player the Drone will actually um how do I say will uh we'll try to collide into the to go outside of the player so um it's a bit hard to explain let me make a drawing so by having the target here so imagine this is a Target and this is the player by having the drone target this we we we are making sure that basically if the Drone arrives to the player it's going to collide with the player however however if we were to just have the exact same position here so depending on the situation the Drone could stop just right here and remain here so the Collision would uh would never end that that would be the thing because you have un Collide and then the Collision would never end well what actually never mind it's not the Collision would never end basically um I think that's this the reason I did it initially but thinking about it again uh maybe it doesn't make any sense so so you know what instead of trying to to justify it let's just remove it for now and then we'll see we'll re readit back when we see if uh if it causes any issues all right so we have this and then we have the attack State everything and then that's it that's basically that's the the AI logic now we also need to set the events for it so I'm going to create another method called set events by the way set events Etc and set Behavior are just methods that I created uh in which we use a bunch of methods offered by kabo so for set events I'm also going to have a reference to the player so we're going to have the exact same logic recursive true remember that because the player is a child game object of the map and then here we're going to have the this. on Collide which is an event listener provided by Kaboom when we collide with a player we want a few things so whoops not that if uh if the player is attacking uh that mean we want to return early we don't want to destroy the player that means it we want this un vulnerability to the player if however that's not the case then we first hurt ourselves the Drone because the Drone selfdestructs and it has only one life so using the heart method which is provided by Kaboom if you use the health component and then here we're going to have a new feature in Kaboom called um well actually we can never mind it's not a new feature here for the player we can also call the heart function and reduce the Life by One why we do this uh how we can do this because remember remember the player also uses the health component that means it comes with methods to manage health so here by calling hurt it's a nice and easy way for you to deduct uh life uh from the player now here on anim and again another event listener provided by Kaboom we want specifically to check if the anim that ended was the explosion the explode anim again these animations are all imported at the beginning of the project in the Kaboom loader file if it's the case we just want to destroy the the Drone now here this.on explode so this is an a custom event and it's a feature in Kaboom that I discovered recently and makes your code very how do I say more clean so you can Define custom events by using this on function I have written a blog post about it again if you're interested I will put Link in the description hopefully if I don't forget so yeah and uh here so you the way you define custom events is you use the on method here and then you decide on a name and then the second param is what what is going to run when this event is triggered you can later on you use the trigger method to trigger a specific event I'm going to show it to you here I'm going to play a sound so you play a sound by using the k k. playay me function and passing in the name of the sound so here boom uh where does this come from it comes from the K Kaboom loader we imported those sounds initially here so here here is all the sound Imports all right then what we want to do is not only play the sounds when we have we trigger this explode event we want to also have a collision ignore we want to avoid the the Drone from colliding multiple times with the player by just like removing any uh making sure that any collisions with the player is avoided is negated or ignored when the Drone is exploded because we have already deducted life points one life from One Life Point from the player so we don't want to have a situation where we do this multiple times because the the Drone is is still colliding with the player while it explodes we also want to use the unus method which allows you to unuse a component uh that you added to a game object initially when you created that so here you can just use a a a string and refer to the name of the component so I want to unuse the body component and finally I want to play the explode animation so here be careful and to not mistake this and this this is for playing sound and is uh a method from Kaboom and this is a method offered by Kaboom but from the game object so this is for playing animation while this is for audio now here we're going to have another on Collide here we're going to have another on cide and then yeah so we have a sword hitbox so this is the logic we want to run when the player hits the with the sword the Drone and here we're going to do only hurt the Drone itself so by having the hurt one here it's going to reduce One Life Point basically similar to this but we don't have to worry about the player logic and then here is when we Define the so here it's not a custom event this the hurt event is a specific already existing event offered by kaboom what it does is that it offers um allows you to run something when you use the her function so when I say hurt when I call the hurt function it's going to trigger the hurt uh event also offered by kabo so here what I want to do is that when we reduce the life point of the Drone I want to check if this. HP HP gives you the current HP of the game object that uses the the health component if it's equal equal to zero so if it's equal to zero I want to trigger the explode custom EV event that I just created earlier on which is going to take care of exploding playing the sound and making the the Drone actually explode with the animation Etc and then that's uh that's it uh one thing left is this on exit screen on exit screen which is offered by the um the on offscreen component allows us to have this method available so when the the Drone is no longer visible on screen if this. pause. initial pause is superior to 400 then this uh I'm going to explain everything this do pause is equal to initial pause so here what it does um did I have the initial pause right Define oh I made a mistake at typo here initial POS pause position so what does this do well here is that uh when the off this will run when the distance uh the player is off screen with a distance of 400 and then here actually I don't think you need to have this you can just set the position to being the initial position basically respawning the Drone where it originally were was and that's it that's the whole Logic for the Drone so let's actually use it now uh let's place the so here I'm going to go in room one. J and then room one. yes and then here yeah so for room one. yes for the positions layer so here so I'm going to have a continue here now if the position type was drone remember for classes entitled you can access them access the the name with the type instead which is kind of strange but it stopped I think class is probably a reserved keyword anyway so here position. type equal equal drone we're going to create the Drone game object and but place it as a child here I'm keeping a reference to it because we're going to do some going to call the two methods we created so here map add and then here make drone and then here pass K and then position and then here we need to pass a vector two with the position dox and then position position y and then drone. set be Behavior which is the method we defined and then draw drone. set events all right now that we have this k 2 I think we the Drone should appear in our game so I'm going to refresh hit enter and and then we have a a l drone so let's see if we can yeah you see that's the issue that is that the the Drone remains kind of stuck above the player but not exactly colliding fully with the player that's why I added a initially here instead of following exactly I added an offset of 12 and now if we look back if I let the the Drone come to me it explodes you see so yep that's a a quirk of the move two method in Kaboom I think and then we have another now let's see if I can attack this one let's see if we can attack okay it's a yep I I was able to attack so that's pretty nice uh so not now what's left is the boss and after the boss I think we going to uh display the C cartridges with which are health pack and then we link the two scenes and then the game is mostly done I think uh we probably have to just add a an intro and Etc by the way if you cannot hear the sounds of the Drone exploding that's on me that's my setup sorry um maybe it's too late for me to verify if it actually recorded it properly but yeah just for your information I on my end I can hear the sounds of the explosions when playing the game so the first thing we're going to implement is the boss barrier so for the boss barrier we're going to go to the room one because it's something that is very like exclusive to this room where the actual boss battle is uh now I think it was in the room etails instead and here when I left the tutu so for the map colliders so if we have the boss barrier map collider what we're going to do is to have the following code so here here so I'm I'm first going to create a constant where I will hold a reference to the boss barrier so first we create a the game object uh that of course is a child of the map now here it's not that interesting but okay let's yeah I'm just going to copy and paste most of the concepts we have already seene so here are the components we're going to use for this object so a rectangle with a width and height the reason I'm using here the W component instead of doing this inside of the the area is because at one point we're actually going to see the rectangle and we're going to set this color for the rectangle for the gate and then the collider X and Y and then ignore collisions with other colliders and set initially the opacity to zero and finally the boss barrier tag now we're going to also have an object where we're going to have a a few methods so the two methods we're going to have is the activate method so this is a method uh which takes care of by using twins it's going to make the uh gate the the boss barrier sorry from invisible to visible uh so here we're going to first set the opacity uh from 0 to 0.3 in 1 second using uh the linear here I have already explained how to use twins here previously uh now here the twi is going to be the camera so as we are changing the opacity of the gate we we're also moving the camera so that we're going to make it we're going to make the the the boss battle arena take center stage and this is the reason I'm not using any await here because we're doing this at the same time so while so when you run this because tween is a synchronous it it will run on its own and then the the code execution will continue to the next one next one even though this is not done yet so that's that and then after this activate method we're going to have a deactivate method as well and for this one I'm also going to paste the code here I don't think there's much need to manually type it so here we have an async deactivate method that takes the current exposition of the player it will make the uh gate uh the boss barrier disappear so here and then it will move back the camera to the player's position and then it will destroy the gate after uh it is uh after it has fully disappeared so that the player can move out of the arena and then here are some other logic we're going to need uh so here this is within the boss barrier but now we have also content outside of it uh I mean not content I mean uh logic to write outside of it on in an un Collide event lessener so when it collides with the player we're going to have it in a sync and here one thing one thing in Kaboom JS is that when you use an on collide with the tag here uh on Collide will pass to the function you use as the second peram the game object that is collided with uh that the tag that the the game object is colliding with so here it's the player tag so it's going to give you the player game object so that means we don't have to use k. getet here so that's pretty handy so here I'm going to first have a current state constant just just as a short hand for this actually it's barely less characters barely less anyway I'm just going to keep it and then here we're going to have a first an if statement and then if the current state is boss defeated true whoops if that's the case then I'm going to set a new state so St state. set and what I'm going to set is here I'm going to this is where it's handy to have the state props enum it makes things less error prone I can immediately just select the as boss defeated and then set that to being true or actually it's not uh it's not that we want to set if the um if the player is in a boss fight so if the player isn't if player in boss fight I should have named this is M but anyway just do not generate any confusion I'm going to do this like that so now I'm going to set that to to be being true uh actually false because the the boss has been defeated sorry and then we're going to make a call to the deactivate method and pass in the player position X now after doing all of that we return so when the boss is defeated we set back the players in boss fight is a player in boss fight Boolean to false we deactivate the boss barrier then if it was not the case then if we also need to check another case if the current state. player in boss fight so actually if now the player is in a boss fight we also need to skip so we won't process the logic that comes after so we have two cases that we want to avoid going further the first case is if the boss is defeated that means means we just want to destroy the gate however if the player is in a boss fight in the boss fight we just want to return early so colliding with the boss barrier will do nothing uh special so now the the case here that we're going to write now the the default case is when the player first enter collides with the boss barrier so when that happens we are going to first disable the player controls so this is something I did not write in the player logic so I need to do that so if I go to player. JS and then from player. JS let's write a method maybe here right disable controls and this is where we're going to use the uh the uh control handlers that we had initially so what I need is simply to have a for Loop that will iterate through the various handlers that we we stored in this Dot control handlers and then cancel them so the way you do that is by calling the cancel method by default all of these handlers have access to that method and then of course don't forget to add the comma here all right so now we have disable control and um there's also another logic I should uh another method I should probably add is called respawn if out of bounds so we want make sure the player responds if they fall uh off the a platform so here I'm going to set three value the B bound value the destination three par I'm sorry the destination name and then the previous scene data and by default it's going to be exit name null so this is going to make sense in a in a moment so actually for now I'm just going to leave it to to do it it's it's going to make sense when we're going to link up the various scenes with each other so now I'm going to go back to the room utils and then from there after having written the boss player Collide I can write um okay first I make a call to disable the player controls because we want to basically Force the player to go through the gate and not not arrive with a situation where the player doesn't uh avoids the gate basically as the gate is sucking the player in it the player is trying to get could avoid it and move to the other direction we don't want to have this situation otherwise you're going to have a bunch of bugs so by disabling the controls of the player and forcing him to go to the gate through the gate if they collide with it uh to go to the boss battle and it's a bit like that in the Souls game once you commit to going through the gate uh there is there is no going back basically and then I'm going to play the idol animation while while we do this and then here I'm going to again have an await for a tween which is going to be responsible for uh changing the player position from this to player Pax but plus 25 pixels so that we make sure that the player goes through the gate we want to do that in 0.2 seconds and here we have the value function that basically do the the adjustments of the value until the destination is reached and then here with an easings linear and then once this is done we are Sav to do player. set controls again so that we give back the player controls uh the controls to the player so this is await so that as long as this is not done we won't proceed forward otherwise if you were to remove that this would run while this would also run so that mean the player could escape and go out of the gate uh yeah out of the Boss Arena while the transition would happen all right now another one so after having the UNC collide with the player the boss barrier we also have the uncollided end so not only can we in Kaboom J know when collide with something but we can know when a collision ends with a game object as well and then here we don't really need to have the player game object here what we want to do is that once the the the Collision is over first I'm going to hold the the current state like that just for it it's handier I guess and then I'm going to have current state and then if the current state is a um player boss fight so if the player is in b a boss fight or current state do so if either the player is in boss fight or the boss is defeated so is boss defeated then we return early we don't do anything and then otherwise we're going to set so state do set so State PR enum to make things less error prone and what we're going to set is the player in boss fight and here we're going to set it to true so that the the boss fight is actually starts and then the boss barrier will activate preventing any while preventing well what actually the activate does is just going to show the the boss barrier and then we're going to assign to the boss barrier a body component so the way you add a component after the fact after having creating created an object you use the use method and then here we want it to be static because it's an obstacle and here we go and that's basically it so now if I go back to the game and hit enter and I if I just go back to the Boss Arena then this is following me yep you can see the Boss Arena is here and I cannot Escape so maybe let me just retry this time around without activating debug mode so that you can have a can clearly see so here we go I'm playing around then as soon as hit I'm transported and I'm stuck here so now it's time to code the boss battle itself so the boss itself so how we're going to do that is going to create a new file in the entities folder that file is going to be called enemy boss. JS and it's going to take the exact same mostly the same uh uh properties Etc so what I'm going to do is I'm going to copy and paste a bunch of stuff but for now let's uh first write the Constructor function so make boss and then pass in K and the initial position as for the components we're going to of course return a k. make and then here for the components I'm just going to copy and paste the first few components here so we have a state machine with different states we have the idle State the follow state where the the the boss follows the player the Open Fire state where the player the boss starts opening fire from their flamethrower and then the fire state where it's firing and then the shot fire when the the animation to close the flamethrower will play and then finally the explode state which is where uh when the player uh the boss dies and then here we have a mass of 100 and a jump Force initially I made the the the boss jumping as well but I haven't used this anymore so feel free to remove it here it's again the same thing here the animation is burner the Sprite and the animation by default is going to be idle and then the health I gave him 15 points of health and opacity initially it's one but as with a player when it gets hit when the boss gets hit it's FL it flashes so it blinks so now what we have here is our various methods uh so let's first I'm going to copy and paste the various properties as well soy suit Speed fire range and duration of the fire and then right below we're going to have the set behavior and set events so set behavior and set events much uh of the same structure as I did with the player and the drones and Etc so here we go and uh yep um I'm going to before going onward I'm going to just uh Define a reusable function that will make the any game object blink uh as I explained it's when the player or the bosses or the enemies take damage uh except for the Drone because they immediately die when they jump on when they hit you so but for the boss and the player there is some reusable logic we can write and I think I'm going to write a create a new file in the entities folder I'm going to call it enti T shared logic. JS so what does this do it will make uh going to have a single function I'm just going to copy and paste it here and go over it so basically we have a make blink function that takes the context The Entity the game object and then it's time span by default it is 0.1 we can specify a different one if you want so it's an optional parameter and then here um we use twins to make first the opacity go from one to zero in a certain time span and then the reverse so the first one is important to have a weight so that this doesn't run as this is running but the second one there is no need to have no weight because it's the only thing here so hope I made this clear all right so now for the boss if I go to set Behavior Uh I'm going to actually first of all let's add the blank logic to the player so I in the set events here I'm going to add a bunch of events to handle that so for the player remember the heal and hurt events so we can we can use that so this do on heal event listener is something that is offered by Kaboom if you use the health component on your game object so here what I'm going to do is I'm going to set the this the health State uh as follows so State props enum and then here player HP and I'm going to set it to the current so this. HP of the component and then I'm going to trigger uh actually hit here to do health bar bar logic so of course we're going to have a UI element that is going to update or uh yeah so here we're going to trigger a custom event for the health bar we haven't created health bar yet so that's why I just going to put a Todo message here the other one which is actually why I came in this file first is because we wanted to make the player blank when they get hurt so we're going to do that inside of the hurt event listener that of course is offered because we when you use the heart function the heart method to reduce the life point of the player the life the health of the player this gets fired and here this is where we're going to call make blink and should normally automatically import it so if you go upward it should be imported all right so make blink is going to take um K and then this which is the game object itself the player itself and then here in this logic if the HP as long as the HP is superior to zero so if the HP is superior to zero I'm going to set the State of the State props en. player HP and then set to the new updated HP so remember the HP method gives you the uptodate um HP calling the hurt on the player fires this event because not only the hurt actually changes the value the health value but also by having this event we can make the player blink but also make sure to set the state for the global state so that when we move on to the second room it's going to keep track going to have the same health value otherwise everything is scoped so by default the comp uh the the the component HP health is scoped on the scene where the the player is created um actually I think there is maybe a method called stay in boom Jazz that allows you to have the same uh game object stay in the next scene I haven't yet learned about it much but I just remembered that it exists so maybe we could have gotten away with not having to deal with global State like that so something to check if you want on on kabon j.com which is the official Doc site here we're GNA also have a health bar update so I'm just gonna I leave a comment here and then we return early because otherwise we will simply have the following code so in case the HP is not Superior to zero I'm just going to copy and paste this part we going to set the state of the player HP to be the max player HP so the reason for this is that we're basically respawning now you could put this later on you could put this after so that first you have the boom sound then the explosion then the the health bar the health of the player is set to being full health because they were going to respawn and then right below that this on anim end anim go so if the anim is equal equal to explode which was triggered here right above explode what's with the weird spacing here we're going to go back to the same room one scene so it's effectively responding so I think we have this and uh yep we have everything we need so let's save that let's of course save this as well well so now if I look at the game press enter can let's see if we take them if we blank if the player is going to Blink yep they blinked so as you can see all right so let's do the state machine for the boss so much like the Drone it's going going to basically have the same pattern so a couple of this not uh on state update or on state enter so let's start with the idol state so on state update we're going to need here and then so for the idle State what we're going to do is make sure that if the state and then current all right so now we need to check for the current state if the player is in a boss fight so state. current and then player in boss right if that's the case we're going to move to the following so enter State and then we move to the follow so this makes sense because as soon as so when the player is not in a boss fight so that means they're not they haven't passed through the gate we don't want the boss to do anything we want the want it to remain idle however as soon as the boss uh the player sorry and has enters the gate this is set to true and that means that it's time for the boss to start following the player so here we don't really need a actually in fact this shouldn't be a on state update it should be an on state enter oh no it's an update because when the game the the room is initialized the the boss is placed so we need to check this every frame until it actually happens the the player actually enters the arena all right the next uh event we need to listen on is on state the follow event so on state enter follow what we're going to do is we're just going to play the Run animation so so here um so we have the play okay so we play The Run animation and then for this on state update for the follow as well with follow State we're going to in case you didn't copy here are the very State we we're going to use so here so for the follow State uh every frame what we're going to do is we're going to first set the flip x value in much the same way we did for the Drone so if the player position is inferior to the boss's position that means that the player is to the left and that means that the boss should face left that's why we do a flip x equal true because by default the Sprites are drawn facing right now here this do move two so we're going to use the move to again as we did for the uh drones and we're going to again do exactly the same thing so move towards the player position with an offset of 12 here so that uh we don't have this weird case where the player is the boss will basically be stuck with the player but nothing will happen so then here we're going to have a Pursuit speed as well actually in fact I don't think it's needed here for this specific case because at the end of the day even if the the boss gets stuck with the player the player can just move around so yeah now the pursuit speed is the same yeah for this boss for the boss we only have a Pursuit speed so we don't have a normal regular speed like with the drones and uh that's basically it for this logic uh we also o need to add an if statement which will determine if we move out of the follow state so if the position uh of the player position uh no if the position of the Drone um the boss sorry is uh if if the position of the player is near enough the position of the boss and this we we we do this by checking for a specific range so the fire range so 40 so if this distance is this distance is in inferior to 40 in this case what we're going to do is we're going to enter into a new state which is the um open fire open fire State and then for the Open Fire State on state enter open fire and then what we're going to do here is just play the Open Fire anim I made a mistake here it should be lowercase and now after this animation is done we're going to actually have it on anim end here but uh for now we're going to have this on anim end uh logic inside of the set events and not here so let's continue defining our various other states and and then we we will tackle this later on so here we could have um that this on state enter for the fire so let's define the logic for the fire state so what we're going to do here is create uh the flamethrower sound flamethrower sound which is going to be a reference to the sound of the flamethrower which we can play like this remember we imported this sound in the Kaboom load loader. JS file now what we do next here is to have the fire hitbox we need to create the hitbox for that and we're going to basically add it as a child of the boss game object and here again it's the same logic we did for the sword attack for the player just various different values here so I'm just going to copy and paste that to go quicker and then here for the logic for when the player hits the collides with the hitbox again this is very similar logic that we did with the sword attack but this time around we hurt the player and then if the P if the HP is equal to zero we set the state we said the the player in boss fight to being false that means that the player just died and that means simply that they're no longer in the in a boss fight and then here finally we have the K Weight which is going to wait this is another form of the weight variant so here I'm just going to put the fire duration so how long does the the fire attack lasts it's it's a property we created here one second and then we run this logic so the second param is the logic to run this is the SEC another form you could have used a weight here and then did your logic right after here but I I felt that it wasn't really needed to use a weight here because there's yeah we can just use this form and then here what happens is that when the fire duration so when the fire attack ends we will stop the sound so that's why I I stored the the sound here the sound listener reference so that I can easily use the stop method on it which is offered by Kaboom as well and then after we have stopped the sound the player uh not the player the boss will enter the shut fire State now for the Open Fire and shut fire we haven't defined anything for the shut fire and open fire we haven't defined any on State uh enter or stuff like that uh we're going to do this in the set events we're going to actually just in our on adim and event listener just run into like enter those States all right so now uh let's define those uh let's let's define the remainder the remaining uh on state enters on state end and on state update for the fire so this onate State end for fire state so this happens here and then inside of this the we we just use that state to delete the fire hit box so as we did with the sword attack you get the fire hit box and then you check if it exist before trying to destroy it and then finally we have actually we have two two things we have the Shut fire so sorry I was inaccurate later on I said we wouldn't Define a on state enter for shut fire but we actually do here we just play the shut fire animation here and as here the on state update for fire this is uh useful to Simply play the fire animation if it's not already playing as as we go here but here I realized that um we could have just defined this here so so yeah I think this is not a necessary State we can take this line of code I'm going to just comment this out and I'm going to paste it here so we just play the animation of fire right here and like that so now let's go to our set events here again we're going to get the player so as we did actually we didn't do this here so const player k. getet player and then recursive true and then index zero and then here we're going to Define an un Collide here so this time around it's the reverse it's when the boss collides with the sword hit box we play the boom sound and then we hurt the boss so we reduced its health and this is an important part that I referenced earlier on we're talking here about the this on anim end we we going to we're going to use a switch case statement here so if we are in the open fire State we enter the fire state so here open fire if I remember correctly we just play the Open Fire um animation this open fire animation ends it's not a infinite Loop uh the loop property wasn't set to true there if you look at the Kaboom loader. JS file if you remember so if we go here to the boss the burner Yep this the boss so for open fire there is no um Loop set to Tri so that means that the animation plays once and then when it ends it ends that's why we can use a in our code here where is it where is it here that's why we can use here um the the on anim and listener so we do the same thing for the shut fire here as well so when the shut fire animation ends we enter this the follow State and finally when the explode animation runs we after it runs actually we call the destroy method uh function from Kaboom to destroy the boss so the boss has been defeated and then right below that this is where we're actually going to define a custom event called this on explode this is exactly the same thing we did for the the Drone enemy uh so here we entered explode State now here explode State uh we haven't defined it I think uh did we do so the the purpose of this is just to have a state that is different than what is the the other states so it doesn't do anything really but yeah that's uh that's that's that uh it's just to if you we weren't to do this uh it would the the state machine would enter other states and then it would conflict so by having a dedicated state usess state quote unquote we were able to uh not enter this case and remember that here the explode we you need to add it as well here in the the state array at the beginning so what we do here we set Collision ignore to the player for the same reason we unuse the body we play the boom sound again uh we play the explode animation which after it's done it's going to destroy the enemy the boss we set the isbs defeated true state to true we set the is double job jump unlocked to true and then here I have enable double jump uh method we haven't written this so let's just write it out quickly so right it's a two one line basically on line method so I'm going to put it uh maybe at the end of the player so let me collapse this so it's clear like that so enable double jump uh the way you you have access to the num jumps property if you use the double jump component and you can set it to to a number you want and here we're going to set it to two so now if I go back to enemy boss it's going to do that we're going to play the notify sound which is a sound that basically will display this notification box now make notification box is does not exist yet so let's create it out let's create this UI element so I'm going to go here I'm going to go to the UI folder which is empty and I'm going to create a new file so this file is going to be called notification box. JS and what it's going to contain is the following so we first have as the first param the context as always and the second param is the content then here we're going to make a game object which is going to be a rectangle and with a darkish blue or purple color and then we're going to use the fixed component so that it is not affected by the camera we're going to Center the the position by calling k. Center which gives us the coordinates for the center of the C canvas the area component is important here because we want to set the anchor as a center and the method we're going to use is going to create is simply a close method that just destroys the the the notification box and then as a child of that container because initially it's a container we're going to put a text component so a child game object that is going to have a text component that is going to use the glyph mess font that I showed you showed you at the beginning of the tutorial and the size is going to be 32 this is what looked good as for the color of the text this is what looks good and fits with the color pallet uh here area and anchor Center again so that the text is centered and then we return the container so that's our notification box if I go to the enemy boss here we can see the text I have put you unlocked a new ability you can now double jump and then after 3 seconds the we going to call the close method the we defined here so that uh the the the notification box uh is closed so here we just add it to the general canvas instead of the par uh the map because it's a UI element and we just store it here so that we can have access to close we can call the close method all right uh now let's import that properly uh because it didn't do it for us automatically so here import notific make notification box remember to add ajs otherwise you're going to get a MIM type error and oops and that's it so now that we have that I think we have everything we need for the boss and it's now time to test it out so let me just make sure that's the case oh we have one last thing uh one last event so the hurt event for the boss so as I explained multiple times now the hurt event is something offered by Kaboom if you use the um health component and here we're going to make blink the um the boss if the HP is superior to zero though we return early as we don't want to trigger the explode event which will take care of destroying the boss all right and let's import that also import make link and uh that's it yep that's the whole logic so now in our room 1js so in room 1js if I go to the positions here and then here I'm just going to add a continue so the reason I'm adding a continue here is that if for this position we enter here there's no point in uh running the other if statement that comes next so because we already know that it's a drone here for this iteration so we need to go to the next iteration to have a to check for the other entities so if the position here name and then here I think it was boss yeah if we have a boss and of course we only spawn the boss if the state current that uh is I think is his boss defeated is false so only if the if the boss was is not defeated that we will spawn the boss and here const boss we add it as a child of the map and then we call the make boss now that we have the make boss we just put here k. Vector 2 for the position oops I can't seem to write it well and then position X position Y and here and then finally we call boss set Behavior which is going to set the AI for the boss and the boss set event events because it's going to set the the various events for it and that's it and also for the cartridge so the cartridge are basically Health uh but before doing that let's just test it out so if I look I refresh state is not defined okay where is that issue from State not room one okay we forgot to import the state so here uh let's import it here import State here we go now if I refresh press enter okay V okay I forgot Vector 2 uh room one line 64 line 64 yep I made a stupid mistake here a typo and then if I press enter what I mean state is not defined where an enemy boss forgot to import the state here as well so import State hopefully now it works press enter and yep so now let's play through the game all right all right let's see if we can fight the boss player is not defined come on players not defined enemy Boss line 35 okay line 35 where the enemy boss where's that player to position okay I guess I should have const player equal K do get player recursive true and then here we go and then now if I play the game normally everything should work all right and then here we go yeah the boss seems to work does he follow me yep H State prop enums is not defined so this is probably again in the enemy boss State props enum here we go so if I fight the boss again here we go and then I move forward there you go all right you unlocked a new ability you can now double jump and now I can indeed double jump so okay so the game works all right now what we need is two things we need the health bar and uh y we need to do the health bar and then after that we'll add the cartridge and then after that the only thing left is really the uh the um the room the second room so for uh room one uh actually no for the UI I'm going to create a new file I'm going to call it health bar. JS I think it would be better to just tackle the cartridge so for the cartridge what I'm going to do uh cartridge are basically Health packs and we can just go to room one. JS and then add a simple if statement here is again it's a single line if the position type is equal equal to cart rdge actually we're going to need to create a new entity for that map add and then we're going to add the cartridge here so in entities create a new file call it health C cart cartridge. JS and then here in health cartridge we're going to have a simple um simple component here let me just explain so make CD The Constructor K and then the position and then the position is just set here then we play use the Sprite cartridge with the default animation and then and we set the on collide with a player and then every time the player collides with the cartridge we play the health sound with a volume of 0.5 because the original sound was too loud and then if the player HP is inferior to the max player HP we allow a heal otherwise we do nothing uh we don't heal at either way we destroy the cartridge so if I go to room one now call make cartridge make cartridge pass in k pass in k. Vector 2 and then position X position Y and then that should be it so if I go and test this out we have our c Bridge here let's try colliding with one and you hear the sound so there is not much um let me just test something so there isn't much to do here to test uh without the health bar so the health bar is really key now so I'm going to go back to health bar. JS which we created here in the UI component and then health bar is basically simple as well in not a lot of line of codes so I'm just going to copy and explain everything so we have this Constructor which is makes makes this health bar component uses this health bar Sprite sets the frame to zero because we have three frames we don't have any animations for this one as I if you remember earlier on in Kaboom loader what we had here in the Sprite Atlas was the health bar with a slice y of three that means that we have three frames so so in Kaboom JJs you can just display a specific frame by using the frame property so that's why what I did here the frame zero and then here I scaled it four times because this we actually scale the camera I think four or two times uh but for the UI to look good here we need to scale this Sprite four times and here the HP mapping just tells you that for any amount of health so one one amount of Health we need to display the the frame two for two Health Point we need to display frame one and for three Health Point we need to display frame frame zero the reason this makes sense is simply that if you go to the ui. PNG you can see that this is going to this part whoops this is going to be frame zero frame one and frame two so when we have full health we have actually the frame zero and yeah frame two uh frame one is when we have two Health Point and frame uh three is uh frame sorry two is when we have one uh HP left and then here that's why I created this mapping so we can easily uh set it here so then I called the set events event listener I create I created the set events method sorry which is which is where we Define this custom update um method uh I mean event sorry and then what it does it takes the current HP and then if the current HP is equal to zero we destroy the health bar because we're going to just recreate it and regardless we set the frame the current frame to be using uh to be used to being the current HP mapping so here it go though this makes a bit less sense because you could maybe just go here if you're going to destroy the the health bar might as well uh not do that so it becomes pointless to to set the frames afterward and then we're just going to create one health bar here that we used that we use here so instead of creating that in our various rooms we just create one here and we import it where we need it so let's add this to room one. JS so we're going to add it at the end of our file here actually outside of the for Loop health bar then we set the event which is just one we call the trigger we actually trigger the update events event once Health bar. trigger the update and then of course remember that we need to actually add the health bar to the scene because we have only used it with make so we haven't added it anyway anyway anywhere in the canvas yet all right so now that we have that uh if you remember earlier on I had two two dos so to to do um no not not that one um health bar come on I had a a comment to do did I forgot about this seriously H okay never mind never mind so I think it was in the player logic in the events for it yeah okay so it was here health bar so here we're just going to have going to call the health bar then trigger an update we're going to do the same thing here as well so now if I look at the result press enter we have our health bar let's take some damage just just to test things out and then you can see our life is reduced and then when I get healed and damaged again and then let's get damaged again and then let's uh let let's let this Droid kill us here we go and then we respond all right sounds good to me and uh yep so the game is basically done except now we need to have the other room so yep let's work on that all right so one quick thing we're going to do before proceeding on to writing the logic for the other room is we're just going to write some logic that when the player Falls here so after a certain y position they respawn to do something like that we're going to fill this function that I left as a todo so the way we're going to go about it is the following so if respawn if out of bounds so here I'm going to create a on update Loop this onupdate Loop what it's going to do is it's going to check every frame if the position of the player so here I'm in play.js in this method that we wrote but didn't write the body of previously and then here so if this so this is the player the position Y is superior to the bound value which is going to be the maximum y position we want to allow then um yeah Superior so remember in in a canvas in Game Dev usually the farther you go down the higher the value of y That's why we have this statement here so now what I do is that if I exceed if the player exceeds this bound value we can just go to the destination name which is going to be the the room you want to go to that we're going to Define later and then we're going to pass the previous scene data as the other by the way the go function in Kaboom J allows you to switch to another scene but it can also take uh in addition to the name of the scene you want to go to you can pass some data and here the data we going to pass is going to be the exit name so here in our what is exit name is going to refer to the exits of the um that we had on our map so here the exit layer in tiled you have exit one and exit two so the way we're going to do we're going to go about this is we're going to use this uh previous scene data to tell Kaboom when to spawn where to spawn in the other room in this particular case though what we do is that we're not going to add anything we're going to make the exit name null because we want to just respond in the current scene so here it doesn't make much sense for now uh but bear with me so here it's time now to use the respawn if out of bounds and you're going to we're going to call this inside of the room one. JS in this file I'm just going to have the player here player um respawn respawn if out of bounds all right so we have this respawn if out out of bounds so what that what we're going to do now is we need to actually pass in the param so I'm just going to pull the player. JS file for reference because I I need to find it just to know what to do so the bound value I think the bound value I did in my original was 1,000 so 1,000 will be the maximum y value want to allow otherwise we would spawn into room one so what we want to do here is to set the respawn if out of bounds uh value the bound value to 1,000 this is what uh looked good and then immediately go to room one if we go out of bounds so let's try it out so if I go here okay it's not a function why is that so here respawn if out of I made a mistake here in player. ja of bounds now everything should work so let's try it out now if I drop off I should respond all right everything is working nice so now we have finished the every like gam playay features and now what is left is just to make the scene transition to the other room and repeat some of the logic for the next room so room two so to be able to pass data between the scenes as I show show as I have shown initially by using this second param to the go function we can actually receive that data we haven't written the logic for it so if I go back to main.ts you can see that we just pass the room one data here but the room one data we can receive it here so if I go to main.js I can create a param here called previous scen data and then I can just decide to pass this as a third Pam to pre to this room one and I'm going to have to of course create a new pram here for uh for the room one function in our room 1js file so this can be passed by the go function by default we want to make sure that this is null um so you have to specify this by default we could have decided that here by default if it's not never mind never mind you have to so by calling K.O room one to go to the room and specifying an object as a second param it's going to be our previous scene data so this refers to this all right now you can see that for our case here we haven't had anything here so let's set the data we want to pass as exit name null we're just coming from the menu so there's no previous exit uh we're coming from but this is going to be useful for room two so here I'm just going to pass the exact same data but just in instead of room one it's going to be room two and then previous seene data here as well and now we need to actually write the code in room one or room 2. J which is pretty empty for now we're going to have to do basically the same thing so set the background color with the color I specified previously which was hasht A2 A5 remember to add the doj to the uh import the statement uh make sure to cam scale four times like we did in room one make sure to add to set the initial camera position to 170 by 100 like the initial cam uh the initial uh camera position we did for the room one and then set the gravity as well to being 1,000 like we did with the first scene the room one scene then we're going to get the room I'm going to store the room layers inside of room data do layers actually we're going to St going to um store the layers inside of the constant room layers sorry and then we're going to do the same thing we did so create a map game object add it to this scene and then set the position to being 0 0 as a reference or just uh you can easily modify it later on and then set the Sprite to being k. Sprite and then Room 2 remember we have this uh loaded from the Kaboom loader. J file and that's basically so now if I um okay yeah so that's basically it now we we can do the I'm just going to copy and paste the exact same logic we had here so I'm going to take room one and then copy all of these and then all of these as well and even the player as well so really everything comes except for the there there aren't any mobs there are cartridges so we're just going to modify a few things so let's copy all of that and then go here and then paste it right below now of course there's a bunch of import statements that are missing so we going to have to figure this out um I'm also going to remove the Drone here because there are no drone drones in this uh room and also the boss so what is left is the cartridge and the player and then here we're going to have to import everything so let's import um import the player the make player sorry function let's import the make cartridge function we also need to import um the state do do we use the state here not sure no we don't we actually need the health bar as well so let's import that as well health bar and then okay we have the health bar we have everything the and then the various set camera zone map colliders Etc so here again I'm just going to go here to room 1. JS and copy and paste this from room utils so take this import statement paste it here and then save and then I think we should have everything we need um let's try it out so so what I'm going to do now is I'm going to actually have to set the exit zones now so one thing that we didn't write in the room utils is a function to handle when you exit a given room Etc uh Etc so right below Set uh maybe at the end of the file I'm going to go to room Ms and then create a new function export function and then this function you're going to call it as I said set exit it zones and then it takes a the context the map game object the exits and the destination the destination name I'm going to call it this way this part all right so here for so where does this exits come from so here in our room two there's another layer we're going to look for is the exit so I'm going to add right above here if the layer name equal equal exits by the way we need to also add this in the room one logic because there are exit exits as well so let me just verify here so we have the exits layer so now we're going to push we're going to create a new array so you could uh also like make this more modular so all this part that we copied and paste from room one you could have a single source of Truth so a big function that does all of this I didn't do it for this project because it's a relatively small scope but in case you you want to push this further I recommend that you start modularizing and abstracting things from here so here uh we're going to have the exits array that I'm going to create and then in the exits array here I'm going to push exit. push do layer doobs just to not have an error later and of course continue because otherwi there's no point in running the last if statement if we arrive to this condition so you could have decided also to have this as an a um switch case statement in hindsight so feel free to refactor so I'm just going to copy that part in room one as well and now we can go back to room utils and then go back to the set exit zones so for set exit zones we're going to iterate through the exit so exit con exit of exits and then we're going to create the exit zone game object which is a child of the map game object we're going to set the position to be exit X exit y because they offer the position so yeah so we have the positional data in inside of the this exit constant and then we're going to have yeah now I'm just going to copy and paste because it's roughly the same thing we've you've been used to with the other ones so the area is specific we ignore call it collisions with colliders and then we pass in the exit name this is important because this tag is unique to the exit name so here for exit one this is going to be the tag for exit two this is going to be the tag and then for here room one uh room two the exit one here exit two and then Final Exit as well okay so now that we have that right below we can set a collider uh on Collide event listener so if the exit Zone on Collide so collides with the player we're going to have the following so we're going to use in the sync function here and uh I'm just going to copy and paste the code just to go a bit faster and then I'll explain it every line what do we do here so we set the background so this to have a a nice transition so we create a rectangle that takes the whole screen that will move via a tween and then if the exit name is the Final Exit we go to the Final Exit scene we haven't created that scene yet so just copy and paste that for now otherwise we go to the destination name uh which is either room one or room room two depending on where you're coming from and we pass in this object uh to that uh to that next scene which is going to tell us the exit name we're coming from that way we can know where to spawn the player either in entrance one or two so we are going going to have to add some some logic to room one and room 2. J to to control the spawning of the player so now that this is done done we are ready to use it so in room let's let's add it to room one and then to room two as well so for room one I have added it here so let's do it last or yeah we can do it last it doesn't matter okay let's do it right after here so right after camera control so set exit zones and then pass in k the map the exits and then the destination name is room two in room one we need to take this same logic in room two but instead of room one uh instead of room two here it's room one and now here in room one let's go here so for the player position actually it's going to be much more a bit more complex than only one if statement so if I go back to the player uh the room one logic so we're here we're going to have two others if statements so if the prev so for the first one we're going to add the condition that if the previous scene data was null does didn't exist actually we need to do the exit name is null so we would spawn the player in the original initial position otherwise if if if the position. name is entrance so yeah so uh we had a pin if I go here if I go to the positions layer in room one so I'm just going to make it visible we have this entrance one and entrance two pins this is where we determine where to spawn the player uh if they're coming back from a scene so for this if statement if if the pin was entrance one so the position was entrance one and we had a previous scene data exit name passed through this uh to go to arrive to room one and it's exit one then we would place the player into the the position of that pin and then continue on and then set the camera position to be the one of the new player position because otherwise the camera would still be up there in the level and then finally exactly the same logic so here again I was at the end of the project so I just wanted to get it done as quickly as possible so there's a bunch of repetition but at least with repeating code that is simple like that it's easy to to abstract it when when you need it into a more reusable version so here is the same logic all right now we do the exact same thing in room two so for room two I'm just going to copy and paste the logic for by the this time around we only access room two from either of those two exits that you have saw initially so we don't need this default if there's no a default spawn spawn point for room two so it's either entrance one or entrance two if you look in tiled room two you can see the player can either spawn here or or there or or there there is no two option uh two options sorry so here the same logic this time around we set the position as the uh never mind so why is this the case map positionx I I don't think we actually need that so if I go back to room one I just set the position normally since we have the player as still a child of the map we can remove this this was a an error on my part because the position is already relative to the to the map anyway so let me just remove that hope it will work and and here we go so hope I was clear if there is anything unclear feel free to comment in the comment section uh ask your questions there so I can see them all right I think we're basically done let's try it out so there's an error already so set background color room two probably missed an import statement uh set background color what's the issue red Declaration of import set background color previously declared at line one okay so it was so it was re red declared at line three or six ah okay I see I copied it twice so I'm just going to remove the first one now if I press enter exit is not defined uh okay line 40 room one so line 40 it's not exits I thought the this layer existed let me look it up exits yes this layer exists uh did I mess something up layer name exits. push ah I forgot to create the original uh the array for all holding all the exits so let's do the same in room two because we're going to have the okay we did it for room two did not do it for room one that's why so if I press enter and then we have our game okay now let's test it out so I'm going to just go to the left and we have previous previous scene data is not defined okay where is this error from um main.js okay main.js previous in data okay we need to pass this here so now it should work let's test it out pressing enter here we go now let's go here and then K is undefined okay so what's the error now K is not defined in room two line 12 room two line 12 so room two line 12 okay we didn't pass in the K here and we didn't pass in the room two data as well and we didn't pass the room data sorry the room data as well and we didn't pass in the previous scene data so forgot to add all of these params that we did for room one now it should work hopefully so I'm going to make it this full screen ah set exit zone is not defined again forgot this in room two set let's add it to set exit zones here did we add it for here as well okay for room one and room two we have them so now let's test it out again and now it should hopefully work and it does and then if I exit back in we're back at the correct position so now I'm just going to go to the other one so actually I have to beat the boss first to get unlock the double jump ability okay let me just hit the let me just beat it and then we'll all right now we should have the double jump unlocked and now I can go to the other side here and we spawn in the correct place and now here should it it's normal if it bugs here because the scene doesn't exist or did we actually create that scene yeah Final Exit we didn't create it so the game is mostly done now the only thing left is really to create those last scenes so the intro scene with a message that tells you like how to play and the final uh Final Exit scene so we're going to do this in main.js uh for the final scene I'm just going to create it here right below the intro scene and then I'm just going to make a call to the notification box with this message going to do the same thing for the entro scene and the project is done so here I'm going to import make notification box and then for the intro scene I'm just going to add the following as well so right below here and then one thing I also want to add is I'm not sure if it does anything but the audio on the web page unless you do a gesture the audio will not activate so if the first sound of your game is the sound effect from getting hit and before that there were no sounds played then it's going to have a lag between the the time the sounds actually play and what happens on the screen for the first sound that is uh that is heard on a web page so I thought this would fix the issue but I'm not sure if it does anything so I'm I'm gonna keep it here so so it's about creating a new audio context but I'm not sure if that it works because we should actually resume the the already existing audio context but I'm not sure how to get access to that so this is something with Kaboom I I don't know if there is a fix except that you start immediately playing some background sound when or in the menu playing some sounds that that way you wouldn't have this issue all right let's test it out and okay set back color is not defined import set background color all right we we the game should be done let's let's play it so escape the factory use the arrow keys to move X to jump and Z to attack and then press start so let's play Let's see if everything works all right so I hit the enemy all right ah I took some damage can I go to the left yep by the way this is intentional that the enemies respawn when you you go to to another room uh that's a bit like uh in Souls games the the enemies respawn like that but so I'm just going to beat the boss and once the boss is beaten okay that's I have unlocked the ability by the way you can make the boss more complex I made it simple on purpose so it's easy for me to play test so now I'm just going to complete the game so here go here here and then I took some damage and then I go to the left side and then I jump here and I jump here and uh by the way I'm just going to drop off here to test that the respawn logic Works yep and I'm just going to also go back here to make sure that the logic works all right it does and then I'm just going to finish the game you escape the factory the end thanks for playing and that's it that's the game hope you enjoyed this tutorial and uh by the way if you want you can subscribe to the channel so that you don't miss out on future tutorials I don't upload that often so it it would be a good idea but yeah so I hope you enjoyed the tutorial and you can go on my channel see other gamedev JavaScript related tutorials thanks for watching bye one last thing uh if you ever want to upload this game online what you do is you just zip the the whole code base and then drop drag and drop it on h. and it should be able to deploy that was one thing I forgot to tell you so same thing for GitHub Pages you just activate GitHub pages on the repo for this project and it should be up and running so that's the advantage of not using a A bundler or npm is that the deployment is very easy all right thanks for watching again bye
