With timestamps:

00:00 - [MUSIC PLAYING]
00:49 - DAVID J. MALAN: All right.
00:50 - This is CS50 and this is
the start of week two.
00:54 - And you'll recall that over
the past couple of weeks,
00:56 - we've been building up.
00:57 - First initially from Scratch, the
graphical programming language
01:00 - that we then, just last week,
translated to the equivalent program NC.
01:04 - And of course, there's
a lot more syntax now.
01:07 - It's entirely text but the ideas,
recall, were fundamentally the same.
01:11 - The catch is that computers
don't understand this.
01:13 - They only understand what language?
01:15 - AUDIENCE: [INAUDIBLE]
01:16 - DAVID J. MALAN: zeros
and ones or binary.
01:18 - And so there's a requisite step in order
for us to get from this code to binary.
01:23 - And what was that step or that
program or process called?
01:26 - AUDIENCE: [INAUDIBLE]
01:27 - DAVID J. MALAN: Yeah, so compiling.
01:28 - And of course, recall as
you've now experimented
01:30 - with this past week that
to compile a program,
01:32 - you can use clang for C, language.
01:34 - And you can just say clang
and then the name of the file
01:36 - that you want to compile.
01:37 - And that outputs by default
a pretty oddly named program.
01:40 - Just a dot out.
01:41 - Which stands for assembler output.
01:43 - More on that in just a moment.
01:44 - But recall too that you can
override that default behavior.
01:47 - And you can actually say,
Output instead a program
01:49 - called, hello instead of just a dot out.
01:52 - But you can go one step further,
and you actually use Make.
01:55 - And Make it self is not a
compiler, it's a build utility.
01:58 - But in layman's terms,
what does it do for us?
02:00 - AUDIENCE: [INAUDIBLE]
02:02 - DAVID J. MALAN: compiles it.
02:03 - And it essentially figures out
all of those otherwise cryptic
02:07 - looking command line arguments.
02:08 - Like dash-o something, and so forth.
02:10 - So that the program
is built just the way
02:12 - we want it without
our having to remember
02:14 - those seemingly magical incantations.
02:16 - And though that only works for
programs as simple as this.
02:20 - In fact, some of you with
the most recent problems that
02:23 - might have encountered compilation
errors that we actually
02:25 - did not encounter deliberately in
class because Make was helping us out.
02:29 - In fact, as soon as
you enhance a program
02:31 - to actually take user input using
CS50's library by including CS50 dot H,
02:36 - some of you might have realized
that all of a sudden the sandbox,
02:39 - and more generally Clang,
didn't know what get_string was.
02:43 - And frankly, Clang might not
even known what a string was.
02:45 - And that's because those two
are features of CS50's library
02:49 - that you have to teach Clang about.
02:51 - But it's not enough to teach Clang what
they look like, as by including CS50.h.
02:57 - Turns out there's a missing
step that Make helps us solve
03:01 - but that you too can just
solve manually if you want.
03:04 - And by that I mean this, instead of
compiling a program with just Clang,
03:08 - hello.c.
03:09 - When you want to use CS50's
library, you actually
03:13 - need to add this additional
command line argument.
03:15 - Specifically at the end, can't
go in the beginning like dash-O.
03:18 - And dash-L stands for link.
03:20 - And this is a way of telling Clang,
by the way when compiling my program,
03:24 - please link in CS50's zeros
and ones that we the staff
03:28 - wrote some weeks ago and
installed in the sandbox for you.
03:31 - So you've got your
zeros and ones and then
03:33 - you've got our zeros
and ones so to speak.
03:35 - And dash-LCS50 says
to link them together.
03:38 - So if you were getting some kind of
undefined reference error to get_string
03:42 - or you didn't--
03:43 - you weren't able to compile a program
that just used any of the get functions
03:46 - from CS50's library.
03:47 - Odds are, this simple change
dash-LCS50 would have fixed.
03:51 - But of course, this isn't interesting
stuff to remember, let alone
03:54 - remembering how to use dash-0
as well, at which point
03:57 - the command gets really tedious to type.
03:59 - So here comes, Make again.
04:00 - Make automates all of this for us.
04:02 - And in fact, if you henceforth
start running Make and then
04:04 - pay closer attention to the fairly
long line of output that it outputs,
04:08 - you'll actually see
mention of dash-LCS50,
04:11 - you'll see mention of even
dash-LM, which stands for math.
04:14 - So if you're using
round, for instance, you
04:16 - might have discovered
that round two also
04:18 - doesn't work out of the box
unless you use Make itself
04:21 - or this more nuanced approach.
04:25 - So this is all to say that
compiling is a bit of a white lie.
04:28 - Like, yes you've been compiling and
you've been going from source code
04:31 - to machine code.
04:32 - But it turns out that there's been
a number of other steps happening
04:35 - for you that we're going to
just slap some labels on today.
04:37 - At the end of the day, we're
just breaking the abstraction.
04:40 - So compiling is this abstraction
from source code to machine code.
04:42 - Let's just kind of zoom
in briefly to appreciate
04:45 - what it is that's going on in
hopes that it makes the code we're
04:47 - compiling a little more understandable.
04:50 - So step one of four, when it comes
to actually compiling a program
04:54 - is called Pre-processing.
04:55 - So recall that this program we
just looked at had a couple of
04:58 - includes at the top of the file.
05:00 - These are generally known
as pre-processor directives.
05:02 - Not a particularly
interesting term but they're
05:05 - demarcated by the hash at
the start of these lines.
05:08 - That's a signal to Clang that these
things should be handled first.
05:12 - Preprocessed.
05:13 - Process before everything else.
05:15 - And in fact, the reason for this we
did discuss last week, inside of CS50.h
05:20 - is what, for instance?
05:21 - AUDIENCE: [INAUDIBLE]
05:24 - DAVID J. MALAN: Specifically,
the declaration of get strings.
05:27 - So there's some lines of code,
the prototype if you recall,
05:30 - that one line of code that teaches
Clang what the inputs to get_string are
05:34 - and what the outputs are.
05:35 - The return type and the
arguments, so to speak.
05:38 - And so when you have include
CS50.h at the top of the file, what
05:42 - is happening when you first run Clang
during this so-called pre-processing
05:45 - step, is Clang looks on the hard drive
for the file literally called CS50.h.
05:49 - It grabs its contents and essentially
finds and replaces this line here.
05:54 - So somewhere in CS50.h is a
line like this yellow one here
05:58 - that says get_string, is a
function that returns a string.
06:02 - And it takes as input, the
so-called argument, a string
06:05 - that we'll call prompt.
06:06 - Meanwhile, with include standard I/O.
What's the point of including that?
06:10 - What is declared inside
of that file presumably?
06:14 - Yeah?
06:14 - AUDIENCE: It's the standard
inputs and outputs.
06:16 - DAVID J. MALAN: Standard
inputs and outputs.
06:17 - And more specifically,
what example there of?
06:19 - What function?
06:19 - AUDIENCE: [INAUDIBLE]
06:20 - DAVID J. MALAN: So printf.
06:21 - The other function we keep using.
06:22 - So inside of standard io.h,
somewhere on the sandbox's hard drive
06:26 - is similarly a line of code that
frankly looks a little more cryptic
06:29 - but we'll come back
to this sort of thing
06:31 - down the road, that says
print if is a function.
06:33 - Happens to return on int, but
more on that another time.
06:36 - Happens to take a char* format.
06:38 - But more on that another time.
06:40 - Indeed, this is one
of the reasons we hide
06:41 - this detail early on because
there's some syntax that's
06:44 - just a distraction for now.
06:45 - But that's all that's going on.
06:46 - The sharp include sign is just
finding and replacing the contents.
06:50 - Plus dot, dot, dot, a bunch of
other things in those files as well.
06:54 - So when we say
pre-processing, we just mean
06:56 - that that's getting substituted in
so you don't have to copy and paste
06:59 - this sort of thing manually yourself.
07:01 - So "compiling" is a word that
actually has a well-defined meaning.
07:04 - Once you've preprocessed your code, and
your code looks essentially like this,
07:08 - unbeknownst to you, then comes
the actual compilation step.
07:11 - And this code here gets
turned into this code here.
07:15 - Now this is scary-looking,
and this is the sort of thing
07:18 - that if you take a class
like CS61 at Harvard,
07:21 - or, more generally, systems
programming, so to speak,
07:23 - you might see something like this.
07:25 - This is x86 64-bit
assembly instructions.
07:28 - And the only thing interesting
about that claim for the moment
07:31 - is that assembly--
07:32 - I kind of alluded to that
earlier-- assembler output, a.out.
07:35 - There's actually a relationship
here, but long story short, these
07:38 - are the lower level
instructions that only the CPU,
07:41 - the brain inside your
computer, actually understands.
07:44 - Your CPU does not understand C. It
doesn't understand Python or C++
07:48 - or Java or any language with
which you might be familiar.
07:50 - It only understands this
cryptic-looking thing.
07:53 - But frankly, from the looks of it, you
might glean that probably not so much
07:56 - fun to program in this.
07:58 - I mean, arguably, it's not that
much fun to program yet in C,
08:00 - So this looks even more cryptic.
08:03 - But that's OK.
08:04 - C and lots of languages
are just these abstractions
08:07 - on top of the lower level
stuff that the CPUs do actually
08:10 - understand so that we don't
have to worry about it as much.
08:13 - But if we highlight a few terms,
here you'll see some familiar things.
08:16 - So main is mentioned in this
so-called assembly code.
08:19 - You see mention of
get string and printf,
08:21 - so we're not losing information.
08:23 - It's just being presented in really a
different language, assembly language.
08:27 - Now you can glean, perhaps, from some
of the names of these instructions,
08:31 - this is what Intel Inside means.
08:33 - When Intel or any brand of
CPU understands instructions,
08:37 - it means things like pushing and
moving and subtracting and calling.
08:42 - These are all low
level verbs, functions,
08:44 - if you will, but at
the level of the CPU.
08:46 - But for more on that, you
can take entire courses.
08:48 - But just to take the hood
off of this for today,
08:51 - this is a step that's been happening
for us magically unbeknownst
08:54 - to us, thanks to Clang.
08:57 - So assembling-- now that you've got this
cryptic-looking code that we will never
09:00 - see again-- we'll never
need to output again--
09:02 - what do you do with it?
09:03 - Well, you said earlier that computers
only understand zeros and ones,
09:07 - so the third step is actually to convert
this assembly language to actual zeros
09:12 - and ones that now look like this.
09:15 - So the assembling step
happening, unbeknownst to you,
09:17 - every time you run
Clang or, in turn, run
09:19 - make, we're getting zeros and
ones out of the assembly code,
09:22 - and we're getting the assembly
code out of your C-code.
09:25 - But here's the fourth and final step.
09:28 - Recall that we need to link in
other people's zeros and ones.
09:32 - If you're using printf
you didn't write that.
09:34 - Someone else created those
zeros and ones, the patterns
09:36 - that the computer understands.
09:38 - You didn't create get string.
09:39 - We did, so you need access
to those zeros and ones
09:41 - so that your program
can use them as well.
09:44 - So linking, essentially, does this.
09:45 - If you've written a program--
for instance, hello.c--
09:48 - and it happens to use a
couple of other libraries,
09:51 - files that other people
wrote of useful code
09:53 - for you, like cs50.c,
which does exist somewhere,
09:57 - and even stdio.c, which
does exist somewhere,
10:00 - or technically, Standard
IO is such a big library,
10:03 - they actually put printf in a
file specifically called printf.c.
10:06 - But somewhere in the sandbox's hard
drive, in all of our Macs and PCs,
10:10 - if they support compiling, are,
for instance, files like these.
10:14 - But we've got to convert this to
zeros and ones, this, and this,
10:18 - and then somehow combine them.
10:19 - So pictorially, this just
looks a bit like this.
10:21 - And this is all happening
automatically by Clang.
10:23 - Hello.c, the code you
wrote, gets compiled
10:25 - to assembly, which then gets assembled
into zeros and ones, so-called machine
10:31 - code or object code.
10:32 - Cs50.c-- we did this for you
before the semester started.
10:36 - Printf was done way before
any of us started decades
10:39 - ago and looks like this.
10:41 - These are three separate files,
though, so the linking step literally
10:44 - means, link all of these things
together, and combine the zeros
10:48 - and ones from, like, three,
at least, separate files,
10:51 - and just combine them
in such a way that now
10:53 - the CPU knows how to use not just
your code but printf and get string
10:57 - and so forth.
10:59 - So last week, we introduced
compiling as an abstraction,
11:02 - if you will, and this is all that
we've really meant this whole time.
11:05 - But now that we've seen what's
going on underneath the hood,
11:08 - and we can stipulate that
my CPU that looks physically
11:11 - like this, albeit smaller
in a laptop or desktop,
11:14 - knows how to deal with all of that.
11:17 - So any questions on these four steps--
11:19 - pre-processing, compiling,
assembling, linking?
11:22 - But generally, now, we can just call
them compiling, as most people do.
11:27 - Any questions?
11:28 - Yeah.
11:29 - AUDIENCE: How does the CPU
know that [INAUDIBLE] is there?
11:36 - Is that [INAUDIBLE]?
11:39 - DAVID J. MALAN: Not in
the pre-processing step,
11:41 - so the question is,
how does the computer
11:43 - know that printf is the
only function that's there?
11:46 - Essentially, when
you're linking in code,
11:49 - only the requisite zeros and
ones are typically linked in.
11:51 - Sometimes you get more than you
actually need, if it's a big library,
11:55 - but that's OK, too.
11:56 - Those zeros and ones are
just never used by the CPU.
11:58 - Good question.
11:59 - Other questions?
12:02 - OK, all right.
12:03 - So now that we know this
is possible, let's start
12:06 - to build our way back
up, because everyone here
12:09 - probably knows now that
when writing in C, which
12:11 - is kind of up here
conceptually, like, it
12:13 - is not without its hurdles and
problems and bugs and mistakes.
12:16 - So let's introduce a few techniques and
tools with which you can henceforth,
12:19 - starting this week and beyond, trying
to troubleshoot those problems yourself
12:23 - rather than just trying to read through
the cryptic-looking error messages
12:26 - or reach out for help to another human.
12:28 - Let's see if software can actually
answer some of these questions for you.
12:31 - So let me go ahead and do this.
12:32 - Let me go ahead and
open up a sandbox here,
12:35 - and I'm going to go ahead
and create a new file called
12:38 - buggy0.c in which I will, this
time, deliberately introduce a bug.
12:43 - I'm going to go ahead and
create my function called
12:46 - main, which, again, is the default,
like when green flag is clicked.
12:50 - And I'm going to go ahead and
say, printf, quote, unquote,
12:53 - "Hello world/m."
12:56 - All right.
12:56 - Looks pretty good.
12:57 - I'm going to go ahead and
compile buggy0, Enter,
13:01 - and of course, I get a bunch
of error messages here.
13:03 - Let me zoom in on them.
13:05 - Fortunately, I only have two, but
remember, you have to, have to,
13:07 - have to always scroll
up to look at the first,
13:09 - because there might just be an annoying
cascading effect from one earlier
13:12 - bug to the later.
13:13 - So buggy0.c, line 5, is what this
means, character 5, so like 5 spaces in,
13:18 - implicitly declaring library
function printf with dot, dot, dot.
13:22 - So you're going to start to see
this pretty often if you make
13:24 - this particular mistake or oversight.
13:27 - Implicitly declaring
something means you forgot
13:29 - to teach Clang that something exists.
13:31 - And you probably know from experience,
perhaps now, what the solution is.
13:36 - What's the first mistake I made here?
13:38 - AUDIENCE: [INAUDIBLE].
13:39 - DAVID J. MALAN: Yeah, I didn't
include the header file,
13:42 - so to speak, for the library.
13:43 - I'm missing, at the top of
the file, include stdio.h,
13:47 - in which printf is defined.
13:49 - But let's propose that you're not
quite sure how to get to that point,
13:53 - and how can we get, actually,
some help with this?
13:55 - Let me actually increase
the size of my terminal
13:57 - here, and recall that just a
moment ago, I ran makebuggy0,
14:00 - which yielded the errors that I saw.
14:02 - It turns out that
installed in the sandbox
14:04 - is a command that we, the
staff, wrote called help50.
14:07 - And this is just a program we
wrote that takes as input any error
14:11 - messages that your code or
some program has outputted.
14:14 - We kind of look for
familiar words and phrases,
14:16 - just like a TF would in office hours,
and if we recognize some error message,
14:20 - we're going to try to provide,
either rhetorically or explicitly,
14:24 - some advice on how to handle.
14:25 - So if I go ahead and run this command
now, notice there's a bit more output.
14:29 - I see exactly the same output in
white and green and red as before,
14:33 - but down below is some yellow, which
comes specifically from help50.
14:36 - And if I go ahead and
zoom in on this, you'll
14:38 - see that the line of
output that we recognized
14:43 - is this one, that same one
I verbally drew attention
14:46 - to before-- buggy0.c, line 5, error,
implicitly declaring library function
14:50 - printf, and so forth.
14:52 - So here, without the background
highlighting, but still in yellow,
14:54 - is our advice or a question a TF or
CA might ask you in office hours.
14:58 - Well, did you forget to
include stdio.h in which printf
15:02 - is declared atop your file?
15:05 - And hopefully, our questions,
rhetorical or otherwise, are correct,
15:08 - and that will get you further along.
15:10 - So let's go ahead and try that advice.
15:12 - So include stdio.h.
15:15 - Now let me go ahead
and go back down here.
15:16 - And if you don't like
clutter, you can type "clear,"
15:19 - or hit Control+L in the terminal
window to keep cleaning it like I do.
15:23 - If you want to go ahead now and run
makebuggy0, Enter, fewer errors,
15:29 - so that's progress, and not the same.
15:30 - So this one's, perhaps, a little easier.
15:33 - Reading the line, what
line of code is buggy here?
15:36 - AUDIENCE: Forgot the semicolon.
15:38 - DAVID J. MALAN: Yeah, so this is
now still on line 5, it turns out,
15:41 - but for a different reason.
15:42 - I seem to be missing a semi-colon.
15:44 - But I could similarly ask
help50 for help with that
15:47 - and hope that it recognizes my error.
15:48 - So this, too, should start
being your first instinct.
15:50 - If on first glance, you
don't really understand
15:52 - what an error message is
doing, even though you've
15:54 - scrolled to the very first one, like
literally ask this program for help
15:57 - by rerunning the exact
same command you just
15:59 - ran, but prefix it with
help50 and a space,
16:03 - and that will run help50 for you.
16:05 - Any questions on that process?
16:08 - All right, let's take a
look at one other program,
16:10 - for instance, that, this time, has
a different error involved in it.
16:15 - So how about-- let me go ahead
and whip up a quick program here.
16:19 - I'll call this buggy2.c for
consistency with some of the samples
16:23 - we have online for you later.
16:25 - And in this example, I'm going to
go ahead and write the correct thing
16:29 - at first, stdio.h, and then I'm
going to have int main void, which
16:33 - just gets my whole program started.
16:35 - And then I'm going to have
a loop, and recall for--
16:37 - [CLEARS THROAT] excuse me--
Mario or some other program,
16:40 - you might have done something like int
i get 0, i is less than or equal to--
16:44 - let's do this 10 times, and then i++.
16:47 - And all I want to do in this program is
print out that value of i, as I can do,
16:53 - with the %i placeholder--
so a simple program.
16:55 - Just want it to count from 0 to 10.
16:59 - So let's go ahead and run
buggy2, or rather, I want to--
17:04 - let's not print up--
17:06 - rewind.
17:07 - Let's go ahead and just
print out a hash symbol
17:12 - and not spoil the solution this way.
17:15 - So here, I go ahead
and print out buggy2.
17:17 - My goal is now I will stipulate to print
out just 10 hash symbols, one per line,
17:21 - which is what I want to do here.
17:23 - And now I'm going to go ahead and run
./buggy2, and I should see, hopefully,
17:28 - 10 hashes.
17:30 - And I kind of spoiled this a little
bit, but what do I instead see?
17:36 - Yeah, I think I see more than I expect.
17:39 - And we can kind of zoom in here and
double check, so 1, 2, 3, 4, 5, 6, 7,
17:46 - 8, 9, 10, ooh, 11.
17:48 - 11.
17:49 - Now some of your eyes might already be
darting to what the solution should be,
17:53 - but let's just propose
that it's not obvious.
17:55 - And if it is actually not obvious,
all the better, so how might
17:57 - you go about diagnosing this
kind of problem, short of just
17:59 - reaching out and asking
a human for help.
18:02 - This is not a problem
that help50 can help with,
18:04 - because it's not an error message.
18:06 - Your program is working.
18:07 - It's just not outputting
what you wanted it to work,
18:09 - but it's not an error message from the
compiler with which help50 can help.
18:13 - So you want to kind of get eyes
into what your program is doing,
18:17 - and you want to understand, why
are you printing 11 when you really
18:20 - are setting this up from 0 to 10?
18:22 - Well, one of the most common
techniques in C or any language,
18:25 - honestly, is to use printf for just
other purposes-- diagnostic purposes.
18:29 - For instance, there's not
much going on in this program,
18:32 - but I'd argue that it would
be interesting for me to know,
18:35 - and therefore understand
my program, by just,
18:37 - let's print out this value
of i on each iteration,
18:41 - as by doing the line of
code that I earlier did,
18:44 - and just say something
literally like, i is %i.
18:47 - I'm going to remove this
ultimately, because it's
18:49 - going to make my program
look a little silly,
18:52 - but it's going to help me
understand what's going on.
18:54 - Let me go ahead and recompile
buggy2, ./bugg2, and this time,
19:01 - I see a lot more output.
19:03 - But if I zoom in, now it's kind of--
19:07 - now the computer is essentially
helping me understand what's going on.
19:10 - When i is 0, here's one of them.
19:11 - When i is 1, here's another.
19:13 - I is 2, 3, 4, 5, 6, 7, 8,
9, and that looks good.
19:16 - But if we scroll a little further,
it feels a little problematic
19:19 - that i can also be 10.
19:22 - So what's logically the
bug in this program?
19:24 - AUDIENCE: [INAUDIBLE].
19:25 - DAVID J. MALAN: Yeah.
19:26 - I use less than or equal to, because
I kind of confuse the paradigm.
19:29 - Like programmers tend to
start counting at zero,
19:31 - apparently, but I want to do this
10 times, and in the human world,
19:34 - if I want to do something 10 times,
I might count up to and including 10.
19:38 - But you can't have it both ways.
19:39 - You can't start at zero
and end at 10 if you
19:41 - want to do something exactly 10 times.
19:43 - So there's a couple
of possibilities here.
19:46 - How might we fix this?
19:48 - Yeah, so we could certainly
change it to less than.
19:50 - What's another correct approach?
19:53 - Yeah, so we could leave this alone
and just start counting at one,
19:56 - and if you're not actually printing
the values in your actual program,
19:59 - that might be perfectly reasonable, too.
20:01 - It's just not conventional.
20:03 - Get comfortable with, quickly, just
counting from zero, because that's just
20:06 - what most everyone does these days.
20:08 - But the technique here
is just use printf.
20:11 - Like, when in doubt, literally use
printf on this line, on this line,
20:15 - on this line.
20:15 - Anywhere something is interesting
maybe going on in your program,
20:18 - just use it to print out the
strings that are in your variables,
20:21 - print out the integers that are in
your variables, or anything else.
20:24 - And it allows you to
kind of see, so to speak,
20:26 - what's going on inside
of your program, printf.
20:32 - One last tool-- so it's not
uncommon, when writing code,
20:36 - to maybe get a little sloppy early
on, especially when you're not
20:39 - quite familiar with the patterns.
20:40 - And for instance, if
I go ahead and do this
20:43 - by deleting a whole bunch of whitespace,
even after fixing this mistake
20:47 - by going from zero to 10,
is this program now correct,
20:52 - if the goal is to print 10 hashes?
20:57 - Yeah, I heard yes.
20:57 - Why is it correct?
20:58 - In what sense?
21:02 - Yeah, exactly.
21:03 - It still works.
21:04 - It prints out the 10
hashes, one per line,
21:06 - but it's poorly written
in the sense of style.
21:09 - So recall that we tend to
evaluate, and the world
21:12 - tends to think about code
in at least three ways.
21:14 - One, the correctness-- does it
do what it's supposed to do,
21:16 - like print 10 hashes?
21:17 - And yes, it does, because all
I did was delete whitespace.
21:19 - I didn't actually change or break
the code after making that fix.
21:22 - Two is design, like how thoughtful,
how well-written is the code?
21:25 - And frankly, it's kind of hard
to write this in too many ways,
21:28 - because it's so few lines.
21:29 - But you'll see over time,
as your programs grow,
21:31 - the teaching fellows and staff
can provide you with feedback
21:33 - on the design of your code.
21:35 - But style is relatively easy.
21:36 - And I've been teaching it mostly
by way of example, if you will,
21:39 - because I've been very
methodically indenting my code
21:42 - and making sure everything looks
very pretty, or at least pretty
21:45 - to a trained eye.
21:47 - But this, let's just
stipulate, is not pretty.
21:49 - Like, left aligning everything
still works, not incorrect,
21:53 - but it's poorly styled.
21:54 - And what would be an
argument for not writing code
21:56 - like this and, instead,
writing code the way
21:58 - I did a moment ago, albeit
after fixing the bug?
22:02 - Yeah.
22:02 - AUDIENCE: It'll help you identify
each little subroutine that
22:05 - goes through the thing, so
you know this section is here.
22:10 - DAVID J. MALAN: Yeah.
22:11 - AUDIENCE: [INAUDIBLE] next one,
so you know where everything is.
22:13 - DAVID J. MALAN: Exactly.
22:14 - Let me summarize this.
22:15 - It allows you to see,
more visually, what
22:17 - are the individual subroutines
or blocks of code doing
22:20 - that are associated with each other?
22:22 - Scratch is colorful, and it has
shapes, like the hugging shape
22:25 - that a lot of the control
blocks make, to make
22:27 - clear visually to the programmer
that this block encompasses others,
22:30 - and, therefore, this repeats
block or this forever block
22:34 - is doing these things
again and again and again.
22:36 - That's the role that these curly
braces serve, and indentation
22:38 - in this and in other
contexts just helps it
22:41 - become more obvious to the
programmer what is inside of what
22:45 - and what is happening where.
22:46 - So this is just better
written, because you
22:49 - can see that the code inside of main
is everything that's indented here.
22:52 - The code that's inside the for loop
is everything that's indented here.
22:56 - So it's just for us human
readers, teaching fellows
22:58 - in the case of a course, or colleagues
in the case of the real world.
23:01 - But suppose that you don't quite see
these patterns too readily initially.
23:05 - That, too, is fine.
23:06 - CS50 has on its website
what we call a style guide.
23:09 - It's just a summary of
what your code should
23:11 - look like when using certain
features of C-- loops,
23:14 - conditions, variables,
functions, and so forth.
23:16 - And it's linked on the course's website.
23:18 - But there's also a tool
that you can use when
23:20 - writing your code that'll help you
clean it up and make it consistent,
23:23 - not just for the sake of making it
consistent with the style guide,
23:26 - but just making your
own code more readable.
23:28 - So for instance, if I go
ahead and run a command called
23:31 - style50 on this program,
buggy2.c, and then hit Enter,
23:37 - I'm going to see some
output that's colorful.
23:40 - I see my own code in white,
and then I see, anywhere
23:44 - I should have indented,
green spaces that
23:47 - are sort of encouraging me to put
space, space, space, space here.
23:50 - Put space, space, space, space here.
23:51 - Put eight spaces here, four
spaces here, and so forth,
23:54 - and then it's reminding me I
should add comments as well.
23:56 - This is a short program--
doesn't necessarily
23:58 - need a lot of commenting
to explain what's going on.
24:01 - But just one //, like we
saw last week to explain,
24:04 - maybe at the top of the file
or top the block of the code,
24:06 - would make style50 happy as well.
24:08 - So let's do that.
24:09 - Let me go ahead and take its advice
and actually indent this with Tab,
24:13 - this with Tab, this with Tab,
this with Tab, and this once more.
24:17 - And you'll notice that on your keyboard,
even though you're hitting Tab,
24:20 - it's actually converting it for you,
which is very common to four spaces,
24:23 - so you don't have to hit
the spacebar four times.
24:25 - Just get into the habit of using Tab.
24:27 - And let me go ahead and
write a comment here.
24:30 - "Print 10 hashes."
24:32 - This way, my colleagues, my
teaching fellow, myself in a week
24:35 - don't have to read my own code again
and figure out what it's doing.
24:37 - I can read the comments
alone per the //.
24:40 - If I run style50 again,
now it looks good.
24:44 - It's in accordance with the style guide,
and it's just more prettily written,
24:47 - so pretty printed would be
a term of art in programming
24:50 - when your code looks good
and isn't just correct.
24:53 - Any questions then?
24:55 - Yeah.
24:56 - AUDIENCE: I tried using
[INAUDIBLE] this past week
24:58 - and it said I needed a new program.
25:00 - DAVID J. MALAN: That's--
25:01 - it wasn't enabled for the
first week of the class.
25:04 - It's enabled as of right
now and henceforth.
25:06 - Other questions?
25:08 - No.
25:09 - All right, so just to recap then, three
tools to have in the proverbial toolbox
25:13 - now are help50 anytime you see an error
message that you don't understand,
25:16 - whether it's with make or Clang
or, perhaps, something else.
25:18 - Printf-- when you've
got a logical program--
25:21 - a bug in your program, and it's just
not working the way it's supposed to
25:24 - or the way the problem set tells
you it should, and then style50
25:27 - when you want to make sure that, does
my code look right in terms of style,
25:31 - and is it as readable as possible?
25:33 - And honestly, you'll find us
at office hours and the like
25:35 - often encouraging you, hey,
before we answer this question,
25:38 - can you please run style50 on your code?
25:40 - Can you please clean up your code,
because it just makes our lives, too,
25:43 - as other humans so much easier
when we can understand what's
25:45 - going on without having to visually
figure out what parentheses and curly
25:49 - braces line up.
25:50 - And so do get into
that habit, because it
25:52 - will save you time from having to waste
time parsing things visually yourself.
25:57 - All right.
25:58 - So there's not just CPUs in computers.
26:01 - CPUs are the brains,
central processing unit,
26:03 - and that's why we keep emphasizing the
instructions that computers understand.
26:06 - There's also this, which
we saw last time, too.
26:09 - This is an example of
what type of hardware?
26:12 - AUDIENCE: RAM.
26:12 - DAVID J. MALAN: RAM, or
Random Access Memory.
26:15 - This is the type of memory
that laptops, desktops, servers
26:17 - have that is used whenever you
run a program or open a file.
26:21 - There's another type of memory called
hard drives or solid state drives,
26:25 - which you're probably
familiar as a consumer,
26:27 - and that's just where your
files are stored permanently.
26:29 - Your battery can die.
26:30 - You can pull the plug from
your laptop or desktop,
26:32 - and any files saved on a
hard drive are persistent.
26:35 - They stay there because
of the technology
26:37 - being used to implement that.
26:38 - But RAM is more ephemeral.
26:41 - RAM is powered only by electricity.
26:43 - It's only used when the power
is on or the battery is charged,
26:46 - and it's where your files and
programs live effectively when
26:49 - you double click on them and open them.
26:52 - So when you double click on
something like Microsoft Word,
26:54 - it is copied from your hard drive
long term into this type of memory,
26:59 - because this type of memory,
though smaller in capacity--
27:02 - you don't have as many bytes of it--
27:04 - but it is much, much, much, much faster.
27:06 - Similarly, when you open a
document, or you go to a web page,
27:09 - the contents of the file you're seeing
are stored in this type of hardware,
27:13 - because even though you don't
have terribly many bytes of it,
27:15 - it's just much, much, much, much faster.
27:18 - And so this will be thematic in
computer science and in hardware.
27:20 - You sort of have lots
of cheap, slow stuff,
27:23 - like hard disk space, relatively
speaking, and you have a little less
27:27 - of the more expensive but
faster stuff like RAM.
27:30 - And you have just one, usually, CPU,
which is the really fast thing that
27:33 - can do a billion things per second.
27:34 - But it, too, is more expensive.
27:37 - So there's four visible chips
on this thing, if you will.
27:39 - And we won't get into the details
of how these things work, but let's
27:42 - just zoom in on this one black
chip here and focus on it
27:46 - as being representative
as some amount of memory.
27:48 - Maybe it's one megabyte,
one million bytes.
27:50 - Maybe it's even one gigabyte
these days, one billion bytes.
27:54 - But this is to say that this chip
can be thought of as just having
27:57 - a bunch of bytes in it.
27:58 - This is not to scale.
27:59 - You have many more bytes
than these, but let
28:01 - me propose that you just
think of each of these squares
28:04 - here as representing one byte.
28:06 - So the very first byte of
memory I have access to is here.
28:08 - Next one is here, and so forth.
28:10 - And the fact that they wrap around
is just an artist rendition.
28:13 - These things you can think
of just virtually as going
28:15 - left to right, not in any kind of grid,
but physically, they look like this.
28:19 - So when you actually create a
variable in a program like C,
28:23 - like you need a char.
28:24 - A char tends to be one
byte or eight bits,
28:27 - and so that means when you have a
variable of type char in a C program,
28:32 - it goes, literally, physically
in one of these boxes,
28:35 - inside of your computer's RAM.
28:37 - So for instance, it might take
up this much space at top left.
28:40 - If you have a bigger
type of data, so you
28:42 - have an integer, which tends
to be four bytes or 32 bits,
28:45 - you might need more than one square,
so the computer might give you access
28:48 - to four squares instead.
28:50 - And you have 32 bits spanning
that region of memory.
28:54 - But honestly, I chose
those boxes arbitrarily.
28:56 - They could be anywhere in that
chip or in any of the other chips.
28:58 - It's up to the computer to just
remember where they are for you.
29:01 - You don't need to remember that, per se.
29:04 - But if we think about
this grid, it turns out
29:07 - this is actually very valuable
that we have chunks of memory--
29:10 - bytes, if you will--
29:11 - that are back to back to back to back.
29:13 - And in fact, there's a
word for this technique.
29:16 - This is contiguous memory--
29:17 - back to back to back to back to back.
29:19 - And in general, in programming,
this is referred to as an array.
29:23 - You might recall from Scratch,
if you use this feature,
29:25 - it actually has things
called lists, which
29:27 - are exactly that-- lists of values,
lists of words, lists of strings.
29:30 - An array is just a contiguous
chunk of memory, such
29:33 - that you can store something here,
something here, something here,
29:35 - something here, and so forth.
29:37 - So it turns out an array,
this super simple primitive,
29:41 - is actually incredibly powerful.
29:43 - Just being able to store
things in my computer's memory
29:46 - back to back to back to back enables so
many possibilities, both design-wise,
29:52 - like how well I can write my code, and
also how fast I can make my code run.
29:56 - So let me go ahead and
take out an example.
29:59 - Let me go ahead and open up, for
instance, a new file in a sandbox,
30:04 - and we'll call this score0.
30:06 - So let me go ahead and close this one,
create a new file called scores0.c.
30:12 - And in this file, let's go ahead and
write a relatively simple program.
30:16 - Let me go ahead and, as
usual, give myself access
30:18 - to some helpful functions--
cs50.h and stdio.h.
30:22 - And no need to copy all this
down verbatim, if you don't like.
30:25 - Everything will have or is
already on the course's website.
30:28 - Let me start my program as
usual with int main void.
30:30 - And then let me write a program,
as this program's name implies,
30:33 - that, like, asks the user for three
scores on recent problem sets,
30:38 - quizzes, whatever, and then kind of
creates a very simple chart of them,
30:41 - like a bar chart to kind of
help me visualize how well
30:44 - or how poorly I did on something.
30:46 - So if I want to get an
integer, no surprise,
30:49 - we can use the get int
function, and I can just
30:51 - ask the user for their first score.
30:54 - But I should probably do
something with this score,
30:56 - and on the left hand side of
this, what do I typically put?
31:00 - Yeah.
31:00 - So int-- sure, score 1 equals
this, and then my semi-colon.
31:04 - So you might not have had many
occasions to use ints just yet,
31:07 - but get int is in the cs50 library.
31:09 - This is the so-called
prompt that the human
31:11 - sees, and let me actually
fix my space, because I
31:13 - want the human to see the
space after the colon.
31:16 - But that's just an aesthetic detail.
31:18 - And then when I get back this
value, its return value--
31:21 - just like Aaron, last week,
handed me a piece of paper,
31:23 - so does get int hand me a virtual
piece of paper with a number
31:26 - that I'm going to store in
a variable called Score 1.
31:29 - And now just to be clear, what has
just happened effectively is this.
31:34 - The moment you create a variable
of type int, which is four bytes,
31:39 - literally, this is what
Clang or, more generally,
31:42 - the computer has done for you.
31:44 - That int that the human
typed in is stored literally
31:47 - in four contiguous bytes back to
back to back, maybe here, maybe here,
31:51 - but together.
31:52 - So that's all that's going on
when you're actually using C.
31:55 - So let me go back into
my code here, and now I
31:58 - want to-- it's not
interesting to plot one score.
32:00 - So let's go ahead and do another.
32:01 - So int Score 2, get int, get int,
and I'll ask the user for score 2,
32:08 - semi-colon, and then let's get one
more, Score 3, get int, call it Score 3,
32:13 - semi-colon.
32:14 - All right, so now let me go
ahead and generate a bar,
32:17 - like a bar chart of this.
32:18 - I'm going to use what
we'll call ASCII art.
32:20 - ASCII, of course, is just text, recall--
32:22 - very simple text in a computer.
32:23 - And I can kind of make a bar chart
pretty simply by just printing out
32:27 - like a bunch of hashes
horizontally, so a short bar
32:30 - will represent a small number, and a
long bar will represent a big number.
32:34 - So let me go ahead and say to the
user, all right, here's your Score 1.
32:38 - I'm going to go ahead, then,
and say, for int i get 0.
32:41 - I is less than Score 1, i++.
32:46 - And now if I scroll down and
give myself a bit of room here,
32:48 - let me go ahead and implement
just a simple print.
32:53 - So go ahead and print out a hash, and
then when you're all done with that,
32:57 - print out a new line at
the end of that loop.
33:01 - And let's just pause there.
33:03 - Just to recap, I've asked
the human for three scores.
33:05 - I'm only doing something with one
of them at the moment, so in fact,
33:09 - just as a quick check, let me delete
those so as to not get ahead of myself.
33:13 - Let me do make score 0.
33:15 - Cross my fingers.
33:16 - OK, no errors.
33:17 - Now let me go ahead and do ./score0,
and your first score on a pset this year
33:22 - out of 100 has been?
33:24 - OK, 100.
33:26 - And good job.
33:27 - So it's a really long bar,
and if we count those up,
33:29 - hopefully, there's actually 100 bars.
33:31 - And if we run it again and
say, eh, it didn't go so well.
33:33 - I got a 50.
33:35 - That's half as big a bar.
33:36 - So it seems like we're on
our way correctness-wise.
33:39 - So now let me go ahead
and get the other scores.
33:41 - Well, I had them here a moment ago.
33:42 - So let me go ahead and just, well,
copy, paste, and change this to two,
33:46 - change this to three, change
this to three, this to three.
33:50 - All right, I know how to print
bars clearly, so let me go ahead
33:53 - and do this, and then do this,
and then fix the indentation.
33:56 - I don't want to say Score 1 everywhere.
33:58 - I want to say a Score 2, Score 2.
34:00 - I mean you're probably being
rubbed the wrong way that this
34:03 - is both tedious and sloppy, and why?
34:06 - What am I doing poorly now design-wise?
34:07 - AUDIENCE: Copying and pasting code.
34:09 - DAVID J. MALAN: Like copy-pasting
almost always bad, right?
34:11 - There's redundancy
here, but that's fine.
34:13 - Let's prioritize correctness,
at least, for now.
34:15 - So let me go ahead and make Score 0.
34:18 - All right, no mistakes-- ./score0.
34:21 - And then Tab it.
34:22 - Let me go ahead now and run--
34:24 - OK, we got 100 the first time.
34:26 - We got 50 the--
34:27 - oh, that's a bug.
34:29 - What did I do there?
34:31 - See, this is what happens
when you copy-paste.
34:33 - So let's fix this.
34:34 - That should say Score 2, so
Control+C will quit a program.
34:37 - Make score 0 will
recreate it. ./0, Enter--
34:42 - all right, here we go.
34:43 - 100, 50.
34:44 - Let's split the difference--
34:46 - 75.
34:47 - All right, so this is a simple
bar chart horizontally drawn
34:51 - of each of my three scores, where this
is 100, this is 50, and this is 75.
34:55 - But there's opportunities
for improvement here.
34:57 - So one, it rubbed some
folks the wrong way
34:59 - already that we were literally
copying and pasting code.
35:05 - So where is one opportunity
for improvement here?
35:09 - What should I do instead of copying
and pasting that code again and again?
35:13 - What ingredient can you bring?
35:15 - OK, so we can use a loop and actually
just do the same thing three times.
35:19 - So let's try that.
35:22 - Let me go ahead and do this.
35:25 - So let's go ahead and
delete the copy-paste I did,
35:28 - and let me go ahead and say, OK, well,
for int i get zero, i less than 3, i++.
35:35 - Let me create a bracket.
35:37 - I can highlight multiple
lines and hit Tab,
35:39 - and they'll all indent for
me, which is convenient.
35:41 - And can I do this now, for instance?
35:48 - Say it a little louder.
35:50 - AUDIENCE: If you [INAUDIBLE]
to a specific [INAUDIBLE]..
35:54 - DAVID J. MALAN: Yeah,
I'm a little worried.
35:56 - As you're noting here, we're using on
line 13 here the same variable, so mm.
36:01 - So it's good instincts,
but I feel like the fact
36:03 - that this program,
unlike last week, we're
36:05 - now collecting multiple pieces of data.
36:06 - Loops are breaking down for us.
36:08 - Yeah.
36:08 - AUDIENCE: [INAUDIBLE] function
[INAUDIBLE] takes in--
36:13 - like you can have it [INAUDIBLE].
36:16 - DAVID J. MALAN: OK.
36:17 - AUDIENCE: So like an input of how
many scores you wanted to enter.
36:20 - DAVID J. MALAN: OK.
36:21 - AUDIENCE: And then [INAUDIBLE].
36:23 - DAVID J. MALAN: Yeah,
we can implement another
36:25 - function that factors out
some of this functionality.
36:27 - Any other thoughts?
36:28 - AUDIENCE: Store your scores in an array.
36:30 - DAVID J. MALAN: OK, so we could
also store our scores in an array.
36:33 - So let's do these in
order then, in fact.
36:34 - So loops are wonderful when you
want to do something again and again
36:37 - and again, but the whole
purpose of a function,
36:39 - fundamentally, is to factor
out common functionality.
36:43 - And there might still be
a loop in the solution,
36:45 - but the real fundamental problem
with what I was doing a moment ago
36:48 - was I was copying and
pasting functionality--
36:50 - shouldn't need to do that,
because in both C and Scratch,
36:52 - we had the ability to
make our own functions.
36:54 - So let's do that.
36:55 - Let me undo my loop changes
here, just to get us
36:58 - back to where we were a moment ago.
36:59 - And let me go ahead and, instead,
clean this up a little bit.
37:02 - Let me go ahead and
create a new function
37:04 - down here that I'm going
to call, say, Chart, just
37:07 - to create a chart for myself.
37:09 - And it's going to take as input a score,
but I could call this anything I want.
37:12 - It's void as its return type, because
I don't need it to hand me something
37:15 - back.
37:16 - Like I'm not getting a
string from the user.
37:18 - I'm just printing a char.
37:19 - It's a so-called side effect or output.
37:21 - Now I'm going to go ahead and
do my loop here for int i get 0.
37:25 - I is less than--
37:27 - how many hashes do I want to print if
I'm being passed in the user score?
37:32 - Like, is this 3 here?
37:34 - AUDIENCE: The score.
37:35 - DAVID J. MALAN: The
score, so if I'm being
37:37 - handed a number that's 0 to 100,
that's what I want to iterate over.
37:40 - If my goal here, ultimately--
37:43 - let me finish this thought-- i++ is
[? 2 ?] inside this loop print out one
37:48 - hash per point in 1's total score.
37:52 - And just to keep things clean,
I'm going to go ahead and put
37:54 - a new line at the very end of this.
37:56 - But I think now, I factored out
a good amount of the redundancy.
37:59 - It's not everything,
but I've at least now
38:01 - given myself a function called Chart.
38:04 - So up here, it looks like I can
kind of remove this loop, which
38:08 - is what I factored out.
38:10 - That's almost identical, except
the variable name was hardcoded.
38:13 - And I think I could
now do chart like this,
38:18 - and then I maybe could do a little
copy-paste, if that's OK, like if maybe
38:22 - I can get away with just doing this,
and then say 2, and then say 3,
38:28 - and then say 3, and then say 2.
38:30 - So it's still copy-paste, but it's less.
38:32 - And it looks better.
38:33 - It literally fits on the screen, so it's
progress-- not perfect, but progress.
38:36 - Better design, but not perfect.
38:38 - So is this going to compile?
38:42 - I'm going to have errors why?
38:44 - AUDIENCE: Essentially, it's
[INAUDIBLE] the program [INAUDIBLE]..
38:47 - DAVID J. MALAN: OK.
38:49 - Yeah.
38:50 - AUDIENCE: We need to
declare a [INAUDIBLE]..
38:52 - DAVID J. MALAN: OK, good.
38:53 - So let me induce the actual error, just
so we know what problem we're solving.
38:58 - Let me go ahead and sort
of innocently go ahead
39:00 - and compile Score 0 hoping
all is well, but of course,
39:03 - it's not because of a
familiar error up here.
39:07 - So notice, implicit declaration of
function chart is invalid in C99.
39:12 - So again, implicit
declaration of function
39:14 - just tends to mean Clang does not
know what you're talking about.
39:18 - And you could run help50,
and it would probably
39:20 - provide you with similar advice.
39:22 - But the gist of this is that
chart is not a C function.
39:25 - It doesn't come with C. I wrote it.
39:27 - I just wrote it a little too late.
39:29 - So one solution that we
didn't used last week
39:32 - would be, OK, well, if you don't
know what chart is, let me just
39:35 - go put it where you'll know about it.
39:37 - And now run make score 0.
39:40 - OK, problem solved.
39:42 - So that fixes it, but we fixed
it in a different way last week.
39:46 - And why might we want to stick
with last week's approach
39:48 - and not just copy-paste
my function and put it
39:50 - at the top instead of the bottom?
39:55 - AUDIENCE: [INAUDIBLE].
39:57 - DAVID J. MALAN: Yeah, I mean it's
kind of a minor concern at the moment,
40:00 - because this is a pretty short program.
40:02 - But I'm pushing the main part of
my program, literally called Main,
40:06 - farther and farther down.
40:07 - And the whole point of reading code
is to understand what it's doing.
40:10 - So if I open this file, and I have to
scroll, scroll, scroll, scroll, scroll,
40:13 - just looking for the main
function, it's just bad style.
40:16 - It's just kind of nice, and
it's a good human convention.
40:18 - Put the main code, the main function,
when green flag clicks equivalent,
40:22 - at the very top.
40:23 - So C does offer us a solution here.
40:25 - You just have to provide
it with a little hint.
40:27 - Let me go ahead and cut this from here,
put it back down at the bottom here,
40:32 - and then go ahead and copy-paste
only or retype only the value--
40:38 - whoops-- the value of that first line,
which is its so-called prototype.
40:43 - Give Clang enough information so that
it knows what arguments the function
40:47 - takes, what its return type is,
and what its name is, semi-colon,
40:50 - and that's the so-called
declaration or--
40:53 - and then implement it with the curly
braces and all the logic down below.
40:58 - So let's go ahead and run this.
40:59 - And if I scroll up here,
we'll see-- whoops.
41:03 - We'll see make score 0.
41:05 - All right, now we're
on our way, score 0.
41:08 - Enter.
41:08 - Score 1 is 100, 50, 75, and now we
seem to have some good functionality.
41:13 - But there's still an opportunity,
I dare say, for improvement.
41:17 - And I think the fundamental
problem is that I'm still
41:19 - copy-pasting the little
stuff, but I think
41:21 - the fundamental problem is that I
don't have the expressiveness to store
41:26 - multiple values, unless I, in
advance, as the programmer,
41:30 - give them all unique names, because if
I use the same variable for everything,
41:34 - I couldn't collect all
three variables at the top,
41:37 - and then iterate over all three at the
bottom, if I only have one variable.
41:40 - So I do need three variables,
but this doesn't scale very well.
41:43 - And who knows?
41:44 - If I want to take in five scores,
10 scores, or more scores,
41:47 - then I'm really copying
and pasting excessively.
41:51 - So it turns out, indeed,
the answer is an array.
41:53 - So an array, at the
end of the day, is just
41:55 - a side effect of storing stuff in
memory back to back to back to back.
41:59 - But what's powerful about this
reality of memory is the following.
42:03 - I can go ahead here and in,
say, a new and more improved
42:07 - version of this program, do this.
42:10 - Let me go ahead and open this one, which
I wrote in advance, called scores2.c.
42:14 - And in scores2.c, notice
we have the following code.
42:18 - In my main function, I've got a new
feature and a new bit of syntax.
42:23 - This line here that I've
highlighted says, hey, Clang,
42:26 - give me a variable called
Scores of type integer,
42:30 - but please give me three of them.
42:32 - So the new syntax are
your square brackets,
42:34 - and inside of which is the number
of variables you want of that type.
42:37 - And you don't have to
give them unique names.
42:39 - You literally call them
collectively, Scores,
42:41 - and in English, I deliberately
chose a plural to connote as much.
42:44 - This is an array of
values, not a single value.
42:48 - What can I do next?
42:49 - Well, here's my for loop for int
i get zero i is less than 3 i++,
42:53 - and now I've solved that earlier
problem that was proposed.
42:56 - Well, just put it in a loop.
42:57 - Now I can, because now my variables are
not called Score 1, Score 2, Score 3,
43:02 - which I literally had to hard code.
43:04 - They're just called Scores, and
now that they're called Scores,
43:07 - and I have this square bracket
notation, notice what I can do.
43:10 - I can get an int, and I can say, give
me score%i, and plug in i plus 1.
43:15 - I didn't want to say
"zero," because humans
43:17 - don't count from zero in general.
43:18 - So this is counting from one, two, and
three, but the computer is doing this.
43:24 - So Scores is a variable.
43:25 - Bracket, i, close bracket says
store the i-th value there.
43:32 - So i-th is just non-English.
43:33 - That means go to bracket
0, bracket 1, bracket 2.
43:36 - So what this effectively means is on
the first iteration of the loop, when
43:40 - i equals 0, this looks
like this, effectively.
43:44 - When i then becomes 1 on the next
iteration, then you're doing this.
43:48 - When i becomes 2 on the final
iteration, it looks like this.
43:51 - When i becomes 3, well,
3 is not less than 3,
43:54 - and so it doesn't execute again.
43:57 - So by using i inside of these square
brackets, am I indexing into an array?
44:03 - To index into an array means
go to a specific location,
44:06 - the so-called i-th location,
but you start counting at zero.
44:09 - Just to make this more
real, then, if you go back
44:12 - to this picture of
your computer's memory,
44:14 - this might, therefore,
be bracket i, bracket 1--
44:18 - bracket 0, bracket 1, bracket 2, bracket
3, bracket 4, bracket 50, or wherever.
44:23 - You can now, using square brackets,
get at any of these blocks of memory
44:27 - to store values for you.
44:30 - Any questions on what we've just done?
44:34 - All right, then on the flip side,
we can do the exact same thing.
44:37 - Now when I print my scores, I can
similarly iterate from 0 to 3,
44:42 - and then print out the
scores by passing to chart
44:45 - the same value, the i-th score.
44:48 - Again, the only new syntax here
is variable name, square bracket,
44:51 - and then a number, like 0,
1, 2, or a variable like i,
44:54 - and then my chart function
down here is exactly the same.
44:57 - It has no idea an array is
even involved, because I'm just
45:00 - passing in one score at a time.
45:04 - Now it turns out there's still one
bad design decision in this program.
45:08 - There's still some redundancy,
something that I keep typing again
45:12 - and again and again.
45:14 - Do any values jump out
at you as repeated?
45:19 - AUDIENCE: The for loop.
45:20 - DAVID J. MALAN: The for loop.
45:21 - OK, so I've got the for
loop in multiple places.
45:24 - Sure.
45:25 - And what other value seems
to be in multiple places?
45:29 - It's subtle.
45:32 - Total number.
45:33 - Yeah, 3.
45:34 - Three is in a few places.
45:35 - It's up here.
45:36 - It's when I declare the array
and ask myself for three scores.
45:41 - It's here when I'm iterating.
45:44 - It's not here, because this
is a different iteration.
45:46 - That's just for the hashes.
45:48 - So in, ironically, three
places, have I written 3.
45:51 - So what does this mean?
45:52 - Well, suppose next year you
take more tests or whatever,
45:54 - and you need more scores.
45:55 - You open up your program, and all right,
now I've got five scores and five--
46:00 - whoops, typo already-- five,
like this kind of pattern
46:04 - where you're typing the
same thing again and again.
46:06 - And now the onus is
on me, the programmer,
46:08 - to remember to change the same
[? damn ?] value in multiple places--
46:11 - bad, bad, bad design.
46:12 - You're going to miss
one of those values.
46:14 - Your program's going
to get more complex.
46:15 - You're going to leave one at
3 and change the other to 5,
46:18 - and logical errors are
eventually going to happen.
46:20 - So how do we solve this?
46:21 - The function's not the solution
here, because it's not functionality.
46:24 - It's just a value.
46:25 - Well, we could use a variable,
but a certain type of variable.
46:28 - These numbers here--
5, 5, 5 or 3, 3, 3--
46:32 - are what humans generally
refer to as magic numbers.
46:34 - Like they're numbers, but
they're kind of magical,
46:36 - because you just arbitrarily
hardcoded them in random places.
46:39 - But a better convention would be, often
as a global variable, to do this--
46:44 - int, let's call it "count," equals 3.
46:47 - So declare a variable of type
int that is the number of things
46:51 - you want, and then type that variable
name all throughout your code
46:55 - so that later on, if you ever
want to change this program,
46:58 - you change it-- whoops--
in one place, and you're
47:01 - done after recompiling the program.
47:03 - And actually, I should do
a little better than this.
47:05 - It turns out that if you know you have
a variable that you're never going
47:08 - to change, because it's
not supposed to change--
47:10 - it's supposed to be a constant value--
47:12 - C also has a special keyword called
const, where before the data type,
47:16 - you say, const int, and then the name
and then the value, and this way,
47:20 - the compiler, Clang, will
make sure that you, the human,
47:22 - don't screw up and accidentally try
to change the count anywhere else.
47:27 - There's one other thing notable.
47:28 - I also capitalize this whole
thing for some reason--
47:30 - human convention.
47:31 - Anytime you capitalize all of
the letters in a variable name,
47:34 - the convention is that
that means it's global.
47:36 - That means it's defined way up top,
and you can use it anywhere, therefore,
47:40 - because it's outside all curly braces.
47:42 - But it's meant to imply and
remind you that this is special.
47:46 - It's not just a so-called
local variable inside
47:48 - of a function or inside
of a loop or the like.
47:52 - Any questions on that?
47:54 - Yeah.
47:55 - AUDIENCE: What is [INAUDIBLE]?
47:56 - Why do you have i plus 1?
47:57 - DAVID J. MALAN: Oh,
why do I have i plus 1?
47:59 - Let me run this program real quick.
48:01 - Why do I have i plus 1 in this
line here, is the question.
48:05 - So let me go ahead and
run make scores 2--
48:07 - whoops-- in my directory.
48:09 - Make scores 2 ./scores2, Enter.
48:13 - I wanted just the human to see
Score 1 and Score 2 and Score 3.
48:18 - I didn't want him or her to see Score 0,
Score 1, Score 2, because it just looks
48:22 - lame to the human.
48:23 - The computer needs to
think in terms of zeros.
48:25 - My humans and my users do
not, so just an aesthetic.
48:29 - Other questions.
48:29 - Yeah.
48:30 - AUDIENCE: [INAUDIBLE].
48:37 - DAVID J. MALAN: Ah,
really good question.
48:39 - And I actually thought
about this last night
48:40 - when trying to craft this example.
48:43 - Why don't I just combine
these two for loops,
48:45 - because they're clearly iterating
an identical number of times?
48:50 - Was this a hand or just a stretch?
48:52 - No, stretch.
48:53 - So this is actually deliberate.
48:57 - If I combine these, what would
change logically in my program?
49:01 - Yeah.
49:02 - AUDIENCE: After every [INAUDIBLE]
input, you would [INAUDIBLE]..
49:05 - DAVID J. MALAN: Yeah, so after
every human input of a score,
49:08 - I would see that user's
chart, the row of hashes.
49:11 - Then I'd ask them for another value.
49:13 - They'd see the chart, another
value, and they'd see the chart.
49:15 - And that's fine, if that
is the design you want.
49:17 - Totally acceptable.
49:18 - Totally correct.
49:19 - I wanted mine to look a little more
traditional with all of the bars
49:22 - together, so I effectively had
to postpone printing the hashes.
49:25 - And that's why I did have
a little bit of redundancy
49:27 - by getting the user's input
here and then iterating again
49:30 - to actually print the user's output
as a chart, so just a design decision.
49:34 - Good question.
49:35 - Other questions?
49:37 - All right, so what does this look like?
49:40 - Actually, you know what?
49:41 - I can probably do a little better.
49:42 - Let me open up one final example
involving scores and this thing
49:45 - called an array.
49:46 - In Scores 4 here, let
me go ahead and do this.
49:52 - Now I've changed my chart
function to do a little bit more,
49:55 - and you might recall from week 0
and 1, we had the call function,
49:58 - and we kept enhancing
it to do more and more,
50:00 - like putting more and
more logic into it.
50:02 - Notice this.
50:04 - Chart function now takes a second
argument, which is kind of interesting.
50:08 - It takes one argument,
which is a number,
50:10 - and then the next argument
is an array of scores.
50:13 - So long story short, if you
want to have a function that
50:16 - takes as input an array,
you don't have to know
50:18 - in advance how big that array is.
50:20 - You should not, in fact, put a
number in between the square brackets
50:23 - in this context.
50:24 - But the thing is you do
need to know, at some point,
50:27 - how many items are in the array.
50:29 - If you've programmed in Java, took
AP CS, Java just gives you .length,
50:32 - if you recall that feature of objects.
50:35 - C does not have this.
50:36 - Arrays do not have an inherent
length associated with them.
50:39 - You have to tell everyone who
uses your array how long it is.
50:44 - So even though you don't
do that syntactically here,
50:46 - you literally just say, I expect
an argument called scores that
50:50 - is an array per the square brackets.
50:53 - You have to pass and almost
always a second variable
50:55 - that is literally called
whatever you want,
50:57 - but is the number of
things in that array,
50:59 - because if the goal of
this function is just
51:02 - to iterate over the number
of scores that are passed in,
51:09 - and then iterate over the
number of points in that score
51:12 - in order to print out the hashes,
you need to know this count.
51:16 - So what does this function
do, just to be clear?
51:19 - This iterates over the total
number of scores from 0 to count,
51:22 - which is probably 3 or 5 or whatever.
51:24 - This loop here, using J,
which is just a convention,
51:27 - instead iterates from 0 to
whatever that i-th score is.
51:32 - So this is what's convenient.
51:33 - Now I've passed in the array, and I
can still get at individual values
51:38 - just by using i, because I'm
on my i-th iteration here.
51:41 - So you might recall this from Mario,
for instance, or any other example
51:44 - in which you had nested loops--
51:46 - just very conventional to use i
on the outside, j on the inside.
51:50 - But again, the only point here is that
you can, indeed, pass around arrays,
51:54 - even as arguments, which we'll
see why that's useful before long.
51:59 - Any questions?
52:02 - OK, so this was a lot, but we can
do so much more still with arrays.
52:05 - It gets even more and more cool.
52:07 - In fact, we'll see, in just a
bit, how arrays have actually
52:10 - been with us since last week.
52:11 - We just didn't quite realize it
under the hood, but let's go ahead
52:14 - and take a breather, five minutes.
52:15 - We'll come back and dive in.
52:16 - All right.
52:17 - So I know that was a
bit of a cliffhanger.
52:20 - Where else could arrays
have actually been?
52:22 - But, of course, this is how we
might depict it pictorially.
52:25 - We called it an array, and it
turns out that last week, when
52:27 - we introduced strings, strings,
sequences of characters,
52:31 - are literally just an
array by another name.
52:34 - A string is an array of chars, and
chars, of course, is another data type.
52:39 - Now what are the actual
implications of this,
52:41 - both in terms of representation,
like how a computer's representing
52:44 - information, and then
fundamentally, programmatically,
52:48 - what can we do when we
know all of our data
52:50 - is so back to back to back or
so proximal to one another?
52:53 - Well, it turns out that we can apply
this logic in a few different ways.
52:58 - Let me go ahead and
open up, for instance,
53:01 - an example here called String 0.
53:04 - So in our code for today,
in our Source 2 folder,
53:08 - let me go ahead and open up String
0, and this example looks like this.
53:13 - Notice that we first, on line
9, get a string from the user.
53:17 - Just say, input, please.
53:19 - We store that value in a string, s,
and then we say, here comes the output.
53:23 - And notice what I'm doing
in the following line.
53:26 - I'm iterating over i from 0
to strlen, whatever that is.
53:31 - And then in line 13, I'm printing
a character one at a time.
53:34 - But notice the syntax I'm using,
which we didn't use last week.
53:38 - If you have a string called
s, you can index into a string
53:43 - just like it's an array, because
it, indeed, is underneath the hood.
53:46 - So s bracket i, where
i starts at 0 and goes
53:50 - up to whatever this value is is just
a way of getting character 0, then
53:55 - character 1, then character
2, then character 3,
53:58 - and so the end result is
actually going to look like this.
54:01 - Let me go ahead and do, make string--
54:04 - whoops-- make string 0.
54:06 - Oops.
54:06 - Not in the directory.
54:07 - Make string 0, ./string0, Enter,
and I'll type in, say, Zamyla,
54:15 - and the output now is
Z-A-M-Y-L-A. It's a little messy,
54:21 - because I don't have a new line here, so
let me actually-- let's clean that up,
54:24 - because this is unnecessarily sloppy.
54:27 - So let me go ahead and
print out a new line.
54:31 - Let me recompile with
make string 0, dot--
54:34 - whoops-- ./string0.
54:37 - Input shall be Zamyla,
Enter, and now Z-A-M-Y-L-A.
54:43 - So why is that happening?
54:44 - Well, if I scroll down on
this code, it seems that I am,
54:47 - via this printf line here, just getting
the i-th character of the name in s,
54:52 - and then printing out one
character at a time per the %c,
54:55 - followed by a new line.
54:57 - So you might guess, what is
this function here doing?
55:01 - Strlen-- slightly abbreviated, but
you can, perhaps, glean what it means.
55:06 - Yeah, so it's actually string length.
55:08 - So it turns out there
is a function that comes
55:11 - with C called strlen, and
humans back in the day
55:13 - and to this day like to type as
few characters when possible.
55:17 - And so strlen is string length,
and the way you use it is you
55:21 - just need one more header file.
55:22 - So there's another library,
the so-called string
55:24 - library that gives you
string-related functions
55:27 - beyond what CS50's library provides.
55:29 - And so if you include
string.h, that gives you access
55:32 - to another function called
strlen, that if you pass it,
55:35 - a variable containing a
string, it will pass you back
55:38 - as a return value the
total number of characters.
55:40 - So I typed in Z-A-M-Y-L-A, and so
that should be returning to me six,
55:46 - thereby printing out the six
characters in Zamyla's name.
55:49 - Yeah.
55:50 - AUDIENCE: [INAUDIBLE].
55:52 - DAVID J. MALAN: Uh-huh.
55:54 - AUDIENCE: [INAUDIBLE] useful to get
the individual digits [INAUDIBLE]..
55:56 - DAVID J. MALAN: Really good question.
55:57 - In the credit problem of the problem
set, would this have been useful?
56:00 - Yes, absolutely.
56:01 - But recall that in the credit
pset, we encourage you to actually
56:04 - take in the number as a long,
so as an integral value, which
56:07 - thereby necessitated arithmetic.
56:09 - But yes, if you had, instead, in
a problem involving credit card
56:12 - numbers, gotten the human's input
as a long string of characters
56:16 - and not as an actual number
like an int or a long,
56:18 - then, yes, you could actually get
at those individual characters,
56:21 - which probably would have made
things even easier but deliberate.
56:26 - Yeah.
56:27 - AUDIENCE: [INAUDIBLE].
56:29 - DAVID J. MALAN: Really good question.
56:30 - If we're defining string in CS50,
are we redefining it in string?
56:33 - No.
56:34 - So string, even though
it's named string.h,
56:36 - doesn't actually define
something called a string.
56:39 - It just has string-related functions.
56:42 - More on that soon.
56:43 - Yeah.
56:43 - AUDIENCE: [INAUDIBLE]
individual values [INAUDIBLE]??
56:46 - DAVID J. MALAN: Ah,
really good question.
56:48 - Could you edit the individual values?
56:51 - So short answer, yes.
56:52 - We could absolutely change values, and
we'll soon do that in another context.
56:57 - Other questions?
56:59 - All right, so turns out this
is correct, if my goal is
57:03 - to print out all of the
characters in Zamyla's name,
57:06 - but it's not the best design.
57:07 - And this one's a little subtle, but
this is, again, what we mean by design.
57:09 - And to a question that
came up during the break,
57:12 - did we expect everyone to be writing
good style and good design last week?
57:16 - No.
57:16 - Up until today, like we've
introduced the notion of correctness
57:19 - in both Scratch and in C
last week, but now we're
57:21 - introducing these other
axes of quality of code
57:24 - like design, how well-designed
it is, and how pretty
57:27 - does it look in the context of style.
57:28 - So expectations are here on out meant to
be aligned with those characteristics,
57:33 - but not in the past.
57:35 - So there's a slight inefficiency here.
57:37 - So on the first iteration of this
loop, I first initialize i to 0,
57:41 - and then I check if i less than the
length of the string, which hopefully,
57:45 - it is, if it's Zamyla,
which is longer than 0.
57:48 - Then I print the i-th character.
57:50 - Then I increment i.
57:51 - Then I check this condition.
57:53 - Then I print the i-th character.
57:55 - Then I increment i.
57:56 - Then I check this
condition and so forth.
57:58 - We looped through loops last week,
and you've used them, perhaps,
58:01 - by now in problems.
58:03 - What question am I redundantly
asking seemingly unnecessarily?
58:11 - I have to check a
condition again and again,
58:13 - because i is getting incremented.
58:15 - But there's another
other question that I
58:18 - don't need to keep asking again
just to get the same answer.
58:21 - AUDIENCE: What is the
length [? of the string? ?]
58:23 - DAVID J. MALAN: Yeah,
there's this function call
58:25 - in my loop of strlen s, which is fine.
58:28 - This is correct.
58:29 - I'm checking the length of the
string, but once I type in Zamyla,
58:32 - her name is not changing in length.
58:34 - I'm incrementing i, so I'm moving
in the string, if you will.
58:38 - But the string itself,
Z-A-M-Y-L-A, is not changing.
58:41 - So why am I asking the computer, again
and again, get me the strlen of s,
58:46 - get me the strlen of s,
get me the strlen of s.
58:48 - So I can actually fix this.
58:49 - I can improve the design, because
that must take some amount of time.
58:52 - Maybe it's fast, but it's still
a non-zero amount of time.
58:55 - So you know what I could do?
58:56 - I could do something like this--
int n get string length of s.
58:59 - And now just do this.
59:01 - This would be better design, because
now I'm only asking the question once
59:05 - of the function.
59:06 - I'm remembering or caching, if
you will, the answer, and then
59:09 - I'm just using a variable.
59:10 - And just comparing
variables is just faster
59:12 - than comparing a variable against
a function, which has to be called,
59:16 - which has to return a value,
which you can then compare.
59:18 - But honestly, it doesn't
have to be this verbose.
59:20 - We can actually be a
little elegant about this.
59:22 - If you're using a loop,
a secret feature of loops
59:25 - is that you can have commas
after declaring variables.
59:28 - And you can actually do this and make
this even more elegant, if you will,
59:32 - or more confusing-looking,
depending on your perspective.
59:35 - But this now does the same thing
but declares n inside of the loop,
59:39 - just like I'm declaring i, and
it's just a little tighter.
59:41 - It's one fewer lines of code.
59:44 - Any questions, then?
59:47 - AUDIENCE: [INAUDIBLE].
59:50 - DAVID J. MALAN: Good question.
59:51 - In the way I've just done it cannot
reuse this outside of the curly braces.
59:54 - The scope of i and n exists
only in this context right now.
59:59 - The other way, yes.
60:00 - I could have used it elsewhere.
60:03 - AUDIENCE: What if you [INAUDIBLE] other
loops, and you also had [INAUDIBLE]??
60:09 - DAVID J. MALAN: Absolutely.
60:11 - AUDIENCE: Using different
letters of the alphabet,
60:13 - you could just use n
and not be [INAUDIBLE]..
60:17 - DAVID J. MALAN: Correct.
60:18 - If I want to use the length
of s again, absolutely.
60:20 - I can declare the variable, as I
did earlier, outside of the loop,
60:24 - so as to reuse it.
60:25 - That's totally fine.
60:26 - Yes.
60:27 - And even i-- i exists only inside of
this loop, so if I have another loop,
60:31 - I can reuse i, and it's a different
i, because these variables only
60:34 - exist inside the for loop
in which they're declared.
60:37 - So it turns out that these strings
don't have anything in them
60:44 - other than character after
character after character.
60:46 - And in fact, let me
go ahead here and draw
60:49 - a picture of what's actually going on
underneath the hood of the computer
60:52 - here.
60:52 - So when I type in Zamyla's
name, I'm, of course,
60:55 - doing something like Z-A-M-Y-L-A.
But where is that actually going?
61:02 - Well, we know now that inside of
your computer is RAM or memory,
61:04 - and you can think of it like a grid.
61:06 - And honestly, I can think
of this whole screen
61:08 - as just being in a different
orientation, a grid of memory.
61:11 - So for instance, maybe we can divide
it into rows and columns like this, not
61:16 - necessarily to scale, and
there's more rows and columns.
61:20 - So on the screen here,
I'm just dividing things
61:23 - into the individual bytes of
memory that we saw a moment ago.
61:28 - And so, indeed, underneath the hood of
the computer is this layout of memory.
61:32 - The compiler has somehow figured out
or the program has somehow figured out
61:35 - where to put the z and where the a and
the m and the y and the l and the a,
61:39 - but the key is that they're all
contiguous, back to back to back.
61:42 - But the catch is if I'm typing other
words into my program or scores
61:46 - into my program or any
data into my program,
61:49 - it's going to end up elsewhere
in the computer's memory.
61:51 - So how do you know where
Zamyla begins and where
61:53 - Zamyla ends, so to speak, in memory?
61:56 - Well, the variable, called
s, essentially is here.
62:02 - There's some remembrance in
the computer of where s begins.
62:06 - But there's no obvious way
to know where Zamyla ends,
62:10 - unless we ourselves tell the computer.
62:12 - So unbeknownst to us, any time a
computer is storing a string like
62:16 - Z-A-M-Y-L-A, it turns out that it's
not using one, two, three, four, five,
62:21 - six characters.
62:22 - It's actually using seven secretly.
62:25 - It's actually putting
a special character
62:28 - of all zeros in the very last bytes.
62:33 - Every byte is eight bits, so it's
putting secretly eight zeros there,
62:37 - or we can actually draw this
more conventionally as /0.
62:40 - It's what's called the null character,
and it just means all zeros.
62:44 - So the length of the
string, Zamyla, is six,
62:46 - but how many bytes does it
apparently take up, just to be clear?
62:50 - So it actually takes up seven.
62:52 - And this is kind of a
secret implementation detail
62:54 - that we don't really have to care
about, but eventually, we will,
62:57 - because if we want to implement
certain functionality,
62:59 - we're going to need to know
what is actually going on.
63:01 - So for instance, let me
go ahead and do this.
63:03 - Let me go ahead and create a
program called strlen itself.
63:07 - So this is not a function but
a program called strlen.c.
63:10 - Let me go ahead and include
the CS50 library at the top.
63:13 - Let me go ahead and include stdio.h.
63:15 - Let me go ahead and type out main
void, so all this is same as always.
63:20 - And then let me go ahead and prompt
the user for, say, his or her name,
63:24 - like so.
63:25 - And then you know what?
63:26 - Let me actually, this time,
not just print their name out,
63:28 - because we've done that ad nauseam.
63:29 - Let's just count the number
of letters in his or her name.
63:32 - So how could we do that?
63:33 - Well, we could just do this-- int
n get strlen of s, and then say,
63:40 - printf "The length of your name is %i."
63:45 - And then we can plug
in n, because that's
63:48 - the number we stored the length in.
63:49 - But to use strlen, I have
to include what header file?
63:52 - String.h, which is the
new one, so string.h.
63:56 - And now if I type this all correctly,
make strlen, make strlen, good.
64:02 - ./strlen-- let's try it--
64:05 - Zamyla.
64:06 - Enter.
64:06 - OK, the length of her name is six.
64:08 - But what is strlen doing?
64:10 - Well, strlen is just an abstraction
for us that someone else wrote,
64:13 - and it's wonderfully convenient, but
you know, we don't strictly need it.
64:16 - I can actually do this myself.
64:18 - If I understand what
the computer is doing,
64:20 - I can implement this same
functionality myself as follows.
64:24 - I can declare a variable called
n and initialize it to 0,
64:26 - and then you know what?
64:27 - I'm going to go ahead and do this.
64:29 - While s bracket n does
not equal all zeros,
64:36 - but you don't write all zeros like this.
64:38 - You literally do this--
64:39 - that /0 to which I referred
earlier in single quotes.
64:42 - That just means all zeros in the bytes.
64:45 - And now I can go ahead and do n++.
64:47 - If I'm familiar with what
this means, remember,
64:49 - that this is just n equals n plus 1, but
it's just a little more compact to say,
64:54 - n++.
64:55 - And then I can print
out the name of your n--
64:57 - the name of your n--
64:59 - the name of-- the length of
your name is %i, plugging in n.
65:03 - So why does this work?
65:05 - It's a little funky-looking,
but this is just
65:07 - demonstrating an understanding
of what's going on
65:09 - underneath the proverbial hood.
65:10 - If n is initialized to zero,
and I look at s bracket n,
65:14 - well, that's like
looking at s bracket 0.
65:16 - And if the string, s, is
Zamyla, what is s bracket 0?
65:21 - Z. And then it does not equal /0.
65:24 - It equals z, obviously.
65:25 - So we increment n.
65:26 - So now n is 1.
65:28 - Now n is 1.
65:29 - So what is s bracket 1 in Zamyla's name?
65:32 - A and so forth, and we get to
Z-A-M-Y-L-A, then all zeros,
65:38 - the so-called null character, or /0.
65:41 - That, of course, does equal
/0, so the loop stops,
65:44 - thereby leaving the total count or
value of n at what it previously was,
65:49 - which was 6.
65:51 - So that's it.
65:52 - Like all underneath
the hood, all we have
65:54 - is memory laid out like this,
top to bottom, left to right,
65:57 - and yet all of the functionality
we've been using for a week now
66:00 - and henceforth just boils down to
some relatively simple primitives,
66:03 - and if you understand
those primitives, you
66:05 - can do anything you want using
the computer, both computationally
66:08 - code-wise, but also memory-wise.
66:11 - We can actually see, in fact, some of
the stuff we looked at two weeks ago as
66:14 - follows.
66:15 - Let me go ahead and open up
an example called ASCII 0.
66:18 - Recall that ASCII is the mapping between
letters and numbers in a computer.
66:22 - And notice what this
program's going to do.
66:23 - Make-- let me go into this folder.
66:26 - Make ascii0, ./ascii0, Enter.
66:30 - The string shall be,
let's say, Zamyla, Enter.
66:34 - Well, it turns out that
if you actually look up
66:38 - the ASCII code for Zamyla's name, z
is 90, lowercase a is 97, m is 109,
66:45 - and so forth.
66:46 - There are those characters,
and actually, we
66:47 - can play the same game we did last week.
66:49 - If I do this again on "hi," there's
your 72, and there's your 73.
66:53 - Where is this coming from?
66:55 - Well, now that I know how to
manipulate individual strings,
66:57 - notice what I can do.
66:58 - I can get a string from the
user, just as we always have.
67:01 - I can iterate over the length of
that string, albeit inefficiently
67:05 - using strlen here.
67:06 - And then notice this new feature today.
67:09 - I can now convert one data type
to another, because a char,
67:14 - a character is just eight bits, but
presented in the context of characters.
67:20 - Bytes is also just eight bits that you
could treat as an integer, a number.
67:24 - It's totally context-sensitive.
67:25 - If you use Photoshop, it's a graphic.
67:27 - If you use a text program,
it's a message and so forth.
67:29 - So you can encode--
67:31 - change the context.
67:33 - So notice here, s bracket i is, of
course, the i-th character of Zamyla's
67:38 - name, so Z or A or M or whatever.
67:40 - But I can convert that i-th character to
an integer doing what's called casting.
67:44 - You can literally, in
parentheses, specify the data type
67:47 - you want to convert one
data type to, and then
67:50 - store it in exactly that data type.
67:52 - So s bracket i-- convert it to a number.
67:54 - Then store it in an actual number
variable, so I can print out its value.
67:59 - So c-- this is show me the character.
68:01 - Show me the letter as by plugging in
the character, and then the letter--
68:06 - sorry, the character and the number
that I've just converted it to.
68:09 - And you don't actually
even have to be explicit.
68:11 - This is called explicit casting.
68:13 - Technically, we can do
this implicitly, too.
68:17 - And the computer knows that
numbers are characters,
68:19 - and characters are a number.
68:20 - You don't have to be
so pedantic and even do
68:22 - the explicit casting in parentheses.
68:24 - You can just do it implicitly with data
types, and honestly, at this point,
68:27 - I don't even need the variable.
68:29 - I can get rid of this, and
down here, I can literally just
68:32 - print the same thing
twice, but tell printf
68:36 - to print the first in the
context of a character
68:39 - and the second in the context of an
int, just treating the exact same bits
68:43 - differently.
68:44 - That's implicit casting.
68:46 - And it just demonstrates
what we did in week 0
68:48 - when we claimed that
letters are numbers,
68:51 - and numbers can also be colors, and
colors can be images, and so forth.
68:54 - Is this a question?
68:55 - AUDIENCE: Would've
been useful for credit.
68:57 - DAVID J. MALAN: Also, yes.
68:57 - It all comes back to credit.
68:58 - Yeah.
68:59 - Indeed.
69:00 - Other questions?
69:01 - No.
69:02 - All right, so what else can we
actually do with this appreciation?
69:06 - So super simple feature that all
of us surely take for granted,
69:08 - if we even use it anymore these days.
69:10 - Google Docs, Microsoft Word,
and such can automatically
69:13 - capitalize words for you these days.
69:14 - I mean your phone can do it nowadays.
69:16 - They just sort of
AutoCorrect your messages.
69:18 - Well, how is that actually working?
69:20 - Well, once you know that a string
is just a bunch of characters
69:22 - back to back to back, and you know
that these characters have numbers
69:26 - representing them, and like capital A is
65, and lowercase A is 97, apparently,
69:32 - and so forth, we can
leverage these patterns.
69:34 - If I go ahead and open
up this other example
69:36 - here called Capitalize 0,
notice what this program is
69:40 - going to do for me first by running it.
69:43 - Make capitalize 0 ./capitalize0.
69:47 - Let me go ahead and type in Zamyla's
name just as before, but now
69:50 - it's all capital.
69:51 - So this is a little extreme.
69:52 - Hopefully, your phone is not
capitalizing every letter,
69:55 - but you can imagine it capitalizing
just the first, if you wanted it.
69:58 - So how does this work?
69:59 - Well, let me go ahead and
open up this example here.
70:03 - And so what we did--
70:04 - so here, I'm getting a string from
the user, just as we always do.
70:08 - Then I'm saying, after, just to
kind of format the output nicely.
70:11 - Here, I'm doing a loop pretty
efficiently from i equals 0 up
70:15 - to the length of the string.
70:17 - And now notice this neat
application of logic.
70:20 - It's a little cryptic,
certainly, at first glance.
70:22 - But whoops.
70:23 - And now it's gone.
70:23 - And what am I doing exactly
with these lines of code?
70:27 - Well, with every iteration of this
loop, I'm asking the question,
70:31 - is the i-th character of s,
so the current character,
70:33 - is it greater than or equal to
lowercase A, and is it less than
70:37 - or equal to lowercase Z?
70:39 - Put another way, how do you say
that more colloquially in English?
70:42 - Is it lowercase, literally.
70:44 - But this is the more programmatic
way of expressing, is it lowercase?
70:47 - All right, if it is,
go ahead and do this.
70:49 - Now this is a little funky, but
print out a character, specifically
70:53 - the i-th character, but subtract
from that lowercase letter whatever
70:58 - the difference is between little A and
big A. Now where did that come from?
71:05 - So it turns out--
71:06 - OK, capital A is 65.
71:08 - Lowercase A is 97.
71:10 - So the difference between those is 32.
71:13 - And that's true for B, so capital
B is 66, and lowercase B is 98.
71:18 - Still 32, and it repeats
for the whole alphabet.
71:20 - So I could just do this.
71:22 - If I know that lowercase letters
have bigger numbers, like 97, 98,
71:27 - and I know that lowercase numbers
have lower letters, like 65, 66,
71:32 - I can just literally subtract
off 32 from my lowercase letters.
71:35 - As you point out, it's
a lowercase letter.
71:37 - Subtract 32, and that
gives us what result?
71:40 - The capitalized version.
71:42 - It uppercases things for us.
71:43 - But honestly, this feels a little
hackish that, like, OK, yes,
71:46 - I can do the math correctly,
but you know what?
71:48 - It's better practice, generally,
to abstract this away.
71:50 - Don't get into the weeds of counting
how many characters are away
71:53 - from each other.
71:53 - Math is cheap and easy in the computer.
71:55 - Let it do the math for you by
subtracting whatever the value of A
71:58 - is, of capital A is from the value of
lowercase A. Or we could just write 32.
72:04 - Otherwise, go ahead and just
print the character unchanged.
72:07 - So in this case, the A-M-Y-L-A
in Zamyla's name got uppercased,
72:11 - and everything else,
the Z, got left alone,
72:13 - just by understanding what's going on
with how the computer's represented.
72:18 - But honestly, God, I don't want
to keep writing code like this.
72:21 - Like, I'm never going to get this.
72:22 - I'm new to programming, perhaps.
72:23 - I'm never going to get this sort of
sequence of all the cryptic symbols
72:26 - together, and that's OK, because we can
actually implement this same program
72:30 - a little more easily,
thanks to functions
72:32 - and abstractions that
others have written for us.
72:35 - So in this program,
turns out I can simplify
72:38 - the questions I'm asking by literally
calling a function that says, is lower.
72:43 - And there's another
one called, is upper,
72:45 - and there's bunches of others
that just literally are called,
72:48 - is something or other.
72:49 - So is lower takes an argument
like the i-th character of s,
72:53 - and it just returns a
bull-- true or false.
72:55 - How is it implemented?
72:57 - Well, honestly, if we looked at the
code that someone else wrote decades ago
73:00 - for is upper, odds are-- or is lower--
73:03 - odds are he or she wrote code
that looks almost like this.
73:07 - But we don't need to worry
about that level of detail.
73:10 - We can just use his or her
function, but how do we do that?
73:12 - Turns out that this function--
and you would only know this
73:15 - by having been told or Googling
or reading a reference--
73:17 - is in a library called ctype.h.
73:20 - And you need the header file
called ctype.h in order to use it.
73:25 - And we'll almost always point you
to references and documentation
73:27 - to explain that to you.
73:29 - Toupper is another feature, right?
73:31 - This math-- like, my god.
73:33 - I just want to uppercase a letter.
73:34 - I don't want to really keep thinking
about how far apart uppercase letters
73:36 - are from lowercase.
73:37 - Turns out that in the
C type library, there's
73:39 - another function called toupper that
literally does the exact same thing
73:43 - in the previous program we wrote.
73:45 - And so that, too, is OK.
73:47 - But you know what?
73:48 - This feels a little verbose.
73:50 - It would be nice if I could
really tighten this program up.
73:53 - So how those toupper work?
73:55 - Well, it turns out some of you might
be familiar with CS50 Reference
73:58 - Online, our web-based
app that we have that
74:00 - helps you navigate
available functions in C.
74:03 - Turns out that all of the
data for that application
74:06 - comes from an older command
line program that comes in Linux
74:09 - and comes in the sandbox
called Man for manual.
74:12 - And anytime you type "man" at the
command prompt, and then the name
74:16 - of a function you're
interested in, if it exists,
74:18 - it will tell you a little
something about it.
74:20 - So if I go to toupper, man toupper,
I get slightly cryptic documentation
74:27 - here.
74:27 - But notice, toupper and
some other functions
74:30 - convert uppercase or lowercase.
74:31 - That's the summary.
74:33 - Notice that in the synopsis,
the man page, so to speak,
74:36 - is telling me what header
file I have to include.
74:39 - Notice that under Synopsis,
it's also telling me
74:41 - what the signature or
prototype is of the function.
74:44 - In other words, the documentation in
Man, the Linux programmer's manual,
74:48 - is very terse.
74:48 - So it's not going to hold your hand
in this black and white format.
74:51 - It's just going to
convey, well, implicitly,
74:54 - you better put this on top of your file.
74:55 - And by the way, this is
how you use the function.
74:57 - It takes an argument called C,
returns a value of type int.
75:03 - Why is it int?
75:06 - Let me wave my hands at that.
75:07 - It effectively returns a
character for our purposes today.
75:10 - And if we scroll down, OK, description.
75:12 - Ugh, I don't really want to read
all of this, but OK, here we go.
75:16 - If c is a lowercase letter, toupper
returns its uppercase equivalent,
75:21 - if an uppercase representation
exists in the current locale.
75:23 - That just means if it's punctuation,
it's not going to do anything.
75:26 - Otherwise, it returns C, And
that's kind of the key detail.
75:29 - If I pass it lowercase A, it's
going to give me capital A,
75:33 - but if I pass it capital A,
what's it going to give me?
75:36 - AUDIENCE: Capital A.
75:37 - DAVID J. MALAN: Also, capital A. It
returns the original character, c.
75:40 - That's the only detail I cared about.
75:42 - When in doubt, read the manual.
75:43 - And it might be a
little cryptic, and this
75:45 - is why CS50 Reference takes
somewhat cryptic documentation
75:48 - and tries to simplify it into
more human-friendly terms.
75:50 - But at the end of the day, these
are the authoritative answers.
75:53 - And if I or one of the staff
don't know, we literally
75:55 - pull up the Man page or CS50 Reference
to answer these kinds of questions.
75:59 - Now what's the implication?
76:01 - I don't need any of this.
76:02 - I can literally get rid of
the condition and just let
76:06 - toupper do all of the
legwork, and now my program
76:10 - is so much more compact than
the previous versions were,
76:13 - because I've read the documentation.
76:15 - I know what the function does, and I
can let toupper uppercase something
76:18 - or just pass it through unchanged.
76:21 - We can better design, because we're
writing fewer lines of code that
76:23 - are just as clear, and so we can
now actually tighten things up.
76:29 - Any questions on this
particular approach?
76:33 - All right.
76:34 - So we're getting very low level.
76:35 - Now let's make these things more
useful, because clearly, other people
76:38 - have solved some of
these problems for us,
76:40 - as by having these functions and the
C type library and the string library.
76:44 - What more is there?
76:45 - Well, recall that every time
we run Clang, or even run make,
76:49 - we're typing multiple words
at the command prompt.
76:52 - You're typing make hello or
make Mario, a second word,
76:56 - or you're typing
clang-o, hello, hello.c,
76:59 - like lots of words at the prompt.
77:01 - Well, it turns out that all
this time, you're using, indeed,
77:04 - command line arguments.
77:05 - But in C, you can write programs that
also accept words and numbers when
77:10 - the user runs the program.
77:11 - Think back, after all.
77:12 - When you ran Mario,
you did ./mario, Enter.
77:15 - You couldn't type any
more words at the prompt.
77:17 - When you did credit,
you did ./credit, Enter.
77:20 - No more words at the prompt.
77:21 - You used get string or get
long to get more input, but not
77:24 - at the command line.
77:26 - And it turns out that we
can, relatively simply, in C,
77:29 - but it's a little
cryptic at first glance.
77:31 - Let me go ahead and--
77:33 - let me go ahead and, here, pull up this
signature here, which looks like this.
77:41 - This is the function that we're all used
to by now for writing a main function.
77:45 - And up until now, we've said void.
77:47 - Main doesn't take any inputs,
and indeed, it just runs.
77:50 - But it turns out if you change your
existing programs or future programs,
77:54 - not to say void, but to
say, int argc, string argv,
77:58 - it's a little cryptic at first glance.
78:00 - But what's a recognizable symbol now?
78:04 - Yeah, there's brackets here.
78:05 - So it turns out that every
time you write a program,
78:08 - if you don't just say void, you
actually enable this feature
78:11 - by writing int argc, string argv.
78:13 - You can actually tell
Clang, you know what?
78:15 - I want this program to accept one or
more words or numbers after the name
78:20 - of the program, so I can do
./hellodavid, or ./hellozamyla.
78:23 - I don't have to wait for the
program to be running to use string.
78:27 - And just as with the earlier example,
where you were able to chart an array,
78:34 - main is defined as taking an array,
called argv historical reasons--
78:38 - argument vector.
78:39 - Vector means array.
78:40 - Argument vector, bracket, closed
bracket just means this is--
78:43 - this contains one or more words,
each of which is a string.
78:46 - Argc is argument count,
so this is the variable
78:49 - that main gets access to that
tells it how many arguments,
78:52 - how many strings are actually in argv.
78:55 - So how can we use this in a useful way?
78:58 - Well, let me go ahead here
and open up the sandbox.
79:01 - And let me go ahead and create a new
file called, say, argv0, argv0.c--
79:06 - again, argument vector, just
list or array of arguments.
79:10 - And let me go ahead and, as usual,
include cs50.h, include stdio.h,
79:19 - and then int main not void,
but int argc, string argv--
79:26 - argv-- open bracket, closed bracket.
79:28 - And even if that doesn't come
naturally at first, it will eventually.
79:31 - And I'm going to do this.
79:32 - If the number of arguments
passed in equals 2,
79:39 - then I'm going to go ahead and do
this-- printf, hello %s, comma,
79:45 - and here in the past, I've
typed a variable name.
79:47 - And I now actually have
access to a variable.
79:49 - Go ahead and do argv bracket 1.
79:52 - Else, if the user does not
type, apparently, two words,
79:56 - let me go ahead and just by default,
say, hello world, as we always have.
80:00 - Now why-- what is this doing,
and how is it doing it?
80:03 - Well, let's quickly run it.
80:04 - So make-- whoops.
80:07 - Make argv0, ./argv0, Enter, Hello World.
80:15 - But if I do Hello--
80:17 - or dot-- the program
would be better named
80:19 - if we called it Hello,
but Zamyla, Enter.
80:23 - Hello Zamyla.
80:24 - If I change it to David,
now I have access to David.
80:26 - If I had David Malan, no.
80:29 - It doesn't support that.
80:30 - So what's going on?
80:31 - If you change main in
any program write to take
80:34 - these two arguments, argc
and argv of type string int
80:38 - and then an array of strings,
argc tells you how many words
80:41 - were typed at the prompt.
80:42 - So if the human typed
two words, I presume
80:45 - the first word is the name of
the program, dot slash argv0,
80:48 - the second word is presumably my
name, if he or she is actually
80:51 - providing their name at the prompt.
80:53 - And so I print out argv bracket 1.
80:55 - Not 0 because that's the name of
the program, but argv bracket 1.
80:58 - Else, down here, if the human doesn't
provide just Zamyla, or just David,
81:02 - or just one word more generally, I
just print the default, "Hello world."
81:07 - But what's neat about this now is
notice that argv is an array of strings.
81:15 - What is a string?
81:18 - It's an array of characters.
81:20 - And so let's enter just one last piece
of syntax that gets kind of powerful
81:24 - here.
81:24 - Let me go ahead and do this.
81:28 - Let me go ahead and, in a
new file here, argv 1 dot c.
81:33 - Let me go ahead and paste this in.
81:35 - Close this.
81:36 - Let me go ahead and do this.
81:38 - Rather than do this logical
checking, let me do this, for--
81:43 - let's say for int, i get 0.
81:48 - i is less than argc--
81:50 - i++.
81:51 - Let's go ahead and, one per
line, print out every word
81:54 - that the human just
typed, just to reinforce
81:57 - that this is indeed what's going on.
81:59 - So argv bracket 0, save.
82:01 - Make argv 1, enter.
82:05 - And now let's go ahead
and run this program--
82:07 - dot slash, argv 1, David Malan.
82:12 - OK, you see all three words.
82:14 - If we change it to Zamyla,
we see just those two words.
82:17 - If we change it to Zamyla
Chan, we see those three words.
82:20 - So we clearly have access to
all of the words in the array,
82:23 - but let's take this one step further.
82:25 - Rather than just print out every word
in a string, let's go ahead and do this.
82:28 - For intj get 0.
82:32 - n equals the string length of
the current argument, like this--
82:40 - j is less than n, j++--
82:43 - oops, oops, oops-- j++.
82:45 - Now let me go ahead and print out not
the full string, but let me do-- oops,
82:49 - oops-- let me go ahead
and print out this--
82:52 - not a string, but a character, n
bracket i bracket j, like this.
83:00 - All right.
83:00 - So what's going on?
83:01 - One, this outer loop, and let's comment
it, iterate over strings in argv.
83:07 - This inner loop, iterate
over chars in argv bracket i.
83:13 - So the outer loop iterates over
all of the strings in argv.
83:17 - And the inner loop, using a
different variable, starting at 0,
83:20 - iterates over all of the
characters in the ith
83:23 - argument, which itself is a string.
83:26 - So we can call string length on it.
83:28 - And then we do this up until n,
which is the length of that string.
83:31 - And then we print out each character.
83:33 - So just to be clear-- when I run
arv1 and correct it, at first glance,
83:38 - why it's implicitly declaring library
function sterling, what's almost always
83:42 - the solution when you do this wrong?
83:44 - AUDIENCE: [INAUDIBLE]
83:45 - DAVID J. MALAN: Yeah.
83:45 - So I forgot this, so include
string.h and help50 would
83:49 - help with that as well.
83:50 - Let's recompile with make argv1.
83:52 - All right.
83:53 - When I run argv1, of, say, Zamyla
Chan, what am I going to see?
84:00 - AUDIENCE: [INAUDIBLE]
84:01 - DAVID J. MALAN: Yeah.
84:03 - Is that the right intuition?
84:05 - AUDIENCE: [INAUDIBLE]
84:06 - DAVID J. MALAN: I'm going
to see Zamyla Chan, but--
84:10 - AUDIENCE: [INAUDIBLE]
84:11 - DAVID J. MALAN: One character on each
line, including the program's name.
84:14 - So in fact, let me scroll this
up so it's a little bigger.
84:16 - Enter.
84:17 - OK, it's a little stupid, the program,
but it does confirm that using arrays
84:22 - do I have access not only to
the words, but I can kind of
84:25 - have the second dimension.
84:26 - And within each word, I can
get at each character within.
84:30 - And we do this, again, just by using
not just single square brackets,
84:34 - but double.
84:35 - And again, just break this
down into the first principles.
84:37 - What is this first bracket?
84:38 - This is the ith argument,
the ith string in the array.
84:41 - And then if you take it
further, with bracket j,
84:43 - that gives you the j
character inside of this.
84:47 - Now, who cares about any of
this kind of functionality?
84:51 - Well, let me scroll back and
propose one application here.
84:54 - So recall that CS is really
just problem solving.
84:57 - But suppose the problem
that you want to solve
84:59 - is to actually pass a
secret message in class
85:02 - or send someone a secret
for whatever reason.
85:04 - Well, the input to that
problem is generally
85:06 - called plain test, a message you
want to send to that other person.
85:09 - You ideally want ciphertext
to emerge from it,
85:12 - which is enciphered and scrambled,
somehow encrypted information
85:15 - so that anyone in the room, like the
teacher, can't just grab the note
85:18 - and read what you're sending to your
secret crush or love across the room,
85:21 - or in any other context as well.
85:23 - But the problem is that if the
message you want to send, say,
85:26 - is our old friend Hi!,
with an exclamation point,
85:29 - you can encode it in certain
contexts as just 72, 73, 33.
85:34 - And I daresay most classes on campus
if you wrote on a piece of paper 72,
85:37 - 73, 33, passed it through the room,
and whatever professor intercepts it,
85:40 - they're not going to know
what you're saying anyway.
85:43 - But this is not a good system.
85:44 - This is not a cryptosystem.
85:46 - Why?
85:47 - It's not secure.
85:52 - [INAUDIBLE]
85:52 - [INTERPOSING VOICES]
85:54 - DAVID J. MALAN: Yeah.
85:55 - Anyone has access to
this, right, so long
85:57 - as you attend like week 1
or 0 of CS50, or you just
86:00 - have general familiarity with Ascii.
86:02 - Like this is just a code.
86:04 - I mean Ascii is a system
that maps letters to numbers.
86:08 - And anyone else who
knows this code obviously
86:10 - knows what your message is,
because it's not a unique secret
86:12 - to you and the recipient.
86:14 - So that's probably not the best idea.
86:16 - Well, you can be a little
more sophisticated.
86:18 - And this is back--
actually, a photograph
86:19 - from World War I of a message that
was sent from Germany to Mexico
86:23 - that was encoded in a very similar way.
86:25 - It wasn't using Ascii.
86:26 - The numbers, as you can
perhaps glean from the photo,
86:29 - are actually much larger.
86:30 - But in this system, in a militaristic
context, there was a code book.
86:33 - So similar in spirit to
Ascii, where you have
86:35 - a column of numbers and a column of
letters to which they correspond,
86:39 - a codebook more generally has
like numbers, and then maybe
86:42 - even letters or whole words
that they correspond to,
86:45 - sometimes thousands of them, like
literally a really big book of codes.
86:50 - And so long as only, in this context
the Germans and the recipients,
86:53 - the Mexicans, had access
to that same book,
86:56 - only they could encrypt and decrypt, or
rather encode and decode information.
87:01 - Of course, in this
very specific context--
87:03 - you can read more about
this in historical texts--
87:05 - this was intercepted.
87:06 - This message, seemingly
innocuous, though definitely
87:08 - suspicious looking
with all these numbers,
87:11 - so therefore not innocuous, the British,
in this case actually, intercepted it.
87:16 - And thanks to a lot of
efforts and cryptanalysis,
87:18 - the Bletchley Park style code
breaking, albeit further back,
87:23 - were they able to figure out what
those numbers represented in words
87:27 - and actually decode the message.
87:29 - And in fact, here's a
photograph of some of the words
87:31 - that were translated
from one to the other.
87:34 - But more on that in any
online or textual references.
87:38 - Turns out in this poem too
there was a similar code, right?
87:41 - So apropos of being in Boston
here, you might recall this one.
87:44 - "Listen my children, and you shall hear
of the midnight ride of Paul Revere.
87:49 - On the 18th of April
in '75, hardly a man
87:51 - is now alive who remembers
that famous day and year.
87:54 - He said to his friend, if the
British march by land or sea
87:58 - from the town tonight
night, hang a lantern
88:00 - aloft in the belfry arch of the
North Church tower as a signal light,
88:05 - one if by land, and two if by sea.
88:08 - And I on the opposite shore
will be ready to ride and spread
88:10 - the alarm through every Middlesex
village and farm for the country folk
88:13 - to be up and to arm."
88:14 - So it turns out some of that is
not actually factually correct,
88:17 - but the one if by land and
the two if by sea code were
88:21 - sort of an example of a one-time code.
88:23 - Because if the revolutionaries in
the American Revolution kind of
88:27 - decided secretly among themselves
literally that-- we will put up one
88:30 - light at the top of a church if
the British are coming by land.
88:34 - And we will instead use two if the
British are instead coming by sea.
88:37 - Like that is a code.
88:38 - And you could write it down in a
book, unless you have a code book.
88:41 - But of course, as soon as
someone figures out that pattern,
88:44 - it's compromised.
88:45 - And so code books tend not to
be the most robust mechanisms
88:49 - for encoding information.
88:51 - Instead, it's better to use
something more algorithmic.
88:54 - And wonderfully, in computer
science is this black box
88:56 - to-- we keep saying,
the home of algorithms.
88:59 - And in general, encryption is a
problem with inputs and outputs,
89:03 - but we just need one more input.
89:05 - The input is what's generally
called the key, or a secret.
89:09 - And a secret might just be a number.
89:11 - So for instance, if I
wanted my secret to be 1,
89:13 - because we'll keep the example simple,
but it could really be any number.
89:16 - And indeed, we saw with the
photograph a moment ago,
89:18 - the Germans used much larger than
this, albeit in the context of codes.
89:21 - Suppose that you now want to send
a more private message to someone
89:24 - across the room in a
class that, I love you.
89:26 - How do you go about encoding that
in a way that isn't just using Ascii
89:31 - and isn't just using
some simple code book?
89:33 - Well, let me propose that now that we
understand how strings are represented,
89:37 - right-- we're about to make love
really, really lame and geeky--
89:41 - so now that you know how to
express strings computationally,
89:44 - well, let's just start
representing "I love you" in Ascii.
89:47 - So I is 73.
89:49 - L is 76.
89:50 - O-V-E Y-O-U. That's just Ascii.
89:53 - Should not send it this
way, because anyone
89:55 - who knows Ascii is going
to know what you're saying.
89:58 - But what if I enciphered this message,
I performed an algorithm on it?
90:02 - And at its simplest,
an algorithm can just
90:04 - be math-- simple
arithmetic, as we've seen.
90:06 - So you know, let me just
use my secret key of 1.
90:09 - And let me make sure that my crush knows
that I am using a secret value of 1.
90:14 - So he or she also knows
to expect that value.
90:17 - And before I send my message, I'm
going to add 1 to every letter.
90:21 - So 73 becomes 74.
90:23 - 76 becomes 77.
90:24 - 80, 87, 70, 90, 80, 86.
90:29 - Now this could just
be sent in the clear.
90:31 - But then, I could actually
send it as a textual message.
90:35 - So let's convert it back to Ascii.
90:37 - 74 is now J. 77 is now M. 80 is now P.
And you can perhaps see the pattern.
90:45 - This message was, I love you.
90:48 - And now, all of the letters
are off by one, I think.
90:52 - I became J. L became M.
O became P, and so forth.
90:57 - So now the claim would
be, cryptographically, I'm
91:00 - going to send this
message across the room.
91:02 - And now no one who has a code book
is going to be able to solve this.
91:05 - I can't just steal the
book and decode it,
91:07 - because now the key is
only up here, so to speak.
91:09 - It's just the number
1 that he or she and I
91:12 - had to agree upon in
advance that we would
91:13 - use for sending our secret messages.
91:15 - So if someone captures this message,
teacher in the room or whoever,
91:20 - how would they even go about
decoding this or decrypting it?
91:26 - Are there any techniques
available to them?
91:29 - I daresay we can kind of
chip away at this love note.
91:32 - AUDIENCE: [INAUDIBLE]
91:32 - DAVID J. MALAN: What's that?
91:33 - Guess and check.
91:34 - OK, we could try all--
91:35 - there still kind of some spacing.
91:36 - So you know honestly, we could do
like kind of a cryptanalysis of it,
91:40 - a frequency attack.
91:41 - Like, I can't think of
too many words in English
91:43 - that have a single letter in them.
91:45 - So what does J probably represent?
91:46 - [INTERPOSING VOICES]
91:47 - DAVID J. MALAN: I, probably.
91:48 - Maybe A, but probably I. And
there's not too many other options.
91:52 - So we've attacked one part
of the message already.
91:55 - I see a commonality.
91:56 - There's two what in here?
91:59 - Two P. And I don't necessarily
know that that maps to O, but I do
92:02 - know it's the same character.
92:04 - So if I kind of continue this thoughtful
process or this trial and error,
92:08 - and I figure out, oh,
what if that's an O?
92:10 - And then that's an O.
And then wait a minute.
92:12 - They're passing from one to another.
92:13 - Maybe this says, I love you.
92:15 - Like you actually can,
with some probability,
92:17 - decrypt a message by doing
this kind of analysis on it.
92:20 - It's at least more secure
than the code book,
92:22 - because you're not compromised
if the book itself is stolen.
92:25 - And you can change the key
every time, so long as you
92:28 - and the recipient actually
agree on something.
92:30 - But at least we now have
this mechanism in place.
92:33 - So with just the understanding
of what you can do with strings,
92:36 - can you actually now do really
interesting domain-specific things
92:39 - to them?
92:40 - And in fact, back in the day, Caesar,
back in militaristic times literally
92:45 - used a cipher quite like this.
92:47 - And frankly, when you're the
first one to use these ciphers,
92:49 - they actually are kind of secure,
even if they're relatively simple.
92:52 - But hopefully, not just using a
key of 1, maybe 2, or 13, or 25,
92:57 - or something larger.
92:58 - But this is an example
of a substitution cipher,
93:01 - or a rotational cipher where
everything's kind of rotating--
93:04 - A's becoming B, B's becoming
C. Or you can kind of
93:07 - rotate it even further than that.
93:11 - Well, let's take a look
at one last example here
93:14 - of just one other final
primitive of a feature
93:17 - today, before we then go back high
level to bring everything together.
93:20 - It turns out that printing
out error messages
93:23 - is not the only way to signal
that something has gone wrong.
93:27 - There's a new keyword, a new use
of an old keyword in this example,
93:31 - that's actually a convention
for signaling errors.
93:33 - So this is an example called exit.c.
93:36 - It apparently wants the human to do
what, if you infer from the code?
93:42 - AUDIENCE: Exit [INAUDIBLE].
93:43 - DAVID J. MALAN: Yes.
93:44 - Say again?
93:44 - AUDIENCE: [INAUDIBLE]
93:45 - DAVID J. MALAN: Well, it
wants the-- well, what
93:47 - does it what the human to do
implicitly, based on the printf's here?
93:51 - How should I run this program?
93:53 - Yeah?
93:53 - AUDIENCE: [INAUDIBLE]
just apply [INAUDIBLE]..
93:56 - DAVID J. MALAN: Yeah.
93:57 - So for whatever reason,
this program implicitly
94:00 - wants me to write exactly
two words at the prompt.
94:03 - Because if I don't, it's going to yell
at me, missing command line argument.
94:06 - And then it's going to
return 1, whatever that is.
94:08 - Otherwise, it's going to
say, Hello, such and such.
94:10 - So if I actually run this program--
94:12 - let me go back over
here and do make exit--
94:17 - oops-- in my directory, make exit.
94:19 - OK, dot slash exit, enter, I'm
missing a command line argument.
94:23 - All right, let me put Zamyla's name.
94:25 - Oh, Hello Zamyla.
94:26 - Let me put Zamyla Chan.
94:28 - Nope, missing command line argument.
94:29 - It just wants the one,
so in this case here.
94:33 - I'm seeing visually the error
message, but it turns out
94:36 - the computer is also signaling to
me what the so-called exit code is.
94:41 - So long story short, we've already
seen examples last week of how
94:44 - you can have a function return a value.
94:46 - And we saw how [? Erin ?]
came up on stage,
94:47 - and she returned to me a piece
of paper with a string on it.
94:50 - But it turns out that
main is a little special.
94:52 - If main returns a value like 1
or 0, you can actually see that,
94:58 - albeit in a kind of a non-obvious way.
95:01 - If I run exit, and I run it
correctly with Zamyla as the name,
95:06 - if I then type echo, dollar sign,
question mark, of all things,
95:10 - enter, I will then see exactly what main
returned with, which in this case is 0.
95:15 - Now, let me try and be uncooperative.
95:17 - If I actually run just dot
slash exit, with no word,
95:23 - I see, missing command line argument.
95:25 - But if I do the same cryptic command,
echo, dollar sign, question mark,
95:29 - I see that main exited with 1.
95:30 - Now, why is this useful?
95:32 - Well, as we start to write
more complicated programs,
95:35 - it's going to be a convention
to exit from main by returning
95:39 - a non-zero value, if
anything goes wrong.
95:42 - 0 happens to mean everything went well.
95:44 - And in fact, in all
of the programs we've
95:46 - written thus far, if you
don't mention return anything,
95:49 - main automatically for you returns 0.
95:53 - And it has been all this time.
95:55 - It's just a feature, so you don't
have to bother typing it yourself.
95:57 - But what's nice about this,
or what's real about this,
96:00 - is if on your Mac or PC, if you've ever
gotten an annoying error message that
96:04 - says, error negative 29, system error
has occurred, or something freezes,
96:08 - but you very often see
numbers on the screen, maybe.
96:11 - Like those error codes actually tend
to map to these kinds of values.
96:15 - So when a human is writing
software and something goes wrong
96:18 - and an error happens, they
typically return a value like this.
96:21 - And the computer has access to it.
96:23 - And this isn't all that useful
for the human running the program.
96:25 - But as your programs
get more complex, we'll
96:27 - see that this is actually quite
useful as a way of signaling
96:32 - that something indeed went wrong.
96:34 - Whew.
96:34 - OK, that's a lot of syntax
wrapped in some loving context.
96:41 - Any questions before we
look at one final domain?
96:44 - No?
96:45 - All right.
96:46 - So it turns out that we can answer the
"who cares" question in yet another way
96:51 - too.
96:52 - It turns out-- let me go ahead and open
up an example of our array again here--
96:59 - that arrays can actually now be used
to solve problems more algorithmically.
97:03 - And this is where life
gets more interesting.
97:05 - Like we were so incredibly
in the weeds today.
97:06 - And as we move forward
in the class, we're
97:08 - not going to spend so
much time on syntax,
97:10 - and dollar signs, and question marks,
and square brackets, and the like.
97:13 - That's not the interesting part.
97:14 - The interesting part is when we
now have these fundamental building
97:17 - blocks, like an array, with
which we can solve problems.
97:20 - So it turns out that
an array, you know, you
97:23 - can kind of think of it
as a series of lockers,
97:26 - a series of lockers that might
look like this, inside of which
97:29 - are values-- strings, or
numbers, or chars, or whatnot.
97:32 - But the lockers is an apt metaphor
because a computer, unlike us humans,
97:36 - can only see and do one thing at a time.
97:38 - It can open one locker and look
inside, but it can't kind of
97:41 - take a step back, like we humans
can, and look at all of the lockers,
97:44 - even if all of the doors are open.
97:46 - So it has to be a more
deliberate act than that.
97:49 - So what are the actual implications?
97:51 - Well, all this time--
97:52 - we had that phone book
example in the first week,
97:55 - and the efficiency of that algorithm, of
finding Mike Smith in this phone book,
97:59 - all assumed what feature
of this phone book?
98:02 - AUDIENCE: That it's
ordered alphabetically.
98:03 - DAVID J. MALAN: That it
was ordered alphabetically.
98:05 - And that was a huge plus, because
then I could go to the middle,
98:08 - and I could go to the middle
of the middle, and so forth.
98:10 - And that was an algorithmic possibility.
98:12 - On our phones, if you
pull up your contacts,
98:13 - you've got a list of first names, or
last names, all alphabetically sorted.
98:17 - That is because, guess what
data structure or layout
98:20 - your phone probably uses
to store your contacts?
98:24 - It's an array of some sort, right?
98:26 - It's just a list.
98:27 - And it might be displayed
vertically, instead of horizontally,
98:29 - as I've been drawing it today.
98:30 - But it's just values that are back,
to back, to back, to back, to back,
98:33 - that are actually sorted.
98:34 - But how did they actually
get into that sorted order?
98:37 - And how do you actually find values?
98:38 - Well, let's consider what
this problem is actually
98:40 - like for a computer, as follows.
98:43 - Let me go ahead here.
98:44 - Would a volunteer mind
joining us up here?
98:47 - I can throw in a free stress ball.
98:49 - OK, someone from the back?
98:51 - OK, come on up here.
98:52 - Come on.
98:52 - What's your name?
98:53 - ERIC: Eric.
98:54 - DAVID J. MALAN: Aaron.
98:55 - All right.
98:56 - So Aaron's going to come on up.
98:57 - And--
98:58 - ERIC: Eric.
98:59 - DAVID J. MALAN: I'm sorry?
98:59 - Oh, Eric.
99:00 - Nice to meet you.
99:01 - All right.
99:01 - Come on over here.
99:02 - So Eric, now normally, I would
ask you to find the number 23.
99:05 - But seeing is that's a little easy,
can you go ahead and just find us
99:08 - the number 50 behind these doors,
or really these yellow lockers?
99:11 - 8?
99:11 - Nope.
99:12 - 42?
99:13 - Nope.
99:13 - OK.
99:14 - Pretty good.
99:14 - That's three, three out of seven.
99:16 - How did you get it so quickly?
99:17 - ERIC: I guessed.
99:18 - DAVID J. MALAN: OK, so he guessed.
99:20 - Is that the best algorithm
that Eric could have used here?
99:24 - ERIC: Probably not.
99:26 - DAVID J. MALAN: Well, I don't know.
99:27 - Yes?
99:28 - No?
99:28 - AUDIENCE: Yeah.
99:29 - DAVID J. MALAN: Why?
99:30 - Why yes?
99:30 - AUDIENCE: [INAUDIBLE]
99:31 - DAVID J. MALAN: He has
no other information.
99:32 - So yes, like that was
the best you can do.
99:34 - But let me give you a
little more information.
99:35 - You can stay here.
99:36 - And let me go ahead and
reload the screen here.
99:40 - And let me go ahead and pull
up a different set of doors.
99:43 - And now suppose that, much like the
phone book, and much like the phones
99:46 - are sorted, now these doors are sorted.
99:49 - And find us the number 50.
99:54 - All right.
99:54 - So good.
99:55 - What did you do that time?
99:57 - AUDIENCE: Well, [INAUDIBLE].
99:59 - It was 50 is 116.
100:00 - So I just--
100:01 - DAVID J. MALAN: Right.
100:02 - So you jumped to the middle,
initially, and then to the right half.
100:07 - And then technically-- so we're
technically off by 1, right?
100:10 - Because like binary search would
have gone to the middle of the--
100:12 - that's OK, but very well done to Eric.
100:14 - Here, let me at least reinforce
this with a stress ball.
100:18 - So thank you.
100:20 - Very well done.
100:21 - So with that additional
information, as you know,
100:23 - Eric was able to do better because the
information was sorted on the screen.
100:27 - But he only had one insight
to a locker at a time,
100:30 - because only by revealing what's
inside can he actually see it.
100:33 - So this seems to
suggest that once you do
100:35 - have this additional information in
Eric's example, in your phone example,
100:39 - in the phone book example, you open up
possibilities for much much, much more
100:44 - efficient algorithms.
100:45 - But to get there, we've kind of been
deferring this whole time in class
100:50 - how you actually sort these elements.
100:53 - And if you wouldn't mind-- and this way,
we'll hopefully end on a more energized
100:56 - note here because I know we've
been in the weeds for a while--
100:59 - can we get like eight volunteers?
101:02 - OK, so 1, 2, 3, 4-- how about
5, 6, 7, 8, come on down.
101:09 - Oh, I'm sorry.
101:09 - Did I completely overlook the front row?
101:11 - OK.
101:12 - All right, next time.
101:13 - Next time.
101:14 - Come on down.
101:20 - Oh, and Colton, do you mind
meeting them over there instead?
101:23 - All right.
101:25 - Come on up.
101:26 - What's your name?
101:26 - [? CAHMY: ?] [? Cahmy. ?]
101:27 - DAVID J. MALAN: [? Cahmy? ?] David.
101:28 - Right over there.
101:29 - What's your name?
101:29 - MATT: Matt.
101:29 - DAVID J. MALAN: Matt?
101:30 - David.
101:30 - [? JUHE: ?] [? Juhe. ?]
101:31 - DAVID J. MALAN: [? Juhe? ?] David.
101:32 - MAX: Max.
101:32 - DAVID J. MALAN: Max, nice to meet you.
101:33 - JAMES: James.
101:34 - DAVID J. MALAN: James, nice to see you.
101:35 - Here, I'll get more chairs.
101:36 - What's your name?
101:37 - ,PEYTON: Peyton.
101:37 - DAVID J. MALAN: Peyton?
101:38 - David.
101:38 - And two more.
101:40 - Actually can what have you
come down to this end here?
101:42 - What's your name.
101:43 - ANDREA: Andrea.
101:43 - DAVID J. MALAN: Andrea, nice to see you.
101:45 - And your name?
101:46 - [? PICCO: ?] [? Picco. ?]
101:46 - DAVID J. MALAN: [? Picco, ?] David.
101:47 - Nice to see you.
101:48 - OK, Colton has a T-shirt for each
of you, very Harvard-esque here.
101:54 - And each of these shirts, as you're
about to see, has a number on it.
101:57 - And that number is--
102:00 - well, go ahead put them
on, if you wouldn't mind.
102:06 - OK, thank you so much.
102:07 - So I daresay we've arranged our humans
much like the lockers in an array.
102:11 - Like we have humans back,
to back, to back, to back.
102:13 - But this is actually both a
blessing and a constraint,
102:17 - because we only have eight chairs.
102:18 - So there's really not much room here, so
we're confined to just this space here.
102:22 - And I see we have a 4,
8, 5, 2, 3, 1, 6, 7.
102:25 - So this is great.
102:26 - Like they are unsorted.
102:28 - By definition, it's pretty random.
102:29 - So that's great.
102:30 - So let's just start off like this.
102:31 - Sort yourselves from 1 to 8, please.
102:42 - OK.
102:42 - All right.
102:43 - Well, what algorithm was that?
102:45 - [LAUGHTER]
102:46 - AUDIENCE: Look around, figure it out.
102:47 - DAVID J. MALAN: Look
around, figure it out.
102:49 - OK, well--
102:49 - MATT: Human ingenuity.
102:50 - DAVID J. MALAN: Human ingenuity?
102:51 - Very well done.
102:52 - So can we-- well, what
was like a thought
102:54 - going through any of your minds?
102:56 - MATT: Find a chair and sit down.
102:57 - DAVID J. MALAN: Find the chair--
102:58 - find the right chair.
102:59 - So go to a location.
103:00 - Good.
103:01 - So like an index location, right?
103:02 - Arrays have indices, so to spea--
103:04 - 0, 1, 2, all the way up to 7.
103:07 - And even though our shirts
are numbered from 1 to 8,
103:10 - you can think in terms of 0 to 7.
103:11 - So that was good.
103:12 - Anyone else?
103:12 - Other thoughts?
103:14 - [? CAHMY: ?] I mean, this is
something we implicitly think of,
103:17 - but no one told us that it
was ordered right to left.
103:19 - Like we could have
done it left to right.
103:20 - DAVID J. MALAN: OK.
103:21 - Absolutely.
103:21 - Could have gone from right to
left, instead of left to right.
103:23 - But at least we all
agreed on this convention
103:25 - too, so that was in your mind.
103:26 - OK.
103:26 - So good.
103:27 - So we got this sorted.
103:28 - Go ahead and re-randomize
yourself, if you could.
103:35 - And what algorithm was this?
103:37 - Just random awkwardness?
103:38 - OK, so that's fine.
103:39 - So it looks pretty random.
103:41 - That will do.
103:42 - Let's see if we can now
reduce the process of sorting
103:44 - to something a little more algorithmic
so that, one, we can be sure
103:47 - we're correct and not just kind of get
lucky that everyone kind of figured it
103:50 - out and no one was
left out, and two, then
103:52 - start to think about how
efficient it is, right?
103:54 - Because if we've been gaining so
much efficiency for the phone book,
103:57 - for our contacts, for
[? error ?] coming up,
103:59 - we really should have been
asking the whole time,
104:01 - sure, you save time with binary
search and divide and conquer,
104:05 - but how much did it cost
you to get to a point
104:08 - where you can use binary
search and divide and conquer?
104:10 - Because sorting, if it's super, super,
super expensive and time-consuming
104:14 - maybe it's a net negative.
104:15 - And you might as well just
search the whole list,
104:17 - rather than ever sort anything.
104:18 - All right.
104:19 - So let's see here.
104:20 - 6 and 5, I don't like this.
104:22 - Why?
104:24 - AUDIENCE: [INAUDIBLE]
104:25 - DAVID J. MALAN: 6 is
supposed to come after 5.
104:27 - And so, can we fix this, please?
104:29 - All right.
104:30 - And then let's see.
104:30 - OK, 6 and 1-- ugh,
don't really like this.
104:33 - Yeah, can we fix this?
104:36 - Very nice.
104:36 - 6 and 3, OK, you really got the
short end of the stick here.
104:39 - So 6 and 3, could we fix this?
104:43 - And 6-- yeah, OK.
104:44 - Ooh, OK, 6 and 7-- good.
104:46 - All right, so that's pretty good.
104:47 - 7 and 8, nice.
104:49 - 8 and 4, sorry.
104:50 - Could we switch here?
104:52 - All right.
104:53 - And then 8 and 2?
104:54 - OK, could we switch here?
104:56 - OK.
104:56 - And let me ask you a
somewhat rhetorical question.
104:58 - OK, am I done?
105:00 - OK, no.
105:00 - Obviously not, but I did
fix some problems, right?
105:03 - I fixed some transpositions,
numbers being out of order.
105:06 - And in fact, I-- what's your name again?
105:07 - [? CAHMY: ?] [? Cahmy. ?]
105:08 - DAVID J. MALAN: [? Cahmy, ?] kind of
bubbled to the right here, if you will.
105:11 - Like you were kind of farther
down, and now you're over here.
105:14 - And like the smaller
numbers, kind of-- yeah 1.
105:16 - Like, my god, like he kind
of bubbled his way this way.
105:19 - So things are percolating,
in some sense.
105:21 - And that's a good thing.
105:23 - And so you know what?
105:24 - Let Me try to fix some
remaining problems.
105:26 - So 1 and 5-- good.
105:27 - Oh 3 and 5, could you switch?
105:29 - 5 and 6, OK.
105:31 - 6 and 7?
105:32 - 7 and 4, could you switch?
105:34 - OK.
105:36 - And 7 and 2, could you switch?
105:40 - And now, I don't have to
speak with [? Cahmy ?] again,
105:42 - because we know you're
in the right place.
105:44 - So I actually don't have
to do quite as much work
105:46 - this time, which is kind of nice.
105:48 - But am I done?
105:49 - No, obviously not.
105:50 - But what's the pattern now?
105:52 - Like what's the fundamental primitive?
105:53 - If I just compare pairwise
humans and numbers,
105:57 - I can slightly improve
the situation each time
105:59 - by just swapping them, swapping them.
106:01 - And each time now--
106:02 - I'm sorry, [? Picco ?]
is in number 7's place.
106:04 - I don't have to talk to him
anymore, because he's now bubbled
106:07 - his way all the way up to the top.
106:08 - So even though I'm doing the
same thing again and again,
106:10 - and looping again and again
isn't always the best thing,
106:13 - so long as you're looping fewer and
fewer times, I will eventually stop,
106:16 - it would seem.
106:17 - Because 6 is going to eventually
go in the right place, and then 5,
106:20 - and then 4, and so forth.
106:21 - So if we can just finish this algorithm.
106:22 - Good.
106:24 - Not good.
106:26 - OK, 6 and 2, not good.
106:27 - If you could swap?
106:28 - OK, and what's your name again?
106:30 - PEYTON: Peyton.
106:31 - DAVID J. MALAN: Peyton is
now in the right place.
106:32 - I have even less work now ahead of me.
106:33 - So if I can just continue this process--
106:35 - 1 and 3, 3 and 5, 4 and
5, OK, and then 2 and 5.
106:39 - And then, what's your name again?
106:40 - MATT: Matt.
106:41 - DAVID J. MALAN: Matt is
now in the right place.
106:42 - Even less work.
106:43 - We're almost there.
106:44 - 1 and 3, 3 and 4, 4 and
2, if you could swap.
106:47 - OK, almost done.
106:48 - And 1 and 3, 3 and 2, if you could swap.
106:51 - Nice.
106:52 - So this is interesting.
106:53 - It would seem that-- you
know, in the first place,
106:55 - I kind of compared
seven pairs of people.
106:59 - And then the next time I went through,
I compared how many pairs of people
107:02 - maximally?
107:02 - AUDIENCE: [INAUDIBLE]
107:03 - DAVID J. MALAN: Just six, right?
107:05 - Because we were able to
leave [? Cahmy ?] out.
107:06 - And then we were able to leave
[? Picco ?] out, and then Peyton.
107:09 - And so the number of comparisons I
was doing was getting fewer and fewer.
107:12 - So that feels pretty good.
107:13 - But you know what?
107:14 - Before We even analyze that, can
you just randomize yourselves again?
107:17 - Any human algorithm is fine.
107:18 - Let's try one other approach, because
this feels kind of non-obvious, right?
107:22 - I was fixing things, but I had to
keep fixing things again and again.
107:26 - Let me try to take a bigger
bite out of the problem
107:28 - this time by just selecting
the smallest person.
107:30 - OK, so your name again is?
107:31 - [? JUHE: ?] [? Juhe. ?]
107:32 - DAVID J. MALAN: [? Juhe, ?] number
2-- that's a pretty small number,
107:34 - so I'm going to remember that
in sort of a mental variable.
107:36 - 4?
107:36 - No, you're too big.
107:37 - Too big.
107:39 - Oh, what was your name again?
107:40 - JAMES: James.
107:40 - DAVID J. MALAN: James.
107:41 - James is a 1.
107:42 - That's pretty nice.
107:43 - Let me keep checking.
107:43 - OK, James, in my mental
variable is the smallest number.
107:47 - I know I want him at the beginning.
107:48 - So if you wouldn't mind coming with me.
107:50 - And I'm sorry, we don't
have room for you anymore.
107:52 - If you could just-- oh, you know what?
107:53 - Could you all just shuffle down?
107:55 - Well, hm, I don't know if I like that.
107:57 - That's a lot of work, right?
107:58 - Moving all these values,
let's not do that.
108:00 - Let's not do that.
108:01 - Number 2, could you
mind just going where--
108:03 - where--
108:03 - JAMES: It's James.
108:04 - DAVID J. MALAN: --James was?
108:06 - OK, so I've kind of made the
problem a little worse in that,
108:09 - now, number 2 is farther
away from the goal.
108:11 - But I could have gotten lucky,
and maybe she was number 7 or 8.
108:14 - And so let me just claim that, on
average, just evicting the person
108:17 - is going to kind of be
a wash and average out.
108:20 - But now James is in the right place.
108:21 - Done.
108:22 - Now I have a problem that's of size 7.
108:24 - So let me select the
next smallest person.
108:26 - 4 is the next smallest, not
8, not 5, not 7-- ooh, 2.
108:29 - Not 3, 6.
108:30 - OK, so you're back in the game.
108:32 - All right, come on back.
108:33 - And can we evict number 4?
108:35 - And on this algorithm,
if you will, I just
108:37 - interpretively select
the smallest person.
108:40 - I'm not comparing everyone in quite the
same way and swapping them pairwise,
108:44 - I'm doing some of more
macroscopic swaps.
108:46 - So now I'm going to look for
the next smallest, which is 3.
108:48 - If you wouldn't mind
popping around here?
108:50 - [? Cahmy, ?] we have to,
unfortunately, evict you,
108:52 - but that works out to our favor.
108:53 - Let me look for the next
smallest, which is 4.
108:55 - OK, you're back in.
108:56 - Come on down.
108:57 - Swap with 5.
108:58 - OK, now I'm looking for 5.
109:00 - Hey, 5, there you are.
109:01 - OK.
109:01 - So go here.
109:02 - OK, looking for 6.
109:03 - Oh, 6, a little bit of a shuffle.
109:06 - OK.
109:07 - And now looking for 7.
109:08 - Oh, 7, if you could go here.
109:10 - But notice, I'm not going back.
109:12 - And this is what's important.
109:13 - Like my steps are getting
shorter and shorter.
109:15 - My remaining steps are
getting shorter and shorter.
109:17 - And now we've actually
sorted all of these humans.
109:21 - So two fundamentally different ways,
but they're both comparative in nature,
109:24 - because I'm comparing
these characters again,
109:27 - and again, and again, and swapping
them if they're out of order.
109:29 - Or at a higher level, going
through and swapping them again,
109:34 - and again, and again.
109:35 - But how many steps am
I taking each time?
109:38 - Even though I was doing fewer and
fewer and I wasn't doubling back,
109:41 - the first time, I was doing
like n minus 1 comparisons.
109:45 - And then I went back here.
109:46 - And in the first algorithm, I
kind of stopped going as far.
109:50 - In the second algorithm, I
just didn't go back as far.
109:53 - So it was just kind of a different
way of thinking of the problem.
109:56 - But then I did what?
109:57 - Like seven comparisons?
109:59 - Then six, then five, then four,
then three, then two, then one.
110:03 - It's getting smaller, but how
many comparisons is that total?
110:06 - I've got like n people,
n being a number.
110:09 - AUDIENCE: [INAUDIBLE]
110:10 - DAVID J. MALAN: Is not
as bad as factorial.
110:12 - We'd be here all day long.
110:14 - But it is big.
110:15 - It is big.
110:15 - Let's go-- a round of applause,
if we could, for our volunteers.
110:18 - You can keep the shirts, if
you'd like, as a souvenir.
110:19 - [APPLAUSE]
110:20 - Thank you, very much.
110:22 - Let me see if we can't just kind of
quantify that-- thank you, so much--
110:26 - and see how we actually
got to that point.
110:29 - If I go ahead and pull up not our
lockers, but our answers here,
110:34 - let me propose that what we just
did was essentially two algorithms.
110:38 - One has the name bubble.
110:39 - And I was kind of deliberately kind
of shoehorning the word in there.
110:42 - Bubble sort is just that
comparative sort, pair by pair,
110:45 - fixing tiny little mistakes.
110:47 - But we needed to do it
again, and again, and again.
110:50 - So those steps kind of add up, but
we can express them as pseudocode.
110:54 - So in pseudocode-- and you can
write this any number of ways--
110:56 - I might just do the following.
110:58 - Just keep doing the following,
until there's no remaining swaps--
111:01 - from i from 0 to n -2, which is just
n is the total number of humans.
111:06 - n -2 is go up from that
person to this person,
111:10 - because I want to compare him or
her against the person next to them.
111:13 - So I don't want to accidentally do this.
111:14 - That's why it's n -2 at the end here.
111:16 - Then I want to go ahead and, if the
ith and the ith +1 elements are out
111:19 - of order, swap them.
111:21 - So that's why I was asking our
human volunteers to exchange places.
111:24 - And then just keep doing that,
until there's no one left to swap.
111:27 - And by definition, everyone is in order.
111:29 - Meanwhile, the second algorithm has the
conventional name of selection sort.
111:33 - Selection sort is literally
just that, where you actually
111:37 - select the smallest person, or number
of interest to you, intuitively,
111:40 - again and again.
111:41 - And the number keeps
getting bigger, but you
111:43 - start ignoring the people who
you've already put into place.
111:45 - So the problem, similarly, is
getting smaller and smaller.
111:48 - Just like in bubble sort, it was
getting more and more sorted.
111:52 - The pseudocode for selection
sort might look like this.
111:54 - For i from 0 to n -1,
so that's 0 in an array.
111:58 - And this is n -1.
112:00 - Just keep looking for the smallest
element between those two chairs,
112:05 - and then pull that person out.
112:06 - And then just evict
whoever's there-- swap them,
112:09 - but not necessarily adjacently,
just as far away as is necessary.
112:13 - And in this way, I keep turning
my back on more and more people
112:16 - because they are then in place.
112:18 - So two different
framings of the problem,
112:20 - but it turns out they're actually both
the same number of steps, give or take.
112:24 - It turns out they're roughly
the same number of steps,
112:27 - even though it's a different
way of thinking about it.
112:29 - Because if I think about bubble sort,
the first iteration, for instance,
112:32 - what just-- actually, well, let's
consider selection sort even.
112:35 - In selection sort, how many
comparisons did I have to do?
112:39 - Well, once I found my
smallest element, I
112:41 - had to compare them
against everyone else.
112:43 - So that's n -1 comparisons
the first time.
112:46 - So n -1 on the board.
112:47 - Then I can ignore them,
because they're behind me now.
112:50 - So now I have how many
comparisons left out of n people?
112:54 - n -2, because I subtracted one.
112:56 - Then again, n -3, then n -4, all the
way down to just one person remaining.
113:00 - So I'll express that sort of
generally, mathematically, like this.
113:03 - So n -1 plus n -2 plus whatever plus
one final comparison, whatever that is.
113:09 - It turns out that if you actually
read the back of the math
113:12 - book or your physics textbooks
where they have those little cheat
113:14 - sheets as to what these recurrences are,
turns out that n -1 plus n -2 plus n -3
113:20 - and so forth can be
expressed more succinctly
113:22 - as literally just n
times n -1 divided by 2.
113:26 - And if you don't recall that, that's OK.
113:28 - I always look these things up as well.
113:30 - But that's true-- fact.
113:32 - So what does that equal out to?
113:33 - Well, it's like n squared minus
n, if you just multiply it out.
113:36 - And then if you divide
the two, then it's
113:38 - n squared divided by 2 minus n over 2.
113:40 - So that's the total number of steps.
113:42 - And I could actually plug this in.
113:43 - We could plug in 8, do the math, and
get the total number of comparisons
113:46 - that I was verbally
kind of rattling off.
113:49 - So is that a big deal?
113:51 - Hm, it feels like it's on
the order of n squared.
113:54 - And indeed, a computer
scientist, when assessing
113:56 - the efficiency of an algorithm,
tends not to care too much
113:59 - about the precise values.
114:00 - All we're going to care
about it's the biggest term.
114:02 - What's the value in the
formula that you come up
114:05 - with that just dominates the
other terms, so to speak,
114:07 - that has the biggest effect, especially
as n is getting larger and larger?
114:11 - Now, why is this?
114:12 - Well, let's just do sort of
proof by example, if you will.
114:15 - If this is the expression,
technically, but I
114:18 - claim that, ugh, it's
close enough to say
114:20 - on the order of, big O of n squared,
so to speak, let's use an example.
114:24 - If there's a million people
on stage, and not just eight,
114:27 - that math works out to
be like a million squared
114:29 - divided by 2 steps minus a
million divided by 2, total.
114:33 - So what does that
actually work out to be?
114:35 - Well, that's 500 billion minus 500,000.
114:38 - And what does that work out to be?
114:40 - Well, that's 499 billion,
999 million, 500,000.
114:46 - That feels pretty darn
close to like n squared.
114:49 - I mean, that's a drop in the bucket
to subtract 500,000 from 500 billion.
114:54 - So you know what?
114:55 - Eh, it's on the order of n squared.
114:57 - It's not precise, but it's in
that general order of magnitude,
115:01 - so to speak.
115:02 - And so this symbol, this
capital 0, is literally a symbol
115:04 - used in computer science
and in programming
115:06 - to just kind of describe
with a wave of the hand,
115:09 - but some good intuition and algorithm,
how fast or slow your algorithm is.
115:13 - And it turns out there's different
ways to evaluate algorithms
115:16 - with just different similar formulas.
115:18 - n squared happens to be how much
time both bubble sort and selection
115:21 - sort take.
115:22 - If I literally count
up all of the work we
115:24 - were doing on stage
with our volunteers, it
115:26 - would be roughly n squared, 8
squared, or 64 steps, give or take,
115:32 - for all of those humans.
115:33 - And that would be notably off.
115:35 - There's a good amount
of rounding error there.
115:36 - But if we had a million
volunteers on stage,
115:39 - then the rounding error
would be pretty negligible.
115:42 - But we've actually seen some of
these other orders of magnitude,
115:45 - so to speak, before.
115:46 - For instance, when we counted someone,
or we searched for Mike Smith one page
115:49 - at a time, we called
that a linear algorithm.
115:52 - And that was big O of n.
115:53 - So it's on the order of n steps.
115:55 - It's 1,000.
115:55 - Maybe it's 999.
115:56 - Whatever.
115:57 - It's on the order of n steps.
115:58 - The [? twosies ?] approach was twice
as fast, recall-- two pages at a time.
116:02 - But you know what?
116:03 - That's still linear, right?
116:05 - Like two pages at a time?
116:06 - Let me just wait till next
year when my CPU is twice
116:08 - as fast, because Intel and companies
keep speeding up computers.
116:10 - The algorithm is fundamentally the same.
116:12 - And indeed, if you think
back to the picture we drew,
116:15 - the shapes of those curves
were indeed the same.
116:18 - That first algorithm, finding Mike
one page at a time looked like this.
116:22 - Second algorithm finding
him looked like this.
116:24 - Only the third algorithm, the divide
and conquer, splitting the phone book
116:28 - was a fundamentally different shape.
116:29 - And so even though we didn't use
this fancy phrasing a couple of weeks
116:33 - ago, these first algorithms, one page
at a time, two pages at a time, eh,
116:37 - they're on the order of n.
116:39 - Technically, yes, n
versus n divided by 2,
116:42 - but we only care about the
dominating factor, the variable n.
116:46 - We can throw away everything
in the denominator,
116:48 - and we can throw away everything that's
smaller than the biggest term, which
116:51 - in this case is just n.
116:52 - And I alluded to this two weeks ago--
116:54 - logarithmic.
116:55 - Well, it turns out that any time you
divide something again, and again,
116:58 - and again, you're leveraging
a logarithmic type function,
117:02 - log base 2 technically.
117:03 - But on the order of log base
n is a common one as well.
117:08 - The beautiful algorithms are these--
117:10 - literally, one step, or technically
constant number of steps.
117:14 - For instance, like what's an
algorithm that might be constant time?
117:20 - Open phone book.
117:21 - OK, one step.
117:22 - Doesn't really matter
how many pages there are,
117:24 - I'm just going to open the phone book.
117:25 - And that doesn't vary
by number of pages.
117:27 - That might be a constant
time algorithm, for instance.
117:30 - So those are the lowest you can go.
117:32 - And then there's somewhere
even in between here
117:34 - that we might aspire to with
certain other algorithms.
117:37 - So in fact, let's just
see if-- just a moment--
117:41 - let's just see if we can do
this a little more succinctly.
117:44 - Let's go ahead and use arrays in just
one final way, using merge sorts.
117:50 - So it turns out, using
an array, we can actually
117:53 - do something pretty powerfully,
so long as we allow ourselves
117:56 - a couple of arrays.
117:58 - So again, when we just add sorting
with bubble sort and selection sort,
118:00 - we had just one array.
118:01 - We had eight chairs
for our eight people.
118:04 - But if I actually allowed myself
like 16 chairs, or even more,
118:07 - and I allowed these
folks to move a bit more,
118:10 - I could actually do even
better than that using arrays.
118:12 - So here's some random numbers that we'll
just do visually, without any humans.
118:16 - And they're in an array, back,
to back, to back, to back.
118:18 - But if I allow myself
a second array, I'm
118:20 - going to be able to shuffle these
things around and not just compare them,
118:23 - because it was those comparisons and
all of my footsteps in front of them
118:26 - that really started
to take a lot of time.
118:28 - So here's my array.
118:29 - You know what?
118:29 - Just like the phone book-- that
phone book example got us pretty far
118:32 - in the first week--
118:33 - let me do half of the problem at a time
and then kind of combine my answer.
118:38 - So here's an array--
118:39 - 4, 2, 7, 5, 6, 8, 3,
1-- randomly sorted.
118:42 - Let me go ahead and
sort just half of this,
118:44 - just like I searched for Mike initially
in just half of the phone book.
118:47 - So 4, 2, 7, 5-- not sorted.
118:50 - But you know what?
118:51 - This feels like too big
of a problem, still.
118:53 - Let me sort just the left
half of the left half.
118:56 - OK, now it's a smaller problem.
118:58 - You know what?
118:59 - 4 and 2, still out of order.
119:00 - Let me just divide this list of two
into two tiny arrays, each of size 1.
119:05 - So here's a mini-array of size 1,
and then another one of like size
119:08 - 7, but they're back
to back, so whatever.
119:10 - But this array of size 1, is it sorted?
119:14 - AUDIENCE: No.
119:15 - DAVID J. MALAN: I'm sorry?
119:16 - AUDIENCE: No.
119:17 - DAVID J. MALAN: No?
119:18 - If this array has just one
element and that element is 4--
119:21 - AUDIENCE: There's only
one thing you can do.
119:22 - DAVID J. MALAN: Yes, then
it is sorted, by definition.
119:24 - All right, so done.
119:25 - Making some progress.
119:26 - Now, let me kind of mentally rewind.
119:28 - Let me sort the right
half of that array.
119:32 - So now I have another array of size 1.
119:34 - Is this array sorted?
119:36 - Yeah, kind of stupidly.
119:37 - We don't really seem
to be doing anything.
119:39 - We're just making claims.
119:40 - But yes, this is sorted.
119:41 - But now, this was the original half.
119:44 - And this half is sorted.
119:46 - This half is sorted.
119:47 - What if I now just kind of
merge these sorted halves?
119:49 - I've got two lists of size 1--
119:52 - 4 and 2.
119:53 - And now if I have extra storage
space, if I had like extra benches,
119:56 - I could do this a little better.
119:58 - don't I go ahead and merge
these two as follows?
120:00 - 2 will go there.
120:02 - 4 will go there.
120:03 - So now I've taken two sorted lists
and made one bigger, more sorted list
120:06 - by just merging them together,
leveraging some additional space.
120:10 - Now, let me mentally rewind.
120:11 - How did I get to 4 and 2?
120:12 - Well, I started with the left half,
then the left half of the left half.
120:15 - Let me now do the right half
of the left half, if you will.
120:19 - All right, let me divide this again.
120:20 - 7, list of size 1, is it sorted?
120:23 - Yes, trivially.
120:24 - 5, is it sorted?
120:26 - Yes.
120:27 - 7 and 5, let's go ahead
and merge them together.
120:29 - 5 is, of course, going to go here.
120:31 - 7, of course, is going to go here.
120:33 - OK.
120:34 - Now where do we go?
120:35 - We originally sorted the left half.
120:37 - Let's go sort the right-- oh, right.
120:39 - Sorry.
120:40 - Now, we have the left half.
120:41 - And the right half of
the left half are sorted.
120:45 - Let's go ahead and merge these.
120:46 - We have two lists now of size 2--
120:48 - 2, 4 and 5, 7, both of which are sorted.
120:52 - If I now merge 2, 4 and 5, 7,
which element should come first
120:56 - in the new longer list, obviously?
120:59 - 2.
121:00 - And then 4, then 5, and then 7.
121:01 - That wasn't much of anything.
121:03 - But OK, we're just using a
little more space in our array.
121:05 - Now what comes next?
121:07 - Now, let's do the right half.
121:08 - Again, we started by taking the
whole problem, doing the left half,
121:11 - the left half of the left half, the left
half of the left half of the left half.
121:14 - And now we're going back
in time, if you will.
121:17 - So let's divide this into two
halves, now the left half into two
121:20 - halves still.
121:21 - 6 is sorted.
121:22 - 8 is sorted.
121:23 - Now I have to merge them--
121:24 - 6, 8.
121:26 - What comes next?
121:26 - Right half-- 3 and 1.
121:29 - Well, left half is sorted,
right half is sorted--
121:31 - 1 and 3.
121:33 - All right, now how do I merge these?
121:35 - 6, 8, 1, 3, which element
should obviously come first?
121:38 - 1, then 3, then 6, then 8.
121:42 - And then lastly, I have
two lists of size four.
121:45 - Let me give myself a little
more space, one more array.
121:48 - Now let me go ahead and put
1, and 2, and 3, and 4, and 5,
121:53 - and 6, and 7, and 8.
121:56 - What just happened?
121:57 - Because it actually happened a lot
faster, even though we were doing this
122:00 - all verbally.
122:01 - Well notice, how many times did
each number change locations?
122:09 - Literally three, right?
122:10 - Like one, two, three, right?
122:13 - It moved from the original array, to the
secondary array, to the tertiary array,
122:17 - to the fourth array,
whatever that's called.
122:19 - And then it was ultimately in place.
122:21 - So each number had to move
one, two, three spots.
122:24 - And then how many numbers are there?
122:26 - AUDIENCE: [INAUDIBLE]
122:28 - DAVID J. MALAN: Well, they were
already in the original array.
122:30 - So how many times do they have to move?
122:32 - Just one, two, three.
122:33 - So how many total numbers
are there, just to be clear?
122:36 - There's eight.
122:37 - So 8 times 3.
122:38 - So let's generalize this.
122:39 - If there's n numbers,
and each time we moved
122:43 - the numbers we did like half of
them, than half, then half, well,
122:46 - how many times can you divide 8 by 2?
122:50 - 8 goes to 4.
122:51 - 4 goes to 2.
122:52 - 2 goes to 1.
122:53 - And that's why we bottomed out
at one element, lists of size 1.
122:57 - So it turns out whenever you divide
something by half, by half, by half,
123:00 - what is that function or formula?
123:05 - Not power, that's bad.
123:06 - That's the other direction.
123:07 - AUDIENCE: [INAUDIBLE]
123:08 - DAVID J. MALAN: It's a logarithm.
123:08 - So again, logarithm is just
a mathematical description
123:11 - for any function that you keep dividing
something again, and again, and again.
123:14 - In half, in half, in half, in third,
in third, in third, whatever it is,
123:17 - it just means division by the
same proportional amounts again,
123:20 - and again, and again.
123:22 - And so if we move the numbers
three times, or more generally log
123:27 - of n times, which again just
means you divided n things again,
123:31 - and again, and again,
you just call that log n.
123:33 - And there's n numbers,
so n numbers moved
123:36 - log n times, the total
arithmetic here in question
123:40 - is one of those other values on
our little cheat sheet, which
123:44 - looked like this.
123:46 - In our other cheat sheet, recall that
we had formulas that looked like this,
123:51 - not just n squared and n, and log n,
and 1, we have this one in the middle--
123:55 - n times log n.
123:57 - So again, we're kind
of jumping around here.
123:59 - But again, each number
moves log n places.
124:02 - There's n total numbers.
124:03 - So n times log n is just,
by definition, n log n.
124:07 - But why is this sorted this way?
124:09 - Well log n, recall from week
0 with the phone book example,
124:12 - the green curve is definitely smaller
than n. n was the straight lines,
124:16 - log n was the green curved one.
124:18 - So this indeed belongs in between,
because this is n times n.
124:21 - This is n.
124:22 - This is n times
something smaller than n.
124:25 - So what's the actual implication?
124:26 - Well, if we were to run
these algorithms side by side
124:29 - and actually compare them
with something like this--
124:34 - let me go ahead and compare these
algorithms using this demo here--
124:41 - if I go ahead and hit play, we'll
see that the bars in this chart
124:44 - are actually horizontal.
124:45 - And the small bars
represent small numbers,
124:47 - large bars represent long numbers.
124:49 - And then each of these is going to
run a different algorithm-- selection
124:52 - sort on the left, bubble
sort in the middle,
124:54 - merge sort, as we'll now
call it, on the right.
124:57 - And here's how long each of
them take to sort those values.
125:04 - Bubble's still going.
125:06 - Selection's still going.
125:07 - And so that's the appreciable
difference, albeit with a small demo,
125:09 - between n squared and
something like log n.
125:12 - And so what have we done here?
125:13 - We've really, really, really got into
the weeds of what arrays can actually
125:17 - do for us and what the relationships
are with strings, because all of it
125:20 - kind of reduces to just things being
back, to back, to back, to back.
125:22 - But now that we kind
of come back, and we'll
125:24 - continue along this
trajectory next time to be
125:26 - able to talk at a much higher level
about what's actually going on.
125:29 - And we can now take this
even further, by applying
125:32 - other sort of forms of media to
these same kinds of questions.
125:35 - And we'll conclude it's
about 60 seconds long.
125:37 - These bars are vertical,
instead of horizontal.
125:39 - And what you'll see
here is a visualization
125:41 - of various sorting algorithms,
among them selection sort, bubble
125:43 - sort, and merge sort, and a whole
assortment of others, each of which
125:46 - has even a different sound
to it because of the speed
125:50 - and the pattern by which
it actually operates.
125:53 - So let's take a quick look.
125:54 - [VIDEO PLAYBACK]
125:55 - [MUSIC PLAYING]
126:05 - This is bubble sort.
126:06 - And you can see how the larger elements
are indeed bubbling up to the top.
126:15 - [?
126:16 - And you can kind of
hear the ?] periodicity,
126:18 - or the cycle that it's going in.
126:25 - And there's less, and less, and less,
and less work to do, until almost--
126:33 - This is selection sort now.
126:34 - So it starts off random, but we
keep selecting the smallest human
126:38 - or, in this case, the shortest bar.
126:41 - And you'll see here the bars
correlate with frequency, clearly.
126:45 - So it's getting higher and
higher and taller and taller.
126:50 - This is merge sort now which,
recall, does things in halves,
126:53 - and then halves of halves,
and then merges those halves.
126:57 - So we just did all the left
work, almost all the right work.
127:03 - That one's very gratifying.
127:04 - [LAUGHS]
127:06 - This is something called [? nom ?]
sort, which is improving things.
127:10 - Not quite perfectly, but it's
always making forward progress,
127:13 - and then kind of doubling
back and cleaning things up.
127:24 - [END PLAYBACK]
127:24 - Whew.
127:25 - That was a lot.
127:26 - Let's call it a day.
127:26 - I'll stick around for
one-on-one questions.
127:28 - We'll see you next time.
127:29 - [APPLAUSE]

Cleaned transcript:

[MUSIC PLAYING] DAVID J. MALAN All right. This is CS50 and this is the start of week two. And you'll recall that over the past couple of weeks, we've been building up. First initially from Scratch, the graphical programming language that we then, just last week, translated to the equivalent program NC. And of course, there's a lot more syntax now. It's entirely text but the ideas, recall, were fundamentally the same. The catch is that computers don't understand this. They only understand what language? AUDIENCE [INAUDIBLE] DAVID J. MALAN zeros and ones or binary. And so there's a requisite step in order for us to get from this code to binary. And what was that step or that program or process called? AUDIENCE [INAUDIBLE] DAVID J. MALAN Yeah, so compiling. And of course, recall as you've now experimented with this past week that to compile a program, you can use clang for C, language. And you can just say clang and then the name of the file that you want to compile. And that outputs by default a pretty oddly named program. Just a dot out. Which stands for assembler output. More on that in just a moment. But recall too that you can override that default behavior. And you can actually say, Output instead a program called, hello instead of just a dot out. But you can go one step further, and you actually use Make. And Make it self is not a compiler, it's a build utility. But in layman's terms, what does it do for us? AUDIENCE [INAUDIBLE] DAVID J. MALAN compiles it. And it essentially figures out all of those otherwise cryptic looking command line arguments. Like dasho something, and so forth. So that the program is built just the way we want it without our having to remember those seemingly magical incantations. And though that only works for programs as simple as this. In fact, some of you with the most recent problems that might have encountered compilation errors that we actually did not encounter deliberately in class because Make was helping us out. In fact, as soon as you enhance a program to actually take user input using CS50's library by including CS50 dot H, some of you might have realized that all of a sudden the sandbox, and more generally Clang, didn't know what get_string was. And frankly, Clang might not even known what a string was. And that's because those two are features of CS50's library that you have to teach Clang about. But it's not enough to teach Clang what they look like, as by including CS50.h. Turns out there's a missing step that Make helps us solve but that you too can just solve manually if you want. And by that I mean this, instead of compiling a program with just Clang, hello.c. When you want to use CS50's library, you actually need to add this additional command line argument. Specifically at the end, can't go in the beginning like dashO. And dashL stands for link. And this is a way of telling Clang, by the way when compiling my program, please link in CS50's zeros and ones that we the staff wrote some weeks ago and installed in the sandbox for you. So you've got your zeros and ones and then you've got our zeros and ones so to speak. And dashLCS50 says to link them together. So if you were getting some kind of undefined reference error to get_string or you didn't you weren't able to compile a program that just used any of the get functions from CS50's library. Odds are, this simple change dashLCS50 would have fixed. But of course, this isn't interesting stuff to remember, let alone remembering how to use dash0 as well, at which point the command gets really tedious to type. So here comes, Make again. Make automates all of this for us. And in fact, if you henceforth start running Make and then pay closer attention to the fairly long line of output that it outputs, you'll actually see mention of dashLCS50, you'll see mention of even dashLM, which stands for math. So if you're using round, for instance, you might have discovered that round two also doesn't work out of the box unless you use Make itself or this more nuanced approach. So this is all to say that compiling is a bit of a white lie. Like, yes you've been compiling and you've been going from source code to machine code. But it turns out that there's been a number of other steps happening for you that we're going to just slap some labels on today. At the end of the day, we're just breaking the abstraction. So compiling is this abstraction from source code to machine code. Let's just kind of zoom in briefly to appreciate what it is that's going on in hopes that it makes the code we're compiling a little more understandable. So step one of four, when it comes to actually compiling a program is called Preprocessing. So recall that this program we just looked at had a couple of includes at the top of the file. These are generally known as preprocessor directives. Not a particularly interesting term but they're demarcated by the hash at the start of these lines. That's a signal to Clang that these things should be handled first. Preprocessed. Process before everything else. And in fact, the reason for this we did discuss last week, inside of CS50.h is what, for instance? AUDIENCE [INAUDIBLE] DAVID J. MALAN Specifically, the declaration of get strings. So there's some lines of code, the prototype if you recall, that one line of code that teaches Clang what the inputs to get_string are and what the outputs are. The return type and the arguments, so to speak. And so when you have include CS50.h at the top of the file, what is happening when you first run Clang during this socalled preprocessing step, is Clang looks on the hard drive for the file literally called CS50.h. It grabs its contents and essentially finds and replaces this line here. So somewhere in CS50.h is a line like this yellow one here that says get_string, is a function that returns a string. And it takes as input, the socalled argument, a string that we'll call prompt. Meanwhile, with include standard I/O. What's the point of including that? What is declared inside of that file presumably? Yeah? AUDIENCE It's the standard inputs and outputs. DAVID J. MALAN Standard inputs and outputs. And more specifically, what example there of? What function? AUDIENCE [INAUDIBLE] DAVID J. MALAN So printf. The other function we keep using. So inside of standard io.h, somewhere on the sandbox's hard drive is similarly a line of code that frankly looks a little more cryptic but we'll come back to this sort of thing down the road, that says print if is a function. Happens to return on int, but more on that another time. Happens to take a char* format. But more on that another time. Indeed, this is one of the reasons we hide this detail early on because there's some syntax that's just a distraction for now. But that's all that's going on. The sharp include sign is just finding and replacing the contents. Plus dot, dot, dot, a bunch of other things in those files as well. So when we say preprocessing, we just mean that that's getting substituted in so you don't have to copy and paste this sort of thing manually yourself. So "compiling" is a word that actually has a welldefined meaning. Once you've preprocessed your code, and your code looks essentially like this, unbeknownst to you, then comes the actual compilation step. And this code here gets turned into this code here. Now this is scarylooking, and this is the sort of thing that if you take a class like CS61 at Harvard, or, more generally, systems programming, so to speak, you might see something like this. This is x86 64bit assembly instructions. And the only thing interesting about that claim for the moment is that assembly I kind of alluded to that earlier assembler output, a.out. There's actually a relationship here, but long story short, these are the lower level instructions that only the CPU, the brain inside your computer, actually understands. Your CPU does not understand C. It doesn't understand Python or C++ or Java or any language with which you might be familiar. It only understands this crypticlooking thing. But frankly, from the looks of it, you might glean that probably not so much fun to program in this. I mean, arguably, it's not that much fun to program yet in C, So this looks even more cryptic. But that's OK. C and lots of languages are just these abstractions on top of the lower level stuff that the CPUs do actually understand so that we don't have to worry about it as much. But if we highlight a few terms, here you'll see some familiar things. So main is mentioned in this socalled assembly code. You see mention of get string and printf, so we're not losing information. It's just being presented in really a different language, assembly language. Now you can glean, perhaps, from some of the names of these instructions, this is what Intel Inside means. When Intel or any brand of CPU understands instructions, it means things like pushing and moving and subtracting and calling. These are all low level verbs, functions, if you will, but at the level of the CPU. But for more on that, you can take entire courses. But just to take the hood off of this for today, this is a step that's been happening for us magically unbeknownst to us, thanks to Clang. So assembling now that you've got this crypticlooking code that we will never see again we'll never need to output again what do you do with it? Well, you said earlier that computers only understand zeros and ones, so the third step is actually to convert this assembly language to actual zeros and ones that now look like this. So the assembling step happening, unbeknownst to you, every time you run Clang or, in turn, run make, we're getting zeros and ones out of the assembly code, and we're getting the assembly code out of your Ccode. But here's the fourth and final step. Recall that we need to link in other people's zeros and ones. If you're using printf you didn't write that. Someone else created those zeros and ones, the patterns that the computer understands. You didn't create get string. We did, so you need access to those zeros and ones so that your program can use them as well. So linking, essentially, does this. If you've written a program for instance, hello.c and it happens to use a couple of other libraries, files that other people wrote of useful code for you, like cs50.c, which does exist somewhere, and even stdio.c, which does exist somewhere, or technically, Standard IO is such a big library, they actually put printf in a file specifically called printf.c. But somewhere in the sandbox's hard drive, in all of our Macs and PCs, if they support compiling, are, for instance, files like these. But we've got to convert this to zeros and ones, this, and this, and then somehow combine them. So pictorially, this just looks a bit like this. And this is all happening automatically by Clang. Hello.c, the code you wrote, gets compiled to assembly, which then gets assembled into zeros and ones, socalled machine code or object code. Cs50.c we did this for you before the semester started. Printf was done way before any of us started decades ago and looks like this. These are three separate files, though, so the linking step literally means, link all of these things together, and combine the zeros and ones from, like, three, at least, separate files, and just combine them in such a way that now the CPU knows how to use not just your code but printf and get string and so forth. So last week, we introduced compiling as an abstraction, if you will, and this is all that we've really meant this whole time. But now that we've seen what's going on underneath the hood, and we can stipulate that my CPU that looks physically like this, albeit smaller in a laptop or desktop, knows how to deal with all of that. So any questions on these four steps preprocessing, compiling, assembling, linking? But generally, now, we can just call them compiling, as most people do. Any questions? Yeah. AUDIENCE How does the CPU know that [INAUDIBLE] is there? Is that [INAUDIBLE]? DAVID J. MALAN Not in the preprocessing step, so the question is, how does the computer know that printf is the only function that's there? Essentially, when you're linking in code, only the requisite zeros and ones are typically linked in. Sometimes you get more than you actually need, if it's a big library, but that's OK, too. Those zeros and ones are just never used by the CPU. Good question. Other questions? OK, all right. So now that we know this is possible, let's start to build our way back up, because everyone here probably knows now that when writing in C, which is kind of up here conceptually, like, it is not without its hurdles and problems and bugs and mistakes. So let's introduce a few techniques and tools with which you can henceforth, starting this week and beyond, trying to troubleshoot those problems yourself rather than just trying to read through the crypticlooking error messages or reach out for help to another human. Let's see if software can actually answer some of these questions for you. So let me go ahead and do this. Let me go ahead and open up a sandbox here, and I'm going to go ahead and create a new file called buggy0.c in which I will, this time, deliberately introduce a bug. I'm going to go ahead and create my function called main, which, again, is the default, like when green flag is clicked. And I'm going to go ahead and say, printf, quote, unquote, "Hello world/m." All right. Looks pretty good. I'm going to go ahead and compile buggy0, Enter, and of course, I get a bunch of error messages here. Let me zoom in on them. Fortunately, I only have two, but remember, you have to, have to, have to always scroll up to look at the first, because there might just be an annoying cascading effect from one earlier bug to the later. So buggy0.c, line 5, is what this means, character 5, so like 5 spaces in, implicitly declaring library function printf with dot, dot, dot. So you're going to start to see this pretty often if you make this particular mistake or oversight. Implicitly declaring something means you forgot to teach Clang that something exists. And you probably know from experience, perhaps now, what the solution is. What's the first mistake I made here? AUDIENCE [INAUDIBLE]. DAVID J. MALAN Yeah, I didn't include the header file, so to speak, for the library. I'm missing, at the top of the file, include stdio.h, in which printf is defined. But let's propose that you're not quite sure how to get to that point, and how can we get, actually, some help with this? Let me actually increase the size of my terminal here, and recall that just a moment ago, I ran makebuggy0, which yielded the errors that I saw. It turns out that installed in the sandbox is a command that we, the staff, wrote called help50. And this is just a program we wrote that takes as input any error messages that your code or some program has outputted. We kind of look for familiar words and phrases, just like a TF would in office hours, and if we recognize some error message, we're going to try to provide, either rhetorically or explicitly, some advice on how to handle. So if I go ahead and run this command now, notice there's a bit more output. I see exactly the same output in white and green and red as before, but down below is some yellow, which comes specifically from help50. And if I go ahead and zoom in on this, you'll see that the line of output that we recognized is this one, that same one I verbally drew attention to before buggy0.c, line 5, error, implicitly declaring library function printf, and so forth. So here, without the background highlighting, but still in yellow, is our advice or a question a TF or CA might ask you in office hours. Well, did you forget to include stdio.h in which printf is declared atop your file? And hopefully, our questions, rhetorical or otherwise, are correct, and that will get you further along. So let's go ahead and try that advice. So include stdio.h. Now let me go ahead and go back down here. And if you don't like clutter, you can type "clear," or hit Control+L in the terminal window to keep cleaning it like I do. If you want to go ahead now and run makebuggy0, Enter, fewer errors, so that's progress, and not the same. So this one's, perhaps, a little easier. Reading the line, what line of code is buggy here? AUDIENCE Forgot the semicolon. DAVID J. MALAN Yeah, so this is now still on line 5, it turns out, but for a different reason. I seem to be missing a semicolon. But I could similarly ask help50 for help with that and hope that it recognizes my error. So this, too, should start being your first instinct. If on first glance, you don't really understand what an error message is doing, even though you've scrolled to the very first one, like literally ask this program for help by rerunning the exact same command you just ran, but prefix it with help50 and a space, and that will run help50 for you. Any questions on that process? All right, let's take a look at one other program, for instance, that, this time, has a different error involved in it. So how about let me go ahead and whip up a quick program here. I'll call this buggy2.c for consistency with some of the samples we have online for you later. And in this example, I'm going to go ahead and write the correct thing at first, stdio.h, and then I'm going to have int main void, which just gets my whole program started. And then I'm going to have a loop, and recall for [CLEARS THROAT] excuse me Mario or some other program, you might have done something like int i get 0, i is less than or equal to let's do this 10 times, and then i++. And all I want to do in this program is print out that value of i, as I can do, with the %i placeholder so a simple program. Just want it to count from 0 to 10. So let's go ahead and run buggy2, or rather, I want to let's not print up rewind. Let's go ahead and just print out a hash symbol and not spoil the solution this way. So here, I go ahead and print out buggy2. My goal is now I will stipulate to print out just 10 hash symbols, one per line, which is what I want to do here. And now I'm going to go ahead and run ./buggy2, and I should see, hopefully, 10 hashes. And I kind of spoiled this a little bit, but what do I instead see? Yeah, I think I see more than I expect. And we can kind of zoom in here and double check, so 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ooh, 11. 11. Now some of your eyes might already be darting to what the solution should be, but let's just propose that it's not obvious. And if it is actually not obvious, all the better, so how might you go about diagnosing this kind of problem, short of just reaching out and asking a human for help. This is not a problem that help50 can help with, because it's not an error message. Your program is working. It's just not outputting what you wanted it to work, but it's not an error message from the compiler with which help50 can help. So you want to kind of get eyes into what your program is doing, and you want to understand, why are you printing 11 when you really are setting this up from 0 to 10? Well, one of the most common techniques in C or any language, honestly, is to use printf for just other purposes diagnostic purposes. For instance, there's not much going on in this program, but I'd argue that it would be interesting for me to know, and therefore understand my program, by just, let's print out this value of i on each iteration, as by doing the line of code that I earlier did, and just say something literally like, i is %i. I'm going to remove this ultimately, because it's going to make my program look a little silly, but it's going to help me understand what's going on. Let me go ahead and recompile buggy2, ./bugg2, and this time, I see a lot more output. But if I zoom in, now it's kind of now the computer is essentially helping me understand what's going on. When i is 0, here's one of them. When i is 1, here's another. I is 2, 3, 4, 5, 6, 7, 8, 9, and that looks good. But if we scroll a little further, it feels a little problematic that i can also be 10. So what's logically the bug in this program? AUDIENCE [INAUDIBLE]. DAVID J. MALAN Yeah. I use less than or equal to, because I kind of confuse the paradigm. Like programmers tend to start counting at zero, apparently, but I want to do this 10 times, and in the human world, if I want to do something 10 times, I might count up to and including 10. But you can't have it both ways. You can't start at zero and end at 10 if you want to do something exactly 10 times. So there's a couple of possibilities here. How might we fix this? Yeah, so we could certainly change it to less than. What's another correct approach? Yeah, so we could leave this alone and just start counting at one, and if you're not actually printing the values in your actual program, that might be perfectly reasonable, too. It's just not conventional. Get comfortable with, quickly, just counting from zero, because that's just what most everyone does these days. But the technique here is just use printf. Like, when in doubt, literally use printf on this line, on this line, on this line. Anywhere something is interesting maybe going on in your program, just use it to print out the strings that are in your variables, print out the integers that are in your variables, or anything else. And it allows you to kind of see, so to speak, what's going on inside of your program, printf. One last tool so it's not uncommon, when writing code, to maybe get a little sloppy early on, especially when you're not quite familiar with the patterns. And for instance, if I go ahead and do this by deleting a whole bunch of whitespace, even after fixing this mistake by going from zero to 10, is this program now correct, if the goal is to print 10 hashes? Yeah, I heard yes. Why is it correct? In what sense? Yeah, exactly. It still works. It prints out the 10 hashes, one per line, but it's poorly written in the sense of style. So recall that we tend to evaluate, and the world tends to think about code in at least three ways. One, the correctness does it do what it's supposed to do, like print 10 hashes? And yes, it does, because all I did was delete whitespace. I didn't actually change or break the code after making that fix. Two is design, like how thoughtful, how wellwritten is the code? And frankly, it's kind of hard to write this in too many ways, because it's so few lines. But you'll see over time, as your programs grow, the teaching fellows and staff can provide you with feedback on the design of your code. But style is relatively easy. And I've been teaching it mostly by way of example, if you will, because I've been very methodically indenting my code and making sure everything looks very pretty, or at least pretty to a trained eye. But this, let's just stipulate, is not pretty. Like, left aligning everything still works, not incorrect, but it's poorly styled. And what would be an argument for not writing code like this and, instead, writing code the way I did a moment ago, albeit after fixing the bug? Yeah. AUDIENCE It'll help you identify each little subroutine that goes through the thing, so you know this section is here. DAVID J. MALAN Yeah. AUDIENCE [INAUDIBLE] next one, so you know where everything is. DAVID J. MALAN Exactly. Let me summarize this. It allows you to see, more visually, what are the individual subroutines or blocks of code doing that are associated with each other? Scratch is colorful, and it has shapes, like the hugging shape that a lot of the control blocks make, to make clear visually to the programmer that this block encompasses others, and, therefore, this repeats block or this forever block is doing these things again and again and again. That's the role that these curly braces serve, and indentation in this and in other contexts just helps it become more obvious to the programmer what is inside of what and what is happening where. So this is just better written, because you can see that the code inside of main is everything that's indented here. The code that's inside the for loop is everything that's indented here. So it's just for us human readers, teaching fellows in the case of a course, or colleagues in the case of the real world. But suppose that you don't quite see these patterns too readily initially. That, too, is fine. CS50 has on its website what we call a style guide. It's just a summary of what your code should look like when using certain features of C loops, conditions, variables, functions, and so forth. And it's linked on the course's website. But there's also a tool that you can use when writing your code that'll help you clean it up and make it consistent, not just for the sake of making it consistent with the style guide, but just making your own code more readable. So for instance, if I go ahead and run a command called style50 on this program, buggy2.c, and then hit Enter, I'm going to see some output that's colorful. I see my own code in white, and then I see, anywhere I should have indented, green spaces that are sort of encouraging me to put space, space, space, space here. Put space, space, space, space here. Put eight spaces here, four spaces here, and so forth, and then it's reminding me I should add comments as well. This is a short program doesn't necessarily need a lot of commenting to explain what's going on. But just one //, like we saw last week to explain, maybe at the top of the file or top the block of the code, would make style50 happy as well. So let's do that. Let me go ahead and take its advice and actually indent this with Tab, this with Tab, this with Tab, this with Tab, and this once more. And you'll notice that on your keyboard, even though you're hitting Tab, it's actually converting it for you, which is very common to four spaces, so you don't have to hit the spacebar four times. Just get into the habit of using Tab. And let me go ahead and write a comment here. "Print 10 hashes." This way, my colleagues, my teaching fellow, myself in a week don't have to read my own code again and figure out what it's doing. I can read the comments alone per the //. If I run style50 again, now it looks good. It's in accordance with the style guide, and it's just more prettily written, so pretty printed would be a term of art in programming when your code looks good and isn't just correct. Any questions then? Yeah. AUDIENCE I tried using [INAUDIBLE] this past week and it said I needed a new program. DAVID J. MALAN That's it wasn't enabled for the first week of the class. It's enabled as of right now and henceforth. Other questions? No. All right, so just to recap then, three tools to have in the proverbial toolbox now are help50 anytime you see an error message that you don't understand, whether it's with make or Clang or, perhaps, something else. Printf when you've got a logical program a bug in your program, and it's just not working the way it's supposed to or the way the problem set tells you it should, and then style50 when you want to make sure that, does my code look right in terms of style, and is it as readable as possible? And honestly, you'll find us at office hours and the like often encouraging you, hey, before we answer this question, can you please run style50 on your code? Can you please clean up your code, because it just makes our lives, too, as other humans so much easier when we can understand what's going on without having to visually figure out what parentheses and curly braces line up. And so do get into that habit, because it will save you time from having to waste time parsing things visually yourself. All right. So there's not just CPUs in computers. CPUs are the brains, central processing unit, and that's why we keep emphasizing the instructions that computers understand. There's also this, which we saw last time, too. This is an example of what type of hardware? AUDIENCE RAM. DAVID J. MALAN RAM, or Random Access Memory. This is the type of memory that laptops, desktops, servers have that is used whenever you run a program or open a file. There's another type of memory called hard drives or solid state drives, which you're probably familiar as a consumer, and that's just where your files are stored permanently. Your battery can die. You can pull the plug from your laptop or desktop, and any files saved on a hard drive are persistent. They stay there because of the technology being used to implement that. But RAM is more ephemeral. RAM is powered only by electricity. It's only used when the power is on or the battery is charged, and it's where your files and programs live effectively when you double click on them and open them. So when you double click on something like Microsoft Word, it is copied from your hard drive long term into this type of memory, because this type of memory, though smaller in capacity you don't have as many bytes of it but it is much, much, much, much faster. Similarly, when you open a document, or you go to a web page, the contents of the file you're seeing are stored in this type of hardware, because even though you don't have terribly many bytes of it, it's just much, much, much, much faster. And so this will be thematic in computer science and in hardware. You sort of have lots of cheap, slow stuff, like hard disk space, relatively speaking, and you have a little less of the more expensive but faster stuff like RAM. And you have just one, usually, CPU, which is the really fast thing that can do a billion things per second. But it, too, is more expensive. So there's four visible chips on this thing, if you will. And we won't get into the details of how these things work, but let's just zoom in on this one black chip here and focus on it as being representative as some amount of memory. Maybe it's one megabyte, one million bytes. Maybe it's even one gigabyte these days, one billion bytes. But this is to say that this chip can be thought of as just having a bunch of bytes in it. This is not to scale. You have many more bytes than these, but let me propose that you just think of each of these squares here as representing one byte. So the very first byte of memory I have access to is here. Next one is here, and so forth. And the fact that they wrap around is just an artist rendition. These things you can think of just virtually as going left to right, not in any kind of grid, but physically, they look like this. So when you actually create a variable in a program like C, like you need a char. A char tends to be one byte or eight bits, and so that means when you have a variable of type char in a C program, it goes, literally, physically in one of these boxes, inside of your computer's RAM. So for instance, it might take up this much space at top left. If you have a bigger type of data, so you have an integer, which tends to be four bytes or 32 bits, you might need more than one square, so the computer might give you access to four squares instead. And you have 32 bits spanning that region of memory. But honestly, I chose those boxes arbitrarily. They could be anywhere in that chip or in any of the other chips. It's up to the computer to just remember where they are for you. You don't need to remember that, per se. But if we think about this grid, it turns out this is actually very valuable that we have chunks of memory bytes, if you will that are back to back to back to back. And in fact, there's a word for this technique. This is contiguous memory back to back to back to back to back. And in general, in programming, this is referred to as an array. You might recall from Scratch, if you use this feature, it actually has things called lists, which are exactly that lists of values, lists of words, lists of strings. An array is just a contiguous chunk of memory, such that you can store something here, something here, something here, something here, and so forth. So it turns out an array, this super simple primitive, is actually incredibly powerful. Just being able to store things in my computer's memory back to back to back to back enables so many possibilities, both designwise, like how well I can write my code, and also how fast I can make my code run. So let me go ahead and take out an example. Let me go ahead and open up, for instance, a new file in a sandbox, and we'll call this score0. So let me go ahead and close this one, create a new file called scores0.c. And in this file, let's go ahead and write a relatively simple program. Let me go ahead and, as usual, give myself access to some helpful functions cs50.h and stdio.h. And no need to copy all this down verbatim, if you don't like. Everything will have or is already on the course's website. Let me start my program as usual with int main void. And then let me write a program, as this program's name implies, that, like, asks the user for three scores on recent problem sets, quizzes, whatever, and then kind of creates a very simple chart of them, like a bar chart to kind of help me visualize how well or how poorly I did on something. So if I want to get an integer, no surprise, we can use the get int function, and I can just ask the user for their first score. But I should probably do something with this score, and on the left hand side of this, what do I typically put? Yeah. So int sure, score 1 equals this, and then my semicolon. So you might not have had many occasions to use ints just yet, but get int is in the cs50 library. This is the socalled prompt that the human sees, and let me actually fix my space, because I want the human to see the space after the colon. But that's just an aesthetic detail. And then when I get back this value, its return value just like Aaron, last week, handed me a piece of paper, so does get int hand me a virtual piece of paper with a number that I'm going to store in a variable called Score 1. And now just to be clear, what has just happened effectively is this. The moment you create a variable of type int, which is four bytes, literally, this is what Clang or, more generally, the computer has done for you. That int that the human typed in is stored literally in four contiguous bytes back to back to back, maybe here, maybe here, but together. So that's all that's going on when you're actually using C. So let me go back into my code here, and now I want to it's not interesting to plot one score. So let's go ahead and do another. So int Score 2, get int, get int, and I'll ask the user for score 2, semicolon, and then let's get one more, Score 3, get int, call it Score 3, semicolon. All right, so now let me go ahead and generate a bar, like a bar chart of this. I'm going to use what we'll call ASCII art. ASCII, of course, is just text, recall very simple text in a computer. And I can kind of make a bar chart pretty simply by just printing out like a bunch of hashes horizontally, so a short bar will represent a small number, and a long bar will represent a big number. So let me go ahead and say to the user, all right, here's your Score 1. I'm going to go ahead, then, and say, for int i get 0. I is less than Score 1, i++. And now if I scroll down and give myself a bit of room here, let me go ahead and implement just a simple print. So go ahead and print out a hash, and then when you're all done with that, print out a new line at the end of that loop. And let's just pause there. Just to recap, I've asked the human for three scores. I'm only doing something with one of them at the moment, so in fact, just as a quick check, let me delete those so as to not get ahead of myself. Let me do make score 0. Cross my fingers. OK, no errors. Now let me go ahead and do ./score0, and your first score on a pset this year out of 100 has been? OK, 100. And good job. So it's a really long bar, and if we count those up, hopefully, there's actually 100 bars. And if we run it again and say, eh, it didn't go so well. I got a 50. That's half as big a bar. So it seems like we're on our way correctnesswise. So now let me go ahead and get the other scores. Well, I had them here a moment ago. So let me go ahead and just, well, copy, paste, and change this to two, change this to three, change this to three, this to three. All right, I know how to print bars clearly, so let me go ahead and do this, and then do this, and then fix the indentation. I don't want to say Score 1 everywhere. I want to say a Score 2, Score 2. I mean you're probably being rubbed the wrong way that this is both tedious and sloppy, and why? What am I doing poorly now designwise? AUDIENCE Copying and pasting code. DAVID J. MALAN Like copypasting almost always bad, right? There's redundancy here, but that's fine. Let's prioritize correctness, at least, for now. So let me go ahead and make Score 0. All right, no mistakes ./score0. And then Tab it. Let me go ahead now and run OK, we got 100 the first time. We got 50 the oh, that's a bug. What did I do there? See, this is what happens when you copypaste. So let's fix this. That should say Score 2, so Control+C will quit a program. Make score 0 will recreate it. ./0, Enter all right, here we go. 100, 50. Let's split the difference 75. All right, so this is a simple bar chart horizontally drawn of each of my three scores, where this is 100, this is 50, and this is 75. But there's opportunities for improvement here. So one, it rubbed some folks the wrong way already that we were literally copying and pasting code. So where is one opportunity for improvement here? What should I do instead of copying and pasting that code again and again? What ingredient can you bring? OK, so we can use a loop and actually just do the same thing three times. So let's try that. Let me go ahead and do this. So let's go ahead and delete the copypaste I did, and let me go ahead and say, OK, well, for int i get zero, i less than 3, i++. Let me create a bracket. I can highlight multiple lines and hit Tab, and they'll all indent for me, which is convenient. And can I do this now, for instance? Say it a little louder. AUDIENCE If you [INAUDIBLE] to a specific [INAUDIBLE].. DAVID J. MALAN Yeah, I'm a little worried. As you're noting here, we're using on line 13 here the same variable, so mm. So it's good instincts, but I feel like the fact that this program, unlike last week, we're now collecting multiple pieces of data. Loops are breaking down for us. Yeah. AUDIENCE [INAUDIBLE] function [INAUDIBLE] takes in like you can have it [INAUDIBLE]. DAVID J. MALAN OK. AUDIENCE So like an input of how many scores you wanted to enter. DAVID J. MALAN OK. AUDIENCE And then [INAUDIBLE]. DAVID J. MALAN Yeah, we can implement another function that factors out some of this functionality. Any other thoughts? AUDIENCE Store your scores in an array. DAVID J. MALAN OK, so we could also store our scores in an array. So let's do these in order then, in fact. So loops are wonderful when you want to do something again and again and again, but the whole purpose of a function, fundamentally, is to factor out common functionality. And there might still be a loop in the solution, but the real fundamental problem with what I was doing a moment ago was I was copying and pasting functionality shouldn't need to do that, because in both C and Scratch, we had the ability to make our own functions. So let's do that. Let me undo my loop changes here, just to get us back to where we were a moment ago. And let me go ahead and, instead, clean this up a little bit. Let me go ahead and create a new function down here that I'm going to call, say, Chart, just to create a chart for myself. And it's going to take as input a score, but I could call this anything I want. It's void as its return type, because I don't need it to hand me something back. Like I'm not getting a string from the user. I'm just printing a char. It's a socalled side effect or output. Now I'm going to go ahead and do my loop here for int i get 0. I is less than how many hashes do I want to print if I'm being passed in the user score? Like, is this 3 here? AUDIENCE The score. DAVID J. MALAN The score, so if I'm being handed a number that's 0 to 100, that's what I want to iterate over. If my goal here, ultimately let me finish this thought i++ is [? 2 ?] inside this loop print out one hash per point in 1's total score. And just to keep things clean, I'm going to go ahead and put a new line at the very end of this. But I think now, I factored out a good amount of the redundancy. It's not everything, but I've at least now given myself a function called Chart. So up here, it looks like I can kind of remove this loop, which is what I factored out. That's almost identical, except the variable name was hardcoded. And I think I could now do chart like this, and then I maybe could do a little copypaste, if that's OK, like if maybe I can get away with just doing this, and then say 2, and then say 3, and then say 3, and then say 2. So it's still copypaste, but it's less. And it looks better. It literally fits on the screen, so it's progress not perfect, but progress. Better design, but not perfect. So is this going to compile? I'm going to have errors why? AUDIENCE Essentially, it's [INAUDIBLE] the program [INAUDIBLE].. DAVID J. MALAN OK. Yeah. AUDIENCE We need to declare a [INAUDIBLE].. DAVID J. MALAN OK, good. So let me induce the actual error, just so we know what problem we're solving. Let me go ahead and sort of innocently go ahead and compile Score 0 hoping all is well, but of course, it's not because of a familiar error up here. So notice, implicit declaration of function chart is invalid in C99. So again, implicit declaration of function just tends to mean Clang does not know what you're talking about. And you could run help50, and it would probably provide you with similar advice. But the gist of this is that chart is not a C function. It doesn't come with C. I wrote it. I just wrote it a little too late. So one solution that we didn't used last week would be, OK, well, if you don't know what chart is, let me just go put it where you'll know about it. And now run make score 0. OK, problem solved. So that fixes it, but we fixed it in a different way last week. And why might we want to stick with last week's approach and not just copypaste my function and put it at the top instead of the bottom? AUDIENCE [INAUDIBLE]. DAVID J. MALAN Yeah, I mean it's kind of a minor concern at the moment, because this is a pretty short program. But I'm pushing the main part of my program, literally called Main, farther and farther down. And the whole point of reading code is to understand what it's doing. So if I open this file, and I have to scroll, scroll, scroll, scroll, scroll, just looking for the main function, it's just bad style. It's just kind of nice, and it's a good human convention. Put the main code, the main function, when green flag clicks equivalent, at the very top. So C does offer us a solution here. You just have to provide it with a little hint. Let me go ahead and cut this from here, put it back down at the bottom here, and then go ahead and copypaste only or retype only the value whoops the value of that first line, which is its socalled prototype. Give Clang enough information so that it knows what arguments the function takes, what its return type is, and what its name is, semicolon, and that's the socalled declaration or and then implement it with the curly braces and all the logic down below. So let's go ahead and run this. And if I scroll up here, we'll see whoops. We'll see make score 0. All right, now we're on our way, score 0. Enter. Score 1 is 100, 50, 75, and now we seem to have some good functionality. But there's still an opportunity, I dare say, for improvement. And I think the fundamental problem is that I'm still copypasting the little stuff, but I think the fundamental problem is that I don't have the expressiveness to store multiple values, unless I, in advance, as the programmer, give them all unique names, because if I use the same variable for everything, I couldn't collect all three variables at the top, and then iterate over all three at the bottom, if I only have one variable. So I do need three variables, but this doesn't scale very well. And who knows? If I want to take in five scores, 10 scores, or more scores, then I'm really copying and pasting excessively. So it turns out, indeed, the answer is an array. So an array, at the end of the day, is just a side effect of storing stuff in memory back to back to back to back. But what's powerful about this reality of memory is the following. I can go ahead here and in, say, a new and more improved version of this program, do this. Let me go ahead and open this one, which I wrote in advance, called scores2.c. And in scores2.c, notice we have the following code. In my main function, I've got a new feature and a new bit of syntax. This line here that I've highlighted says, hey, Clang, give me a variable called Scores of type integer, but please give me three of them. So the new syntax are your square brackets, and inside of which is the number of variables you want of that type. And you don't have to give them unique names. You literally call them collectively, Scores, and in English, I deliberately chose a plural to connote as much. This is an array of values, not a single value. What can I do next? Well, here's my for loop for int i get zero i is less than 3 i++, and now I've solved that earlier problem that was proposed. Well, just put it in a loop. Now I can, because now my variables are not called Score 1, Score 2, Score 3, which I literally had to hard code. They're just called Scores, and now that they're called Scores, and I have this square bracket notation, notice what I can do. I can get an int, and I can say, give me score%i, and plug in i plus 1. I didn't want to say "zero," because humans don't count from zero in general. So this is counting from one, two, and three, but the computer is doing this. So Scores is a variable. Bracket, i, close bracket says store the ith value there. So ith is just nonEnglish. That means go to bracket 0, bracket 1, bracket 2. So what this effectively means is on the first iteration of the loop, when i equals 0, this looks like this, effectively. When i then becomes 1 on the next iteration, then you're doing this. When i becomes 2 on the final iteration, it looks like this. When i becomes 3, well, 3 is not less than 3, and so it doesn't execute again. So by using i inside of these square brackets, am I indexing into an array? To index into an array means go to a specific location, the socalled ith location, but you start counting at zero. Just to make this more real, then, if you go back to this picture of your computer's memory, this might, therefore, be bracket i, bracket 1 bracket 0, bracket 1, bracket 2, bracket 3, bracket 4, bracket 50, or wherever. You can now, using square brackets, get at any of these blocks of memory to store values for you. Any questions on what we've just done? All right, then on the flip side, we can do the exact same thing. Now when I print my scores, I can similarly iterate from 0 to 3, and then print out the scores by passing to chart the same value, the ith score. Again, the only new syntax here is variable name, square bracket, and then a number, like 0, 1, 2, or a variable like i, and then my chart function down here is exactly the same. It has no idea an array is even involved, because I'm just passing in one score at a time. Now it turns out there's still one bad design decision in this program. There's still some redundancy, something that I keep typing again and again and again. Do any values jump out at you as repeated? AUDIENCE The for loop. DAVID J. MALAN The for loop. OK, so I've got the for loop in multiple places. Sure. And what other value seems to be in multiple places? It's subtle. Total number. Yeah, 3. Three is in a few places. It's up here. It's when I declare the array and ask myself for three scores. It's here when I'm iterating. It's not here, because this is a different iteration. That's just for the hashes. So in, ironically, three places, have I written 3. So what does this mean? Well, suppose next year you take more tests or whatever, and you need more scores. You open up your program, and all right, now I've got five scores and five whoops, typo already five, like this kind of pattern where you're typing the same thing again and again. And now the onus is on me, the programmer, to remember to change the same [? damn ?] value in multiple places bad, bad, bad design. You're going to miss one of those values. Your program's going to get more complex. You're going to leave one at 3 and change the other to 5, and logical errors are eventually going to happen. So how do we solve this? The function's not the solution here, because it's not functionality. It's just a value. Well, we could use a variable, but a certain type of variable. These numbers here 5, 5, 5 or 3, 3, 3 are what humans generally refer to as magic numbers. Like they're numbers, but they're kind of magical, because you just arbitrarily hardcoded them in random places. But a better convention would be, often as a global variable, to do this int, let's call it "count," equals 3. So declare a variable of type int that is the number of things you want, and then type that variable name all throughout your code so that later on, if you ever want to change this program, you change it whoops in one place, and you're done after recompiling the program. And actually, I should do a little better than this. It turns out that if you know you have a variable that you're never going to change, because it's not supposed to change it's supposed to be a constant value C also has a special keyword called const, where before the data type, you say, const int, and then the name and then the value, and this way, the compiler, Clang, will make sure that you, the human, don't screw up and accidentally try to change the count anywhere else. There's one other thing notable. I also capitalize this whole thing for some reason human convention. Anytime you capitalize all of the letters in a variable name, the convention is that that means it's global. That means it's defined way up top, and you can use it anywhere, therefore, because it's outside all curly braces. But it's meant to imply and remind you that this is special. It's not just a socalled local variable inside of a function or inside of a loop or the like. Any questions on that? Yeah. AUDIENCE What is [INAUDIBLE]? Why do you have i plus 1? DAVID J. MALAN Oh, why do I have i plus 1? Let me run this program real quick. Why do I have i plus 1 in this line here, is the question. So let me go ahead and run make scores 2 whoops in my directory. Make scores 2 ./scores2, Enter. I wanted just the human to see Score 1 and Score 2 and Score 3. I didn't want him or her to see Score 0, Score 1, Score 2, because it just looks lame to the human. The computer needs to think in terms of zeros. My humans and my users do not, so just an aesthetic. Other questions. Yeah. AUDIENCE [INAUDIBLE]. DAVID J. MALAN Ah, really good question. And I actually thought about this last night when trying to craft this example. Why don't I just combine these two for loops, because they're clearly iterating an identical number of times? Was this a hand or just a stretch? No, stretch. So this is actually deliberate. If I combine these, what would change logically in my program? Yeah. AUDIENCE After every [INAUDIBLE] input, you would [INAUDIBLE].. DAVID J. MALAN Yeah, so after every human input of a score, I would see that user's chart, the row of hashes. Then I'd ask them for another value. They'd see the chart, another value, and they'd see the chart. And that's fine, if that is the design you want. Totally acceptable. Totally correct. I wanted mine to look a little more traditional with all of the bars together, so I effectively had to postpone printing the hashes. And that's why I did have a little bit of redundancy by getting the user's input here and then iterating again to actually print the user's output as a chart, so just a design decision. Good question. Other questions? All right, so what does this look like? Actually, you know what? I can probably do a little better. Let me open up one final example involving scores and this thing called an array. In Scores 4 here, let me go ahead and do this. Now I've changed my chart function to do a little bit more, and you might recall from week 0 and 1, we had the call function, and we kept enhancing it to do more and more, like putting more and more logic into it. Notice this. Chart function now takes a second argument, which is kind of interesting. It takes one argument, which is a number, and then the next argument is an array of scores. So long story short, if you want to have a function that takes as input an array, you don't have to know in advance how big that array is. You should not, in fact, put a number in between the square brackets in this context. But the thing is you do need to know, at some point, how many items are in the array. If you've programmed in Java, took AP CS, Java just gives you .length, if you recall that feature of objects. C does not have this. Arrays do not have an inherent length associated with them. You have to tell everyone who uses your array how long it is. So even though you don't do that syntactically here, you literally just say, I expect an argument called scores that is an array per the square brackets. You have to pass and almost always a second variable that is literally called whatever you want, but is the number of things in that array, because if the goal of this function is just to iterate over the number of scores that are passed in, and then iterate over the number of points in that score in order to print out the hashes, you need to know this count. So what does this function do, just to be clear? This iterates over the total number of scores from 0 to count, which is probably 3 or 5 or whatever. This loop here, using J, which is just a convention, instead iterates from 0 to whatever that ith score is. So this is what's convenient. Now I've passed in the array, and I can still get at individual values just by using i, because I'm on my ith iteration here. So you might recall this from Mario, for instance, or any other example in which you had nested loops just very conventional to use i on the outside, j on the inside. But again, the only point here is that you can, indeed, pass around arrays, even as arguments, which we'll see why that's useful before long. Any questions? OK, so this was a lot, but we can do so much more still with arrays. It gets even more and more cool. In fact, we'll see, in just a bit, how arrays have actually been with us since last week. We just didn't quite realize it under the hood, but let's go ahead and take a breather, five minutes. We'll come back and dive in. All right. So I know that was a bit of a cliffhanger. Where else could arrays have actually been? But, of course, this is how we might depict it pictorially. We called it an array, and it turns out that last week, when we introduced strings, strings, sequences of characters, are literally just an array by another name. A string is an array of chars, and chars, of course, is another data type. Now what are the actual implications of this, both in terms of representation, like how a computer's representing information, and then fundamentally, programmatically, what can we do when we know all of our data is so back to back to back or so proximal to one another? Well, it turns out that we can apply this logic in a few different ways. Let me go ahead and open up, for instance, an example here called String 0. So in our code for today, in our Source 2 folder, let me go ahead and open up String 0, and this example looks like this. Notice that we first, on line 9, get a string from the user. Just say, input, please. We store that value in a string, s, and then we say, here comes the output. And notice what I'm doing in the following line. I'm iterating over i from 0 to strlen, whatever that is. And then in line 13, I'm printing a character one at a time. But notice the syntax I'm using, which we didn't use last week. If you have a string called s, you can index into a string just like it's an array, because it, indeed, is underneath the hood. So s bracket i, where i starts at 0 and goes up to whatever this value is is just a way of getting character 0, then character 1, then character 2, then character 3, and so the end result is actually going to look like this. Let me go ahead and do, make string whoops make string 0. Oops. Not in the directory. Make string 0, ./string0, Enter, and I'll type in, say, Zamyla, and the output now is ZAMYLA. It's a little messy, because I don't have a new line here, so let me actually let's clean that up, because this is unnecessarily sloppy. So let me go ahead and print out a new line. Let me recompile with make string 0, dot whoops ./string0. Input shall be Zamyla, Enter, and now ZAMYLA. So why is that happening? Well, if I scroll down on this code, it seems that I am, via this printf line here, just getting the ith character of the name in s, and then printing out one character at a time per the %c, followed by a new line. So you might guess, what is this function here doing? Strlen slightly abbreviated, but you can, perhaps, glean what it means. Yeah, so it's actually string length. So it turns out there is a function that comes with C called strlen, and humans back in the day and to this day like to type as few characters when possible. And so strlen is string length, and the way you use it is you just need one more header file. So there's another library, the socalled string library that gives you stringrelated functions beyond what CS50's library provides. And so if you include string.h, that gives you access to another function called strlen, that if you pass it, a variable containing a string, it will pass you back as a return value the total number of characters. So I typed in ZAMYLA, and so that should be returning to me six, thereby printing out the six characters in Zamyla's name. Yeah. AUDIENCE [INAUDIBLE]. DAVID J. MALAN Uhhuh. AUDIENCE [INAUDIBLE] useful to get the individual digits [INAUDIBLE].. DAVID J. MALAN Really good question. In the credit problem of the problem set, would this have been useful? Yes, absolutely. But recall that in the credit pset, we encourage you to actually take in the number as a long, so as an integral value, which thereby necessitated arithmetic. But yes, if you had, instead, in a problem involving credit card numbers, gotten the human's input as a long string of characters and not as an actual number like an int or a long, then, yes, you could actually get at those individual characters, which probably would have made things even easier but deliberate. Yeah. AUDIENCE [INAUDIBLE]. DAVID J. MALAN Really good question. If we're defining string in CS50, are we redefining it in string? No. So string, even though it's named string.h, doesn't actually define something called a string. It just has stringrelated functions. More on that soon. Yeah. AUDIENCE [INAUDIBLE] individual values [INAUDIBLE]?? DAVID J. MALAN Ah, really good question. Could you edit the individual values? So short answer, yes. We could absolutely change values, and we'll soon do that in another context. Other questions? All right, so turns out this is correct, if my goal is to print out all of the characters in Zamyla's name, but it's not the best design. And this one's a little subtle, but this is, again, what we mean by design. And to a question that came up during the break, did we expect everyone to be writing good style and good design last week? No. Up until today, like we've introduced the notion of correctness in both Scratch and in C last week, but now we're introducing these other axes of quality of code like design, how welldesigned it is, and how pretty does it look in the context of style. So expectations are here on out meant to be aligned with those characteristics, but not in the past. So there's a slight inefficiency here. So on the first iteration of this loop, I first initialize i to 0, and then I check if i less than the length of the string, which hopefully, it is, if it's Zamyla, which is longer than 0. Then I print the ith character. Then I increment i. Then I check this condition. Then I print the ith character. Then I increment i. Then I check this condition and so forth. We looped through loops last week, and you've used them, perhaps, by now in problems. What question am I redundantly asking seemingly unnecessarily? I have to check a condition again and again, because i is getting incremented. But there's another other question that I don't need to keep asking again just to get the same answer. AUDIENCE What is the length [? of the string? ?] DAVID J. MALAN Yeah, there's this function call in my loop of strlen s, which is fine. This is correct. I'm checking the length of the string, but once I type in Zamyla, her name is not changing in length. I'm incrementing i, so I'm moving in the string, if you will. But the string itself, ZAMYLA, is not changing. So why am I asking the computer, again and again, get me the strlen of s, get me the strlen of s, get me the strlen of s. So I can actually fix this. I can improve the design, because that must take some amount of time. Maybe it's fast, but it's still a nonzero amount of time. So you know what I could do? I could do something like this int n get string length of s. And now just do this. This would be better design, because now I'm only asking the question once of the function. I'm remembering or caching, if you will, the answer, and then I'm just using a variable. And just comparing variables is just faster than comparing a variable against a function, which has to be called, which has to return a value, which you can then compare. But honestly, it doesn't have to be this verbose. We can actually be a little elegant about this. If you're using a loop, a secret feature of loops is that you can have commas after declaring variables. And you can actually do this and make this even more elegant, if you will, or more confusinglooking, depending on your perspective. But this now does the same thing but declares n inside of the loop, just like I'm declaring i, and it's just a little tighter. It's one fewer lines of code. Any questions, then? AUDIENCE [INAUDIBLE]. DAVID J. MALAN Good question. In the way I've just done it cannot reuse this outside of the curly braces. The scope of i and n exists only in this context right now. The other way, yes. I could have used it elsewhere. AUDIENCE What if you [INAUDIBLE] other loops, and you also had [INAUDIBLE]?? DAVID J. MALAN Absolutely. AUDIENCE Using different letters of the alphabet, you could just use n and not be [INAUDIBLE].. DAVID J. MALAN Correct. If I want to use the length of s again, absolutely. I can declare the variable, as I did earlier, outside of the loop, so as to reuse it. That's totally fine. Yes. And even i i exists only inside of this loop, so if I have another loop, I can reuse i, and it's a different i, because these variables only exist inside the for loop in which they're declared. So it turns out that these strings don't have anything in them other than character after character after character. And in fact, let me go ahead here and draw a picture of what's actually going on underneath the hood of the computer here. So when I type in Zamyla's name, I'm, of course, doing something like ZAMYLA. But where is that actually going? Well, we know now that inside of your computer is RAM or memory, and you can think of it like a grid. And honestly, I can think of this whole screen as just being in a different orientation, a grid of memory. So for instance, maybe we can divide it into rows and columns like this, not necessarily to scale, and there's more rows and columns. So on the screen here, I'm just dividing things into the individual bytes of memory that we saw a moment ago. And so, indeed, underneath the hood of the computer is this layout of memory. The compiler has somehow figured out or the program has somehow figured out where to put the z and where the a and the m and the y and the l and the a, but the key is that they're all contiguous, back to back to back. But the catch is if I'm typing other words into my program or scores into my program or any data into my program, it's going to end up elsewhere in the computer's memory. So how do you know where Zamyla begins and where Zamyla ends, so to speak, in memory? Well, the variable, called s, essentially is here. There's some remembrance in the computer of where s begins. But there's no obvious way to know where Zamyla ends, unless we ourselves tell the computer. So unbeknownst to us, any time a computer is storing a string like ZAMYLA, it turns out that it's not using one, two, three, four, five, six characters. It's actually using seven secretly. It's actually putting a special character of all zeros in the very last bytes. Every byte is eight bits, so it's putting secretly eight zeros there, or we can actually draw this more conventionally as /0. It's what's called the null character, and it just means all zeros. So the length of the string, Zamyla, is six, but how many bytes does it apparently take up, just to be clear? So it actually takes up seven. And this is kind of a secret implementation detail that we don't really have to care about, but eventually, we will, because if we want to implement certain functionality, we're going to need to know what is actually going on. So for instance, let me go ahead and do this. Let me go ahead and create a program called strlen itself. So this is not a function but a program called strlen.c. Let me go ahead and include the CS50 library at the top. Let me go ahead and include stdio.h. Let me go ahead and type out main void, so all this is same as always. And then let me go ahead and prompt the user for, say, his or her name, like so. And then you know what? Let me actually, this time, not just print their name out, because we've done that ad nauseam. Let's just count the number of letters in his or her name. So how could we do that? Well, we could just do this int n get strlen of s, and then say, printf "The length of your name is %i." And then we can plug in n, because that's the number we stored the length in. But to use strlen, I have to include what header file? String.h, which is the new one, so string.h. And now if I type this all correctly, make strlen, make strlen, good. ./strlen let's try it Zamyla. Enter. OK, the length of her name is six. But what is strlen doing? Well, strlen is just an abstraction for us that someone else wrote, and it's wonderfully convenient, but you know, we don't strictly need it. I can actually do this myself. If I understand what the computer is doing, I can implement this same functionality myself as follows. I can declare a variable called n and initialize it to 0, and then you know what? I'm going to go ahead and do this. While s bracket n does not equal all zeros, but you don't write all zeros like this. You literally do this that /0 to which I referred earlier in single quotes. That just means all zeros in the bytes. And now I can go ahead and do n++. If I'm familiar with what this means, remember, that this is just n equals n plus 1, but it's just a little more compact to say, n++. And then I can print out the name of your n the name of your n the name of the length of your name is %i, plugging in n. So why does this work? It's a little funkylooking, but this is just demonstrating an understanding of what's going on underneath the proverbial hood. If n is initialized to zero, and I look at s bracket n, well, that's like looking at s bracket 0. And if the string, s, is Zamyla, what is s bracket 0? Z. And then it does not equal /0. It equals z, obviously. So we increment n. So now n is 1. Now n is 1. So what is s bracket 1 in Zamyla's name? A and so forth, and we get to ZAMYLA, then all zeros, the socalled null character, or /0. That, of course, does equal /0, so the loop stops, thereby leaving the total count or value of n at what it previously was, which was 6. So that's it. Like all underneath the hood, all we have is memory laid out like this, top to bottom, left to right, and yet all of the functionality we've been using for a week now and henceforth just boils down to some relatively simple primitives, and if you understand those primitives, you can do anything you want using the computer, both computationally codewise, but also memorywise. We can actually see, in fact, some of the stuff we looked at two weeks ago as follows. Let me go ahead and open up an example called ASCII 0. Recall that ASCII is the mapping between letters and numbers in a computer. And notice what this program's going to do. Make let me go into this folder. Make ascii0, ./ascii0, Enter. The string shall be, let's say, Zamyla, Enter. Well, it turns out that if you actually look up the ASCII code for Zamyla's name, z is 90, lowercase a is 97, m is 109, and so forth. There are those characters, and actually, we can play the same game we did last week. If I do this again on "hi," there's your 72, and there's your 73. Where is this coming from? Well, now that I know how to manipulate individual strings, notice what I can do. I can get a string from the user, just as we always have. I can iterate over the length of that string, albeit inefficiently using strlen here. And then notice this new feature today. I can now convert one data type to another, because a char, a character is just eight bits, but presented in the context of characters. Bytes is also just eight bits that you could treat as an integer, a number. It's totally contextsensitive. If you use Photoshop, it's a graphic. If you use a text program, it's a message and so forth. So you can encode change the context. So notice here, s bracket i is, of course, the ith character of Zamyla's name, so Z or A or M or whatever. But I can convert that ith character to an integer doing what's called casting. You can literally, in parentheses, specify the data type you want to convert one data type to, and then store it in exactly that data type. So s bracket i convert it to a number. Then store it in an actual number variable, so I can print out its value. So c this is show me the character. Show me the letter as by plugging in the character, and then the letter sorry, the character and the number that I've just converted it to. And you don't actually even have to be explicit. This is called explicit casting. Technically, we can do this implicitly, too. And the computer knows that numbers are characters, and characters are a number. You don't have to be so pedantic and even do the explicit casting in parentheses. You can just do it implicitly with data types, and honestly, at this point, I don't even need the variable. I can get rid of this, and down here, I can literally just print the same thing twice, but tell printf to print the first in the context of a character and the second in the context of an int, just treating the exact same bits differently. That's implicit casting. And it just demonstrates what we did in week 0 when we claimed that letters are numbers, and numbers can also be colors, and colors can be images, and so forth. Is this a question? AUDIENCE Would've been useful for credit. DAVID J. MALAN Also, yes. It all comes back to credit. Yeah. Indeed. Other questions? No. All right, so what else can we actually do with this appreciation? So super simple feature that all of us surely take for granted, if we even use it anymore these days. Google Docs, Microsoft Word, and such can automatically capitalize words for you these days. I mean your phone can do it nowadays. They just sort of AutoCorrect your messages. Well, how is that actually working? Well, once you know that a string is just a bunch of characters back to back to back, and you know that these characters have numbers representing them, and like capital A is 65, and lowercase A is 97, apparently, and so forth, we can leverage these patterns. If I go ahead and open up this other example here called Capitalize 0, notice what this program is going to do for me first by running it. Make capitalize 0 ./capitalize0. Let me go ahead and type in Zamyla's name just as before, but now it's all capital. So this is a little extreme. Hopefully, your phone is not capitalizing every letter, but you can imagine it capitalizing just the first, if you wanted it. So how does this work? Well, let me go ahead and open up this example here. And so what we did so here, I'm getting a string from the user, just as we always do. Then I'm saying, after, just to kind of format the output nicely. Here, I'm doing a loop pretty efficiently from i equals 0 up to the length of the string. And now notice this neat application of logic. It's a little cryptic, certainly, at first glance. But whoops. And now it's gone. And what am I doing exactly with these lines of code? Well, with every iteration of this loop, I'm asking the question, is the ith character of s, so the current character, is it greater than or equal to lowercase A, and is it less than or equal to lowercase Z? Put another way, how do you say that more colloquially in English? Is it lowercase, literally. But this is the more programmatic way of expressing, is it lowercase? All right, if it is, go ahead and do this. Now this is a little funky, but print out a character, specifically the ith character, but subtract from that lowercase letter whatever the difference is between little A and big A. Now where did that come from? So it turns out OK, capital A is 65. Lowercase A is 97. So the difference between those is 32. And that's true for B, so capital B is 66, and lowercase B is 98. Still 32, and it repeats for the whole alphabet. So I could just do this. If I know that lowercase letters have bigger numbers, like 97, 98, and I know that lowercase numbers have lower letters, like 65, 66, I can just literally subtract off 32 from my lowercase letters. As you point out, it's a lowercase letter. Subtract 32, and that gives us what result? The capitalized version. It uppercases things for us. But honestly, this feels a little hackish that, like, OK, yes, I can do the math correctly, but you know what? It's better practice, generally, to abstract this away. Don't get into the weeds of counting how many characters are away from each other. Math is cheap and easy in the computer. Let it do the math for you by subtracting whatever the value of A is, of capital A is from the value of lowercase A. Or we could just write 32. Otherwise, go ahead and just print the character unchanged. So in this case, the AMYLA in Zamyla's name got uppercased, and everything else, the Z, got left alone, just by understanding what's going on with how the computer's represented. But honestly, God, I don't want to keep writing code like this. Like, I'm never going to get this. I'm new to programming, perhaps. I'm never going to get this sort of sequence of all the cryptic symbols together, and that's OK, because we can actually implement this same program a little more easily, thanks to functions and abstractions that others have written for us. So in this program, turns out I can simplify the questions I'm asking by literally calling a function that says, is lower. And there's another one called, is upper, and there's bunches of others that just literally are called, is something or other. So is lower takes an argument like the ith character of s, and it just returns a bull true or false. How is it implemented? Well, honestly, if we looked at the code that someone else wrote decades ago for is upper, odds are or is lower odds are he or she wrote code that looks almost like this. But we don't need to worry about that level of detail. We can just use his or her function, but how do we do that? Turns out that this function and you would only know this by having been told or Googling or reading a reference is in a library called ctype.h. And you need the header file called ctype.h in order to use it. And we'll almost always point you to references and documentation to explain that to you. Toupper is another feature, right? This math like, my god. I just want to uppercase a letter. I don't want to really keep thinking about how far apart uppercase letters are from lowercase. Turns out that in the C type library, there's another function called toupper that literally does the exact same thing in the previous program we wrote. And so that, too, is OK. But you know what? This feels a little verbose. It would be nice if I could really tighten this program up. So how those toupper work? Well, it turns out some of you might be familiar with CS50 Reference Online, our webbased app that we have that helps you navigate available functions in C. Turns out that all of the data for that application comes from an older command line program that comes in Linux and comes in the sandbox called Man for manual. And anytime you type "man" at the command prompt, and then the name of a function you're interested in, if it exists, it will tell you a little something about it. So if I go to toupper, man toupper, I get slightly cryptic documentation here. But notice, toupper and some other functions convert uppercase or lowercase. That's the summary. Notice that in the synopsis, the man page, so to speak, is telling me what header file I have to include. Notice that under Synopsis, it's also telling me what the signature or prototype is of the function. In other words, the documentation in Man, the Linux programmer's manual, is very terse. So it's not going to hold your hand in this black and white format. It's just going to convey, well, implicitly, you better put this on top of your file. And by the way, this is how you use the function. It takes an argument called C, returns a value of type int. Why is it int? Let me wave my hands at that. It effectively returns a character for our purposes today. And if we scroll down, OK, description. Ugh, I don't really want to read all of this, but OK, here we go. If c is a lowercase letter, toupper returns its uppercase equivalent, if an uppercase representation exists in the current locale. That just means if it's punctuation, it's not going to do anything. Otherwise, it returns C, And that's kind of the key detail. If I pass it lowercase A, it's going to give me capital A, but if I pass it capital A, what's it going to give me? AUDIENCE Capital A. DAVID J. MALAN Also, capital A. It returns the original character, c. That's the only detail I cared about. When in doubt, read the manual. And it might be a little cryptic, and this is why CS50 Reference takes somewhat cryptic documentation and tries to simplify it into more humanfriendly terms. But at the end of the day, these are the authoritative answers. And if I or one of the staff don't know, we literally pull up the Man page or CS50 Reference to answer these kinds of questions. Now what's the implication? I don't need any of this. I can literally get rid of the condition and just let toupper do all of the legwork, and now my program is so much more compact than the previous versions were, because I've read the documentation. I know what the function does, and I can let toupper uppercase something or just pass it through unchanged. We can better design, because we're writing fewer lines of code that are just as clear, and so we can now actually tighten things up. Any questions on this particular approach? All right. So we're getting very low level. Now let's make these things more useful, because clearly, other people have solved some of these problems for us, as by having these functions and the C type library and the string library. What more is there? Well, recall that every time we run Clang, or even run make, we're typing multiple words at the command prompt. You're typing make hello or make Mario, a second word, or you're typing clango, hello, hello.c, like lots of words at the prompt. Well, it turns out that all this time, you're using, indeed, command line arguments. But in C, you can write programs that also accept words and numbers when the user runs the program. Think back, after all. When you ran Mario, you did ./mario, Enter. You couldn't type any more words at the prompt. When you did credit, you did ./credit, Enter. No more words at the prompt. You used get string or get long to get more input, but not at the command line. And it turns out that we can, relatively simply, in C, but it's a little cryptic at first glance. Let me go ahead and let me go ahead and, here, pull up this signature here, which looks like this. This is the function that we're all used to by now for writing a main function. And up until now, we've said void. Main doesn't take any inputs, and indeed, it just runs. But it turns out if you change your existing programs or future programs, not to say void, but to say, int argc, string argv, it's a little cryptic at first glance. But what's a recognizable symbol now? Yeah, there's brackets here. So it turns out that every time you write a program, if you don't just say void, you actually enable this feature by writing int argc, string argv. You can actually tell Clang, you know what? I want this program to accept one or more words or numbers after the name of the program, so I can do ./hellodavid, or ./hellozamyla. I don't have to wait for the program to be running to use string. And just as with the earlier example, where you were able to chart an array, main is defined as taking an array, called argv historical reasons argument vector. Vector means array. Argument vector, bracket, closed bracket just means this is this contains one or more words, each of which is a string. Argc is argument count, so this is the variable that main gets access to that tells it how many arguments, how many strings are actually in argv. So how can we use this in a useful way? Well, let me go ahead here and open up the sandbox. And let me go ahead and create a new file called, say, argv0, argv0.c again, argument vector, just list or array of arguments. And let me go ahead and, as usual, include cs50.h, include stdio.h, and then int main not void, but int argc, string argv argv open bracket, closed bracket. And even if that doesn't come naturally at first, it will eventually. And I'm going to do this. If the number of arguments passed in equals 2, then I'm going to go ahead and do this printf, hello %s, comma, and here in the past, I've typed a variable name. And I now actually have access to a variable. Go ahead and do argv bracket 1. Else, if the user does not type, apparently, two words, let me go ahead and just by default, say, hello world, as we always have. Now why what is this doing, and how is it doing it? Well, let's quickly run it. So make whoops. Make argv0, ./argv0, Enter, Hello World. But if I do Hello or dot the program would be better named if we called it Hello, but Zamyla, Enter. Hello Zamyla. If I change it to David, now I have access to David. If I had David Malan, no. It doesn't support that. So what's going on? If you change main in any program write to take these two arguments, argc and argv of type string int and then an array of strings, argc tells you how many words were typed at the prompt. So if the human typed two words, I presume the first word is the name of the program, dot slash argv0, the second word is presumably my name, if he or she is actually providing their name at the prompt. And so I print out argv bracket 1. Not 0 because that's the name of the program, but argv bracket 1. Else, down here, if the human doesn't provide just Zamyla, or just David, or just one word more generally, I just print the default, "Hello world." But what's neat about this now is notice that argv is an array of strings. What is a string? It's an array of characters. And so let's enter just one last piece of syntax that gets kind of powerful here. Let me go ahead and do this. Let me go ahead and, in a new file here, argv 1 dot c. Let me go ahead and paste this in. Close this. Let me go ahead and do this. Rather than do this logical checking, let me do this, for let's say for int, i get 0. i is less than argc i++. Let's go ahead and, one per line, print out every word that the human just typed, just to reinforce that this is indeed what's going on. So argv bracket 0, save. Make argv 1, enter. And now let's go ahead and run this program dot slash, argv 1, David Malan. OK, you see all three words. If we change it to Zamyla, we see just those two words. If we change it to Zamyla Chan, we see those three words. So we clearly have access to all of the words in the array, but let's take this one step further. Rather than just print out every word in a string, let's go ahead and do this. For intj get 0. n equals the string length of the current argument, like this j is less than n, j++ oops, oops, oops j++. Now let me go ahead and print out not the full string, but let me do oops, oops let me go ahead and print out this not a string, but a character, n bracket i bracket j, like this. All right. So what's going on? One, this outer loop, and let's comment it, iterate over strings in argv. This inner loop, iterate over chars in argv bracket i. So the outer loop iterates over all of the strings in argv. And the inner loop, using a different variable, starting at 0, iterates over all of the characters in the ith argument, which itself is a string. So we can call string length on it. And then we do this up until n, which is the length of that string. And then we print out each character. So just to be clear when I run arv1 and correct it, at first glance, why it's implicitly declaring library function sterling, what's almost always the solution when you do this wrong? AUDIENCE [INAUDIBLE] DAVID J. MALAN Yeah. So I forgot this, so include string.h and help50 would help with that as well. Let's recompile with make argv1. All right. When I run argv1, of, say, Zamyla Chan, what am I going to see? AUDIENCE [INAUDIBLE] DAVID J. MALAN Yeah. Is that the right intuition? AUDIENCE [INAUDIBLE] DAVID J. MALAN I'm going to see Zamyla Chan, but AUDIENCE [INAUDIBLE] DAVID J. MALAN One character on each line, including the program's name. So in fact, let me scroll this up so it's a little bigger. Enter. OK, it's a little stupid, the program, but it does confirm that using arrays do I have access not only to the words, but I can kind of have the second dimension. And within each word, I can get at each character within. And we do this, again, just by using not just single square brackets, but double. And again, just break this down into the first principles. What is this first bracket? This is the ith argument, the ith string in the array. And then if you take it further, with bracket j, that gives you the j character inside of this. Now, who cares about any of this kind of functionality? Well, let me scroll back and propose one application here. So recall that CS is really just problem solving. But suppose the problem that you want to solve is to actually pass a secret message in class or send someone a secret for whatever reason. Well, the input to that problem is generally called plain test, a message you want to send to that other person. You ideally want ciphertext to emerge from it, which is enciphered and scrambled, somehow encrypted information so that anyone in the room, like the teacher, can't just grab the note and read what you're sending to your secret crush or love across the room, or in any other context as well. But the problem is that if the message you want to send, say, is our old friend Hi!, with an exclamation point, you can encode it in certain contexts as just 72, 73, 33. And I daresay most classes on campus if you wrote on a piece of paper 72, 73, 33, passed it through the room, and whatever professor intercepts it, they're not going to know what you're saying anyway. But this is not a good system. This is not a cryptosystem. Why? It's not secure. [INAUDIBLE] [INTERPOSING VOICES] DAVID J. MALAN Yeah. Anyone has access to this, right, so long as you attend like week 1 or 0 of CS50, or you just have general familiarity with Ascii. Like this is just a code. I mean Ascii is a system that maps letters to numbers. And anyone else who knows this code obviously knows what your message is, because it's not a unique secret to you and the recipient. So that's probably not the best idea. Well, you can be a little more sophisticated. And this is back actually, a photograph from World War I of a message that was sent from Germany to Mexico that was encoded in a very similar way. It wasn't using Ascii. The numbers, as you can perhaps glean from the photo, are actually much larger. But in this system, in a militaristic context, there was a code book. So similar in spirit to Ascii, where you have a column of numbers and a column of letters to which they correspond, a codebook more generally has like numbers, and then maybe even letters or whole words that they correspond to, sometimes thousands of them, like literally a really big book of codes. And so long as only, in this context the Germans and the recipients, the Mexicans, had access to that same book, only they could encrypt and decrypt, or rather encode and decode information. Of course, in this very specific context you can read more about this in historical texts this was intercepted. This message, seemingly innocuous, though definitely suspicious looking with all these numbers, so therefore not innocuous, the British, in this case actually, intercepted it. And thanks to a lot of efforts and cryptanalysis, the Bletchley Park style code breaking, albeit further back, were they able to figure out what those numbers represented in words and actually decode the message. And in fact, here's a photograph of some of the words that were translated from one to the other. But more on that in any online or textual references. Turns out in this poem too there was a similar code, right? So apropos of being in Boston here, you might recall this one. "Listen my children, and you shall hear of the midnight ride of Paul Revere. On the 18th of April in '75, hardly a man is now alive who remembers that famous day and year. He said to his friend, if the British march by land or sea from the town tonight night, hang a lantern aloft in the belfry arch of the North Church tower as a signal light, one if by land, and two if by sea. And I on the opposite shore will be ready to ride and spread the alarm through every Middlesex village and farm for the country folk to be up and to arm." So it turns out some of that is not actually factually correct, but the one if by land and the two if by sea code were sort of an example of a onetime code. Because if the revolutionaries in the American Revolution kind of decided secretly among themselves literally that we will put up one light at the top of a church if the British are coming by land. And we will instead use two if the British are instead coming by sea. Like that is a code. And you could write it down in a book, unless you have a code book. But of course, as soon as someone figures out that pattern, it's compromised. And so code books tend not to be the most robust mechanisms for encoding information. Instead, it's better to use something more algorithmic. And wonderfully, in computer science is this black box to we keep saying, the home of algorithms. And in general, encryption is a problem with inputs and outputs, but we just need one more input. The input is what's generally called the key, or a secret. And a secret might just be a number. So for instance, if I wanted my secret to be 1, because we'll keep the example simple, but it could really be any number. And indeed, we saw with the photograph a moment ago, the Germans used much larger than this, albeit in the context of codes. Suppose that you now want to send a more private message to someone across the room in a class that, I love you. How do you go about encoding that in a way that isn't just using Ascii and isn't just using some simple code book? Well, let me propose that now that we understand how strings are represented, right we're about to make love really, really lame and geeky so now that you know how to express strings computationally, well, let's just start representing "I love you" in Ascii. So I is 73. L is 76. OVE YOU. That's just Ascii. Should not send it this way, because anyone who knows Ascii is going to know what you're saying. But what if I enciphered this message, I performed an algorithm on it? And at its simplest, an algorithm can just be math simple arithmetic, as we've seen. So you know, let me just use my secret key of 1. And let me make sure that my crush knows that I am using a secret value of 1. So he or she also knows to expect that value. And before I send my message, I'm going to add 1 to every letter. So 73 becomes 74. 76 becomes 77. 80, 87, 70, 90, 80, 86. Now this could just be sent in the clear. But then, I could actually send it as a textual message. So let's convert it back to Ascii. 74 is now J. 77 is now M. 80 is now P. And you can perhaps see the pattern. This message was, I love you. And now, all of the letters are off by one, I think. I became J. L became M. O became P, and so forth. So now the claim would be, cryptographically, I'm going to send this message across the room. And now no one who has a code book is going to be able to solve this. I can't just steal the book and decode it, because now the key is only up here, so to speak. It's just the number 1 that he or she and I had to agree upon in advance that we would use for sending our secret messages. So if someone captures this message, teacher in the room or whoever, how would they even go about decoding this or decrypting it? Are there any techniques available to them? I daresay we can kind of chip away at this love note. AUDIENCE [INAUDIBLE] DAVID J. MALAN What's that? Guess and check. OK, we could try all there still kind of some spacing. So you know honestly, we could do like kind of a cryptanalysis of it, a frequency attack. Like, I can't think of too many words in English that have a single letter in them. So what does J probably represent? [INTERPOSING VOICES] DAVID J. MALAN I, probably. Maybe A, but probably I. And there's not too many other options. So we've attacked one part of the message already. I see a commonality. There's two what in here? Two P. And I don't necessarily know that that maps to O, but I do know it's the same character. So if I kind of continue this thoughtful process or this trial and error, and I figure out, oh, what if that's an O? And then that's an O. And then wait a minute. They're passing from one to another. Maybe this says, I love you. Like you actually can, with some probability, decrypt a message by doing this kind of analysis on it. It's at least more secure than the code book, because you're not compromised if the book itself is stolen. And you can change the key every time, so long as you and the recipient actually agree on something. But at least we now have this mechanism in place. So with just the understanding of what you can do with strings, can you actually now do really interesting domainspecific things to them? And in fact, back in the day, Caesar, back in militaristic times literally used a cipher quite like this. And frankly, when you're the first one to use these ciphers, they actually are kind of secure, even if they're relatively simple. But hopefully, not just using a key of 1, maybe 2, or 13, or 25, or something larger. But this is an example of a substitution cipher, or a rotational cipher where everything's kind of rotating A's becoming B, B's becoming C. Or you can kind of rotate it even further than that. Well, let's take a look at one last example here of just one other final primitive of a feature today, before we then go back high level to bring everything together. It turns out that printing out error messages is not the only way to signal that something has gone wrong. There's a new keyword, a new use of an old keyword in this example, that's actually a convention for signaling errors. So this is an example called exit.c. It apparently wants the human to do what, if you infer from the code? AUDIENCE Exit [INAUDIBLE]. DAVID J. MALAN Yes. Say again? AUDIENCE [INAUDIBLE] DAVID J. MALAN Well, it wants the well, what does it what the human to do implicitly, based on the printf's here? How should I run this program? Yeah? AUDIENCE [INAUDIBLE] just apply [INAUDIBLE].. DAVID J. MALAN Yeah. So for whatever reason, this program implicitly wants me to write exactly two words at the prompt. Because if I don't, it's going to yell at me, missing command line argument. And then it's going to return 1, whatever that is. Otherwise, it's going to say, Hello, such and such. So if I actually run this program let me go back over here and do make exit oops in my directory, make exit. OK, dot slash exit, enter, I'm missing a command line argument. All right, let me put Zamyla's name. Oh, Hello Zamyla. Let me put Zamyla Chan. Nope, missing command line argument. It just wants the one, so in this case here. I'm seeing visually the error message, but it turns out the computer is also signaling to me what the socalled exit code is. So long story short, we've already seen examples last week of how you can have a function return a value. And we saw how [? Erin ?] came up on stage, and she returned to me a piece of paper with a string on it. But it turns out that main is a little special. If main returns a value like 1 or 0, you can actually see that, albeit in a kind of a nonobvious way. If I run exit, and I run it correctly with Zamyla as the name, if I then type echo, dollar sign, question mark, of all things, enter, I will then see exactly what main returned with, which in this case is 0. Now, let me try and be uncooperative. If I actually run just dot slash exit, with no word, I see, missing command line argument. But if I do the same cryptic command, echo, dollar sign, question mark, I see that main exited with 1. Now, why is this useful? Well, as we start to write more complicated programs, it's going to be a convention to exit from main by returning a nonzero value, if anything goes wrong. 0 happens to mean everything went well. And in fact, in all of the programs we've written thus far, if you don't mention return anything, main automatically for you returns 0. And it has been all this time. It's just a feature, so you don't have to bother typing it yourself. But what's nice about this, or what's real about this, is if on your Mac or PC, if you've ever gotten an annoying error message that says, error negative 29, system error has occurred, or something freezes, but you very often see numbers on the screen, maybe. Like those error codes actually tend to map to these kinds of values. So when a human is writing software and something goes wrong and an error happens, they typically return a value like this. And the computer has access to it. And this isn't all that useful for the human running the program. But as your programs get more complex, we'll see that this is actually quite useful as a way of signaling that something indeed went wrong. Whew. OK, that's a lot of syntax wrapped in some loving context. Any questions before we look at one final domain? No? All right. So it turns out that we can answer the "who cares" question in yet another way too. It turns out let me go ahead and open up an example of our array again here that arrays can actually now be used to solve problems more algorithmically. And this is where life gets more interesting. Like we were so incredibly in the weeds today. And as we move forward in the class, we're not going to spend so much time on syntax, and dollar signs, and question marks, and square brackets, and the like. That's not the interesting part. The interesting part is when we now have these fundamental building blocks, like an array, with which we can solve problems. So it turns out that an array, you know, you can kind of think of it as a series of lockers, a series of lockers that might look like this, inside of which are values strings, or numbers, or chars, or whatnot. But the lockers is an apt metaphor because a computer, unlike us humans, can only see and do one thing at a time. It can open one locker and look inside, but it can't kind of take a step back, like we humans can, and look at all of the lockers, even if all of the doors are open. So it has to be a more deliberate act than that. So what are the actual implications? Well, all this time we had that phone book example in the first week, and the efficiency of that algorithm, of finding Mike Smith in this phone book, all assumed what feature of this phone book? AUDIENCE That it's ordered alphabetically. DAVID J. MALAN That it was ordered alphabetically. And that was a huge plus, because then I could go to the middle, and I could go to the middle of the middle, and so forth. And that was an algorithmic possibility. On our phones, if you pull up your contacts, you've got a list of first names, or last names, all alphabetically sorted. That is because, guess what data structure or layout your phone probably uses to store your contacts? It's an array of some sort, right? It's just a list. And it might be displayed vertically, instead of horizontally, as I've been drawing it today. But it's just values that are back, to back, to back, to back, to back, that are actually sorted. But how did they actually get into that sorted order? And how do you actually find values? Well, let's consider what this problem is actually like for a computer, as follows. Let me go ahead here. Would a volunteer mind joining us up here? I can throw in a free stress ball. OK, someone from the back? OK, come on up here. Come on. What's your name? ERIC Eric. DAVID J. MALAN Aaron. All right. So Aaron's going to come on up. And ERIC Eric. DAVID J. MALAN I'm sorry? Oh, Eric. Nice to meet you. All right. Come on over here. So Eric, now normally, I would ask you to find the number 23. But seeing is that's a little easy, can you go ahead and just find us the number 50 behind these doors, or really these yellow lockers? 8? Nope. 42? Nope. OK. Pretty good. That's three, three out of seven. How did you get it so quickly? ERIC I guessed. DAVID J. MALAN OK, so he guessed. Is that the best algorithm that Eric could have used here? ERIC Probably not. DAVID J. MALAN Well, I don't know. Yes? No? AUDIENCE Yeah. DAVID J. MALAN Why? Why yes? AUDIENCE [INAUDIBLE] DAVID J. MALAN He has no other information. So yes, like that was the best you can do. But let me give you a little more information. You can stay here. And let me go ahead and reload the screen here. And let me go ahead and pull up a different set of doors. And now suppose that, much like the phone book, and much like the phones are sorted, now these doors are sorted. And find us the number 50. All right. So good. What did you do that time? AUDIENCE Well, [INAUDIBLE]. It was 50 is 116. So I just DAVID J. MALAN Right. So you jumped to the middle, initially, and then to the right half. And then technically so we're technically off by 1, right? Because like binary search would have gone to the middle of the that's OK, but very well done to Eric. Here, let me at least reinforce this with a stress ball. So thank you. Very well done. So with that additional information, as you know, Eric was able to do better because the information was sorted on the screen. But he only had one insight to a locker at a time, because only by revealing what's inside can he actually see it. So this seems to suggest that once you do have this additional information in Eric's example, in your phone example, in the phone book example, you open up possibilities for much much, much more efficient algorithms. But to get there, we've kind of been deferring this whole time in class how you actually sort these elements. And if you wouldn't mind and this way, we'll hopefully end on a more energized note here because I know we've been in the weeds for a while can we get like eight volunteers? OK, so 1, 2, 3, 4 how about 5, 6, 7, 8, come on down. Oh, I'm sorry. Did I completely overlook the front row? OK. All right, next time. Next time. Come on down. Oh, and Colton, do you mind meeting them over there instead? All right. Come on up. What's your name? [? CAHMY ?] [? Cahmy. ?] DAVID J. MALAN [? Cahmy? ?] David. Right over there. What's your name? MATT Matt. DAVID J. MALAN Matt? David. [? JUHE ?] [? Juhe. ?] DAVID J. MALAN [? Juhe? ?] David. MAX Max. DAVID J. MALAN Max, nice to meet you. JAMES James. DAVID J. MALAN James, nice to see you. Here, I'll get more chairs. What's your name? ,PEYTON Peyton. DAVID J. MALAN Peyton? David. And two more. Actually can what have you come down to this end here? What's your name. ANDREA Andrea. DAVID J. MALAN Andrea, nice to see you. And your name? [? PICCO ?] [? Picco. ?] DAVID J. MALAN [? Picco, ?] David. Nice to see you. OK, Colton has a Tshirt for each of you, very Harvardesque here. And each of these shirts, as you're about to see, has a number on it. And that number is well, go ahead put them on, if you wouldn't mind. OK, thank you so much. So I daresay we've arranged our humans much like the lockers in an array. Like we have humans back, to back, to back, to back. But this is actually both a blessing and a constraint, because we only have eight chairs. So there's really not much room here, so we're confined to just this space here. And I see we have a 4, 8, 5, 2, 3, 1, 6, 7. So this is great. Like they are unsorted. By definition, it's pretty random. So that's great. So let's just start off like this. Sort yourselves from 1 to 8, please. OK. All right. Well, what algorithm was that? [LAUGHTER] AUDIENCE Look around, figure it out. DAVID J. MALAN Look around, figure it out. OK, well MATT Human ingenuity. DAVID J. MALAN Human ingenuity? Very well done. So can we well, what was like a thought going through any of your minds? MATT Find a chair and sit down. DAVID J. MALAN Find the chair find the right chair. So go to a location. Good. So like an index location, right? Arrays have indices, so to spea 0, 1, 2, all the way up to 7. And even though our shirts are numbered from 1 to 8, you can think in terms of 0 to 7. So that was good. Anyone else? Other thoughts? [? CAHMY ?] I mean, this is something we implicitly think of, but no one told us that it was ordered right to left. Like we could have done it left to right. DAVID J. MALAN OK. Absolutely. Could have gone from right to left, instead of left to right. But at least we all agreed on this convention too, so that was in your mind. OK. So good. So we got this sorted. Go ahead and rerandomize yourself, if you could. And what algorithm was this? Just random awkwardness? OK, so that's fine. So it looks pretty random. That will do. Let's see if we can now reduce the process of sorting to something a little more algorithmic so that, one, we can be sure we're correct and not just kind of get lucky that everyone kind of figured it out and no one was left out, and two, then start to think about how efficient it is, right? Because if we've been gaining so much efficiency for the phone book, for our contacts, for [? error ?] coming up, we really should have been asking the whole time, sure, you save time with binary search and divide and conquer, but how much did it cost you to get to a point where you can use binary search and divide and conquer? Because sorting, if it's super, super, super expensive and timeconsuming maybe it's a net negative. And you might as well just search the whole list, rather than ever sort anything. All right. So let's see here. 6 and 5, I don't like this. Why? AUDIENCE [INAUDIBLE] DAVID J. MALAN 6 is supposed to come after 5. And so, can we fix this, please? All right. And then let's see. OK, 6 and 1 ugh, don't really like this. Yeah, can we fix this? Very nice. 6 and 3, OK, you really got the short end of the stick here. So 6 and 3, could we fix this? And 6 yeah, OK. Ooh, OK, 6 and 7 good. All right, so that's pretty good. 7 and 8, nice. 8 and 4, sorry. Could we switch here? All right. And then 8 and 2? OK, could we switch here? OK. And let me ask you a somewhat rhetorical question. OK, am I done? OK, no. Obviously not, but I did fix some problems, right? I fixed some transpositions, numbers being out of order. And in fact, I what's your name again? [? CAHMY ?] [? Cahmy. ?] DAVID J. MALAN [? Cahmy, ?] kind of bubbled to the right here, if you will. Like you were kind of farther down, and now you're over here. And like the smaller numbers, kind of yeah 1. Like, my god, like he kind of bubbled his way this way. So things are percolating, in some sense. And that's a good thing. And so you know what? Let Me try to fix some remaining problems. So 1 and 5 good. Oh 3 and 5, could you switch? 5 and 6, OK. 6 and 7? 7 and 4, could you switch? OK. And 7 and 2, could you switch? And now, I don't have to speak with [? Cahmy ?] again, because we know you're in the right place. So I actually don't have to do quite as much work this time, which is kind of nice. But am I done? No, obviously not. But what's the pattern now? Like what's the fundamental primitive? If I just compare pairwise humans and numbers, I can slightly improve the situation each time by just swapping them, swapping them. And each time now I'm sorry, [? Picco ?] is in number 7's place. I don't have to talk to him anymore, because he's now bubbled his way all the way up to the top. So even though I'm doing the same thing again and again, and looping again and again isn't always the best thing, so long as you're looping fewer and fewer times, I will eventually stop, it would seem. Because 6 is going to eventually go in the right place, and then 5, and then 4, and so forth. So if we can just finish this algorithm. Good. Not good. OK, 6 and 2, not good. If you could swap? OK, and what's your name again? PEYTON Peyton. DAVID J. MALAN Peyton is now in the right place. I have even less work now ahead of me. So if I can just continue this process 1 and 3, 3 and 5, 4 and 5, OK, and then 2 and 5. And then, what's your name again? MATT Matt. DAVID J. MALAN Matt is now in the right place. Even less work. We're almost there. 1 and 3, 3 and 4, 4 and 2, if you could swap. OK, almost done. And 1 and 3, 3 and 2, if you could swap. Nice. So this is interesting. It would seem that you know, in the first place, I kind of compared seven pairs of people. And then the next time I went through, I compared how many pairs of people maximally? AUDIENCE [INAUDIBLE] DAVID J. MALAN Just six, right? Because we were able to leave [? Cahmy ?] out. And then we were able to leave [? Picco ?] out, and then Peyton. And so the number of comparisons I was doing was getting fewer and fewer. So that feels pretty good. But you know what? Before We even analyze that, can you just randomize yourselves again? Any human algorithm is fine. Let's try one other approach, because this feels kind of nonobvious, right? I was fixing things, but I had to keep fixing things again and again. Let me try to take a bigger bite out of the problem this time by just selecting the smallest person. OK, so your name again is? [? JUHE ?] [? Juhe. ?] DAVID J. MALAN [? Juhe, ?] number 2 that's a pretty small number, so I'm going to remember that in sort of a mental variable. 4? No, you're too big. Too big. Oh, what was your name again? JAMES James. DAVID J. MALAN James. James is a 1. That's pretty nice. Let me keep checking. OK, James, in my mental variable is the smallest number. I know I want him at the beginning. So if you wouldn't mind coming with me. And I'm sorry, we don't have room for you anymore. If you could just oh, you know what? Could you all just shuffle down? Well, hm, I don't know if I like that. That's a lot of work, right? Moving all these values, let's not do that. Let's not do that. Number 2, could you mind just going where where JAMES It's James. DAVID J. MALAN James was? OK, so I've kind of made the problem a little worse in that, now, number 2 is farther away from the goal. But I could have gotten lucky, and maybe she was number 7 or 8. And so let me just claim that, on average, just evicting the person is going to kind of be a wash and average out. But now James is in the right place. Done. Now I have a problem that's of size 7. So let me select the next smallest person. 4 is the next smallest, not 8, not 5, not 7 ooh, 2. Not 3, 6. OK, so you're back in the game. All right, come on back. And can we evict number 4? And on this algorithm, if you will, I just interpretively select the smallest person. I'm not comparing everyone in quite the same way and swapping them pairwise, I'm doing some of more macroscopic swaps. So now I'm going to look for the next smallest, which is 3. If you wouldn't mind popping around here? [? Cahmy, ?] we have to, unfortunately, evict you, but that works out to our favor. Let me look for the next smallest, which is 4. OK, you're back in. Come on down. Swap with 5. OK, now I'm looking for 5. Hey, 5, there you are. OK. So go here. OK, looking for 6. Oh, 6, a little bit of a shuffle. OK. And now looking for 7. Oh, 7, if you could go here. But notice, I'm not going back. And this is what's important. Like my steps are getting shorter and shorter. My remaining steps are getting shorter and shorter. And now we've actually sorted all of these humans. So two fundamentally different ways, but they're both comparative in nature, because I'm comparing these characters again, and again, and again, and swapping them if they're out of order. Or at a higher level, going through and swapping them again, and again, and again. But how many steps am I taking each time? Even though I was doing fewer and fewer and I wasn't doubling back, the first time, I was doing like n minus 1 comparisons. And then I went back here. And in the first algorithm, I kind of stopped going as far. In the second algorithm, I just didn't go back as far. So it was just kind of a different way of thinking of the problem. But then I did what? Like seven comparisons? Then six, then five, then four, then three, then two, then one. It's getting smaller, but how many comparisons is that total? I've got like n people, n being a number. AUDIENCE [INAUDIBLE] DAVID J. MALAN Is not as bad as factorial. We'd be here all day long. But it is big. It is big. Let's go a round of applause, if we could, for our volunteers. You can keep the shirts, if you'd like, as a souvenir. [APPLAUSE] Thank you, very much. Let me see if we can't just kind of quantify that thank you, so much and see how we actually got to that point. If I go ahead and pull up not our lockers, but our answers here, let me propose that what we just did was essentially two algorithms. One has the name bubble. And I was kind of deliberately kind of shoehorning the word in there. Bubble sort is just that comparative sort, pair by pair, fixing tiny little mistakes. But we needed to do it again, and again, and again. So those steps kind of add up, but we can express them as pseudocode. So in pseudocode and you can write this any number of ways I might just do the following. Just keep doing the following, until there's no remaining swaps from i from 0 to n 2, which is just n is the total number of humans. n 2 is go up from that person to this person, because I want to compare him or her against the person next to them. So I don't want to accidentally do this. That's why it's n 2 at the end here. Then I want to go ahead and, if the ith and the ith +1 elements are out of order, swap them. So that's why I was asking our human volunteers to exchange places. And then just keep doing that, until there's no one left to swap. And by definition, everyone is in order. Meanwhile, the second algorithm has the conventional name of selection sort. Selection sort is literally just that, where you actually select the smallest person, or number of interest to you, intuitively, again and again. And the number keeps getting bigger, but you start ignoring the people who you've already put into place. So the problem, similarly, is getting smaller and smaller. Just like in bubble sort, it was getting more and more sorted. The pseudocode for selection sort might look like this. For i from 0 to n 1, so that's 0 in an array. And this is n 1. Just keep looking for the smallest element between those two chairs, and then pull that person out. And then just evict whoever's there swap them, but not necessarily adjacently, just as far away as is necessary. And in this way, I keep turning my back on more and more people because they are then in place. So two different framings of the problem, but it turns out they're actually both the same number of steps, give or take. It turns out they're roughly the same number of steps, even though it's a different way of thinking about it. Because if I think about bubble sort, the first iteration, for instance, what just actually, well, let's consider selection sort even. In selection sort, how many comparisons did I have to do? Well, once I found my smallest element, I had to compare them against everyone else. So that's n 1 comparisons the first time. So n 1 on the board. Then I can ignore them, because they're behind me now. So now I have how many comparisons left out of n people? n 2, because I subtracted one. Then again, n 3, then n 4, all the way down to just one person remaining. So I'll express that sort of generally, mathematically, like this. So n 1 plus n 2 plus whatever plus one final comparison, whatever that is. It turns out that if you actually read the back of the math book or your physics textbooks where they have those little cheat sheets as to what these recurrences are, turns out that n 1 plus n 2 plus n 3 and so forth can be expressed more succinctly as literally just n times n 1 divided by 2. And if you don't recall that, that's OK. I always look these things up as well. But that's true fact. So what does that equal out to? Well, it's like n squared minus n, if you just multiply it out. And then if you divide the two, then it's n squared divided by 2 minus n over 2. So that's the total number of steps. And I could actually plug this in. We could plug in 8, do the math, and get the total number of comparisons that I was verbally kind of rattling off. So is that a big deal? Hm, it feels like it's on the order of n squared. And indeed, a computer scientist, when assessing the efficiency of an algorithm, tends not to care too much about the precise values. All we're going to care about it's the biggest term. What's the value in the formula that you come up with that just dominates the other terms, so to speak, that has the biggest effect, especially as n is getting larger and larger? Now, why is this? Well, let's just do sort of proof by example, if you will. If this is the expression, technically, but I claim that, ugh, it's close enough to say on the order of, big O of n squared, so to speak, let's use an example. If there's a million people on stage, and not just eight, that math works out to be like a million squared divided by 2 steps minus a million divided by 2, total. So what does that actually work out to be? Well, that's 500 billion minus 500,000. And what does that work out to be? Well, that's 499 billion, 999 million, 500,000. That feels pretty darn close to like n squared. I mean, that's a drop in the bucket to subtract 500,000 from 500 billion. So you know what? Eh, it's on the order of n squared. It's not precise, but it's in that general order of magnitude, so to speak. And so this symbol, this capital 0, is literally a symbol used in computer science and in programming to just kind of describe with a wave of the hand, but some good intuition and algorithm, how fast or slow your algorithm is. And it turns out there's different ways to evaluate algorithms with just different similar formulas. n squared happens to be how much time both bubble sort and selection sort take. If I literally count up all of the work we were doing on stage with our volunteers, it would be roughly n squared, 8 squared, or 64 steps, give or take, for all of those humans. And that would be notably off. There's a good amount of rounding error there. But if we had a million volunteers on stage, then the rounding error would be pretty negligible. But we've actually seen some of these other orders of magnitude, so to speak, before. For instance, when we counted someone, or we searched for Mike Smith one page at a time, we called that a linear algorithm. And that was big O of n. So it's on the order of n steps. It's 1,000. Maybe it's 999. Whatever. It's on the order of n steps. The [? twosies ?] approach was twice as fast, recall two pages at a time. But you know what? That's still linear, right? Like two pages at a time? Let me just wait till next year when my CPU is twice as fast, because Intel and companies keep speeding up computers. The algorithm is fundamentally the same. And indeed, if you think back to the picture we drew, the shapes of those curves were indeed the same. That first algorithm, finding Mike one page at a time looked like this. Second algorithm finding him looked like this. Only the third algorithm, the divide and conquer, splitting the phone book was a fundamentally different shape. And so even though we didn't use this fancy phrasing a couple of weeks ago, these first algorithms, one page at a time, two pages at a time, eh, they're on the order of n. Technically, yes, n versus n divided by 2, but we only care about the dominating factor, the variable n. We can throw away everything in the denominator, and we can throw away everything that's smaller than the biggest term, which in this case is just n. And I alluded to this two weeks ago logarithmic. Well, it turns out that any time you divide something again, and again, and again, you're leveraging a logarithmic type function, log base 2 technically. But on the order of log base n is a common one as well. The beautiful algorithms are these literally, one step, or technically constant number of steps. For instance, like what's an algorithm that might be constant time? Open phone book. OK, one step. Doesn't really matter how many pages there are, I'm just going to open the phone book. And that doesn't vary by number of pages. That might be a constant time algorithm, for instance. So those are the lowest you can go. And then there's somewhere even in between here that we might aspire to with certain other algorithms. So in fact, let's just see if just a moment let's just see if we can do this a little more succinctly. Let's go ahead and use arrays in just one final way, using merge sorts. So it turns out, using an array, we can actually do something pretty powerfully, so long as we allow ourselves a couple of arrays. So again, when we just add sorting with bubble sort and selection sort, we had just one array. We had eight chairs for our eight people. But if I actually allowed myself like 16 chairs, or even more, and I allowed these folks to move a bit more, I could actually do even better than that using arrays. So here's some random numbers that we'll just do visually, without any humans. And they're in an array, back, to back, to back, to back. But if I allow myself a second array, I'm going to be able to shuffle these things around and not just compare them, because it was those comparisons and all of my footsteps in front of them that really started to take a lot of time. So here's my array. You know what? Just like the phone book that phone book example got us pretty far in the first week let me do half of the problem at a time and then kind of combine my answer. So here's an array 4, 2, 7, 5, 6, 8, 3, 1 randomly sorted. Let me go ahead and sort just half of this, just like I searched for Mike initially in just half of the phone book. So 4, 2, 7, 5 not sorted. But you know what? This feels like too big of a problem, still. Let me sort just the left half of the left half. OK, now it's a smaller problem. You know what? 4 and 2, still out of order. Let me just divide this list of two into two tiny arrays, each of size 1. So here's a miniarray of size 1, and then another one of like size 7, but they're back to back, so whatever. But this array of size 1, is it sorted? AUDIENCE No. DAVID J. MALAN I'm sorry? AUDIENCE No. DAVID J. MALAN No? If this array has just one element and that element is 4 AUDIENCE There's only one thing you can do. DAVID J. MALAN Yes, then it is sorted, by definition. All right, so done. Making some progress. Now, let me kind of mentally rewind. Let me sort the right half of that array. So now I have another array of size 1. Is this array sorted? Yeah, kind of stupidly. We don't really seem to be doing anything. We're just making claims. But yes, this is sorted. But now, this was the original half. And this half is sorted. This half is sorted. What if I now just kind of merge these sorted halves? I've got two lists of size 1 4 and 2. And now if I have extra storage space, if I had like extra benches, I could do this a little better. don't I go ahead and merge these two as follows? 2 will go there. 4 will go there. So now I've taken two sorted lists and made one bigger, more sorted list by just merging them together, leveraging some additional space. Now, let me mentally rewind. How did I get to 4 and 2? Well, I started with the left half, then the left half of the left half. Let me now do the right half of the left half, if you will. All right, let me divide this again. 7, list of size 1, is it sorted? Yes, trivially. 5, is it sorted? Yes. 7 and 5, let's go ahead and merge them together. 5 is, of course, going to go here. 7, of course, is going to go here. OK. Now where do we go? We originally sorted the left half. Let's go sort the right oh, right. Sorry. Now, we have the left half. And the right half of the left half are sorted. Let's go ahead and merge these. We have two lists now of size 2 2, 4 and 5, 7, both of which are sorted. If I now merge 2, 4 and 5, 7, which element should come first in the new longer list, obviously? 2. And then 4, then 5, and then 7. That wasn't much of anything. But OK, we're just using a little more space in our array. Now what comes next? Now, let's do the right half. Again, we started by taking the whole problem, doing the left half, the left half of the left half, the left half of the left half of the left half. And now we're going back in time, if you will. So let's divide this into two halves, now the left half into two halves still. 6 is sorted. 8 is sorted. Now I have to merge them 6, 8. What comes next? Right half 3 and 1. Well, left half is sorted, right half is sorted 1 and 3. All right, now how do I merge these? 6, 8, 1, 3, which element should obviously come first? 1, then 3, then 6, then 8. And then lastly, I have two lists of size four. Let me give myself a little more space, one more array. Now let me go ahead and put 1, and 2, and 3, and 4, and 5, and 6, and 7, and 8. What just happened? Because it actually happened a lot faster, even though we were doing this all verbally. Well notice, how many times did each number change locations? Literally three, right? Like one, two, three, right? It moved from the original array, to the secondary array, to the tertiary array, to the fourth array, whatever that's called. And then it was ultimately in place. So each number had to move one, two, three spots. And then how many numbers are there? AUDIENCE [INAUDIBLE] DAVID J. MALAN Well, they were already in the original array. So how many times do they have to move? Just one, two, three. So how many total numbers are there, just to be clear? There's eight. So 8 times 3. So let's generalize this. If there's n numbers, and each time we moved the numbers we did like half of them, than half, then half, well, how many times can you divide 8 by 2? 8 goes to 4. 4 goes to 2. 2 goes to 1. And that's why we bottomed out at one element, lists of size 1. So it turns out whenever you divide something by half, by half, by half, what is that function or formula? Not power, that's bad. That's the other direction. AUDIENCE [INAUDIBLE] DAVID J. MALAN It's a logarithm. So again, logarithm is just a mathematical description for any function that you keep dividing something again, and again, and again. In half, in half, in half, in third, in third, in third, whatever it is, it just means division by the same proportional amounts again, and again, and again. And so if we move the numbers three times, or more generally log of n times, which again just means you divided n things again, and again, and again, you just call that log n. And there's n numbers, so n numbers moved log n times, the total arithmetic here in question is one of those other values on our little cheat sheet, which looked like this. In our other cheat sheet, recall that we had formulas that looked like this, not just n squared and n, and log n, and 1, we have this one in the middle n times log n. So again, we're kind of jumping around here. But again, each number moves log n places. There's n total numbers. So n times log n is just, by definition, n log n. But why is this sorted this way? Well log n, recall from week 0 with the phone book example, the green curve is definitely smaller than n. n was the straight lines, log n was the green curved one. So this indeed belongs in between, because this is n times n. This is n. This is n times something smaller than n. So what's the actual implication? Well, if we were to run these algorithms side by side and actually compare them with something like this let me go ahead and compare these algorithms using this demo here if I go ahead and hit play, we'll see that the bars in this chart are actually horizontal. And the small bars represent small numbers, large bars represent long numbers. And then each of these is going to run a different algorithm selection sort on the left, bubble sort in the middle, merge sort, as we'll now call it, on the right. And here's how long each of them take to sort those values. Bubble's still going. Selection's still going. And so that's the appreciable difference, albeit with a small demo, between n squared and something like log n. And so what have we done here? We've really, really, really got into the weeds of what arrays can actually do for us and what the relationships are with strings, because all of it kind of reduces to just things being back, to back, to back, to back. But now that we kind of come back, and we'll continue along this trajectory next time to be able to talk at a much higher level about what's actually going on. And we can now take this even further, by applying other sort of forms of media to these same kinds of questions. And we'll conclude it's about 60 seconds long. These bars are vertical, instead of horizontal. And what you'll see here is a visualization of various sorting algorithms, among them selection sort, bubble sort, and merge sort, and a whole assortment of others, each of which has even a different sound to it because of the speed and the pattern by which it actually operates. So let's take a quick look. [VIDEO PLAYBACK] [MUSIC PLAYING] This is bubble sort. And you can see how the larger elements are indeed bubbling up to the top. [? And you can kind of hear the ?] periodicity, or the cycle that it's going in. And there's less, and less, and less, and less work to do, until almost This is selection sort now. So it starts off random, but we keep selecting the smallest human or, in this case, the shortest bar. And you'll see here the bars correlate with frequency, clearly. So it's getting higher and higher and taller and taller. This is merge sort now which, recall, does things in halves, and then halves of halves, and then merges those halves. So we just did all the left work, almost all the right work. That one's very gratifying. [LAUGHS] This is something called [? nom ?] sort, which is improving things. Not quite perfectly, but it's always making forward progress, and then kind of doubling back and cleaning things up. [END PLAYBACK] Whew. That was a lot. Let's call it a day. I'll stick around for oneonone questions. We'll see you next time. [APPLAUSE]
