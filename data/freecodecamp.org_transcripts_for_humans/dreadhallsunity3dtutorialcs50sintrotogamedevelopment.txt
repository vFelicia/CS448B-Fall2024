With timestamps:

00:00 - [Music]
00:17 - all right welcome to lecture nine of
00:19 - gd50 today's topic is dread halls um so
00:24 - last week we ventured into unity our
00:26 - first foray into 3d and not only 3d but
00:29 - also just getting our hands around um
00:31 - our heads and hands around the unity
00:33 - game engine which is uh among unreal and
00:36 - others sort of the most popular game
00:38 - engines in use for 2d and 3d games
00:41 - um and last week we did sort of a 2.5 d
00:44 - style helicopter game whereby everything
00:46 - was in 3d but we were still
00:49 - aligning things based on just two axes
00:51 - the x and the y i believe um possibly
00:54 - the z and the y i don't remember but two
00:56 - axes versus three axes today we'll
00:58 - actually be
00:59 - diving into using all three axes
01:01 - available to us in unity 3d in the
01:02 - context of a game called dread halls and
01:05 - so what dread halls is
01:07 - is a
01:08 - v it was a vr game actually the first vr
01:10 - game that i ever played
01:12 - um on the oculus the the gear vr samsung
01:15 - gear vr and it pits you in sort of this
01:18 - dark and eerie 3d maze where you don't
01:20 - really know what's going on and you can
01:22 - go around and get collectibles and
01:24 - encounter creatures and stuff as you can
01:25 - see in the bottom right screenshot there
01:28 - today's example is going to be a little
01:29 - simpler but it allows us to explore
01:31 - things like procedural maze generation
01:33 - and
01:34 - first person camera controls so last
01:36 - week recall we were using sort of a
01:37 - three
01:38 - a third person camera whereby we were
01:40 - sort of far back on the scene
01:42 - today we'll actually be using a
01:44 - first-person camera where the camera is
01:45 - effectively our eyes as if we were
01:47 - walking around in the maze ourselves
01:51 - unfortunately we won't be using a vr
01:53 - demonstration this week but next week i
01:54 - hope to put together sort of a vr
01:56 - sampling
01:58 - using this project so we can see how
01:59 - this works in vr and how unity's toolkit
02:01 - works in vr so some of the topics we'll
02:03 - be covering today we'll be talking about
02:05 - texturing so recall last week
02:07 - the helicopter and all of the items in
02:09 - our game were just sort of flat colors
02:12 - they didn't really have any textures
02:13 - associated with them we'll talk about
02:14 - how to assign textures to materials and
02:16 - how to apply those materials to objects
02:18 - in our scene we'll talk about materials
02:20 - and lighting so not only materials but
02:22 - also
02:23 - the different kinds of lights that unity
02:25 - supports and a few details
02:27 - about those we'll talk about again 3d
02:30 - maze generation so we'll have a simple
02:31 - but effective algorithm for creating
02:35 - a 3d data structure to represent our
02:38 - level as opposed to previously where we
02:39 - had just a you know a tile map that we
02:42 - could generate to give us the appearance
02:44 - of walking around in some sort of 2d
02:46 - world now we'll actually perform a
02:48 - similar operation on data a 2d array but
02:50 - we'll take that array and we'll actually
02:52 - create 3d blocks and create a maze that
02:54 - we can walk through in 3d space
02:56 - which is
02:57 - kind of fun and interesting
02:59 - last week we only had one scene in our
03:01 - game so which was just a play scene and
03:03 - even though we had sort of like a game
03:05 - over state within that scene we didn't
03:06 - transition between scenes we just sort
03:08 - of reloaded the same scene today we'll
03:10 - have a title screen and a play scene
03:14 - which sort of um
03:16 - is an evolution of the idea that we had
03:18 - in love 2d where we had a state machine
03:20 - that was governing our entire game um in
03:22 - terms of the different states that we
03:24 - could be in whether it was the title the
03:25 - game over the play state and so forth
03:28 - unity does the same thing with scene
03:30 - objects which are effectively a snapshot
03:32 - of a series of game objects aligned in a
03:35 - particular way in the editor
03:37 - we'll talk about fog and also global
03:40 - lighting and certain other things that
03:42 - allow us to create a atmosphere
03:44 - conducive to the sort of feel that we
03:46 - want to get in our game today which is
03:47 - sort of creepy and eerie and lastly when
03:50 - we talk about how to create ui elements
03:53 - in the game we'll talk about unity2d
03:56 - it's canvas object and text labels and
03:58 - some other things and how those all
03:59 - operate
04:00 - which is sort of two sides of the same
04:02 - coin unity 3d
04:04 - also comes bundled with unity2d a set of
04:07 - tools used to make not only 2d games but
04:10 - also 2d interfaces that you can apply to
04:12 - your 3d games
04:14 - so first a demo now i've been sick for
04:16 - the last week so i'm not going to
04:19 - ask for anybody to come up and demo just
04:20 - because i don't want to get anybody else
04:21 - sick
04:22 - so i'm going to just go ahead and show
04:25 - just this lecture the
04:27 - game that i put together for you so here
04:29 - i have two scenes notice here i have a
04:31 - title scene and a play scene i'm in the
04:33 - unity editor right now
04:34 - i'm going to load up the title scene
04:36 - here which i've done and then notice
04:38 - that it has sort of a game view and a
04:39 - scene view i'm going to hit play i'm
04:41 - going to make sure that it's set to
04:42 - maximize which it is and so we have
04:45 - sound here so we should hear audio and
04:46 - hit play
04:49 - and notice that we have sort of like
04:51 - this ambient creepy music track playing
04:54 - we have a very we could have easily done
04:57 - this in love2d this is just a black
04:59 - screen with two uh text labels on it um
05:02 - and this is done with unity's 2d ui
05:04 - toolkit
05:06 - and so it says it tells us to press
05:07 - enter so if i press enter we instantly
05:10 - get teleported into kind of like this
05:12 - maze this creepy looking maze and so i
05:14 - can walk around
05:16 - in this maze and there are a few things
05:18 - going on so anybody um can anybody tell
05:21 - me some of the things they noticed about
05:22 - the scene
05:23 - what jumps out at them
05:31 - what are some of the elements if you
05:32 - were to put this together yourself where
05:34 - would you start what are the pieces that
05:36 - we can put together here
05:44 - yep there has to be a ground that you
05:46 - can stand on and there is so we're
05:48 - generating
05:49 - uh not only walls in our scene of course
05:52 - but we need a ground to sit and
05:53 - obviously and also if you look up top
05:55 - it's kind of difficult to tell but we
05:57 - also have a ceiling so ground and a
05:58 - ceiling and walls
06:03 - some kind of lighting yes
06:05 - and so in in this case we're actually
06:07 - using ambient world lighting as opposed
06:09 - to having a light source so we'll take a
06:11 - look at that last in last week's lecture
06:12 - we used or two weeks priors lecture we
06:14 - used a directional light object but in
06:16 - this case we have no lights in the scene
06:18 - we're actually using unity's world
06:19 - lighting which we'll take a look at soon
06:24 - when we walk around
06:26 - notice that i can move my where my
06:28 - camera is looking with my mouse
06:30 - so we're actually controlling the camera
06:32 - with a first person controller an fps
06:35 - controller which is actually a component
06:37 - that unity provides to you
06:40 - and then notice eventually if we keep
06:42 - exploring the maze we come across this
06:45 - little thing here which is a um sort of
06:47 - a pickup and when we pick this up
06:52 - we get sort of like this piano weird
06:53 - creepy piano sound and then the scene
06:55 - reloads
06:58 - um
06:59 - anybody notice anything about what we
07:01 - see in the distance like how that's how
07:03 - that's affected
07:07 - like if i'm looking at this wall right
07:08 - here for example it's kind of hard to
07:10 - tell but as opposed to like down this
07:13 - hallway what's what's the difference
07:14 - there
07:17 - the light source is further away i guess
07:19 - the light source is further away kind of
07:21 - so we're what we're experiencing here
07:23 - we're seeing is uh it's a
07:25 - a graphics a sort of concept called fog
07:29 - and so what fog lets you do is
07:32 - it effectively adds color to the scene
07:34 - based upon how far away the objects are
07:36 - in the scene it multiplies color onto
07:38 - them and it gives you the illusion of
07:40 - looking in look as if you're surrounded
07:43 - by fog basically and it's been around
07:45 - for a very long time back even as far as
07:47 - the n64 days and we'll talk about that
07:49 - um later today and it's actually
07:50 - incredibly easy to add that into a game
07:53 - with unity and its world lighting system
07:55 - any idea
07:56 - as to how fog not only in terms of
07:58 - aesthetics but how it could maybe help
08:00 - with performance
08:08 - yeah you don't need as much
08:10 - pixel clarity because it's already
08:12 - blurry you don't need as much pixel
08:14 - clarity um kind of the
08:18 - the big thing about fog and the way that
08:20 - it was used a long time ago is that
08:22 - because eventually things are completely
08:25 - opaque beyond a certain point you don't
08:27 - need far draw distance in your game so
08:29 - you can actually
08:31 - like dynamically you can you can emit
08:33 - rendering things that are a certain
08:34 - distance away because you wouldn't be
08:36 - able to see them anyway and so this was
08:38 - an optimization technique used a lot
08:40 - back when draw distance was a huge
08:43 - bottleneck on computers and gave video
08:46 - game consoles back in like the 90s for
08:47 - example like silent hill the game for
08:49 - ps1 was almost exclusively fog and you
08:52 - could see very little in front of you
08:53 - and we'll see a screenshot of that later
08:55 - and they use that for um to boost their
08:58 - performance and also to provide a
08:59 - certain aesthetic
09:01 - and then one other thing you might be
09:02 - paying attention to is there's a sound
09:03 - on loop just sort of this creepy sort of
09:06 - whispering sound and that's to
09:08 - um just add atmosphere right just
09:11 - because without it we would you know
09:13 - it's
09:14 - little things like that especially in
09:16 - horror games like this
09:17 - the atmosphere can be everything so with
09:19 - very simple ideas fog some whispers
09:22 - first person controller sort of tight
09:23 - hallways
09:25 - you can produce something that's pretty
09:26 - scary now there are a few things missing
09:28 - from this namely there's nothing that's
09:30 - going to come at you and attack you
09:33 - but it would be not terribly difficult
09:35 - to add but
09:37 - because we're using procedural
09:38 - generation you would need what's called
09:40 - a nav mesh and you would need to
09:42 - generate that procedurally so things
09:43 - could follow you in 3d space
09:45 - we might have some time to talk about
09:47 - how to do that a little bit later today
09:49 - but that's not implemented in this
09:51 - particular lecture
09:52 - but it would be not too
09:55 - infeasible to accomplish
09:57 - but those are some of the pieces that
09:59 - we'll take a look at today
10:00 - so that was this is the title scene
10:03 - notice that there's uh not a whole lot
10:05 - here actually so if i zoom back out we
10:07 - can see you know canvases are huge in
10:09 - unity just because it's more optimized
10:11 - for the engine to render them that way
10:13 - but we can see even though it's a 2d
10:15 - sort of
10:17 - ui
10:18 - it's very visible in 3d space and if we
10:21 - click this button here
10:23 - we end up getting
10:25 - uh
10:26 - oh no that's that just brings us into
10:28 - sorry click this button here that brings
10:30 - us into sort of the 2d unity 2d mode so
10:33 - now we're interacting with things in 2d
10:35 - and i can actually click on this label
10:37 - and move it around
10:39 - in 2d as if we were using a 2d game
10:41 - engine as opposed to a 3d game engine so
10:44 - we'll look at that a little bit later
10:45 - this is the just the title scene so the
10:47 - play scene itself
10:49 - i'm not going to save that the play
10:50 - scene itself i'm going to go from 2d
10:52 - back to 3d here is pretty much empty so
10:55 - we have a first person controller here
10:57 - this is the
10:58 - fps controller object
11:00 - does anybody
11:02 - anybody tell what basically constitutes
11:04 - an fps controller just by looking at the
11:06 - scene here
11:08 - what are the some of the pieces that
11:09 - jump out at you
11:14 - i thought you just put the camera right
11:16 - where the player is or right in front of
11:18 - the player exactly but the camera right
11:20 - where the player is effectively where
11:21 - their head should be relative to where
11:23 - their body is and their body what's
11:26 - constituting their body here can you
11:27 - tell
11:30 - it could just be uh it looks like a cube
11:32 - in the middle there it's this it's
11:33 - actually this capsule right here i don't
11:35 - know if you can see it
11:36 - uh there's this capsule here this green
11:39 - capsule it's a little bit more organic
11:41 - feeling than a cube necessarily but you
11:43 - could use a cube as well
11:45 - but a capsule is how
11:47 - uh character controllers in unity are
11:49 - represented
11:50 - and character controllers sort of come
11:53 - for free in unity which is really nice
11:54 - they're part of the standard assets so
11:57 - if you go to import package in unity if
11:58 - you're going to assets import package
12:01 - there's a lot of packages that come for
12:02 - free that sort of bootstrap you
12:04 - notice there's like 2d packages cameras
12:06 - characters
12:08 - the characters package has 3d characters
12:10 - uh are third-person characters
12:12 - first-person characters some that are
12:14 - physics-based some that are not
12:15 - physics-based this particular controller
12:18 - is not physics-based meaning that we
12:20 - don't apply forces to it we move it
12:22 - around it's kinematic
12:24 - it can't it is affected by gravity so in
12:26 - a sense it kind of is physics based but
12:28 - it's not strictly physics based like a
12:30 - rigid body and a rigid body would and
12:32 - the collisions that occur between this
12:34 - and another rigid body aren't the same
12:35 - as they would be if we were to make this
12:37 - a purely rigid body based character
12:39 - controller there is a purely rigid body
12:42 - based character controller that you can
12:43 - import i haven't experimented with it a
12:45 - lot but you could probably figure out a
12:47 - good use for that in terms of a game or
12:48 - maybe you want to move precisely on
12:51 - surfaces that have different materials
12:53 - like icy surfaces or whatnot and have it
12:55 - apply it in a very physically realistic
12:57 - way
13:00 - another few things that we have here in
13:01 - our
13:03 - play scene we have a dungeon generator
13:05 - object so this dungeon generator object
13:07 - is just an empty object with a level
13:08 - generator script here
13:10 - and then we have a few other objects a
13:12 - floor parent a wall's parent and a
13:14 - whisper source so we'll get into the
13:16 - details of what all of those mean
13:19 - our goal today we'll be talking about a
13:20 - few things so we'll be talking about
13:22 - here's a picture of just our maze so we
13:24 - talked about some of those things at a
13:25 - high level we'll actually explore how to
13:27 - implement them in unity today so making
13:30 - a maze making the fog effect walking
13:32 - through it with our character controller
13:35 - we want to be able to have some kind of
13:36 - game play here so we have collectibles
13:38 - in the form of this red coin it's
13:40 - actually part of another standard assets
13:42 - pack they prototype assets pack it comes
13:44 - with a prototype little coin object that
13:46 - you can throw in anybody notice anything
13:49 - about this uh coin beyond the fact that
13:51 - it's uh
13:53 - you know just a sort of red coin
13:55 - what else do you notice about this scene
13:57 - here
13:59 - it's emitting a glow any ideas as to how
14:00 - it's emitting a glow
14:05 - it's a light source inside of it exactly
14:07 - so we'll talk about that we'll show you
14:08 - how that's implemented very easy to do
14:10 - in unity and then we'll also talk about
14:12 - towards the end our 2d scene our title
14:16 - scene and how to construct it which is
14:18 - actually very easy in unity as opposed
14:20 - to doing something by code you very
14:22 - rarely actually for interfaces need to
14:24 - touch code at least in terms of how to
14:25 - lay them out in unity you can do
14:27 - everything very visually and with the
14:28 - mouse it's actually it's a it's a
14:31 - pleasure to make you interfaces if
14:33 - you're used to just making them in in
14:35 - code
14:36 - so texturing so last week or two weeks
14:39 - ago we did nothing with textures it was
14:41 - well that's not true we had one texture
14:43 - on the background which was the
14:46 - sort of scrolling background but we
14:47 - didn't really look at that too much
14:49 - in today's example you know the
14:51 - helicopter and the coin and the um
14:54 - the buildings and all that stuff those
14:56 - were all just polygons with flat colors
14:59 - associated with them
15:01 - today we'll be talking about how to
15:02 - actually texture things with materials
15:04 - and so this is very easy to do in unity
15:07 - so i'm going to go over to a
15:09 - to my title scene here just because it's
15:11 - fairly it's it's lit in a fairly normal
15:13 - way as opposed to the play scene which
15:15 - is not lit in a normal way because we're
15:16 - using
15:17 - environment lighting we don't have a sky
15:19 - box
15:20 - the title scene has a fairly normal
15:22 - light a lighting setup so if i add a
15:26 - cube here to the scene
15:29 - so you can see right off the bat by
15:30 - default we do get a material here
15:33 - which has an al what's called an albedo
15:35 - component albedo just means like what's
15:37 - its surface color look like
15:39 - it has a much more technical definition
15:43 - and you can look up on wikipedia what
15:44 - albedo means it has something to do with
15:46 - the way that light interacts with
15:47 - surfaces
15:49 - there's a lot of other elements here you
15:51 - can make something look metallic
15:52 - you can make it look smooth or rough and
15:54 - you can also add normal maps height maps
15:56 - and a few other things which gives it
15:58 - more of like a bumpy texture and so
16:00 - forth and you can also make things emit
16:03 - uh light this way which the coin
16:06 - actually not only emits light but also
16:07 - is a light source so it does both
16:09 - [Music]
16:11 - and there's a few other things here for
16:13 - example let's say you have a very large
16:15 - cube and a small texture
16:18 - if you put a very small texture on a
16:20 - large cube what's it going to look like
16:26 - what's your instinct if we have a very
16:28 - large cube at a very let's say we have a
16:29 - 64 by 64 pixel texture but our cube is
16:32 - humongous
16:34 - what's that what effect is that going to
16:35 - have on the cube
16:39 - it's going to look kind of like an n64
16:41 - cube right it's going to what basically
16:43 - happens it's going to interpolate
16:45 - between the texture pixels the texels
16:47 - when you apply a texture to your cube
16:50 - and so when you apply a small texture to
16:52 - a large surface it's going to look
16:53 - stretched
16:54 - it's going to be it's going to look
16:56 - stretched and like
16:57 - it's going to look also filtered as it
16:59 - like you sort of see in some youtube
17:01 - videos if you watch them and they
17:02 - recorded a very small resolution but you
17:04 - blow them up they look filtered or if
17:06 - you've ever stretched a picture in the
17:07 - right software and it's looked it looks
17:10 - interpolated and filtered it's going to
17:11 - have that look
17:13 - so you can do is you can apply tiling so
17:15 - here we can see there's a tiling element
17:18 - x and y so
17:20 - of 1 in the x and y direction because it
17:22 - only applies on a flat surface
17:25 - so
17:26 - the
17:27 - effect of tiling would be such that if
17:29 - you have a 64 by 64 texture you could
17:32 - just tile that texture several times to
17:34 - get the desired look that you want on
17:36 - whatever surface that you're trying to
17:37 - look at in your game world maybe it's a
17:38 - very small object but maybe it's a very
17:40 - large object that you're looking at as a
17:42 - character and you want to tile bricks
17:44 - for example or you know stone
17:46 - so
17:47 - to apply a texture to a
17:52 - to a
17:54 - 3d object in the scene
17:56 - i'm going to go into here so you need a
17:58 - material first
18:00 - and so these are all unity material
18:01 - objects you can tell because they have a
18:03 - circular they look like if they've been
18:05 - wrapped around a sphere
18:07 - these are all unity materials as opposed
18:08 - to textures textures are just 2d objects
18:10 - 2d you know textures 2d images
18:13 - so this is part of a an asset pack that
18:15 - i downloaded for this
18:17 - lecture called dungeon modules low poly
18:19 - dungeon modules which is in the asset
18:21 - store
18:23 - and so what i'm going to do is i'm just
18:24 - going to apply let's say i want to just
18:26 - apply this rock material to this object
18:28 - right and i go over to that
18:30 - i'm going to first
18:32 - add a i think because i went into the
18:35 - material uh
18:37 - had a
18:38 - incorrect appearance
18:40 - so
18:41 - do that oh that's strange
18:44 - i'm going to create a new scene
18:48 - and then i'm going to add a
18:50 - cube
18:52 - and then a
18:53 - not pop but maybe the beam
18:57 - i wonder why it is not
19:00 - that's very strange for some reason it
19:02 - might be a setting that i have enabled
19:03 - that's not allowing it to
19:06 - correctly render
19:08 - but the effect of that should be that we
19:10 - apply normally if you apply a um
19:14 - uh
19:16 - a texture to a material it'll have the
19:19 - effect of
19:21 - creating it'll instantly texture it but
19:23 - what i can do is i can go to textures
19:24 - here and this should work too i can go
19:26 - to that and then it'll apply it that way
19:29 - so
19:30 - normally if you're in a fresh project
19:32 - and you add a new 3d object and you just
19:34 - click and drag a material onto a 3d
19:36 - object it will texture it for you in
19:38 - this case i think because it's
19:40 - automatically assigning a material to
19:41 - these objects
19:43 - based on some project setting that i'm
19:44 - off
19:45 - off the cuff just unable to
19:48 - i don't know for sure you can instead
19:51 - just go to the albedo component here so
19:53 - albedo functions not only as a color but
19:55 - also as a texture for your object and so
19:58 - you can apply a texture just a 2d image
20:00 - to your albedo component of a material
20:02 - right and that'll have the same effect
20:04 - as texturing it
20:05 - [Music]
20:07 - immediately so normally what this is
20:08 - supposed to do is
20:10 - create a
20:12 - albedo create a new material with that
20:14 - texture as the albedo when you set a
20:16 - material to the
20:19 - 3d object
20:20 - now i wonder if i
20:24 - yeah i'm not sure i'm not sure exactly
20:26 - why uh it didn't work as uh like right
20:28 - off the bat like it's normally supposed
20:30 - to in a fresh project it will i'll try
20:32 - to investigate but if it ever happens
20:34 - like that where for some reason you're i
20:36 - think it has to do with the way the
20:37 - shaders are set on here maybe there's a
20:39 - setting i'm just not
20:40 - sure about but you can
20:43 - just set the albedo
20:45 - component here manually and it'll have
20:47 - the same effect
20:48 - so the albedo component of your material
20:51 - setting that with a texture textures
20:53 - objects
20:54 - and so that's effectively how we get
20:55 - from
20:57 - this sort of
20:58 - look of a flat shaded
21:00 - or flat color shaded object to a texture
21:03 - shaded object just like that
21:06 - and
21:07 - texture mapping
21:09 - sort of in itself is a very wide field
21:12 - and fairly complicated but
21:16 - ultimately it looks something like this
21:18 - so does anybody can anybody tell me what
21:20 - this looks like
21:21 - here
21:23 - so we see here obviously we have a fully
21:27 - textured model
21:28 - but if we're looking at this
21:32 - what does it look like we've done here
21:38 - so what does it look like ignore all the
21:39 - lines but what does it sort of look like
21:41 - we have on this surface
21:46 - it's just a texture right
21:48 - we can see whoops we can sort of see the
21:50 - colors here for example maybe the his
21:53 - belt here or or actually that looks like
21:55 - the top of his head here this being the
21:57 - top of his head and then we have like
21:58 - his belt and other things
22:01 - this right here we can pretty clearly
22:02 - see that's like sort of his face mask
22:04 - right but it's just on a 2d surface like
22:06 - this is a just a regular texture and so
22:08 - what we've done here
22:11 - is basically taking all of the
22:14 - polygons that comprise the model and
22:16 - sort of laid them out flat
22:18 - right
22:19 - lay them out flat as if on a table where
22:21 - our texture is
22:23 - and that's what uv mapping is
22:25 - and this is usually something that you
22:27 - do in whatever 3d modeling software that
22:29 - you're using
22:31 - in unity
22:32 - when you apply a texture to a material
22:35 - or a material with a texture to an
22:37 - object it will use its standard um it
22:41 - has its own built-in like mapping
22:43 - algorithm that'll apply material to a
22:46 - model and so it does it differently for
22:48 - different objects we can we can create a
22:51 - like a sphere for example move the
22:53 - sphere over here
22:55 - and i'm going to try again and just to
22:56 - see if the uh
22:58 - applying the material works
23:01 - on that no it doesn't so applying a so
23:04 - if you go into this
23:08 - material here
23:10 - which is
23:12 - for some reason grayed out
23:15 - um
23:16 - new scene again
23:18 - create a new 3d
23:20 - sphere
23:22 - and then
23:32 - oh this time it looks like it's i can't
23:34 - tell no i don't think that's working
23:36 - um
23:38 - oh now it's now it allows us to accept a
23:40 - texture okay so we can apply a texture
23:43 - whoops we apply a texture to that and so
23:46 - now we can see our
23:48 - sphere has been mapped as well and it
23:50 - looks fairly convincing it's been
23:51 - wrapped around it in a way that doesn't
23:53 - look too distorted or too weird and so
23:55 - unity has its own ways of
23:57 - mapping for its primitive objects
24:01 - whether it's spheres cubes we have a few
24:03 - other ones capsule cylinders planes
24:06 - and it'll depend obviously on where your
24:07 - texture is if your texture is fairly
24:09 - ornate it might end up looking distorted
24:12 - but for most purposes
24:15 - for simple primitive objects for most
24:17 - textures it should work pretty well now
24:19 - if you imported a model that was like a
24:22 - table or character
24:24 - and you just applied a
24:26 - texture to it it's not going to look
24:29 - good it's going to look messed up
24:31 - and so your 3d software will export a
24:33 - material with the model assuming that
24:36 - you've modeled
24:37 - in that software with a texture it'll
24:40 - actually give you a material that you
24:41 - can
24:42 - then reference that will properly apply
24:44 - a texture to your character but the same
24:48 - sort of apply a texture just a regular
24:50 - texture to a complicated model just
24:52 - isn't going to work because it hasn't
24:53 - been uv mapped in a smart way unity's
24:56 - not going to know i have a table i want
24:57 - to map
24:59 - i want to map the texture to
25:01 - the table in a you know in a way that
25:03 - looks convincing you can see this kind
25:05 - of if we create a
25:07 - cube
25:09 - and then
25:11 - if we go ahead and
25:15 - i've been making it apparent for some
25:17 - reason uh if we go up here i'm gonna
25:20 - first assign
25:22 - uh okay for some reason that worked
25:24 - instantly um but you can see we've
25:26 - applied a sort of wall texture to it and
25:29 - then if we
25:30 - scale it down so this is the scale
25:33 - button up here so we have um you can
25:35 - move rotate things if unfamiliar the uh
25:38 - sort of these top buttons up here are
25:40 - transform operators so you can move
25:43 - things scale or rotate things and scale
25:45 - things so if you scale
25:47 - this along the you know this
25:50 - y-axis a bit and then you zoom in
25:53 - the texture looks pretty compressed and
25:55 - distorted
25:56 - because it's just doing the same
25:58 - algorithm and assuming it's the same
25:59 - kind of surface without taking into
26:01 - consideration how it's been warped right
26:04 - so
26:05 - ideally you wouldn't have the sort of
26:06 - like flattening thing this this
26:08 - flattening happening and so in your 3d
26:10 - software you would unwrap your model and
26:13 - then um apply a texture to each separate
26:17 - polygon of your model in a way that
26:20 - looks convincing
26:22 - and so this isn't anything that you
26:23 - necessarily have to do um for the
26:26 - lectures for the demonstration for your
26:28 - project but if you are creating your own
26:31 - 3d assets if you're importing 3d assets
26:33 - and if you want to use textures
26:35 - in a way that we're doing today you will
26:37 - need to
26:39 - probably become familiar with uv
26:41 - wrapping uv unwrapping uv mapping in
26:43 - whatever software that you're using and
26:45 - if you're just unfamiliar with it in
26:46 - general and have wanted to know sort of
26:48 - what goes on in
26:50 - turning a you know flat white polygon
26:53 - character into something that has a
26:54 - texture this is effectively what happens
26:57 - you unwrap it make it flat sort of like
27:00 - stamp the material onto it effectively
27:03 - and that be they know that maps the
27:06 - uvs of the texture sort of the textures
27:08 - virtual coordinates to
27:10 - your
27:11 - 3d model so any questions as to how this
27:14 - works at all
27:17 - or about unity and um applying textures
27:22 - what's the general way that you uh
27:25 - you make the
27:27 - the textures on the right where it's
27:28 - kind of like
27:30 - you know it's like a world that's been
27:31 - flattened how do you make the textures
27:33 - on the right that i mean that's kind of
27:35 - an art form in itself you you do have to
27:37 - do it by hand
27:38 - um
27:40 - and sort of know
27:42 - i mean there's a good amount of trial
27:44 - and error that'll go into it too as
27:45 - you're making your model and sort of
27:47 - unwrapping it and noticing oh this looks
27:49 - weird as i'm
27:51 - applying this polygon to the surface i'm
27:53 - gonna go and change that texture but you
27:55 - could use any you could use or
27:56 - photoshop or any standard
27:59 - texture creation software and kind of
28:01 - just
28:02 - um it's something i don't do a lot of it
28:04 - but it's something that i imagine that
28:05 - you just get better at with time and
28:07 - artists texture artists and modeling
28:09 - artists probably
28:10 - have developed sort of like an attuned
28:12 - sense of
28:13 - what makes a good texture versus what
28:15 - doesn't
28:17 - generally you'll make the model
28:20 - first
28:21 - and then you'll make the texture
28:24 - so
28:27 - okay so we already talked a little bit
28:29 - about models uh sorry about materials um
28:32 - we'll we'll go back over it really
28:33 - briefly again there uh there is a
28:37 - resource that i really like and i think
28:39 - does a really wonderful job of teaching
28:41 - beyond far beyond the basics of unity
28:43 - and that's catlitecoding.com and it's
28:46 - totally free they just have a bunch of
28:48 - free articles on there which are very
28:50 - in-depth
28:51 - and this is a screenshot taken from one
28:54 - of the articles where they talk about
28:56 - how to make really interesting materials
28:58 - so you can see here this one on the left
29:00 - it looks very you know it looks like a
29:02 - fireball like it's made out of magma
29:05 - and it's got bumps on it it has contour
29:07 - you can see that there's sort of like a
29:09 - glow to the fire on it on the right you
29:12 - can see that this model has um sort of
29:14 - conditional shine on certain parts of it
29:16 - like the metal part of it is shiny but
29:18 - the rest of it isn't and so like how do
29:20 - we make certain parts of the material
29:22 - shiny how do we make certain parts of it
29:23 - flat
29:24 - the article goes into depth on that and
29:26 - effectively what they do is they use
29:28 - several layers of maps like a shininess
29:30 - map which is a texture
29:33 - that
29:34 - tells
29:35 - that you reference in a unity custom
29:38 - shader that you write which the article
29:40 - teaches you how to write which will make
29:42 - certain parts of the texture glossy and
29:45 - certain parts of it not glossy so matte
29:48 - and so you can do a lot of really cool
29:50 - very interesting things and unity's
29:51 - shading system is very um sort of the
29:54 - sky is the limit i mean because it's
29:56 - effectively a standard shader
29:58 - language like you would it's effectively
29:59 - the same thing as hlsl i believe which
30:02 - is high level shading language which is
30:04 - a if i'm not
30:07 - uh microsoft originally came up with it
30:09 - and it's very similar to glsl which is
30:12 - the opengl shading language um and so
30:14 - what these are effectively is just
30:16 - little programs that run on your
30:17 - graphics card we talked about this
30:18 - before
30:19 - but they tell your scene how to process
30:22 - lighting for the objects that are within
30:25 - it and everything in unity has a shader
30:27 - associated with it even if it's just the
30:29 - standard shader which by default is just
30:30 - a white color
30:32 - but you can write your own shaders and
30:34 - you're capable of virtually unlimited
30:36 - possibility and
30:39 - the
30:40 - this effectively is all a shader and
30:43 - it's all a shader that's been written in
30:46 - code but we have a lot of these
30:49 - variables that are exposed to us and
30:51 - albedo is one of them and albedo is sort
30:54 - of conditional if it if it gets a
30:56 - texture applied to it it will just
30:59 - render that texture but if you apply
31:01 - color to it it will apply that color to
31:04 - your material and so that's how you can
31:05 - get you know textured things versus
31:07 - non-textured things metallic just
31:09 - computes
31:11 - shininess and reflectivity off of
31:13 - surfaces and that's just something
31:14 - that's written into the shader and
31:16 - produces the lighting
31:17 - responsible to make that happen and all
31:19 - of these different things are just part
31:20 - of a single shader and a material is
31:23 - effectively a shader they're kind of one
31:26 - in the same a material is a little bit
31:27 - different in that you can also specify
31:30 - how its surface should interact with
31:31 - other things so for example
31:33 - if you're in an ice level a material can
31:35 - not only be
31:37 - like the glo the sort of glossy icy look
31:39 - of something but also how slippery is it
31:42 - when i walk over it and should i slide
31:43 - and how should other things interact
31:45 - with it that have physics
31:47 - so like those two sort of hand in hand
31:49 - are sort of what a material is
31:51 - but
31:52 - um
31:54 - likely as you're starting out the only
31:55 - real things that you'll need to consider
31:58 - and you're sort of bound only by your
31:59 - curiosity are albedo and maybe metallic
32:02 - and maybe emission and then depending on
32:05 - how much you how big your thing is and
32:07 - how small your texture is maybe tiling
32:10 - and then recall last week we manipulated
32:12 - offset so offset is how much the texture
32:15 - is shifted and recall it loops around
32:17 - back to the other side
32:19 - and so by manipulating offset on the
32:20 - x-axis we were able to get a scrolling
32:24 - infinitely scrolling texture right
32:27 - and so all these things have their uses
32:30 - and pretty much everything in unity has
32:32 - its uses it's a very vast tool kit to
32:34 - use
32:35 - but those are probably the important
32:36 - things that you'll see and this article
32:38 - and many others on this website which i
32:40 - highly recommend if you're looking to
32:41 - get really deep into unity
32:43 - will give you a lot of insight into how
32:45 - things work far beyond just the
32:47 - surface level there
32:49 - so any questions on materials
32:54 - all right
32:55 - so we're going to take a look now at
32:56 - lighting so materials materials are one
32:59 - part of the equation so that's sort of
33:01 - defines how things should look when
33:03 - light hits them but we also need light
33:05 - itself in our scene to illuminate things
33:08 - and so this is taken from another
33:09 - article on cat like coding on rendering
33:12 - and so this is a scene with a lot of
33:14 - lights a lot of glowing lights emissive
33:16 - lights and there's a lot more going on
33:18 - here
33:19 - but
33:20 - this is a another great series of
33:22 - articles on how to understand the
33:24 - lighting model in unity
33:25 - and it teaches you a lot it teaches you
33:28 - almost you know down to the very bare
33:31 - ingredients of the sort of the software
33:32 - and the rendering if you want to go that
33:34 - deep i certainly haven't gone through
33:36 - every article because there's just a
33:37 - tremendous amount of content it's very
33:38 - deep but if you're looking to really um
33:41 - if you're looking to really get a sense
33:43 - of how it works i would i would
33:44 - encourage you to explore that
33:46 - so we'll look at a few different types
33:48 - of lighting beyond the more complicated
33:50 - things that this article talks about
33:52 - we'll look at the different styles of
33:53 - lights which
33:55 - you'll probably use
33:56 - more often as you're starting out
33:58 - so
33:59 - point lights anybody have an idea as to
34:01 - what a point light might be based on
34:02 - this picture
34:08 - uh it's not pointing in a very specific
34:10 - direction that's actually a spotlight
34:13 - so a point light
34:15 - is a set a source of light that actually
34:18 - uh shoots out in all directions around
34:20 - it so it emits light in all directions
34:22 - but within a confined area at a specific
34:25 - intensity
34:26 - a spotlight shines light in a specific
34:29 - direction so only one direction and
34:31 - what's interesting about spotlights is
34:32 - you can actually apply what's called a
34:34 - cookie to them and what a cookie does
34:37 - very similar to what the bat like the
34:39 - batman light does it allows you to apply
34:41 - a texture to a light and therefore cast
34:44 - shadows specific shadows on the light so
34:47 - if you wanted to make like something
34:48 - like the bat signal you could put the
34:50 - bat
34:51 - man icon cookie on your spotlight and
34:53 - it'll shine the light but the bat uh the
34:55 - batman logo will be in the middle of it
34:57 - it's effectively the same thing as
34:59 - taking a literal spotlight and putting a
35:01 - object onto it
35:03 - it produces a shadow a manual shadow
35:05 - it's called a cookie yep
35:08 - um
35:09 - a directional light so anybody
35:12 - know what a directional light is
35:13 - so despite its name it's actually not
35:16 - not the same thing as a spotlight
35:22 - so directional light we used a
35:24 - directional light last week actually
35:26 - last lecture directional light casts
35:28 - light in a single direction but
35:31 - throughout the entire scene as if it's
35:33 - the sun
35:34 - so this allows us to illuminate globally
35:36 - the entire scene but all light gets cast
35:39 - from one direction
35:41 - so if you want to produce the appearance
35:43 - of daylight in your scene just a single
35:45 - directional light will illuminate
35:46 - everything
35:48 - and then the last thing
35:50 - which is used less
35:52 - is called an area light so does anybody
35:54 - know can anybody guess what area light
35:56 - is based on this picture here
36:03 - yes so it's light that's only on the
36:06 - surface
36:07 - light that's only on the surface
36:09 - kind of yes so it's light that will emit
36:12 - from the surface of a
36:15 - specifically designated
36:17 - uh
36:18 - rectangle effectively in one direction
36:20 - so you can define a large area
36:24 - for example maybe like maybe you want
36:25 - like a wall strip in your game or
36:27 - something along the wall to emit light
36:30 - specifically uh to the left or something
36:32 - like that
36:33 - that's what an area light is capable of
36:35 - now
36:36 - area lights are computationally
36:37 - expensive and so you can only use them
36:40 - when you bake your lighting does anybody
36:42 - remember what baking means when
36:43 - referring to lighting
36:47 - so baked lighting just means that
36:49 - instead of
36:50 - real-time lighting calculating things
36:52 - dynamically the light gets calculated
36:55 - one time and saved and almost like
36:58 - freezed onto all of the objects in the
37:00 - scene
37:01 - and so there are pros and cons to this
37:02 - what's a pro to baked lighting do we
37:07 - that's think computationally intensive
37:09 - less computationally intensive what's a
37:11 - downside to
37:12 - baked lighting
37:15 - it can be dynamically affected
37:18 - can be dynamically affected so if you're
37:20 - walking through a baked lighting scene
37:22 - and you're expecting to cast a shadow on
37:24 - something or for something to cast a
37:25 - shadow onto you it's not going to happen
37:27 - because the environment's already been
37:29 - pre the lighting for that scene's been
37:30 - pre-baked it's almost as if we've just
37:32 - recolored the world in a specific way
37:35 - but we're not actually doing any
37:36 - lighting calculations but this is how
37:38 - lighting worked in like the n64 era and
37:41 - it's how it still works now for certain
37:43 - situations if you know nothing's going
37:44 - to cast a shadow on something you can
37:47 - make really nice looking lighting for a
37:49 - scene without
37:51 - needing to do it in real time you can
37:53 - just bake it right
37:55 - so those are the different types of
37:56 - lights so we can see that in unity so if
37:59 - we go here
38:01 - i'm going to
38:03 - so right now we have a directional light
38:05 - so this directional light is this object
38:07 - here by default all um and you can zoom
38:10 - in as much as you want but it's sort of
38:11 - like um oh there we go
38:16 - this directional light is
38:18 - only shining in one direction
38:21 - so i can move it here so currently i'm
38:22 - in
38:24 - um
38:25 - it's a little bit weird to navigate just
38:27 - because it's been rotated a little bit
38:29 - given that it's a directional light it's
38:30 - rotation
38:34 - so notice how it changes so if i shine
38:36 - it upwards notice that everything comes
38:38 - black because the lighting is just
38:40 - shining upwards right so as if it's
38:41 - coming from below
38:43 - and if i shine it towards there notice
38:45 - that the the lighting on the the sphere
38:47 - and the
38:49 - little cube there sort of change a bit
38:50 - right because they're
38:52 - getting affected by the direction of the
38:54 - light a little bit but they both get
38:55 - affected the exact same because the
38:57 - directional light is omnipresent it's
38:59 - throughout the entire scene it's a
39:00 - global object
39:02 - now if i delete the directional light
39:05 - notice we have no light now so these
39:06 - things just look kind of like statically
39:08 - shaded
39:10 - you can add a new light through
39:12 - if you right click in your sort of game
39:14 - object view and then you go over here
39:15 - you can see we have all the different
39:16 - lights we talked about there's also
39:18 - things called reflection probes and
39:19 - light probe groups and those are a
39:21 - little bit more complicated but those
39:22 - allow you to effectively get pseudo real
39:25 - time lighting and reflection with baked
39:28 - lighting and reflection
39:29 - we won't talk about those in today's
39:31 - lecture but here's a point light for
39:33 - example
39:34 - so
39:35 - let's see where is it that's right over
39:37 - here so i'm going to move it over here
39:40 - so you can see it's not global like the
39:44 - um directional light was right it's just
39:46 - affecting this very limited and i'm
39:48 - going to zoom in a little bit so you can
39:49 - see a little bit better but it's
39:50 - affecting just sort of these two objects
39:53 - relative to where its position is right
39:57 - and so this works perfectly for things
39:58 - like lamps in your scene if you want to
40:00 - have a street light or whether you want
40:02 - to have maybe like a fire going on in a
40:04 - house or if you want the you know like
40:06 - the power up that we had in the uh or
40:08 - the pickup that we had in the uh unity
40:11 - scene right we have just the
40:14 - it's just emitting a purple light that
40:17 - um
40:18 - is within a very small radius
40:20 - notice here
40:22 - we can uh change the color of the light
40:25 - so if i make it like that
40:29 - for some reason oh
40:31 - there we go
40:34 - so we'll do that
40:36 - so notice now it's emitting a purple
40:38 - light so you can color a light however
40:40 - you want to produce whatever effects you
40:42 - want so fire is not going to emit white
40:44 - light it's probably going to emit like
40:45 - an orange red light
40:47 - street lights are probably going to emit
40:48 - kind of like a yellow orangey light
40:51 - so depending on what your scene looks
40:52 - like and what you're trying to emulate
40:54 - you can accomplish pretty much anything
40:56 - with just the you know these very simple
40:58 - objects so i'm going to get rid of the
41:00 - point light
41:02 - and then i'm going to create a spotlight
41:05 - i'm not going to create a area light
41:07 - just because we need to actually bake
41:08 - the lighting into the scene but i will
41:10 - create a spotlight just so we can see
41:11 - what it looks like
41:15 - get it in the right position
41:22 - sometimes it can be a little tough to uh
41:24 - figure out exactly where you are
41:27 - okay getting close
41:30 - there we go perfect
41:33 - so this little spotlight right here is
41:35 - being produced by our object so we can
41:37 - see we can move it around and then we
41:38 - can apply a cookie to it if we want to
41:40 - as well
41:41 - it's right here so in your if you're in
41:43 - a spotlight and you want to apply a
41:44 - texture to it just this little cookie
41:47 - and it just expects a texture so
41:49 - whatever whatever image you want and if
41:51 - you're creating a cookie texture
41:53 - white means full light and black means
41:56 - full shadow and so you can make it a
41:58 - grayscale image you can make it anywhere
42:00 - in between white and black
42:02 - which will allow you to produce some
42:03 - interesting effects the
42:05 - for example the manual in
42:07 - um
42:10 - it's not here it's not i didn't include
42:11 - the picture here but the manual shows
42:14 - like there are some kind of like the
42:15 - lights that you put on a stand and they
42:17 - have a bunch of leds right and they're
42:19 - sort of in a grid and they shoot out a
42:21 - spotlight you can create a cookie that's
42:23 - kind of a gray scale with those gridded
42:25 - lines and it'll shoot light onto the
42:27 - scene as if it's being broadcast from a
42:30 - sort of grid of leds
42:32 - so there's a lot you can do with just
42:34 - some very simple ideas
42:36 - those are the kinds of lighting that we
42:38 - can use and in today's lecture we only
42:41 - really use the point light and the last
42:43 - lecture we use the directional light
42:46 - and spotlights you can you could for
42:48 - example
42:50 - programmatically change for example the
42:52 - rotation of a spotlight if you want to
42:54 - have like a swinging spotlight in your
42:56 - scene to illuminate some wall or some
42:58 - surface there's a lot of cool things you
43:00 - could do with it
43:01 - so those are the core types of lights in
43:04 - unity does anybody have any questions as
43:05 - to how they're used or how they work
43:08 - for the directional light does it matter
43:10 - where it's placed or only the direction
43:12 - it's it does not matter so for the
43:13 - directional light it does not matter
43:14 - where it's placed you could place it
43:16 - anywhere in your scene zero zero or some
43:18 - far distance away you'll have the exact
43:19 - same effect on the entire scene
43:22 - yeah
43:22 - any more
43:24 - questions okay
43:26 - cool cool so those are lights um bump
43:29 - mapping talk about very briefly so bump
43:31 - mapping is we actually do use this in
43:33 - the game
43:34 - um
43:35 - the a bump map effectively is so what
43:38 - you see here on the left is a an actual
43:40 - 3d scene these are actual models being
43:43 - shaded in real time
43:45 - and on real-time but they're actually
43:46 - real models being illuminated in the
43:48 - middle we can see what's called a bump
43:50 - map
43:51 - and on the right we can see a just a
43:53 - flat
43:56 - like a flat plane
43:57 - with a bump map with that same bump map
43:59 - applied to it and then illuminated
44:02 - so
44:03 - what a bump map allows us to do is to
44:05 - take a flat wall or flat surface or
44:08 - whatever you want
44:10 - and then
44:11 - simulate
44:12 - like an actual three-dimensional contour
44:14 - three-dimensional bumps or whatever you
44:16 - want on that surface
44:18 - without needing to create the actual
44:20 - geometry to make it possible
44:22 - and so
44:23 - there are different tools that will
44:24 - allow you to create bump mapping
44:27 - objects are bump mapping textures often
44:29 - 3d packages will have these
44:31 - so you can create them
44:32 - or other software
44:34 - but they are effectively just the
44:37 - encoding of what are called surface
44:40 - normals
44:41 - so just a vector going from outside of
44:44 - the um
44:47 - outside of the polygon at that given
44:48 - point and they
44:51 - tell the lighting system in unity
44:53 - pretend as if
44:54 - there's actually
44:57 - geometry pointed in that direction when
44:59 - you calculate it and so even though it
45:01 - doesn't distort the geometry in a way
45:03 - that's like this is still completely
45:05 - flat the lighting
45:07 - thinks that the geometry is
45:10 - kind of
45:11 - you know contoured and so it allows us
45:13 - to create
45:15 - this is kind of a toy example but it's
45:17 - actually relevant in the in the case of
45:19 - walls that have and we covered this last
45:21 - week just not in as much detail but
45:24 - walls that you want to be flat and you
45:25 - don't want to have a lot of polygons for
45:27 - you can create a bump map for
45:28 - and apply that bump map and then when
45:30 - you're rendering it when you walk past a
45:32 - wall it's going to look as if the wall
45:33 - actually has cracks and bumps in it
45:36 - for a realistic effect and this is used
45:38 - in the game to slight degree and you can
45:40 - crank it up if you want to i didn't on
45:42 - my computer because my settings or my
45:43 - specs aren't sufficient but every
45:45 - texture in today's example has a bump
45:47 - map associated with it
45:49 - so you can actually see
45:52 - where what the um
45:56 - you can actually see the effect of bump
45:57 - mapping
45:58 - at various degrees of
46:00 - of use the materials here so i'm going
46:03 - to go i'm going to load up the
46:05 - scene
46:06 - that has the actual
46:09 - stuff
46:12 - i'm going to
46:15 - actually i don't need to load the scene
46:16 - all i need to do is go to the materials
46:18 - and the
46:19 - floor for example where's the floor
46:21 - right here
46:23 - so
46:24 - notice that before we talked about
46:25 - albedo and then i also mentioned normal
46:27 - map so right here all you really need to
46:29 - do in order to get unity to detect
46:31 - normal maps and this is just part of the
46:32 - standard shader normal maps and bump
46:34 - maps by the way are effectively
46:36 - synonymous
46:38 - you can just
46:39 - drag your
46:41 - normal map texture into this field here
46:43 - this little square and then give it a
46:45 - degree i wish to apply that normal map
46:47 - and so if you look at this
46:49 - here you might be able to see i don't
46:51 - recall yeah we can sort of see how it
46:53 - changes the texture right so
46:56 - at zero
46:59 - there's no normal mapping taking place
47:01 - at all that texture is just completely
47:03 - flat as if we had done just the regular
47:05 - apply texture to a sphere but the degree
47:08 - at which we apply normal mapping so
47:10 - notice at degree one it kind of looks
47:12 - pretty realistic as if we've got kind of
47:14 - a stony texture and the more we go
47:17 - right the more exaggerated it starts to
47:19 - look
47:20 - right
47:21 - and you can just keep doing that
47:24 - and it'll eventually just look really
47:25 - distorted but that allows you
47:28 - and depending on how strong your
47:29 - computer is you can go higher or lower
47:32 - to
47:34 - affect just how bumpy
47:36 - just how strong the bump map the normal
47:38 - map affects the lighting rendering
47:40 - so it's that easy to get just a
47:44 - fairly sort of extra sense of realism in
47:46 - your scene so you'll notice if you're
47:48 - walking through the scene if you turn
47:49 - off lighting it's even easier to see all
47:51 - of the surfaces the floors the ceilings
47:54 - and the walls have a bump map as well as
47:57 - a texture map
47:59 - so that's in case you're wondering what
48:01 - these weird colored textures are
48:03 - rgb or xyz for the
48:07 - surface normals and how and their
48:09 - permutations thereof and that's how it
48:10 - gets encoded into this and so often you
48:12 - can see if you're looking at a bump map
48:15 - and a texture map you can kind of see
48:17 - together like oh okay this makes sense
48:19 - the parts that i would expect to be
48:21 - bumpier do have
48:22 - a correlation to how they look on the
48:25 - actual bump map texture you can see it
48:27 - here everything that is bumpy or
48:29 - contoured is very visible in the bump
48:31 - map that's just by nature of
48:33 - the way the data is encoded so any
48:35 - questions as to how bump maps work or
48:37 - what they are or how to use them in
48:39 - unity
48:42 - all right cool so now we can start
48:44 - getting into a little bit more into how
48:47 - this all comes together in our maze
48:49 - on our game and we'll talk about maze
48:51 - generation
48:53 - so i'm going to
48:55 - just start up the uh game the scene here
48:58 - so i'm in the actual
49:01 - play scene so in scenes i loaded up play
49:03 - as before i'm going to hit play
49:06 - i'm going to turn off my sound just
49:08 - because the creepy sound is a little
49:09 - disorienting after a while
49:11 - um and then i'm going to
49:13 - [Music]
49:15 - oh and actually i'm going to go to a 2x3
49:18 - view
49:21 - and then hit play
49:24 - so we have
49:25 - the regular game view down here below
49:28 - and then also if i zoom out you can see
49:32 - that
49:32 - our scene was empty before but now we've
49:35 - got a maze and currently it's not very
49:37 - visible at all
49:38 - um
49:39 - because one we're playing fog
49:42 - right and recall fog allows us to
49:44 - effectively add color to objects that
49:46 - are farther away from us
49:48 - and two there's a ceiling on top of our
49:51 - um a roof on top of our maze so it's
49:54 - actually blocking out the actual what
49:55 - the maze looks like
49:57 - so we can fairly easily
49:59 - make a couple of changes here in order
50:01 - to see our maze a little bit better so
50:03 - i'm going to go to window i'm going to
50:04 - go to lighting settings and so if you go
50:07 - to window lighting settings those are
50:09 - your sort of global unity lighting
50:10 - settings right
50:12 - you can set your skybox you can set
50:14 - environment lighting you can set things
50:16 - like fog you can choose how things are
50:18 - baked there's a lot of things here
50:21 - we won't cover nearly all of them we
50:22 - will cover a few of them
50:24 - environment lighting is a big one that's
50:27 - actually how we're lighting the scene in
50:28 - this game so all the lighting that's not
50:31 - um
50:32 - well all the lighting is environment
50:34 - lighting uh that's how we're doing it
50:36 - we're doing it with color so notice that
50:37 - you can choose skybox gradient and color
50:40 - so if you choose
50:42 - skybox environment lighting it's going
50:44 - to have sort of like
50:45 - it's going to look kind of like this
50:46 - skybox that we have here right this sort
50:48 - of in the far distance looks blue kind
50:50 - of looks a little bit more natural but i
50:52 - didn't but it
50:53 - when it's applied to our scene it
50:54 - doesn't look uh quite the way we want it
50:56 - to look
50:58 - so we went instead was just color and i
51:00 - chose this sort of murky greenish
51:02 - brownish color and that gave the result
51:05 - that i was looking for but you can make
51:06 - this any color you want to we can make
51:08 - this some sort of bright yellow color i
51:11 - have no idea what this is going to look
51:12 - like this is probably going to look
51:12 - horrible but
51:15 - yep
51:16 - i mean actually this
51:17 - in a in a weird way this kind of looks
51:19 - interesting this actually looks closer
51:21 - to the original dread hall's game than
51:24 - what i did but it's not very scary kind
51:26 - of looks like we're in a pyramid
51:29 - um
51:30 - that is
51:31 - um am i able to go back no okay well i
51:35 - uh
51:37 - screwed up the color let me try and find
51:38 - kind of what color i had before it's
51:40 - kind of like a nasty green
51:43 - kind of like that it's probably good
51:46 - enough
51:47 - okay something like that and so we play
51:49 - it again we can see you know we're back
51:51 - to
51:51 - the nasty dark color
51:54 - but that's environment lighting so it
51:55 - applies a lighting uh uniform just
51:58 - ambience kind of like a directional
52:00 - light but it doesn't have a direction it
52:01 - just applies to everything in your scene
52:03 - at
52:04 - a given intensity
52:08 - and
52:10 - that that is how we are lighting our
52:11 - scene that's it's that's that easy just
52:13 - environment lighting in our scene on our
52:15 - lighting scene window
52:16 - now the other important thing here is
52:18 - the fog
52:20 - so fog is as easy almost as easy as just
52:23 - clicking this button here that says fog
52:25 - and then choosing a color for it
52:26 - probably you can choose the density so
52:28 - obviously if it's a higher density fog
52:30 - it's going to look as if you're in a
52:32 - foggier place like it's going to sum the
52:34 - color to things that are closer to you
52:36 - faster than it would if you had a lower
52:39 - density fog and there's some other
52:42 - features here
52:43 - some of which i'm not terribly familiar
52:44 - with but for the sake of today's example
52:46 - just the
52:47 - click make sure fog is selected and then
52:50 - click uh make sure you have the right
52:51 - color for your fog so if you have like a
52:53 - ridiculous red color for your fog it's
52:55 - probably gonna look
52:57 - weird
52:59 - yep but you can see how you could do all
53:01 - kinds of weird effects just by adding
53:03 - these things together like if you want
53:05 - to have the effect of being in some sort
53:06 - of like i don't know noxious
53:08 - foreign world maybe you want like a
53:10 - purple fog instead of like a
53:12 - dark green fog or whatever that's you
53:14 - know super easy you produce a lot of
53:16 - very basic but effective effects that
53:18 - way
53:19 - um i find i think it was just that kind
53:20 - of the same nasty green color
53:26 - so to bring up this lighting screen all
53:28 - you need to go do is if you're on a mac
53:29 - i think a window is the same thing
53:30 - there's a window option in the top menu
53:33 - window and then lighting here and then
53:36 - settings
53:37 - and so this will bring you to all of the
53:39 - settings that are pertinent to at least
53:41 - today's example
53:42 - and so we're not using any lights in our
53:44 - scene that we talked about before um at
53:47 - least for the lighting of the scene
53:49 - itself now there are there are point
53:52 - lights being used for the pickups and
53:54 - i'll show you that in a second
53:57 - but what i wanted to illustrate was how
53:59 - we can sort of look at our maze
54:01 - as
54:02 - after it's been generated and so what we
54:04 - need to do first notice that before we
54:06 - were kind of um
54:08 - we couldn't really see our maze at a
54:10 - distance it was just purely dark green
54:11 - because of the fog it was adding green
54:14 - to that um
54:16 - geometry because it was so far away so
54:18 - i'm going to disable fog for now it'll
54:20 - actually remember your settings which is
54:21 - kind of nice so just going to disable
54:23 - fog
54:25 - and
54:26 - i'm going to actually add a directional
54:29 - light to the scene so i'm going to go
54:31 - here add a directional light
54:33 - and then i'm going to hit play again
54:38 - so
54:39 - now
54:40 - our
54:40 - scene is
54:41 - lit
54:44 - and um
54:47 - you know it looks a lot different a lot
54:48 - less scary and we can see our maze a lot
54:51 - better we can actually see that it is a
54:53 - collection of
54:57 - blocks it's all it's tiled blocks now
55:00 - we can't see into the maze because the
55:01 - maze has a roof so what i did was i just
55:03 - made generate roof an option in the
55:05 - script and so if you unselect that and
55:07 - then we try again
55:10 - now we can see our maze
55:11 - so this is what our mazes look like and
55:13 - so the cool thing about unity which i
55:15 - really love is just this ability to look
55:17 - through your scene
55:18 - independent of the actual game just to
55:20 - like help debug like
55:22 - it's hard to know if you're generating
55:24 - your maze correctly um
55:26 - when you're creating it in 3d you know
55:27 - in 2d you can easily just look at it but
55:29 - in 3d if especially in a first person
55:32 - game you can't really see it so being
55:34 - able to split your view like this the
55:35 - scene and the game and actually see oh
55:37 - my algorithm is working or it's not
55:39 - working
55:41 - it's super helpful
55:42 - so we can see
55:44 - that
55:45 - it is carving a maze for us it looks a
55:47 - little bit weird it's not a
55:49 - traditional maze in the sense that it
55:51 - has the you know the classic maze shape
55:54 - to it but it effectively functions as a
55:56 - maze and it works very well for its
55:59 - intended purpose
56:01 - um and the algorithm is incredibly
56:03 - simple and we'll talk about that
56:05 - so that's our maze
56:07 - i'm going to go ahead and revert
56:09 - all of the
56:10 - i think if i just reload the scene it
56:11 - should just revert it
56:13 - don't save yep okay so everything's been
56:15 - reverted all the lighting everything
56:16 - just gonna do a sanity check and make
56:18 - sure
56:19 - yep everything works perfectly well
56:23 - so
56:25 - anybody have any ideas as to where to
56:27 - get started if we were to implement a 3d
56:29 - maze
56:32 - the way i did it once before is
56:34 - you uh
56:35 - you put a bunch of x x's where you want
56:38 - something to be drawn in an array
56:40 - and then you loop through the array and
56:42 - draw instantiate
56:44 - the uh
56:46 - the balls
56:47 - yes so um create an array populate it
56:50 - with
56:51 - x's where you want
56:53 - data wherever you want something to be
56:55 - instantiated and loop over and
56:56 - instantiate everything it's exactly how
56:58 - it works
56:59 - um
57:00 - now in terms of actually creating the
57:03 - maze
57:04 - do you have any ideas as to what
57:05 - how would you go about implementing a
57:08 - a simple maze generator and there are
57:11 - obviously very complicated maze
57:12 - generation algorithms so
57:14 - like nothing terribly fancy but just a
57:16 - simple
57:17 - how would you make a maze
57:19 - or it's random
57:33 - so
57:34 - starting with the idea that we have an
57:36 - array right it's going to be a 2d array
57:38 - because we have two axes upon which
57:40 - we're generating things here even though
57:42 - we're in a 3d
57:43 - environment we don't need a 3d array we
57:46 - just need a 2d array because if there is
57:48 - a positive value for wherever we want to
57:51 - generate a block in our 3d or
57:53 - 3d maze
57:54 - we just generate a column of blocks we
57:56 - don't need to worry about a third
57:58 - dimension right
57:59 - our maze isn't like taking into
58:01 - consideration like multiple levels at
58:04 - which point we would need to maybe
58:06 - consider three dimensions i mean even
58:07 - still you can still divide those into
58:09 - separate 2d arrays of mazes
58:14 - we just have an x and a y
58:16 - so
58:18 - how would we get started what would we
58:20 - start populating the array let's say we
58:21 - have an array it's just a bunch of zeros
58:23 - right
58:24 - what are we populating with the array
58:25 - after after we've initialized it
58:35 - so i'm thinking maybe you would kind of
58:37 - start off with
58:38 - um
58:39 - just full of walls and then
58:42 - add like um corridors maybe so start
58:45 - with a bunch of walls and then add
58:48 - quarters that's exactly what we do
58:50 - um
58:51 - the algorithm is actually pretty simple
58:54 - so i'll try and maybe draw a little bit
58:56 - just to see if it can illustrate how
58:57 - this works
59:04 - by making sure that every um
59:08 - thing that you change is orthogonal
59:10 - every block every step that you move is
59:12 - orthogonal that will that will ensure
59:14 - that you
59:16 - start at one point and another point and
59:17 - those points will always be accessible
59:20 - to one another just by virtue of how
59:21 - simple the algorithm is and the
59:23 - orthogonality of it so
59:25 - if we start with
59:27 - um walls so um one one one one one one
59:33 - one
59:34 - one these are all
59:36 - in the in the
59:37 - distro these are all booleans because we
59:39 - don't need we only need zeros and ones
59:41 - so we're just gonna use true and false
59:42 - we don't need to use integers for that
59:45 - so this is our starting maze here um and
59:48 - actually i'm going to add another
59:51 - dimension because or not another
59:53 - dimension but another
59:56 - size just because the
59:57 - the walls always need to stay to be
60:00 - there these these are basically
60:01 - untouchable
60:03 - i'm gonna try and draw
60:05 - that as best i can
60:08 - right
60:10 - so we effectively have this as our
60:12 - working area for creating a maze right
60:14 - because we want this to be we want walls
60:16 - no matter what because we don't want our
60:18 - person to be able to walk outside the
60:19 - maze or see the outside world ever we
60:21 - want them to be locked in
60:23 - so
60:24 - we have all of these
60:26 - ones here these trues effectively and so
60:30 - all we need to do is start like at some
60:32 - random position let's say this value
60:36 - um at 3 2 or well it's actually
60:39 - technically it's 2 3 because we go we
60:42 - index at y and then x in a 2d array so
60:44 - we go 2 3
60:46 - we go here
60:48 - and then
60:49 - we basically
60:51 - can move either
60:53 - left or you can move
60:54 - either left or right or up or down well
60:57 - we can't move both at the same time and
60:58 - why can't we move both at the same time
61:02 - let's say that we're let's say first of
61:03 - all let me say that we're let's say
61:04 - we're going to carve our way through the
61:06 - maze right
61:08 - so we're going to turn these ones into
61:10 - zeros
61:12 - but
61:14 - we can only move either we can only move
61:16 - orthogonally meaning
61:18 - left or right up or down we can't move
61:19 - diagonally so we can only
61:23 - let's say we have a an x move
61:27 - right
61:28 - and a y move
61:33 - and those can be set to but by default
61:35 - there's zero so we're basically saying
61:37 - where on this step of the generation
61:39 - are we going to move and actually
61:41 - technically it's direction because we're
61:43 - the way that we do it is via directions
61:47 - what's in front of you will have no wall
61:50 - and there'll be walls on either side of
61:51 - you except for where you came from
61:54 - yes so if you're here and they move down
61:57 - this is gonna be zero this is gonna be
61:58 - zero and so those points are linked
62:00 - right and then from there we're gonna
62:02 - move in in a given direction
62:05 - and so all of the let's say we move here
62:07 - all of those are going to be linked
62:10 - and so
62:11 - if we move here
62:13 - all of those are going to be linked just
62:14 - by virtue of the fact that we're moving
62:15 - orthogonally
62:17 - we will we can't create a maze that's
62:19 - unreachable
62:20 - because the way that um
62:22 - just by virtue of the fact that we're
62:23 - moving it now orthogonally now if we
62:25 - move diagonally if i were to move here
62:27 - right
62:29 - there's walls right here and then two
62:31 - spaces there that's not going to work
62:33 - because we can't access that we see it
62:35 - we're going to see a cube here and a
62:36 - cube here and we're going to see we
62:38 - won't be able to get move diagonally
62:40 - through walls right so that's why we
62:41 - need to ensure that we only move either
62:44 - in the x or y direction not both at
62:46 - once and so what the algorithm does is
62:50 - it randomly chooses should i move x or
62:52 - should i move y
62:53 - and should i move positive or negative
62:55 - so it'll do
62:57 - math.random equal you know
62:59 - two equals one effectively in the code
63:02 - it's random.value less than 0.5 because
63:05 - random.value in unity gives you 0 to 1
63:08 - as a float
63:10 - so you say
63:11 - if random.value less than 0.5
63:15 - which is a random chance between you
63:16 - know true and false effectively 50
63:18 - percent
63:20 - moving x or moving y and then
63:23 - same thing but should i move in the
63:25 - negative or positive direction right so
63:28 - if i'm here
63:29 - i'm thinking okay let's see x move or y
63:31 - move uh it's again it's going to be an x
63:33 - move so i'm going to move either left or
63:34 - right okay so am i going to move either
63:37 - negative one or one step one to the
63:39 - right or to the left right so if it's
63:42 - negative one and that's going to move to
63:44 - the left right
63:45 - and if it's positive 1 it's going to
63:46 - move to the right
63:48 - so i mean that's the essence of the
63:50 - algorithm just loop over a bunch of
63:52 - times whenever i move to another tile
63:56 - turn that into a zero so actually this
63:59 - becomes a zero uh
64:01 - change the color
64:04 - so this will become a zero right so
64:06 - that's now an empty space
64:10 - and in the code that instantly teleports
64:12 - the character to that space two so we
64:15 - know that our character is always going
64:16 - to be in an empty space because he gets
64:18 - placed in the first open space that gets
64:20 - generated in the maze
64:22 - and so let's say x move is equal to
64:26 - negative one on this iteration so let's
64:28 - say we're looping until we've cleared x
64:30 - blocks so i want to clear it let's say i
64:32 - want to clear five blocks so
64:34 - two clear
64:37 - equals five right that's how many blocks
64:40 - when we've cleared that many blocks
64:41 - we're done with the maze generator right
64:43 - so
64:44 - cleared one so our current counter is
64:47 - one
64:48 - so x we get flip a coin we're moving to
64:51 - the x direction
64:52 - by negative one
64:54 - so
64:55 - we move um two
64:58 - here
65:00 - and then we turn this into a zero
65:02 - now
65:03 - this
65:04 - implementation of the algorithm moves
65:06 - one step at a time and so because of its
65:09 - randomness what this ends up doing is it
65:12 - produces very large chunks of deformed
65:15 - space just because the crawler is just
65:16 - constantly moving around
65:18 - kind of like haphazardly so what's a
65:20 - refinement that we can make to this
65:21 - algorithm to make it look a little bit
65:23 - more like corridors or like hallways
65:27 - just keep going until you hit the outer
65:29 - wall
65:30 - you could do that yeah keep going until
65:31 - you hit the other wall um
65:34 - the result of that you mean hit the like
65:37 - the side of the maze
65:39 - yeah because well if you did that
65:41 - it would effectively just be like
65:44 - it would kind of be
65:45 - it might work in some cases but it will
65:47 - be very long hallways and not a lot of
65:50 - like turns or anything like that
65:52 - so the result what we actually want to
65:55 - do is when we flip a coin and we say x
65:58 - move or y move
66:00 - we want to also say
66:02 - times to move we want to create a new
66:04 - variable called number of times to move
66:06 - effectively right to move
66:11 - and then we just set that to a random
66:13 - number between
66:14 - one so we're going to move one tile or
66:17 - the
66:18 - size of the maze
66:20 - minus two
66:21 - right taking into consideration both
66:23 - walls right
66:24 - so
66:26 - let's say we get the
66:28 - let's say we let's say we did x move
66:30 - minus one and it and we only got two
66:34 - move equal to one right so we only move
66:36 - here we move once in this direction so
66:38 - we've got two spaces
66:39 - and then let's say we flip a coin again
66:41 - and then we got y move right
66:44 - positive one
66:46 - and then two move we got two
66:49 - right so we're going to move two
66:50 - directions
66:52 - in the y-axis by one so what this is a
66:55 - result of us going down here so we go
66:57 - zero
66:58 - and then zero
67:00 - right
67:01 - and so
67:03 - the effect of this
67:04 - is that
67:05 - we move
67:07 - um we can move in more than just uh one
67:10 - block at a time and avoid sort of random
67:13 - like haphazard weird organic large room
67:17 - aesthetic that we want if we want like a
67:19 - hallway
67:20 - grid-like dungeon looking
67:23 - like room generator right
67:26 - now there's a caveat to this and that is
67:29 - if we start here
67:31 - for example and then we want to
67:34 - uh let's say we flip a coin it's x move
67:36 - but it's positive like positive four
67:38 - right
67:39 - we can't obviously move
67:41 - four tiles to the right because one
67:43 - it'll go into our walls on the outside
67:45 - and two it's actually beyond the bounds
67:46 - of our array
67:48 - so we need to clamp that value down when
67:51 - we add one
67:53 - to our value
67:55 - to wherever our x we have to basically
67:57 - keep pointers right we keep pointer to
67:59 - whichever tile we're currently at
68:01 - we need to keep uh when we actually go
68:05 - to the next tile in our step
68:07 - we need to clamp that value within the
68:09 - range of our walls so we need to clamp
68:13 - between
68:14 - one
68:15 - so because we don't want to be at zero
68:18 - we want to clamp it between one and
68:20 - maize size minus
68:23 - minus two actually because we want to
68:25 - make sure that we don't go any farther
68:26 - than the this one here
68:30 - does that make sense this this is how
68:32 - that is effectively how our generator
68:33 - works it's a step beyond just the move
68:35 - one block at a time just because the
68:37 - mazes look way too
68:39 - empty and weird
68:41 - with this approach where you're moving
68:43 - in a direction
68:44 - and for a random number of tiles as
68:46 - opposed to just one tile at a time you
68:47 - actually get pretty nice looking simple
68:50 - mazes
68:51 - this isn't how like actual maze
68:53 - generation works um for mazes that you
68:55 - would see in like an actual maze that
68:56 - you do on like a crossword puzzle book
68:58 - or a maze book or something those are
69:00 - more complicated um
69:02 - but this solution works well it's very
69:06 - fast and very cheap
69:08 - and actually pretty simple to understand
69:10 - so any questions as to how the maze
69:12 - generator the algorithm at least is
69:13 - applied to our 2d array works
69:18 - all right
69:19 - cool that's the um
69:21 - that's basically the gist of it so we're
69:23 - gonna take a break here um for about
69:25 - five minutes and then as soon as we get
69:26 - back we'll dive a little bit more into
69:28 - um
69:30 - sort of how the character controller
69:31 - works and the pickup and a few other
69:33 - aspects of the game
69:35 - all right welcome back to lecture nine
69:37 - so before the break we were talking
69:39 - about uh the way that we implemented
69:41 - procedural maze generation so a fairly
69:43 - simple uh algorithm that creates this
69:46 - sort of hallway look where we can easily
69:48 - get lost but they aren't technically
69:50 - mazes in the traditional sense like you
69:52 - might have seen growing up in puzzle
69:55 - books and such
69:57 - another pitch for cat like coding
69:59 - because articles are amazing he has
70:01 - another one on how he did
70:04 - a maze generator and in this one beyond
70:06 - just regular blocks oh i'm sorry i
70:09 - didn't have the uh slider on the on the
70:11 - thing
70:12 - so this is a screenshot of another
70:15 - article from cali coding where
70:17 - he talks about how to make his own maze
70:19 - generator and the cool thing about his
70:21 - is that he has a bunch of different
70:22 - geometry involved in the scene it's not
70:24 - just blocks he has doors and windows and
70:26 - other things
70:27 - and his algorithm is a little bit
70:28 - different than mine and produces some
70:30 - pretty interesting looking things you
70:32 - can see here also it has a view of the
70:34 - scene
70:36 - sort of superimposed on the actual scene
70:39 - which he does with a trick using two
70:42 - cameras
70:44 - so
70:45 - also here's another um
70:47 - maze slash dungeon generator article
70:49 - that i really like where he creates sort
70:52 - of like dungeons and dragon style
70:53 - generators and this is sort of pertinent
70:54 - to my interests as a developer because i
70:56 - really love roguelikes and dungeon
70:58 - generators and rpgs but he goes into
71:01 - extensive detail on how to make a really
71:03 - nice and efficient
71:05 - 2d maze slash dungeon generator that
71:08 - produces really nice looking dungeons as
71:10 - you can see here it's got a very
71:12 - variable layout lots of corridors and
71:13 - rooms and stuff like that so
71:15 - implementing something like this in
71:16 - unity would be really cool and there's a
71:18 - plethora of generators and assets like
71:20 - this that'll do the same kind of thing
71:22 - in unity available in the asset store so
71:24 - you don't have to make this yourself
71:25 - most the time you can create you can
71:26 - just go find either free or paid assets
71:29 - that will do all this for you
71:31 - and save you a tremendous amount of time
71:33 - and much of them are also very
71:34 - customizable too so you can tailor the
71:37 - generator to fit the domain of your game
71:40 - so
71:41 - we saw how the lighting works in our
71:42 - game we've seen the
71:44 - maze sort of how it's generated
71:46 - what it looks like we have not taken a
71:49 - look yet at the character controller so
71:51 - we'll briefly just take a look at that
71:52 - it's actually incredibly easy to do in
71:54 - unity at least to get something fairly
71:56 - basic up and running
71:58 - the way that we get a fps controller in
72:01 - the case of our game
72:02 - is unity has which i alluded to before
72:05 - a set of custom or a built-in standard
72:08 - asset packs that allow people getting
72:11 - used to the game engine or i'm just
72:12 - trying to bootstrap their game
72:14 - up and running with some very basic
72:16 - components very basic things that are
72:18 - super helpful for um just to started
72:21 - getting your game running so actually we
72:22 - use the prototyping standard asset pack
72:24 - for our pickup we use the um
72:27 - characters one for the
72:30 - character controller the fps controller
72:34 - so if you if you're in a fresh project
72:36 - and just go to import package and you
72:37 - import this characters thing here it'll
72:39 - import it into your game so you can
72:41 - immediately use the prefabs that it
72:43 - gives you to create a character object
72:46 - so it'll by default just put it in your
72:48 - assets folder um underneath standard
72:50 - assets and then characters and then
72:52 - there's a first person folder and within
72:54 - the first person folder there's a
72:55 - prefabs folder with which has the fps
72:57 - controller game object and so all you
73:00 - need to do is just drag it into the
73:01 - scene and then that becomes your um
73:04 - default camera
73:06 - so
73:09 - it comes with it comes with unity
73:11 - correct that's just a standard asset
73:14 - uh it's always in the the fps controller
73:16 - will always be in the so you have to
73:18 - import it first you have to import the
73:21 - um the asset package the characters
73:23 - package once you've imported the
73:25 - characters package
73:26 - you'll go into standard assets in your
73:28 - assets folder there will be a new folder
73:30 - called standard assets within standard
73:32 - assets you'll go to characters then
73:35 - first person
73:36 - and then prefabs and that's where you'll
73:38 - find the fps controller
73:41 - yes no problem
73:42 - so the fps controller if we take a look
73:44 - at it we talked about it before briefly
73:47 - but effectively
73:48 - it's just a
73:50 - capsule collider
73:52 - which is sort of defying physics because
73:54 - it's kinematic
73:56 - kinematic with gravity applied to it
73:58 - and it has a camera sort of on towards
74:00 - the top of it where the head is to
74:02 - simulate the perspective of somebody
74:04 - from first person view
74:06 - and there's some programming involved
74:08 - that allows you to control it with the
74:09 - keys
74:10 - and the mouse to control the camera's
74:11 - rotation with the mouse and the position
74:14 - of the collider
74:15 - with the wasd
74:18 - keys
74:19 - and if you want you can dig into the
74:21 - actual script for it too they're all
74:22 - built included with the
74:25 - standard assets pack when you import
74:26 - that into your project it comes with all
74:28 - the scripts that make all that possible
74:30 - i haven't dug through all of them in too
74:32 - much detail but it's all there for you
74:34 - if curious as to how it works
74:37 - and so if you want to get just a simple
74:40 - you know fps controller in your game the
74:42 - character in your game to walk around
74:44 - and you know play a first person game
74:46 - it's takes about a minute to get up and
74:48 - running
74:49 - now there's a lot of customization that
74:51 - you can apply to your character
74:53 - controller to make it not just the
74:55 - standard basic
74:57 - character
74:58 - right
74:59 - so
75:00 - you can set a walk speed you can set a
75:01 - run speed
75:03 - you can set jump speed you can uh you
75:06 - know you can set the sensitivity of the
75:08 - mouse look on the uh
75:10 - on the game on the fps controller you
75:12 - can apply what's called fov kick which
75:14 - means when you're sprinting which it
75:17 - allows you to sprint by with pressing
75:18 - shift which multiplies your speed um
75:21 - it'll actually um uh
75:24 - i think it'll expand your depth of field
75:26 - a little bit to make it look as if
75:27 - you're kind of like claustrophobic right
75:30 - like things kind of like
75:31 - um go out and so it looks more narrow
75:33 - and it kind of gives you that look as if
75:35 - you're like sprinting down a path and
75:36 - you can set just how much it increases
75:38 - by you can set the curve of how that is
75:41 - applied here so this is one of the
75:42 - components that unity allows you to to
75:44 - do is there's a curve
75:46 - object and you can use this curve to
75:48 - influence
75:49 - various things in your game i actually
75:50 - haven't used it much myself but if
75:52 - you're looking for something to apply a
75:54 - curve to
75:56 - unity has an interface for making that
75:58 - visible within your inspector
76:01 - head bob which means when i walk should
76:03 - should the camera kind of like go up and
76:04 - down and
76:07 - when you do have a head bob like what's
76:08 - the curve look like so here's another
76:09 - curve this is the sort of what the head
76:12 - bob looks like kind of a sine wave but a
76:14 - little bit distorted
76:17 - and
76:18 - a few other things so for example
76:20 - footstep sounds maybe you don't like the
76:22 - sounds that come by default with the
76:23 - controller so you give it your own
76:24 - footsteps sounds super easy to do just
76:26 - drag new sounds here
76:28 - jump sound and a landing sound to more
76:31 - sounds that you can add to it
76:32 - and that'll allow you to customize most
76:35 - of the feel of how your character moves
76:36 - around
76:37 - in terms of just a basic fps
76:40 - controller
76:41 - and so just by applying those very basic
76:45 - things customizing a little bit we got
76:47 - lucky with this maze it
76:49 - just means that the maze went all the
76:50 - way around and then looped right back to
76:52 - where we were and ended there so this is
76:55 - that's that maze okay but um i'm gonna
76:58 - go ahead and turn up the sound
77:00 - you can hear the footsteps right
77:03 - along with the creepy whispering but the
77:05 - footsteps are just provided to us with
77:08 - us uh provided to us by the fps
77:11 - controller
77:12 - and again you can customize those to be
77:14 - whatever you want and so this gives you
77:16 - the ability to walk around in your scene
77:18 - from a first person view it doesn't
77:19 - really give you much more than that um
77:21 - in order to do like an fps where you
77:24 - have like maybe a gun or a weapon or
77:25 - something you need to program some more
77:27 - things and it's a lot more complicated
77:29 - but for just basic navigation of a 3d
77:32 - scene
77:32 - that's a great foundation a great way to
77:34 - way to get started so any questions as
77:37 - to how the fps controller works
77:41 - there are other controllers too there
77:43 - are third person controllers so if you
77:45 - want um
77:46 - to use those they don't come with a
77:48 - camera based on my experimentation they
77:50 - don't actually come with a camera by
77:51 - default so i think you have to parent a
77:53 - camera to them in the way that you want
77:55 - for your game like for example some
77:56 - games have the camera super high above
77:58 - your character while you're walking
77:59 - around and some of them have like a
78:03 - like behind the shoulder look almost
78:05 - like like fortnite or gears of war like
78:06 - really close to the character and then
78:08 - some kind of have like in banjo-kazooie
78:10 - you could be walking up a mountain and
78:11 - so the camera's kind of like
78:12 - perpendicular to where you are and sort
78:14 - of like follows you around so camera
78:16 - programming for 3d characters is a
78:18 - little bit more complicated than it is
78:19 - for first person games and so that's why
78:21 - i imagine it doesn't come with a camera
78:23 - by default so it can be a little bit
78:24 - more complicated but i do believe there
78:27 - are a lot of assets on the asset store
78:28 - that can help bootstrap you for getting
78:30 - a
78:31 - programmatic camera setup going for your
78:33 - character in a 3d third person view
78:38 - yeah when you're walking around your
78:39 - maze like occasionally you're like
78:41 - clipping the wall and kind of seeing
78:43 - like yeah
78:44 - yep uh that i believe that's the result
78:47 - of the collider being a little bit too
78:48 - big so what um what he said was that
78:51 - they walking through the maze you can
78:53 - kind of clip through the wall a little
78:55 - bit see if we can actually experience it
78:57 - yeah like right there
78:58 - uh
78:59 - yeah and that's the i believe that's
79:01 - just the the camera or the collar the
79:04 - collider being a little bit too large
79:06 - and so it's probably like get rid of
79:08 - that all together just by shrinking the
79:09 - collider a little bit
79:11 - um just a detail that i didn't iron out
79:13 - but
79:14 - you'll see that a lot of games actually
79:16 - a lot of games have like clipping that
79:18 - you can get
79:19 - that you can observe depending on how
79:21 - they've programmed the game
79:23 - um but yeah any other questions as to
79:26 - how
79:27 - character controllers are work and how
79:29 - the import process works and how to get
79:31 - it in your scene
79:34 - okay cool yeah it's super easy
79:37 - again here's what the fps control looks
79:39 - like capsule collider with a camera
79:42 - and then the third person controller by
79:43 - default they give you a pretty nice
79:44 - looking model on the left side there
79:46 - so that you can experiment with it and
79:48 - they apparently give you an ai one as
79:50 - well so you can test ai in your scene
79:51 - with it but i haven't experimented too
79:53 - much with that to
79:54 - vouch for how well it works
79:57 - so
79:58 - an important aspect of today's example
80:00 - is that we've gone from having just one
80:02 - scene to having two scenes so i wanted
80:04 - to illustrate how we sort of
80:07 - move between the scenes a little bit and
80:09 - also i realized we didn't really cover
80:11 - the dungeon generator
80:13 - in code detail but notice that i have
80:15 - exposed a lot of things here a floor
80:18 - prefab wall prefab ceiling prefab
80:21 - these are just the the cubes that are
80:22 - textured to be our floor walls and
80:23 - ceiling we can just click and drag them
80:25 - from the inspector into our scene onto
80:27 - the components there
80:28 - we have a character controller reference
80:30 - here so that we can place the character
80:33 - controller in our scene when we've
80:34 - generated the first block we can
80:37 - basically take the transform and
80:40 - set its position to whatever that xz is
80:43 - and then a floor parent and a wall's
80:45 - parent so the reason that we have parent
80:47 - objects actually which we didn't look at
80:49 - before oops i've lost track of where my
80:51 - there it is
80:52 - the reason that we have parent objects
80:54 - here is because when we instantiate all
80:57 - of the cubes in our scene just sort of
81:00 - you know just
81:01 - instantiate them without really thinking
81:03 - about it
81:04 - it ends up
81:06 - basically i'll show you here
81:08 - um
81:10 - well first of all
81:12 - i don't know what this is oh i think
81:14 - it's
81:17 - that's interesting
81:18 - oh because i clicked on the floor parent
81:20 - right okay um so you click on the walls
81:22 - parent actually i didn't do that yet but
81:23 - it'll actually show you where all of the
81:25 - all the objects that are parented or
81:27 - that are dependent on that parent
81:29 - so the floor parent here see how many
81:32 - floor blocks there are there's quite a
81:33 - lot
81:35 - excuse me
81:38 - there's a lot of floor blocks here and
81:40 - in the walls parent there's even more
81:42 - there's a lot of walls and ceiling
81:44 - blocks
81:46 - and if we just generate those without
81:49 - assigning them apparent it'll just fill
81:51 - up our hierarchy there
81:53 - a very messily and it makes navigating
81:56 - our scene um during debugging very
81:58 - difficult right we don't need to see
82:00 - that we have a million clones of the
82:02 - floor or the the ceiling blocks or the
82:04 - wall blocks
82:06 - and so what we do is we just
82:07 - take the all of the clone blocks and we
82:10 - just parent them to an object and when
82:13 - you parent something to an object you
82:15 - get that little drop down like for
82:16 - example this first person character this
82:19 - fps controller is the parent of this
82:21 - first person character as those are two
82:23 - separate objects that both comprise the
82:25 - fps controller effectively
82:27 - a parent is top level and its children
82:30 - are therefore within it within this
82:32 - little arrow here and it's collapsible
82:34 - all of the things within the play scene
82:36 - for example the play scene is the parent
82:38 - to all of these
82:39 - it's sort of like a folder hierarchy
82:41 - type of thing
82:42 - and so if you want to clean up your
82:44 - scene if you're instantiating a ton of
82:45 - things just
82:47 - effectively containerize them by putting
82:48 - them into a parent object and so we do
82:51 - that in our game
82:53 - with a function called create child
82:56 - prefab
82:57 - and so create child prefab does is it
83:00 - does an instantiation as normal right
83:02 - creates a prefab
83:03 - instantiates it gives it a position xyz
83:07 - quaternion.identity because we don't
83:08 - want to apply any rotation to it but
83:12 - myprefor prefab.transform.parent
83:16 - equals
83:17 - parent.transform
83:19 - effectively linking our
83:21 - um we're assigning the parent field of
83:23 - our
83:24 - of that prefabs transform
83:26 - to the parents transform
83:28 - and that has the effect of basically
83:30 - linking them together in a parent-child
83:31 - relationship
83:32 - and that will allow us to
83:34 - collapse and expand a list
83:37 - when one parent has a bunch of children
83:39 - we can expand it and contract it in the
83:41 - hierarchy view and save us a lot of
83:45 - save as a bit of a headache in terms of
83:46 - navigating our scene when we instantiate
83:47 - a lot of things which is fairly normal
83:51 - um
83:53 - so the
83:54 - actual may i'll go over this fairly
83:56 - quickly it's a fairly simple algorithm
83:58 - and i've talked about it on the screen
84:00 - we don't have a ton of time but
84:02 - basically we go z to x
84:04 - the reason that we go z to x is because
84:06 - in unity z and x are sort of like the
84:09 - ground axes and y is sort of like the up
84:12 - and down axis and so we don't want to
84:14 - instantiate we're not really worried
84:16 - about navigating the y-axis during our
84:19 - maze generator because all we're going
84:20 - to do is instantiate four blocks along
84:22 - the y-axis during that phase right
84:25 - so we're basically taking our 2d array
84:27 - and we're iterating over it x y and then
84:30 - we're mapping that to unity's z x or x z
84:34 - if that makes sense
84:36 - because
84:37 - notice
84:38 - the uh like this is our ground right so
84:42 - where this transform is you can see the
84:44 - ground how this is x
84:46 - the blue is a z
84:48 - and y is this axis here we're generating
84:51 - we're effectively only concerned about
84:52 - generating on the ground and then when
84:54 - we generate a wall we just generate it
84:55 - four blocks high on the y we don't think
84:57 - about the y
84:59 - so that's why x and y for our 2d array
85:02 - but x and z
85:03 - for applying that array to unity's 3d
85:06 - coordinate system does that make sense
85:10 - okay so
85:12 - we're iterating over z and x
85:15 - and then we're indexing into our
85:18 - um map data z and x which is effectively
85:20 - the same thing as y and x
85:22 - and then we are creating a child prefab
85:25 - if map data zx so recall if so recall
85:29 - that our map data is a 2d array of
85:32 - booleans right
85:34 - and so if we have map data zx equal to
85:37 - true
85:38 - that means there's a wall there it means
85:39 - that there's a true in our array so we
85:42 - should instantiate a wall at that
85:44 - location so we create three wall prefabs
85:48 - assign them to the walls parent so that
85:49 - they get containerized within there so
85:51 - they don't clog up our hierarchy view
85:56 - and then
86:00 - let me see here
86:04 - and so if we don't so if we've if we've
86:06 - gone through our maze right if we're
86:08 - generating our maze and we get to our
86:10 - first tile that's actually not
86:12 - a
86:14 - wall so it's an empty space
86:16 - so
86:17 - basically the else here so if map data
86:19 - z-x is not true it's going to be false
86:21 - so if that's the case and if
86:24 - not character placed so character place
86:27 - is just a boolean it's a private bully
86:29 - and we don't want this to be visible in
86:30 - our inspector there's no purpose for it
86:31 - to be visible in our inspector this is
86:33 - just a boolean for us to use in our
86:35 - script
86:36 - so
86:37 - we set that to false by default because
86:39 - we haven't placed our character yet but
86:40 - once we when we generate our maze we
86:42 - have to make sure we put our character
86:43 - in a spot that there isn't a wall
86:45 - because we'd obviously don't want him
86:46 - trapped in a wall or clipping through
86:47 - the maze right so if not character
86:51 - placed
86:52 - we're going to set the character
86:53 - controller's transform we're going to
86:55 - set its position and rotation which is a
86:57 - function um we're going to set it to x
87:01 - and then y one and then z
87:04 - and then no rotation so
87:05 - quaternion.identity
87:08 - and then set that to true so therefore
87:10 - this will never be called again so this
87:12 - only gets called on the very first empty
87:14 - space that we
87:16 - go through our maze
87:18 - and that's it for that um when we no
87:22 - matter what we do um whether there's a
87:25 - wall in our maze or not we're going to
87:26 - want to generate a floor and a ceiling
87:28 - at that space
87:29 - so
87:30 - that's of course assuming that generate
87:33 - roof is true which recall we made a
87:34 - public boolean in our inspector so that
87:37 - i could debug and show you guys what the
87:38 - maze looks like from up above so if
87:40 - generate roof
87:42 - create a child prefab for ceiling prefab
87:44 - at x4z so a bit higher up
87:48 - and then no matter what always want a
87:50 - floor
87:51 - so create a floor prefab at x 0 z so
87:55 - down below and our character controller
87:57 - gets placed at recall x1z so just above
87:59 - the floor
88:01 - the assignment
88:03 - is actually part of the assignment is
88:05 - generate
88:06 - a hole in the floor and if there's a
88:09 - hole in the floor
88:10 - and the character falls through the
88:11 - floor of the hole should get a game over
88:14 - right so you're going to create a game
88:15 - over scene you're going to need to
88:16 - transition to that scene and then we're
88:18 - going to need to
88:19 - check to see whether the character's
88:21 - transform has gone below a certain
88:22 - amount right
88:24 - that's all fairly easy stuff to do
88:27 - but you'll look to do some of that in
88:28 - here
88:29 - and then the actual maze data
88:32 - function is here i won't go over it in
88:34 - detail but it's the algorithm that we
88:36 - talked about before where we choose
88:38 - direction to move
88:39 - randomly and we choose a random number
88:41 - of steps to move clamp that value within
88:44 - the constraints of the maze and then set
88:46 - every tile that we explore
88:48 - to false
88:50 - and that has the effect of creating the
88:52 - maze and then we just return that data
88:53 - back to our function it's just a 2d
88:55 - array notice that in unity sorry in c
88:58 - sharp to create a 2d array it's a little
89:00 - bit different than in a lot of other
89:01 - languages it has its own syntax for that
89:04 - you have the array syntax that you're
89:05 - probably familiar with but then you also
89:06 - have this comma and that comma is to
89:08 - designate that there are two arguments
89:10 - to that um index syntax here just means
89:14 - there an x should go here and y should
89:16 - go there basically
89:17 - um or a y x and that's 2d array and you
89:20 - can make it you can make it as many
89:22 - degrees as you want to just add more
89:24 - commas to it
89:26 - and notice that to actually
89:27 - [Music]
89:28 - allocate the memory that we want for
89:30 - that 2d array newbool
89:33 - may size may size so our maze is always
89:35 - square shaped same same
89:38 - and you could easily make this mace x
89:40 - maze y if you wanted to to make it like
89:42 - rectangular so you just need to have two
89:45 - public variables instead of one
89:47 - and all of this is fairly visible
89:49 - through the inspector too and our
89:51 - dungeon generator you can see i made a
89:53 - tiles to remove 350 so that means that
89:55 - our maze is going to cut out 350 tiles
89:58 - and as soon as it cuts out 350 tiles
89:59 - it's done and then our maze size is 30
90:02 - by 30. so that means there's going to be
90:04 - 900 tiles in our maze so you can tailor
90:07 - this to whatever you want in order to
90:09 - produce
90:10 - sparse or denser mazes
90:13 - to your liking
90:15 - so any questions as to how
90:18 - the code for that works
90:20 - more or less
90:22 - so
90:23 - now we'll actually get to the scenes
90:24 - part of it and so transitioning between
90:26 - oh yeah
90:27 - yeah um
90:28 - i'm thinking like
90:30 - you know for like a smaller game like
90:31 - that like that works great but like for
90:33 - a larger game wouldn't you want to model
90:35 - the walls as like 2d
90:37 - kind of objects and like the ceiling
90:39 - instead of like a whole cube
90:42 - oh yeah
90:43 - so for a small game um is it ideal more
90:46 - ideal for the walls to be rendered as
90:49 - like one con one discrete object as
90:51 - opposed to like several cubes
90:53 - yeah absolutely that's 100 true and
90:56 - actually minecraft is an example of this
90:59 - sort of idea that you think would work
91:01 - but they actually consolidate all their
91:03 - geometry after they've generated it in
91:05 - this way and produce like um
91:08 - models that are more optimized like that
91:11 - you think that you're interacting with
91:12 - this world that's a bunch of these
91:13 - little blocks all separate but it's
91:15 - actually one big piece of geometry and
91:16 - then it dynamically figures out what
91:18 - you're hitting and removes and adds
91:20 - blocks as needed and there's some uh
91:22 - some cool videos on youtube as to how to
91:24 - do this in unity too which i looked at a
91:26 - long time ago and it kind of shows you
91:27 - you can actually dynamically create
91:29 - meshes and vertices and stuff in unity
91:31 - and then create objects that way which
91:33 - is really cool
91:34 - but that's a little bit more on the
91:35 - advanced side
91:37 - but yeah absolutely for
91:39 - an actual implementation of this a
91:41 - simple but more efficient way to do it
91:43 - would just be to have like yeah one
91:45 - solid large wall object that's like as
91:48 - tall as you need to be and maybe as wide
91:50 - as you need it to be for um one
91:52 - character and have that work but for
91:54 - simplicity's sake to illustrate the
91:55 - algorithm um we were just using
91:58 - the
91:59 - cubes yeah exactly but yeah good point
92:02 - that's a 100 true
92:05 - all right multiple scenes
92:07 - so the way that we do this
92:10 - so i'm going to go into my text editor
92:14 - whoops
92:16 - so the
92:20 - grab pickups script so grab pickups is a
92:25 - component that's attached to
92:28 - the character controller because he's
92:30 - going to be picking up pickups
92:33 - and what the grab pickup script
92:35 - effectively does is
92:38 - the
92:39 - character controller
92:41 - built in
92:43 - collide has this function that you can
92:44 - define for it called on controller
92:46 - collider hit where anything that
92:48 - collides with the controller's collider
92:51 - will trigger this callback function and
92:53 - you can grab the information
92:55 - about the
92:57 - um
92:57 - object that you collided with and then
93:00 - perform some sort of logic on that and
93:02 - so it's actually calling this function
93:03 - every single time we
93:05 - uh collide with any of the tiles or the
93:08 - blocks in our scene as well there's just
93:10 - no logic to account for them so it's
93:11 - just effectively an empty function call
93:14 - but
93:15 - if it's the case that the
93:19 - game object
93:21 - has a
93:22 - tag of pickup which we've set in our ed
93:26 - unity editor and i'll show you how to do
93:27 - that
93:28 - then we should play a sound
93:30 - from our pickup sound source
93:32 - and then we should
93:33 - using
93:35 - we actually use this in the last lecture
93:37 - but only within the same scene we're
93:39 - going to call
93:41 - scenemanager.loadsceneplay
93:43 - and you need unity engine.scene
93:45 - management
93:46 - using
93:47 - unityengine.com at the top of your
93:48 - script in order to use this
93:51 - and load scene effectively just like
93:53 - we'll literally just load a scene by its
93:55 - name
93:56 - and we're doing that in a couple places
93:58 - so we're actually doing it there but
94:00 - remember we had the
94:02 - title scene which had the same sort of
94:04 - thing you press enter and you load a
94:07 - you load the play scene right so this
94:09 - load scene on input component that i
94:11 - created is attached to a text field in
94:15 - the title scene
94:17 - and all we're doing here is in the
94:19 - update we're just saying hey if update
94:21 - if input.getaxis submit
94:24 - is equal to one
94:27 - then
94:28 - cmanage.loadsceneplay almost almost the
94:30 - same kind of almost the same code only
94:32 - in this case we're
94:34 - querying unity's input it has a global
94:36 - input manager get axis so it has several
94:39 - axes is how it defines it different like
94:42 - methods of input
94:44 - and then it defines them by keywords so
94:46 - in this case submit is a keyword and you
94:48 - define you map those
94:51 - keys
94:52 - or you map those keywords to specific
94:54 - keys and input sources on whatever
94:56 - platform you're targeting in this case
94:57 - submit is synonymous with either enter
95:00 - or return depending on which platform
95:02 - we're using and it could have other
95:04 - meanings if we're exporting this to xbox
95:07 - or for exporting it to the web or for
95:09 - exporting it to a mobile phone there's a
95:11 - lot of different
95:12 - ways it changes
95:14 - and so the way that it
95:16 - checks is it'll be zero or one
95:19 - specifically so we can say if input dot
95:20 - get access submit equals one
95:22 - um
95:23 - c manager load scene play
95:25 - and it won't let you
95:27 - do if input dot get access submit
95:29 - because it's explicitly expecting an
95:31 - integer and it'll throw an error if
95:33 - you're trying to use it like a boolean
95:35 - so we need to use
95:37 - this equals equals 1 to test for
95:40 - equivalence
95:42 - and that's all we're effectively doing
95:44 - there
95:47 - now
95:48 - the
95:49 - interesting thing is when we
95:52 - reload the scene
95:54 - for
95:55 - the
95:56 - pickup right for the maze there's a
95:58 - soundtrack playing in the background and
96:01 - we want the soundtrack to constantly be
96:03 - playing the same thing and to loop right
96:07 - the sound effect we don't want it to
96:09 - start up immediately again and start
96:11 - like from the very beginning again we
96:12 - kind of want the seamless sort of feel
96:14 - to it
96:15 - and so
96:16 - how do we think we can solve this
96:18 - problem
96:30 - correct
96:34 - so any ideas as to how we would do this
96:41 - well so whenever we collide with the
96:42 - pickup we reload the scene completely
96:45 - from scratch
96:46 - and so when you reload a scene it
96:47 - destroys every game object in the scene
96:49 - including all the objects that have
96:51 - audio sources attached to them
96:53 - and so when it reloads the scene it
96:54 - reinstantiates all the game objects in
96:56 - the scene including those with audio
96:58 - sources and re-triggers their playing
97:00 - so what we want to do is prevent this
97:01 - from happening
97:04 - just have a counter and when you get the
97:07 - first pickup then it goes to one and
97:08 - then you say if less than one play the
97:12 - sound
97:14 - um
97:15 - that will have the effect of so you're
97:18 - saying have a counter and when
97:21 - true
97:24 - so
97:25 - have a counter or true false when you
97:27 - load the scene it starts the music but
97:29 - what happens when we reload the scene
97:30 - from scratch and the audio that was
97:32 - playing gets deleted
97:34 - can you transport certain objects
97:37 - between scenes can you transport certain
97:38 - objects between scenes effectively you
97:41 - can
97:42 - there's a function called don't destroy
97:44 - on load
97:46 - actually
97:47 - so with that it's a unity function which
97:49 - allows you to preserve an object as it
97:51 - is between scenes
97:54 - so uh if you don't want your scene with
97:56 - the music to or your object with the
97:58 - music to
98:00 - destroy itself and then reinstantiate
98:03 - unload well technically just don't
98:05 - destroy itself
98:07 - um just do don't destroy unload at the
98:08 - game object
98:10 - and so this don't destroy we apply this
98:11 - to our audio source our whisper source
98:13 - it's called in the scene
98:15 - the only problem with this is
98:18 - if we reinstantiate or if we don't
98:20 - destroy on load this object it's going
98:22 - to persevere but when we reload the
98:24 - scene it's going to instantiate a new
98:25 - one so what's the effect of this going
98:27 - to be
98:29 - gonna have two audio sources playing at
98:30 - the same time what happens when we do
98:31 - another one
98:33 - we have three audio sources playing at
98:34 - the same time so for every time you go
98:36 - to a next level you're going to add the
98:38 - same audio track to the scene it's going
98:39 - to be very annoying very quickly
98:42 - the way that we avoid this happening is
98:44 - by making what's called a singleton and
98:46 - so what a singleton is is a class that
98:49 - can only effectively be instantiated one
98:51 - time
98:52 - right
98:54 - and
98:56 - um we do this by creating a static
98:59 - variable here
99:01 - called don't destroy
99:03 - um
99:06 - uh no we called instance which is of
99:08 - type don't destroy so it's this
99:09 - component here right and so the don't
99:13 - destroy class as a whole has this static
99:15 - variable called instance and we set it
99:17 - to null by default when we haven't
99:19 - instantiated a don't destroy component
99:22 - yet
99:23 - and what this
99:24 - ensures
99:26 - in our scene
99:27 - by the logic we have in the awake
99:29 - function awake is almost the same thing
99:31 - as star just means whenever you can you
99:32 - can pause an object and
99:35 - it'll awake from its pause state but
99:37 - awake also gets called when an object
99:39 - gets instantiated
99:41 - so
99:42 - if the instance is set to null on awake
99:45 - um
99:46 - instance equals this so this don't
99:48 - destroy so whatever this is being called
99:50 - from this this don't destroy will be the
99:52 - instance whatever the first don't
99:54 - destroy component is in our scene the
99:56 - very first maze that we generate the
99:58 - sound source
99:59 - instance will be this
100:01 - and then we set don't destroy on load
100:03 - for the game object that is holding that
100:06 - don't destroy don't destroy component
100:09 - right that audio source
100:12 - but
100:13 - if the instance is not equal to this so
100:16 - if we've woken and this is level two for
100:19 - example instance is going to be set to
100:22 - the
100:22 - um
100:24 - the don't destroy a component on the
100:26 - don't destroy unload object that we
100:27 - created in the first maze right because
100:29 - we did this logic here
100:32 - and so it's going to try and instantiate
100:34 - a second
100:36 - don't destroy a component it's going to
100:38 - another sound source
100:40 - but instance is not going to be null
100:41 - instance is going to be
100:43 - equal to that first object so we say if
100:46 - instance is not equal to this
100:49 - destroy game object so this is going to
100:51 - be from the standpoint of the second
100:53 - um just don't destroy that got created
100:57 - basically
100:58 - the singleton will persist indefinitely
100:59 - yeah indefinitely upon its first
101:01 - instantiation and there will only ever
101:03 - be one singleton this is a very basic
101:05 - very common
101:07 - pattern in software engineering for
101:08 - ensuring that you only have one object
101:10 - of a given type present throughout your
101:11 - entire project
101:14 - but this is how we prevent multiple
101:17 - sound sources from being instantiated we
101:18 - always ensure that only one object of
101:20 - that with that component gets
101:21 - instantiated at once and any future
101:24 - instantiations of that object get
101:25 - destroyed immediately assuming that they
101:27 - aren't that first object if they are
101:29 - that first object instance will not
101:31 - instance will equal this and so it'll
101:33 - still skip this part and so it'll stay
101:34 - alive
101:36 - so any questions as to how the
101:38 - persevering through multiple scenes
101:40 - works for their sound source
101:44 - okay um that's how we get multiple
101:47 - scenes so far we looked at fog already
101:50 - but i have a few screenshots here to
101:51 - kind of help illustrate what fog has
101:52 - looked like over the years
101:55 - so fog looks pretty unconvincing in this
101:57 - screenshot this is turok for the n64
102:00 - it's just kind of looks as if
102:02 - you know sort of at a certain distance a
102:03 - very dense sheet of fog
102:05 - has appeared and you can actually make
102:07 - this happen in unity by setting the
102:10 - there's a curve a fog curve that i
102:12 - believe you can manipulate that while
102:14 - effectively
102:15 - the algorithm that determines how the
102:17 - color gets summed to things far away is
102:19 - very fast as opposed to gradual or
102:21 - linear so you can make it just like
102:23 - exponential effectively and make it look
102:24 - as if
102:25 - the fog is incredibly dense and starts
102:28 - almost at a very fixed spot and have the
102:30 - rest of this area sort of in front of
102:31 - you look normal
102:33 - here's another example star wars the
102:35 - empire one of my favorite n64 games
102:37 - which has sort of the same look and so
102:39 - in this area you can see fog is very
102:41 - distinguishable
102:43 - very artificial looking because it's
102:45 - very tinted in this case it looks very
102:46 - blue in this case it looks very like
102:48 - pale blue
102:50 - this is silent hill and silent hill
102:53 - looks realer more realistic
102:55 - but um kind of the same thing at play
102:58 - here you have a
102:59 - very pale gray metallic blue color and
103:02 - the
103:03 - density in this case is very high the
103:06 - density is much higher
103:08 - well maybe close to as high as it is in
103:10 - our game that we should that we're
103:11 - showing today um but it's effectively
103:14 - the same thing just with a different
103:15 - color and they used it to great effect
103:17 - in here not only for um sort of this
103:19 - aesthetic to make you look as if you're
103:21 - in some sort of desolate town but also
103:24 - to dynamically load objects or to
103:26 - prevent rendering objects that are a
103:28 - certain distance away and to optimize
103:29 - performance on the hardware that was
103:31 - severely limited at the time which was
103:32 - playstation 1 which is a fairly weak
103:34 - console
103:36 - and then here is shadow of the colossus
103:38 - for ps4 which just came out not too long
103:40 - ago and we can see fog is still being
103:42 - used but it looks photorealistic and
103:45 - there's probably a lot more that they're
103:46 - doing they probably have several layers
103:47 - of fog they probably have textures and
103:50 - um you know transparent objects that are
103:53 - simulating fog and a lot of more
103:54 - complicated things like that fog that
103:56 - only hangs at a certain distance so it
103:58 - looks like fog going over the lake
103:59 - there's a lot of things here but it's
104:01 - the same idea and they probably have the
104:02 - same sort of foundational base fog
104:04 - present throughout the scene
104:07 - and then here's our game just to show
104:08 - how it looks like you can barely even
104:10 - see it but it does give you this sort of
104:12 - like lost in a really dangerous maze
104:14 - feeling which and it's super easy to do
104:17 - and it can it can save you performance
104:20 - and it can add a lot of aesthetic to
104:21 - your game
104:22 - and so the last big thing we'll talk
104:24 - about today is unity2d actually so i'm
104:27 - going to go back into
104:29 - questions about fog i know that was a
104:30 - pretty high level overview i've already
104:32 - looked at fog we looked at how it
104:33 - applies in the settings
104:34 - any questions as to how it works or how
104:36 - to get it working unity
104:39 - okay
104:40 - so we're going to go ahead and look at
104:43 - our
104:44 - title scene and so we looked at this
104:46 - earlier briefly but i'm going to go
104:48 - ahead and show you the components so i'm
104:50 - going to take a look at our canvas if
104:51 - you double click on something you'll
104:53 - zoom out
104:54 - and so it'll automatically detect sort
104:56 - of what your resolution is and scale the
104:58 - canvas accordingly in your scene view
105:01 - there's a 2d button here i'm going to go
105:03 - ahead and go to my default layout
105:06 - i'm going to click on the
105:09 - canvas
105:10 - notice that it shifted things a little
105:11 - bit because now i have a larger window
105:13 - that's going to be rendered to
105:15 - i'm going to click on the canvas and
105:16 - then i'm going to go to 2d mode and then
105:19 - notice when you click on 2d in 3d mode
105:22 - you go like instantly into like seeing
105:25 - it as if you're manipulating it in a 2d
105:27 - engine versus a 3d engine and then going
105:28 - back to 3d now it's a three-dimensional
105:30 - plane that you're actually looking at
105:32 - so in 2d mode you can easily sort of
105:35 - navigate it right click and drag it
105:37 - around
105:38 - i'm going to go here like this and these
105:41 - are very simple components that you can
105:43 - just interact with
105:45 - as a gui now
105:47 - the main thing that you need to get any
105:49 - of this to work is the canvas which is
105:51 - here so if you right click and then go
105:53 - to ui
105:55 - you can go to canvas if you want to
105:58 - or you can just add any of these things
106:00 - that you want and it'll automatically
106:02 - add a canvas for you because a canvas is
106:05 - necessary for all of the unity ui
106:07 - rendering stuff
106:09 - so if i were to just add a text and on
106:10 - an empty scene it will just create a
106:14 - a brand new canvas and an event system
106:17 - the event system is just how unity talks
106:20 - to the canvas and the all the ui
106:23 - elements of your canvas given mouse and
106:25 - keyboard input and stuff like that
106:27 - it's nothing that you necessarily have
106:28 - to worry about or use
106:31 - but the canvas is the sort of overall
106:34 - container for all gui stuff that you do
106:37 - now if i click on the the title text or
106:39 - the enter text notice that they are
106:40 - children of the canvas so they are
106:42 - within the canvas the canvas is their
106:44 - parent the title text i can move it
106:46 - around notice that it snaps right it's
106:48 - got some nice snapping functionality
106:51 - i can set it up there it'll snap to the
106:52 - top it'll yeah it's pretty handy you can
106:56 - scale or scale the bounding box it
106:59 - doesn't scale the actual text but the
107:02 - notice that i do have
107:04 - like
107:05 - right justification centering left
107:07 - justification those sorts of
107:09 - helping
107:11 - the sort of features
107:12 - i can increase the font size via slider
107:15 - right so i can immediately see without
107:17 - having to edit some code and then reload
107:20 - the project what changing some of these
107:22 - values will look like i can easily
107:24 - change the color in real time so i can
107:25 - get a sense of how that looks if you
107:27 - wanted some sort of slimy dread 50 look
107:30 - i guess
107:33 - and you can also assign materials to it
107:35 - as well which is kind of cool which i
107:36 - haven't explored too much in detail but
107:38 - you have that option if you want to give
107:39 - it a material instead of a
107:41 - instead of a color
107:42 - materialed font
107:44 - [Music]
107:45 - because ultimately all this stuff is
107:47 - still 3d but unity presents it in a way
107:49 - that makes it look as if you're
107:51 - interacting with it in 2d it's pretty
107:52 - nice
107:54 - i mean when you hit play it's going to
107:55 - open up to that yep and then how do you
107:58 - transition to the rest of the game
108:00 - so the transition to the rest of the
108:02 - game is in the
108:04 - load scene on input here so this script
108:07 - that we looked at earlier
108:09 - so this is assigned to one of those text
108:10 - labels so i just gave it to the i forget
108:13 - was it the i think it's the enter text
108:15 - so i gave it this load scene on input
108:17 - just because it's a it's the enter text
108:19 - it seemed appropriate uh you could put
108:22 - it on anything in the scene it doesn't
108:23 - matter as long as it has this update
108:25 - function which then has this if input
108:27 - dot get access submit equals one and
108:30 - then recall
108:32 - the
108:33 - go into the project settings input
108:37 - all these axes here are defined for you
108:40 - automatically and then you can choose
108:42 - what they map to but submit as you can
108:44 - see positive button is return
108:47 - so if submit is equal to one repress
108:50 - return it'll be equal to one effectively
108:53 - and it gets mapped to other buttons
108:54 - depending on what input sources you have
108:56 - on your
108:57 - device
108:59 - but you can check what it is on your
109:01 - computer just by going to axes in your
109:03 - input manager so it's once again edit
109:06 - project settings input and then you can
109:07 - see all the axes here
109:10 - the 2dc that's a whole that's just a
109:12 - scene in itself it's a scene in itself
109:13 - completely as a camera so we are um
109:17 - the camera renders the thing about
109:18 - canvas is it's kind of separate from the
109:20 - camera so it gets rendered onto whatever
109:22 - the camera is rendering separately
109:25 - but the camera in this case
109:27 - what i've done because if by default we
109:29 - just render the camera and the ui it's
109:31 - going to look just like this it's going
109:32 - to look like the sky with dread50 and
109:34 - press enter that's not the aesthetic
109:36 - that we want so
109:38 - i take the camera and then you can give
109:41 - it a background so by default the
109:42 - background is that sky is the sky box
109:45 - and so
109:46 - it's set clear flags clear flags are
109:49 - same thing as background so whenever
109:51 - there's no geometry or anything um
109:54 - clear what this clear color clear flag
109:57 - this gets drawn to before any geometry
109:59 - in the scene basically
110:02 - excuse me
110:03 - so clear flags solid color in this case
110:05 - and then just black using a color picker
110:08 - so super easy super nice
110:10 - um and then this ui this canvas will get
110:13 - drawn on top of this camera so that's
110:16 - what produces the sort of combined
110:18 - effect of having the the ui text and the
110:21 - black background and then that enter
110:24 - text having that component that checks
110:26 - for the submit input because that's what
110:28 - enter and return map to
110:30 - that is um
110:32 - that is what lets us transition from uh
110:35 - the current scene to the play scene
110:39 - and so there are a lot of other cool
110:40 - features that these
110:43 - like labels and such have
110:45 - for example being able to set its anchor
110:48 - position
110:49 - so depending on what device you're
110:51 - shipping to you might want
110:53 - you know you're going to have multiple
110:54 - screen sizes and screen
110:56 - resolutions so you can say i want this
110:59 - label
111:01 - to always be
111:02 - at the very top middle
111:04 - of my scene and i can do this by
111:07 - clicking this little box here which is
111:09 - the anchor point selector and then just
111:11 - clicking that
111:13 - and so that will always anchor dread50s
111:15 - text to the top middle no matter what
111:16 - our resolution is
111:18 - it'll always be there
111:21 - and there's a lot that you can do
111:25 - whoops on top of that
111:27 - and you do that with any ui component
111:29 - just relative positioning depending on
111:32 - the resolution and the nice thing about
111:33 - unity 2 if you go to game you can
111:36 - actually choose sorry in the second menu
111:37 - you can choose a lot of aspect ratios so
111:39 - 5'4 doesn't look that great
111:42 - 4 3 doesn't look that great 16 10
111:45 - 16 9
111:46 - and then standalone
111:48 - so
111:50 - standalone is the default export size of
111:52 - your platform
111:54 - but you can choose you can have it
111:58 - you can test different resolutions and
112:00 - you can also add more to you can add a
112:02 - fixed resolution if you want
112:05 - or an aspect ratio
112:07 - and
112:08 - do a lot of cool things that way so you
112:10 - don't have to necessarily test it
112:11 - physically on different devices although
112:12 - it's very good too so you can make sure
112:14 - that you're not blowing up your hardware
112:16 - but you have that option
112:19 - so any questions as to how
112:21 - unity2d works
112:24 - and
112:25 - how the canvas works or how we've gotten
112:27 - the simple ui to work
112:30 - part of the assignment will be and we'll
112:32 - take a look at that now actually
112:34 - so assignment nine we talked about this
112:36 - already about the gaps on the floor but
112:39 - this will be part of you know the maze
112:40 - generator right because that's where we
112:41 - generate ultimately or the degenerate
112:44 - the maze instantiator the actual
112:47 - part of the maze generator that creates
112:48 - the physical maze
112:50 - but create gaps in the floor
112:51 - and then when the player falls through
112:53 - approximately two blocks below
112:56 - which so you can set make check the
112:57 - transform is the y positions less than a
113:00 - certain amount right which should be
113:03 - should be less than zero i think it's
113:04 - based on the top part of it um
113:07 - then you should transition to a new
113:08 - screen that says game over
113:10 - so create a new scene
113:12 - very similar to the first scene that we
113:14 - looked at which was just the title
113:15 - screen and you can probably copy most of
113:17 - that but that scene should say game over
113:20 - and then pressing enter there should
113:22 - load the title scene right
113:25 - and then
113:26 - lastly add a text object to the place
113:28 - scene that just keeps track of how many
113:30 - levels you've navigated through and you
113:32 - can probably do this with some kind of
113:34 - static variable but any solution that
113:36 - accomplishes it is welcome
113:38 - but all together all pretty easy pieces
113:41 - to put together
113:42 - that was this week which was dread halls
113:45 - and our first foray into first person
113:46 - games next week we'll look at portal it
113:48 - won't look necessarily this good but
113:50 - it'll look similar to this this is a
113:53 - screenshot from portal itself
113:55 - but we'll look at how we can render to
113:57 - textures how we can cast rays from our
113:59 - character our first person controller
114:01 - how we can actually make it look as if
114:02 - we have a weapon or a gun or portal gun
114:04 - which is you know not too difficult you
114:06 - just have to parent basically a model to
114:08 - your first person controller
114:10 - um
114:12 - and then when we walk through a portal
114:14 - how do we transition from the other two
114:16 - from one portal to the other portal so
114:17 - just a uh you know teleport your
114:20 - transform to another position
114:22 - but that was that
114:24 - next week is portal and i will see you
114:25 - all next time

Cleaned transcript:

all right welcome to lecture nine of gd50 today's topic is dread halls um so last week we ventured into unity our first foray into 3d and not only 3d but also just getting our hands around um our heads and hands around the unity game engine which is uh among unreal and others sort of the most popular game engines in use for 2d and 3d games um and last week we did sort of a 2.5 d style helicopter game whereby everything was in 3d but we were still aligning things based on just two axes the x and the y i believe um possibly the z and the y i don't remember but two axes versus three axes today we'll actually be diving into using all three axes available to us in unity 3d in the context of a game called dread halls and so what dread halls is is a v it was a vr game actually the first vr game that i ever played um on the oculus the the gear vr samsung gear vr and it pits you in sort of this dark and eerie 3d maze where you don't really know what's going on and you can go around and get collectibles and encounter creatures and stuff as you can see in the bottom right screenshot there today's example is going to be a little simpler but it allows us to explore things like procedural maze generation and first person camera controls so last week recall we were using sort of a three a third person camera whereby we were sort of far back on the scene today we'll actually be using a firstperson camera where the camera is effectively our eyes as if we were walking around in the maze ourselves unfortunately we won't be using a vr demonstration this week but next week i hope to put together sort of a vr sampling using this project so we can see how this works in vr and how unity's toolkit works in vr so some of the topics we'll be covering today we'll be talking about texturing so recall last week the helicopter and all of the items in our game were just sort of flat colors they didn't really have any textures associated with them we'll talk about how to assign textures to materials and how to apply those materials to objects in our scene we'll talk about materials and lighting so not only materials but also the different kinds of lights that unity supports and a few details about those we'll talk about again 3d maze generation so we'll have a simple but effective algorithm for creating a 3d data structure to represent our level as opposed to previously where we had just a you know a tile map that we could generate to give us the appearance of walking around in some sort of 2d world now we'll actually perform a similar operation on data a 2d array but we'll take that array and we'll actually create 3d blocks and create a maze that we can walk through in 3d space which is kind of fun and interesting last week we only had one scene in our game so which was just a play scene and even though we had sort of like a game over state within that scene we didn't transition between scenes we just sort of reloaded the same scene today we'll have a title screen and a play scene which sort of um is an evolution of the idea that we had in love 2d where we had a state machine that was governing our entire game um in terms of the different states that we could be in whether it was the title the game over the play state and so forth unity does the same thing with scene objects which are effectively a snapshot of a series of game objects aligned in a particular way in the editor we'll talk about fog and also global lighting and certain other things that allow us to create a atmosphere conducive to the sort of feel that we want to get in our game today which is sort of creepy and eerie and lastly when we talk about how to create ui elements in the game we'll talk about unity2d it's canvas object and text labels and some other things and how those all operate which is sort of two sides of the same coin unity 3d also comes bundled with unity2d a set of tools used to make not only 2d games but also 2d interfaces that you can apply to your 3d games so first a demo now i've been sick for the last week so i'm not going to ask for anybody to come up and demo just because i don't want to get anybody else sick so i'm going to just go ahead and show just this lecture the game that i put together for you so here i have two scenes notice here i have a title scene and a play scene i'm in the unity editor right now i'm going to load up the title scene here which i've done and then notice that it has sort of a game view and a scene view i'm going to hit play i'm going to make sure that it's set to maximize which it is and so we have sound here so we should hear audio and hit play and notice that we have sort of like this ambient creepy music track playing we have a very we could have easily done this in love2d this is just a black screen with two uh text labels on it um and this is done with unity's 2d ui toolkit and so it says it tells us to press enter so if i press enter we instantly get teleported into kind of like this maze this creepy looking maze and so i can walk around in this maze and there are a few things going on so anybody um can anybody tell me some of the things they noticed about the scene what jumps out at them what are some of the elements if you were to put this together yourself where would you start what are the pieces that we can put together here yep there has to be a ground that you can stand on and there is so we're generating uh not only walls in our scene of course but we need a ground to sit and obviously and also if you look up top it's kind of difficult to tell but we also have a ceiling so ground and a ceiling and walls some kind of lighting yes and so in in this case we're actually using ambient world lighting as opposed to having a light source so we'll take a look at that last in last week's lecture we used or two weeks priors lecture we used a directional light object but in this case we have no lights in the scene we're actually using unity's world lighting which we'll take a look at soon when we walk around notice that i can move my where my camera is looking with my mouse so we're actually controlling the camera with a first person controller an fps controller which is actually a component that unity provides to you and then notice eventually if we keep exploring the maze we come across this little thing here which is a um sort of a pickup and when we pick this up we get sort of like this piano weird creepy piano sound and then the scene reloads um anybody notice anything about what we see in the distance like how that's how that's affected like if i'm looking at this wall right here for example it's kind of hard to tell but as opposed to like down this hallway what's what's the difference there the light source is further away i guess the light source is further away kind of so we're what we're experiencing here we're seeing is uh it's a a graphics a sort of concept called fog and so what fog lets you do is it effectively adds color to the scene based upon how far away the objects are in the scene it multiplies color onto them and it gives you the illusion of looking in look as if you're surrounded by fog basically and it's been around for a very long time back even as far as the n64 days and we'll talk about that um later today and it's actually incredibly easy to add that into a game with unity and its world lighting system any idea as to how fog not only in terms of aesthetics but how it could maybe help with performance yeah you don't need as much pixel clarity because it's already blurry you don't need as much pixel clarity um kind of the the big thing about fog and the way that it was used a long time ago is that because eventually things are completely opaque beyond a certain point you don't need far draw distance in your game so you can actually like dynamically you can you can emit rendering things that are a certain distance away because you wouldn't be able to see them anyway and so this was an optimization technique used a lot back when draw distance was a huge bottleneck on computers and gave video game consoles back in like the 90s for example like silent hill the game for ps1 was almost exclusively fog and you could see very little in front of you and we'll see a screenshot of that later and they use that for um to boost their performance and also to provide a certain aesthetic and then one other thing you might be paying attention to is there's a sound on loop just sort of this creepy sort of whispering sound and that's to um just add atmosphere right just because without it we would you know it's little things like that especially in horror games like this the atmosphere can be everything so with very simple ideas fog some whispers first person controller sort of tight hallways you can produce something that's pretty scary now there are a few things missing from this namely there's nothing that's going to come at you and attack you but it would be not terribly difficult to add but because we're using procedural generation you would need what's called a nav mesh and you would need to generate that procedurally so things could follow you in 3d space we might have some time to talk about how to do that a little bit later today but that's not implemented in this particular lecture but it would be not too infeasible to accomplish but those are some of the pieces that we'll take a look at today so that was this is the title scene notice that there's uh not a whole lot here actually so if i zoom back out we can see you know canvases are huge in unity just because it's more optimized for the engine to render them that way but we can see even though it's a 2d sort of ui it's very visible in 3d space and if we click this button here we end up getting uh oh no that's that just brings us into sorry click this button here that brings us into sort of the 2d unity 2d mode so now we're interacting with things in 2d and i can actually click on this label and move it around in 2d as if we were using a 2d game engine as opposed to a 3d game engine so we'll look at that a little bit later this is the just the title scene so the play scene itself i'm not going to save that the play scene itself i'm going to go from 2d back to 3d here is pretty much empty so we have a first person controller here this is the fps controller object does anybody anybody tell what basically constitutes an fps controller just by looking at the scene here what are the some of the pieces that jump out at you i thought you just put the camera right where the player is or right in front of the player exactly but the camera right where the player is effectively where their head should be relative to where their body is and their body what's constituting their body here can you tell it could just be uh it looks like a cube in the middle there it's this it's actually this capsule right here i don't know if you can see it uh there's this capsule here this green capsule it's a little bit more organic feeling than a cube necessarily but you could use a cube as well but a capsule is how uh character controllers in unity are represented and character controllers sort of come for free in unity which is really nice they're part of the standard assets so if you go to import package in unity if you're going to assets import package there's a lot of packages that come for free that sort of bootstrap you notice there's like 2d packages cameras characters the characters package has 3d characters uh are thirdperson characters firstperson characters some that are physicsbased some that are not physicsbased this particular controller is not physicsbased meaning that we don't apply forces to it we move it around it's kinematic it can't it is affected by gravity so in a sense it kind of is physics based but it's not strictly physics based like a rigid body and a rigid body would and the collisions that occur between this and another rigid body aren't the same as they would be if we were to make this a purely rigid body based character controller there is a purely rigid body based character controller that you can import i haven't experimented with it a lot but you could probably figure out a good use for that in terms of a game or maybe you want to move precisely on surfaces that have different materials like icy surfaces or whatnot and have it apply it in a very physically realistic way another few things that we have here in our play scene we have a dungeon generator object so this dungeon generator object is just an empty object with a level generator script here and then we have a few other objects a floor parent a wall's parent and a whisper source so we'll get into the details of what all of those mean our goal today we'll be talking about a few things so we'll be talking about here's a picture of just our maze so we talked about some of those things at a high level we'll actually explore how to implement them in unity today so making a maze making the fog effect walking through it with our character controller we want to be able to have some kind of game play here so we have collectibles in the form of this red coin it's actually part of another standard assets pack they prototype assets pack it comes with a prototype little coin object that you can throw in anybody notice anything about this uh coin beyond the fact that it's uh you know just a sort of red coin what else do you notice about this scene here it's emitting a glow any ideas as to how it's emitting a glow it's a light source inside of it exactly so we'll talk about that we'll show you how that's implemented very easy to do in unity and then we'll also talk about towards the end our 2d scene our title scene and how to construct it which is actually very easy in unity as opposed to doing something by code you very rarely actually for interfaces need to touch code at least in terms of how to lay them out in unity you can do everything very visually and with the mouse it's actually it's a it's a pleasure to make you interfaces if you're used to just making them in in code so texturing so last week or two weeks ago we did nothing with textures it was well that's not true we had one texture on the background which was the sort of scrolling background but we didn't really look at that too much in today's example you know the helicopter and the coin and the um the buildings and all that stuff those were all just polygons with flat colors associated with them today we'll be talking about how to actually texture things with materials and so this is very easy to do in unity so i'm going to go over to a to my title scene here just because it's fairly it's it's lit in a fairly normal way as opposed to the play scene which is not lit in a normal way because we're using environment lighting we don't have a sky box the title scene has a fairly normal light a lighting setup so if i add a cube here to the scene so you can see right off the bat by default we do get a material here which has an al what's called an albedo component albedo just means like what's its surface color look like it has a much more technical definition and you can look up on wikipedia what albedo means it has something to do with the way that light interacts with surfaces there's a lot of other elements here you can make something look metallic you can make it look smooth or rough and you can also add normal maps height maps and a few other things which gives it more of like a bumpy texture and so forth and you can also make things emit uh light this way which the coin actually not only emits light but also is a light source so it does both and there's a few other things here for example let's say you have a very large cube and a small texture if you put a very small texture on a large cube what's it going to look like what's your instinct if we have a very large cube at a very let's say we have a 64 by 64 pixel texture but our cube is humongous what's that what effect is that going to have on the cube it's going to look kind of like an n64 cube right it's going to what basically happens it's going to interpolate between the texture pixels the texels when you apply a texture to your cube and so when you apply a small texture to a large surface it's going to look stretched it's going to be it's going to look stretched and like it's going to look also filtered as it like you sort of see in some youtube videos if you watch them and they recorded a very small resolution but you blow them up they look filtered or if you've ever stretched a picture in the right software and it's looked it looks interpolated and filtered it's going to have that look so you can do is you can apply tiling so here we can see there's a tiling element x and y so of 1 in the x and y direction because it only applies on a flat surface so the effect of tiling would be such that if you have a 64 by 64 texture you could just tile that texture several times to get the desired look that you want on whatever surface that you're trying to look at in your game world maybe it's a very small object but maybe it's a very large object that you're looking at as a character and you want to tile bricks for example or you know stone so to apply a texture to a to a 3d object in the scene i'm going to go into here so you need a material first and so these are all unity material objects you can tell because they have a circular they look like if they've been wrapped around a sphere these are all unity materials as opposed to textures textures are just 2d objects 2d you know textures 2d images so this is part of a an asset pack that i downloaded for this lecture called dungeon modules low poly dungeon modules which is in the asset store and so what i'm going to do is i'm just going to apply let's say i want to just apply this rock material to this object right and i go over to that i'm going to first add a i think because i went into the material uh had a incorrect appearance so do that oh that's strange i'm going to create a new scene and then i'm going to add a cube and then a not pop but maybe the beam i wonder why it is not that's very strange for some reason it might be a setting that i have enabled that's not allowing it to correctly render but the effect of that should be that we apply normally if you apply a um uh a texture to a material it'll have the effect of creating it'll instantly texture it but what i can do is i can go to textures here and this should work too i can go to that and then it'll apply it that way so normally if you're in a fresh project and you add a new 3d object and you just click and drag a material onto a 3d object it will texture it for you in this case i think because it's automatically assigning a material to these objects based on some project setting that i'm off off the cuff just unable to i don't know for sure you can instead just go to the albedo component here so albedo functions not only as a color but also as a texture for your object and so you can apply a texture just a 2d image to your albedo component of a material right and that'll have the same effect as texturing it immediately so normally what this is supposed to do is create a albedo create a new material with that texture as the albedo when you set a material to the 3d object now i wonder if i yeah i'm not sure i'm not sure exactly why uh it didn't work as uh like right off the bat like it's normally supposed to in a fresh project it will i'll try to investigate but if it ever happens like that where for some reason you're i think it has to do with the way the shaders are set on here maybe there's a setting i'm just not sure about but you can just set the albedo component here manually and it'll have the same effect so the albedo component of your material setting that with a texture textures objects and so that's effectively how we get from this sort of look of a flat shaded or flat color shaded object to a texture shaded object just like that and texture mapping sort of in itself is a very wide field and fairly complicated but ultimately it looks something like this so does anybody can anybody tell me what this looks like here so we see here obviously we have a fully textured model but if we're looking at this what does it look like we've done here so what does it look like ignore all the lines but what does it sort of look like we have on this surface it's just a texture right we can see whoops we can sort of see the colors here for example maybe the his belt here or or actually that looks like the top of his head here this being the top of his head and then we have like his belt and other things this right here we can pretty clearly see that's like sort of his face mask right but it's just on a 2d surface like this is a just a regular texture and so what we've done here is basically taking all of the polygons that comprise the model and sort of laid them out flat right lay them out flat as if on a table where our texture is and that's what uv mapping is and this is usually something that you do in whatever 3d modeling software that you're using in unity when you apply a texture to a material or a material with a texture to an object it will use its standard um it has its own builtin like mapping algorithm that'll apply material to a model and so it does it differently for different objects we can we can create a like a sphere for example move the sphere over here and i'm going to try again and just to see if the uh applying the material works on that no it doesn't so applying a so if you go into this material here which is for some reason grayed out um new scene again create a new 3d sphere and then oh this time it looks like it's i can't tell no i don't think that's working um oh now it's now it allows us to accept a texture okay so we can apply a texture whoops we apply a texture to that and so now we can see our sphere has been mapped as well and it looks fairly convincing it's been wrapped around it in a way that doesn't look too distorted or too weird and so unity has its own ways of mapping for its primitive objects whether it's spheres cubes we have a few other ones capsule cylinders planes and it'll depend obviously on where your texture is if your texture is fairly ornate it might end up looking distorted but for most purposes for simple primitive objects for most textures it should work pretty well now if you imported a model that was like a table or character and you just applied a texture to it it's not going to look good it's going to look messed up and so your 3d software will export a material with the model assuming that you've modeled in that software with a texture it'll actually give you a material that you can then reference that will properly apply a texture to your character but the same sort of apply a texture just a regular texture to a complicated model just isn't going to work because it hasn't been uv mapped in a smart way unity's not going to know i have a table i want to map i want to map the texture to the table in a you know in a way that looks convincing you can see this kind of if we create a cube and then if we go ahead and i've been making it apparent for some reason uh if we go up here i'm gonna first assign uh okay for some reason that worked instantly um but you can see we've applied a sort of wall texture to it and then if we scale it down so this is the scale button up here so we have um you can move rotate things if unfamiliar the uh sort of these top buttons up here are transform operators so you can move things scale or rotate things and scale things so if you scale this along the you know this yaxis a bit and then you zoom in the texture looks pretty compressed and distorted because it's just doing the same algorithm and assuming it's the same kind of surface without taking into consideration how it's been warped right so ideally you wouldn't have the sort of like flattening thing this this flattening happening and so in your 3d software you would unwrap your model and then um apply a texture to each separate polygon of your model in a way that looks convincing and so this isn't anything that you necessarily have to do um for the lectures for the demonstration for your project but if you are creating your own 3d assets if you're importing 3d assets and if you want to use textures in a way that we're doing today you will need to probably become familiar with uv wrapping uv unwrapping uv mapping in whatever software that you're using and if you're just unfamiliar with it in general and have wanted to know sort of what goes on in turning a you know flat white polygon character into something that has a texture this is effectively what happens you unwrap it make it flat sort of like stamp the material onto it effectively and that be they know that maps the uvs of the texture sort of the textures virtual coordinates to your 3d model so any questions as to how this works at all or about unity and um applying textures what's the general way that you uh you make the the textures on the right where it's kind of like you know it's like a world that's been flattened how do you make the textures on the right that i mean that's kind of an art form in itself you you do have to do it by hand um and sort of know i mean there's a good amount of trial and error that'll go into it too as you're making your model and sort of unwrapping it and noticing oh this looks weird as i'm applying this polygon to the surface i'm gonna go and change that texture but you could use any you could use or photoshop or any standard texture creation software and kind of just um it's something i don't do a lot of it but it's something that i imagine that you just get better at with time and artists texture artists and modeling artists probably have developed sort of like an attuned sense of what makes a good texture versus what doesn't generally you'll make the model first and then you'll make the texture so okay so we already talked a little bit about models uh sorry about materials um we'll we'll go back over it really briefly again there uh there is a resource that i really like and i think does a really wonderful job of teaching beyond far beyond the basics of unity and that's catlitecoding.com and it's totally free they just have a bunch of free articles on there which are very indepth and this is a screenshot taken from one of the articles where they talk about how to make really interesting materials so you can see here this one on the left it looks very you know it looks like a fireball like it's made out of magma and it's got bumps on it it has contour you can see that there's sort of like a glow to the fire on it on the right you can see that this model has um sort of conditional shine on certain parts of it like the metal part of it is shiny but the rest of it isn't and so like how do we make certain parts of the material shiny how do we make certain parts of it flat the article goes into depth on that and effectively what they do is they use several layers of maps like a shininess map which is a texture that tells that you reference in a unity custom shader that you write which the article teaches you how to write which will make certain parts of the texture glossy and certain parts of it not glossy so matte and so you can do a lot of really cool very interesting things and unity's shading system is very um sort of the sky is the limit i mean because it's effectively a standard shader language like you would it's effectively the same thing as hlsl i believe which is high level shading language which is a if i'm not uh microsoft originally came up with it and it's very similar to glsl which is the opengl shading language um and so what these are effectively is just little programs that run on your graphics card we talked about this before but they tell your scene how to process lighting for the objects that are within it and everything in unity has a shader associated with it even if it's just the standard shader which by default is just a white color but you can write your own shaders and you're capable of virtually unlimited possibility and the this effectively is all a shader and it's all a shader that's been written in code but we have a lot of these variables that are exposed to us and albedo is one of them and albedo is sort of conditional if it if it gets a texture applied to it it will just render that texture but if you apply color to it it will apply that color to your material and so that's how you can get you know textured things versus nontextured things metallic just computes shininess and reflectivity off of surfaces and that's just something that's written into the shader and produces the lighting responsible to make that happen and all of these different things are just part of a single shader and a material is effectively a shader they're kind of one in the same a material is a little bit different in that you can also specify how its surface should interact with other things so for example if you're in an ice level a material can not only be like the glo the sort of glossy icy look of something but also how slippery is it when i walk over it and should i slide and how should other things interact with it that have physics so like those two sort of hand in hand are sort of what a material is but um likely as you're starting out the only real things that you'll need to consider and you're sort of bound only by your curiosity are albedo and maybe metallic and maybe emission and then depending on how much you how big your thing is and how small your texture is maybe tiling and then recall last week we manipulated offset so offset is how much the texture is shifted and recall it loops around back to the other side and so by manipulating offset on the xaxis we were able to get a scrolling infinitely scrolling texture right and so all these things have their uses and pretty much everything in unity has its uses it's a very vast tool kit to use but those are probably the important things that you'll see and this article and many others on this website which i highly recommend if you're looking to get really deep into unity will give you a lot of insight into how things work far beyond just the surface level there so any questions on materials all right so we're going to take a look now at lighting so materials materials are one part of the equation so that's sort of defines how things should look when light hits them but we also need light itself in our scene to illuminate things and so this is taken from another article on cat like coding on rendering and so this is a scene with a lot of lights a lot of glowing lights emissive lights and there's a lot more going on here but this is a another great series of articles on how to understand the lighting model in unity and it teaches you a lot it teaches you almost you know down to the very bare ingredients of the sort of the software and the rendering if you want to go that deep i certainly haven't gone through every article because there's just a tremendous amount of content it's very deep but if you're looking to really um if you're looking to really get a sense of how it works i would i would encourage you to explore that so we'll look at a few different types of lighting beyond the more complicated things that this article talks about we'll look at the different styles of lights which you'll probably use more often as you're starting out so point lights anybody have an idea as to what a point light might be based on this picture uh it's not pointing in a very specific direction that's actually a spotlight so a point light is a set a source of light that actually uh shoots out in all directions around it so it emits light in all directions but within a confined area at a specific intensity a spotlight shines light in a specific direction so only one direction and what's interesting about spotlights is you can actually apply what's called a cookie to them and what a cookie does very similar to what the bat like the batman light does it allows you to apply a texture to a light and therefore cast shadows specific shadows on the light so if you wanted to make like something like the bat signal you could put the bat man icon cookie on your spotlight and it'll shine the light but the bat uh the batman logo will be in the middle of it it's effectively the same thing as taking a literal spotlight and putting a object onto it it produces a shadow a manual shadow it's called a cookie yep um a directional light so anybody know what a directional light is so despite its name it's actually not not the same thing as a spotlight so directional light we used a directional light last week actually last lecture directional light casts light in a single direction but throughout the entire scene as if it's the sun so this allows us to illuminate globally the entire scene but all light gets cast from one direction so if you want to produce the appearance of daylight in your scene just a single directional light will illuminate everything and then the last thing which is used less is called an area light so does anybody know can anybody guess what area light is based on this picture here yes so it's light that's only on the surface light that's only on the surface kind of yes so it's light that will emit from the surface of a specifically designated uh rectangle effectively in one direction so you can define a large area for example maybe like maybe you want like a wall strip in your game or something along the wall to emit light specifically uh to the left or something like that that's what an area light is capable of now area lights are computationally expensive and so you can only use them when you bake your lighting does anybody remember what baking means when referring to lighting so baked lighting just means that instead of realtime lighting calculating things dynamically the light gets calculated one time and saved and almost like freezed onto all of the objects in the scene and so there are pros and cons to this what's a pro to baked lighting do we that's think computationally intensive less computationally intensive what's a downside to baked lighting it can be dynamically affected can be dynamically affected so if you're walking through a baked lighting scene and you're expecting to cast a shadow on something or for something to cast a shadow onto you it's not going to happen because the environment's already been pre the lighting for that scene's been prebaked it's almost as if we've just recolored the world in a specific way but we're not actually doing any lighting calculations but this is how lighting worked in like the n64 era and it's how it still works now for certain situations if you know nothing's going to cast a shadow on something you can make really nice looking lighting for a scene without needing to do it in real time you can just bake it right so those are the different types of lights so we can see that in unity so if we go here i'm going to so right now we have a directional light so this directional light is this object here by default all um and you can zoom in as much as you want but it's sort of like um oh there we go this directional light is only shining in one direction so i can move it here so currently i'm in um it's a little bit weird to navigate just because it's been rotated a little bit given that it's a directional light it's rotation so notice how it changes so if i shine it upwards notice that everything comes black because the lighting is just shining upwards right so as if it's coming from below and if i shine it towards there notice that the the lighting on the the sphere and the little cube there sort of change a bit right because they're getting affected by the direction of the light a little bit but they both get affected the exact same because the directional light is omnipresent it's throughout the entire scene it's a global object now if i delete the directional light notice we have no light now so these things just look kind of like statically shaded you can add a new light through if you right click in your sort of game object view and then you go over here you can see we have all the different lights we talked about there's also things called reflection probes and light probe groups and those are a little bit more complicated but those allow you to effectively get pseudo real time lighting and reflection with baked lighting and reflection we won't talk about those in today's lecture but here's a point light for example so let's see where is it that's right over here so i'm going to move it over here so you can see it's not global like the um directional light was right it's just affecting this very limited and i'm going to zoom in a little bit so you can see a little bit better but it's affecting just sort of these two objects relative to where its position is right and so this works perfectly for things like lamps in your scene if you want to have a street light or whether you want to have maybe like a fire going on in a house or if you want the you know like the power up that we had in the uh or the pickup that we had in the uh unity scene right we have just the it's just emitting a purple light that um is within a very small radius notice here we can uh change the color of the light so if i make it like that for some reason oh there we go so we'll do that so notice now it's emitting a purple light so you can color a light however you want to produce whatever effects you want so fire is not going to emit white light it's probably going to emit like an orange red light street lights are probably going to emit kind of like a yellow orangey light so depending on what your scene looks like and what you're trying to emulate you can accomplish pretty much anything with just the you know these very simple objects so i'm going to get rid of the point light and then i'm going to create a spotlight i'm not going to create a area light just because we need to actually bake the lighting into the scene but i will create a spotlight just so we can see what it looks like get it in the right position sometimes it can be a little tough to uh figure out exactly where you are okay getting close there we go perfect so this little spotlight right here is being produced by our object so we can see we can move it around and then we can apply a cookie to it if we want to as well it's right here so in your if you're in a spotlight and you want to apply a texture to it just this little cookie and it just expects a texture so whatever whatever image you want and if you're creating a cookie texture white means full light and black means full shadow and so you can make it a grayscale image you can make it anywhere in between white and black which will allow you to produce some interesting effects the for example the manual in um it's not here it's not i didn't include the picture here but the manual shows like there are some kind of like the lights that you put on a stand and they have a bunch of leds right and they're sort of in a grid and they shoot out a spotlight you can create a cookie that's kind of a gray scale with those gridded lines and it'll shoot light onto the scene as if it's being broadcast from a sort of grid of leds so there's a lot you can do with just some very simple ideas those are the kinds of lighting that we can use and in today's lecture we only really use the point light and the last lecture we use the directional light and spotlights you can you could for example programmatically change for example the rotation of a spotlight if you want to have like a swinging spotlight in your scene to illuminate some wall or some surface there's a lot of cool things you could do with it so those are the core types of lights in unity does anybody have any questions as to how they're used or how they work for the directional light does it matter where it's placed or only the direction it's it does not matter so for the directional light it does not matter where it's placed you could place it anywhere in your scene zero zero or some far distance away you'll have the exact same effect on the entire scene yeah any more questions okay cool cool so those are lights um bump mapping talk about very briefly so bump mapping is we actually do use this in the game um the a bump map effectively is so what you see here on the left is a an actual 3d scene these are actual models being shaded in real time and on realtime but they're actually real models being illuminated in the middle we can see what's called a bump map and on the right we can see a just a flat like a flat plane with a bump map with that same bump map applied to it and then illuminated so what a bump map allows us to do is to take a flat wall or flat surface or whatever you want and then simulate like an actual threedimensional contour threedimensional bumps or whatever you want on that surface without needing to create the actual geometry to make it possible and so there are different tools that will allow you to create bump mapping objects are bump mapping textures often 3d packages will have these so you can create them or other software but they are effectively just the encoding of what are called surface normals so just a vector going from outside of the um outside of the polygon at that given point and they tell the lighting system in unity pretend as if there's actually geometry pointed in that direction when you calculate it and so even though it doesn't distort the geometry in a way that's like this is still completely flat the lighting thinks that the geometry is kind of you know contoured and so it allows us to create this is kind of a toy example but it's actually relevant in the in the case of walls that have and we covered this last week just not in as much detail but walls that you want to be flat and you don't want to have a lot of polygons for you can create a bump map for and apply that bump map and then when you're rendering it when you walk past a wall it's going to look as if the wall actually has cracks and bumps in it for a realistic effect and this is used in the game to slight degree and you can crank it up if you want to i didn't on my computer because my settings or my specs aren't sufficient but every texture in today's example has a bump map associated with it so you can actually see where what the um you can actually see the effect of bump mapping at various degrees of of use the materials here so i'm going to go i'm going to load up the scene that has the actual stuff i'm going to actually i don't need to load the scene all i need to do is go to the materials and the floor for example where's the floor right here so notice that before we talked about albedo and then i also mentioned normal map so right here all you really need to do in order to get unity to detect normal maps and this is just part of the standard shader normal maps and bump maps by the way are effectively synonymous you can just drag your normal map texture into this field here this little square and then give it a degree i wish to apply that normal map and so if you look at this here you might be able to see i don't recall yeah we can sort of see how it changes the texture right so at zero there's no normal mapping taking place at all that texture is just completely flat as if we had done just the regular apply texture to a sphere but the degree at which we apply normal mapping so notice at degree one it kind of looks pretty realistic as if we've got kind of a stony texture and the more we go right the more exaggerated it starts to look right and you can just keep doing that and it'll eventually just look really distorted but that allows you and depending on how strong your computer is you can go higher or lower to affect just how bumpy just how strong the bump map the normal map affects the lighting rendering so it's that easy to get just a fairly sort of extra sense of realism in your scene so you'll notice if you're walking through the scene if you turn off lighting it's even easier to see all of the surfaces the floors the ceilings and the walls have a bump map as well as a texture map so that's in case you're wondering what these weird colored textures are rgb or xyz for the surface normals and how and their permutations thereof and that's how it gets encoded into this and so often you can see if you're looking at a bump map and a texture map you can kind of see together like oh okay this makes sense the parts that i would expect to be bumpier do have a correlation to how they look on the actual bump map texture you can see it here everything that is bumpy or contoured is very visible in the bump map that's just by nature of the way the data is encoded so any questions as to how bump maps work or what they are or how to use them in unity all right cool so now we can start getting into a little bit more into how this all comes together in our maze on our game and we'll talk about maze generation so i'm going to just start up the uh game the scene here so i'm in the actual play scene so in scenes i loaded up play as before i'm going to hit play i'm going to turn off my sound just because the creepy sound is a little disorienting after a while um and then i'm going to oh and actually i'm going to go to a 2x3 view and then hit play so we have the regular game view down here below and then also if i zoom out you can see that our scene was empty before but now we've got a maze and currently it's not very visible at all um because one we're playing fog right and recall fog allows us to effectively add color to objects that are farther away from us and two there's a ceiling on top of our um a roof on top of our maze so it's actually blocking out the actual what the maze looks like so we can fairly easily make a couple of changes here in order to see our maze a little bit better so i'm going to go to window i'm going to go to lighting settings and so if you go to window lighting settings those are your sort of global unity lighting settings right you can set your skybox you can set environment lighting you can set things like fog you can choose how things are baked there's a lot of things here we won't cover nearly all of them we will cover a few of them environment lighting is a big one that's actually how we're lighting the scene in this game so all the lighting that's not um well all the lighting is environment lighting uh that's how we're doing it we're doing it with color so notice that you can choose skybox gradient and color so if you choose skybox environment lighting it's going to have sort of like it's going to look kind of like this skybox that we have here right this sort of in the far distance looks blue kind of looks a little bit more natural but i didn't but it when it's applied to our scene it doesn't look uh quite the way we want it to look so we went instead was just color and i chose this sort of murky greenish brownish color and that gave the result that i was looking for but you can make this any color you want to we can make this some sort of bright yellow color i have no idea what this is going to look like this is probably going to look horrible but yep i mean actually this in a in a weird way this kind of looks interesting this actually looks closer to the original dread hall's game than what i did but it's not very scary kind of looks like we're in a pyramid um that is um am i able to go back no okay well i uh screwed up the color let me try and find kind of what color i had before it's kind of like a nasty green kind of like that it's probably good enough okay something like that and so we play it again we can see you know we're back to the nasty dark color but that's environment lighting so it applies a lighting uh uniform just ambience kind of like a directional light but it doesn't have a direction it just applies to everything in your scene at a given intensity and that that is how we are lighting our scene that's it's that's that easy just environment lighting in our scene on our lighting scene window now the other important thing here is the fog so fog is as easy almost as easy as just clicking this button here that says fog and then choosing a color for it probably you can choose the density so obviously if it's a higher density fog it's going to look as if you're in a foggier place like it's going to sum the color to things that are closer to you faster than it would if you had a lower density fog and there's some other features here some of which i'm not terribly familiar with but for the sake of today's example just the click make sure fog is selected and then click uh make sure you have the right color for your fog so if you have like a ridiculous red color for your fog it's probably gonna look weird yep but you can see how you could do all kinds of weird effects just by adding these things together like if you want to have the effect of being in some sort of like i don't know noxious foreign world maybe you want like a purple fog instead of like a dark green fog or whatever that's you know super easy you produce a lot of very basic but effective effects that way um i find i think it was just that kind of the same nasty green color so to bring up this lighting screen all you need to go do is if you're on a mac i think a window is the same thing there's a window option in the top menu window and then lighting here and then settings and so this will bring you to all of the settings that are pertinent to at least today's example and so we're not using any lights in our scene that we talked about before um at least for the lighting of the scene itself now there are there are point lights being used for the pickups and i'll show you that in a second but what i wanted to illustrate was how we can sort of look at our maze as after it's been generated and so what we need to do first notice that before we were kind of um we couldn't really see our maze at a distance it was just purely dark green because of the fog it was adding green to that um geometry because it was so far away so i'm going to disable fog for now it'll actually remember your settings which is kind of nice so just going to disable fog and i'm going to actually add a directional light to the scene so i'm going to go here add a directional light and then i'm going to hit play again so now our scene is lit and um you know it looks a lot different a lot less scary and we can see our maze a lot better we can actually see that it is a collection of blocks it's all it's tiled blocks now we can't see into the maze because the maze has a roof so what i did was i just made generate roof an option in the script and so if you unselect that and then we try again now we can see our maze so this is what our mazes look like and so the cool thing about unity which i really love is just this ability to look through your scene independent of the actual game just to like help debug like it's hard to know if you're generating your maze correctly um when you're creating it in 3d you know in 2d you can easily just look at it but in 3d if especially in a first person game you can't really see it so being able to split your view like this the scene and the game and actually see oh my algorithm is working or it's not working it's super helpful so we can see that it is carving a maze for us it looks a little bit weird it's not a traditional maze in the sense that it has the you know the classic maze shape to it but it effectively functions as a maze and it works very well for its intended purpose um and the algorithm is incredibly simple and we'll talk about that so that's our maze i'm going to go ahead and revert all of the i think if i just reload the scene it should just revert it don't save yep okay so everything's been reverted all the lighting everything just gonna do a sanity check and make sure yep everything works perfectly well so anybody have any ideas as to where to get started if we were to implement a 3d maze the way i did it once before is you uh you put a bunch of x x's where you want something to be drawn in an array and then you loop through the array and draw instantiate the uh the balls yes so um create an array populate it with x's where you want data wherever you want something to be instantiated and loop over and instantiate everything it's exactly how it works um now in terms of actually creating the maze do you have any ideas as to what how would you go about implementing a a simple maze generator and there are obviously very complicated maze generation algorithms so like nothing terribly fancy but just a simple how would you make a maze or it's random so starting with the idea that we have an array right it's going to be a 2d array because we have two axes upon which we're generating things here even though we're in a 3d environment we don't need a 3d array we just need a 2d array because if there is a positive value for wherever we want to generate a block in our 3d or 3d maze we just generate a column of blocks we don't need to worry about a third dimension right our maze isn't like taking into consideration like multiple levels at which point we would need to maybe consider three dimensions i mean even still you can still divide those into separate 2d arrays of mazes we just have an x and a y so how would we get started what would we start populating the array let's say we have an array it's just a bunch of zeros right what are we populating with the array after after we've initialized it so i'm thinking maybe you would kind of start off with um just full of walls and then add like um corridors maybe so start with a bunch of walls and then add quarters that's exactly what we do um the algorithm is actually pretty simple so i'll try and maybe draw a little bit just to see if it can illustrate how this works by making sure that every um thing that you change is orthogonal every block every step that you move is orthogonal that will that will ensure that you start at one point and another point and those points will always be accessible to one another just by virtue of how simple the algorithm is and the orthogonality of it so if we start with um walls so um one one one one one one one one these are all in the in the distro these are all booleans because we don't need we only need zeros and ones so we're just gonna use true and false we don't need to use integers for that so this is our starting maze here um and actually i'm going to add another dimension because or not another dimension but another size just because the the walls always need to stay to be there these these are basically untouchable i'm gonna try and draw that as best i can right so we effectively have this as our working area for creating a maze right because we want this to be we want walls no matter what because we don't want our person to be able to walk outside the maze or see the outside world ever we want them to be locked in so we have all of these ones here these trues effectively and so all we need to do is start like at some random position let's say this value um at 3 2 or well it's actually technically it's 2 3 because we go we index at y and then x in a 2d array so we go 2 3 we go here and then we basically can move either left or you can move either left or right or up or down well we can't move both at the same time and why can't we move both at the same time let's say that we're let's say first of all let me say that we're let's say we're going to carve our way through the maze right so we're going to turn these ones into zeros but we can only move either we can only move orthogonally meaning left or right up or down we can't move diagonally so we can only let's say we have a an x move right and a y move and those can be set to but by default there's zero so we're basically saying where on this step of the generation are we going to move and actually technically it's direction because we're the way that we do it is via directions what's in front of you will have no wall and there'll be walls on either side of you except for where you came from yes so if you're here and they move down this is gonna be zero this is gonna be zero and so those points are linked right and then from there we're gonna move in in a given direction and so all of the let's say we move here all of those are going to be linked and so if we move here all of those are going to be linked just by virtue of the fact that we're moving orthogonally we will we can't create a maze that's unreachable because the way that um just by virtue of the fact that we're moving it now orthogonally now if we move diagonally if i were to move here right there's walls right here and then two spaces there that's not going to work because we can't access that we see it we're going to see a cube here and a cube here and we're going to see we won't be able to get move diagonally through walls right so that's why we need to ensure that we only move either in the x or y direction not both at once and so what the algorithm does is it randomly chooses should i move x or should i move y and should i move positive or negative so it'll do math.random equal you know two equals one effectively in the code it's random.value less than 0.5 because random.value in unity gives you 0 to 1 as a float so you say if random.value less than 0.5 which is a random chance between you know true and false effectively 50 percent moving x or moving y and then same thing but should i move in the negative or positive direction right so if i'm here i'm thinking okay let's see x move or y move uh it's again it's going to be an x move so i'm going to move either left or right okay so am i going to move either negative one or one step one to the right or to the left right so if it's negative one and that's going to move to the left right and if it's positive 1 it's going to move to the right so i mean that's the essence of the algorithm just loop over a bunch of times whenever i move to another tile turn that into a zero so actually this becomes a zero uh change the color so this will become a zero right so that's now an empty space and in the code that instantly teleports the character to that space two so we know that our character is always going to be in an empty space because he gets placed in the first open space that gets generated in the maze and so let's say x move is equal to negative one on this iteration so let's say we're looping until we've cleared x blocks so i want to clear it let's say i want to clear five blocks so two clear equals five right that's how many blocks when we've cleared that many blocks we're done with the maze generator right so cleared one so our current counter is one so x we get flip a coin we're moving to the x direction by negative one so we move um two here and then we turn this into a zero now this implementation of the algorithm moves one step at a time and so because of its randomness what this ends up doing is it produces very large chunks of deformed space just because the crawler is just constantly moving around kind of like haphazardly so what's a refinement that we can make to this algorithm to make it look a little bit more like corridors or like hallways just keep going until you hit the outer wall you could do that yeah keep going until you hit the other wall um the result of that you mean hit the like the side of the maze yeah because well if you did that it would effectively just be like it would kind of be it might work in some cases but it will be very long hallways and not a lot of like turns or anything like that so the result what we actually want to do is when we flip a coin and we say x move or y move we want to also say times to move we want to create a new variable called number of times to move effectively right to move and then we just set that to a random number between one so we're going to move one tile or the size of the maze minus two right taking into consideration both walls right so let's say we get the let's say we let's say we did x move minus one and it and we only got two move equal to one right so we only move here we move once in this direction so we've got two spaces and then let's say we flip a coin again and then we got y move right positive one and then two move we got two right so we're going to move two directions in the yaxis by one so what this is a result of us going down here so we go zero and then zero right and so the effect of this is that we move um we can move in more than just uh one block at a time and avoid sort of random like haphazard weird organic large room aesthetic that we want if we want like a hallway gridlike dungeon looking like room generator right now there's a caveat to this and that is if we start here for example and then we want to uh let's say we flip a coin it's x move but it's positive like positive four right we can't obviously move four tiles to the right because one it'll go into our walls on the outside and two it's actually beyond the bounds of our array so we need to clamp that value down when we add one to our value to wherever our x we have to basically keep pointers right we keep pointer to whichever tile we're currently at we need to keep uh when we actually go to the next tile in our step we need to clamp that value within the range of our walls so we need to clamp between one so because we don't want to be at zero we want to clamp it between one and maize size minus minus two actually because we want to make sure that we don't go any farther than the this one here does that make sense this this is how that is effectively how our generator works it's a step beyond just the move one block at a time just because the mazes look way too empty and weird with this approach where you're moving in a direction and for a random number of tiles as opposed to just one tile at a time you actually get pretty nice looking simple mazes this isn't how like actual maze generation works um for mazes that you would see in like an actual maze that you do on like a crossword puzzle book or a maze book or something those are more complicated um but this solution works well it's very fast and very cheap and actually pretty simple to understand so any questions as to how the maze generator the algorithm at least is applied to our 2d array works all right cool that's the um that's basically the gist of it so we're gonna take a break here um for about five minutes and then as soon as we get back we'll dive a little bit more into um sort of how the character controller works and the pickup and a few other aspects of the game all right welcome back to lecture nine so before the break we were talking about uh the way that we implemented procedural maze generation so a fairly simple uh algorithm that creates this sort of hallway look where we can easily get lost but they aren't technically mazes in the traditional sense like you might have seen growing up in puzzle books and such another pitch for cat like coding because articles are amazing he has another one on how he did a maze generator and in this one beyond just regular blocks oh i'm sorry i didn't have the uh slider on the on the thing so this is a screenshot of another article from cali coding where he talks about how to make his own maze generator and the cool thing about his is that he has a bunch of different geometry involved in the scene it's not just blocks he has doors and windows and other things and his algorithm is a little bit different than mine and produces some pretty interesting looking things you can see here also it has a view of the scene sort of superimposed on the actual scene which he does with a trick using two cameras so also here's another um maze slash dungeon generator article that i really like where he creates sort of like dungeons and dragon style generators and this is sort of pertinent to my interests as a developer because i really love roguelikes and dungeon generators and rpgs but he goes into extensive detail on how to make a really nice and efficient 2d maze slash dungeon generator that produces really nice looking dungeons as you can see here it's got a very variable layout lots of corridors and rooms and stuff like that so implementing something like this in unity would be really cool and there's a plethora of generators and assets like this that'll do the same kind of thing in unity available in the asset store so you don't have to make this yourself most the time you can create you can just go find either free or paid assets that will do all this for you and save you a tremendous amount of time and much of them are also very customizable too so you can tailor the generator to fit the domain of your game so we saw how the lighting works in our game we've seen the maze sort of how it's generated what it looks like we have not taken a look yet at the character controller so we'll briefly just take a look at that it's actually incredibly easy to do in unity at least to get something fairly basic up and running the way that we get a fps controller in the case of our game is unity has which i alluded to before a set of custom or a builtin standard asset packs that allow people getting used to the game engine or i'm just trying to bootstrap their game up and running with some very basic components very basic things that are super helpful for um just to started getting your game running so actually we use the prototyping standard asset pack for our pickup we use the um characters one for the character controller the fps controller so if you if you're in a fresh project and just go to import package and you import this characters thing here it'll import it into your game so you can immediately use the prefabs that it gives you to create a character object so it'll by default just put it in your assets folder um underneath standard assets and then characters and then there's a first person folder and within the first person folder there's a prefabs folder with which has the fps controller game object and so all you need to do is just drag it into the scene and then that becomes your um default camera so it comes with it comes with unity correct that's just a standard asset uh it's always in the the fps controller will always be in the so you have to import it first you have to import the um the asset package the characters package once you've imported the characters package you'll go into standard assets in your assets folder there will be a new folder called standard assets within standard assets you'll go to characters then first person and then prefabs and that's where you'll find the fps controller yes no problem so the fps controller if we take a look at it we talked about it before briefly but effectively it's just a capsule collider which is sort of defying physics because it's kinematic kinematic with gravity applied to it and it has a camera sort of on towards the top of it where the head is to simulate the perspective of somebody from first person view and there's some programming involved that allows you to control it with the keys and the mouse to control the camera's rotation with the mouse and the position of the collider with the wasd keys and if you want you can dig into the actual script for it too they're all built included with the standard assets pack when you import that into your project it comes with all the scripts that make all that possible i haven't dug through all of them in too much detail but it's all there for you if curious as to how it works and so if you want to get just a simple you know fps controller in your game the character in your game to walk around and you know play a first person game it's takes about a minute to get up and running now there's a lot of customization that you can apply to your character controller to make it not just the standard basic character right so you can set a walk speed you can set a run speed you can set jump speed you can uh you know you can set the sensitivity of the mouse look on the uh on the game on the fps controller you can apply what's called fov kick which means when you're sprinting which it allows you to sprint by with pressing shift which multiplies your speed um it'll actually um uh i think it'll expand your depth of field a little bit to make it look as if you're kind of like claustrophobic right like things kind of like um go out and so it looks more narrow and it kind of gives you that look as if you're like sprinting down a path and you can set just how much it increases by you can set the curve of how that is applied here so this is one of the components that unity allows you to to do is there's a curve object and you can use this curve to influence various things in your game i actually haven't used it much myself but if you're looking for something to apply a curve to unity has an interface for making that visible within your inspector head bob which means when i walk should should the camera kind of like go up and down and when you do have a head bob like what's the curve look like so here's another curve this is the sort of what the head bob looks like kind of a sine wave but a little bit distorted and a few other things so for example footstep sounds maybe you don't like the sounds that come by default with the controller so you give it your own footsteps sounds super easy to do just drag new sounds here jump sound and a landing sound to more sounds that you can add to it and that'll allow you to customize most of the feel of how your character moves around in terms of just a basic fps controller and so just by applying those very basic things customizing a little bit we got lucky with this maze it just means that the maze went all the way around and then looped right back to where we were and ended there so this is that's that maze okay but um i'm gonna go ahead and turn up the sound you can hear the footsteps right along with the creepy whispering but the footsteps are just provided to us with us uh provided to us by the fps controller and again you can customize those to be whatever you want and so this gives you the ability to walk around in your scene from a first person view it doesn't really give you much more than that um in order to do like an fps where you have like maybe a gun or a weapon or something you need to program some more things and it's a lot more complicated but for just basic navigation of a 3d scene that's a great foundation a great way to way to get started so any questions as to how the fps controller works there are other controllers too there are third person controllers so if you want um to use those they don't come with a camera based on my experimentation they don't actually come with a camera by default so i think you have to parent a camera to them in the way that you want for your game like for example some games have the camera super high above your character while you're walking around and some of them have like a like behind the shoulder look almost like like fortnite or gears of war like really close to the character and then some kind of have like in banjokazooie you could be walking up a mountain and so the camera's kind of like perpendicular to where you are and sort of like follows you around so camera programming for 3d characters is a little bit more complicated than it is for first person games and so that's why i imagine it doesn't come with a camera by default so it can be a little bit more complicated but i do believe there are a lot of assets on the asset store that can help bootstrap you for getting a programmatic camera setup going for your character in a 3d third person view yeah when you're walking around your maze like occasionally you're like clipping the wall and kind of seeing like yeah yep uh that i believe that's the result of the collider being a little bit too big so what um what he said was that they walking through the maze you can kind of clip through the wall a little bit see if we can actually experience it yeah like right there uh yeah and that's the i believe that's just the the camera or the collar the collider being a little bit too large and so it's probably like get rid of that all together just by shrinking the collider a little bit um just a detail that i didn't iron out but you'll see that a lot of games actually a lot of games have like clipping that you can get that you can observe depending on how they've programmed the game um but yeah any other questions as to how character controllers are work and how the import process works and how to get it in your scene okay cool yeah it's super easy again here's what the fps control looks like capsule collider with a camera and then the third person controller by default they give you a pretty nice looking model on the left side there so that you can experiment with it and they apparently give you an ai one as well so you can test ai in your scene with it but i haven't experimented too much with that to vouch for how well it works so an important aspect of today's example is that we've gone from having just one scene to having two scenes so i wanted to illustrate how we sort of move between the scenes a little bit and also i realized we didn't really cover the dungeon generator in code detail but notice that i have exposed a lot of things here a floor prefab wall prefab ceiling prefab these are just the the cubes that are textured to be our floor walls and ceiling we can just click and drag them from the inspector into our scene onto the components there we have a character controller reference here so that we can place the character controller in our scene when we've generated the first block we can basically take the transform and set its position to whatever that xz is and then a floor parent and a wall's parent so the reason that we have parent objects actually which we didn't look at before oops i've lost track of where my there it is the reason that we have parent objects here is because when we instantiate all of the cubes in our scene just sort of you know just instantiate them without really thinking about it it ends up basically i'll show you here um well first of all i don't know what this is oh i think it's that's interesting oh because i clicked on the floor parent right okay um so you click on the walls parent actually i didn't do that yet but it'll actually show you where all of the all the objects that are parented or that are dependent on that parent so the floor parent here see how many floor blocks there are there's quite a lot excuse me there's a lot of floor blocks here and in the walls parent there's even more there's a lot of walls and ceiling blocks and if we just generate those without assigning them apparent it'll just fill up our hierarchy there a very messily and it makes navigating our scene um during debugging very difficult right we don't need to see that we have a million clones of the floor or the the ceiling blocks or the wall blocks and so what we do is we just take the all of the clone blocks and we just parent them to an object and when you parent something to an object you get that little drop down like for example this first person character this fps controller is the parent of this first person character as those are two separate objects that both comprise the fps controller effectively a parent is top level and its children are therefore within it within this little arrow here and it's collapsible all of the things within the play scene for example the play scene is the parent to all of these it's sort of like a folder hierarchy type of thing and so if you want to clean up your scene if you're instantiating a ton of things just effectively containerize them by putting them into a parent object and so we do that in our game with a function called create child prefab and so create child prefab does is it does an instantiation as normal right creates a prefab instantiates it gives it a position xyz quaternion.identity because we don't want to apply any rotation to it but myprefor prefab.transform.parent equals parent.transform effectively linking our um we're assigning the parent field of our of that prefabs transform to the parents transform and that has the effect of basically linking them together in a parentchild relationship and that will allow us to collapse and expand a list when one parent has a bunch of children we can expand it and contract it in the hierarchy view and save us a lot of save as a bit of a headache in terms of navigating our scene when we instantiate a lot of things which is fairly normal um so the actual may i'll go over this fairly quickly it's a fairly simple algorithm and i've talked about it on the screen we don't have a ton of time but basically we go z to x the reason that we go z to x is because in unity z and x are sort of like the ground axes and y is sort of like the up and down axis and so we don't want to instantiate we're not really worried about navigating the yaxis during our maze generator because all we're going to do is instantiate four blocks along the yaxis during that phase right so we're basically taking our 2d array and we're iterating over it x y and then we're mapping that to unity's z x or x z if that makes sense because notice the uh like this is our ground right so where this transform is you can see the ground how this is x the blue is a z and y is this axis here we're generating we're effectively only concerned about generating on the ground and then when we generate a wall we just generate it four blocks high on the y we don't think about the y so that's why x and y for our 2d array but x and z for applying that array to unity's 3d coordinate system does that make sense okay so we're iterating over z and x and then we're indexing into our um map data z and x which is effectively the same thing as y and x and then we are creating a child prefab if map data zx so recall if so recall that our map data is a 2d array of booleans right and so if we have map data zx equal to true that means there's a wall there it means that there's a true in our array so we should instantiate a wall at that location so we create three wall prefabs assign them to the walls parent so that they get containerized within there so they don't clog up our hierarchy view and then let me see here and so if we don't so if we've if we've gone through our maze right if we're generating our maze and we get to our first tile that's actually not a wall so it's an empty space so basically the else here so if map data zx is not true it's going to be false so if that's the case and if not character placed so character place is just a boolean it's a private bully and we don't want this to be visible in our inspector there's no purpose for it to be visible in our inspector this is just a boolean for us to use in our script so we set that to false by default because we haven't placed our character yet but once we when we generate our maze we have to make sure we put our character in a spot that there isn't a wall because we'd obviously don't want him trapped in a wall or clipping through the maze right so if not character placed we're going to set the character controller's transform we're going to set its position and rotation which is a function um we're going to set it to x and then y one and then z and then no rotation so quaternion.identity and then set that to true so therefore this will never be called again so this only gets called on the very first empty space that we go through our maze and that's it for that um when we no matter what we do um whether there's a wall in our maze or not we're going to want to generate a floor and a ceiling at that space so that's of course assuming that generate roof is true which recall we made a public boolean in our inspector so that i could debug and show you guys what the maze looks like from up above so if generate roof create a child prefab for ceiling prefab at x4z so a bit higher up and then no matter what always want a floor so create a floor prefab at x 0 z so down below and our character controller gets placed at recall x1z so just above the floor the assignment is actually part of the assignment is generate a hole in the floor and if there's a hole in the floor and the character falls through the floor of the hole should get a game over right so you're going to create a game over scene you're going to need to transition to that scene and then we're going to need to check to see whether the character's transform has gone below a certain amount right that's all fairly easy stuff to do but you'll look to do some of that in here and then the actual maze data function is here i won't go over it in detail but it's the algorithm that we talked about before where we choose direction to move randomly and we choose a random number of steps to move clamp that value within the constraints of the maze and then set every tile that we explore to false and that has the effect of creating the maze and then we just return that data back to our function it's just a 2d array notice that in unity sorry in c sharp to create a 2d array it's a little bit different than in a lot of other languages it has its own syntax for that you have the array syntax that you're probably familiar with but then you also have this comma and that comma is to designate that there are two arguments to that um index syntax here just means there an x should go here and y should go there basically um or a y x and that's 2d array and you can make it you can make it as many degrees as you want to just add more commas to it and notice that to actually allocate the memory that we want for that 2d array newbool may size may size so our maze is always square shaped same same and you could easily make this mace x maze y if you wanted to to make it like rectangular so you just need to have two public variables instead of one and all of this is fairly visible through the inspector too and our dungeon generator you can see i made a tiles to remove 350 so that means that our maze is going to cut out 350 tiles and as soon as it cuts out 350 tiles it's done and then our maze size is 30 by 30. so that means there's going to be 900 tiles in our maze so you can tailor this to whatever you want in order to produce sparse or denser mazes to your liking so any questions as to how the code for that works more or less so now we'll actually get to the scenes part of it and so transitioning between oh yeah yeah um i'm thinking like you know for like a smaller game like that like that works great but like for a larger game wouldn't you want to model the walls as like 2d kind of objects and like the ceiling instead of like a whole cube oh yeah so for a small game um is it ideal more ideal for the walls to be rendered as like one con one discrete object as opposed to like several cubes yeah absolutely that's 100 true and actually minecraft is an example of this sort of idea that you think would work but they actually consolidate all their geometry after they've generated it in this way and produce like um models that are more optimized like that you think that you're interacting with this world that's a bunch of these little blocks all separate but it's actually one big piece of geometry and then it dynamically figures out what you're hitting and removes and adds blocks as needed and there's some uh some cool videos on youtube as to how to do this in unity too which i looked at a long time ago and it kind of shows you you can actually dynamically create meshes and vertices and stuff in unity and then create objects that way which is really cool but that's a little bit more on the advanced side but yeah absolutely for an actual implementation of this a simple but more efficient way to do it would just be to have like yeah one solid large wall object that's like as tall as you need to be and maybe as wide as you need it to be for um one character and have that work but for simplicity's sake to illustrate the algorithm um we were just using the cubes yeah exactly but yeah good point that's a 100 true all right multiple scenes so the way that we do this so i'm going to go into my text editor whoops so the grab pickups script so grab pickups is a component that's attached to the character controller because he's going to be picking up pickups and what the grab pickup script effectively does is the character controller built in collide has this function that you can define for it called on controller collider hit where anything that collides with the controller's collider will trigger this callback function and you can grab the information about the um object that you collided with and then perform some sort of logic on that and so it's actually calling this function every single time we uh collide with any of the tiles or the blocks in our scene as well there's just no logic to account for them so it's just effectively an empty function call but if it's the case that the game object has a tag of pickup which we've set in our ed unity editor and i'll show you how to do that then we should play a sound from our pickup sound source and then we should using we actually use this in the last lecture but only within the same scene we're going to call scenemanager.loadsceneplay and you need unity engine.scene management using unityengine.com at the top of your script in order to use this and load scene effectively just like we'll literally just load a scene by its name and we're doing that in a couple places so we're actually doing it there but remember we had the title scene which had the same sort of thing you press enter and you load a you load the play scene right so this load scene on input component that i created is attached to a text field in the title scene and all we're doing here is in the update we're just saying hey if update if input.getaxis submit is equal to one then cmanage.loadsceneplay almost almost the same kind of almost the same code only in this case we're querying unity's input it has a global input manager get axis so it has several axes is how it defines it different like methods of input and then it defines them by keywords so in this case submit is a keyword and you define you map those keys or you map those keywords to specific keys and input sources on whatever platform you're targeting in this case submit is synonymous with either enter or return depending on which platform we're using and it could have other meanings if we're exporting this to xbox or for exporting it to the web or for exporting it to a mobile phone there's a lot of different ways it changes and so the way that it checks is it'll be zero or one specifically so we can say if input dot get access submit equals one um c manager load scene play and it won't let you do if input dot get access submit because it's explicitly expecting an integer and it'll throw an error if you're trying to use it like a boolean so we need to use this equals equals 1 to test for equivalence and that's all we're effectively doing there now the interesting thing is when we reload the scene for the pickup right for the maze there's a soundtrack playing in the background and we want the soundtrack to constantly be playing the same thing and to loop right the sound effect we don't want it to start up immediately again and start like from the very beginning again we kind of want the seamless sort of feel to it and so how do we think we can solve this problem correct so any ideas as to how we would do this well so whenever we collide with the pickup we reload the scene completely from scratch and so when you reload a scene it destroys every game object in the scene including all the objects that have audio sources attached to them and so when it reloads the scene it reinstantiates all the game objects in the scene including those with audio sources and retriggers their playing so what we want to do is prevent this from happening just have a counter and when you get the first pickup then it goes to one and then you say if less than one play the sound um that will have the effect of so you're saying have a counter and when true so have a counter or true false when you load the scene it starts the music but what happens when we reload the scene from scratch and the audio that was playing gets deleted can you transport certain objects between scenes can you transport certain objects between scenes effectively you can there's a function called don't destroy on load actually so with that it's a unity function which allows you to preserve an object as it is between scenes so uh if you don't want your scene with the music to or your object with the music to destroy itself and then reinstantiate unload well technically just don't destroy itself um just do don't destroy unload at the game object and so this don't destroy we apply this to our audio source our whisper source it's called in the scene the only problem with this is if we reinstantiate or if we don't destroy on load this object it's going to persevere but when we reload the scene it's going to instantiate a new one so what's the effect of this going to be gonna have two audio sources playing at the same time what happens when we do another one we have three audio sources playing at the same time so for every time you go to a next level you're going to add the same audio track to the scene it's going to be very annoying very quickly the way that we avoid this happening is by making what's called a singleton and so what a singleton is is a class that can only effectively be instantiated one time right and um we do this by creating a static variable here called don't destroy um uh no we called instance which is of type don't destroy so it's this component here right and so the don't destroy class as a whole has this static variable called instance and we set it to null by default when we haven't instantiated a don't destroy component yet and what this ensures in our scene by the logic we have in the awake function awake is almost the same thing as star just means whenever you can you can pause an object and it'll awake from its pause state but awake also gets called when an object gets instantiated so if the instance is set to null on awake um instance equals this so this don't destroy so whatever this is being called from this this don't destroy will be the instance whatever the first don't destroy component is in our scene the very first maze that we generate the sound source instance will be this and then we set don't destroy on load for the game object that is holding that don't destroy don't destroy component right that audio source but if the instance is not equal to this so if we've woken and this is level two for example instance is going to be set to the um the don't destroy a component on the don't destroy unload object that we created in the first maze right because we did this logic here and so it's going to try and instantiate a second don't destroy a component it's going to another sound source but instance is not going to be null instance is going to be equal to that first object so we say if instance is not equal to this destroy game object so this is going to be from the standpoint of the second um just don't destroy that got created basically the singleton will persist indefinitely yeah indefinitely upon its first instantiation and there will only ever be one singleton this is a very basic very common pattern in software engineering for ensuring that you only have one object of a given type present throughout your entire project but this is how we prevent multiple sound sources from being instantiated we always ensure that only one object of that with that component gets instantiated at once and any future instantiations of that object get destroyed immediately assuming that they aren't that first object if they are that first object instance will not instance will equal this and so it'll still skip this part and so it'll stay alive so any questions as to how the persevering through multiple scenes works for their sound source okay um that's how we get multiple scenes so far we looked at fog already but i have a few screenshots here to kind of help illustrate what fog has looked like over the years so fog looks pretty unconvincing in this screenshot this is turok for the n64 it's just kind of looks as if you know sort of at a certain distance a very dense sheet of fog has appeared and you can actually make this happen in unity by setting the there's a curve a fog curve that i believe you can manipulate that while effectively the algorithm that determines how the color gets summed to things far away is very fast as opposed to gradual or linear so you can make it just like exponential effectively and make it look as if the fog is incredibly dense and starts almost at a very fixed spot and have the rest of this area sort of in front of you look normal here's another example star wars the empire one of my favorite n64 games which has sort of the same look and so in this area you can see fog is very distinguishable very artificial looking because it's very tinted in this case it looks very blue in this case it looks very like pale blue this is silent hill and silent hill looks realer more realistic but um kind of the same thing at play here you have a very pale gray metallic blue color and the density in this case is very high the density is much higher well maybe close to as high as it is in our game that we should that we're showing today um but it's effectively the same thing just with a different color and they used it to great effect in here not only for um sort of this aesthetic to make you look as if you're in some sort of desolate town but also to dynamically load objects or to prevent rendering objects that are a certain distance away and to optimize performance on the hardware that was severely limited at the time which was playstation 1 which is a fairly weak console and then here is shadow of the colossus for ps4 which just came out not too long ago and we can see fog is still being used but it looks photorealistic and there's probably a lot more that they're doing they probably have several layers of fog they probably have textures and um you know transparent objects that are simulating fog and a lot of more complicated things like that fog that only hangs at a certain distance so it looks like fog going over the lake there's a lot of things here but it's the same idea and they probably have the same sort of foundational base fog present throughout the scene and then here's our game just to show how it looks like you can barely even see it but it does give you this sort of like lost in a really dangerous maze feeling which and it's super easy to do and it can it can save you performance and it can add a lot of aesthetic to your game and so the last big thing we'll talk about today is unity2d actually so i'm going to go back into questions about fog i know that was a pretty high level overview i've already looked at fog we looked at how it applies in the settings any questions as to how it works or how to get it working unity okay so we're going to go ahead and look at our title scene and so we looked at this earlier briefly but i'm going to go ahead and show you the components so i'm going to take a look at our canvas if you double click on something you'll zoom out and so it'll automatically detect sort of what your resolution is and scale the canvas accordingly in your scene view there's a 2d button here i'm going to go ahead and go to my default layout i'm going to click on the canvas notice that it shifted things a little bit because now i have a larger window that's going to be rendered to i'm going to click on the canvas and then i'm going to go to 2d mode and then notice when you click on 2d in 3d mode you go like instantly into like seeing it as if you're manipulating it in a 2d engine versus a 3d engine and then going back to 3d now it's a threedimensional plane that you're actually looking at so in 2d mode you can easily sort of navigate it right click and drag it around i'm going to go here like this and these are very simple components that you can just interact with as a gui now the main thing that you need to get any of this to work is the canvas which is here so if you right click and then go to ui you can go to canvas if you want to or you can just add any of these things that you want and it'll automatically add a canvas for you because a canvas is necessary for all of the unity ui rendering stuff so if i were to just add a text and on an empty scene it will just create a a brand new canvas and an event system the event system is just how unity talks to the canvas and the all the ui elements of your canvas given mouse and keyboard input and stuff like that it's nothing that you necessarily have to worry about or use but the canvas is the sort of overall container for all gui stuff that you do now if i click on the the title text or the enter text notice that they are children of the canvas so they are within the canvas the canvas is their parent the title text i can move it around notice that it snaps right it's got some nice snapping functionality i can set it up there it'll snap to the top it'll yeah it's pretty handy you can scale or scale the bounding box it doesn't scale the actual text but the notice that i do have like right justification centering left justification those sorts of helping the sort of features i can increase the font size via slider right so i can immediately see without having to edit some code and then reload the project what changing some of these values will look like i can easily change the color in real time so i can get a sense of how that looks if you wanted some sort of slimy dread 50 look i guess and you can also assign materials to it as well which is kind of cool which i haven't explored too much in detail but you have that option if you want to give it a material instead of a instead of a color materialed font because ultimately all this stuff is still 3d but unity presents it in a way that makes it look as if you're interacting with it in 2d it's pretty nice i mean when you hit play it's going to open up to that yep and then how do you transition to the rest of the game so the transition to the rest of the game is in the load scene on input here so this script that we looked at earlier so this is assigned to one of those text labels so i just gave it to the i forget was it the i think it's the enter text so i gave it this load scene on input just because it's a it's the enter text it seemed appropriate uh you could put it on anything in the scene it doesn't matter as long as it has this update function which then has this if input dot get access submit equals one and then recall the go into the project settings input all these axes here are defined for you automatically and then you can choose what they map to but submit as you can see positive button is return so if submit is equal to one repress return it'll be equal to one effectively and it gets mapped to other buttons depending on what input sources you have on your device but you can check what it is on your computer just by going to axes in your input manager so it's once again edit project settings input and then you can see all the axes here the 2dc that's a whole that's just a scene in itself it's a scene in itself completely as a camera so we are um the camera renders the thing about canvas is it's kind of separate from the camera so it gets rendered onto whatever the camera is rendering separately but the camera in this case what i've done because if by default we just render the camera and the ui it's going to look just like this it's going to look like the sky with dread50 and press enter that's not the aesthetic that we want so i take the camera and then you can give it a background so by default the background is that sky is the sky box and so it's set clear flags clear flags are same thing as background so whenever there's no geometry or anything um clear what this clear color clear flag this gets drawn to before any geometry in the scene basically excuse me so clear flags solid color in this case and then just black using a color picker so super easy super nice um and then this ui this canvas will get drawn on top of this camera so that's what produces the sort of combined effect of having the the ui text and the black background and then that enter text having that component that checks for the submit input because that's what enter and return map to that is um that is what lets us transition from uh the current scene to the play scene and so there are a lot of other cool features that these like labels and such have for example being able to set its anchor position so depending on what device you're shipping to you might want you know you're going to have multiple screen sizes and screen resolutions so you can say i want this label to always be at the very top middle of my scene and i can do this by clicking this little box here which is the anchor point selector and then just clicking that and so that will always anchor dread50s text to the top middle no matter what our resolution is it'll always be there and there's a lot that you can do whoops on top of that and you do that with any ui component just relative positioning depending on the resolution and the nice thing about unity 2 if you go to game you can actually choose sorry in the second menu you can choose a lot of aspect ratios so 5'4 doesn't look that great 4 3 doesn't look that great 16 10 16 9 and then standalone so standalone is the default export size of your platform but you can choose you can have it you can test different resolutions and you can also add more to you can add a fixed resolution if you want or an aspect ratio and do a lot of cool things that way so you don't have to necessarily test it physically on different devices although it's very good too so you can make sure that you're not blowing up your hardware but you have that option so any questions as to how unity2d works and how the canvas works or how we've gotten the simple ui to work part of the assignment will be and we'll take a look at that now actually so assignment nine we talked about this already about the gaps on the floor but this will be part of you know the maze generator right because that's where we generate ultimately or the degenerate the maze instantiator the actual part of the maze generator that creates the physical maze but create gaps in the floor and then when the player falls through approximately two blocks below which so you can set make check the transform is the y positions less than a certain amount right which should be should be less than zero i think it's based on the top part of it um then you should transition to a new screen that says game over so create a new scene very similar to the first scene that we looked at which was just the title screen and you can probably copy most of that but that scene should say game over and then pressing enter there should load the title scene right and then lastly add a text object to the place scene that just keeps track of how many levels you've navigated through and you can probably do this with some kind of static variable but any solution that accomplishes it is welcome but all together all pretty easy pieces to put together that was this week which was dread halls and our first foray into first person games next week we'll look at portal it won't look necessarily this good but it'll look similar to this this is a screenshot from portal itself but we'll look at how we can render to textures how we can cast rays from our character our first person controller how we can actually make it look as if we have a weapon or a gun or portal gun which is you know not too difficult you just have to parent basically a model to your first person controller um and then when we walk through a portal how do we transition from the other two from one portal to the other portal so just a uh you know teleport your transform to another position but that was that next week is portal and i will see you all next time
