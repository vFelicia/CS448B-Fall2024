With timestamps:

00:00 - Improve your Flutter skills by building a Google Docs clone.
00:04 - You'll also learn more about Node.js, Express, Sockets, MongoDB, and more.
00:08 - Rivan Ranawat is your teacher.
00:11 - Rivan has created a bunch of popular tutorials and he is an excellent teacher.
00:15 - In this tutorial, we are going to build Google Docs clone using Flutter and Node.js.
00:19 - This course is designed for beginners in Node.js and no prior knowledge of JavaScript is required.
00:24 - We will learn how to authenticate users with Google,
00:27 - keep the user logged in, create REST APIs to display and create new documents,
00:32 - build a powerful routing system to share link of our documents,
00:36 - and establish socket connection to allow users to collaborate with each other.
00:40 - They can type, color, bold, italicize, change size, and much more simultaneously.
00:45 - Pre-requisite for this course is having a basic knowledge of Flutter.
00:48 - For state management, we will be using RiverPod.
00:51 - Before we get into this video, I'd like to invite you all to our Discord server.
00:55 - Link is mentioned in the description below.
00:57 - We will start off by creating a Flutter project.
01:00 - So we'll go to the Visual Studio Code and in the empty project here,
01:03 - we will click on Command-Shift-P and then click on Flutter New Project option.
01:09 - Then we are going to generate a application.
01:11 - So we can click over here and then we need to assign the folder where we need to store this.
01:16 - So we can go to the desktop and here we will just create a new folder called Docs Clone Flutter.
01:23 - Then click on Create and then we can select this folder to create the project in.
01:28 - Now we also need to name this project.
01:30 - Again, we will just name this Docs Clone Flutter and then click on Enter.
01:36 - Here you can see Flutter Create is being run and here you can see our project is ready.
01:41 - We need to start running it.
01:43 - Now just to test our application, we can obviously run it.
01:46 - So I'm going to run it on web.
01:48 - I'll just click on Run and run it without debugging.
01:51 - Let's wait for it to know if we have successfully set up our application.
01:55 - So our application has started and here if you see it, our web version is running.
02:01 - Great.
02:01 - Now let's try to remove everything, all the boilerplate code.
02:04 - So I'm just going to grab all of it from here, remove it out, all the comments from here.
02:11 - And here I'm going to create a new folder called Screens.
02:15 - Here we will create our very first screen called the Login Screen.
02:18 - This Login Screen is going to be very simple.
02:21 - It's just going to consist of a single button in the center, which is the Google button.
02:25 - So let's import Material Dart, then create a stateless widget and call this Login Screen.
02:32 - Here we are going to return a scaffold and let's just return that so that we can see
02:38 - an empty screen and know this is working.
02:40 - We'll go to the main.dart file again and here import Login Screen.
02:47 - We also remove this comment and let's see if, and you can see a blank white screen showing up.
02:53 - Great.
02:53 - That's exactly what we wanted.
02:55 - Now what we want is in the center, a button showing up with a Google icon here and then
03:01 - a button and a text saying sign in with Google.
03:04 - So to do that, we will go to the Login Screen and in here, in the body, we'll pass in a center
03:10 - widget because we want it in the center.
03:14 - Then we will have a child and now we want an elevated button with an icon, as you've
03:19 - seen in the picture already.
03:20 - We're not going to use the normal elevated button.
03:23 - No, we want elevatedButton.icon because we need to pass in an icon.
03:28 - It's not necessarily an icon because icon here accepts a return data type of widget.
03:33 - We can pass in a widget.
03:35 - It doesn't necessarily have to be icon or icon data.
03:39 - So here in the onPressed, I can just pass in an empty function.
03:44 - We look into that a bit later.
03:46 - Here, now we want an icon, so to get the icon, you can go to this website.
03:52 - I'll mention the link in the description below.
03:54 - This is my GitHub repository where you can find all the source codes for what we are
03:58 - doing it today.
03:59 - So to get this, well, we need the DocsLogo.png as well and the gLogo, which is Google logo.
04:05 - We want both of them.
04:06 - So let's install them right away.
04:09 - Having installed both of them, here we will create an assets folder.
04:13 - This assets folder is going to contain all of our assets.
04:15 - If you want, you can change the font style.
04:17 - So you can bring in that here as well.
04:20 - Now in that assets, I'm going to have images and in those images, we're going to put in
04:24 - our two images, which is this.
04:26 - I'll just drag them in the images folder and here we have it.
04:30 - Cool.
04:31 - Now we will go to the Popspec.yaml file so that we register as an asset.
04:35 - The file so that we register the images that we have in our application.
04:40 - So let's just uncomment these three lines and your pass in assets slash images and then
04:47 - pass in Docs-Logo.png.
04:53 - Similarly we are going to do it for gLogo as well.
04:57 - So we'll just pass in g over here and here you can see it says gLogo 2.
05:02 - So we can have gLogo 2 but you'll get 1 because I already have that image stored in my app,
05:07 - in my finder or the search explorer.
05:11 - Having this, we can stop our app and restart it because that we can't restart it right
05:18 - now but after fixing this error, we have to restart our application because you made changes
05:22 - in Popspec.yaml file.
05:24 - Now here in the icon, we have to pass in image.asset and pass in the asset name, which is well
05:32 - assets slash images slash gLogo.png.
05:39 - Then in the label, we are going to pass in a text.
05:43 - So we will have constant text saying sign in with Google.
05:50 - Then I'll just put trailing commas so that it formats the document well enough.
05:56 - Now let's try to run our application and see where we've got.
05:59 - And here you can see it's saying unable to load asset and the reason for that is here
06:04 - we need to pass in gLogo 2, not gLogo, so I'll just save this much and here you can
06:10 - see a big button showing up.
06:12 - Now the reason this button is so big is because this image size is pretty big.
06:18 - Now we need to reduce this image size.
06:20 - So what we can do is in the image.asset, just pass in the height as 20.
06:26 - After we do this much, you can see it's pretty small.
06:29 - Now after having the appropriate height for this image, we just we still need this icon
06:33 - to be bigger and it should be white in color and the text should be black in color.
06:38 - So let's make those changes pretty quickly.
06:40 - For the style, we'll just pass in elevated button dot style from and then we will have
06:46 - to pass minimum size.
06:48 - The minimum size is going to be constant size 150 comma 50.
06:56 - So this will represent the width and this will represent the height.
07:02 - Now you can see it's showing up good enough.
07:04 - Now we just need to change this to white.
07:06 - So we'll just pass in the background color and the background color is going to be colors.white.
07:11 - Now instead of writing all our colors like this, normally what we can do is in the lib
07:17 - folder, create a new file called colors dot dot and as in when we get a new color, for
07:22 - example colors dot white or colors dot blue, we can just save it in here.
07:27 - So how I'm going to save is constant k white color is equal to colors dot white.
07:37 - Also import the material package because we are using colors and then we can take this
07:45 - pass it in here and import the package.
07:50 - You can see it works well.
07:51 - Now the reason we need to do this is because suppose we want this docs clone to be changing
07:59 - the theme.
08:00 - For example, this needs to change the theme if the background color here changes to black
08:04 - because we just need to match this with the background color.
08:08 - So to change it, we can't obviously go around and change it every time from here.
08:14 - We if we have some constants over here, we can easily change their value.
08:18 - For example, if I wanted black from just one file, I can change the color and it changes.
08:24 - It's pretty cool, right?
08:26 - So we'll just save it like them.
08:27 - And if you want to add theme changing options, you can definitely do it using the state management
08:33 - tool you want.
08:34 - Great.
08:35 - Having that, here you can see we can't see our text.
08:38 - So let's just pass it in the style, which will be constant text style and constant is
08:47 - not required anymore because we are already in a constant text here, we need to pass in
08:52 - the color.
08:53 - Now for the color again, we just pass in K black color.
08:57 - If you're wondering why I'm prefixing with K, it's because it's a constant.
09:00 - It's never going to change, right?
09:02 - So I'm just going to pass in as K black.
09:06 - If you have any other better names, for example, if you want to name it according to your purpose,
09:10 - you can do that as well.
09:12 - So here in the K black color, I'm just passing it in here.
09:15 - We've already imported it.
09:18 - Now if we come here, this looks good.
09:20 - Now the next thing we need to look at is Google sign in.
09:24 - So for Google sign in, we're going to use a package called Google sign in.
09:29 - It's from Flutter itself, and we're going to use this.
09:32 - So now let's quickly install that.
09:34 - I'm going to use the Dart add dependency thing here and just pass in Google sign in.
09:41 - After Flutter pub get is done, we can just go to the pubspec dot yaml file just to see
09:46 - if it's there and it's there.
09:48 - Great.
09:49 - Now we can close this file, we can close this terminal as well.
09:53 - And then close all the save files.
09:54 - Now we need to do the some installation process for Google sign in.
09:58 - Since you're not using Firebase for this, we have to do some extra stuff.
10:03 - For example, we need to register our application to Google cloud platform.
10:07 - So now we'll just click over here and go there.
10:11 - Here you come to this screen, just click over here and then click on new project.
10:16 - Here we will be asked to mention a project name.
10:18 - I'll just name it Doc's clone tutorial because I already have the Google Doc's clone project
10:25 - name created.
10:26 - I'll click on create.
10:28 - And after this is done, I'll see you.
10:31 - After this process is done, you can just click on select project.
10:34 - Now after coming in here, you need to go to the credentials.
10:39 - Then you click on create credentials and then we need to create OAuth client ID.
10:44 - Just click over here.
10:46 - And you can see to create an OAuth client ID, we must first configure the consent screen.
10:50 - So we need to configure the consent screen after this.
10:53 - Now just see what you're doing.
10:55 - I'm just going to keep it external and then click on create.
10:59 - Then we need to mention app name and stuff.
11:01 - So let's quickly type all of that.
11:04 - So we'll have Doc's clone tutorial.
11:06 - In the email, I'm just going to keep in this.
11:11 - Then I'm going to skip all of this.
11:13 - This is not necessary.
11:14 - And again, here I need to mention my email address and then click on save and continue.
11:22 - After that, we need to manage the scope.
11:24 - Let's click on scope.
11:25 - And what all information do we need?
11:27 - Well, first we need the email.
11:28 - That's very important.
11:30 - Then we need the profile info as well.
11:39 - And that's pretty much all we need.
11:41 - So we can just click on update after scrolling down.
11:44 - And here you can see we have all of it.
11:46 - Now click on save and continue.
11:49 - Then if you want, you can add the test users because you're doing external.
11:54 - So basically until you have the app registered with Google, you can use these test users
12:04 - and you can only have a hundred of them.
12:07 - But after that, you can submit your app for review to Google Docs or Google Cloud and
12:12 - all of that will be done.
12:14 - Now I'll just click on add users and add my emails.
12:17 - I added some of my emails and after which I just click on save and continue.
12:22 - Make sure these emails are the ones you're using Google sign in with.
12:25 - So basically whenever that Google sign in pop up box appears, you want to select the
12:30 - email, right?
12:31 - So just pass in the email that you want or that you will be selecting and you can add
12:36 - as many as you want till hundred.
12:38 - So that's great.
12:39 - Now we can come back to the dashboard.
12:42 - And if you want, you can just click here to publish your app.
12:45 - But I don't want to do that.
12:47 - I just want to keep it for testing.
12:50 - So I'm not going to go there.
12:51 - Now again, we can go to our credentials, click on create credentials and then OAuth client
12:55 - ID.
12:56 - Now what is our application type?
12:57 - Well, we have to do it for web, Android and iOS.
13:00 - So let's do it one by one for everything.
13:02 - We'll have Android first, then in the name we'll pass in Docs Android.
13:09 - Then we need the package name.
13:10 - So for the package name, let's go over here in our android.manifest.xml file.
13:16 - Just copy this package name and paste it over here.
13:20 - Then we need the certificate fingerprint.
13:23 - Try to use this.
13:24 - If this doesn't work, just open up your terminal and copy this line.
13:30 - I'll mention it in the description below.
13:33 - Just copy it and then click on enter.
13:35 - This will give the SHA-1 or SHA-256 whatever that's needed.
13:40 - We need SHA-1.
13:41 - So I'll copy this and paste it in here.
13:44 - Then click on create and make sure to download this JSON file.
13:48 - This client ID is not of much use to us because we already have JSON file.
13:52 - And similar to Firebase, we're going to set it up.
13:55 - So in our app, in the app folder, we're going to store our JSON file.
14:03 - So let's go to our finder, click on downloads and here name it as GoogleServices.json file.
14:12 - I've named it as GoogleServices2 because GoogleServices already exists in my finder.
14:18 - I need to delete it.
14:20 - So now having this, we have GoogleServices created.
14:23 - No need to do anything or tamper with anything where it's not needed.
14:27 - Now just rename this to GoogleServices.json file.
14:31 - Great.
14:32 - Now let's close all of this.
14:34 - For Android, let's see what else do we need to do.
14:38 - That's pretty much all that we need for Android.
14:41 - So now we can go to the build.gradle, here update the flutter minimum SDK version to
14:48 - 21 and here we'll enable multi-dex.
14:57 - Having done all of this, I don't think anything else is needed.
15:03 - So we'll close this file.
15:04 - Now we need to configure for iOS.
15:06 - To configure for iOS, make sure that you have a macOS or you have macOS in your system or
15:14 - you have virtual machine setup so that you can work with us.
15:19 - But if you only have Windows and have no virtual machines, you can't build apps for iOS.
15:26 - So just skip through this process.
15:29 - The timestamps are mentioned in the description below.
15:31 - We'll open it in Xcode.
15:34 - Now we can go to our Google Cloud console again.
15:37 - Click on create credentials, OAuth client ID and now we will register iOS app.
15:42 - Now what is our client name?
15:44 - Well, iOS docs clone.
15:48 - Now we need the app bundle ID.
15:50 - To get the bundle ID, we'll go to runner, we'll click over here on the runner.
15:55 - Copy this bundle identifier and paste it in here.
15:58 - Then we can click on create.
16:00 - We need to download the blist file as well.
16:03 - So we'll just rename this, we'll rename this to Google service.
16:10 - It's not like this, I guess it's Google service info and after this hyphen.
16:17 - Yeah that's it but I need to put it in desktop so that I can rename this correctly because
16:22 - I already have that created.
16:24 - So I'll put this in runner and then click on finish.
16:28 - Now let's see if I name this correctly, I'll go to the iOS integration part.
16:35 - Here you can see Google service info.
16:36 - It's correct.
16:37 - We have put it in runner, we have completed all these steps.
16:40 - Now we need to go to the info.blist file.
16:45 - For iOS, don't go in Mac.
16:47 - Make sure to go in iOS info.blist and in here we need to pass in this whole bunch.
16:54 - So we can just copy this, paste it here and here you can see it says to pass in reverse
16:59 - client ID instead of this.
17:01 - So how can we do that, well just go to Google service info, take this reverse client ID
17:08 - and go to info.blist and paste it in here.
17:13 - Copy the, save this much and there we have it.
17:19 - We have done this.
17:20 - Now we need to go to the pod file, uncomment this line and yeah that's pretty much it.
17:27 - Final configuration is for web.
17:29 - So we'll have to create another client ID, we'll call this web and let's call this web
17:35 - docs clone.
17:38 - Now you can see authorize JavaScript origins.
17:41 - This basically means what URIs or what URLs are accepted for our application to run on.
17:49 - Well what will we use, if you're deploying it online, you'll have to pass in the name
17:55 - over here but since we're just doing it locally as of now, we can just click on add URI, pass
18:01 - in HETP slash slash localhost 3000.
18:07 - That's one that we're going to have.
18:11 - Then we can click on download JSON.
18:15 - Then go to our downloads and here we have this JSON file.
18:20 - We can click on OK.
18:22 - Then we will go to our Google sign in and see what we need to do for web.
18:26 - We just need to copy this line.
18:28 - After copying this, we'll go to index.html for web.
18:33 - In the head, we will pass in this line.
18:36 - Now we need to pass in the OAuth client ID.
18:40 - To get the OAuth client ID, all we need is this line.
18:45 - So we'll just paste it in here.
18:49 - Let's remove this extra and save it.
18:54 - Yeah, it's not necessary for you to put it over here, you can even put it over here somewhere
19:00 - but it has to be in this block which is the head block.
19:04 - Don't put it outside of this somewhere here.
19:06 - Just put it somewhere here inside of this block.
19:11 - After this is done, well, that's all we need.
19:14 - We don't need the JSON file.
19:16 - If you have it, just delete it.
19:18 - Now if we try to run our application and if we try to use Google login on web on this
19:24 - port which is just some random port, it won't work because we've passed in the port as localhost
19:32 - 3000 and it will only work there.
19:34 - If you deploy it online on some website, it won't work even there because the URL over
19:39 - there is different.
19:40 - So once you deploy your application somewhere on the web, you need to pass that URL in the
19:45 - Google Cloud platform as well.
19:47 - To do that, you can just click on this edit button and pass in the URL again.
19:53 - It's that simple.
19:54 - Again, it's in credentials and here you can pass it in.
19:58 - And if you're working on Android and iOS apps, they don't accept com.example apps, the package
20:04 - that we have.
20:05 - For example, if I go to the android.manifest, you can see the package name here is this.
20:11 - They won't accept apps with com.example.
20:14 - You have to name it something else.
20:16 - So obviously there are packages that will help you change the package names throughout
20:21 - the application and then you can deploy it on the Play Store.
20:25 - But after that, you again have to register over here because this works for com.example
20:31 - app, not for the newly registered package name, right?
20:37 - Now having all of this set up, let's see how we can run on the web.
20:41 - So if we just go to Google sign in web package, here you can see this is how we can run on
20:48 - a specific port.
20:49 - So if I just type it in over here, you can see we need to pass in flutter dash dash chrome
20:56 - and it has to be localhost so you can type that.
21:00 - This is not generally required because anyways, the default one is localhost.
21:04 - And then you can have web port.
21:06 - Now since we passed in 3000, I'll pass in 3000 here.
21:09 - If you've passed in something else as the port, you need to pass that.
21:13 - So if I run this much, it will open the app in localhost 3000.
21:18 - Let's wait for it to launch.
21:20 - And here we are.
21:21 - Our application is there.
21:22 - Now we need to configure the Google sign in.
21:25 - So for that, we're going to create a repository because it's going to be some business logic
21:29 - and we're going to create a file called auth underscore repository dot dot.
21:34 - Here I'm going to create the class auth repository and then we are going to have, well, first
21:41 - of all, instance of Google sign in.
21:43 - So we'll have Google sign in and we are going to make this private.
21:48 - We're not going to initialize this.
21:50 - We're going to take it from the constructor so that it's easier for us to do unit testing
21:57 - the video on it.
21:59 - Unit testing, widget testing and integration testing will be out very soon.
22:02 - So stay on the lookout for that.
22:04 - But for now, it's just helpful in unit testing so that we can create mocks.
22:09 - If you're already familiar with it, you'll know this.
22:12 - And we've made this private.
22:13 - I'll tell you why.
22:17 - Another thing that we might need is and other constructors that we need, we can look after
22:22 - them later on.
22:23 - But now we can just generate constructor for this.
22:26 - If you're wondering how I got this, you can just go to the extensions tab and download
22:31 - Dart class generator package.
22:35 - It's pretty useful.
22:37 - Now here you can see it's already giving us an error because we can't have private variables
22:42 - in constructor.
22:43 - That doesn't really make sense.
22:45 - So what I'm going to do here is remove all the required part and just type in Google
22:52 - sign in and then have this.
22:58 - Also make this a required field.
22:59 - Here we need to make sure that we pass in Google sign in as Google sign in.
23:05 - What we're basically doing is creating a private variable which we will use throughout our
23:10 - application.
23:11 - But here we are accepting Google sign in from the constructor.
23:15 - Since we can't have the private variable over here, we are passing it as a public variable.
23:21 - But the scope of it is limited to this constructor because that's how they work.
23:27 - And then here I'm asserting that this Google sign in is equal to Google sign in.
23:32 - So this private variable is equal to whatever value is passed in over here.
23:37 - Why are we doing this?
23:38 - Well, if we just pass in Google sign in and you required this dot Google sign in, this
23:43 - should work, right?
23:45 - But what's the point of this when Google sign in is a public variable?
23:51 - That means it can be easily accessed.
23:52 - The point of making this private is that the scope of it is limited to this class only.
23:58 - We don't want other classes to access this Google sign.
24:02 - That's why we are doing this.
24:04 - If we just make it a public variable like this, it will allow us to use this instance
24:11 - of the class.
24:13 - But that's not what we want.
24:14 - So this is how we're going to do now.
24:17 - Having this, now we will create the function called void sign in with Google and we're
24:24 - going to pass in asynchronous.
24:29 - Again a try and a catch block.
24:33 - And in case of any errors, let's just print out A. We will obviously replace this print
24:40 - because they're not available in production code.
24:43 - But we will replace this later on when we do the error handling part.
24:47 - For now, we're just using the Google sign in plugin.
24:51 - So what we're going to do is very, very simple.
24:54 - We're just going to have Google sign in dot sign in and that will allow us to do the Google
25:02 - sign in part.
25:03 - That's how easy it is.
25:04 - Now if we just hover over this, you can see it will return to as a future of Google sign
25:08 - in account.
25:09 - So we can just have final user is equal to Google sign in and we will await this.
25:15 - Now we will also check if user is not equal to null.
25:21 - Then we can do other tasks.
25:22 - For now, we can just print out, let's say, user's email and user's display name.
25:33 - If you want, you can also print out the user's profile picture.
25:38 - But all of that is not really needed in our application.
25:41 - We will be storing all of this data in our state management tool.
25:46 - But all of this is very unnecessary.
25:49 - I'm just storing it because if you want to use this application later on in some other
25:52 - parts, you can have this source code ready and expand on it because then you'll need
25:58 - email and all of that stuff.
26:00 - Now I'll just try to refresh it.
26:04 - Then and before doing this, we also need to create provider.
26:09 - Now to create a provider, well, obviously we will use RiverPod.
26:18 - So what we are going to do here is pass the instance of this class to this provider.
26:22 - So we're going to call this AuthRepositoryProvider.
26:28 - And here we're going to have provider.
26:30 - We'll get a ref here.
26:32 - This ref is of the type ProviderRef, if I just show it to you.
26:37 - This ProviderRef is basically a thing, an object that will allow us to interact with
26:44 - other providers.
26:46 - Right now it's not necessary, so we can just pass an underscore.
26:49 - But when one of your provider, suppose this provider depends on another provider, this
26:55 - ref will be very useful for us.
27:00 - And here I just need to pass an AuthRepository.
27:03 - Here you can see it asks for Google Sign-in, so we can just pass an instance of Google
27:07 - Sign-in class.
27:09 - That's all that we need.
27:12 - Why are we creating this provider?
27:14 - Well, obviously instead of doing AuthRepository, passing in Google Sign-in and creating instance
27:19 - of Google Sign-in class continuously, what we can do is use this provider.
27:24 - This will allow us to use this class very easily and it will allow us to test our applications
27:33 - better as well.
27:37 - So this is the best choice in my opinion.
27:39 - Now we can go to the login screen again.
27:42 - Here instead of having a stateless widget, we are going to have a consumer widget.
27:46 - What is this consumer widget?
27:47 - Here you can see, after converting it to consumer widget, which is given by FlutterRiverPod
27:51 - package, we get something known as WidgetRef.
27:59 - This WidgetRef is like ProviderRef, but ProviderRef allows us to interact with providers.
28:05 - WidgetRef will allow us to interact with widgets.
28:08 - Right?
28:09 - Pretty simple.
28:10 - So after extending this, we can have WidgetRef.
28:13 - Why do we need WidgetRef?
28:14 - Well, you can see it's provider.
28:16 - We can't directly use AuthRepositoryProvider anywhere, right?
28:20 - To call this AuthRepositoryProvider, we need ref.
28:25 - So we can use ref and then use read like Provider package.
28:31 - We can use ref.read, but since we are in the build method, we'll use ref.watch and then
28:37 - we'll have AuthRepositoryProvider and then we need sign in with Google and that's the
28:45 - line that we need.
28:47 - Instead of creating instance of AuthRepository class, all we did was this line and this will
28:53 - help us when our app gets bigger.
28:57 - So now you won't understand the difference.
28:59 - You'll think creating instance of a class is very much easier, but trust me, this one
29:03 - is much much better.
29:06 - Now I'll just create a function for this called sign in with Google, take in a WidgetRef from
29:11 - the argument and then call this method ref.watch AuthRepositoryProvider.signInWithGoogle.
29:20 - Now since we are outside the build function, we can use ref.read.
29:26 - Now we can use sign in with Google function and pass it in like this.
29:32 - Also remove this end from here.
29:35 - And then we need to pass in the WidgetRef.
29:38 - Save this much and we have the app ready.
29:41 - Also if you go to your pubspec.yml file, you can see Flutter RiverPod version is 1.0.4,
29:48 - which matches the latest version, but in mid-September, Flutter RiverPod 2.0 is going to be released
29:55 - and it's pretty much going to be similar with the pre-release version.
29:58 - So I'm going to use this as of now.
30:01 - There won't be any difference, I'm pretty sure about that.
30:07 - So I'm just going to replace this with this version.
30:10 - If you have 2.0.0, make sure to use that.
30:13 - It's always great to stay on the stable version.
30:15 - But with RiverPod packages, I'm pretty sure pre-release versions are safe as well.
30:20 - I've never encountered anything that would change my application.
30:24 - So here it is, we are using 2.0 with the pre-release version.
30:30 - I'll repeat, if you have 2.0.0 released already, please check it and make this 2.0.
30:37 - But for me, it's not available yet, so I'm going to use the pre-release version.
30:42 - There won't be any differences, so don't worry about it.
30:45 - Whatever we are going to use is pretty basic stuff of RiverPod.
30:49 - So it won't get changed anytime soon.
30:55 - Now we can exit our application, run our application again and let's wait for it to launch and
31:02 - see if it's working.
31:03 - So our app has launched and as you can see, it's localhost 3000.
31:07 - I'm going to click on sign in with Google and it's throwing me an error, you can see
31:12 - that.
31:13 - Why is this error?
31:15 - Because whenever we use Flutter RiverPod, if you are familiar with provider, we always
31:19 - need to wrap it with a storehouse widget.
31:23 - A provider that will store all the information of our other providers.
31:27 - For RiverPod, it's pretty easy, we'll just wrap it with a widget called provider scope
31:35 - and we need to import this and make it a constant.
31:41 - So this provider scope will allow us to use other providers and it will act as a storehouse
31:48 - for other providers as well.
31:50 - And if you scroll down, you can see a widget that stores the state of providers.
31:54 - All Flutter applications using RiverPod must contain this at the root of their widget tree.
31:58 - This is the root of our widget tree, my app.
32:02 - So I'm having that.
32:04 - Let's restart the application and then click on sign in with Google.
32:09 - Here you can see I'm sent to another thing.
32:12 - I'll just pass in my email and password.
32:14 - I've logged in and let's see if I'm getting anything.
32:16 - You can see this is my email, this is my display name and this is my avatar.
32:21 - So if I just go over here, click on open, you can see R showing up.
32:29 - That's great.
32:30 - All of these things, the Google sign in part is now working.
32:34 - Now the next part we need to do is we need to store all of this in a database, correct?
32:39 - So now we will have to create a node server and then set up MongoDB to store all of this
32:44 - data in MongoDB.
32:46 - Before diving into the code of Node.js, let's understand what exactly Node.js is.
32:52 - If you go to their website, it will say Node.js is a JavaScript runtime built on Chrome's
32:56 - V8 JavaScript engine.
32:58 - Basically, JavaScript cannot be run outside of the browser.
33:03 - So Node.js was built exactly to do that.
33:07 - It could be run outside the browser after using this tool.
33:11 - That's all Node.js does.
33:12 - It allows us to use JavaScript outside of this browser.
33:16 - So obviously Node.js uses JavaScript.
33:19 - But Node.js allows us to do multiple more things.
33:22 - It will allow us to create our own servers.
33:25 - It will allow us to create APIs.
33:27 - It will allow us to create sockets and manage them.
33:30 - What exactly socket?
33:31 - We'll get to it when we get to it in the tutorial.
33:35 - But basically it establishes bi-directional communication.
33:38 - If you're confused, don't worry about it, we'll go through it later.
33:42 - But Node.js just fastens all of our processes.
33:48 - Writing plain JavaScript would be very much difficult.
33:50 - But with Node.js, it's much much more easier.
33:52 - Node.js doesn't just allow us to create servers and all of that good stuff.
33:57 - It also allows us to create terminal apps.
34:00 - For example, if you open up your terminal and want to do something with your terminal
34:04 - only, Node.js even allows that.
34:08 - But we're only going to look at creating APIs, sockets and all of that stuff.
34:13 - So what does this line even mean?
34:16 - JavaScript runtime built on Chrome's V8 JavaScript engine.
34:19 - Well, we all know what a runtime is.
34:21 - You can consider Node.js kind of like a framework, a backend framework.
34:26 - For example, Flutter is a front-end framework.
34:28 - Node.js is a backend framework.
34:32 - And Chrome's V8 JavaScript engine, this line right here.
34:36 - Basically Chrome runs on this JavaScript engine, which is called V8.
34:40 - And this V8 JavaScript engine is written in C++, which means it's terribly fast.
34:47 - By terribly fast, I mean it's pretty fast, not in a bad way.
34:50 - But it just means simply that Chrome V8 allows us to execute JavaScript code.
34:57 - And that's exactly what Node.js is using.
35:01 - Chrome is built on Chrome's V8 engine.
35:03 - And Node.js is built on Chrome's V8 engine and thus allows us to write code over there.
35:08 - So this is pretty much all about Node.js.
35:11 - I think you got a very brief idea about it.
35:14 - So now if you want to install it, if you're on Windows, this will show you Windows.
35:18 - And just click on this version or this version.
35:21 - This version is recommended for most users.
35:24 - But I'm using 18 version.
35:26 - And if you want to verify that you've installed successfully, just go to your terminal and
35:31 - write node-version.
35:34 - And it says version 18.1.0.
35:36 - But I don't think it will make a difference even if you use a lower version like 16.17.
35:41 - Even 14 works just well for me as well.
35:44 - So now let's get done with all of this.
35:47 - Now we'll come to our root file.
35:49 - Let's close all the save files, clear off our terminal.
35:54 - And in the root, we need to create a folder.
35:58 - So I'm going to type make directory, which is mkdir, which will make a folder.
36:03 - And we need to name this server.
36:05 - So now we have a server folder ready.
36:08 - Instead you could just click over here and create a folder.
36:10 - Same thing.
36:11 - But it should be in the root of your folder of docs clone.
36:17 - Now let's go to the server.
36:19 - So I'm going to use cd, which means change directory server.
36:23 - And now I'm going to run npm in it.
36:26 - This npm is node package manager.
36:30 - Node package manager is like pub.dev.
36:32 - So if you just go to the website, which is npmjs.com, you can see this npm right here.
36:42 - This is not the real name.
36:43 - Don't get confused by it.
36:45 - It's just for fun.
36:46 - If you just click over here, you can see it keeps on changing.
36:50 - Anyways, so here you can search for packages.
36:53 - Just like flutter, we can have multiple packages.
36:56 - For example, if in flutter you're using HTTP package, you can have the same thing here
37:01 - as well, which is HTTP.
37:03 - The same thing.
37:04 - I mean, this one is same, but there are multiple that are different as well.
37:09 - For example, if you want to use something like express that was mentioned over here,
37:14 - you can see we're going to use this as well.
37:17 - So basically, this will manage all the packages and npm will allow us to initialize a node
37:25 - project.
37:26 - So here we are just writing npm in it.
37:29 - And then if we click on enter, just try to do it yourself, you'll see that you'll get
37:33 - a bunch of options, you just have to click enter on them.
37:37 - But a shortcut to avoid that is just typing dash y, which means that you'll initialize
37:43 - it and all the options that are asked later on will be defaulted to yes, that's exactly
37:48 - what we wanted.
37:49 - So I've done that npm in it dash y.
37:53 - Now in the server folder, I'm going to create a new file called index.js.
37:58 - In this index.js before coming over here, we need to go to the package.json.
38:03 - Now what exactly is package.json?
38:06 - Package.json can be considered like pubspec.yml file.
38:09 - It contains a name, version, description, the main file, which means the file that we
38:15 - want to run in the start, the scripts, well, multiple scripts that we'll have, we'll get
38:21 - into this in just a minute.
38:23 - Then we have author, license, everything that you'll need to create a flutter package.
38:32 - And your node package, it's just the same thing as pubspec.yml file, it will manage
38:39 - all our dependencies, it will manage all our dev dependencies, similar.
38:44 - Everything is pretty similar.
38:46 - So now in the scripts, I want to change something.
38:48 - So we're going to add two scripts.
38:50 - Well, first of all is the start one, which means which is short for node.slash index.js.
39:00 - Now what does this mean?
39:01 - Wait a second, I'll show it to you.
39:03 - For example, here I type console.log hello world.
39:07 - If you're wondering what console.log is, it's basically print in Dart.
39:13 - It will just print it out to the terminal and if you're on web, it will print it out
39:18 - on the web.
39:20 - Here if I just type, let's say node.slash index.js, because I'm in the server folder,
39:27 - I can use.slash.
39:29 - If I was in the root folder, I would have to use.slash server slash index.js.
39:35 - It's relative routing.
39:37 - Now if I just click on enter, you can see hello world prints out.
39:41 - What I've done here is instead of writing this command, this entire big command, what
39:45 - I can do is just use npm start and it does the same thing.
39:50 - It will run this command behind the scenes and print the same thing out to us.
39:58 - Why is this needed?
40:00 - Well, if you deploy it online, you will have to use something like npm start so that it
40:06 - starts the server.
40:07 - You can't use node.slash index.js.
40:10 - And now let's try to install some dependencies.
40:13 - To install our dependencies, what do we use to do?
40:16 - Well, we would use this Dart add dependency, otherwise we would go to pubspec.yml file
40:22 - and over here manually add them.
40:25 - But another, the third option would be to use something like flutter, pub add, and then
40:34 - the name of the dependency, right?
40:36 - That's exactly what we're going to do over here.
40:39 - Here we're going to write npm, i, or install, both of them work.
40:45 - Even i works.
40:46 - Even install works.
40:47 - As the name suggests, it will install dependencies whatever we type here.
40:51 - So what all dependencies do we need?
40:54 - Well, I said we need express, right?
40:56 - We'll install that.
40:57 - I'll tell you what express means when we get it.
41:01 - Then we need HTTP.
41:03 - I said we're going to need that.
41:05 - You'll understand when we write the code.
41:07 - Then we need socket.io at 2.3.0.
41:12 - This is very important.
41:14 - Socket.io at 2.3.0.
41:17 - Why do we need add 2.3.0?
41:19 - Well, because the sockets are managed in such a way that it needs to be connected on the
41:25 - client side as well, and in the server side as well.
41:29 - So when we're connecting it on the client side, we're going to use another package because
41:33 - we can't manually write the whole socket client code.
41:36 - It's very big and it's very tough to understand as well.
41:40 - So we already have a package for it.
41:42 - That's exactly what we're going to use.
41:44 - And that package that we're going to use socket.io client has to have a socket.io version of
41:52 - 2.3.0.
41:54 - Then only it will work.
41:55 - It won't work without that.
41:58 - So we need to make sure that we add this version.
42:02 - If we add like this, it will install the latest version.
42:05 - But if we write add 2.3.0, it will install the specific version.
42:11 - And then it won't give us any errors later on when we connect to the client side.
42:15 - When we get to the socket part, you'll understand it better when we read the documentation as
42:19 - well.
42:21 - Another thing that we need is JSON Web Token.
42:25 - JSON Web Token, short for JWT, will allow us to securely store our token or create a
42:32 - token based on the user ID.
42:37 - And this token will be stored on our device and that will allow us to process the state
42:42 - in our application.
42:44 - That's why we need this.
42:45 - And finally, we need Mongoose.
42:47 - What is Mongoose?
42:48 - Well, it's just a data object model for MongoDB.
42:55 - Using Mongoose, all the MongoDB tasks get quite simpler like connection, sending data
43:01 - to the server and it gets more organized in my opinion.
43:04 - So I'm going to use this Mongoose.
43:07 - After that, we are just going to click on enter and you can see all of them got installed
43:11 - and we have a new folder of node modules.
43:14 - This node modules contains all the necessary files that we have and it's pretty big.
43:20 - So you can ignore it and if you're uploading it to GitHub, this project, you need to make
43:25 - sure that you have dot git ignore file here and pass in node underscore modules like this.
43:32 - If you're not using GitHub, don't worry about this.
43:35 - So now that we know about console dot log, let's remove it.
43:38 - Now let's import all the packages that we have added, right?
43:44 - So in Flutter, we used to do import and then pass in the name like this package.
43:51 - HTTP from HTTP dot dot.
43:56 - This is how we used to import stuff here.
43:59 - It's a bit different.
44:02 - We need to do constant express is equal to require express.
44:09 - With this, we have imported it.
44:12 - This express we have imported it and stored it in a variable.
44:16 - You can understand what this means.
44:18 - Even in Flutter, we have the variable expression constant express equal to require express.
44:23 - This means express cannot be re initialized or re given a value again.
44:29 - After that, we'll import mongoose.
44:32 - Let's require mongoose as well.
44:36 - Then let's have constant app equal to express.
44:41 - What we have done here is basically initialized express and stored it in the app variable.
44:46 - So we have imported express and you're just initializing express just like we do.
44:52 - We call the function, right?
44:54 - That's exactly what we have done and stored it in this app variable.
44:58 - Then we need to do app dot listen.
45:03 - Now what is this listen method?
45:04 - Well, listen method is basically helping us to start our server.
45:09 - So when we use this, it will continuously listen to our server and will respond.
45:15 - So here, first of all, in the lesson method, we need to supply it with a port.
45:20 - So on which port should it start running?
45:23 - You can see our web is running, our web was running on the version 3000.
45:28 - But even this has to run somewhere, right?
45:32 - So exactly we need to pass in a port.
45:35 - Now we are going to store it over here, which is called constant port.
45:39 - Let's store it over here so that all imports stay on the same line, all initializations
45:46 - on the same line and app dot listen at the end of the file.
45:49 - It's not necessary to make it stay at the end of the file.
45:53 - But if you put it at the end, it seems much more organized, right?
45:58 - So we can say the port as 3000 again.
46:01 - But our server is already, our web is already running on port 3000.
46:07 - So let's have it on 3001, right?
46:11 - Or if that's not there, this is a shorthand.
46:15 - So if the port 3001 is not there, and it will always be there.
46:22 - So the port here is going to be process dot env dot port.
46:28 - If you have developed many apps, you might know that you have to store some secret information
46:33 - inside of dot env files so that they stay secure and are not visible to the public.
46:39 - But this is exactly what we're going to do process dot env dot port.
46:43 - Otherwise, if that's not present, this is 3001, not 3001, 3001.
46:49 - So basically, this process dot env dot port is stored in the site to which we deploy.
46:56 - For example, if you're deploying on Heroku or Firebase, the server, then we need to make
47:04 - sure that we provide it with a port, it can't run on 3001.
47:08 - It's only for local development, but on the web, it will already give us the env port.
47:15 - And we will access this using process dot env dot port.
47:20 - But what if we are doing local development, we don't have process dot env dot port.
47:25 - In that case, we want to use 3001.
47:29 - This is exactly what we're doing.
47:30 - If process dot env dot port is present, which is usually present in the sites to which we
47:35 - deploy our server to, if that's not present, then we will use 3001.
47:40 - And it's most likely the case that we are doing local development.
47:44 - In our case, it will show up 3001 look.
47:48 - So if here I pass in the port, because first a port is needed, and then a callback function.
47:55 - But before that, I'm going to pass in 0.0.0.0, which basically means that you can access
48:01 - this from anywhere from any IP address that you want.
48:05 - You can access this server.
48:07 - So I've passed in 0.0.0.
48:10 - Then we need a callback function.
48:11 - So whenever the app is connected, what do we say?
48:15 - So we'll just pass in console dot log connected at port dollar port.
48:30 - And we can't put in port.
48:34 - So we are going to have port 3001.
48:37 - Now let's just save it and run npm start again.
48:41 - If I just do this, you can see connected at port 3001.
48:45 - Let me correct the spelling.
48:48 - And here we have it.
48:49 - Now this is the way we create functions in JavaScript.
48:52 - You pass in two parentheses, then arrow function, then a block, and then whatever you want to
49:00 - pass in.
49:01 - Alternatively, what you can do is just write in function here and it will solve the error.
49:08 - If you just try to run it again, you'll have to close this because it hasn't noticed the
49:13 - changes.
49:14 - Whenever we make a change, we need to restart the server.
49:17 - So to exit it, we can just type control C and it will exit it.
49:23 - Then we will write pass in npm start again and you can see it again connects to the port
49:28 - 3001.
49:29 - Both the syntax are fine.
49:31 - I just like this one better because it's shorter and less use of keywords, right?
49:38 - I'll again stop this and start it.
49:40 - You can see it still works.
49:42 - It's absolutely fine.
49:44 - Now if you want to use something like this, you know, in our Flutter we used to do.
49:52 - If we wanted to paste some variable here, we would have a string and then over here
49:57 - we need to pass in the variable.
50:00 - But here you can see there is no highlighting and if I save the file, start my server again,
50:05 - you can see it says connected at port port.
50:08 - It hasn't noticed the string interpolation.
50:11 - That's what it's called.
50:13 - In Flutter when we used to do this, it used to work.
50:16 - For example, if I just go in the main.dart file, here I want to pass in the key color.
50:23 - For example, let's say key black color.
50:26 - I used to do this and the highlighting used to come and now the name is Flutter demo and
50:30 - then colors.white, colors.black, sorry.
50:35 - But that didn't happen here.
50:37 - Why?
50:38 - Because here you need to provide backticks instead of normal string.
50:43 - So when you do this, it will identify this as a variable.
50:48 - This backtick is present below the escape key.
50:52 - Now if you try to start it, you can see connected at port port and it's still showing that because
50:59 - I haven't saved the file.
51:00 - When I save the file and try to do it again, you can see connected at port 3001.
51:05 - Great.
51:06 - Now you've noticed we have created a server.
51:09 - That's how simple it was.
51:11 - Just these many lines of code and we have created a server.
51:14 - Let me remove this comment.
51:15 - I hope you've understood everything till now.
51:18 - Now the next part is you've noticed that we've written so many npm starts here.
51:23 - That's not very ideal, you know, making some change and then restarting the server again
51:29 - doing so much tasks.
51:31 - Sometimes we just forget and it will cause us to scratch our heads and think what we've
51:35 - done wrong.
51:36 - But nothing really was wrong except starting the server.
51:39 - So how do you fix that?
51:40 - Well, for that we need to install a dev dependency which is called nodemon.
51:46 - So when we install it like this, it will save it in dependencies.
51:50 - But we want it as a dev dependency because it's only a developer dependency.
51:55 - We don't want it in our application.
51:57 - We just want it for our own use.
51:59 - So we're going to use it as a dev dependency.
52:01 - How do we install it?
52:03 - Dash dash save dev.
52:06 - So you've installed nodemon.
52:08 - This will install it in dependencies.
52:09 - But to make it save in dev dependencies, you'll have to use dash dash save dev.
52:16 - When you click on enter, you can see it is loading.
52:20 - If it's installed, let me clear the terminal as well.
52:23 - And if you come over here, dev dependencies now has nodemon over here.
52:28 - Nodemon will allow us to start a server very quickly.
52:31 - So once I start nodemon, it will keep running a server.
52:36 - And whenever we make a change and save our file, it will again restart the whole server.
52:41 - We don't have to do it by ourselves.
52:43 - Now of course we need a script for that as well, otherwise we'll have to keep writing
52:47 - nodemon.slash index.js.
52:50 - So here what I'm going to do is create another script called dev and then write nodemon.slash
52:57 - index.js and put in a comma.
53:03 - Then we'll come to index.js file.
53:08 - Let's try to run it again.
53:09 - But now we'll run npm run dev, with npm start, this used to get executed.
53:14 - With npm run dev, this is going to get executed.
53:18 - So now I'll just click on enter and you can see connected at port 3001.
53:24 - Now if I just type in console.log, hey this is changing.
53:31 - And if I click on save, you can see it restarted the server.
53:35 - Then it has connected at port 3001 and hey this is changing.
53:39 - My spelling is wrong but anyways.
53:42 - So you can see it's automatically restarting our whole server.
53:45 - Now we have a proper base to start from.
53:48 - Now the next step is to connect our database to our application.
53:52 - So this is how mongoose is going to help us.
53:55 - But before connecting it to mongoose, we need the database setup.
53:59 - So let's get to it.
54:01 - So to create mongodb or setup mongodb, we need to go to this website mongodb.com.
54:07 - Then click on this sign option and then use your desired option to sign up.
54:13 - So let's just click over here and then use whatever you want.
54:17 - I've already created an account so I'm just going to use that.
54:20 - And I'll see you after I login.
54:22 - So I've come to this screen, you might not see the screen in the start, you'll have to
54:25 - fill in some information if you're signing up for the first time.
54:29 - But since I'm already logged in, I'm not seeing the startup screen, just fill in all the information
54:34 - that you'll require after sign up.
54:37 - And then you'll ultimately come to a screen that looks like this.
54:40 - You just need to click here.
54:42 - Then click on new project.
54:44 - Then you have to mention the project name, I'm just going to call this docs clone tutorial.
54:49 - And then click on next.
54:51 - Then you can add any members that you want.
54:53 - I don't have any so I'm just going to click on create project.
54:57 - Here it asks us to build a database first so we will click over here.
55:01 - Then we're going to use the free cluster, there's dedicated one and the serverless one.
55:06 - You can read all the information that's required and that will help you.
55:09 - I'm going to go with the free option.
55:12 - Then here, I'll just select all the default options and then click on create cluster.
55:18 - Then it asks us for the username and password and make sure that whatever you type in here
55:23 - is correct and you have it secured.
55:27 - And you remember it because this will be needed in the next step that we'll use when we need
55:32 - to connect to our database from our code right here.
55:36 - So I'm just going to enter some username and some password.
55:40 - After you pass in it, just click on create user and this will have it.
55:44 - You have this if you want other username and password to use it, you can use that as well.
55:49 - But for me, one is enough, if you have more team members, make sure to use that.
55:53 - It will be very easy for you to segregate and see what the who did what and later on.
55:59 - Anyways, so where would we like to connect from the cloud environment or from the local
56:04 - environment?
56:05 - I'm going to use the local environment.
56:06 - So I'm just going to pass in 0.0.0.0.
56:10 - That means that your IP address is available to anyone and it can be used anywhere as I
56:15 - mentioned over here as well 0.0.0.0 basically means that it can be accessed from anywhere
56:22 - if you want to add any description add that otherwise just click on add entry.
56:27 - Then we can click on finish and close and go to our database.
56:31 - While our database is being deployed, let's write some code to connect it.
56:34 - It's pretty simple.
56:35 - As I've already mentioned, we're going to use Mongoose for it.
56:38 - It makes our connection stuff very easy and it will later on also provide us with some
56:42 - modeling which will make our code cleaner and even easier to connect and save update
56:49 - or delete data from MongoDB.
56:53 - So here I'm just going to connect it.
56:55 - So for connecting it's as simple as it gets.
56:57 - It's just we have to use this Mongoose and call dot connect with this we have the connect
57:03 - ready.
57:04 - If you hover over this and in here you need to pass in the URL.
57:08 - So here I'm just going to pass in constant DB and this DB link will be whatever we get
57:14 - from your whenever this database gets deployed we will have to click on this connect button
57:20 - which will give us the URL.
57:22 - So if yours is already there you can try it out but I'm just going to pass in like this
57:28 - and whenever I get the database link I can just pass it in over here but now only doing
57:34 - this much isn't enough because connect is a promise.
57:38 - What is a promise you can consider it like a future like in Dart we have future so to
57:43 - use a future if we are in a function we can make that function async and then use await
57:49 - and then we can resolve that future or if you're outside of a function and you don't
57:54 - have any function then you can use dot then function right and that will give you a function
57:59 - for example or some data.
58:01 - So you'll get some data here and then you can use that data to suppose print that data.
58:08 - That's how Dart works and similar to that JavaScript works as well.
58:12 - You have the dot then method and dot catch method similar to Dart.
58:17 - So we can just have dot then and whenever this kind of thing happens we will just say
58:23 - console dot log connection successful otherwise there is an error right.
58:31 - So we can just catch that error and then just print it out.
58:37 - So we'll write console dot log error save this much and our connection should be successful.
58:44 - Now if I just open up my terminal you can see invalid scheme because the database URL
58:49 - is incorrect.
58:51 - Now let's try to see our database has been deployed if it's taking more time try to refresh
58:55 - it and see even after that if it's not happening then wait for some more time.
59:01 - If it happens then you can just click on this connect button then click on connector application
59:06 - with MongoDB native driver we have the driver as Node.js and we have the version 18.
59:11 - If you have 16 it still works you can see we need 4.1 or higher.
59:15 - Now we can just copy this MongoDB URL paste it in here and now you can see we have our
59:21 - username that we typed in earlier.
59:23 - Now we need to pass in password.
59:25 - So let's just remove this make sure to include these angle brackets if they are there it
59:30 - will cause an error and you'll not be able to connect so just remove them and pass in
59:34 - your password my password is pretty simple I'm going to change it later on as a matter
59:38 - of fact I'm going to delete this database after my project is completed so don't try
59:44 - to copy this URL create your own so you'll even be able to see the data and you can see
59:50 - connection is successful now.
59:52 - If I just try to let's say change this you can see it's giving me an error that means
59:58 - it's working successfully if you want to see the data how can you see it well first of
60:03 - all close this go to this cluster and then in the collections tab you'll be able to see
60:09 - everything but since you have not created any data you can't see anything.
60:13 - So now let's try to save our data what is the data that we're going to save the user
60:18 - data so whenever you're the user registers we just know we just pop up a Google sign-in
60:26 - button and whenever the user clicks on that Google sign-in button the user gets logged
60:32 - in from the from the account they selected from the pop-up but how do we know that the
60:37 - user has logged in into our application we have no idea currently because Google sign-in
60:43 - doesn't store it to any console any database nothing it just tells us and gives us data
60:50 - so now we need to make sure that we store it in a database and exactly for that we're
60:54 - going to use MongoDB so how are we going to do it well as I mentioned we're going to use
60:59 - mongoose for that and store the data but before that we have to create a rest API what is
61:05 - the rest API the full form for it is representational state transfer basically whenever you request
61:11 - to a server some data you can only do it using an API correct so we are going to make that
61:19 - API which is application programming interface you might have used somewhere in your application
61:24 - for example when you're using HTTP calls if you made some application so you're requesting
61:30 - or getting some data using HTTP dot get that's exactly basically what we're going to get
61:35 - so whenever we request some server some data using suppose HTTP get or post whatever request
61:42 - you sent in it will send back to you the current state of the database that's exactly and simply
61:49 - what we're going to do and that's basically what rest even means so how are you going
61:55 - to do that well we have to create API for that we can create that using node that's
62:00 - why we have used node but with express this plug-in that we have installed or package
62:05 - you can call it this package allows us to make our rest API even quicker than expected
62:11 - so let's try to use this express and create our application so what I'm going to do is
62:17 - here I'm going to pass in express not express because we have not initialized yet using
62:25 - app we can call so we can use the app dot get or app dot post and then define an API
62:32 - and we are going to call this slash API slash sign up this is the route of our API basically
62:38 - if you if your server right now is running on localhost three thousand one right now
62:48 - if I just pass in slash API slash sign up it will and use a post request for that it
62:56 - will make sure that it runs whatever code we call inside the callback function which
63:01 - is this function and this function let me create that function will have something known
63:07 - as a request and response with the request you can access many multiple headers for example
63:14 - you can access header body whatever data you want to send in from the client side can be
63:21 - accessed using request and whatever data you want to send can be used using risk or response
63:28 - you can name this anything you want these are basically variables to access those objects
63:34 - that are sent to us so that we can make sure that our API works so with request we are
63:42 - able to get the information from the client side with the response we'll be able to send
63:48 - some data but we look into it but now another problem comes in I just have this slash API
63:54 - slash sign up what if my user also wants to suppose get the data so I'll have to create
64:03 - another API for it called app dot API get let's say let's call this slash API slash
64:10 - get and this will be a get request there are many types of requests get post delete update
64:18 - patch you can use all of them and these are the most frequently used ones we are mainly
64:25 - going to use both of them in our application today for the delete one you'll have enough
64:31 - idea to make sure you can delete anything but we're just going to use get and post so
64:39 - I have get here and post here that's how we are going to work but what if I have more
64:44 - API is created for example I want something known as update user information I even want
64:52 - to delete the user account so will I keep creating here but I can keep creating here
65:01 - but that would just make my code very messy what if my application doesn't have login
65:06 - for example in our application we also want to create the documents we also want to save
65:11 - the documents we also want to update the title of our document how are we going to do all
65:16 - of that in just a single file of course we can but imagine this for a very big app for
65:23 - the real Google Docs if they use such kind of structure it will just make their app such
65:27 - pathetic right so we're going to make sure that we shift our code into a separate file
65:33 - of its own so that it's clearly distinguishable if you want to do user tasks you can do it
65:38 - in one separate file if you want to do document tasks you can do it there correct so let's
65:43 - remove all of this from here save it and then we can go to the server file create a new
65:51 - folder called routes and in this routes I'm going to create user.js file so this is the
65:58 - route we are going to create all the user related routes in this file itself now I'm
66:05 - going to require express again because this file doesn't have any import lines just because
66:13 - this has doesn't mean even this file has access to this correct just like a flutter file if
66:21 - you have an import line here doesn't mean a login screen also has that import line they're
66:26 - two separate files so we'll import that now we can of course initialize app and have constant
66:34 - app equal to express but instead of doing this there's another method you can take and
66:39 - I find this much much more cleaner which is using constant author outer which will be
66:47 - equal to express dot router so with this I have author outer created now I can use author
66:56 - outer dot post slash API slash sign up then I can have request response again it's the
67:05 - exact same thing just we have created this author using this router method and we have
67:13 - created it in a separate file that's all now of course our tasks are going to be asynchronous
67:19 - because you're going to use MongoDB it's an external service and we have to store data
67:24 - on the web whenever we have to do such kind of stuff we always require the methods to
67:29 - be asynchronous so I'm going to pass async over here I can't keep using dot then that's
67:35 - why async await was made that's why I'm not using dot then method but of course you can
67:41 - use it I just don't like nesting very much then I can have a try catch block similar
67:47 - to dart whenever there you think there can be a scope of error you can just have a try
67:52 - catch block then you need some data for example what do you want to store in MongoDB well
68:01 - it's a username the email the profile picture that's exactly what we had even printed in
68:06 - the auth repository right all of these things we want to save in our database so we need
68:11 - to get them how are we going to get them well I already told we are going to get them from
68:16 - request dot body right so with request we are able to access whatever client side information
68:24 - is being received and then with body we are able to use whatever is passed through the
68:31 - body there's headers as well but with the headers it's usually for the auth token when
68:38 - we get to it I'll let you know what this auth token is but basically you can even access
68:44 - headers and these two other things you are going to access in our application today but
68:49 - you can access much more information from there if you want to know more just research
68:53 - about it on Google just write request node.js express and you'll get your specific information
69:02 - if you want to follow along well then let's just go ahead now I'm going to destructure
69:08 - it so what is happening well in the request dot body whenever we go to the client side
69:13 - what we are going to do is whenever we send a post request what are we going to do HTTP
69:18 - dot post then pass in this URL which is localhost 3000 slash API slash signup then we have to
69:29 - pass in body and this body is going to be an object what is an object well basically
69:35 - a map so here we are going to pass in like this name ignore the errors for now name and
69:42 - then you'll pass in name then email email and profile picture same thing so that's how
69:51 - we are going to do so now instead of getting some object over here this will be an object
69:57 - or a map so instead of getting an a map over here I'm directly converting it to a string
70:03 - variable or a variable it's not necessarily a string variable JavaScript doesn't care
70:09 - about that it doesn't care about the types so here I'm going to have name email and profile
70:15 - picture and then just save it you can see we have all three stuff now I have access
70:22 - to all of this now I have to store that data to store the data as I said we are going to
70:26 - use mongoose but instead of directly storing the data using mongoose let's create a model
70:31 - for it so models can be considered like structures if you have created an application with a
70:39 - me before using firebase you already know that we create models and in JavaScript we
70:45 - create model in Dart sorry we create models using class this is user model we are going
70:52 - to create right now as well and then we are going to have final string email final string
70:59 - let's say name all of this we are going to write later on similar thing we are going
71:04 - to do in JavaScript as well but using mongoose because in mongoose our stuff becomes much
71:10 - more easier to store of course we can create classes in JavaScript as well but using mongoose
71:17 - it will be a much more easier task so here I'm going to create user.js again since we
71:23 - are in models user.js I can create it again because they both have different routes if
71:28 - you want to create user.js again in the routes folder you won't be able to do that's pretty
71:33 - basic so now in the models we are going to first of all import mongoose so let's require
71:40 - mongoose then here we are going to create something known as user schema user schema
71:48 - is basically the structure of our user so how is our user going to be structured out
71:54 - is it going to have a name email profile picture all of that's good stuff so it's just going
72:00 - to have the structure the schema that's what it is and how do we create it using mongoose
72:07 - we just call mongoose dot schema easy enough and now we just have to pass in an object
72:14 - like this so that we can provide it with a bunch of properties so the first property
72:20 - is name let's pass in like this this is the syntax that we are going to use whatever property
72:26 - name the user will have for example the user is going to have a name so we pass in a name
72:31 - then another object and here you pass in another properties for example what is the type of
72:37 - this name going to be having a type is always good especially when we have from dart it's
72:43 - very much needed for us then we are going to make sure that required is true for example
72:49 - when we use our constructors we want it to be required if there is no require it will
72:54 - throw us an error but in dart it will throw a compile time error which means it will literally
72:59 - show you in your code that please enter your name but in mongoose it will show us an error
73:07 - over here which is runtime error whenever we run and try to store the data and if it's
73:12 - not there then it will throw us an error now the next thing we require is email similar
73:18 - to this it's going to have two properties type string and require true and then we need
73:23 - a profile picture this is also going to be the same thing tribe string required true
73:30 - there are a bunch of other properties that you can use check it out on net you can have
73:37 - trim set to true that means that the user will have their string trimmed from the end
73:44 - that's exactly what trim does just calling the trim method basically so you can add that
73:51 - but i don't think any of this needs it because we are getting it from google directly google
73:55 - has done all of this so why do should i do it again right but if you don't want to take
73:59 - any chances don't take just type it in then now we have created this structure of our
74:05 - application or the user but what about the model we also want the user to have something
74:13 - so that they can store we have just defined how it should look like we have not told it
74:19 - where it should be stored how it should be stored what should the name of the collection
74:23 - be you can see our collections what should the name of this collection be so for exactly
74:28 - that we are going to have constant user equal to mongoose dot model with this we have created
74:34 - a model first we need to pass in the name of the model which has user and then pass
74:39 - in the schema which has user schema and then we can save this much so with this our model
74:45 - is completed we have told how this should look like and we have created a model so that
74:50 - we can easily use them now let's go to the user dot js route and actually instead of
74:57 - calling this user dot js let's call it auth dot js it's going to consist of all the routes
75:02 - using auth not user because you're going to have state persistence route something like
75:08 - that and it's it comes under authentication not really user right but this can be called
75:14 - user model because it just consists data of the user now here i want to find a user with
75:22 - the so how are you going to proceed with this part so how are you going to proceed with
75:28 - this part well first of all whenever we are signing up the user we need to make sure that
75:33 - the same email already exists or not so if the same email already exists then we want
75:40 - to make sure that we don't store the data right i mean if the email already exists we
75:46 - don't want to store that data it's already stored on the mongo db why should i waste
75:52 - one call of mine which is very precious always make sure to reduce the calls to the database
75:57 - so i'll always make sure that email already exists or not if it does not exist then we
76:04 - want to store the data but if it's already stored then well nothing else correct so these
76:11 - are the two tasks there's a third task as well which is token we have to send we have
76:16 - to make and send one but we look into it when we get to the state persistence part which
76:21 - is right after this after we connect to this part we can go to the state persistence part
76:27 - so here how do we check if the email already exists in our database for that we need to
76:31 - you know how to call mongoose and how to check for the database so we are going to use user
76:37 - for that but you can see i don't get any auto option to get the user we have created it
76:43 - here why am i not able to access this user over here well that's because the scope of
76:48 - this user variable is only limited to this file which means you can use this user variable
76:53 - anywhere in this file but you cannot use outside of this how am i going to use this outside
76:58 - then well you can just call module.exports is equal to user you can consider this user
77:05 - to be variable or to be a private variable now and when you use this line it becomes
77:11 - a public variable now you can come to auth.js and here you have user now i get the auto
77:17 - correct option and it requires this this is relative routing when you use express directly
77:23 - it will require the package from node modules folder but when you use user like this it
77:29 - will look for some file so that's the basic difference you can also store you can also
77:35 - call your files like this in flutter that's a feature but no one really uses it you can
77:43 - use it anyways so here how do we find the user with the same email so well we are just
77:51 - going to call user and you can see a bunch of options already there since i have created
77:56 - this user as a mongoose model i have a bunch of options you can see find find one find
78:01 - by id remove where add listener aggregate apply and so on but what do i want to do well
78:07 - i want to find the email do i have a find email option no obviously why because user
78:14 - has the email property that we created it's not necessary that if you create another application
78:20 - it will have user email necessarily it won't have but we do have find by id correct that's
78:27 - because the id property is automatically generated by mongo db itself just like firebase if we
78:35 - don't provide id it will automatically generate that id but for email that's not the case
78:41 - because every user every collection for example if i have a document collection it won't have
78:45 - an email so what's the point of having a find by email option right so here we are going
78:50 - to have find but now again the question remains how are we going to find the user with email
78:56 - then we are just going to call find one why am i using find one and not find because find
79:03 - will return to me a list of users with the same email i'm pretty sure that my app is
79:11 - only going to have one user with the same email but even if there are many many i just
79:15 - want to catch the first one after i get the first one that means that the user with the
79:23 - same email already exists directly without sending any information or creating the new
79:29 - information we are going to send the data so here i want to find one and here again
79:36 - you can see i've passed in a map or an object because i can't just type in email right user
79:43 - dot find one email that doesn't really make sense user dot find one email but what what
79:48 - email do we need to find out so here i'm going to make it like this an object and then we
79:55 - can pass an email this basically means user in the user collection find one user with
80:03 - this email property which matches our email so if you want not get confused i'll just
80:09 - type in email over here so you want to find one user with the email property as the email
80:16 - that we got from our client try to understand the sentence we want to find one user with
80:24 - the email property with the and it should be similar to the email that we are getting
80:31 - from the client side so now i'll just remove this because even naming this carries a big
80:36 - value you'll realize later on because when we send data from the client side we are going
80:43 - to send it with the name of email and when we are destructuring it this is called destructuring
80:48 - whenever we are destructuring it name matters very much so i have this now i find the user
80:54 - now i'll just save it to the user variable and we are using let here let is basically
81:00 - equal to variable user even you can even have variable user or a constant user but we won't
81:06 - use constant why because we are going to assign this user variable with something later on
81:12 - so i'm just going to have let let user is equal to user dot find one but this will be
81:18 - a promise or a future so how are we going to resolve this well we have a async function
81:25 - we can just call await and this will store the correct user information if it's there
81:31 - so we have already now we need to make check or if the email already exists or not so we
81:36 - are going to have if the user does not exist the syntax is allowed in javascript we don't
81:41 - have to do if user is not equal to null what you can do instead if if there is no user
81:49 - then we want to create a new user correct so we can have user is equal to new user just
81:56 - like you create an object you're going to do that and here you are again going to pass
82:01 - in a map because you can consider to remember it you can just consider it that we passed
82:07 - in an object these are required properties whenever we have required properties even
82:12 - in flutter how do we do it well we have to pass in all the stuff so we are going to have
82:17 - email as email we need to pass in the email correct and this name should be equal and
82:24 - the same as the name that you'll type in here so if i pass in profile pic i'll paste this
82:33 - and i want this same name to be there and the name name will also be like this and with
82:39 - this we have created a new user and set it to this but with this much only we have not
82:45 - saved anything to our mongo db well where's the save call correct we have just created
82:51 - that model and assigned it to a variable that doesn't mean mongo db will automatically store
82:55 - it to web so to save it we are going to use user is equal to await user which is this
83:03 - small variable dot save what have i done here well just consider this line we have used
83:10 - save and we have awaited it because this is a mongo db call it will take time so we will
83:17 - have await user dot save and assign this to a user variable why are we assigning it again
83:22 - because as i said mongo db will automatically create that token id or the id for us not
83:28 - the token sorry it will only create the id for us so when it's creating that id we also
83:34 - want that user id to be there so that we can access in our application later on ids are
83:38 - very crucial correct so here we are going to have user dot save and save it to this
83:43 - variable but if there is no user if there is the user already existing then we want
83:48 - to do nothing basically now we have stored the data as well now we just want to return
83:53 - that data to our client side we do that using response dot json it told you response will
84:00 - allow us to send data to send data you can also use send and then send it but with json
84:07 - it will automatically encode it in a json formatting that will be easier for us and
84:14 - then we'll just pass in the user and we'll pass in like this so we want user user alternatively
84:23 - what you can do is just pass in user so when the key and the value name are the same thing
84:31 - you can use the shorter hand syntax instead of typing this full you can just type user
84:37 - and it will know that it means user user correct and we can do the same thing over here as
84:44 - well so instead of having name name name you can just have name profile pic email this
84:51 - will only be allowed in objects or maps you can't use it anywhere else obviously you can
84:57 - just use it within these curly brackets so even here i can use it because there is a
85:03 - curly bracket it's an object great now i can send the data so let's try to test this
85:08 - api now how i'm going to test this api i don't want to go to the client side write the whole
85:13 - bunch of code and then realize i've done something wrong i can't use this right so to test this
85:19 - you can install an extension called thunder client with thunder client you can test your
85:24 - api within your application or within your vs code itself if you're using android studio
85:30 - to follow this tutorial i'll recommend you to install a tool known as postman postman
85:37 - will allow you to test this api and it has much more features than thunder client as
85:44 - a matter of fact if you're using vs code as well but if you want more features than this
85:49 - thunder client gives you you can use postman this will allow you to test debug you can
85:55 - see it will allow you to do that and over 20 million developers already use it but i'm
86:02 - going to use this thunder client because my tasks are very simple i just want to send
86:07 - a post get or some kind of a request and then i'll get some data from here so now what i'm
86:15 - going to do is test this api so i'll go to the thunder client i'll create a post request
86:23 - and click on send but you can see i cannot post slash api slash sign up so how i'm going
86:28 - to do that well why is this even happening so this is happening because in auth.js file
86:36 - we've created our auth router and stuff that's all cool but our index.js is the main file
86:42 - and it doesn't really know what auth router is you can create as many files as you want
86:46 - but you need to register it with the main file and the main file is what we have passed
86:51 - in over here the main file index.js you have to make sure that even index.js knows about
86:57 - it because javascript or node.js will only execute this code we want further code to
87:03 - be executed as well so let our index.js file know about this how are we going to make them
87:08 - know well we're just going to use app.use this is known as a middleware basically when
87:14 - the data comes from the client side to the server side there is something known as middleware
87:19 - in between of them what does this mean let me show you a diagrammatic representation
87:24 - this is our server or the client side this is our server side we are sending some data
87:32 - from here and when we send some data and we want some data it will send us back over here
87:39 - let me just label this this is client this is server sorry for my terrible drawing so
87:45 - here we have the client and the server but what if i want to manipulate some data in
87:51 - between how i'm going to do that well i can do it in the server side but sometimes it's
87:56 - not just acceptable so you do that in this middleware box this is the middleware box
88:03 - i'm just going to create it again so with this middleware box let me just type in m
88:12 - with this middleware box i'm going to manipulate any data coming but here i'm not really manipulating
88:20 - data i'm just using app.use so that i can make sure to use this author router so i'm
88:29 - just going to pass in author router over here but this is called a middleware similarly
88:38 - we are going to use middleware for authentication purposes as well when we get to it make sure
88:42 - to remember this diagram if you want take a screenshot of it a very systematic representation
88:49 - but this middleware is very important for us but you can see when we type author router
88:55 - we are not able to import it again we have to pass in the module.exports line so we'll
89:00 - have module.exports equal to author router now we can take this author router and now
89:09 - we can import it as well so now if i try to run my application let's see if we have no
89:16 - errors i'll go to the extensions tab use thunder client and after you install it you'll get
89:22 - this option just i'm going to click over here i've passed in some data already but if you
89:29 - want to test yours you can just click on new request and pass in data when you click on
89:34 - new request you'll have to pass in this url over here localhost 3001 which is the port
89:39 - we are on and then slash api slash sign up whatever route you want to test and then you
89:46 - might be over here you have to go to this body pass in adjacent content like this you
89:52 - have to pass in a curly bracket then the name email and profile picture make sure to do
89:57 - that single inverted commas are not allowed only double inverted commas are allowed then
90:03 - we are going to send the data and you can see processing is there but it's requiring
90:09 - so much time for this processing that means something is wrong there has to be something
90:13 - wrong when there is so much wrong i mean there's so much time and the reason for that is if
90:18 - we come over here we are destructuring this property but how are we able to destructure
90:22 - it we want to make sure that whatever data comes to us let's go to our diagram again
90:27 - whatever data comes to us from our client side to our server side is always in json
90:34 - format we can't guarantee that because when other developers join in it won't be very
90:40 - easy for us to keep them telling them that this has to be json this has to be json right
90:45 - so instead of that what we can do is app dot use express dot json so what this will do
90:54 - this is again a middleware as i told you so whatever data is coming here it will take
91:00 - that it will convert it into a json format and send it to the server as i said the manipulation
91:06 - of data this manipulation of data has occurred here and i said sometimes it can't just happen
91:12 - in the client side that's why now i'm going to go over here again and now i'm going to
91:17 - send the request and you can see it was very quick it was very instant so i've got my user
91:23 - already created now if i just go to my server and refresh it you can see user's collection
91:32 - is there and here we have it this is id this is the automatically generated id by mongo
91:38 - db we nowhere mentioned it to create it created on its own and it's of the type object id
91:44 - which is another type created by mongo db you can consider it this way then we have
91:49 - name as naman email as number 123 and profile pic as test 123 obviously our profile pic
91:55 - is going to be different later on but here we have it our user is now created our models
92:01 - are working well now the next part is connecting it with the client side let's get into it
92:07 - so for that i'm going to come to the auth repository simply and we're replace all of
92:12 - this with this much now let's understand what we want to do all right so now what i'm going
92:18 - to do is in the lib folder i'm going to create a new folder called models and in this model
92:23 - we are going to create a user model file pretty simple it's going to be very similar to the
92:27 - user model we just created it's going to be well first of all we have to create a class
92:32 - so we love class user model then we are going to have final string profile picture final
92:41 - string email final string name but other than this we also need something known as a token
92:51 - which is going to be empty initially but later on we are going to add this token and another
93:00 - thing that we need is uid if you're getting confused with token don't worry i haven't
93:04 - explained it yet i mean we will get to it when we get to it it's just the next step
93:09 - after this sign up process so we're here in our user model we generated a constructor
93:15 - we need other classes as well so i'm going to generate jsong serialization and then just
93:21 - save it i'm going to close the terminal go to the sort repository and in here i'm going
93:26 - to create instance of this user model class so i'm just going to pass in user model then
93:32 - we need to pass in the name email sorry so we'll have user dot let's see and we have
93:39 - named the same thing you can see this is user even this is user so now we have to change
93:44 - this name i'm just going to call this user account then we will have user account sorry
93:50 - this will be user dot email this will be user dot name and this can be null so let's pass
93:58 - in this over here and this is going to be display name one second then we need a profile
94:05 - pick so we'll have user dot photo url and the uid so the uid is going to be empty for
94:13 - now token is going to be empty for now why are they empty well as i already mentioned
94:19 - to you they need to be initially empty because we don't have the uid access yet token access
94:26 - yet we all we have is these three great after creating this we need to send a http request
94:33 - so to send the http request obviously we'll have the http plugin installed this is the
94:39 - pub.dev page of it it's created by dart language or google itself you can go through the documentation
94:47 - if you don't know how to use it but i'm going to go through in this tutorial anyways now
94:52 - for the unit testing obviously we'll have to get the instance over here whatever packages
94:58 - that are there need to be coming from here so we're going to final client client and
95:05 - obviously this is going to be underscore client and we are having client because http directly
95:10 - provides us with post and get methods but we don't want that we want to use client so
95:16 - that we can mock it if you're familiar with unit testing you might know so i'm just going
95:20 - to have client client then over here we're going to have client set equal to the client
95:28 - i've already explained this in detail now we can have client dot post i hope that's
95:35 - the method if you go to roth.js we can remove this comment not needed anymore we will have
95:40 - post request here so i'm just going to pass in post then we need to pass it to a specific
95:46 - url now to get the url what we are going to do is create a new file in the lib folder
95:51 - called constants dot dot in this constants file we are going to store all the constants
95:59 - of our application for now there will only be one so we'll have constant host and then
96:06 - here we need to pass in the host well of course we have to pass in http slash slash local
96:12 - host 3001 and why are we storing it here well if we just come to this auth repository you
96:20 - might notice that we will keep using this host because we have to keep sending get request
96:26 - or post requests right so we will keep using this instead of writing this whole big string
96:32 - and making some error we can just use this host and other thing is when we deploy our
96:38 - application to some server then the url will change it will no longer be http localhost
96:43 - 3001 that time as well it will help us so anyways here we can type in host but another
96:53 - problem here is we can't have localhost if we have localhost it won't really work on
96:59 - the android app it will work on ios it will work on web but it won't work on android so
97:04 - to fix this issue we have to pass in our ip address now to get your ip address on mac
97:11 - you can just search on the net how to get my ip address but this ip address doesn't
97:15 - have to be you know public ip address it doesn't have to be this public ip address no it doesn't
97:26 - have to be public ip address it has to be your own private address just type it on the
97:31 - net how to get your own private ip address if it's public ip address it won't work if
97:36 - you type on google what's my ip address it will just give you a public ip address that
97:40 - won't be allowed you need to use your private ip address anyways i'll just type in my own
97:45 - ip address here and see you when i get done with it alright i'm closing my constants.dart
97:53 - file and in the host let's just first of all import it and i don't think it's importing
98:01 - let's quickly import the constants.dart file and here in the host we have to pass in slash
98:07 - api slash signup whatever we named over here in our router then we need to pass in you
98:16 - can see this is already giving us an error because it wants a type of uri so we want
98:21 - to pass this so that it passes this string and converts it into a uri after that we need
98:27 - a callback function not a callback function sorry we need to pass in the body and the
98:32 - body is going to be user.to.json not user user account.to.json and that's pretty much
98:41 - it then we need to supply headers to it and this header is going to be content type application
98:51 - json slash json semicolon charset is equal to utf minus eight or dash eight basically
99:03 - this header will tell this header will tell this is a type of json format please accept
99:12 - this if it's not if you don't add this it will give you an error or a warning something
99:18 - like that then we want to save it in a res variable we'll also call await because this
99:24 - is a future and in javascript terms it's a promise now i'm going to after getting this
99:32 - response i'm just going to handle this so we are going to have switch res.status code
99:38 - so our thing our whole concept is determined on the fact that what status code are we receiving
99:46 - and with this i realize the error in our code already if you see in the try block we have
99:51 - sent in dot json but here we can also add something known as status you can see it adds
99:59 - a status code this status code can be anything for example the most famous one is 404 404
100:06 - basically means not found that is a status code for telling that that yeah we didn't
100:09 - find this page sorry with 200 we say that everything is okay but we don't add it over
100:15 - here because by default it is 200 if you don't mention anything it's going to be 200 but
100:21 - in the try block and in the catch block the error that i mentioned we have to pass in
100:26 - some error right so we will just pass in res.json error e.to string or e.message whatever you
100:35 - want and here if we send it you can see again that would be a problem because res.json will
100:43 - have a status code of 200 which is not acceptable by us we want a status code of 500 which means
100:51 - internal server error so that means that some server error has happened we don't know what
100:56 - but here is the error here is the status code something has gone wrong it's not successful
101:02 - so anything that's not 200 has to be passed in over here if you don't pass in your error
101:07 - handling method will all go wrong all right so in our switch block we will just write
101:12 - if the case let me just write it case is 200 then what we will be do well we'll just use
101:21 - new user and set it equal to user which is this user we don't want that sorry we want
101:31 - user account so you want to use this user account and then have user account dot copy
101:37 - with we don't have the copy with function so let's go in the user model create a copy
101:41 - with function save this much come over here and we'll have copy with function with this
101:47 - we are able to change contents of the user account for example if i want to change the
101:51 - email we can i can change the email already with this copy with but if i directly try
101:56 - to do this user dot email is equal to something you can see this is getting an error because
102:02 - over here i've set the type of my email to be a final final won't change so to change
102:07 - it what i'm doing is copy with if you want to understand the working you can go through
102:12 - this function what it really does all right so in the copy with function i'm going to
102:18 - pass in uid because that's the new thing and the token now we have not received the token
102:24 - so i'm going to leave it empty for now the next thing we are going to work on is the
102:27 - token so here we are going to get that user correct so how i'm going to get that data
102:34 - let's go to this thunder client in our local host you can see this is our object model
102:40 - whenever we send the data we are basically sending all of this how are we sending all
102:45 - of this we have our user account we are converting this into a user model while sending it we
102:52 - are converting this user body to json to json behind the scenes encodes this to map function
103:00 - and to map basically converts it into a map so after encoding and all of that stuff we
103:06 - send it to our server in our server we just extract all of these things since it's an
103:12 - adjacent format and then we just do our processes that's how the whole process goes all right
103:20 - so now to get the uid you can see we have a json bracket and in that we have user so
103:27 - how are we going to get that well first of all how do we get the information to get the
103:31 - information we always do res dot body so whatever response we get that body to get the request
103:39 - you can see to get the request data we are using request dot body but to get the data
103:46 - we are going to get response dot body so in client side we are going to have so in client
103:52 - side to get the data we are going to use response dot body but in the client server side we
103:58 - are going to use request dot body great now response dot body is simply a string we need
104:06 - to convert this into a json format so that we can access objects on it so how are we
104:11 - going to do that well simple enough json decode with this function we'll be able to convert
104:17 - our response dot body to a proper function or to a proper json file or to a proper json
104:24 - string then here i want to access the user property you can see here there is the user
104:32 - property i want to access that property but i just don't want the user property i also
104:38 - want its id so i'm going to have user and the id id here is underscore you won't be
104:44 - able to see it but if you go to the mongo db you can see its underscore id so i'm going
104:50 - to pass in another thing like this so we are taking response we are converting it into
104:58 - json accessing the user property and in that user property we have id property and that
105:03 - will make sure that we have the correct user id let's see what error are we getting well
105:08 - we need to pass in this client so we'll pass in the client as well simple enough you see
105:15 - the usage of this provider now i've just created it over here if i use this auth repository
105:20 - provider in like hundreds of files i don't have to go in those hundreds of files and
105:24 - then use this client instead i just have to modify it over here and everything else falls
105:29 - in place there were no errors in any other file all right so let's go down again here
105:38 - add a break then add a default and in that default we can just throw a string error saying
105:47 - some error occurred otherwise what you can do is just leave it over here it wouldn't
105:53 - really matter in our case at least if you want to do advanced error handling you can
106:00 - just go ahead and do that for example case 400 case 500 all of those types but i'm not
106:05 - going to go that deep in this application all right now how do i get the data how do
106:13 - i store it in my state management system so for that first of all i have to create that
106:17 - state management system so above at the top of my file i'm going to create something known
106:23 - as user provider this will keep track of our user data and this will be equal to state
106:29 - provider this is another type of provider provided by river pod this will also have
106:35 - a ref but i didn't think i care about that and initially the value will be null also
106:41 - here let's give it a type of user model what is all of this basically we're creating a
106:47 - user provider which is of the state provider the problem is if we use this provider it
106:53 - is just a read-only widget we can't we can't just modify the values in this provider to
106:59 - modify the values we can use state provider or other type of provider like change notify
107:04 - provider all of that but state provider is the easiest of all so i'm just going to use
107:09 - them and here i've provided the type if i don't provide this type and hover over this
107:13 - you can see the type of the state provider has become null but that's not true initially
107:19 - the value is going to be null why is it going to be null because when we do our state persistence
107:25 - in our main.dart file we are going to check if the user is null that that means that the
107:31 - user is logged in if the user is not null that means that the user is not logged in
107:35 - so for that we wanted null but if i pass the value of null to it it will cause me some
107:42 - bugs some warnings some errors later on in my application so i'm going to provide it
107:47 - with the user model type as well and this is nullable if you just type this it can't
107:52 - be null correct so just pass in and empty this that means it's a nullable now if you
107:58 - hover over this this has a type of user model now obviously i want to use this user provider
108:05 - in my application over here because i usually like to keep my providers separate from my
108:11 - business logic so i'm going to do that in my ui file usually you will use controllers
108:16 - for that but i'm not going to go that deep into this architecture this is a very simple
108:21 - application the main point of this tutorial is to get you familiar with node.js and sockets
108:27 - so let's now dive into it over here though so how i'm going to well work in the ui file
108:36 - i have to return from return something from here correct only then can i give some thing
108:43 - so i have to change this type but what will the type be i that's a very complex thing
108:49 - because i if there's an error i want to show the error if there's a data i want to show
108:54 - the data so do i pass in a map that would be an ideal choice you have to pass in a map
108:59 - but instead of doing a map way i would like to create another model called error model
109:06 - with this error model you can well first of all create a class and you don't have to pass
109:13 - in model like this instead models are much better than maps whenever you get the opportunity
109:20 - i try to do that they reduce the scope of errors and they are much reusable as well
109:26 - so here this is going to have two properties final string error final dynamic data this
109:36 - is a very rare use case i found for data data i usually try to give types to everything
109:42 - that makes my code much better but here the data can be anything it can be a string it
109:49 - can be an integer it can be a custom class as well we don't know what we're going to
109:54 - return so i'm just going to pass in a dynamic over here now i'm going to create a constructor
110:00 - and that's pretty much it if we want any other functions we can get to it all right over
110:05 - here though i'm going to change the return data type to future error model now we need
110:13 - to return this error model so first of all we'll instantiate this we are not creating
110:18 - this inside of the try block otherwise the scope is limited to this try block we want
110:22 - it to be accessible even outside of this function now here we are going to have error model
110:28 - equal to error model then we pass in the error which will be some unexpected error occurred
110:37 - the data initially is going to be null if all of our if our try block gets removed i
110:45 - mean here we are going to change the value but if that's not the case then it will tell
110:50 - you that something wrong happened i don't know what but there is something wrong but
110:57 - if there is a case 200 that means everything went well make sure to not add it over here
111:01 - if you add it over here that will be bad but if you add it in case 200 that means for sure
111:06 - everything went well so error is equal to error model then we will pass in the error
111:13 - error is going to be null now error here is not showing null so i'm going to go here and
111:19 - pass in question mark that means it can be null and we didn't have to do the same thing
111:24 - for data because dynamic can also be null but in the data here we are going to pass
111:30 - in new user you can see right now we are passing in a custom class which is user model usually
111:38 - i mean we can just pass in a string as well so that's why the dynamic and in the catch
111:44 - block as well we are going to have something similar so let's just copy this line remove
111:48 - the print warning and in here the data will be null the error will be e dot two string
111:57 - whatever we get over here that's going to be the error alright that's pretty much it
112:02 - let's see we have to return this that's why we are getting an error so i'm going to have
112:06 - to return this error great now i can go to my login screen where i've called this sign
112:13 - in with google function you can see the return type is error model so i have to create this
112:17 - asynchronous i'm going to await this and then get the error model so i'm going to call this
112:25 - final error model is equal to this then i'm going to check if error model dot error is
112:34 - equal to null if the error is there then we want to show a snack bar so for that we are
112:40 - going to use scaffold messenger dot off context dot show snack bar and then we will pass in
112:48 - a snack bar the content which is going to be a text and it will just be error model
112:53 - dot error let's just pass in not and over here it's going to be not equal to null so
113:02 - if error model dot if error model dot error is not null then this should happen but of
113:08 - course we don't have build context so let's accept build context and that throws another
113:13 - warning but we'll get to it so here we have it now you can see do not use build context
113:19 - across async apps to avoid that what we can do is final s messenger is equal to scaffold
113:30 - messenger dot off context let's put it here we'll take the s messenger and put it over
113:35 - here so now the error is fixed we have used context before making the asynchronous call
113:41 - and then we are showing a snack bar but if there is no error then what should we do and
113:46 - actually i like it this way better i'm just going to put this in the else block so if
113:54 - the error model dot error is null that means everything was successful that means data
113:59 - has some value what are we going to do well i just want to go to the home screen so i'm
114:06 - just going to create another screen called home underscore screen dot dot import material
114:13 - dot create a stateless widget and then home screen this is going to be a scaffold save
114:21 - this much also here in our body we are going to have a centered child text which is just
114:34 - going to be reading from our river pod so we are going to have consumer widget and this
114:41 - will have a widget ref everything we have done so now in the text what are we going
114:47 - to add well i just want to check for now that the email is correct or not so i'm just going
114:52 - to have ref dot watch user provider dot email and this has to be not nullable that means
115:02 - that the user provider now has some value and it obviously has some value because we
115:05 - went to the home screen but before navigating to the home screen we also need to make sure
115:11 - that we store it in our user provider how are we going to store it well simple enough
115:17 - we are just going to use ref so we are going to have ref dot read user provider over here
115:23 - if i type this you can see i'm not getting any option to edit it what should i do it's
115:28 - just showing me the values of the user model the properties available on user model because
115:33 - this is of the type user model to make some changes you'll have to add dot notifier here
115:39 - and then you can update the value you can see now we are getting different options now
115:43 - i can call dot update and now i can update the state so the state can be error model
115:51 - dot data that's pretty much it they should update it now i have to go to the next screen
116:00 - so again i'll have to create navigator here otherwise the same message warning that we
116:04 - will get we need to avoid that so we'll have navigator dot of context obviously we'll have
116:13 - navigator replaced later on when we use some package so that we can have our proper routing
116:18 - done but for now we will just have navigator dot push then we will pass in material page
116:30 - route we'll get a context and here we just need to return the home screen i can ignore
116:38 - the warnings for now or i cannot let's just check not ignore it i'll save this much i'll
116:45 - have to start my server i exited it so i'm just going to run it again i'm also going
116:49 - to run my web version and see if it's working or not and i just realized i've launched chrome
116:57 - on a wrong version i have to launch it on a 3000 port so i'm just going to run the command
117:03 - that we already earlier had which is this flutter run dash d chrome web port 3000 and
117:10 - we are running this on 3000 but our server is running on 3001 that's a keynote if you
117:15 - run both on 3000 that will be a scope of error all right so our app has launched let's go
117:20 - over here sign in with google and you can see it sends us xml hcdp request error now
117:27 - why am i getting this error well that's basically because of an error known as course cross
117:32 - origin restriction basically this is a very multi-platform app you can run it on android
117:39 - app ios web whenever we are sending hcdp request you can see we're sending it from web we can't
117:47 - share it you know from web from android all of that so to solve this error we will just
117:55 - have to close our server and run npm install course course issue is a very major issue
118:03 - i mean it just happens to everyone so make sure to add that over here we just have to
118:08 - import it first so we'll have constant course is equal to require course if you want to
118:14 - know more about course you can check out the web it's a pretty big thing i can't explain
118:19 - it all together over here over here i'm just going to use app.use and then pass in calls
118:26 - and since we are here i realize another error that we might have made we have to go to the
118:32 - user model here and in the from map function you can see everything is correct except the
118:38 - uid part because uid is not really uid it's underscore id you can see it in our thunder
118:46 - client as well if we just go over here everything is correct except underscore id we want the
118:52 - underscore id as well correct so here instead of having uid we are going to have map underscore
118:57 - id now i can restart my server okay i have to restart my server not use this i can go
119:09 - to the index.js file and instead of using course like this i have to use it like this
119:15 - as a function now save this much i'll try to run the app on web again i'll restart the
119:21 - app then i'll click on sign in with google and you can see revan contacts at the rate
119:27 - gmail.com showing up now if i go to the home screen and you're type in id just to make
119:35 - sure uid just to make sure it's correct and i have to restart it of course when you restarted
119:42 - the state didn't persist we have to work on that we are going to do just that after testing
119:47 - this out we're going to click on sign in with google and our id is showing up as well that
119:53 - means everything worked now the next part is whenever we restart the app we don't want
119:57 - to come here if we are logged in we want to stay logged in if you're not logged in we
120:01 - don't want to stay logged in come on the screen let's get into it so how is this entire state
120:06 - persistence thing going to work out well i'm going to draw a diagram to explain that to
120:11 - you well again this is our client side this is our server side and now we want to process
120:18 - the state so obviously we've done the login process we have sent it across then we've
120:22 - got our data but that's all is over we understood the problem as well but now to process the
120:28 - state what we're going to do is first of all whenever we log in we are going to send that
120:34 - data across but here when we do our login processes for example when we do it in our
120:40 - index dot js and in the author router sorry if we come over here let me close the terminal
120:48 - here we'll be generating a jwt which is json web token this token will allow us to securely
120:56 - store the user id within ourselves and verify if it's a correct user or not so here we will
121:05 - generate a jwt and send it across to the client side so when we got here we're going to send
121:10 - this across but with a catch we are also attaching our jwt with it so we are attaching our jwt
121:19 - with it as well now over here in our client side and this is the server side so whenever
121:26 - in our client side we get the jwt we are going to store it in our local machine that means
121:32 - in the device for example if you are on web we are going to store it in the local storage
121:36 - of web if you are on android or ios we are going to store in the local storages of those
121:40 - devices this jwt will get stored here and then whenever the user quits the app or suppose
121:48 - here we restart our app we are going to check whenever the restart happens that means whenever
121:53 - we get to the root of this file whenever we start our application here we are going to
121:58 - check if the jwt is there or not in our local storage if it's not there in our local storage
122:05 - well we are not logged in but if it is there then we want to get the user information as
122:09 - well because ultimately if i just sign in with google because ultimately i want to display
122:15 - some information on my webpage that's not going to happen in our application but in
122:19 - case you want to display a profile picture let's suppose so after you restart the app
122:24 - and the user is logged in you could get to the right screen as well but you don't you
122:28 - won't have the user data in your provider right because we are adding to our provider
122:33 - after we get the user information from our auth repository that means over here here
122:39 - we are creating a new user sending it over going to the login screen we are getting this
122:44 - and reading from here but that won't be the case when we restart the application when
122:49 - we restart the application we'll directly come here we'll check okay there is no user
122:54 - we'll go to the home screen login screen if there is a user okay let's go to the home
122:57 - screen but where is the data where are we storing it in our user provider we are nowhere
123:02 - storing it so exactly we are going to fetch the user information with that jwt that's
123:10 - why we are using jwt jwt will securely process that user id that we are going to sign it
123:18 - with you'll see later on in our code but with that we are going to sign our jwt and when
123:25 - we send it to the server again to fetch our data we are also going to pass in jwt so all
123:31 - of this stuff has happened now let me erase it off so all of that stuff has happened now
123:36 - for state persistence we will send across our jwt and in our server side we'll make
123:41 - some code so that it can send it across again and give us the user data so after we have
123:48 - this user data we can access our application pretty simple correct now let's get into it
123:54 - we are going to go to our authorouter so let's quickly go there where is our authorouter
124:01 - yeah and here we are going to well first of all create a json web token so for that we
124:07 - have installed a package correct now you know jwt is just for securely transmitting information
124:12 - so and just to mention why are we using the securely transmitting information not directly
124:19 - id we can store the id as well in our local storage but if we use the id there is a great
124:24 - possibility a hacker or someone else might get into your phone crack your phone and just
124:30 - see the local storage of your application so we don't want that we always want to secure
124:36 - it that would be really good as well correct now over here i'm going to have jwt and we'll
124:43 - require it saying json web token jwt is just short but this is the package name json web
124:49 - token now i'm going to use this jwt and as i said we're going to sign it with something
124:55 - which is our id so we already have the method for it you can see sign so always we need
125:01 - to provide jwt you can consider jwt like a wrapper around some information so with jwt
125:07 - we will get a random generalized random generated token but we want to display something correct
125:14 - i mean not display but we want to get some information based on it so for that we are
125:19 - going to have jwt dot sign then we are going to pass in the id and the id is going to be
125:26 - user dot underscore id now let's understand why we did this over here we found the user
125:34 - whatever user we had in mongoose with the same email we have already used that now here
125:39 - we are just checking if there is no user that means we need to create the new user so we
125:44 - have saved it and then we are you we are assigning it to the same variable right so we can use
125:50 - user dot underscore id if the user is newly being created then it will save it if it already
125:55 - exists we already have that same user variable there now here i'm going to have constant
126:02 - token equal to jwt dot sign having this i can just take this token and pass it along
126:09 - with our user and that's why we had this object created otherwise you could have just done
126:14 - user and it would work just fine but we want to do we wanted to send token as well so i
126:19 - did this now as we are here we can also create another route which is to get the user data
126:26 - as i mentioned already over here we need to get the user data so i'm just going to create
126:30 - another route called authrouter dot get we are using the get request here because we
126:36 - want to get the user data here we use the post request because we wanted to send some
126:41 - data to our database and here i'm going to have just slash then we are going to have
126:48 - something known as an auth middleware which we are going to create just now and then we
126:53 - are going to have async request response and then this is all of our code our route so
127:00 - basically whenever we access localhost 3000 but with only a slash we don't want anything
127:07 - else slash api slash sign up is not required we only require slash that time we will use
127:13 - this slash and you can have multiple routes with this slash for example you can also have
127:18 - authrouter dot post but this part needs to be different otherwise this part needs to
127:23 - be different but it has to be different you can't have two routes with the same url right
127:28 - i mean the server will get confused all right now what is this auth middleware well auth
127:35 - middleware as i mentioned you can guess it it's a middleware so let me get my illustration
127:42 - quickly so here we are going to have our middleware obviously as i mentioned this is a middleware
127:48 - part but in this middleware whenever the client sends some data it will come over here now
127:54 - in our application we are going to have a feature wherein the logged in users will only
127:59 - be able to see certain types of routes for example document only the logged in user will
128:04 - be able to view the shared documents will be able to create new documents all of that
128:09 - stuff so we need to make sure that we add a layer of protection to check if the user
128:14 - is authenticated or not so if the user is authenticated then only we can proceed forward
128:19 - now of course we can put that in every route for example if i have this route i can here
128:26 - get the user's id from the header and then check and why header why not body because
128:34 - get request don't allow body i mean we are just getting the data so what's the use of
128:38 - body but there is something known as header so tokens are generally sent from the header
128:44 - now with this header we can get the user id and then check in our database if that user
128:50 - already exists if the user exists that means that the user is authenticated if the he is
128:56 - not then they're not authenticated all of that stuff also we'll have to say check something
129:01 - regarding the token correct because we want to know that the user is logged in or not
129:06 - i mean the user can just log in and then click on log out and after that we we don't know
129:11 - if the user logged out correct so for that purpose jwt will help us and we'll create
129:16 - all of that in auth middleware we won't do it in this route of course we can do it in
129:21 - this route but it wouldn't make sense to do it for hundreds of routes correct so here
129:27 - we are going to get some data we can access that auth middleware so this is our auth let
129:32 - me create that a so this is our auth middleware after we get that we know if the user is logged
129:39 - in or not if the user is logged in then we can perform our task accordingly if not then
129:44 - we can just say the user is not logged in i don't know what you're telling so let's
129:49 - go here and create the auth middleware in our server we are going to create middlewares
129:54 - and this auth middleware that we are going to create is a very important thing in our
130:00 - application you can understand that right away because on this our entire application
130:07 - is going to depend because logged in users will only be able to see the google sign in
130:12 - button no other route they'll be able to access so this is a very important feature if you
130:19 - didn't understand make sure to leave a comment and i'll try to explain it to you again anyways
130:24 - now let's create a function for authentication we are not going to use mongoose for it because
130:29 - well obviously mongoose has to do something with mongo db we don't want to do anything
130:35 - with mongo db so here i'm going to have my auth middleware it's going to be a simple
130:40 - function and it's going to be async request response next and then since it's async we
130:49 - are going to have a try and a catch block then here we are going to first of all access
130:57 - the token and we are going to get the token here from the request dot header so we can
131:03 - have constant token is equal to request as i mentioned request allows us to view body
131:10 - allows us to view header so this is the header and through the header we are going to pass
131:19 - something known as a token and i'm going to call this x auth token i like to generally
131:24 - call this i think it's a convention as well i'm not pretty sure about that anyways you
131:29 - can name this whatever but make sure later on in your application whenever i use this
131:34 - x auth token you have to replace this with your own token i mean with your own line for
131:40 - example if you type in token you want this to be token not x auth token then then here
131:47 - you can check if there is no token mentioned that means there is some problem because you
131:54 - have not mentioned any auth token so we can just return response dot status 401 why are
132:04 - we having 401 because 401 means no authorization i mean the user is unauthorized that's why
132:12 - you're using from 401 if you use 400 it would make sense a bit but it still doesn't clearly
132:19 - make sense because 400 means bad request so here i'm going to pass in 401 no authorization
132:29 - so we are just going to have a json and here we are going to type in a message if you want
132:33 - you can have an error as well but i'm going to go ahead with message and i'm going to
132:37 - type no auth token access denied now if there is no token then you're going to return it
132:49 - so if there is no token mentioned then we are returning it that means we are getting
132:54 - out of the function so we can use the guard clauses technique here and obviously just
132:59 - continue along so here we are going to have constant verified so that we verify now how
133:06 - are we going to verify the token it's in a jwt format you remember we are sending the
133:12 - data we are getting the data back jwt we are storing it in a local machine and then we
133:17 - are sending this data again to a server let me remove the arrow so that it's not confusing
133:23 - so we are again sending our data the jwt to a server through the header and xoth token
133:33 - is exactly that jwt so how are we going to verify that jwt is in a gibberish format it's
133:38 - not a real id how are we going to do that well obviously we are just going to have jwt.verify
133:44 - method on it now let's access jwt as well so we are going to have constant jwt is equal
133:53 - to require json web token and now we have access to this i can just call verify method
134:01 - now in this verify method first we need to pass in a token so our token is this and then
134:07 - we need to provide it with a key so if you go here we have made an error already here
134:13 - in the sign method it requires a payload which is our id and a secret or private key this
134:23 - secret or private key i need to mention now what is the secret key going to be well it's
134:28 - just going to be something you can access your jwt with for example if you want multiple
134:35 - jwt's in your application it's not just for you know storing or securing the information
134:40 - or password it can be literally anything correct so here we are assigning the key to it so
134:48 - this is the password key if you want later on for a document for example you can create
134:53 - document key we are not going to need this in our application but for password we do
134:57 - need it so we will provide password key and exactly that we need to mention over here
135:03 - as well so that we can verify it then here we are going to check if not verified then
135:10 - we are going to return res.status again 401 because it's unauthorized json message token
135:19 - verification failed try again later or authorization denied you know this seems like a very good
135:28 - message all right now after having this if the user is verified then finally we can just
135:39 - do request dot user is equal to verified dot id what does this mean well here we are basically
135:51 - telling that the request parameter that we have can now have a new object on it this
135:59 - is how objects are used if i have not mentioned it already request dot user is equal to verified
136:05 - dot id not index of verified dot id so if we go over here and we have the auth middleware
136:15 - with us only when we have the auth middleware with us and the user is authenticated here
136:22 - we can just do console dot log request dot user and it will print out the id of the user
136:28 - because here we have stored request dot user as verified dot id so what has happened is
136:37 - we add our again big box here we went we are checking if there is authorization we are
136:44 - storing some information which is our id as request dot user then we are going here so
136:50 - it already has that information that yeah request dot user is this if you try to use
136:55 - it over here it will give you null or undefined something like that so you don't want that
137:01 - so obviously only when you use auth middleware will you be able to so yeah we have done that
137:06 - and similarly we are going to do for the token as well so we have we are going to have request
137:10 - dot token equal to token and now here we are going to have a catch block saying res dot
137:19 - status five hundred dot json error and here we are going to have e dot message great now
137:31 - you might have noticed that we have an extra parameter here which is next obviously this
137:36 - is not an express related route so this is a middleware now in the middleware i mean
137:42 - this comes in express but it's in the middleware of the express route so we also get access
137:50 - to next so we can call next over here which is a function what is this function well when
137:57 - we go from our client to us to our middleware we are having our verifications like if there
138:03 - is no token this then if there is a token then we can move forward so we'll have verified
138:09 - jwt dot verify then we are having a check if it is not verified then we'll return all
138:15 - of this and if it is verified then we are going to have all of this done but how does
138:21 - our server know that we won't go next i mean we do won't go over here we don't have to
138:26 - go over here all of this can happen but we won't go to the next part even if it is successful
138:32 - if we don't add this line we won't be able to go over here because our middleware doesn't
138:38 - know we have to go and when do we have to go only after all of these attempts have been
138:43 - done only then do we have to go next so we have added next over here all right now having
138:50 - done that let's export this don't forget it we won't be able to access it then we can
138:56 - take this auth middleware come over here and import that auth middleware great now that
139:03 - we have access to it we can use mongoose to get the user data that's what i had mentioned
139:08 - right so here we just want to get access to the user so we'll have access user and how
139:13 - did we get access to user well this line correct i've named it const instead of let because
139:19 - i'm not going to reassign it i'm just getting the data i just want to get the data and send
139:23 - it across so i'm just going to use the same thing user dot find one i can use that so
139:31 - i will have await user dot fine but here you can see find find one find by id which one
139:41 - do we use well we can use find and then find one of course because there's going to be
139:46 - only one user with the same id and then we can have underscore id as request dot user
139:55 - now this should work but i'm not sure if it will work because id is of the type object
140:01 - id that i would already mentioned to you but here it's of the type string so you might
140:05 - have to check that but another approach to this is just using find by id option you already
140:12 - have the id why don't we just use find by id option and then we can have request dot
140:17 - user and that's it that's all we need to write now we just need to send it across so we just
140:24 - have to pass in user and here we also need to pass in token now what is this token going
140:32 - to be well request dot token simple because here in our auth middleware we are setting
140:40 - request dot token as token so we already have access to it but here i'm not doing request
140:45 - dot token like this you can see there is an error so i have to do it like this only when
140:51 - the key and the value are same for example if this was this then only we could do this
140:56 - now if you seriously want to do it and think it's cool no problem you can just do constant
141:00 - token is equal to request dot token and then do something like this this will also work
141:07 - but just to make sure anyone reading the source code understands this properly i'm just going
141:14 - to do this great now after having this of course you can have the try and catch block
141:21 - wrapped around i'm not doing that now you get the gist of everything that i'm doing
141:26 - so i'm going to skip a bit of steps here now i'm going to close all the save file go to
141:31 - my auth repository file again now over here we're going to have something really similar
141:39 - so i'll just copy this entire function for your practice i would recommend you to not
141:43 - copy and paste this if i start copy and pasting the tutorial will be much shorter so i'll
141:49 - keep copy pasting but it would be highly recommended for you to type this all code so that you
141:55 - can create your apps in the future but even before doing that let me just remove the sauce
142:02 - i'll go up here and as we talked about in the client side in the login side you can
142:08 - see we have a body user account or two json and all of that good stuff here we are going
142:13 - to you do user account or copy with and also have access to token and this token is going
142:20 - to be very similar to this but instead of having you know user underscore id we're
142:24 - going to have token and this has no id it's just token all right so now let's just try
142:31 - to use our thunder client to do the signup process i'm going to click on send and you
142:38 - can see user is there and token is there and this is a pretty big token this has just converted
142:43 - our user id to gibberish so let's close this off and we have access to the token now whenever
142:51 - we get this token we want to make sure that we store it in our server in our local storage
142:57 - how are we going to do that we always obviously don't know how to store it in our local storage
143:02 - so for that we're going to use a plugin called shared preferences after installing that there's
143:10 - no other process required don't worry about it we will just go to our repository and create
143:15 - another called local storage local repository or i think a better name would be local storage
143:22 - repository and in this local storage well first of all create the class and then we
143:33 - are going to have our function well it will just be two function void set token so here
143:46 - we are going to have well this is going to be asynchronous so we'll have shared preferences
143:52 - preferences is equal to await shared preferences dot get instance and then we are just going
143:57 - to do preferences dot set string here pass in x auth token and then pass in the token
144:07 - so this is going to receive a token from here and paste it over here so what are we doing
144:12 - here well first of all we are getting the instance of shared preferences this is how
144:16 - you get it you can't do something like this to get the instance that's just wrong because
144:22 - you just can't have it so here we are receiving the token because we are going to call it
144:27 - here whenever we call it here we are going to pass in our token we don't have access
144:32 - to it as a local class then here we are going to have shared preferences is equal to await
144:37 - shared preferences dot get instance we got the instance of our preferences now we can
144:41 - call multiple methods on it we can call get the string set the string set boolean whatever
144:46 - value you want to set we want to set a string so we will pass in the key of it x auth token
144:52 - don't confuse it with the value of our server and our server also we are going to use the
144:57 - same value x auth token but just to reduce you know usage of many strings i'm using x
145:05 - auth token if you want you can even call this token but when we get the string we want to
145:11 - use this exact name we don't want to falter so let's just keep one name x auth token for
145:17 - all of that and now we have set the token that's all we have set it to our local storage
145:22 - now we need to do this for get token as well so we are going to avoid get token we are
145:28 - going to remove the parenthesis we don't want that anymore it's just going to be a single
145:33 - line function so we are just going to do preferences dot no it's it cannot be single line because
145:42 - we want this shared preferences get instance line so here we are just going to have get
145:52 - string x auth token this doesn't require anything else after we get this we obviously need to
145:59 - return this string so let's return this after having string token is equal to preferences
146:07 - dot get string await this this can be null so that's fine you can just return this token
146:16 - over here the return data type is going to be string and since this is async we are going
146:22 - to have future string and this apparently doesn't require await so let's just remove
146:28 - that so here what have we done well we have created instance of preferences now we are
146:33 - just calling get string on it which can be null because this string might not just exist
146:39 - we have made some error or the user is opening the app for the first time and logging in
146:44 - for the first time then we are just returning the token great now we want to use it over
146:51 - here so what are we going to do well we are just going to take it from the constructor
146:54 - first which is local storage repository it is a package i mean this class doesn't know
147:00 - about local storage repository instead of creating a whole new instead of calling it
147:07 - as an object i would prefer to use constructor so that it's the unit testing is much more
147:12 - easier so you'll have local storage repository again make it private then here we are going
147:18 - to have required local storage repository local storage repository and then just finally
147:25 - have underscore local storage repository equal to this local storage repository now we can
147:33 - take this local storage repository go down and you'll have local storage repository dot
147:39 - set token and this new token is going to be well the new user's token simple enough we
147:48 - add the new user we copied it with this uid and with this token now new user has access
147:55 - to this token or otherwise you could have just taken this from here and pasted it over
148:00 - here but what's the use of it just writing more code right so just use new user dot token
148:06 - and there we have it now we will go up here pass in the local storage repository simple
148:12 - enough now let's finally create the get user data route so whenever we have all of this
148:24 - done we want to get the user data even now we won't be able to you know possess the state
148:30 - because we have not got the user data we are not checking if the user is null or not we
148:35 - are not doing anything of that sort so we need to get this straight so whenever we get
148:39 - this user data well first of all rename this to get user data here we are going to have
148:45 - the same error model created then here in the try block well let's just remove everything
148:54 - till here because all of this we might need switch case error handling all of that stuff
149:02 - so here what are we going to have well we want to get the token first so that we can
149:06 - check if the token is null or not if the token is not null then we can get the user data
149:11 - if the token is null then the user is not authenticated sorry so here I'm going to have
149:20 - string which can be null token is equal to await local storage repository dot get token
149:30 - now we have token with us now we can check if token is not equal to null then we are
149:36 - going to send the request so we can just take this from here paste it in here even the switch
149:45 - cases methods and all of that stuff we can shift it in here also let's remove one bracket
149:54 - that's extra all right so now here if the token is not null then we want to send a response
150:01 - and it's going to be a get request because we want to get the user data for to get the
150:06 - user data we created a route which will just be host slash correct now we have the body
150:14 - as I said get request you can't send body if this was post you could see we could pass
150:19 - in the body but with get no body so let's just remove it so how do we send our token
150:25 - well I already mentioned correct we are going to send in X auth token and this is the header
150:31 - you might have seen we are sending this content type thing here we also need to pass in X
150:37 - auth token and here we will pass in our token now we may we know that it's not going to
150:43 - be null so we can pass it over now after this request is sent we are going to have switch
150:50 - response dot status code if it's 200 then what do we do in case of 200 well we will
150:57 - just remove all of this what we are going to have is user model user model dot from
151:06 - json and then here we need to pass in the source which is going to be user dot body
151:13 - correct no that's the that's the wrong part also this is going to be rest dot body now
151:20 - why is this wrong it does say from json right so we need to pass in our json which is a
151:26 - sponsored body but no that's not how we do it for example if you come to our thunder
151:31 - client here again you might see this is our response we are even passing in token now
151:37 - if we just pass in this it will just see two things user and token and none of our properties
151:44 - from user model dot from json you can see that from json calls from map and in this
151:49 - from map we are just doing email name profile picture all of that stuff but in our map we
151:54 - are passing in this entire object in our entire object this isn't map at user this is not
152:00 - map at token this is map at user at underscore id at underscore name so how do we fix this
152:10 - well simple enough we are just going to pass in this as response dot body at user so whenever
152:19 - we pass in user it will pass in all of that stuff correct but here comes another error
152:26 - we can't use on string these brackets so we will have to convert it to json so we will
152:36 - pass in json encode then we will pass this response dot body to it don't pass user to
152:42 - it just pass user and here we don't need to encode it we just need to decode it now you
152:49 - can see we have fixed the error but this basically means that you have returned a json we have
152:56 - returned a json object from json requires a string so we again need to make sure that
153:01 - we encode it so we will just pass in encode again here we will take all of these lines
153:07 - and pass it over here now it makes much more sense so what have we done we have decoded
153:13 - the json that we got by sending the response we are accessing the user property on it so
153:18 - that we get all of this data then we are encoding this json and finally calling user model dot
153:26 - from json which will read all of the property in this user tab which is id name email profile
153:31 - pic and that's why in from json you can see we have map at underscore id because our property
153:38 - here is map at underscore id but now what about the token token is also very important
153:45 - in our application how do we fix that we didn't get the token we just got the all the elements
153:50 - over here now to fix that what we are going to have is dot copy with and we need to pass
153:56 - in token like this and this token is going to be token well because we have the token
154:03 - already why do we use the token that it's giving us instead we will just take the token
154:08 - from here it's the same thing right you can also do all of this and pass in token but
154:18 - instead of doing that just pass in this token it's the exact same thing we are passing in
154:24 - the token in our index dot js file we are sorry in our auth router we are having auth
154:34 - middleware where we are storing this request dot header you can see we are having this
154:39 - request dot header where we are accessing the token and then sending it off to request
154:44 - dot token and we are sending this to our client again so literally the same thing we are sending
154:50 - off to our server and back to our client so why do i use that instead just use dot token
154:56 - and we have it we have our entire user ready now we just need to send that data across
155:02 - which is an error model all of our stuff is done now we can successfully go back to our
155:10 - home screen where we are going to come we are going to change this not to our home screen
155:15 - sorry in our main dot file where we can change this my app to a stateful widget here in the
155:22 - in its state we are going to call the get user data function because whenever app our
155:27 - app restarts we want this get user data to be there so i'm just going to call the get
155:33 - user data function here i'm going to create that function as well so we will avoid get
155:39 - user data asynchronous and now i will also have an error model created right up there
155:47 - so i'm going to have an error model error model which can be null so as long as the
155:54 - error model is null that means we are fetching the data so as long as it is fetching the
155:59 - data it's going to be null but so we can use that to display a loading indicator but what
156:07 - if the error model is when the error model is not null we can check the error model dot
156:14 - error if that is null if that is null there's something wrong anyways here we can pass in
156:21 - consumer so that we can give our user data some thing not user data sorry error model
156:27 - something some value so for this we obviously need to use auth repository to get access
156:35 - to auth repository we need reference widget ref now how do we do that in a stateful widget
156:42 - it's easy here here and here if you're wondering how i click with three cursors you can just
156:50 - click on option and it will select or deselect for you here i'm going to pass in consumer
157:01 - and you can see error goes away this i've imported flutter river pod that's why this
157:07 - is now a consumer stateful widget which is another widget provided by river pod itself
157:14 - and it's equivalent to consumer widget but just like stateless widget and stateful widget
157:19 - are different consumer and consumer stateful widget are different consumer stateful widget
157:24 - in our consumer state stores the reference the widget ref for example in our login screen
157:31 - if we go we add widget ref here but in our main dot file since we have consumer state
157:39 - we don't have a widget ref here it's already there present like we have set state present
157:44 - correct we have set state present only in stateful widget if we do it in a stateless
157:49 - widget it won't be possible without using another widget you know which is stateful
157:55 - builder so in our main.art file we are just going to use reference.read and we're going
158:03 - to read from the auth repository provider what do we want well we just want the user
158:09 - data so give it back to us and we need to await this because get user data will return
158:15 - future error model our error model is just of the type error model great now we can check
158:23 - if error model.data and before that we'll have to check if error model is not equal
158:33 - to null so if the error model is not null and error model.data is not null then we want
158:43 - to update the user provider that means the error model is not null it's not loading anymore
158:49 - error model.data is not null that means that there is data there is no error so we are
158:59 - just going to use ref.read user provider.notifier so that we can update it we have done this
159:06 - in the login screen as well.update and then we want to update it with whatever user data
159:12 - we get so we're just going to have user sorry error model.data and that's it this is of
159:22 - the type user model if it's correct I mean if there is no error because here in our auth
159:27 - repository we've passed a new user after having all of this done I think we have all the parts
159:37 - ready now we just need to check and watch first of all so we will watch here saying
159:45 - final user is equal to ref.watch and then pass in user provider then if you're using
159:54 - watch in the build method it's correct I mean you can use watch in build read in outside
160:02 - the build so here you can check if user is not equal to null then you want the login
160:10 - screen otherwise the home screen sorry I typed it reverse I'm just going to use user is null
160:18 - then login screen otherwise home screen now also I've noticed all the code part is done
160:25 - if there is no error obviously so I'm just going to start my web on the port 3000 otherwise
160:32 - it will give me an error correct so I'll run it on this port web port 3000 and let's wait
160:38 - for it so here I have the app ready I'm going to click on sign in with Google I'm signed
160:45 - in and you can see 63 all that ID stuff showing up now if I refresh my browser I'm again going
160:53 - back to the screen you can see even if I restart my app from here you can see nothing really
161:00 - changes because well we are on the screen and we will remain on the screen our part
161:04 - now is working successfully we have completed state persistence now let's try it on Android
161:10 - and iOS and if you have any errors there well let's just figure it out how to complete that
161:16 - so I've launched the Android emulator and here I'm going to click on sign in with Google
161:21 - and you can see null check operator used on a null value it does sign me in but it gives
161:26 - me a null check operator let's see why we got that error and the null check operator
161:31 - came here because of fear sometimes the display name or the photo URL can be empty display
161:37 - name is mostly never empty but photo URL can be so to fix that error what you need to do
161:42 - is this with this the profile picture will get stored with an empty string if you want
161:47 - to give a default profile picture you can pass that link of the profile picture over
161:51 - here but I'm not interested in that so I'm just going to give it an empty string for
161:56 - the display name also you can do the same thing if it is null then it will give somewhere
162:01 - if it will give an empty string otherwise it will give this value great now if I restart
162:07 - it should start the application now if I click on sign in with Google I go to the next screen
162:13 - if I restart the app I'm still over here you can see that now the next part of our application
162:20 - is going to be the document part but before that we need to work on something else we
162:24 - want to work on the routing of our application how are we going to manage the routing in
162:28 - such a big application correct now in spite of it being a big application you can use
162:37 - navigator but there's a problem with navigator dynamic links basically whenever I go on the
162:45 - web I want to pass in a certain URL that will fetch me the current document for example
162:51 - if I pass in whatever my URL name is localhost 3000 let's say after that I'll put slash
162:57 - document slash the ID of the document and I want to go to that document how am I going
163:04 - to achieve this that won't be possible with navigator so we are going to use navigator
163:09 - 2.0 for that but I found navigator 2.0 a bit tricky to use and explain so I'm going to
163:16 - use route master for it this is a wrapper around navigator 2.0 and it has a silly name
163:24 - that's fine but this is much much more easier to use if you are coming from a react.js you
163:31 - might know this as the react router DOM it's so much simpler to use it's very simple if
163:38 - you see an example you might see if we want a dynamic link kind of thing this is the link
163:47 - slash feed slash profile slash ID and to use this we are just going to use info dot path
163:52 - meters ID and we have it it's so much simpler and it's very similar to react router DOM
164:01 - so I'm just going to copy this and add it to my dependency I'm going to close this I
164:07 - don't need this anymore I'm going to run on my web because all of these changes won't
164:11 - be visible on phones correct it will only be visible on our web so I'll directly go
164:19 - to the main dot dot and here I need to register my routes first so instead of returning material
164:26 - app here I'm going to return material app dot and I just realized we can't run this
164:31 - we have to run on a specific port so let's run on that port here we have it web port
164:38 - 3000 now here instead of returning material app I want to return material app dot router
164:44 - we have all the same properties except this home and a few other for example routes that
164:50 - is no longer there now we have access to other things like router delegate router information
165:01 - parser router information provider all of that stuff but what we are going to use is
165:06 - two things route information parser which is constant route information parser and you
165:14 - can see abstract classes can't be initiated to fix that we need to return route master
165:21 - information parser and with that we have the property already passed in all we need to
165:28 - do is pass in this constant route master parser and you can see initializes a parser that
165:33 - works in conjunction with route master delegate now we need to pass in route master delegate
165:39 - so here in the router delegate property we are going to pass in route master delegate
165:46 - and here it requires a route builder now based on this route builder we are going to generate
165:52 - and tell which route can be used and what route can be used so here we are going to
165:57 - get a context which is very cool and also here we can return the route we want to use
166:06 - so I am going to shift my final user call in this context and now I am going to check
166:12 - if user is not equal to null and user dot token dot is not empty so if the token is
166:24 - not empty and the user is not null that means that the user is logged in so you want to
166:29 - return a route that will work for logged in otherwise you have to return a route that
166:34 - will work for logged out and here you can see it requires a route map so we need to
166:39 - create this route map I am going to create this in a different file altogether because
166:43 - as our app grows you don't want to fill this UI part over here right so I am just going
166:48 - to create another file called router dot dot in this router dot dot I am going to create
166:54 - basically as many routes I want as global variables so I am going to have final logged
167:01 - out route is equal to route map and here I have to pass in a required route called routes
167:11 - and here it's going to be a map now what is our first map route going to be it's going
167:17 - to be slash so whenever we are logged in what kind of routes do we want to make accessible
167:23 - we are doing that basically so router delegate will tell us that if we are logged in what
167:29 - all routes are accessible if you are logged in then all what routes are accessible so
167:35 - when we have slash we are going to well get something you can see but I don't really care
167:41 - about that still I can take this for this logged out route I don't care so I am going
167:47 - to have constant material page and in the child I am going to pass in login screen so
167:58 - basically whenever we are logged out what all routes do we want to display what all
168:02 - routes can the user go to well just the slash part so whenever the user is logged out and
168:07 - comes to this slash part for example localhost 3000 slash then the user will only be able
168:15 - to see login screen and what other routes do you want nothing else whenever the user
168:20 - is logged out all other actions are prohibited so we don't want anything else now I am going
168:26 - to copy this I am going to create logged in route and here well this is going to be slash
168:33 - again so whenever the user is logged in what all routes do you want to display so whenever
168:37 - the user comes on slash localhost 3000 slash and the user is logged in then we want to
168:43 - show them the home screen so I am going to name this home screen another route that we
168:52 - want is going to be document but we will get to it when we start creating and go to the
168:58 - document part for now logged out route has slash and this also has slash same thing but
169:05 - the only difference is if the user is logged out this will be returned if the user is logged
169:11 - in this will be returned and here we are going to pass the same thing if the user is not
169:16 - null and the user token is not empty then we are going to return logged in route otherwise
169:23 - we are going to return the logged out route note that logged in route will be able to
169:30 - display all of the routes that you want for example if you want other screens to have
169:34 - the same logged in route for example document on all of that stuff you can have that here
169:38 - but this will only include the for the users that are logged out to see an example let's
169:45 - quickly restart our application and here sign in with Google and as you can see I logged
169:52 - in and I am still on the same route I was on localhost 3000 I am still on localhost
169:57 - 3000 that's how crazy it is and even if I try to refresh I am not going back that means
170:05 - it's working so whenever we have slash it's working and this slash also works and that's
170:12 - because we are using ref.watch user provider this is because of river pod as well so whenever
170:19 - there is some change in the route you can see ref.watch runs and all of that stuff happens
170:25 - it reads the data from the user provider correctly and thus we get all of this output this is
170:31 - all together now let's go back to our login screen and wherever we use navigator of we
170:37 - need to replace this with route master dot of context and with this what we can do is
170:43 - navigator dot push but now we just have to pass in slash these have shorter methods for
170:49 - example if we want to do pop or we want to go to the other screen and we want to replace
170:56 - the other screen we can use dot replace instead of using push replacement all of that stuff
171:03 - just replace very simple now if I restart the app I am still over here and all of that
171:09 - stuff works properly now the next part comes in creating our app bar where in our app bar
171:16 - we will be able to log out and also be able to create new documents and then obviously
171:22 - we need to display those documents so let's quickly get into all of this stuff so now
171:29 - we will go to our home screen and in here create a very simple app bar this will be
171:35 - called app bar and here in the actions we are going to put two things well first of
171:41 - all is the icon button and the second one is also an icon button but the icon is going
171:47 - to differ which is the first one is add so that we can create a document here it will
171:52 - be a constant and another one is the logout button so that we can well log out and here
171:59 - let's try to refresh our application I'll restart it and here we have it now first of
172:05 - all we need to remove this debug banner so what we can do is set debug show check mode
172:11 - banner to false and after that we can come to the home screen and here change the color
172:17 - of app bar so the background color here can be k white color after that the elevation
172:24 - can be zero because right now there is a bit of elevation now we will just restart the
172:30 - app and here we have it our app shows up but the icon buttons are not showing up because
172:35 - they are of the white color as well so we need to change their color that color can
172:40 - be color k black color then we can copy this exact same thing and paste it down here great
172:48 - now if we reload our application here we have both of these things cool let's just make
172:55 - our logout button red color so we'll go to our colors dot dot file and here create another
173:02 - constant called k red color so we'll call this k red color make this colors dot red
173:10 - and your k red color then again restart our application and here we have it the red color
173:17 - looks good now let's work on the sign out option it's pretty simple now to make you
173:23 - understand how the sign out function is going to work let me ask you how what is the basis
173:28 - of the state persistence of our application token right so what if we just remove the
173:35 - token from the local storage if I remove the local storage token everything will just disappear
173:42 - right that's the main point so I just need to go to my auth repository here create a
173:49 - new function called void sign out and here this will be asynchronous obviously so here
173:57 - I'm just going to do local storage repository dot set token and I'm going to set it to an
174:03 - empty string I've just removed the token so here if I just show you the state persistence
174:08 - code we are checking if there is a token or not correct if the token is not null then
174:13 - all of this is happening but what if the token is there I mean not there sorry so here we
174:19 - are just throwing an error and on the main dot dart screen we're not handling the error
174:24 - or throwing some error message here we are just saying that if the data is not there
174:29 - then the user is not going to get any value so this user provider will be empty thus this
174:35 - will be empty and thus we will show you the logged out route and that's pretty much it
174:39 - if you just refresh the application and obviously bind this function so we will avoid call this
174:49 - sign out and here have widget ref passed in and here we are just going to call ref dot
175:05 - read auth repository provider dot sign out it's not sign in with Google sign out also
175:12 - we need to clear off our data from the provider because right now the provider has some data
175:17 - we don't want it to contain any data so here we will just say ref dot watch sorry ref dot
175:28 - read user provider dot notifier dot update and we'll again set it to null because here
175:35 - on the main dot art file we are just checking if there is no null then logged in route otherwise
175:41 - the logged out route that's why we are coming to the home screen and setting this to null
175:46 - easy and why are we doing this well this line will set the local storage token to empty
175:53 - so whenever we next restart the application our app won't log in but what if we are I
176:02 - mean we are already logged in whenever we click over here we are logged in it will just
176:07 - clear off the token but still there is some data in the user provider so we'll still be
176:11 - over here even though we are logged out when we restart only then will we go to the logged
176:17 - log in screen but before that we'll still stay on this screen that's why this line is
176:22 - important that will make it null and when it's made null here this part will also run
176:29 - again and thus we will get the logged out route if I just run this again I'll click
176:37 - over here let me just take this and pass it in over here so it will be something like
176:46 - this we passed in the rest successfully now restart the application and then click over
176:51 - here and you come to this sign in with Google now if I just restart the application you
176:56 - can see I'm signing in with Google but when I click over here it didn't even ask me for
177:03 - my email or anything the reason for that is I have not signed out with Google you can
177:08 - see here I signed in with Google and that's all I had to do but from here I even need
177:14 - to sign out right so for that what I'm going to do is await Google sign in dot sign out
177:24 - and after signing out it will ask us for the our email and stuff again so that's pretty
177:30 - cool now I'm not going to sign out and do stuff again but that was the basic point now
177:36 - the next part is whenever we click over here we need to create a new document and go to
177:41 - the new document so for that before anything else we need to create a document screen correct
177:48 - so we'll just create that we'll call this document underscore screen dot dot so we'll
177:55 - import material dot I know this is going to be a stateful consumer so I'm adding the stateful
178:02 - consumer if you're wondering how I got this well first of all let me type this name document
178:07 - screen if you're wondering how I got this consumer stateful snippet I just added an
178:14 - extension called flutter river port snippets you can download it it's pretty cool now to
178:23 - make sure these errors go away import flutter river port and you can see all the errors
178:28 - go away now we need to report it on a scaffold here now also there's another thing that we
178:34 - need to do other thing is we need to get an ID over here so every document this document
178:42 - screen is going to be used for every document that we go through for example there suppose
178:46 - there is a list of documents that are shown here which we created when we click on them
178:51 - we will go to this document screen with a unique ID and this document screen will be
178:56 - this document screen of course we can't keep on creating different screens for different
179:00 - documents correct that would be like really terrible I mean it won't even work correct
179:05 - because we don't know how many documents there are going to be and for every document we
179:09 - can't keep on creating screens dynamically correct so this document screen will manage
179:15 - this all so for that we need a string of ID now here we need to pass accept this through
179:24 - the constructor so that we can pass it from the screen that we are getting it from which
179:29 - can be this part whenever we click over here we generate a new document ID and go over
179:34 - there otherwise it can be from the list of documents that we will show later on over
179:39 - here in the center for now we can just display you know a basic ID so we'll have text ID
179:47 - and that's it I think widget dot ID is better and then just save it alright now let's get
179:54 - to the backend part of all of this stuff so whenever we click over here we need to create
180:00 - a new document so for that we'll have to do multiple more tasks now our authentication
180:05 - part is completed so we don't really care about the auth repository anymore we'll have
180:09 - to do all our stuff in the document repository but before that we'll have to create a route
180:14 - right and it won't be in the auth.js file this is only for authentication files so now
180:19 - we need to create document.js which is the document route and even the document model
180:26 - correct because now we don't want to store all of the data in user collection we want
180:31 - to store it in the document collection so let's quickly design a document so what is
180:37 - our document going to be like let's just think about it well first of all it should have
180:43 - the user's ID I mean ID of the user who created this document so that we know to whom it belongs
180:50 - and later on we can fetch on the screen the list of documents of the user then we need
180:58 - the time at which it was created I mean it's not really necessary but if you want you can
181:03 - keep this it will be really helpful if you want to expand this project later on but for
181:08 - me I'm not even going to use it because MongoDB will automatically arrange it in an order
181:15 - I like then we want the title of the document obviously initially it's going to be set as
181:23 - untitled document but later on the user can even update that and finally we need the contents
181:30 - of that document so what all is written I mean the bullet points the bold text the italicized
181:37 - text all of that stuff so first of all we'll start off by importing mongoose so let's require
181:44 - mongoose after that we need to create a document schema we all we know all of that stuff because
181:53 - we have already done that in the user.js file so we'll have document schema how do we create
181:58 - a mongoose schema well I already said that but mongoose.schema and obviously before we
182:09 - even forget it let's just export this document schema away now here we are going to have
182:17 - uid let me make it small and uid will have which properties well required should be true
182:26 - type will be string uid will always be a string correct after that we will have created at
182:35 - what is created at going to be well it's going to be a date right but in flutter whenever
182:40 - we will create a json model we will convert that date time object into a number which
182:47 - is going to be milliseconds since epoch so for that I'm going to make this first of all
182:52 - required and then give the type of number after that we will have title so here required
183:02 - will be true and type will be string but also there is going to be trim set to true why
183:13 - because title is there I mean title is in the input of the user whenever the user inputs
183:19 - the title I mean the user is doing it and the user input can be risky sometimes so we
183:27 - always need to make sure that we trim it and then we want content content will be of the
183:34 - type array and here you might notice that I'm not entering the required type as true
183:40 - why because content is not necessarily required for instance when we create our application
183:47 - or create a document sorry when we click over here the content is going to be empty so for
183:55 - that I can mention another property called default so what do I want in the starting
184:01 - so what if I don't provide any value to content it's not necessarily required I don't have
184:06 - to give it away whenever I create the document model but I want the default to be an empty
184:13 - list so if I don't give it so that means when I don't mention the content it will take in
184:20 - an empty array and it will do the executions further on based on this now I need to create
184:26 - a document which will be mongoose dot model not mongo mongoose dot model please get it
184:37 - now we want document which is the name of the collection and we will pass in our document
184:42 - schema now I will just take this document and export this not document schema if you
184:49 - notice this then you're well on your way to go ahead now in the document or just like
184:55 - always we are going to import express so we'll have constant express is equal to require
185:00 - express then we are going to have constant document which is equal to require dot dot
185:08 - slash models slash document I'm importing the model then I'm going to create my own
185:15 - document router so I'll have constant document router is equal to require not require sorry
185:25 - express dot router correct now I can go ahead now so I'll have document router dot post
185:35 - and here I need to mention the URL first so I'll have doc slash create not URL path then
185:42 - the auth middleware let me see if I can import it I can't seem to import this so I think
185:50 - I'll have to import it like this so I'll have auth is equal to require dot dot slash middleware
185:56 - slash auth after that we can have asynchronous request response and then we're going to have
186:08 - a semicolon and I think I wasn't able to import because I was missing this I was keeping
186:14 - this parenthesis in between when I remove that I will be able to import great so now
186:21 - after this obviously the try and the catch block right away we are just going to mention
186:26 - the catch block so I'll just copy this paste it in here and now in the try we want to create
186:34 - the document so what is the document going to be well let document is equal to new document
186:41 - we are going to create the object of the new document and then store it to database very
186:46 - simple stuff we did this for the user as well so if you want you can pause and go ahead
186:51 - and try to remind yourself how to do that alright if you weren't able to do it no problem
186:58 - it's still the start so we can just follow along so we'll have created at from the request
187:04 - dot body why are we having that because created at is time based now since it's time based
187:11 - there can be some delay from the server from the client side from the client side when
187:19 - the data comes and we post it to the server there can be some delay due to which the created
187:25 - at function I mean the created at variable will have different time zones we don't want
187:29 - that delay so right away we are just taking from the client side and sending it to the
187:34 - server side we don't want two different values in the client and the server side that's why
187:40 - now here first of all we want to pass in the UID which is going to be request dot user
187:46 - you can see if it was UID then we could have done it this way but since it's request dot
187:51 - user which contains the ID of the user because we add the auth middle where here only authenticated
187:56 - person will be able to accept our application access our application now in the title well
188:03 - what should the first title be it should be untitled document right whenever we create
188:10 - an document we want it to be untitled document and then we want created at after that we
188:19 - are just going to do document is equal to document dot save and we want to do await
188:25 - because it's asynchronous process promise and then we can just do res dot json document
188:31 - easy enough and document will automatically generate the ID for us and all of that stuff
188:36 - which will be really helpful for us later on but here we have it now we just need to
188:41 - export this document router and go to our index dot js file where here I'm going to
188:50 - use I'll use it after auth router so I'll have app dot use document router the matter
188:56 - doesn't really matter but auth router if it's first I feel better now I can go to
189:04 - my repository and here create document repository dot dot file so here first of all I'll have
189:13 - to create my class called document repository then I'm going to have final client underscore
189:23 - client then I'm going to create a constructor out of this so let's quickly create that and
189:30 - here I can't seem to use this anymore so I'm just going to have client and then client
189:39 - is equal to client great now what I can do is create a document so which will be future
189:50 - error model now we will just return error model just literally everywhere except where
189:56 - we don't want to handle the errors or anything I'll do that in a few functions but I'll
190:01 - let you know you'll have to do it if you want your application to be better anyways so here
190:07 - I'm going to have asynchronous try and catch block because while sending the HTTP request
190:16 - there can be some errors and here I'm going to copy most of the things from auth repository
190:22 - but again I would recommend you to not copy and write it on your own it would be better
190:27 - for you but here I'm just going to literally copy all the boilerplate code I've written
190:33 - all of that so I would recommend you to write it too but anyways we don't need all of this
190:43 - stuff let's remove the bracket from the bottom as well now let's save this much so what do
190:49 - we want to do well we want to share a post request we want to import this host variable
190:54 - as well but now here we want slash doc slash create then we want the headers and now we'll
191:04 - always need the token so we'll always have to accept this from the parameter we can't
191:09 - do this over here because I'm not making the ref calls in my repository classes but here
191:16 - I also need to pass in a body correct so the body is going to be let's just get it okay
191:24 - so the body is going to be created at and now I'm just going to send in date time dot
191:30 - now dot milliseconds since epoch also we need to json encode this because we are sending
191:38 - the body we can't just send a map right we can't send an object we want to encode it
191:43 - so we'll have json encode and here also I'm going to encode this now after I get my response
191:52 - I'll check if it's case 200 if it's case 200 then I don't want to do any of this stuff
191:58 - I want my data to be very simply document model and I will have to create that document
192:06 - model as well so here I'm going to quickly create my document model you can see how helpful
192:11 - models are even in dot even in mongoose I hope you're getting the hang of them so here
192:17 - I'm going to have class document model what all stuff are we going to have we have already
192:22 - decided that in the document model in our mongoose file a user id created at title and
192:30 - content let me just have this as well so let's quickly type all of that out final string
192:38 - title final string uid final list content and I'm not giving this list any type you
192:48 - might notice I'm not doing list of string I'm not doing list of int we don't know what
192:53 - the type is because it can be literally anything it can not be just string you know it can
192:59 - be anything that's how the document that you're going to create will work because there are
193:05 - going to be bullet points there are going to be tick marks there is going to be well
193:11 - bolding italicizing changing font size changing font family all of that will be very different
193:16 - so it's just going to be list which is dynamic can have any value also we are going to have
193:24 - date time created at and finally the thing that we have not mentioned here so let's remove
193:30 - this now it's useless now so we'll just have final string id now we can take this bulb
193:39 - icon generate a constructor we can take this bulb icon generate json serialization but
193:47 - here in the from map function always make sure that this id is map underscore id don't
193:54 - change this uid now because this uid will be the uid because in the document we have
193:59 - created this uid property which is the user id but the id property is the id of the document
194:07 - uid is the user id of the document that we are storing so make sure to change this now
194:13 - we can save this and in the document repository we'll have the data as document model dot
194:20 - from json res dot body and here we don't have to do that json encode and decode thing
194:26 - because from json will do that but we had to do it earlier because we had two things
194:30 - returning earlier which if you go here i can again show it to you the user and the token
194:36 - but here we are just sending off the document great so now here let's remove all of this
194:47 - let's break it out and i think this is pretty much it this is our function to create a new
194:53 - document so i can go to my screens folder in the home screen and here i will create
195:02 - a function called void create document so what is this going to be well first of all
195:08 - let's just make it asynchronous because we are going to call the create document function
195:14 - and then we are going to first of all get the token because we want to pass in the token
195:19 - we'll have ref so let's get the ref ref dot read and then we are going to have auth repository
195:29 - provider dot i don't think we need auth repository we need user provider dot token and this user
195:41 - can be null but now it cannot be null because we are in the home screen we are on the home
195:47 - screen only only when the token is not null so we want to not get this null check operator
195:56 - error now we are going to get navigator which will be route master dot of context we are
196:05 - not using build context anymore and we are using i mean sorry we are not using navigator
196:11 - dot of context we are using route master dot of context we also need a snack bar so we
196:17 - will have navigator dot of context then we are going to get the error model which is
196:27 - going to be await ref dot read now we are going to read auth repository provider and
196:35 - call get i don't know why i keep calling auth repository provider it's over and done we
196:42 - need to create the provider for document repository so we'll have final document repository provider
196:51 - which is equal to provider ref and then we can return from this document repository instance
197:00 - and then client we can pass it in easy now we can go to the home screen and here we can
197:08 - pass in document repository provider instead now we can finally call create document and
197:14 - pass in our token just calling the simple function not a very weird task now after that
197:24 - we are going to check if error model dot data is not equal to null so if the error model
197:32 - dot data is not null then we are going to use navigator dot push and push it to the
197:39 - document screen so we'll have slash document slash dollar error model dot data dot id why
197:56 - can we use the id because we know it's going to be an instance of the document model class
198:00 - whenever we use data dot id correct now we need elsewhere we are going to have snackbar
198:06 - dot show ok we don't need navigator of we need scaffold messenger of i'm not sure what
198:18 - i'm doing so here we'll have scaffold messenger then we can do snackbar dot show snackbar
198:26 - and then pass in snackbar the content here is going to be a text saying well whatever
198:35 - error is there correct so we'll just have error model dot error and now it cannot be
198:40 - null because we have already made the checks for it great now we just need to link this
198:49 - to our button here so we'll have like this create document pass in the build context
198:57 - pass in the widget ref and there we are but now if we do that i think it will create the
199:02 - document but it will tell us that the route was not found if i do this ok we don't get
199:09 - anything let's see if we get any error nothing so let's go to our document model sorry in
199:19 - our document repository we'll go down here and in the default we are going to well have
199:24 - the error handling part done so that we know what the error is or you can just even print
199:29 - it out but never mind since you're here we don't need a break after default but if you
199:34 - put in no problem here in the data we are going to pass in null but the error is going
199:41 - to be whatever data we got from here so we're just going to pass interest dot body now ok
199:49 - i think we didn't even restart our application that's why it sent us the error but anyways
199:55 - let's start it if we do this you can see page document and this unique id you can see it
200:01 - wasn't found so that means it's working we got the unique id passed in and if we go to
200:08 - our mongo db you can see that the document was already present there so now why is this
200:16 - route problem coming in well pretty simple error the reason for that is you have not
200:23 - registered in the logged in route make sure that you pass it in the logged in route so
200:28 - here what we are going to do is slash document slash id that's what you need to pass in slash
200:35 - document that's what it is slash document and then our id so this is the id you need
200:42 - to pass in this colon this is called a slug so make sure that you pass it in and then
200:50 - we get a route so we can use constant material page and then in the child we will pass in
200:57 - the document screen and in the document screen we want to pass in the id which will be route
201:02 - dot path parameters and there we are going to access the id and this cannot be a constant
201:13 - so let's just remove that and this can be of the type string nullable so let's make
201:20 - sure that it's not nullable or if there is what we can do is just an empty string simple
201:26 - enough so here we have it material page child document screen so whatever we have passed
201:32 - in here we need to pass in over here and this is path parameters that means you can have
201:37 - multiple ids like this for instance if you want slash dollar something else you can do
201:45 - that as well but here the route dot parameter will become like this it will become something
201:53 - else over here so you have to pass in the same thing after this colon anyway so now
201:59 - after having this done let's restart our application and now if i well go back we don't want to
202:08 - go on the document screen i click on create and you can see i'm coming on this screen
202:14 - where our document id and we're not seeing anything else because here i've passed in
202:19 - something else over here and that's causing the error now if i remove this out and refresh
202:24 - my application close the file also here i'll pass in localhost 3000 i'll click on create
202:31 - and here you can see i'm going to the other screen and the ids are similar that means
202:36 - that this stuff is working the navbar is also gone cool stuff but as you could see in the
202:42 - router dot file even if we added another part another part and click on saved then reload
202:49 - our file and do this we go here but we are still on the same screen even though we are
202:56 - here it doesn't go to the other screen so that's a really cool feature i like it then
203:03 - we can restart our application and whenever we go you can see it automatically restarted
203:09 - and we came on this screen cool now i can again go to the localhost 3000 which is our
203:16 - starting port now here we need to display all the available documents i mean the documents
203:24 - that i have created not anyone else i want the documents created by me so that i can
203:29 - open them anytime i want so let's get into it so now to display them what i'm going to
203:34 - do is go to the document or js route and here create my route very first route called document
203:42 - router dot get my very first get route in the document file so here we want to pass
203:49 - in the url so i'm just going to pass in doc slash me authentication asynchronous request
203:56 - response and the simple route creation after that i want the try and catch block so here
204:07 - i'm going to have that very quickly also i'm going to have this pasted over here now in
204:15 - the try block i want to get all the documents created by me how am i going to get that just
204:20 - think about it did you get it if you didn't then simple enough you just need to do await
204:28 - document dot find and now we want to find all the documents created by me if my user
204:37 - id which is uid in the document i've saved it like that correct the uid is saved as request
204:45 - dot user's id i mean the uid over here that's saved in the document collection is the same
204:51 - as the request dot user that means the user id then we want to get them so we will find
204:57 - them find will return to us a list of document even if it is one document it will return
205:03 - as a list of one document and then we are just going to rest dot json and documents
205:12 - good enough now our route is created now we just need to go to our document repository
205:19 - and here create a very simple thing we will just have something like this but instead
205:26 - of creating a document we are going to get the documents so we are going to have get
205:30 - document so here we are going to send a response so it's going to be post is going to be get
205:38 - actually and we don't need to pass in a body the header is going to be exhaust token and
205:43 - here the docs slash me will come in not docs slash create i want to get docs of mine now
205:51 - switch rest dot status code case 200 and then the error will be this but before that we
205:57 - need to return the document the rest dot body will return to us the list of all the document
206:05 - we don't want to return a list we want to well return one document from the model and
206:11 - then put it in a list here if you do that it will give you an error because rest dot
206:16 - body will be list and this accepts a string not a list correct so here first of all we
206:22 - will have to create a very simple model called document models list let's call this documents
206:29 - initially set to an empty list then we will do for and i is equal to zero i is less than
206:38 - json decode response dot body dot length i plus plus so what we have done we have decoded
206:49 - the json so that we can get the length after we do decode the json of res dot body we can
206:55 - get access to the link so what is the length of the list correct we'll get that and we
207:01 - loop through it and every time we go through one object in the list we want to add that
207:10 - so we'll have documents dot add and we'll add document model dot from json exactly this
207:18 - line right let's just pass in but instead of res dot body we are going to pass in that
207:25 - whole line that we had created earlier as well it's going to be json decode response
207:31 - dot body at i but this will be enclosed by json encode pass it in and then add it in
207:46 - also here we need to pass in document dot model dot from json and then we'll pass in
207:53 - all of this stuff because we want it to be a type of document model correct now we can
208:00 - just pass in documents over here easy enough after saving it i think everything is pretty
208:08 - much done so for this how are you going to do it well there are two approaches you can
208:12 - take there is a provider known as future provider and river port which will allow you to make
208:20 - your boilerplate list but you can look into that in some of my other videos but in this
208:28 - video i'm just going to go ahead with a simple future builder i'm going to go in the document
208:35 - screen instead uh sorry in the home screen and instead of having a centered text saying
208:41 - this i'm going to have my big future builder ready this future builder will have builder
208:48 - it's going to be context and snapshot and a future which will be ref dot watch and we'll
208:56 - have document repository provider dot get documents then we want to provide it with
209:04 - a token so what is the token going to be well it's going to be ref dot watch user provider
209:11 - which can be null dot token a very big line indeed i know but we are just watching the
209:18 - documentary repository provider now we have instance of document repository then we are
209:23 - calling get documents because we have that class basically and then we can use ref dot
209:30 - watch to get the token because it needs a token now here in the builder what we are
209:36 - going to have is very simple if where we will check if snapshot dot connection state is
209:44 - equal to connection state dot waiting then what do we do if the connection state is waiting
209:49 - i want it to have a loader showing up so i'm going to create my custom loader here which
209:56 - will be called in the common tab in the widgets folder called loader dot dot this loader will
210:07 - be importing material dot creating a stateless widget we'll call this loader and this will
210:12 - return a centered child of circular progress indicator this is also going to be a constant
210:23 - so we'll save this much then we can take this loader return a constant loader after that
210:37 - we are going to return a list view builder which will have context and an index and we'll
210:52 - save this much then we also need an item count and the item count is going to be snapshot
210:57 - dot data dot docs dot link and this data here cannot be accessed because we have not given
211:04 - future builder a type we need to give future builder a type which will be error model import
211:11 - that and this can be null and yeah we are getting this error because it's not docs but
211:17 - it's data so when we pass in data now the error fixes now you don't even need this so
211:22 - we can remove this line and it still works so now in our item builder first of all i'm
211:29 - getting my document model because well this is a list view builder i have the item builder
211:34 - and we are getting list of documents correct now i want to get a particular document so
211:40 - for that i'm going to do document is equal to snapshot dot data dot data dot docs i'm
211:51 - not sure why i'm using docs continuously but it's dot data at index now i have access to
211:58 - the document so what i can do is return a card of child center and the text will be
212:12 - center i mean the text is going to be document dot title because whenever we see a card we want
212:20 - the title to be there correct and we need a style which will be constant text trial which will be
212:28 - font size 17 i'm going to make it a bit bigger so that you know it looks cool also here we are
212:35 - returning so we want a semicolon now i'll save this much and see what i'm getting so i'll just
212:40 - refresh my application and here you can see untitled document these many are showing up
212:46 - which is actually correct because i created many documents too because i thought it was a bug in
212:51 - my application but with you if you created clicked on this once then you might have just one
212:58 - but anyways there are a lot of things to fix first of all the height of the card the height
213:03 - of the card right now is just what the text size is i want it to be a bit bigger than the text size
213:08 - correct so for that i'm going to wrap my card widget with a widget known as size box so that
213:17 - i can give it a height of 50 now if i save this much and again reload my application now it looks
213:25 - much bigger and much better now i want to reduce the size of this if i pass in the width over here
213:31 - it won't work for example if i give it a width of 200 and save it and then restart the app you can
213:37 - see nothing really works so i'm going to remove this but give list view builder a sized box widget
213:44 - so we'll have wrap with widget call it size box and then give it a width of 600 now i'm going to
213:53 - save it reload the application and here we have it our doc our card is now 600 width i want this
214:03 - to shift in the center right so i'm just going to wrap this size box with a centered widget
214:09 - and save it now again restart the app and here it is in the center pretty cool i also want some
214:15 - margin from the top right even from here even from here so what am i going to do well i'm going to
214:20 - replace this sized box with a container so that i can give it a margin when i don't have to give
214:26 - it a margin i'm going to use a size box but otherwise i will just use a container now i'll
214:32 - have constant edge inserts dot only and from the top i want 10 of margin if i restart now
214:42 - you can see it looks much better it's not stuck to our navigation bar it is cooler now whenever i
214:50 - click on this i want to go to the document screen and well our magic will start the document socket
214:56 - connection how are we going to achieve that very simple enough we are just going to wrap the center
215:04 - widget with a widget called as inkwell why am i using inkwell because i want the on tap property
215:13 - and why am i not using gesture detector instead let me show you if i restart the app you can see
215:18 - whenever i click on this right now it's giving me this because i don't have to wrap it with the
215:25 - centered in the list view builder let me remove this widget i have to wrap it inside of my card
215:32 - because i want to when i click on this one card i want this hover effect to come in right now
215:39 - it's for the entire screen if i restart nothing shows up because i want to pass in and on tap
215:44 - as well only then will the hover and the splash effect come in when i restart you can see all of
215:51 - this cool cool things happening it is really cool now whenever i click on this i want to navigate
215:57 - to the document screen so for that we are just going to use route master correct so i'm going
216:03 - to create another function here called void navigate to document we are going to have a build context
216:14 - uh then the document id as well because we don't know what and where to move right we want the
216:22 - document id and we will only have access when we know which card was clicked so we are going to
216:27 - have route master dot of context dot push then we will use slash document slash dollar
216:38 - document id now why did i use push instead of replace when i push i get access to this back
216:46 - button but when i use replace i don't get access to this back button that means i cannot go back
216:51 - i don't it will replace the current screen i want to push it so that you know it's kind of a stack
216:56 - if i go back i can go back but with the replace i can't go back there's no looking back now we
217:02 - can go back to our inkwell widget and you'll have navigate to document pass in the build context
217:09 - pass in the document dot id and done now i'll restart my application and whenever i click here
217:17 - i go to this screen if i click over here i go to this one
217:23 - i go to this one you can see all of these ids are different from each other so this is the screen
217:34 - of our application now the next part is over here creating our nav bar and here we'll be able to
217:40 - change our title and we will be able to display you know the google docs icon all that styling
217:47 - stuff after that we will get into our text editor which is a cool thing because it's so easy let's
217:56 - dive into it really quick all right so first of all i'm going to close my terminal and close all
218:01 - the save files and then i'm going to go to the document screen and now let's think how our design
218:07 - should look like this is how the design should look like well what do we have here well first of
218:12 - all we have an app bar which has a different color than this because this is pure white and by default
218:18 - flutter is not giving us the pure white background color then we need our editing tools but before
218:24 - that you can see this line part here that part is not because of the elevation or anything
218:30 - that line is basically because of the color so we need to add that color below the app bar as well
218:36 - but first let's start with the app bar we want a google docs icon we have already installed that
218:41 - in a flutter project here you can see when we were installing the google logo and then we want this
218:48 - text input field this is a text input field not anything else because you can edit this title and
218:54 - then finally at the end we just want the share icon should be very easy to do for us so let's
218:59 - get started with it so here in the scaffold i'm going to return an app bar so let's have an app
219:05 - bar and in the app bar first of all we are going to change the background color so we'll pass in
219:12 - the background color as k white color and then we want the elevation to be set to zero now let's see
219:19 - how it's looking i'll go i'll have to sign in and actually i can't sign in because i logged in from
219:25 - another port see you when i go to the 3000 port all right so our browser is there with us now
219:32 - let's click on sign in with google here i have to enter my email i'll see after i log in here i've
219:37 - clicked on a document and here you can see i'm getting the id and even the app bar that's looking
219:42 - good now let's try to make some changes here as well i'm going to close the terminal now in the
219:49 - actions because i want to add your the share button so i'm going to click on actions and then add
219:57 - the button elevated button dot icon again we need the icon button because if you go over here we
220:03 - have the lock icon and then the share button so let's quickly create that onpress will be empty
220:08 - for now then we are going to have icon of icons dot lock lock not local also i'm going to set a
220:17 - color to it so let's pass in the color of k black color after that save it this is going to be
220:24 - constant then here we need a constant text and then it's going to be called share after we share
220:32 - it and let's try to restart our app here we have the share button now we need to decrease its size
220:40 - and stuff and even before doing that let's just change this black color to the normal color that
220:48 - looks much better yep now we just need to reduce the lock icon size so we can have size as 16 and
220:57 - then save it restart and this looks much better now we just need to make sure that we reduce its
221:03 - size to reduce its size you can to take two approaches well give it a size directly by
221:09 - passing in the style otherwise you can just do control shift r wrap it with a widget called
221:16 - padding and give it a padding of eight then restart the app and if you see this is looking
221:23 - better but i want it much better so i'm just going to convert it to 10 and restart again
221:29 - as you can see this looks much better to me now i want this to be of a different blue color not
221:35 - the original blue color i have to make some changes so i can go to my colors dot file
221:40 - and here i'm going to create k blue color which is equal to color dot from rgbo
221:50 - which means red green blue opacity so it's going to be 26 115 232 1 and if you're wondering where
221:59 - this color is coming from well it's just extracted from the google docs share button itself
222:06 - so here in the button we're going to pass in style as elevated button dot style from and then we can
222:13 - pass in the color of background so we'll have background color as k blue color see now if i
222:20 - restart the app and go over here this looks like a more stylish button now we need to add the title
222:27 - so what is the title going to be these two things the text input and the docs button or docs icon
222:33 - sorry so let's quickly add them below our actions we are going to have a title and in the title
222:43 - we are going to have a row in that row children and the first child is the icon itself so it's
222:50 - going to be image dot asset and then we will pass provide the asset which is asset slash images
222:57 - slash docs logo dot png now let's save this much restart and here we have it now it's too big so
223:06 - we'll decrease its height so you'll have height as 40 and then save it again restart the app
223:14 - here we have the docs i can fitting good enough after having this i can leave a space
223:21 - so i'll have constant size box with of let's say 10 after which i can add another one which is text
223:30 - field now since we are in a row text field works this way that it will try to get everything in the
223:38 - row but we don't give everything over here because this is a docs icon so what are we going to do
223:44 - about it well we have to wrap it with expanded but if we wrap it with expanded this text field
223:50 - will go till here i don't want that i want to give it a specific width so for exactly that we are
223:55 - going to add a size box which will have a width and the width here is going to be 100 let's say
224:02 - then in the text field we are going to pass in a decoration which will be constant input decoration
224:09 - and that will say that border should be input border dot none then there should be content padding
224:19 - and the content padding will be edge insets dot only from the left side 10
224:29 - then save it restart the app and we don't really see our text field and we're not getting any error
224:38 - for it as well to give it some value what we have to do is create a controller so we'll have text
224:44 - field controller it's called text editing controller my bad then we're going to call this
224:52 - title controller which will be equal to text editing controller and we are going to pass in
224:59 - an initial value now what is the initial value going to be we can pass it through text argument
225:05 - this will be just untitled document you later on we are going to use this so that we can give it
225:17 - the initial text of something else which is taken from the
225:22 - database because even if it's untitled document in the database we are storing it as untitled
225:26 - document right but for now let's just keep this we are also going to call the dispose method here
225:33 - we are going to have title controller dot dispose now we can take this title controller go down
225:39 - and pass to it the controller which is title controller now we can restart the app and we have
225:46 - our nice text field but 100 is too small of it so i'm going to pass in 180 i'll restart and this
225:54 - looks much better i can change the document and everything but still it doesn't look very good
226:00 - because we don't know we have come over here or this even exists right i mean if i click on it
226:05 - it automatically starts to serve like a cursor it puts on it i want it to have some border
226:12 - so for that i'm going to add focus border so whenever the user clicks on this they will see
226:19 - a border now what will the border be outline input border and then we are going to have border side
226:25 - let me have border side of border side and the color is going to be k blue color
226:35 - let me put some trailing commas and then restart the app now if i click over here you can see this
226:41 - works well when i focus it it looks good now below this part here i want to add a border you can see
226:53 - you can see that there is a border here so that there is a clear distinction to make that clear
226:58 - distinction how are we going to do it well app bar doesn't support anything like that except it
227:03 - has an argument called bottom with bottom you can pass in a container but the problem is bottom
227:12 - accepts a type of preferred size widget we can add to it an app bar and it wouldn't throw us an
227:19 - error but i don't want an app bar i want a simple border so for that i'm going to create my own
227:25 - preferred size and in that i want to pass in a child and a preferred size now what is my
227:30 - preferred size going to be well it's just constant size dot from height one so whatever width is
227:39 - there keep all of it and i just want to increase the height by how much one and there is a child
227:48 - now the child is going to be a simple border so we can have container decoration box decoration
227:57 - and we can pass in a border which will be border dot all now here what color are we
228:03 - going to choose well it's going to be gray color correct so again let's go to our colors here we
228:08 - are going to have variable k gray color if you're wondering why i don't have constant here you'll
228:16 - understand right now when i use colors dot gray dot shade 800 this is not a constant shade 800
228:24 - is not a constant it is variable if i put constant over here you can see it throws an error
228:28 - so i'm going to pass in variable k gray color now why do i want shade 800 because when i use k
228:35 - gray uh just the gray color it's too prominent i want it to be a less prominent one so i'm going
228:41 - to use the lesser shade now i can take this pass it in here and what is the color going to be well
228:49 - k gray color also here i want the width to be minimized so i'm just going to pass in 0.1
228:56 - now we are getting this error to resolve this error we just need to push the preferred size
229:01 - at the top and not at the ear because widget child should always be at the last that's what
229:09 - the error prompt says to us so let's just follow that right now if i restart it everything looks
229:15 - good but now still there's not too much padding from the top over here so in the app bar uh
229:23 - wherever we had our app bar let's go at the top and in the title we are going to wrap our row with
229:31 - padding after we wrap the row with padding here we just need to pass in dot symmetric and vertical
229:39 - we can do eight let's say nine and then we can restart our app now this looks much more better
229:48 - there is some padding from the top and it looks much more organized all right having this done
229:53 - now we need to set up our controller or you can save our text editor the main part of our
229:59 - application how are we going to do that well obviously we can't use the text field over here
230:04 - that's just very useless so for that editor we are going to use something known as a quill editor
230:13 - and what is a quill editor well you can find it here flutter quill 6.0.0 published just three
230:20 - days ago so this there might be some code that might be a bit different from uh what i've written
230:25 - earlier because i wasn't using 6.0.0 but let's hope not anyways
230:31 - this flutter quill uh is like built on quill quill is something used in some javascript frameworks
230:41 - i've built it i've built a text editor with the quill js itself uh and even with react quill when
230:49 - i was using react it's a very powerful tool and i can completely rely on it if you want to check
230:54 - out you can check this out but we are going to use this flutter quill it's going to provide
230:59 - us with nice widgets and controllers which will make our lives much more easier now to set it up
231:04 - well let's just go to the documentation you can see they've literally provided the entire code we
231:10 - are going to use so let's just copy it in the body we are going to paste it now we need to import
231:19 - this so let's import quill we need to create this controller and also remove this container
231:26 - let's see we don't have that option to remove the container so let's quickly
231:31 - remove it by ourselves now we need to create the controller for our quill so how are we going to
231:35 - do that you can check out the documentation again it's written over there but what we are going to
231:40 - do is while importing quill first of all we are going to use it as quill okay because this has
231:48 - some package which will interfere with our material package and we don't want that correct
231:52 - now we can just use quill like this now let's create this controller so we'll have quill dot
232:00 - quill controller and let's call this underscore controller let me have quill here passed in
232:11 - which will be quill controller dot basic
232:16 - let me pass this in easy
232:22 - also make this final for now later on we are definitely going to change we are going to make
232:26 - all of these controllers late when we use the socket iopart but for now let's just keep it the
232:32 - way it is now we can take this controller and we have it now let's try to restart our app it will
232:38 - or it should throw us an error it does not have any error so let's just keep it as it is
232:44 - or it should throw us an error it doesn't it shows us the toolbar correctly which is great
232:51 - but now you can see we are not getting any text editor as such why well it's because of the
232:58 - sizing issues what i'm going to do is over here remove this comment first and instead of expanded
233:07 - and like this what i'm going to do is wrap this widget with another widget known as a sized box
233:16 - size box will will give it give it a fixed width which will be 750 then we can restart our
233:24 - application now you can see we have certain width in our application it might not be visible but
233:29 - the cursor is very visible now to make this more prominent we will have to wrap it with the
233:35 - card right so that we can give it a bit of elevation and change its color so the quill part
233:42 - we are just going to go ahead and wrap it with the widget card now let's restart
233:50 - you can see some changes it's much more elevated and visible but now we are going to give it a
233:55 - color color is going to be k white color that's probably the default color as well then we will
234:01 - increase its elevation to 5 then restart the application and it's much much more easier to
234:08 - read i mean much much more prominent but now it's stuck at the top and it's not even centered so to
234:14 - make it centered first of all you can wrap this column with centered widget then restart
234:19 - it's at the center now then we need to leave some space from the top so we'll have constant
234:26 - so we'll have constant size box height 10 and let's leave some space between these controllers as
234:34 - well so now it looks much better now we just need to wrap it with a padding widget because you can
234:42 - see our cursor is right over here we want it somewhere over here so for that we have to wrap
234:47 - our quill editor with padding widget not our card widget because if we wrap card this will get
234:52 - padding from all of these sides we don't want that we want only from this quill editor so i'm
234:58 - going to wrap it with a widget called padding and the padding is going to be 30 from all the sides
235:10 - now this looks much better you can type anything you can bold it italicize it whatever good stuff
235:16 - you saw in the intro as well you can also pass in snippets of code if i've not already told it to
235:22 - you anyways so if i remove all of this let's remove it we have our text editor set up now the next
235:31 - part is whenever we change the stuff over here we want it to change in our database as well and
235:37 - it should be reflected as well so let's get into it so to update the title what we are going to do
235:42 - is close all the saved documents all the files and then we are going to go to document.js route
235:48 - and here create a new route well it's going to be very similar it's going to be the same post
235:53 - request so let's copy this line again if you should type it but here i'm just going to do
236:01 - dots slash doc slash title then here i'm going to take in the id and the title from request.body
236:10 - because every document will have their own id i want to go to that document find that id and
236:18 - then update their title correct i mean i will find the document by their id and then update
236:23 - their title so here what i'm going to do is constant or document is equal to await document
236:36 - dot find by id and update this is another method basically we find by id and then update whatever
236:44 - field we want to update so here i'm just going to pass in first of all the id and then i'm going
236:50 - to pass in the title and that's pretty much it now we have updated the document i just need to do
236:57 - res.json document because i don't even have to do this it already updates it and does all the
237:04 - stuff behind the scenes we just need to return this document and we're done easy enough now we
237:09 - can go to our document repository and here create another function to update the document
237:16 - so i'm just going to copy this entire function let's go down and here paste it in so this is
237:23 - going to be called update document here we are going to get the token along with that we also
237:32 - need the id and we also need the title now since there are three parameters what i like to do is
237:37 - make them named arguments so that it's easier for us i'll just pass in required everywhere
237:44 - and then save it also let's put a comma here so that the formatting does this
237:49 - work all right so we have the error model there now we will have a response we'll post but here
237:55 - it will be host doc title then we'll pass in our token because here we have passed in the auth
238:02 - middleware then we want our body but in the body this time we are going to have we'll remove this
238:10 - line and then we'll have id we'll pass in the id then we are going to have a title and the title
238:19 - will be title all of them from the parameters here i don't think we even need the update document
238:26 - part we'll just do it void because we know there are very less chances of this not working so i'm
238:32 - just going to remove all of this i'm not going to return anything but if you want you can just go
238:37 - ahead and do the error handling part it's much better and much easier and it's good to do always
238:43 - but i prefer not to do it this time and it's not update document it's actually update title
238:51 - let's remove this line we'll just do this part but obviously again i'll tell you error handling
238:57 - you should do it i'm not doing it i just don't want to waste much more time great now i will go
239:04 - ahead in the document screen here i'll create a function to call that method void update title
239:11 - we will need widget ref so that we can call the document repository so i'll have ref dot read
239:20 - document repository provider dot create or update title then we need to pass in the token which is
239:28 - ref dot read let's find the user provider
239:38 - and then we'll just pass in the token and this can be non-nullable because we are logged in
239:44 - then we want the document id don't confuse it with the user id we want the document id
239:49 - which we are going to get from widget dot id whatever we are getting from the constructor
239:54 - correct because that's the document id as well and then we need the updated title so that means
239:59 - what do we need to update it to well we are going to get that whenever the user submits this field
240:06 - correct so what are we going to have well we will just get the value from your string title
240:12 - now whenever the user clicks on enter that means that the user does this and clicks on enter then
240:19 - we want the text field to get updated so for that we are going to have an on submitted but
240:24 - on submitted option this will give us a value so whenever the on submitted part is triggered
240:31 - what value will we receive well the entire string there so here what i'm going to do is call this
240:36 - document to do is call this function called update title pass in the widget ref and the title will
240:44 - be value great now let's restart the application and here i'm going to store it as titled document
240:56 - i'm going to click on enter and nothing really happens if we restart our application we see
241:02 - nothing so there is no way of knowing for the user as well that is it saved so exactly for
241:08 - that we also need to retrieve the content of the document so whatever is passed to it we want to
241:14 - update it as well whenever we refresh the document because here i've passed in the title it's stored
241:21 - in the database as well i'm very sure about that right now but i want to display it whenever we
241:29 - refresh or come to this document so how we going to do that we're going to go to the document.js
241:34 - part i'm going to copy this get route and then i'm just going to get this document what is this
241:42 - document well whatever document we have we want to get the data of this document so we are just
241:48 - going to fetch the data by its id and then just return it out so here how do we get the document
241:56 - id there's no way because this is a get route get routes don't have body so how will i access the
242:01 - id so for that there is the slug part now this might be very familiar because in the router dot
242:08 - dot part we have done the same thing as i said the routing part is very similar in node.js react
242:15 - router dom everything so here we have id now we can access this id that's whatever is passed to
242:22 - it also let's remove this we don't need me so we have slash docs and then we need to pass in the
242:29 - id now to get access to this id what we can do is just use request dot parents dot id
242:41 - with this we have access to the id of whatever is passed through it so we are passing the document
242:47 - id in the url of the route itself because we don't have access to request dot body over here
242:54 - now what am i going to do well find by id i'm just going to fetch it so this is going to be
243:01 - a constant document and then just return this document easy enough now again i'll go to my
243:09 - document repository and i will create the get function for our content as well so let's copy
243:17 - this get route because it's going to be very similar let's paste it here then we are going
243:26 - to call this get document by id then we want the token and also the id of the document
243:35 - document then we are going to do get but here we are not going to have docs slash me we are
243:41 - going to have doc at id because that's the route right document and this will make sure that we
243:50 - have access to request dot params dot id this is basically request dot parameter that this is like
243:56 - what parameter is passed to it i call it slug same thing
244:00 - then we will pass in the header the token because we have the auth middleware then the case 200
244:07 - but here we don't have a list of document we just have a single document so for that what are we
244:13 - going to do well simple enough it's much simpler than what we have done before
244:16 - we'll just remove all the for loops and stuff also remove all of this and here we are just
244:24 - going to have response dot body and we'll pass it in as the data as well you can see this looks
244:31 - much much better document model dot from json dress dot body because this will return to us
244:36 - a single body we have used find by id not find this will return to us a list but this will return
244:43 - just a single document because ids are unique in mongo db we have the default one as well
244:49 - but here i don't want to throw this error what i want to say instead is that this document doesn't
244:56 - exist please try again later that's the only possible conclusion for us because if the user
245:02 - goes to this route let's say 44 then we want to tell them that yeah this route doesn't even
245:08 - exist in our mongo db or it's not accessible to you but accessible to someone else correct
245:13 - or it's not accessible to you but accessible to someone else correct but that's not the
245:19 - feature we are looking forward to we are just saying that this document does not exist in the
245:23 - entire app so we are just going to throw an error when we throw an error it goes to the catch block
245:30 - and here we are anyways having the error model created so here i'm just throwing this document
245:36 - does not exist that's it and here let's add another one please create a new one this sounds
245:46 - much much better right now we can go to the document screen and here we will call this
245:52 - function in the init state because whenever our application reloads we want it to show
245:57 - that's when init state also loads up right so here i'm going to create the function called
246:02 - fetch document data now i'm going to copy this function go down here i have fetch document data
246:10 - and here it's going to be asynchronous now the first thing we need to do is get the error model
246:17 - and start displaying it so here i'm going to have error model error model is equal to await
246:25 - ref and i need access to ref so i have to and we already have that because we have a consumer state
246:31 - consumer state and now i just realized why do we use error model here when we also have to use it
246:37 - later on when using quill controller because the content of our application will also change
246:44 - correct whenever we type something it will start auto saving it and it will store to the database
246:49 - even then the content will also change so we need it there as well so instead of creating it like
246:55 - this i'm going to create it as a variable in this class so i'm just going to have error model like
247:01 - this but it will initially be null correct so that we can distinguish that the data has come
247:07 - or not otherwise we'll get late initialization error now we can do await ref dot read document
247:15 - repository provider dot get document by id then we need to pass in the token ref dot read
247:26 - what is our token well first of all the user provider which can't be null then the token
247:34 - and then the document id which is widget dot id simple we know all of this now we have access to
247:41 - error model and we're not creating a new one so make sure you remove that because if you put this
247:46 - it will create a new variable of local called error model we don't want that we want to set it
247:52 - to this global variable now here we are going to check if error model dot data is not equal to null
248:04 - so i'm making sure error model is not null because here error model will get some value
248:09 - so error model will definitely not be nullier but error model dot data can be null so if it's not
248:16 - null then what do we do if there is no null that means that means we have successfully got the
248:22 - document model that means the correct document and the data so what we can do is just use
248:28 - title controller dot text is equal to error model dot data dot title this might be null
248:39 - might not be accessible here but you can just use as document model and wrap it with a parenthesis
248:47 - so that it automatically identifies and then later on you can use any of the function
248:52 - correct so i'm just going to do that and i'm also going to call the set state function
248:57 - if i call the set state function it will rebuild the widget
249:00 - and after rebuilding it it will show us the current proper title so if i restart my application
249:08 - let's see over here i'm still getting title document and i just realized why this is not
249:14 - working i have to remove this actually let's just go to the local os 3000 and now you can see title
249:22 - document showing up which is the updated title if i click over here it's showing title document as
249:27 - well if i refresh it again it's showing title document that means this part is now working
249:33 - we've successfully got the data now the next part and obviously before going to the next part let's
249:41 - try it out again if i restart my browser title document correct and if i go to the local os 3000
249:50 - we have seen that already it updates the title that's pretty good anyway so this is the document
249:55 - and we have done all of that now the next part is whenever we write over here we do the collaborative
250:00 - editing part and implement the autosave functionality for that we need to jump right into sockets
250:07 - and we'll start off by understanding what really sockets are how are we going to use it in our
250:12 - application and well just writing the code for it it's pretty simple let's go so let's start off by
250:19 - understanding how sockets work i have my own diagram here so let's start off with the
250:24 - diagram here so i have my client server here again a basic back-to-back client and server model
250:32 - so whenever the client sends some information it's usually only then the server can send
250:38 - information that's how http request works that's how we've been making our rest apis work right we
250:45 - we tell them please send us data server sends us the data but in sockets what happens is client
250:51 - says yeah i want a connection then the server keeps on giving the connection and then whenever
250:59 - we again tell the client that yeah some data has changed server keeps sending that if we
251:04 - set an interval server will keep doing that and you can do it as many types as you want and it's
251:10 - very quick as well sockets are designed for this purpose itself it's it's kind of like a wrapper
251:16 - around around http not really but you can consider it that way it has it is http but with more
251:24 - features which is real time so whenever we get some data it's going to be real time and it will
251:29 - keep on sending the data to us every bit of information so if the client suppose says yeah
251:36 - i want to start listening to it so client said i want to listen the server will send out the data
251:43 - whenever some data changes we can make sure that server sends it back to them correct
251:52 - but how and why are we using sockets for like multiple users for example we have client over
251:57 - here suppose this is another client and they're all attached to the same document so we have three
252:04 - clients who are attached to the same document for example this is my ios phone this is my web and
252:09 - this is my android phone they're all connected to the same document so first of all we need to make
252:17 - sure that they are connected to the same document only then will the sockets work and they are also
252:23 - obviously having the same server which is our custom server but since they've joined the same
252:30 - document id we have to make sure that socket joins their id they all have their own sockets
252:36 - correct so we need to make sure the sockets join their id and after which if this client the web
252:43 - client tells yeah there is some change please send this to all the user the server will send it here
252:50 - here and here if it was http and if web send the server request server would send it to only this
253:00 - part only back to the client but with sockets we can make sure that every client gets that information
253:06 - if there is a change we can broadcast it to all three of them right but what if i want to send it
253:16 - to only two of them or only to the ones that are there in the room or only to the ones that are
253:21 - not there in the room well you obviously wouldn't want that but what if you want to do that well
253:25 - there are many options on that and we're going to look into it socket provides all of that to us
253:31 - but i hope the simple explanation was clear if there are three clients if we use http
253:36 - and if one client sends some data to the server it will only be sent back to that user it won't be
253:45 - sent to everyone in that room correct but with socket we can send it to everyone now how are
253:52 - we going to connect to socket well for that we are going to have socket io client this is from the
253:59 - client and from the server side both you can see that we are sending from the client and we are
254:03 - getting from the server as well so we are going to use socket client on both the sides on with
254:09 - flutter we are going to use this and with node.js we've already installed it socket io 2.3.0 this
254:16 - is very important 2.3.0 as i've already mentioned it to you you can see here port of awesome now
254:22 - javascript node.js library socket io client version 2.01 to version 3.03 in dart we need
254:30 - to use them as i've used 2.3.0 but there's another problem with this when i use socket io client
254:38 - 2.0.0 i couldn't connect to my server there was some issue from uh i don't know from where and
254:45 - i'm not even sure why i got i couldn't get it working but when i lowered down the version
254:50 - it started working so i'm going to use that version you can try with 2.0.0 if it works for
254:56 - you then great if it doesn't then simply go to your pubspec.yml file add this dependency
255:04 - but here it will be the version 1.0.2 make sure flutterpub get is run i'm going to close this
255:13 - dart compiler clear it off and now i'm going to create an instance of this socket io client
255:20 - now i can't just go on and create that instance in the document screen well first of all it's
255:26 - about keeping the business logic away and second part is that what if i want to use it in some
255:32 - other screen as well for example this document screen has some collaborative editing but i want
255:37 - to use that in other screen as and when i expand the app i won't i won't be able to create instances
255:45 - of the socket io client again and again because socket io client doesn't for some reason uh
255:51 - accept that so we want to make sure that one single instance of socket io client revolves
255:57 - around our entire app so to do that we are going to go over here in a library folder and create
256:03 - clients we'll have our first client called socket client dot dart and how are we going to make sure
256:10 - that single instance remains throughout the class for that we are going to use singleton design
256:17 - pattern so here we are going to have a class of socket client then we are going to have socket
256:26 - and we are going to import it not from dart io so let's import it again but from socket io client
256:33 - let's remove dot io and i'm going to use it as io instead so that there is no confusion so i'm
256:41 - going to have io dot socket which can be nullable socket then we are going to have a static instance
256:50 - of socket client that we can pass from our function then here we are going to create an
256:59 - uh uh socket socket client uh private constructor how are we going to do that socket client dot
257:06 - internal will make sure our constructor here is private and cannot be initialized now i'm going
257:15 - to give this socket the value so it's going to be socket is equal to io dot io that's how you
257:22 - connect to a uri and then you need to pass in the url so for us it's very simple it's just going to
257:28 - be host correct now we can have string dynamic and a map that's what it requires also here let's
257:38 - import our host so this is how the connection is going to be done we need to configure the socket
257:45 - socket and then we just need to call socket dot connect and it will connect also this has to be
257:53 - non-nullable now here i need to pass in some important functions for example transports
258:00 - and this will be web socket we need the transportation through the web socket
258:04 - and then we need auto connect set to false
258:10 - we don't want it to auto connect right we've always wanted us to connect it ourselves
258:15 - then this is the private constructor whenever you want it it will be called and it will connect
258:22 - and then you also need to provide the instance correct so how are we going to do that well we
258:28 - are just going to create a function for it static socket client get instance then we are going to
258:35 - check if the private variable instance is null then we want socket client dot internal we can
258:41 - call this in the class itself but we cannot call outside of this because socket client internal
258:48 - has become a private constructor like private variable so this in tanks basically means that
258:54 - if there is no instance and the instance is null then we want to create a socket client internal
259:01 - and that will make sure we connect otherwise we will return that same instance
259:08 - then we can return that instance from here also this will be private
259:15 - and it cannot be null so this is our socket client package now after having all of this done
259:24 - we need to go to over here and have socket repository dot dot all of our socket repository
259:30 - calls or socket calls are going to be here where we are going to send to the server just like
259:35 - we are our document repository and local storage repository now before going to the socket repository
259:42 - let's connect to our server as well we have connected to the client now we need to make sure
259:47 - we connect to the server so that we know yeah the connection between the client and the server is
259:52 - successful because we have passed in the correct port as well if we had not passed it there would
259:57 - be some error now let's go to the index.js file and here we need to require constant
260:06 - first of all HTTP because we want to create our socket server then we need to
260:14 - create a server which will be variable server equal to
260:19 - equal to HTTP dot create server and how are we going to create the server exactly for that
260:28 - we are going to go down and do app we need to create the server with the app with express
260:36 - so here we are going to pass in HTTP dot create server app and now we need to do the socket
260:42 - connection so what we are going to do is variable io is equal to require as you might have guessed
260:50 - socket dot io and this should make sure that io has some value but here i'm going to even call
261:00 - the function where we need to pass in the server which is our server you can see what we've done
261:07 - is required socket io and usually what we do is socket and then we store it in another variable
261:15 - called io which is equal to socket like this correct but now i've done a shorthand syntax for
261:24 - this and i've done it this way great now i can come over here below the mongoose call i'm going
261:32 - to do it io let me have io correctly dot on connection so whenever there the connection
261:41 - is made this is how we listen to the socket io calls io dot on connection so if the connection
261:47 - is made with our client side or with any other client then it will say yeah the connection has
261:53 - been made and here it will give access to the socket object using which we can send data to
261:59 - us client side as well so if the connection is made we'll get access to socket and with this
262:05 - socket we can send data to our client side now i can just type console dot log connected just
262:15 - to make sure that we have connected or not plus i also want to show you socket dot id this is the
262:23 - socket id that means every client that connects to it will have their own unique socket id and
262:30 - this can be accessed using this socket dot id even on the client side we have the socket client
262:38 - right even this has their own client id if you want to access that i'll show it to you
262:45 - but here first of all we are going to have socket repository which we are going to create using
262:54 - final and we are going to have socket client which is having a private variable which is going to be
263:00 - equal to socket client and you can see i cannot create a constructor on it you can see that
263:08 - so what i'm going to do is dot instance dot socket and it cannot be null because socket here will
263:18 - never be null because we are if there is no value we are not sending any value but if there is a
263:23 - value and this value can never be null because here we are just passing in a null check operator
263:29 - basically if there is no value it will run the connect command and it will connect it and if
263:36 - it will connect it and if there is a value then it will directly return that if you want to make
263:44 - sure that this socket client is used somewhere else you can just create a getter of this
263:48 - so we have socket client and we'll pass in the socket client also here the return data type
263:55 - will be socket now let's save this much and see what we're getting so i'm just going to make this
264:04 - socket repository call and use this socket client i'm going to call this socket repository so that
264:13 - i get to know if it's successful or not so i'm just going to do socket repository socket repository
264:19 - is equal to socket repository and i think this is pretty much it it should work because whenever
264:25 - i call this class this is going to get executed and the connection if it is made then it should
264:31 - print it out also here you can see we have some error over here io is not defined so we need to
264:39 - go up here and you can see we are naming it socket not io so let's name it io and save it now the
264:46 - connection is successful and we need to restart our app because why not then we can sign in with
264:56 - google now i'm logged in so i'll go to the title document and i'm going to the node server nothing
265:07 - really gets printed out so what i'm going to do is create a test call and show you a demo of how
265:14 - the test call will be made so basically uh whenever we uh let's not create a test call actually what
265:22 - i'm going to do is as i said it to you socket client has to join a server so that you know our
265:29 - socket and our whole server knows our whole application knows that this socket has joined
265:36 - this is in this room so that we can send some data to a particular room itself so that some
265:42 - clients listening to it will get so for example if there is this server as well but it's not
265:47 - connected to the same document as these three clients so it's connected to the server but by
265:55 - a different document id now we don't want the server to send the same data over here as well
266:01 - so how are we going to achieve that well by making sockets join a particular room so that a server
266:07 - can send data to a particular room so for that i'm going to create a function called join room
266:13 - then we are going to get the document id and then we are just going to use socket client dot
266:20 - emit join and then we need to pass in the document id because we want to join a particular
266:26 - document id that is the room id as well now i can go to the server and here instead of this call
266:33 - i can say socket dot on join so as i mentioned io dot on will listen socket client dot emit
266:43 - then we need to pass in what is the key like we are emitting join but we will have multiple
266:52 - calls in our application each call will have a different string so that would make it easier
266:59 - for us to make our application accessible right if everyone has the same name then how do we
267:05 - distinguish between the different requests sent so we have socket client dot emit and we are sending
267:10 - the document id so that we can join the room with that id so whenever there is a join we are not
267:16 - going to get we are not going to get the socket back here because socket instance is already there
267:20 - with us we're going to get the document id whatever document that we passed in over here
267:26 - we're going to get the same data but this doesn't necessarily have to be document id
267:31 - this can be data as well you can call this anything this is basically a variable and then
267:36 - we are creating the callback function so whenever we get this join what do we do well we are just
267:44 - going to use socket dot join method and join to this particular document id simple enough now i
267:52 - can go to my document screen and in here i am going to join the particular room so i'm going
268:01 - to have socket repository dot socket client actually i'm just going to have socket repository
268:12 - dot join room and we need to pass in widget dot id i'm going to do it at the top before even
268:18 - fetching the document data before because later on in our document data function we're going to
268:23 - make some uh i think socket calls so let's have it right at the top so whenever our web page
268:29 - reloads let's just join the room now if i go to this particular screen let's refresh there is a
268:38 - title document but we don't know anything because we've not logged it out so let's say console dot
268:43 - log join now i'll go to my socket repository again also restart my app and again go to the node
268:54 - terminal nothing really shows up and the reason it's not working is because if we go down here
269:03 - we still have app dot listen but our server is now this http dot create server so we need to
269:09 - start listening with this we'll replace the app with server and now you can see connected at
269:14 - port 3000 joined connection successful as well so everything now works we have done the socket
269:21 - joining part as well so this is connected now the next part is whenever we type something we need
269:29 - to send it to all the the users in this room how are we going to achieve that let's understand with
269:35 - the diagram again i'm going to remove all of this and let's start fresh so we are going to have our
269:41 - three clients suppose we will have one two and three clients then we have our server then suppose
269:53 - this one and let's just assume all of these documents are connected to the same document
269:58 - id and they are in the same room all right so now what will happen this client will send the data
270:06 - to the server that yeah i've changed something so whenever there is some change we are going to
270:13 - send this to the server this server is going to return it back let me change the color
270:20 - this will change this color i didn't know it will change the entire color but anyways
270:24 - this will change the this will send it back to all three of them unless unless we tell it not
270:33 - to send to this part because they've already made the change in their document we want the change to
270:38 - be made in this one and this one only we'll send from this one and they'll send it to everyone
270:43 - except the sender because this has already made the document change for example if i type over
270:48 - here this has already made the change in the document correct but the other two that are
270:54 - connected to this document haven't made the change yet so we will send the data to both of them but
271:01 - not this one otherwise this will also start typing over here and whenever they receive the data we'll
271:07 - make sure that quill we have the quill controller all right we have this quill controller for a
271:13 - reason this quill controller will take that data and make sure that it updates the content over
271:22 - here as well that's going to be very simple for us but there is a bit of logic there as well
271:27 - so i'll get to it very soon so how are we going to write the code for this well in the socket
271:33 - repository we are going to create a function we are going to have void typing so whenever the
271:39 - user types something we're going to get typing and this will be map string dynamic data it's
271:48 - going to be of the type map so whatever data we get it's going to be of the type map and we are
271:53 - going to send it over because we are going to convert whatever data we get in the format of
271:59 - map because it's going to be two things delta which is something like a format so you have
272:05 - text format you have uh let's say jason format there is a delta format as well with the delta
272:12 - format we can have multiple things right for example bullet points and all of those stuff
272:21 - bolding italicizing with delta format we can make sure that we can pass all of that data to the
272:27 - document or to the socket or to our mongo db as well so what am i going to do well socket client
272:34 - dot emit simple enough and then we are going to emit typing this one was joined this one is typing
272:41 - so you know what to put in the server right socket dot on typing then we are going to send
272:46 - off the data this data cannot be anything other than just one variable this can be a map
272:52 - or a string or an end but this has to be one variable that you're sending across since i
272:57 - have two variables to pass i'm converting it into a map format now i'll go to my index dot
273:04 - js file i'll have socket dot on typing so whenever i get the typing request we will get two things
273:13 - well it's just going to be data for now and whenever we get that data we are going to do
273:21 - socket dot broadcast this is something new now what is this broadcast broadcast basically means
273:28 - that the data will which we are sending to from the client to the server will be sent to everyone
273:35 - except the sender itself exactly what we want if this sender this is the sender then we want
273:41 - the data to go to everyone except the sender so that's what broadcast will do then we can have
273:47 - dot two which means we will send it to a particular room only if we don't add two it will send it to
273:54 - everyone be it like a third client as well which is not connected to the same client
274:00 - as these three but is some other document itself even this but this server will tell okay you didn't
274:08 - tell me to send it to this room so i'm sending the data to this one as well but wouldn't that
274:13 - be confusing right because this document doesn't even care about it so yeah here we are going to
274:19 - have socket dot broadcast dot two data dot room we can access objects using data dot room and this
274:29 - is what we are going to pass in we want to pass in the room id so that we can broadcast to a
274:34 - particular room and we are going to send in the data a data which is the delta so here we are
274:39 - going to have dot emit and we are going to have changes so these were the changes take back your
274:46 - data after sending it across again i'll do it on the socket repository part what am i going to do
274:54 - well i'm going to create a change listener we have emitted here but for the first time we are sending
275:00 - some data from the server to the client side you can see these arrows we are sending from the data
275:05 - from the server to the client side so this client side has to listen to it as well so we are going
275:11 - to have void change listener then we are going to well have a function here we are going to have
275:20 - socket client dot on changes what is the name here changes so we are going to have changes
275:28 - and then we will pass in the data but what data do we do need to pass in well
275:33 - we don't need to pass in anything basically we will send in a function
275:38 - which will return the map whatever data we get here it's going to return that same data so that
275:45 - it can be accessed in our ui file and make the changes over there because we need to compose
275:50 - right so whatever data we get here we need to add that to the quill document we can't access
275:55 - the quill document from our socket repository so what we're going to do is accept the function
276:00 - function of map string dynamic call that function and we are going to send that function across
276:14 - which is data so basically whenever we get any changes we are going to get this data
276:20 - we are going to call this function which has data map in it and we're going to pass that out
276:27 - so if we call this change listener in our in its state in the document screen let's do that
276:33 - here we are going to have socket repository dot change listener and you can see we have something
276:41 - known as p0 which is basically data so whenever we add change listener we need we will pass in
276:48 - some data we will get some data and with this data what function do we need to run well we
276:54 - basically need to tell controller right now the controller has some value so right now what i'm
276:59 - going to do is make this nullable also remove the final call here so basically this controller
277:08 - i'm going to give it some value after fetching the document correct see here i'm just going to
277:13 - have if the data is not null then we will have controller equal to quill dot quill controller
277:22 - controller
277:27 - document okay so we need to pass in the document now what is the document going to be
277:33 - well it's just going to be error model dot data dot content because it is a document model dot
277:43 - content dot is empty so if it's empty if the content is empty what do we want because this
277:49 - document cannot accept and like it cannot accept empty document created from the delta
278:01 - so here we will just pass in an empty document but if the data is not empty then we need to
278:09 - create this document from that delta and then how are we going to create the delta well we
278:18 - are going to create the delta from document dot from the json file not document sorry we are going
278:26 - to create the delta from json and we are going to pass in the json which is error model dot data
278:34 - dot content i hope that was clear enough
278:37 - and you can see even selection is needed so selection is going to be constant
278:49 - text selection dot collapsed and we will pass in the offset as zero so here we are basically
278:55 - checking if the data is not null then the title controller text should be this and then we will
279:00 - set in the value of quill controller to be this so if the content is not empty right now it is empty
279:06 - so we will pass in a document which is empty but if it is not empty then we will pass in
279:14 - document from delta and we are going to create delta from the json file and json and we are
279:19 - going to pass in the content but this content we are sure that it's json of delta is because
279:26 - we are going to store it that way again now in the change listener that we wanted to work on
279:32 - we are just going to use controller dot compose
279:38 - so whenever we get some data we want to compose it right we want to make sure that controller
279:44 - can update the document and now after this we don't need to call set state because compose
279:49 - within itself calls notify listeners with notify listeners it will notify this quill controller
279:57 - also here you need to pass in that it's not null but before that we need to make a connect
280:02 - correction that if the quill controller quill let's say controller is not equal to null then
280:13 - but if it is null then we want to return a scaffold with the body as the loader
280:22 - as the loader also here it will be a constant scaffold
280:31 - we can go at the bottom pass in non-nullable now because here if it is null then we are going
280:38 - to return a loader now we can go back to the top here and compose it we know that it will refresh
280:45 - the document itself not the entire widget so we are saved there as well now here in the delta it
280:52 - will be delta dot from and this will be quill dot delta dot from json and then we will pass in the
281:03 - data which is going to be data at delta that's how we will send in the information when we create
281:12 - that function you will get to know but basically this is how our data is going to look like as i
281:17 - said it's going to have two properties delta and room so delta is over here
281:25 - now the text selection is going to be controller dot selection
281:33 - and if it is null then we want to use our own value constant text selection dot collapse offset
281:42 - zero and the source here is going to be change source dot remote this is going to be very
281:48 - important in our application also here we'll pass in quill this is going to be very essential
281:54 - for our application i'll let you know why but basically we've composed this now we have quill
282:00 - dot change source dot remote this can be local as well but this will be remote i'll tell you why when
282:06 - we create now the typing function so now how do we listen to the changes in our document so
282:13 - whenever i type how do we how do i listen to it well what you can do is whenever we fetch the
282:18 - document after that we can just have controller dot document dot changes dot listen and you can
282:30 - see as easy as it gets whenever there is a change in our document we are listening to it and we have
282:39 - access to the event and this event is a tuple which gives us delta delta and a change source
282:45 - delta the first delta is going to be the delta telling us the entire new controller document
282:55 - so this is the entire content of the document then we have second which is the changes that are made
283:05 - from the previous part basically this is the entire document if i type like this and then i
283:15 - again type this you can see this is the entire content of the document so it will every time
283:21 - so it will every time there is a change delta the first delta in this tuple will give us this entire
283:27 - part but the second delta will give us only this s which is the change that is made and third is the
283:38 - chain source so what is the source that had the chain is it local if it is local that means that
283:45 - we have typed it over here correct so we have type but if it's remote when is it going to be remote
283:53 - whenever we have composed this so it's going to be composition from this change listener so whenever
284:01 - we send data from here to our server which will send it over here we can compose this data
284:08 - and send in remote that means that the document will change again right so here we are composing
284:16 - it and when we compose it the document will again change because this content over here will change
284:21 - that means this function will be triggered again because document.changes.listen i mean it won't
284:27 - happen on this document but what if we have our second browser as well we are listening there
284:33 - we are listening there what we did was suppose let me just bring it up i'm going to bring it
284:39 - up like this suppose i have localhost 3000 here as well i'll bring both of them together here
284:50 - so suppose both of them are linked to the same file now if i'd make the change over here let's say
284:56 - a then it will change over here as well correct that's how our logic works right now but when
285:04 - it changes over here this document will get notified that yeah this has changed this will
285:10 - get triggered then this will again send it to a server server will again send it to all the
285:15 - clients that are connected which means this one and this one will also get the a then again the
285:21 - loop will happen this will send it across over here this will send it across over here like this
285:27 - and by just pressing one key of a we have gotten an infinite loop now to escape that we have this
285:37 - chain source so if the chain source is remote we have passed in over here if this is remote
285:43 - that means we have got it from this part that means we just have to return from this document
285:49 - we don't have to make any changes we don't have to send anything to the server again
285:53 - but if it is local then we want to send it to the server so let's add that logic here well first
285:59 - of all we need to check if the data dot item let me get this event so event dot item three
286:09 - is equal to quill dot change source dot local if it is local then only we have to send it to the
286:19 - server so we'll have map string dynamic map is equal to this then we can have a delta property
286:30 - and in this delta property we can pass in event dot item two now why are we passing item two as
286:37 - i said item two will get you the changed part we don't always want to get the whole uh you can
286:44 - say whole text over here because what if our paragraph gets like suppose a thousand characters
286:52 - long we don't always want to refresh thousand characters when we just type one character right
286:56 - if i if suppose this is thousand characters i type this a over here q over here it will
287:04 - rebuild this entire part why do i do that instead with compose what we can do if you just go up
287:11 - here you can see compose will make sure that it will take all the item tools basically all the
287:19 - deltas that are changed it will compose them with the existing deltas then we are going to pass in
287:28 - the room and the room is going to be widget dot id and then we are going to second it across
287:34 - so for that we have already created our function socket repository dot typing and we'll pass in our
287:41 - map as the data after sending this i can go to my dart i can restart now you can see i'm logged in
287:48 - so if i go to this document but before going to this document what i'm going to do is create a
287:53 - new window altogether where i can test this app again but since i'm already logged in from the
287:58 - same device it will think that i'm logged in so i'm just going to go in the just guest mode i can't
288:05 - go in the incognito mode because uh the cookies will be disabled there i don't want to disable
288:11 - them and i can't so i'll have localhost 3000 again i'll have to log in over here and make
288:17 - sure to log in with the same account that you had registered earlier on the google cloud platform
288:23 - and i'm logged in you can see there are no documents over here because i'm using it for
288:27 - the first time now what i'm going to do is create a new document i'm going to make sure this doc
288:34 - this user also gets to the same document now i can type a you can see the change is there now if
288:41 - you want to see it real time i can come over here let me minimize this out minimize this also
288:53 - and here if i type let's say a i'm getting all of it if i type in here if i bold it out italicize
289:04 - it underline it convert it to a code everything seems to be working so our part here is done
289:11 - but what if i refresh my application you can see it's empty right now but if i refresh this also
289:19 - it's going to be empty that just means we haven't started the auto save feature now to start the
289:28 - auto save feature what we are going to do is create a function for it here in our socket
289:35 - repository and then finally call it so we are just going to have void auto save then here we
289:43 - are going to get the delta so that we can tell what we need to do otherwise what we can do is
289:50 - the same map string dynamic technique so we can have map string dynamic data and we can do socket
289:58 - client dot emit save and pass in this data all right now we need to handle this in the index.js
290:11 - file so what are we going to do here we are going to have socket dot on save so whenever there is
290:18 - a save call what are we going to do well we are going to get the access to the data and here we
290:23 - are going to call the function which we are going to create outside of this so we are going to have
290:28 - constant save data is easy equal to async we're going to pass in the data to this function as
290:34 - well now why am i creating this extra function because well first of all i don't want to put
290:39 - asynchronous over here another thing it just looks cleaner here i'm going to have well let
290:47 - document is equal to await and we are going to call document dot find by id to save the data
290:58 - obviously what i'm going to do well i'm just going to find the id i'm going to find the document so
291:05 - i'll have delta data dot delta that is going to be the name of our content and actually here it's
291:15 - going to be document id because i want to find the document by its id so this will be data dot
291:20 - document id then we will have document dot content is equal to data dot delta then we will do document
291:32 - is equal to await document dot save now if you're wondering if you could have done find by id and
291:39 - update yes you could have done but i wanted to show you the other way you can use find by id and
291:45 - update and it should work just fine anyway we have data dot doc id data dot delta and there is going
291:53 - to be only two elements just like this one you know this had data dot this typing one has data
292:01 - dot content this is has data dot delta if you want you can name this data dot content as well
292:06 - and it should just work fine but make sure to make the appropriate changes later on now we are just
292:12 - going to call the save data function and we are going to pass in the data why have i not created
292:17 - http request for it or the or the restful api for it well that's because what if you want to show
292:25 - like saving or saved feature here we don't have that in our application but what if you want to
292:30 - show that right so you can just put io dot 2 call over here basically io dot 2 call will send it to
292:37 - everyone including the user itself that yeah we have made some change this has been saved socket
292:44 - dot broadcast 2 will send it to everyone except the sender io dot 2 will send it to everyone
292:49 - including the sender and if you wanted to send it to only the sender then it will be socket dot 2
292:57 - or just socket it should just work but i'm not going to send anything that simple now i'm going
293:05 - to go to the socket repository i don't even have an on auto save listener call i'll just go to the
293:11 - document screen now when do i want to auto save and how will the auto save feature work well i'm
293:17 - just going to check my document that in every two seconds i'm going to send an auto save request
293:26 - auto save request that yeah it's been two seconds now let's just update the document two seconds
293:30 - update the document if you want you can make sure to update the document in as much time as you want
293:36 - five seconds ten seconds one second 500 milliseconds whatever you wish to it just
293:43 - depends on how many calls you want to make to the server i think two is fine it will take user to
293:48 - take two seconds to just go from here and then click on back so i think it's a pretty good thing
293:55 - so here i'm just going to well leave this part i'm going to come here i'm not going to put it
294:02 - in any function because if i put it in fetch document data then it will only run when it's
294:08 - fetching otherwise in this listen function which is basically kind of a stream if i put it over
294:13 - here you can see this is a stream subscription if i put it over here then whenever the user types
294:20 - only then will the auto save feature work we don't want that we want it to work even if the user
294:25 - doesn't type anything so we will have socket repository dot
294:36 - auto save and then we want to pass in our map what is our map going to be well it's going to
294:43 - consist of three things and you can see set cannot be typed so let's pass in string comma
294:54 - dynamic just to tell it that this is not a set this is a map all right so what is the first thing
295:03 - delta what is the delta going to be how am i going to retrieve the delta now i don't want delta of
295:09 - the changes that are made i want the delta of the entire screen to get that i can make use of the
295:14 - controller given by quill dot document dot two delta then i want the room id so let's see what
295:24 - i saved the room id as room again so i can just pass in room widget dot id and that's pretty much
295:33 - it it should start saving but you can see this will run only once only when the nh state function
295:39 - is run which is in the start i don't want to save it in the start obviously so when do how do i make
295:45 - it run every two seconds so i'm going to wrap it with timer dot periodic this timer is given by
295:54 - flutter itself so we have timer dot periodic then we need to pass in a duration how many times
296:00 - i mean in how many seconds should it run so it will be constant duration pass in the seconds as
296:08 - two and then we are going to have timer
296:14 - and this is going to be a function so i'm just going to copy this paste it down here and save
296:20 - it now you can see every two seconds this timer will run if you want you can make this one second
296:25 - if you want you can make this millisecond of 500 every five milliseconds it will run but i don't
296:31 - want that i want two seconds so let's start now obviously we need to restart so i'm going to
296:36 - restart from both the sides localhost 3000 over here also localhost 3000 and you can see there
296:50 - is some error in our server data dot delta cannot set properties of null content so let's go over
296:58 - here and see what's happening the problem is it couldn't find the proper id this is document dot
297:04 - find by id data dot doc id but we don't have anything data dot doc id we have data dot room
297:09 - so we are going to do data dot room now if we restart you can see it should work so let me
297:15 - restart my browser even this should restart all right so now i'm going to make changes in title
297:25 - document i'm going to share the link you know this button is not working so i'm going to make this
297:31 - work as well right now i'm going to send hi you can see h is now there i is also there so hey
297:39 - hey what's up and all of this stuff now i'm going to add the bullet points as well so
297:50 - and this will also contribute to the bullet points
297:55 - also bold one italicize one and change the color of one great now let's try to go back
298:05 - so when i click here i should go back so how can i make that feature work
298:11 - well we need to go to the document screen and whenever this button is clicked so
298:21 - this is the button
298:25 - we just need to wrap it with a widget known as gesture detectors we don't want
298:30 - we don't want ink well because i don't want the splash effect we'll have on tap and we'll
298:38 - just do route master dot route master dot of context dot replace the current screen with slash
298:50 - so that we go back to the slash part right and then we just need to restart when i restart this
298:56 - the content should all be the same but it's not restarting for us there is some bug with this i
299:06 - don't know what but whenever i try to do it with two browsers it always does this so i'm just going
299:12 - to close this i'm going to restart my browser i'm going to log in and see you again we should get
299:18 - our data saved and if it's not saved then we've made some mistake in our code all right so have
299:24 - my browsers ready two browsers i logged out of one so let me sign in again now i'll just come over
299:32 - here okay so now if i go to this title document you can see all of the data that we wrote is saved
299:39 - if i take this send it across it's still saved and if i click over here i go back to this slash
299:45 - now i just need to make this share work how is that going to work so whenever we click on this
299:50 - it should copy this to our clipboard so we have clipboard dot set data clipboard data and then we
299:59 - can pass in the dot then as well so what data do we need to pass in here well it's going to be text
300:09 - and what text do we want well hdb well basically all of this
300:13 - is this entire thing so let's just remove this hdb then we will have dollar widget dot id
300:27 - then we have dot then and after dot then we are just going to have scaffold messenger dot
300:34 - of context dot show snack bar then we are going to display the snack bar that yeah this has been
300:41 - copied link copied also put a constant there and then just well this is pretty much it let's try
300:54 - to restart if i you know click on the share you can see link copied if i paste it over here
301:03 - is the same link and i come back over here if suppose i go on a different untitled document
301:10 - and try to type there the same is not happening over here but i share the link away from here
301:16 - to here i mean of course it didn't get copied but over here if i go
301:25 - you can see we go back to the assa assa assa all that part great so our docs google docs is
301:33 - working all the displaying part is working and even it's responsive sometimes not using media
301:39 - query we can get you responsive websites as well so this was it for the tutorial thank you
301:45 - so much for watching see you in the next video you

Cleaned transcript:

Improve your Flutter skills by building a Google Docs clone. You'll also learn more about Node.js, Express, Sockets, MongoDB, and more. Rivan Ranawat is your teacher. Rivan has created a bunch of popular tutorials and he is an excellent teacher. In this tutorial, we are going to build Google Docs clone using Flutter and Node.js. This course is designed for beginners in Node.js and no prior knowledge of JavaScript is required. We will learn how to authenticate users with Google, keep the user logged in, create REST APIs to display and create new documents, build a powerful routing system to share link of our documents, and establish socket connection to allow users to collaborate with each other. They can type, color, bold, italicize, change size, and much more simultaneously. Prerequisite for this course is having a basic knowledge of Flutter. For state management, we will be using RiverPod. Before we get into this video, I'd like to invite you all to our Discord server. Link is mentioned in the description below. We will start off by creating a Flutter project. So we'll go to the Visual Studio Code and in the empty project here, we will click on CommandShiftP and then click on Flutter New Project option. Then we are going to generate a application. So we can click over here and then we need to assign the folder where we need to store this. So we can go to the desktop and here we will just create a new folder called Docs Clone Flutter. Then click on Create and then we can select this folder to create the project in. Now we also need to name this project. Again, we will just name this Docs Clone Flutter and then click on Enter. Here you can see Flutter Create is being run and here you can see our project is ready. We need to start running it. Now just to test our application, we can obviously run it. So I'm going to run it on web. I'll just click on Run and run it without debugging. Let's wait for it to know if we have successfully set up our application. So our application has started and here if you see it, our web version is running. Great. Now let's try to remove everything, all the boilerplate code. So I'm just going to grab all of it from here, remove it out, all the comments from here. And here I'm going to create a new folder called Screens. Here we will create our very first screen called the Login Screen. This Login Screen is going to be very simple. It's just going to consist of a single button in the center, which is the Google button. So let's import Material Dart, then create a stateless widget and call this Login Screen. Here we are going to return a scaffold and let's just return that so that we can see an empty screen and know this is working. We'll go to the main.dart file again and here import Login Screen. We also remove this comment and let's see if, and you can see a blank white screen showing up. Great. That's exactly what we wanted. Now what we want is in the center, a button showing up with a Google icon here and then a button and a text saying sign in with Google. So to do that, we will go to the Login Screen and in here, in the body, we'll pass in a center widget because we want it in the center. Then we will have a child and now we want an elevated button with an icon, as you've seen in the picture already. We're not going to use the normal elevated button. No, we want elevatedButton.icon because we need to pass in an icon. It's not necessarily an icon because icon here accepts a return data type of widget. We can pass in a widget. It doesn't necessarily have to be icon or icon data. So here in the onPressed, I can just pass in an empty function. We look into that a bit later. Here, now we want an icon, so to get the icon, you can go to this website. I'll mention the link in the description below. This is my GitHub repository where you can find all the source codes for what we are doing it today. So to get this, well, we need the DocsLogo.png as well and the gLogo, which is Google logo. We want both of them. So let's install them right away. Having installed both of them, here we will create an assets folder. This assets folder is going to contain all of our assets. If you want, you can change the font style. So you can bring in that here as well. Now in that assets, I'm going to have images and in those images, we're going to put in our two images, which is this. I'll just drag them in the images folder and here we have it. Cool. Now we will go to the Popspec.yaml file so that we register as an asset. The file so that we register the images that we have in our application. So let's just uncomment these three lines and your pass in assets slash images and then pass in DocsLogo.png. Similarly we are going to do it for gLogo as well. So we'll just pass in g over here and here you can see it says gLogo 2. So we can have gLogo 2 but you'll get 1 because I already have that image stored in my app, in my finder or the search explorer. Having this, we can stop our app and restart it because that we can't restart it right now but after fixing this error, we have to restart our application because you made changes in Popspec.yaml file. Now here in the icon, we have to pass in image.asset and pass in the asset name, which is well assets slash images slash gLogo.png. Then in the label, we are going to pass in a text. So we will have constant text saying sign in with Google. Then I'll just put trailing commas so that it formats the document well enough. Now let's try to run our application and see where we've got. And here you can see it's saying unable to load asset and the reason for that is here we need to pass in gLogo 2, not gLogo, so I'll just save this much and here you can see a big button showing up. Now the reason this button is so big is because this image size is pretty big. Now we need to reduce this image size. So what we can do is in the image.asset, just pass in the height as 20. After we do this much, you can see it's pretty small. Now after having the appropriate height for this image, we just we still need this icon to be bigger and it should be white in color and the text should be black in color. So let's make those changes pretty quickly. For the style, we'll just pass in elevated button dot style from and then we will have to pass minimum size. The minimum size is going to be constant size 150 comma 50. So this will represent the width and this will represent the height. Now you can see it's showing up good enough. Now we just need to change this to white. So we'll just pass in the background color and the background color is going to be colors.white. Now instead of writing all our colors like this, normally what we can do is in the lib folder, create a new file called colors dot dot and as in when we get a new color, for example colors dot white or colors dot blue, we can just save it in here. So how I'm going to save is constant k white color is equal to colors dot white. Also import the material package because we are using colors and then we can take this pass it in here and import the package. You can see it works well. Now the reason we need to do this is because suppose we want this docs clone to be changing the theme. For example, this needs to change the theme if the background color here changes to black because we just need to match this with the background color. So to change it, we can't obviously go around and change it every time from here. We if we have some constants over here, we can easily change their value. For example, if I wanted black from just one file, I can change the color and it changes. It's pretty cool, right? So we'll just save it like them. And if you want to add theme changing options, you can definitely do it using the state management tool you want. Great. Having that, here you can see we can't see our text. So let's just pass it in the style, which will be constant text style and constant is not required anymore because we are already in a constant text here, we need to pass in the color. Now for the color again, we just pass in K black color. If you're wondering why I'm prefixing with K, it's because it's a constant. It's never going to change, right? So I'm just going to pass in as K black. If you have any other better names, for example, if you want to name it according to your purpose, you can do that as well. So here in the K black color, I'm just passing it in here. We've already imported it. Now if we come here, this looks good. Now the next thing we need to look at is Google sign in. So for Google sign in, we're going to use a package called Google sign in. It's from Flutter itself, and we're going to use this. So now let's quickly install that. I'm going to use the Dart add dependency thing here and just pass in Google sign in. After Flutter pub get is done, we can just go to the pubspec dot yaml file just to see if it's there and it's there. Great. Now we can close this file, we can close this terminal as well. And then close all the save files. Now we need to do the some installation process for Google sign in. Since you're not using Firebase for this, we have to do some extra stuff. For example, we need to register our application to Google cloud platform. So now we'll just click over here and go there. Here you come to this screen, just click over here and then click on new project. Here we will be asked to mention a project name. I'll just name it Doc's clone tutorial because I already have the Google Doc's clone project name created. I'll click on create. And after this is done, I'll see you. After this process is done, you can just click on select project. Now after coming in here, you need to go to the credentials. Then you click on create credentials and then we need to create OAuth client ID. Just click over here. And you can see to create an OAuth client ID, we must first configure the consent screen. So we need to configure the consent screen after this. Now just see what you're doing. I'm just going to keep it external and then click on create. Then we need to mention app name and stuff. So let's quickly type all of that. So we'll have Doc's clone tutorial. In the email, I'm just going to keep in this. Then I'm going to skip all of this. This is not necessary. And again, here I need to mention my email address and then click on save and continue. After that, we need to manage the scope. Let's click on scope. And what all information do we need? Well, first we need the email. That's very important. Then we need the profile info as well. And that's pretty much all we need. So we can just click on update after scrolling down. And here you can see we have all of it. Now click on save and continue. Then if you want, you can add the test users because you're doing external. So basically until you have the app registered with Google, you can use these test users and you can only have a hundred of them. But after that, you can submit your app for review to Google Docs or Google Cloud and all of that will be done. Now I'll just click on add users and add my emails. I added some of my emails and after which I just click on save and continue. Make sure these emails are the ones you're using Google sign in with. So basically whenever that Google sign in pop up box appears, you want to select the email, right? So just pass in the email that you want or that you will be selecting and you can add as many as you want till hundred. So that's great. Now we can come back to the dashboard. And if you want, you can just click here to publish your app. But I don't want to do that. I just want to keep it for testing. So I'm not going to go there. Now again, we can go to our credentials, click on create credentials and then OAuth client ID. Now what is our application type? Well, we have to do it for web, Android and iOS. So let's do it one by one for everything. We'll have Android first, then in the name we'll pass in Docs Android. Then we need the package name. So for the package name, let's go over here in our android.manifest.xml file. Just copy this package name and paste it over here. Then we need the certificate fingerprint. Try to use this. If this doesn't work, just open up your terminal and copy this line. I'll mention it in the description below. Just copy it and then click on enter. This will give the SHA1 or SHA256 whatever that's needed. We need SHA1. So I'll copy this and paste it in here. Then click on create and make sure to download this JSON file. This client ID is not of much use to us because we already have JSON file. And similar to Firebase, we're going to set it up. So in our app, in the app folder, we're going to store our JSON file. So let's go to our finder, click on downloads and here name it as GoogleServices.json file. I've named it as GoogleServices2 because GoogleServices already exists in my finder. I need to delete it. So now having this, we have GoogleServices created. No need to do anything or tamper with anything where it's not needed. Now just rename this to GoogleServices.json file. Great. Now let's close all of this. For Android, let's see what else do we need to do. That's pretty much all that we need for Android. So now we can go to the build.gradle, here update the flutter minimum SDK version to 21 and here we'll enable multidex. Having done all of this, I don't think anything else is needed. So we'll close this file. Now we need to configure for iOS. To configure for iOS, make sure that you have a macOS or you have macOS in your system or you have virtual machine setup so that you can work with us. But if you only have Windows and have no virtual machines, you can't build apps for iOS. So just skip through this process. The timestamps are mentioned in the description below. We'll open it in Xcode. Now we can go to our Google Cloud console again. Click on create credentials, OAuth client ID and now we will register iOS app. Now what is our client name? Well, iOS docs clone. Now we need the app bundle ID. To get the bundle ID, we'll go to runner, we'll click over here on the runner. Copy this bundle identifier and paste it in here. Then we can click on create. We need to download the blist file as well. So we'll just rename this, we'll rename this to Google service. It's not like this, I guess it's Google service info and after this hyphen. Yeah that's it but I need to put it in desktop so that I can rename this correctly because I already have that created. So I'll put this in runner and then click on finish. Now let's see if I name this correctly, I'll go to the iOS integration part. Here you can see Google service info. It's correct. We have put it in runner, we have completed all these steps. Now we need to go to the info.blist file. For iOS, don't go in Mac. Make sure to go in iOS info.blist and in here we need to pass in this whole bunch. So we can just copy this, paste it here and here you can see it says to pass in reverse client ID instead of this. So how can we do that, well just go to Google service info, take this reverse client ID and go to info.blist and paste it in here. Copy the, save this much and there we have it. We have done this. Now we need to go to the pod file, uncomment this line and yeah that's pretty much it. Final configuration is for web. So we'll have to create another client ID, we'll call this web and let's call this web docs clone. Now you can see authorize JavaScript origins. This basically means what URIs or what URLs are accepted for our application to run on. Well what will we use, if you're deploying it online, you'll have to pass in the name over here but since we're just doing it locally as of now, we can just click on add URI, pass in HETP slash slash localhost 3000. That's one that we're going to have. Then we can click on download JSON. Then go to our downloads and here we have this JSON file. We can click on OK. Then we will go to our Google sign in and see what we need to do for web. We just need to copy this line. After copying this, we'll go to index.html for web. In the head, we will pass in this line. Now we need to pass in the OAuth client ID. To get the OAuth client ID, all we need is this line. So we'll just paste it in here. Let's remove this extra and save it. Yeah, it's not necessary for you to put it over here, you can even put it over here somewhere but it has to be in this block which is the head block. Don't put it outside of this somewhere here. Just put it somewhere here inside of this block. After this is done, well, that's all we need. We don't need the JSON file. If you have it, just delete it. Now if we try to run our application and if we try to use Google login on web on this port which is just some random port, it won't work because we've passed in the port as localhost 3000 and it will only work there. If you deploy it online on some website, it won't work even there because the URL over there is different. So once you deploy your application somewhere on the web, you need to pass that URL in the Google Cloud platform as well. To do that, you can just click on this edit button and pass in the URL again. It's that simple. Again, it's in credentials and here you can pass it in. And if you're working on Android and iOS apps, they don't accept com.example apps, the package that we have. For example, if I go to the android.manifest, you can see the package name here is this. They won't accept apps with com.example. You have to name it something else. So obviously there are packages that will help you change the package names throughout the application and then you can deploy it on the Play Store. But after that, you again have to register over here because this works for com.example app, not for the newly registered package name, right? Now having all of this set up, let's see how we can run on the web. So if we just go to Google sign in web package, here you can see this is how we can run on a specific port. So if I just type it in over here, you can see we need to pass in flutter dash dash chrome and it has to be localhost so you can type that. This is not generally required because anyways, the default one is localhost. And then you can have web port. Now since we passed in 3000, I'll pass in 3000 here. If you've passed in something else as the port, you need to pass that. So if I run this much, it will open the app in localhost 3000. Let's wait for it to launch. And here we are. Our application is there. Now we need to configure the Google sign in. So for that, we're going to create a repository because it's going to be some business logic and we're going to create a file called auth underscore repository dot dot. Here I'm going to create the class auth repository and then we are going to have, well, first of all, instance of Google sign in. So we'll have Google sign in and we are going to make this private. We're not going to initialize this. We're going to take it from the constructor so that it's easier for us to do unit testing the video on it. Unit testing, widget testing and integration testing will be out very soon. So stay on the lookout for that. But for now, it's just helpful in unit testing so that we can create mocks. If you're already familiar with it, you'll know this. And we've made this private. I'll tell you why. Another thing that we might need is and other constructors that we need, we can look after them later on. But now we can just generate constructor for this. If you're wondering how I got this, you can just go to the extensions tab and download Dart class generator package. It's pretty useful. Now here you can see it's already giving us an error because we can't have private variables in constructor. That doesn't really make sense. So what I'm going to do here is remove all the required part and just type in Google sign in and then have this. Also make this a required field. Here we need to make sure that we pass in Google sign in as Google sign in. What we're basically doing is creating a private variable which we will use throughout our application. But here we are accepting Google sign in from the constructor. Since we can't have the private variable over here, we are passing it as a public variable. But the scope of it is limited to this constructor because that's how they work. And then here I'm asserting that this Google sign in is equal to Google sign in. So this private variable is equal to whatever value is passed in over here. Why are we doing this? Well, if we just pass in Google sign in and you required this dot Google sign in, this should work, right? But what's the point of this when Google sign in is a public variable? That means it can be easily accessed. The point of making this private is that the scope of it is limited to this class only. We don't want other classes to access this Google sign. That's why we are doing this. If we just make it a public variable like this, it will allow us to use this instance of the class. But that's not what we want. So this is how we're going to do now. Having this, now we will create the function called void sign in with Google and we're going to pass in asynchronous. Again a try and a catch block. And in case of any errors, let's just print out A. We will obviously replace this print because they're not available in production code. But we will replace this later on when we do the error handling part. For now, we're just using the Google sign in plugin. So what we're going to do is very, very simple. We're just going to have Google sign in dot sign in and that will allow us to do the Google sign in part. That's how easy it is. Now if we just hover over this, you can see it will return to as a future of Google sign in account. So we can just have final user is equal to Google sign in and we will await this. Now we will also check if user is not equal to null. Then we can do other tasks. For now, we can just print out, let's say, user's email and user's display name. If you want, you can also print out the user's profile picture. But all of that is not really needed in our application. We will be storing all of this data in our state management tool. But all of this is very unnecessary. I'm just storing it because if you want to use this application later on in some other parts, you can have this source code ready and expand on it because then you'll need email and all of that stuff. Now I'll just try to refresh it. Then and before doing this, we also need to create provider. Now to create a provider, well, obviously we will use RiverPod. So what we are going to do here is pass the instance of this class to this provider. So we're going to call this AuthRepositoryProvider. And here we're going to have provider. We'll get a ref here. This ref is of the type ProviderRef, if I just show it to you. This ProviderRef is basically a thing, an object that will allow us to interact with other providers. Right now it's not necessary, so we can just pass an underscore. But when one of your provider, suppose this provider depends on another provider, this ref will be very useful for us. And here I just need to pass an AuthRepository. Here you can see it asks for Google Signin, so we can just pass an instance of Google Signin class. That's all that we need. Why are we creating this provider? Well, obviously instead of doing AuthRepository, passing in Google Signin and creating instance of Google Signin class continuously, what we can do is use this provider. This will allow us to use this class very easily and it will allow us to test our applications better as well. So this is the best choice in my opinion. Now we can go to the login screen again. Here instead of having a stateless widget, we are going to have a consumer widget. What is this consumer widget? Here you can see, after converting it to consumer widget, which is given by FlutterRiverPod package, we get something known as WidgetRef. This WidgetRef is like ProviderRef, but ProviderRef allows us to interact with providers. WidgetRef will allow us to interact with widgets. Right? Pretty simple. So after extending this, we can have WidgetRef. Why do we need WidgetRef? Well, you can see it's provider. We can't directly use AuthRepositoryProvider anywhere, right? To call this AuthRepositoryProvider, we need ref. So we can use ref and then use read like Provider package. We can use ref.read, but since we are in the build method, we'll use ref.watch and then we'll have AuthRepositoryProvider and then we need sign in with Google and that's the line that we need. Instead of creating instance of AuthRepository class, all we did was this line and this will help us when our app gets bigger. So now you won't understand the difference. You'll think creating instance of a class is very much easier, but trust me, this one is much much better. Now I'll just create a function for this called sign in with Google, take in a WidgetRef from the argument and then call this method ref.watch AuthRepositoryProvider.signInWithGoogle. Now since we are outside the build function, we can use ref.read. Now we can use sign in with Google function and pass it in like this. Also remove this end from here. And then we need to pass in the WidgetRef. Save this much and we have the app ready. Also if you go to your pubspec.yml file, you can see Flutter RiverPod version is 1.0.4, which matches the latest version, but in midSeptember, Flutter RiverPod 2.0 is going to be released and it's pretty much going to be similar with the prerelease version. So I'm going to use this as of now. There won't be any difference, I'm pretty sure about that. So I'm just going to replace this with this version. If you have 2.0.0, make sure to use that. It's always great to stay on the stable version. But with RiverPod packages, I'm pretty sure prerelease versions are safe as well. I've never encountered anything that would change my application. So here it is, we are using 2.0 with the prerelease version. I'll repeat, if you have 2.0.0 released already, please check it and make this 2.0. But for me, it's not available yet, so I'm going to use the prerelease version. There won't be any differences, so don't worry about it. Whatever we are going to use is pretty basic stuff of RiverPod. So it won't get changed anytime soon. Now we can exit our application, run our application again and let's wait for it to launch and see if it's working. So our app has launched and as you can see, it's localhost 3000. I'm going to click on sign in with Google and it's throwing me an error, you can see that. Why is this error? Because whenever we use Flutter RiverPod, if you are familiar with provider, we always need to wrap it with a storehouse widget. A provider that will store all the information of our other providers. For RiverPod, it's pretty easy, we'll just wrap it with a widget called provider scope and we need to import this and make it a constant. So this provider scope will allow us to use other providers and it will act as a storehouse for other providers as well. And if you scroll down, you can see a widget that stores the state of providers. All Flutter applications using RiverPod must contain this at the root of their widget tree. This is the root of our widget tree, my app. So I'm having that. Let's restart the application and then click on sign in with Google. Here you can see I'm sent to another thing. I'll just pass in my email and password. I've logged in and let's see if I'm getting anything. You can see this is my email, this is my display name and this is my avatar. So if I just go over here, click on open, you can see R showing up. That's great. All of these things, the Google sign in part is now working. Now the next part we need to do is we need to store all of this in a database, correct? So now we will have to create a node server and then set up MongoDB to store all of this data in MongoDB. Before diving into the code of Node.js, let's understand what exactly Node.js is. If you go to their website, it will say Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine. Basically, JavaScript cannot be run outside of the browser. So Node.js was built exactly to do that. It could be run outside the browser after using this tool. That's all Node.js does. It allows us to use JavaScript outside of this browser. So obviously Node.js uses JavaScript. But Node.js allows us to do multiple more things. It will allow us to create our own servers. It will allow us to create APIs. It will allow us to create sockets and manage them. What exactly socket? We'll get to it when we get to it in the tutorial. But basically it establishes bidirectional communication. If you're confused, don't worry about it, we'll go through it later. But Node.js just fastens all of our processes. Writing plain JavaScript would be very much difficult. But with Node.js, it's much much more easier. Node.js doesn't just allow us to create servers and all of that good stuff. It also allows us to create terminal apps. For example, if you open up your terminal and want to do something with your terminal only, Node.js even allows that. But we're only going to look at creating APIs, sockets and all of that stuff. So what does this line even mean? JavaScript runtime built on Chrome's V8 JavaScript engine. Well, we all know what a runtime is. You can consider Node.js kind of like a framework, a backend framework. For example, Flutter is a frontend framework. Node.js is a backend framework. And Chrome's V8 JavaScript engine, this line right here. Basically Chrome runs on this JavaScript engine, which is called V8. And this V8 JavaScript engine is written in C++, which means it's terribly fast. By terribly fast, I mean it's pretty fast, not in a bad way. But it just means simply that Chrome V8 allows us to execute JavaScript code. And that's exactly what Node.js is using. Chrome is built on Chrome's V8 engine. And Node.js is built on Chrome's V8 engine and thus allows us to write code over there. So this is pretty much all about Node.js. I think you got a very brief idea about it. So now if you want to install it, if you're on Windows, this will show you Windows. And just click on this version or this version. This version is recommended for most users. But I'm using 18 version. And if you want to verify that you've installed successfully, just go to your terminal and write nodeversion. And it says version 18.1.0. But I don't think it will make a difference even if you use a lower version like 16.17. Even 14 works just well for me as well. So now let's get done with all of this. Now we'll come to our root file. Let's close all the save files, clear off our terminal. And in the root, we need to create a folder. So I'm going to type make directory, which is mkdir, which will make a folder. And we need to name this server. So now we have a server folder ready. Instead you could just click over here and create a folder. Same thing. But it should be in the root of your folder of docs clone. Now let's go to the server. So I'm going to use cd, which means change directory server. And now I'm going to run npm in it. This npm is node package manager. Node package manager is like pub.dev. So if you just go to the website, which is npmjs.com, you can see this npm right here. This is not the real name. Don't get confused by it. It's just for fun. If you just click over here, you can see it keeps on changing. Anyways, so here you can search for packages. Just like flutter, we can have multiple packages. For example, if in flutter you're using HTTP package, you can have the same thing here as well, which is HTTP. The same thing. I mean, this one is same, but there are multiple that are different as well. For example, if you want to use something like express that was mentioned over here, you can see we're going to use this as well. So basically, this will manage all the packages and npm will allow us to initialize a node project. So here we are just writing npm in it. And then if we click on enter, just try to do it yourself, you'll see that you'll get a bunch of options, you just have to click enter on them. But a shortcut to avoid that is just typing dash y, which means that you'll initialize it and all the options that are asked later on will be defaulted to yes, that's exactly what we wanted. So I've done that npm in it dash y. Now in the server folder, I'm going to create a new file called index.js. In this index.js before coming over here, we need to go to the package.json. Now what exactly is package.json? Package.json can be considered like pubspec.yml file. It contains a name, version, description, the main file, which means the file that we want to run in the start, the scripts, well, multiple scripts that we'll have, we'll get into this in just a minute. Then we have author, license, everything that you'll need to create a flutter package. And your node package, it's just the same thing as pubspec.yml file, it will manage all our dependencies, it will manage all our dev dependencies, similar. Everything is pretty similar. So now in the scripts, I want to change something. So we're going to add two scripts. Well, first of all is the start one, which means which is short for node.slash index.js. Now what does this mean? Wait a second, I'll show it to you. For example, here I type console.log hello world. If you're wondering what console.log is, it's basically print in Dart. It will just print it out to the terminal and if you're on web, it will print it out on the web. Here if I just type, let's say node.slash index.js, because I'm in the server folder, I can use.slash. If I was in the root folder, I would have to use.slash server slash index.js. It's relative routing. Now if I just click on enter, you can see hello world prints out. What I've done here is instead of writing this command, this entire big command, what I can do is just use npm start and it does the same thing. It will run this command behind the scenes and print the same thing out to us. Why is this needed? Well, if you deploy it online, you will have to use something like npm start so that it starts the server. You can't use node.slash index.js. And now let's try to install some dependencies. To install our dependencies, what do we use to do? Well, we would use this Dart add dependency, otherwise we would go to pubspec.yml file and over here manually add them. But another, the third option would be to use something like flutter, pub add, and then the name of the dependency, right? That's exactly what we're going to do over here. Here we're going to write npm, i, or install, both of them work. Even i works. Even install works. As the name suggests, it will install dependencies whatever we type here. So what all dependencies do we need? Well, I said we need express, right? We'll install that. I'll tell you what express means when we get it. Then we need HTTP. I said we're going to need that. You'll understand when we write the code. Then we need socket.io at 2.3.0. This is very important. Socket.io at 2.3.0. Why do we need add 2.3.0? Well, because the sockets are managed in such a way that it needs to be connected on the client side as well, and in the server side as well. So when we're connecting it on the client side, we're going to use another package because we can't manually write the whole socket client code. It's very big and it's very tough to understand as well. So we already have a package for it. That's exactly what we're going to use. And that package that we're going to use socket.io client has to have a socket.io version of 2.3.0. Then only it will work. It won't work without that. So we need to make sure that we add this version. If we add like this, it will install the latest version. But if we write add 2.3.0, it will install the specific version. And then it won't give us any errors later on when we connect to the client side. When we get to the socket part, you'll understand it better when we read the documentation as well. Another thing that we need is JSON Web Token. JSON Web Token, short for JWT, will allow us to securely store our token or create a token based on the user ID. And this token will be stored on our device and that will allow us to process the state in our application. That's why we need this. And finally, we need Mongoose. What is Mongoose? Well, it's just a data object model for MongoDB. Using Mongoose, all the MongoDB tasks get quite simpler like connection, sending data to the server and it gets more organized in my opinion. So I'm going to use this Mongoose. After that, we are just going to click on enter and you can see all of them got installed and we have a new folder of node modules. This node modules contains all the necessary files that we have and it's pretty big. So you can ignore it and if you're uploading it to GitHub, this project, you need to make sure that you have dot git ignore file here and pass in node underscore modules like this. If you're not using GitHub, don't worry about this. So now that we know about console dot log, let's remove it. Now let's import all the packages that we have added, right? So in Flutter, we used to do import and then pass in the name like this package. HTTP from HTTP dot dot. This is how we used to import stuff here. It's a bit different. We need to do constant express is equal to require express. With this, we have imported it. This express we have imported it and stored it in a variable. You can understand what this means. Even in Flutter, we have the variable expression constant express equal to require express. This means express cannot be re initialized or re given a value again. After that, we'll import mongoose. Let's require mongoose as well. Then let's have constant app equal to express. What we have done here is basically initialized express and stored it in the app variable. So we have imported express and you're just initializing express just like we do. We call the function, right? That's exactly what we have done and stored it in this app variable. Then we need to do app dot listen. Now what is this listen method? Well, listen method is basically helping us to start our server. So when we use this, it will continuously listen to our server and will respond. So here, first of all, in the lesson method, we need to supply it with a port. So on which port should it start running? You can see our web is running, our web was running on the version 3000. But even this has to run somewhere, right? So exactly we need to pass in a port. Now we are going to store it over here, which is called constant port. Let's store it over here so that all imports stay on the same line, all initializations on the same line and app dot listen at the end of the file. It's not necessary to make it stay at the end of the file. But if you put it at the end, it seems much more organized, right? So we can say the port as 3000 again. But our server is already, our web is already running on port 3000. So let's have it on 3001, right? Or if that's not there, this is a shorthand. So if the port 3001 is not there, and it will always be there. So the port here is going to be process dot env dot port. If you have developed many apps, you might know that you have to store some secret information inside of dot env files so that they stay secure and are not visible to the public. But this is exactly what we're going to do process dot env dot port. Otherwise, if that's not present, this is 3001, not 3001, 3001. So basically, this process dot env dot port is stored in the site to which we deploy. For example, if you're deploying on Heroku or Firebase, the server, then we need to make sure that we provide it with a port, it can't run on 3001. It's only for local development, but on the web, it will already give us the env port. And we will access this using process dot env dot port. But what if we are doing local development, we don't have process dot env dot port. In that case, we want to use 3001. This is exactly what we're doing. If process dot env dot port is present, which is usually present in the sites to which we deploy our server to, if that's not present, then we will use 3001. And it's most likely the case that we are doing local development. In our case, it will show up 3001 look. So if here I pass in the port, because first a port is needed, and then a callback function. But before that, I'm going to pass in 0.0.0.0, which basically means that you can access this from anywhere from any IP address that you want. You can access this server. So I've passed in 0.0.0. Then we need a callback function. So whenever the app is connected, what do we say? So we'll just pass in console dot log connected at port dollar port. And we can't put in port. So we are going to have port 3001. Now let's just save it and run npm start again. If I just do this, you can see connected at port 3001. Let me correct the spelling. And here we have it. Now this is the way we create functions in JavaScript. You pass in two parentheses, then arrow function, then a block, and then whatever you want to pass in. Alternatively, what you can do is just write in function here and it will solve the error. If you just try to run it again, you'll have to close this because it hasn't noticed the changes. Whenever we make a change, we need to restart the server. So to exit it, we can just type control C and it will exit it. Then we will write pass in npm start again and you can see it again connects to the port 3001. Both the syntax are fine. I just like this one better because it's shorter and less use of keywords, right? I'll again stop this and start it. You can see it still works. It's absolutely fine. Now if you want to use something like this, you know, in our Flutter we used to do. If we wanted to paste some variable here, we would have a string and then over here we need to pass in the variable. But here you can see there is no highlighting and if I save the file, start my server again, you can see it says connected at port port. It hasn't noticed the string interpolation. That's what it's called. In Flutter when we used to do this, it used to work. For example, if I just go in the main.dart file, here I want to pass in the key color. For example, let's say key black color. I used to do this and the highlighting used to come and now the name is Flutter demo and then colors.white, colors.black, sorry. But that didn't happen here. Why? Because here you need to provide backticks instead of normal string. So when you do this, it will identify this as a variable. This backtick is present below the escape key. Now if you try to start it, you can see connected at port port and it's still showing that because I haven't saved the file. When I save the file and try to do it again, you can see connected at port 3001. Great. Now you've noticed we have created a server. That's how simple it was. Just these many lines of code and we have created a server. Let me remove this comment. I hope you've understood everything till now. Now the next part is you've noticed that we've written so many npm starts here. That's not very ideal, you know, making some change and then restarting the server again doing so much tasks. Sometimes we just forget and it will cause us to scratch our heads and think what we've done wrong. But nothing really was wrong except starting the server. So how do you fix that? Well, for that we need to install a dev dependency which is called nodemon. So when we install it like this, it will save it in dependencies. But we want it as a dev dependency because it's only a developer dependency. We don't want it in our application. We just want it for our own use. So we're going to use it as a dev dependency. How do we install it? Dash dash save dev. So you've installed nodemon. This will install it in dependencies. But to make it save in dev dependencies, you'll have to use dash dash save dev. When you click on enter, you can see it is loading. If it's installed, let me clear the terminal as well. And if you come over here, dev dependencies now has nodemon over here. Nodemon will allow us to start a server very quickly. So once I start nodemon, it will keep running a server. And whenever we make a change and save our file, it will again restart the whole server. We don't have to do it by ourselves. Now of course we need a script for that as well, otherwise we'll have to keep writing nodemon.slash index.js. So here what I'm going to do is create another script called dev and then write nodemon.slash index.js and put in a comma. Then we'll come to index.js file. Let's try to run it again. But now we'll run npm run dev, with npm start, this used to get executed. With npm run dev, this is going to get executed. So now I'll just click on enter and you can see connected at port 3001. Now if I just type in console.log, hey this is changing. And if I click on save, you can see it restarted the server. Then it has connected at port 3001 and hey this is changing. My spelling is wrong but anyways. So you can see it's automatically restarting our whole server. Now we have a proper base to start from. Now the next step is to connect our database to our application. So this is how mongoose is going to help us. But before connecting it to mongoose, we need the database setup. So let's get to it. So to create mongodb or setup mongodb, we need to go to this website mongodb.com. Then click on this sign option and then use your desired option to sign up. So let's just click over here and then use whatever you want. I've already created an account so I'm just going to use that. And I'll see you after I login. So I've come to this screen, you might not see the screen in the start, you'll have to fill in some information if you're signing up for the first time. But since I'm already logged in, I'm not seeing the startup screen, just fill in all the information that you'll require after sign up. And then you'll ultimately come to a screen that looks like this. You just need to click here. Then click on new project. Then you have to mention the project name, I'm just going to call this docs clone tutorial. And then click on next. Then you can add any members that you want. I don't have any so I'm just going to click on create project. Here it asks us to build a database first so we will click over here. Then we're going to use the free cluster, there's dedicated one and the serverless one. You can read all the information that's required and that will help you. I'm going to go with the free option. Then here, I'll just select all the default options and then click on create cluster. Then it asks us for the username and password and make sure that whatever you type in here is correct and you have it secured. And you remember it because this will be needed in the next step that we'll use when we need to connect to our database from our code right here. So I'm just going to enter some username and some password. After you pass in it, just click on create user and this will have it. You have this if you want other username and password to use it, you can use that as well. But for me, one is enough, if you have more team members, make sure to use that. It will be very easy for you to segregate and see what the who did what and later on. Anyways, so where would we like to connect from the cloud environment or from the local environment? I'm going to use the local environment. So I'm just going to pass in 0.0.0.0. That means that your IP address is available to anyone and it can be used anywhere as I mentioned over here as well 0.0.0.0 basically means that it can be accessed from anywhere if you want to add any description add that otherwise just click on add entry. Then we can click on finish and close and go to our database. While our database is being deployed, let's write some code to connect it. It's pretty simple. As I've already mentioned, we're going to use Mongoose for it. It makes our connection stuff very easy and it will later on also provide us with some modeling which will make our code cleaner and even easier to connect and save update or delete data from MongoDB. So here I'm just going to connect it. So for connecting it's as simple as it gets. It's just we have to use this Mongoose and call dot connect with this we have the connect ready. If you hover over this and in here you need to pass in the URL. So here I'm just going to pass in constant DB and this DB link will be whatever we get from your whenever this database gets deployed we will have to click on this connect button which will give us the URL. So if yours is already there you can try it out but I'm just going to pass in like this and whenever I get the database link I can just pass it in over here but now only doing this much isn't enough because connect is a promise. What is a promise you can consider it like a future like in Dart we have future so to use a future if we are in a function we can make that function async and then use await and then we can resolve that future or if you're outside of a function and you don't have any function then you can use dot then function right and that will give you a function for example or some data. So you'll get some data here and then you can use that data to suppose print that data. That's how Dart works and similar to that JavaScript works as well. You have the dot then method and dot catch method similar to Dart. So we can just have dot then and whenever this kind of thing happens we will just say console dot log connection successful otherwise there is an error right. So we can just catch that error and then just print it out. So we'll write console dot log error save this much and our connection should be successful. Now if I just open up my terminal you can see invalid scheme because the database URL is incorrect. Now let's try to see our database has been deployed if it's taking more time try to refresh it and see even after that if it's not happening then wait for some more time. If it happens then you can just click on this connect button then click on connector application with MongoDB native driver we have the driver as Node.js and we have the version 18. If you have 16 it still works you can see we need 4.1 or higher. Now we can just copy this MongoDB URL paste it in here and now you can see we have our username that we typed in earlier. Now we need to pass in password. So let's just remove this make sure to include these angle brackets if they are there it will cause an error and you'll not be able to connect so just remove them and pass in your password my password is pretty simple I'm going to change it later on as a matter of fact I'm going to delete this database after my project is completed so don't try to copy this URL create your own so you'll even be able to see the data and you can see connection is successful now. If I just try to let's say change this you can see it's giving me an error that means it's working successfully if you want to see the data how can you see it well first of all close this go to this cluster and then in the collections tab you'll be able to see everything but since you have not created any data you can't see anything. So now let's try to save our data what is the data that we're going to save the user data so whenever you're the user registers we just know we just pop up a Google signin button and whenever the user clicks on that Google signin button the user gets logged in from the from the account they selected from the popup but how do we know that the user has logged in into our application we have no idea currently because Google signin doesn't store it to any console any database nothing it just tells us and gives us data so now we need to make sure that we store it in a database and exactly for that we're going to use MongoDB so how are we going to do it well as I mentioned we're going to use mongoose for that and store the data but before that we have to create a rest API what is the rest API the full form for it is representational state transfer basically whenever you request to a server some data you can only do it using an API correct so we are going to make that API which is application programming interface you might have used somewhere in your application for example when you're using HTTP calls if you made some application so you're requesting or getting some data using HTTP dot get that's exactly basically what we're going to get so whenever we request some server some data using suppose HTTP get or post whatever request you sent in it will send back to you the current state of the database that's exactly and simply what we're going to do and that's basically what rest even means so how are you going to do that well we have to create API for that we can create that using node that's why we have used node but with express this plugin that we have installed or package you can call it this package allows us to make our rest API even quicker than expected so let's try to use this express and create our application so what I'm going to do is here I'm going to pass in express not express because we have not initialized yet using app we can call so we can use the app dot get or app dot post and then define an API and we are going to call this slash API slash sign up this is the route of our API basically if you if your server right now is running on localhost three thousand one right now if I just pass in slash API slash sign up it will and use a post request for that it will make sure that it runs whatever code we call inside the callback function which is this function and this function let me create that function will have something known as a request and response with the request you can access many multiple headers for example you can access header body whatever data you want to send in from the client side can be accessed using request and whatever data you want to send can be used using risk or response you can name this anything you want these are basically variables to access those objects that are sent to us so that we can make sure that our API works so with request we are able to get the information from the client side with the response we'll be able to send some data but we look into it but now another problem comes in I just have this slash API slash sign up what if my user also wants to suppose get the data so I'll have to create another API for it called app dot API get let's say let's call this slash API slash get and this will be a get request there are many types of requests get post delete update patch you can use all of them and these are the most frequently used ones we are mainly going to use both of them in our application today for the delete one you'll have enough idea to make sure you can delete anything but we're just going to use get and post so I have get here and post here that's how we are going to work but what if I have more API is created for example I want something known as update user information I even want to delete the user account so will I keep creating here but I can keep creating here but that would just make my code very messy what if my application doesn't have login for example in our application we also want to create the documents we also want to save the documents we also want to update the title of our document how are we going to do all of that in just a single file of course we can but imagine this for a very big app for the real Google Docs if they use such kind of structure it will just make their app such pathetic right so we're going to make sure that we shift our code into a separate file of its own so that it's clearly distinguishable if you want to do user tasks you can do it in one separate file if you want to do document tasks you can do it there correct so let's remove all of this from here save it and then we can go to the server file create a new folder called routes and in this routes I'm going to create user.js file so this is the route we are going to create all the user related routes in this file itself now I'm going to require express again because this file doesn't have any import lines just because this has doesn't mean even this file has access to this correct just like a flutter file if you have an import line here doesn't mean a login screen also has that import line they're two separate files so we'll import that now we can of course initialize app and have constant app equal to express but instead of doing this there's another method you can take and I find this much much more cleaner which is using constant author outer which will be equal to express dot router so with this I have author outer created now I can use author outer dot post slash API slash sign up then I can have request response again it's the exact same thing just we have created this author using this router method and we have created it in a separate file that's all now of course our tasks are going to be asynchronous because you're going to use MongoDB it's an external service and we have to store data on the web whenever we have to do such kind of stuff we always require the methods to be asynchronous so I'm going to pass async over here I can't keep using dot then that's why async await was made that's why I'm not using dot then method but of course you can use it I just don't like nesting very much then I can have a try catch block similar to dart whenever there you think there can be a scope of error you can just have a try catch block then you need some data for example what do you want to store in MongoDB well it's a username the email the profile picture that's exactly what we had even printed in the auth repository right all of these things we want to save in our database so we need to get them how are we going to get them well I already told we are going to get them from request dot body right so with request we are able to access whatever client side information is being received and then with body we are able to use whatever is passed through the body there's headers as well but with the headers it's usually for the auth token when we get to it I'll let you know what this auth token is but basically you can even access headers and these two other things you are going to access in our application today but you can access much more information from there if you want to know more just research about it on Google just write request node.js express and you'll get your specific information if you want to follow along well then let's just go ahead now I'm going to destructure it so what is happening well in the request dot body whenever we go to the client side what we are going to do is whenever we send a post request what are we going to do HTTP dot post then pass in this URL which is localhost 3000 slash API slash signup then we have to pass in body and this body is going to be an object what is an object well basically a map so here we are going to pass in like this name ignore the errors for now name and then you'll pass in name then email email and profile picture same thing so that's how we are going to do so now instead of getting some object over here this will be an object or a map so instead of getting an a map over here I'm directly converting it to a string variable or a variable it's not necessarily a string variable JavaScript doesn't care about that it doesn't care about the types so here I'm going to have name email and profile picture and then just save it you can see we have all three stuff now I have access to all of this now I have to store that data to store the data as I said we are going to use mongoose but instead of directly storing the data using mongoose let's create a model for it so models can be considered like structures if you have created an application with a me before using firebase you already know that we create models and in JavaScript we create model in Dart sorry we create models using class this is user model we are going to create right now as well and then we are going to have final string email final string let's say name all of this we are going to write later on similar thing we are going to do in JavaScript as well but using mongoose because in mongoose our stuff becomes much more easier to store of course we can create classes in JavaScript as well but using mongoose it will be a much more easier task so here I'm going to create user.js again since we are in models user.js I can create it again because they both have different routes if you want to create user.js again in the routes folder you won't be able to do that's pretty basic so now in the models we are going to first of all import mongoose so let's require mongoose then here we are going to create something known as user schema user schema is basically the structure of our user so how is our user going to be structured out is it going to have a name email profile picture all of that's good stuff so it's just going to have the structure the schema that's what it is and how do we create it using mongoose we just call mongoose dot schema easy enough and now we just have to pass in an object like this so that we can provide it with a bunch of properties so the first property is name let's pass in like this this is the syntax that we are going to use whatever property name the user will have for example the user is going to have a name so we pass in a name then another object and here you pass in another properties for example what is the type of this name going to be having a type is always good especially when we have from dart it's very much needed for us then we are going to make sure that required is true for example when we use our constructors we want it to be required if there is no require it will throw us an error but in dart it will throw a compile time error which means it will literally show you in your code that please enter your name but in mongoose it will show us an error over here which is runtime error whenever we run and try to store the data and if it's not there then it will throw us an error now the next thing we require is email similar to this it's going to have two properties type string and require true and then we need a profile picture this is also going to be the same thing tribe string required true there are a bunch of other properties that you can use check it out on net you can have trim set to true that means that the user will have their string trimmed from the end that's exactly what trim does just calling the trim method basically so you can add that but i don't think any of this needs it because we are getting it from google directly google has done all of this so why do should i do it again right but if you don't want to take any chances don't take just type it in then now we have created this structure of our application or the user but what about the model we also want the user to have something so that they can store we have just defined how it should look like we have not told it where it should be stored how it should be stored what should the name of the collection be you can see our collections what should the name of this collection be so for exactly that we are going to have constant user equal to mongoose dot model with this we have created a model first we need to pass in the name of the model which has user and then pass in the schema which has user schema and then we can save this much so with this our model is completed we have told how this should look like and we have created a model so that we can easily use them now let's go to the user dot js route and actually instead of calling this user dot js let's call it auth dot js it's going to consist of all the routes using auth not user because you're going to have state persistence route something like that and it's it comes under authentication not really user right but this can be called user model because it just consists data of the user now here i want to find a user with the so how are you going to proceed with this part so how are you going to proceed with this part well first of all whenever we are signing up the user we need to make sure that the same email already exists or not so if the same email already exists then we want to make sure that we don't store the data right i mean if the email already exists we don't want to store that data it's already stored on the mongo db why should i waste one call of mine which is very precious always make sure to reduce the calls to the database so i'll always make sure that email already exists or not if it does not exist then we want to store the data but if it's already stored then well nothing else correct so these are the two tasks there's a third task as well which is token we have to send we have to make and send one but we look into it when we get to the state persistence part which is right after this after we connect to this part we can go to the state persistence part so here how do we check if the email already exists in our database for that we need to you know how to call mongoose and how to check for the database so we are going to use user for that but you can see i don't get any auto option to get the user we have created it here why am i not able to access this user over here well that's because the scope of this user variable is only limited to this file which means you can use this user variable anywhere in this file but you cannot use outside of this how am i going to use this outside then well you can just call module.exports is equal to user you can consider this user to be variable or to be a private variable now and when you use this line it becomes a public variable now you can come to auth.js and here you have user now i get the auto correct option and it requires this this is relative routing when you use express directly it will require the package from node modules folder but when you use user like this it will look for some file so that's the basic difference you can also store you can also call your files like this in flutter that's a feature but no one really uses it you can use it anyways so here how do we find the user with the same email so well we are just going to call user and you can see a bunch of options already there since i have created this user as a mongoose model i have a bunch of options you can see find find one find by id remove where add listener aggregate apply and so on but what do i want to do well i want to find the email do i have a find email option no obviously why because user has the email property that we created it's not necessary that if you create another application it will have user email necessarily it won't have but we do have find by id correct that's because the id property is automatically generated by mongo db itself just like firebase if we don't provide id it will automatically generate that id but for email that's not the case because every user every collection for example if i have a document collection it won't have an email so what's the point of having a find by email option right so here we are going to have find but now again the question remains how are we going to find the user with email then we are just going to call find one why am i using find one and not find because find will return to me a list of users with the same email i'm pretty sure that my app is only going to have one user with the same email but even if there are many many i just want to catch the first one after i get the first one that means that the user with the same email already exists directly without sending any information or creating the new information we are going to send the data so here i want to find one and here again you can see i've passed in a map or an object because i can't just type in email right user dot find one email that doesn't really make sense user dot find one email but what what email do we need to find out so here i'm going to make it like this an object and then we can pass an email this basically means user in the user collection find one user with this email property which matches our email so if you want not get confused i'll just type in email over here so you want to find one user with the email property as the email that we got from our client try to understand the sentence we want to find one user with the email property with the and it should be similar to the email that we are getting from the client side so now i'll just remove this because even naming this carries a big value you'll realize later on because when we send data from the client side we are going to send it with the name of email and when we are destructuring it this is called destructuring whenever we are destructuring it name matters very much so i have this now i find the user now i'll just save it to the user variable and we are using let here let is basically equal to variable user even you can even have variable user or a constant user but we won't use constant why because we are going to assign this user variable with something later on so i'm just going to have let let user is equal to user dot find one but this will be a promise or a future so how are we going to resolve this well we have a async function we can just call await and this will store the correct user information if it's there so we have already now we need to make check or if the email already exists or not so we are going to have if the user does not exist the syntax is allowed in javascript we don't have to do if user is not equal to null what you can do instead if if there is no user then we want to create a new user correct so we can have user is equal to new user just like you create an object you're going to do that and here you are again going to pass in a map because you can consider to remember it you can just consider it that we passed in an object these are required properties whenever we have required properties even in flutter how do we do it well we have to pass in all the stuff so we are going to have email as email we need to pass in the email correct and this name should be equal and the same as the name that you'll type in here so if i pass in profile pic i'll paste this and i want this same name to be there and the name name will also be like this and with this we have created a new user and set it to this but with this much only we have not saved anything to our mongo db well where's the save call correct we have just created that model and assigned it to a variable that doesn't mean mongo db will automatically store it to web so to save it we are going to use user is equal to await user which is this small variable dot save what have i done here well just consider this line we have used save and we have awaited it because this is a mongo db call it will take time so we will have await user dot save and assign this to a user variable why are we assigning it again because as i said mongo db will automatically create that token id or the id for us not the token sorry it will only create the id for us so when it's creating that id we also want that user id to be there so that we can access in our application later on ids are very crucial correct so here we are going to have user dot save and save it to this variable but if there is no user if there is the user already existing then we want to do nothing basically now we have stored the data as well now we just want to return that data to our client side we do that using response dot json it told you response will allow us to send data to send data you can also use send and then send it but with json it will automatically encode it in a json formatting that will be easier for us and then we'll just pass in the user and we'll pass in like this so we want user user alternatively what you can do is just pass in user so when the key and the value name are the same thing you can use the shorter hand syntax instead of typing this full you can just type user and it will know that it means user user correct and we can do the same thing over here as well so instead of having name name name you can just have name profile pic email this will only be allowed in objects or maps you can't use it anywhere else obviously you can just use it within these curly brackets so even here i can use it because there is a curly bracket it's an object great now i can send the data so let's try to test this api now how i'm going to test this api i don't want to go to the client side write the whole bunch of code and then realize i've done something wrong i can't use this right so to test this you can install an extension called thunder client with thunder client you can test your api within your application or within your vs code itself if you're using android studio to follow this tutorial i'll recommend you to install a tool known as postman postman will allow you to test this api and it has much more features than thunder client as a matter of fact if you're using vs code as well but if you want more features than this thunder client gives you you can use postman this will allow you to test debug you can see it will allow you to do that and over 20 million developers already use it but i'm going to use this thunder client because my tasks are very simple i just want to send a post get or some kind of a request and then i'll get some data from here so now what i'm going to do is test this api so i'll go to the thunder client i'll create a post request and click on send but you can see i cannot post slash api slash sign up so how i'm going to do that well why is this even happening so this is happening because in auth.js file we've created our auth router and stuff that's all cool but our index.js is the main file and it doesn't really know what auth router is you can create as many files as you want but you need to register it with the main file and the main file is what we have passed in over here the main file index.js you have to make sure that even index.js knows about it because javascript or node.js will only execute this code we want further code to be executed as well so let our index.js file know about this how are we going to make them know well we're just going to use app.use this is known as a middleware basically when the data comes from the client side to the server side there is something known as middleware in between of them what does this mean let me show you a diagrammatic representation this is our server or the client side this is our server side we are sending some data from here and when we send some data and we want some data it will send us back over here let me just label this this is client this is server sorry for my terrible drawing so here we have the client and the server but what if i want to manipulate some data in between how i'm going to do that well i can do it in the server side but sometimes it's not just acceptable so you do that in this middleware box this is the middleware box i'm just going to create it again so with this middleware box let me just type in m with this middleware box i'm going to manipulate any data coming but here i'm not really manipulating data i'm just using app.use so that i can make sure to use this author router so i'm just going to pass in author router over here but this is called a middleware similarly we are going to use middleware for authentication purposes as well when we get to it make sure to remember this diagram if you want take a screenshot of it a very systematic representation but this middleware is very important for us but you can see when we type author router we are not able to import it again we have to pass in the module.exports line so we'll have module.exports equal to author router now we can take this author router and now we can import it as well so now if i try to run my application let's see if we have no errors i'll go to the extensions tab use thunder client and after you install it you'll get this option just i'm going to click over here i've passed in some data already but if you want to test yours you can just click on new request and pass in data when you click on new request you'll have to pass in this url over here localhost 3001 which is the port we are on and then slash api slash sign up whatever route you want to test and then you might be over here you have to go to this body pass in adjacent content like this you have to pass in a curly bracket then the name email and profile picture make sure to do that single inverted commas are not allowed only double inverted commas are allowed then we are going to send the data and you can see processing is there but it's requiring so much time for this processing that means something is wrong there has to be something wrong when there is so much wrong i mean there's so much time and the reason for that is if we come over here we are destructuring this property but how are we able to destructure it we want to make sure that whatever data comes to us let's go to our diagram again whatever data comes to us from our client side to our server side is always in json format we can't guarantee that because when other developers join in it won't be very easy for us to keep them telling them that this has to be json this has to be json right so instead of that what we can do is app dot use express dot json so what this will do this is again a middleware as i told you so whatever data is coming here it will take that it will convert it into a json format and send it to the server as i said the manipulation of data this manipulation of data has occurred here and i said sometimes it can't just happen in the client side that's why now i'm going to go over here again and now i'm going to send the request and you can see it was very quick it was very instant so i've got my user already created now if i just go to my server and refresh it you can see user's collection is there and here we have it this is id this is the automatically generated id by mongo db we nowhere mentioned it to create it created on its own and it's of the type object id which is another type created by mongo db you can consider it this way then we have name as naman email as number 123 and profile pic as test 123 obviously our profile pic is going to be different later on but here we have it our user is now created our models are working well now the next part is connecting it with the client side let's get into it so for that i'm going to come to the auth repository simply and we're replace all of this with this much now let's understand what we want to do all right so now what i'm going to do is in the lib folder i'm going to create a new folder called models and in this model we are going to create a user model file pretty simple it's going to be very similar to the user model we just created it's going to be well first of all we have to create a class so we love class user model then we are going to have final string profile picture final string email final string name but other than this we also need something known as a token which is going to be empty initially but later on we are going to add this token and another thing that we need is uid if you're getting confused with token don't worry i haven't explained it yet i mean we will get to it when we get to it it's just the next step after this sign up process so we're here in our user model we generated a constructor we need other classes as well so i'm going to generate jsong serialization and then just save it i'm going to close the terminal go to the sort repository and in here i'm going to create instance of this user model class so i'm just going to pass in user model then we need to pass in the name email sorry so we'll have user dot let's see and we have named the same thing you can see this is user even this is user so now we have to change this name i'm just going to call this user account then we will have user account sorry this will be user dot email this will be user dot name and this can be null so let's pass in this over here and this is going to be display name one second then we need a profile pick so we'll have user dot photo url and the uid so the uid is going to be empty for now token is going to be empty for now why are they empty well as i already mentioned to you they need to be initially empty because we don't have the uid access yet token access yet we all we have is these three great after creating this we need to send a http request so to send the http request obviously we'll have the http plugin installed this is the pub.dev page of it it's created by dart language or google itself you can go through the documentation if you don't know how to use it but i'm going to go through in this tutorial anyways now for the unit testing obviously we'll have to get the instance over here whatever packages that are there need to be coming from here so we're going to final client client and obviously this is going to be underscore client and we are having client because http directly provides us with post and get methods but we don't want that we want to use client so that we can mock it if you're familiar with unit testing you might know so i'm just going to have client client then over here we're going to have client set equal to the client i've already explained this in detail now we can have client dot post i hope that's the method if you go to roth.js we can remove this comment not needed anymore we will have post request here so i'm just going to pass in post then we need to pass it to a specific url now to get the url what we are going to do is create a new file in the lib folder called constants dot dot in this constants file we are going to store all the constants of our application for now there will only be one so we'll have constant host and then here we need to pass in the host well of course we have to pass in http slash slash local host 3001 and why are we storing it here well if we just come to this auth repository you might notice that we will keep using this host because we have to keep sending get request or post requests right so we will keep using this instead of writing this whole big string and making some error we can just use this host and other thing is when we deploy our application to some server then the url will change it will no longer be http localhost 3001 that time as well it will help us so anyways here we can type in host but another problem here is we can't have localhost if we have localhost it won't really work on the android app it will work on ios it will work on web but it won't work on android so to fix this issue we have to pass in our ip address now to get your ip address on mac you can just search on the net how to get my ip address but this ip address doesn't have to be you know public ip address it doesn't have to be this public ip address no it doesn't have to be public ip address it has to be your own private address just type it on the net how to get your own private ip address if it's public ip address it won't work if you type on google what's my ip address it will just give you a public ip address that won't be allowed you need to use your private ip address anyways i'll just type in my own ip address here and see you when i get done with it alright i'm closing my constants.dart file and in the host let's just first of all import it and i don't think it's importing let's quickly import the constants.dart file and here in the host we have to pass in slash api slash signup whatever we named over here in our router then we need to pass in you can see this is already giving us an error because it wants a type of uri so we want to pass this so that it passes this string and converts it into a uri after that we need a callback function not a callback function sorry we need to pass in the body and the body is going to be user.to.json not user user account.to.json and that's pretty much it then we need to supply headers to it and this header is going to be content type application json slash json semicolon charset is equal to utf minus eight or dash eight basically this header will tell this header will tell this is a type of json format please accept this if it's not if you don't add this it will give you an error or a warning something like that then we want to save it in a res variable we'll also call await because this is a future and in javascript terms it's a promise now i'm going to after getting this response i'm just going to handle this so we are going to have switch res.status code so our thing our whole concept is determined on the fact that what status code are we receiving and with this i realize the error in our code already if you see in the try block we have sent in dot json but here we can also add something known as status you can see it adds a status code this status code can be anything for example the most famous one is 404 404 basically means not found that is a status code for telling that that yeah we didn't find this page sorry with 200 we say that everything is okay but we don't add it over here because by default it is 200 if you don't mention anything it's going to be 200 but in the try block and in the catch block the error that i mentioned we have to pass in some error right so we will just pass in res.json error e.to string or e.message whatever you want and here if we send it you can see again that would be a problem because res.json will have a status code of 200 which is not acceptable by us we want a status code of 500 which means internal server error so that means that some server error has happened we don't know what but here is the error here is the status code something has gone wrong it's not successful so anything that's not 200 has to be passed in over here if you don't pass in your error handling method will all go wrong all right so in our switch block we will just write if the case let me just write it case is 200 then what we will be do well we'll just use new user and set it equal to user which is this user we don't want that sorry we want user account so you want to use this user account and then have user account dot copy with we don't have the copy with function so let's go in the user model create a copy with function save this much come over here and we'll have copy with function with this we are able to change contents of the user account for example if i want to change the email we can i can change the email already with this copy with but if i directly try to do this user dot email is equal to something you can see this is getting an error because over here i've set the type of my email to be a final final won't change so to change it what i'm doing is copy with if you want to understand the working you can go through this function what it really does all right so in the copy with function i'm going to pass in uid because that's the new thing and the token now we have not received the token so i'm going to leave it empty for now the next thing we are going to work on is the token so here we are going to get that user correct so how i'm going to get that data let's go to this thunder client in our local host you can see this is our object model whenever we send the data we are basically sending all of this how are we sending all of this we have our user account we are converting this into a user model while sending it we are converting this user body to json to json behind the scenes encodes this to map function and to map basically converts it into a map so after encoding and all of that stuff we send it to our server in our server we just extract all of these things since it's an adjacent format and then we just do our processes that's how the whole process goes all right so now to get the uid you can see we have a json bracket and in that we have user so how are we going to get that well first of all how do we get the information to get the information we always do res dot body so whatever response we get that body to get the request you can see to get the request data we are using request dot body but to get the data we are going to get response dot body so in client side we are going to have so in client side to get the data we are going to use response dot body but in the client server side we are going to use request dot body great now response dot body is simply a string we need to convert this into a json format so that we can access objects on it so how are we going to do that well simple enough json decode with this function we'll be able to convert our response dot body to a proper function or to a proper json file or to a proper json string then here i want to access the user property you can see here there is the user property i want to access that property but i just don't want the user property i also want its id so i'm going to have user and the id id here is underscore you won't be able to see it but if you go to the mongo db you can see its underscore id so i'm going to pass in another thing like this so we are taking response we are converting it into json accessing the user property and in that user property we have id property and that will make sure that we have the correct user id let's see what error are we getting well we need to pass in this client so we'll pass in the client as well simple enough you see the usage of this provider now i've just created it over here if i use this auth repository provider in like hundreds of files i don't have to go in those hundreds of files and then use this client instead i just have to modify it over here and everything else falls in place there were no errors in any other file all right so let's go down again here add a break then add a default and in that default we can just throw a string error saying some error occurred otherwise what you can do is just leave it over here it wouldn't really matter in our case at least if you want to do advanced error handling you can just go ahead and do that for example case 400 case 500 all of those types but i'm not going to go that deep in this application all right now how do i get the data how do i store it in my state management system so for that first of all i have to create that state management system so above at the top of my file i'm going to create something known as user provider this will keep track of our user data and this will be equal to state provider this is another type of provider provided by river pod this will also have a ref but i didn't think i care about that and initially the value will be null also here let's give it a type of user model what is all of this basically we're creating a user provider which is of the state provider the problem is if we use this provider it is just a readonly widget we can't we can't just modify the values in this provider to modify the values we can use state provider or other type of provider like change notify provider all of that but state provider is the easiest of all so i'm just going to use them and here i've provided the type if i don't provide this type and hover over this you can see the type of the state provider has become null but that's not true initially the value is going to be null why is it going to be null because when we do our state persistence in our main.dart file we are going to check if the user is null that that means that the user is logged in if the user is not null that means that the user is not logged in so for that we wanted null but if i pass the value of null to it it will cause me some bugs some warnings some errors later on in my application so i'm going to provide it with the user model type as well and this is nullable if you just type this it can't be null correct so just pass in and empty this that means it's a nullable now if you hover over this this has a type of user model now obviously i want to use this user provider in my application over here because i usually like to keep my providers separate from my business logic so i'm going to do that in my ui file usually you will use controllers for that but i'm not going to go that deep into this architecture this is a very simple application the main point of this tutorial is to get you familiar with node.js and sockets so let's now dive into it over here though so how i'm going to well work in the ui file i have to return from return something from here correct only then can i give some thing so i have to change this type but what will the type be i that's a very complex thing because i if there's an error i want to show the error if there's a data i want to show the data so do i pass in a map that would be an ideal choice you have to pass in a map but instead of doing a map way i would like to create another model called error model with this error model you can well first of all create a class and you don't have to pass in model like this instead models are much better than maps whenever you get the opportunity i try to do that they reduce the scope of errors and they are much reusable as well so here this is going to have two properties final string error final dynamic data this is a very rare use case i found for data data i usually try to give types to everything that makes my code much better but here the data can be anything it can be a string it can be an integer it can be a custom class as well we don't know what we're going to return so i'm just going to pass in a dynamic over here now i'm going to create a constructor and that's pretty much it if we want any other functions we can get to it all right over here though i'm going to change the return data type to future error model now we need to return this error model so first of all we'll instantiate this we are not creating this inside of the try block otherwise the scope is limited to this try block we want it to be accessible even outside of this function now here we are going to have error model equal to error model then we pass in the error which will be some unexpected error occurred the data initially is going to be null if all of our if our try block gets removed i mean here we are going to change the value but if that's not the case then it will tell you that something wrong happened i don't know what but there is something wrong but if there is a case 200 that means everything went well make sure to not add it over here if you add it over here that will be bad but if you add it in case 200 that means for sure everything went well so error is equal to error model then we will pass in the error error is going to be null now error here is not showing null so i'm going to go here and pass in question mark that means it can be null and we didn't have to do the same thing for data because dynamic can also be null but in the data here we are going to pass in new user you can see right now we are passing in a custom class which is user model usually i mean we can just pass in a string as well so that's why the dynamic and in the catch block as well we are going to have something similar so let's just copy this line remove the print warning and in here the data will be null the error will be e dot two string whatever we get over here that's going to be the error alright that's pretty much it let's see we have to return this that's why we are getting an error so i'm going to have to return this error great now i can go to my login screen where i've called this sign in with google function you can see the return type is error model so i have to create this asynchronous i'm going to await this and then get the error model so i'm going to call this final error model is equal to this then i'm going to check if error model dot error is equal to null if the error is there then we want to show a snack bar so for that we are going to use scaffold messenger dot off context dot show snack bar and then we will pass in a snack bar the content which is going to be a text and it will just be error model dot error let's just pass in not and over here it's going to be not equal to null so if error model dot if error model dot error is not null then this should happen but of course we don't have build context so let's accept build context and that throws another warning but we'll get to it so here we have it now you can see do not use build context across async apps to avoid that what we can do is final s messenger is equal to scaffold messenger dot off context let's put it here we'll take the s messenger and put it over here so now the error is fixed we have used context before making the asynchronous call and then we are showing a snack bar but if there is no error then what should we do and actually i like it this way better i'm just going to put this in the else block so if the error model dot error is null that means everything was successful that means data has some value what are we going to do well i just want to go to the home screen so i'm just going to create another screen called home underscore screen dot dot import material dot create a stateless widget and then home screen this is going to be a scaffold save this much also here in our body we are going to have a centered child text which is just going to be reading from our river pod so we are going to have consumer widget and this will have a widget ref everything we have done so now in the text what are we going to add well i just want to check for now that the email is correct or not so i'm just going to have ref dot watch user provider dot email and this has to be not nullable that means that the user provider now has some value and it obviously has some value because we went to the home screen but before navigating to the home screen we also need to make sure that we store it in our user provider how are we going to store it well simple enough we are just going to use ref so we are going to have ref dot read user provider over here if i type this you can see i'm not getting any option to edit it what should i do it's just showing me the values of the user model the properties available on user model because this is of the type user model to make some changes you'll have to add dot notifier here and then you can update the value you can see now we are getting different options now i can call dot update and now i can update the state so the state can be error model dot data that's pretty much it they should update it now i have to go to the next screen so again i'll have to create navigator here otherwise the same message warning that we will get we need to avoid that so we'll have navigator dot of context obviously we'll have navigator replaced later on when we use some package so that we can have our proper routing done but for now we will just have navigator dot push then we will pass in material page route we'll get a context and here we just need to return the home screen i can ignore the warnings for now or i cannot let's just check not ignore it i'll save this much i'll have to start my server i exited it so i'm just going to run it again i'm also going to run my web version and see if it's working or not and i just realized i've launched chrome on a wrong version i have to launch it on a 3000 port so i'm just going to run the command that we already earlier had which is this flutter run dash d chrome web port 3000 and we are running this on 3000 but our server is running on 3001 that's a keynote if you run both on 3000 that will be a scope of error all right so our app has launched let's go over here sign in with google and you can see it sends us xml hcdp request error now why am i getting this error well that's basically because of an error known as course cross origin restriction basically this is a very multiplatform app you can run it on android app ios web whenever we are sending hcdp request you can see we're sending it from web we can't share it you know from web from android all of that so to solve this error we will just have to close our server and run npm install course course issue is a very major issue i mean it just happens to everyone so make sure to add that over here we just have to import it first so we'll have constant course is equal to require course if you want to know more about course you can check out the web it's a pretty big thing i can't explain it all together over here over here i'm just going to use app.use and then pass in calls and since we are here i realize another error that we might have made we have to go to the user model here and in the from map function you can see everything is correct except the uid part because uid is not really uid it's underscore id you can see it in our thunder client as well if we just go over here everything is correct except underscore id we want the underscore id as well correct so here instead of having uid we are going to have map underscore id now i can restart my server okay i have to restart my server not use this i can go to the index.js file and instead of using course like this i have to use it like this as a function now save this much i'll try to run the app on web again i'll restart the app then i'll click on sign in with google and you can see revan contacts at the rate gmail.com showing up now if i go to the home screen and you're type in id just to make sure uid just to make sure it's correct and i have to restart it of course when you restarted the state didn't persist we have to work on that we are going to do just that after testing this out we're going to click on sign in with google and our id is showing up as well that means everything worked now the next part is whenever we restart the app we don't want to come here if we are logged in we want to stay logged in if you're not logged in we don't want to stay logged in come on the screen let's get into it so how is this entire state persistence thing going to work out well i'm going to draw a diagram to explain that to you well again this is our client side this is our server side and now we want to process the state so obviously we've done the login process we have sent it across then we've got our data but that's all is over we understood the problem as well but now to process the state what we're going to do is first of all whenever we log in we are going to send that data across but here when we do our login processes for example when we do it in our index dot js and in the author router sorry if we come over here let me close the terminal here we'll be generating a jwt which is json web token this token will allow us to securely store the user id within ourselves and verify if it's a correct user or not so here we will generate a jwt and send it across to the client side so when we got here we're going to send this across but with a catch we are also attaching our jwt with it so we are attaching our jwt with it as well now over here in our client side and this is the server side so whenever in our client side we get the jwt we are going to store it in our local machine that means in the device for example if you are on web we are going to store it in the local storage of web if you are on android or ios we are going to store in the local storages of those devices this jwt will get stored here and then whenever the user quits the app or suppose here we restart our app we are going to check whenever the restart happens that means whenever we get to the root of this file whenever we start our application here we are going to check if the jwt is there or not in our local storage if it's not there in our local storage well we are not logged in but if it is there then we want to get the user information as well because ultimately if i just sign in with google because ultimately i want to display some information on my webpage that's not going to happen in our application but in case you want to display a profile picture let's suppose so after you restart the app and the user is logged in you could get to the right screen as well but you don't you won't have the user data in your provider right because we are adding to our provider after we get the user information from our auth repository that means over here here we are creating a new user sending it over going to the login screen we are getting this and reading from here but that won't be the case when we restart the application when we restart the application we'll directly come here we'll check okay there is no user we'll go to the home screen login screen if there is a user okay let's go to the home screen but where is the data where are we storing it in our user provider we are nowhere storing it so exactly we are going to fetch the user information with that jwt that's why we are using jwt jwt will securely process that user id that we are going to sign it with you'll see later on in our code but with that we are going to sign our jwt and when we send it to the server again to fetch our data we are also going to pass in jwt so all of this stuff has happened now let me erase it off so all of that stuff has happened now for state persistence we will send across our jwt and in our server side we'll make some code so that it can send it across again and give us the user data so after we have this user data we can access our application pretty simple correct now let's get into it we are going to go to our authorouter so let's quickly go there where is our authorouter yeah and here we are going to well first of all create a json web token so for that we have installed a package correct now you know jwt is just for securely transmitting information so and just to mention why are we using the securely transmitting information not directly id we can store the id as well in our local storage but if we use the id there is a great possibility a hacker or someone else might get into your phone crack your phone and just see the local storage of your application so we don't want that we always want to secure it that would be really good as well correct now over here i'm going to have jwt and we'll require it saying json web token jwt is just short but this is the package name json web token now i'm going to use this jwt and as i said we're going to sign it with something which is our id so we already have the method for it you can see sign so always we need to provide jwt you can consider jwt like a wrapper around some information so with jwt we will get a random generalized random generated token but we want to display something correct i mean not display but we want to get some information based on it so for that we are going to have jwt dot sign then we are going to pass in the id and the id is going to be user dot underscore id now let's understand why we did this over here we found the user whatever user we had in mongoose with the same email we have already used that now here we are just checking if there is no user that means we need to create the new user so we have saved it and then we are you we are assigning it to the same variable right so we can use user dot underscore id if the user is newly being created then it will save it if it already exists we already have that same user variable there now here i'm going to have constant token equal to jwt dot sign having this i can just take this token and pass it along with our user and that's why we had this object created otherwise you could have just done user and it would work just fine but we want to do we wanted to send token as well so i did this now as we are here we can also create another route which is to get the user data as i mentioned already over here we need to get the user data so i'm just going to create another route called authrouter dot get we are using the get request here because we want to get the user data here we use the post request because we wanted to send some data to our database and here i'm going to have just slash then we are going to have something known as an auth middleware which we are going to create just now and then we are going to have async request response and then this is all of our code our route so basically whenever we access localhost 3000 but with only a slash we don't want anything else slash api slash sign up is not required we only require slash that time we will use this slash and you can have multiple routes with this slash for example you can also have authrouter dot post but this part needs to be different otherwise this part needs to be different but it has to be different you can't have two routes with the same url right i mean the server will get confused all right now what is this auth middleware well auth middleware as i mentioned you can guess it it's a middleware so let me get my illustration quickly so here we are going to have our middleware obviously as i mentioned this is a middleware part but in this middleware whenever the client sends some data it will come over here now in our application we are going to have a feature wherein the logged in users will only be able to see certain types of routes for example document only the logged in user will be able to view the shared documents will be able to create new documents all of that stuff so we need to make sure that we add a layer of protection to check if the user is authenticated or not so if the user is authenticated then only we can proceed forward now of course we can put that in every route for example if i have this route i can here get the user's id from the header and then check and why header why not body because get request don't allow body i mean we are just getting the data so what's the use of body but there is something known as header so tokens are generally sent from the header now with this header we can get the user id and then check in our database if that user already exists if the user exists that means that the user is authenticated if the he is not then they're not authenticated all of that stuff also we'll have to say check something regarding the token correct because we want to know that the user is logged in or not i mean the user can just log in and then click on log out and after that we we don't know if the user logged out correct so for that purpose jwt will help us and we'll create all of that in auth middleware we won't do it in this route of course we can do it in this route but it wouldn't make sense to do it for hundreds of routes correct so here we are going to get some data we can access that auth middleware so this is our auth let me create that a so this is our auth middleware after we get that we know if the user is logged in or not if the user is logged in then we can perform our task accordingly if not then we can just say the user is not logged in i don't know what you're telling so let's go here and create the auth middleware in our server we are going to create middlewares and this auth middleware that we are going to create is a very important thing in our application you can understand that right away because on this our entire application is going to depend because logged in users will only be able to see the google sign in button no other route they'll be able to access so this is a very important feature if you didn't understand make sure to leave a comment and i'll try to explain it to you again anyways now let's create a function for authentication we are not going to use mongoose for it because well obviously mongoose has to do something with mongo db we don't want to do anything with mongo db so here i'm going to have my auth middleware it's going to be a simple function and it's going to be async request response next and then since it's async we are going to have a try and a catch block then here we are going to first of all access the token and we are going to get the token here from the request dot header so we can have constant token is equal to request as i mentioned request allows us to view body allows us to view header so this is the header and through the header we are going to pass something known as a token and i'm going to call this x auth token i like to generally call this i think it's a convention as well i'm not pretty sure about that anyways you can name this whatever but make sure later on in your application whenever i use this x auth token you have to replace this with your own token i mean with your own line for example if you type in token you want this to be token not x auth token then then here you can check if there is no token mentioned that means there is some problem because you have not mentioned any auth token so we can just return response dot status 401 why are we having 401 because 401 means no authorization i mean the user is unauthorized that's why you're using from 401 if you use 400 it would make sense a bit but it still doesn't clearly make sense because 400 means bad request so here i'm going to pass in 401 no authorization so we are just going to have a json and here we are going to type in a message if you want you can have an error as well but i'm going to go ahead with message and i'm going to type no auth token access denied now if there is no token then you're going to return it so if there is no token mentioned then we are returning it that means we are getting out of the function so we can use the guard clauses technique here and obviously just continue along so here we are going to have constant verified so that we verify now how are we going to verify the token it's in a jwt format you remember we are sending the data we are getting the data back jwt we are storing it in a local machine and then we are sending this data again to a server let me remove the arrow so that it's not confusing so we are again sending our data the jwt to a server through the header and xoth token is exactly that jwt so how are we going to verify that jwt is in a gibberish format it's not a real id how are we going to do that well obviously we are just going to have jwt.verify method on it now let's access jwt as well so we are going to have constant jwt is equal to require json web token and now we have access to this i can just call verify method now in this verify method first we need to pass in a token so our token is this and then we need to provide it with a key so if you go here we have made an error already here in the sign method it requires a payload which is our id and a secret or private key this secret or private key i need to mention now what is the secret key going to be well it's just going to be something you can access your jwt with for example if you want multiple jwt's in your application it's not just for you know storing or securing the information or password it can be literally anything correct so here we are assigning the key to it so this is the password key if you want later on for a document for example you can create document key we are not going to need this in our application but for password we do need it so we will provide password key and exactly that we need to mention over here as well so that we can verify it then here we are going to check if not verified then we are going to return res.status again 401 because it's unauthorized json message token verification failed try again later or authorization denied you know this seems like a very good message all right now after having this if the user is verified then finally we can just do request dot user is equal to verified dot id what does this mean well here we are basically telling that the request parameter that we have can now have a new object on it this is how objects are used if i have not mentioned it already request dot user is equal to verified dot id not index of verified dot id so if we go over here and we have the auth middleware with us only when we have the auth middleware with us and the user is authenticated here we can just do console dot log request dot user and it will print out the id of the user because here we have stored request dot user as verified dot id so what has happened is we add our again big box here we went we are checking if there is authorization we are storing some information which is our id as request dot user then we are going here so it already has that information that yeah request dot user is this if you try to use it over here it will give you null or undefined something like that so you don't want that so obviously only when you use auth middleware will you be able to so yeah we have done that and similarly we are going to do for the token as well so we have we are going to have request dot token equal to token and now here we are going to have a catch block saying res dot status five hundred dot json error and here we are going to have e dot message great now you might have noticed that we have an extra parameter here which is next obviously this is not an express related route so this is a middleware now in the middleware i mean this comes in express but it's in the middleware of the express route so we also get access to next so we can call next over here which is a function what is this function well when we go from our client to us to our middleware we are having our verifications like if there is no token this then if there is a token then we can move forward so we'll have verified jwt dot verify then we are having a check if it is not verified then we'll return all of this and if it is verified then we are going to have all of this done but how does our server know that we won't go next i mean we do won't go over here we don't have to go over here all of this can happen but we won't go to the next part even if it is successful if we don't add this line we won't be able to go over here because our middleware doesn't know we have to go and when do we have to go only after all of these attempts have been done only then do we have to go next so we have added next over here all right now having done that let's export this don't forget it we won't be able to access it then we can take this auth middleware come over here and import that auth middleware great now that we have access to it we can use mongoose to get the user data that's what i had mentioned right so here we just want to get access to the user so we'll have access user and how did we get access to user well this line correct i've named it const instead of let because i'm not going to reassign it i'm just getting the data i just want to get the data and send it across so i'm just going to use the same thing user dot find one i can use that so i will have await user dot fine but here you can see find find one find by id which one do we use well we can use find and then find one of course because there's going to be only one user with the same id and then we can have underscore id as request dot user now this should work but i'm not sure if it will work because id is of the type object id that i would already mentioned to you but here it's of the type string so you might have to check that but another approach to this is just using find by id option you already have the id why don't we just use find by id option and then we can have request dot user and that's it that's all we need to write now we just need to send it across so we just have to pass in user and here we also need to pass in token now what is this token going to be well request dot token simple because here in our auth middleware we are setting request dot token as token so we already have access to it but here i'm not doing request dot token like this you can see there is an error so i have to do it like this only when the key and the value are same for example if this was this then only we could do this now if you seriously want to do it and think it's cool no problem you can just do constant token is equal to request dot token and then do something like this this will also work but just to make sure anyone reading the source code understands this properly i'm just going to do this great now after having this of course you can have the try and catch block wrapped around i'm not doing that now you get the gist of everything that i'm doing so i'm going to skip a bit of steps here now i'm going to close all the save file go to my auth repository file again now over here we're going to have something really similar so i'll just copy this entire function for your practice i would recommend you to not copy and paste this if i start copy and pasting the tutorial will be much shorter so i'll keep copy pasting but it would be highly recommended for you to type this all code so that you can create your apps in the future but even before doing that let me just remove the sauce i'll go up here and as we talked about in the client side in the login side you can see we have a body user account or two json and all of that good stuff here we are going to you do user account or copy with and also have access to token and this token is going to be very similar to this but instead of having you know user underscore id we're going to have token and this has no id it's just token all right so now let's just try to use our thunder client to do the signup process i'm going to click on send and you can see user is there and token is there and this is a pretty big token this has just converted our user id to gibberish so let's close this off and we have access to the token now whenever we get this token we want to make sure that we store it in our server in our local storage how are we going to do that we always obviously don't know how to store it in our local storage so for that we're going to use a plugin called shared preferences after installing that there's no other process required don't worry about it we will just go to our repository and create another called local storage local repository or i think a better name would be local storage repository and in this local storage well first of all create the class and then we are going to have our function well it will just be two function void set token so here we are going to have well this is going to be asynchronous so we'll have shared preferences preferences is equal to await shared preferences dot get instance and then we are just going to do preferences dot set string here pass in x auth token and then pass in the token so this is going to receive a token from here and paste it over here so what are we doing here well first of all we are getting the instance of shared preferences this is how you get it you can't do something like this to get the instance that's just wrong because you just can't have it so here we are receiving the token because we are going to call it here whenever we call it here we are going to pass in our token we don't have access to it as a local class then here we are going to have shared preferences is equal to await shared preferences dot get instance we got the instance of our preferences now we can call multiple methods on it we can call get the string set the string set boolean whatever value you want to set we want to set a string so we will pass in the key of it x auth token don't confuse it with the value of our server and our server also we are going to use the same value x auth token but just to reduce you know usage of many strings i'm using x auth token if you want you can even call this token but when we get the string we want to use this exact name we don't want to falter so let's just keep one name x auth token for all of that and now we have set the token that's all we have set it to our local storage now we need to do this for get token as well so we are going to avoid get token we are going to remove the parenthesis we don't want that anymore it's just going to be a single line function so we are just going to do preferences dot no it's it cannot be single line because we want this shared preferences get instance line so here we are just going to have get string x auth token this doesn't require anything else after we get this we obviously need to return this string so let's return this after having string token is equal to preferences dot get string await this this can be null so that's fine you can just return this token over here the return data type is going to be string and since this is async we are going to have future string and this apparently doesn't require await so let's just remove that so here what have we done well we have created instance of preferences now we are just calling get string on it which can be null because this string might not just exist we have made some error or the user is opening the app for the first time and logging in for the first time then we are just returning the token great now we want to use it over here so what are we going to do well we are just going to take it from the constructor first which is local storage repository it is a package i mean this class doesn't know about local storage repository instead of creating a whole new instead of calling it as an object i would prefer to use constructor so that it's the unit testing is much more easier so you'll have local storage repository again make it private then here we are going to have required local storage repository local storage repository and then just finally have underscore local storage repository equal to this local storage repository now we can take this local storage repository go down and you'll have local storage repository dot set token and this new token is going to be well the new user's token simple enough we add the new user we copied it with this uid and with this token now new user has access to this token or otherwise you could have just taken this from here and pasted it over here but what's the use of it just writing more code right so just use new user dot token and there we have it now we will go up here pass in the local storage repository simple enough now let's finally create the get user data route so whenever we have all of this done we want to get the user data even now we won't be able to you know possess the state because we have not got the user data we are not checking if the user is null or not we are not doing anything of that sort so we need to get this straight so whenever we get this user data well first of all rename this to get user data here we are going to have the same error model created then here in the try block well let's just remove everything till here because all of this we might need switch case error handling all of that stuff so here what are we going to have well we want to get the token first so that we can check if the token is null or not if the token is not null then we can get the user data if the token is null then the user is not authenticated sorry so here I'm going to have string which can be null token is equal to await local storage repository dot get token now we have token with us now we can check if token is not equal to null then we are going to send the request so we can just take this from here paste it in here even the switch cases methods and all of that stuff we can shift it in here also let's remove one bracket that's extra all right so now here if the token is not null then we want to send a response and it's going to be a get request because we want to get the user data for to get the user data we created a route which will just be host slash correct now we have the body as I said get request you can't send body if this was post you could see we could pass in the body but with get no body so let's just remove it so how do we send our token well I already mentioned correct we are going to send in X auth token and this is the header you might have seen we are sending this content type thing here we also need to pass in X auth token and here we will pass in our token now we may we know that it's not going to be null so we can pass it over now after this request is sent we are going to have switch response dot status code if it's 200 then what do we do in case of 200 well we will just remove all of this what we are going to have is user model user model dot from json and then here we need to pass in the source which is going to be user dot body correct no that's the that's the wrong part also this is going to be rest dot body now why is this wrong it does say from json right so we need to pass in our json which is a sponsored body but no that's not how we do it for example if you come to our thunder client here again you might see this is our response we are even passing in token now if we just pass in this it will just see two things user and token and none of our properties from user model dot from json you can see that from json calls from map and in this from map we are just doing email name profile picture all of that stuff but in our map we are passing in this entire object in our entire object this isn't map at user this is not map at token this is map at user at underscore id at underscore name so how do we fix this well simple enough we are just going to pass in this as response dot body at user so whenever we pass in user it will pass in all of that stuff correct but here comes another error we can't use on string these brackets so we will have to convert it to json so we will pass in json encode then we will pass this response dot body to it don't pass user to it just pass user and here we don't need to encode it we just need to decode it now you can see we have fixed the error but this basically means that you have returned a json we have returned a json object from json requires a string so we again need to make sure that we encode it so we will just pass in encode again here we will take all of these lines and pass it over here now it makes much more sense so what have we done we have decoded the json that we got by sending the response we are accessing the user property on it so that we get all of this data then we are encoding this json and finally calling user model dot from json which will read all of the property in this user tab which is id name email profile pic and that's why in from json you can see we have map at underscore id because our property here is map at underscore id but now what about the token token is also very important in our application how do we fix that we didn't get the token we just got the all the elements over here now to fix that what we are going to have is dot copy with and we need to pass in token like this and this token is going to be token well because we have the token already why do we use the token that it's giving us instead we will just take the token from here it's the same thing right you can also do all of this and pass in token but instead of doing that just pass in this token it's the exact same thing we are passing in the token in our index dot js file we are sorry in our auth router we are having auth middleware where we are storing this request dot header you can see we are having this request dot header where we are accessing the token and then sending it off to request dot token and we are sending this to our client again so literally the same thing we are sending off to our server and back to our client so why do i use that instead just use dot token and we have it we have our entire user ready now we just need to send that data across which is an error model all of our stuff is done now we can successfully go back to our home screen where we are going to come we are going to change this not to our home screen sorry in our main dot file where we can change this my app to a stateful widget here in the in its state we are going to call the get user data function because whenever app our app restarts we want this get user data to be there so i'm just going to call the get user data function here i'm going to create that function as well so we will avoid get user data asynchronous and now i will also have an error model created right up there so i'm going to have an error model error model which can be null so as long as the error model is null that means we are fetching the data so as long as it is fetching the data it's going to be null but so we can use that to display a loading indicator but what if the error model is when the error model is not null we can check the error model dot error if that is null if that is null there's something wrong anyways here we can pass in consumer so that we can give our user data some thing not user data sorry error model something some value so for this we obviously need to use auth repository to get access to auth repository we need reference widget ref now how do we do that in a stateful widget it's easy here here and here if you're wondering how i click with three cursors you can just click on option and it will select or deselect for you here i'm going to pass in consumer and you can see error goes away this i've imported flutter river pod that's why this is now a consumer stateful widget which is another widget provided by river pod itself and it's equivalent to consumer widget but just like stateless widget and stateful widget are different consumer and consumer stateful widget are different consumer stateful widget in our consumer state stores the reference the widget ref for example in our login screen if we go we add widget ref here but in our main dot file since we have consumer state we don't have a widget ref here it's already there present like we have set state present correct we have set state present only in stateful widget if we do it in a stateless widget it won't be possible without using another widget you know which is stateful builder so in our main.art file we are just going to use reference.read and we're going to read from the auth repository provider what do we want well we just want the user data so give it back to us and we need to await this because get user data will return future error model our error model is just of the type error model great now we can check if error model.data and before that we'll have to check if error model is not equal to null so if the error model is not null and error model.data is not null then we want to update the user provider that means the error model is not null it's not loading anymore error model.data is not null that means that there is data there is no error so we are just going to use ref.read user provider.notifier so that we can update it we have done this in the login screen as well.update and then we want to update it with whatever user data we get so we're just going to have user sorry error model.data and that's it this is of the type user model if it's correct I mean if there is no error because here in our auth repository we've passed a new user after having all of this done I think we have all the parts ready now we just need to check and watch first of all so we will watch here saying final user is equal to ref.watch and then pass in user provider then if you're using watch in the build method it's correct I mean you can use watch in build read in outside the build so here you can check if user is not equal to null then you want the login screen otherwise the home screen sorry I typed it reverse I'm just going to use user is null then login screen otherwise home screen now also I've noticed all the code part is done if there is no error obviously so I'm just going to start my web on the port 3000 otherwise it will give me an error correct so I'll run it on this port web port 3000 and let's wait for it so here I have the app ready I'm going to click on sign in with Google I'm signed in and you can see 63 all that ID stuff showing up now if I refresh my browser I'm again going back to the screen you can see even if I restart my app from here you can see nothing really changes because well we are on the screen and we will remain on the screen our part now is working successfully we have completed state persistence now let's try it on Android and iOS and if you have any errors there well let's just figure it out how to complete that so I've launched the Android emulator and here I'm going to click on sign in with Google and you can see null check operator used on a null value it does sign me in but it gives me a null check operator let's see why we got that error and the null check operator came here because of fear sometimes the display name or the photo URL can be empty display name is mostly never empty but photo URL can be so to fix that error what you need to do is this with this the profile picture will get stored with an empty string if you want to give a default profile picture you can pass that link of the profile picture over here but I'm not interested in that so I'm just going to give it an empty string for the display name also you can do the same thing if it is null then it will give somewhere if it will give an empty string otherwise it will give this value great now if I restart it should start the application now if I click on sign in with Google I go to the next screen if I restart the app I'm still over here you can see that now the next part of our application is going to be the document part but before that we need to work on something else we want to work on the routing of our application how are we going to manage the routing in such a big application correct now in spite of it being a big application you can use navigator but there's a problem with navigator dynamic links basically whenever I go on the web I want to pass in a certain URL that will fetch me the current document for example if I pass in whatever my URL name is localhost 3000 let's say after that I'll put slash document slash the ID of the document and I want to go to that document how am I going to achieve this that won't be possible with navigator so we are going to use navigator 2.0 for that but I found navigator 2.0 a bit tricky to use and explain so I'm going to use route master for it this is a wrapper around navigator 2.0 and it has a silly name that's fine but this is much much more easier to use if you are coming from a react.js you might know this as the react router DOM it's so much simpler to use it's very simple if you see an example you might see if we want a dynamic link kind of thing this is the link slash feed slash profile slash ID and to use this we are just going to use info dot path meters ID and we have it it's so much simpler and it's very similar to react router DOM so I'm just going to copy this and add it to my dependency I'm going to close this I don't need this anymore I'm going to run on my web because all of these changes won't be visible on phones correct it will only be visible on our web so I'll directly go to the main dot dot and here I need to register my routes first so instead of returning material app here I'm going to return material app dot and I just realized we can't run this we have to run on a specific port so let's run on that port here we have it web port 3000 now here instead of returning material app I want to return material app dot router we have all the same properties except this home and a few other for example routes that is no longer there now we have access to other things like router delegate router information parser router information provider all of that stuff but what we are going to use is two things route information parser which is constant route information parser and you can see abstract classes can't be initiated to fix that we need to return route master information parser and with that we have the property already passed in all we need to do is pass in this constant route master parser and you can see initializes a parser that works in conjunction with route master delegate now we need to pass in route master delegate so here in the router delegate property we are going to pass in route master delegate and here it requires a route builder now based on this route builder we are going to generate and tell which route can be used and what route can be used so here we are going to get a context which is very cool and also here we can return the route we want to use so I am going to shift my final user call in this context and now I am going to check if user is not equal to null and user dot token dot is not empty so if the token is not empty and the user is not null that means that the user is logged in so you want to return a route that will work for logged in otherwise you have to return a route that will work for logged out and here you can see it requires a route map so we need to create this route map I am going to create this in a different file altogether because as our app grows you don't want to fill this UI part over here right so I am just going to create another file called router dot dot in this router dot dot I am going to create basically as many routes I want as global variables so I am going to have final logged out route is equal to route map and here I have to pass in a required route called routes and here it's going to be a map now what is our first map route going to be it's going to be slash so whenever we are logged in what kind of routes do we want to make accessible we are doing that basically so router delegate will tell us that if we are logged in what all routes are accessible if you are logged in then all what routes are accessible so when we have slash we are going to well get something you can see but I don't really care about that still I can take this for this logged out route I don't care so I am going to have constant material page and in the child I am going to pass in login screen so basically whenever we are logged out what all routes do we want to display what all routes can the user go to well just the slash part so whenever the user is logged out and comes to this slash part for example localhost 3000 slash then the user will only be able to see login screen and what other routes do you want nothing else whenever the user is logged out all other actions are prohibited so we don't want anything else now I am going to copy this I am going to create logged in route and here well this is going to be slash again so whenever the user is logged in what all routes do you want to display so whenever the user comes on slash localhost 3000 slash and the user is logged in then we want to show them the home screen so I am going to name this home screen another route that we want is going to be document but we will get to it when we start creating and go to the document part for now logged out route has slash and this also has slash same thing but the only difference is if the user is logged out this will be returned if the user is logged in this will be returned and here we are going to pass the same thing if the user is not null and the user token is not empty then we are going to return logged in route otherwise we are going to return the logged out route note that logged in route will be able to display all of the routes that you want for example if you want other screens to have the same logged in route for example document on all of that stuff you can have that here but this will only include the for the users that are logged out to see an example let's quickly restart our application and here sign in with Google and as you can see I logged in and I am still on the same route I was on localhost 3000 I am still on localhost 3000 that's how crazy it is and even if I try to refresh I am not going back that means it's working so whenever we have slash it's working and this slash also works and that's because we are using ref.watch user provider this is because of river pod as well so whenever there is some change in the route you can see ref.watch runs and all of that stuff happens it reads the data from the user provider correctly and thus we get all of this output this is all together now let's go back to our login screen and wherever we use navigator of we need to replace this with route master dot of context and with this what we can do is navigator dot push but now we just have to pass in slash these have shorter methods for example if we want to do pop or we want to go to the other screen and we want to replace the other screen we can use dot replace instead of using push replacement all of that stuff just replace very simple now if I restart the app I am still over here and all of that stuff works properly now the next part comes in creating our app bar where in our app bar we will be able to log out and also be able to create new documents and then obviously we need to display those documents so let's quickly get into all of this stuff so now we will go to our home screen and in here create a very simple app bar this will be called app bar and here in the actions we are going to put two things well first of all is the icon button and the second one is also an icon button but the icon is going to differ which is the first one is add so that we can create a document here it will be a constant and another one is the logout button so that we can well log out and here let's try to refresh our application I'll restart it and here we have it now first of all we need to remove this debug banner so what we can do is set debug show check mode banner to false and after that we can come to the home screen and here change the color of app bar so the background color here can be k white color after that the elevation can be zero because right now there is a bit of elevation now we will just restart the app and here we have it our app shows up but the icon buttons are not showing up because they are of the white color as well so we need to change their color that color can be color k black color then we can copy this exact same thing and paste it down here great now if we reload our application here we have both of these things cool let's just make our logout button red color so we'll go to our colors dot dot file and here create another constant called k red color so we'll call this k red color make this colors dot red and your k red color then again restart our application and here we have it the red color looks good now let's work on the sign out option it's pretty simple now to make you understand how the sign out function is going to work let me ask you how what is the basis of the state persistence of our application token right so what if we just remove the token from the local storage if I remove the local storage token everything will just disappear right that's the main point so I just need to go to my auth repository here create a new function called void sign out and here this will be asynchronous obviously so here I'm just going to do local storage repository dot set token and I'm going to set it to an empty string I've just removed the token so here if I just show you the state persistence code we are checking if there is a token or not correct if the token is not null then all of this is happening but what if the token is there I mean not there sorry so here we are just throwing an error and on the main dot dart screen we're not handling the error or throwing some error message here we are just saying that if the data is not there then the user is not going to get any value so this user provider will be empty thus this will be empty and thus we will show you the logged out route and that's pretty much it if you just refresh the application and obviously bind this function so we will avoid call this sign out and here have widget ref passed in and here we are just going to call ref dot read auth repository provider dot sign out it's not sign in with Google sign out also we need to clear off our data from the provider because right now the provider has some data we don't want it to contain any data so here we will just say ref dot watch sorry ref dot read user provider dot notifier dot update and we'll again set it to null because here on the main dot art file we are just checking if there is no null then logged in route otherwise the logged out route that's why we are coming to the home screen and setting this to null easy and why are we doing this well this line will set the local storage token to empty so whenever we next restart the application our app won't log in but what if we are I mean we are already logged in whenever we click over here we are logged in it will just clear off the token but still there is some data in the user provider so we'll still be over here even though we are logged out when we restart only then will we go to the logged log in screen but before that we'll still stay on this screen that's why this line is important that will make it null and when it's made null here this part will also run again and thus we will get the logged out route if I just run this again I'll click over here let me just take this and pass it in over here so it will be something like this we passed in the rest successfully now restart the application and then click over here and you come to this sign in with Google now if I just restart the application you can see I'm signing in with Google but when I click over here it didn't even ask me for my email or anything the reason for that is I have not signed out with Google you can see here I signed in with Google and that's all I had to do but from here I even need to sign out right so for that what I'm going to do is await Google sign in dot sign out and after signing out it will ask us for the our email and stuff again so that's pretty cool now I'm not going to sign out and do stuff again but that was the basic point now the next part is whenever we click over here we need to create a new document and go to the new document so for that before anything else we need to create a document screen correct so we'll just create that we'll call this document underscore screen dot dot so we'll import material dot I know this is going to be a stateful consumer so I'm adding the stateful consumer if you're wondering how I got this well first of all let me type this name document screen if you're wondering how I got this consumer stateful snippet I just added an extension called flutter river port snippets you can download it it's pretty cool now to make sure these errors go away import flutter river port and you can see all the errors go away now we need to report it on a scaffold here now also there's another thing that we need to do other thing is we need to get an ID over here so every document this document screen is going to be used for every document that we go through for example there suppose there is a list of documents that are shown here which we created when we click on them we will go to this document screen with a unique ID and this document screen will be this document screen of course we can't keep on creating different screens for different documents correct that would be like really terrible I mean it won't even work correct because we don't know how many documents there are going to be and for every document we can't keep on creating screens dynamically correct so this document screen will manage this all so for that we need a string of ID now here we need to pass accept this through the constructor so that we can pass it from the screen that we are getting it from which can be this part whenever we click over here we generate a new document ID and go over there otherwise it can be from the list of documents that we will show later on over here in the center for now we can just display you know a basic ID so we'll have text ID and that's it I think widget dot ID is better and then just save it alright now let's get to the backend part of all of this stuff so whenever we click over here we need to create a new document so for that we'll have to do multiple more tasks now our authentication part is completed so we don't really care about the auth repository anymore we'll have to do all our stuff in the document repository but before that we'll have to create a route right and it won't be in the auth.js file this is only for authentication files so now we need to create document.js which is the document route and even the document model correct because now we don't want to store all of the data in user collection we want to store it in the document collection so let's quickly design a document so what is our document going to be like let's just think about it well first of all it should have the user's ID I mean ID of the user who created this document so that we know to whom it belongs and later on we can fetch on the screen the list of documents of the user then we need the time at which it was created I mean it's not really necessary but if you want you can keep this it will be really helpful if you want to expand this project later on but for me I'm not even going to use it because MongoDB will automatically arrange it in an order I like then we want the title of the document obviously initially it's going to be set as untitled document but later on the user can even update that and finally we need the contents of that document so what all is written I mean the bullet points the bold text the italicized text all of that stuff so first of all we'll start off by importing mongoose so let's require mongoose after that we need to create a document schema we all we know all of that stuff because we have already done that in the user.js file so we'll have document schema how do we create a mongoose schema well I already said that but mongoose.schema and obviously before we even forget it let's just export this document schema away now here we are going to have uid let me make it small and uid will have which properties well required should be true type will be string uid will always be a string correct after that we will have created at what is created at going to be well it's going to be a date right but in flutter whenever we will create a json model we will convert that date time object into a number which is going to be milliseconds since epoch so for that I'm going to make this first of all required and then give the type of number after that we will have title so here required will be true and type will be string but also there is going to be trim set to true why because title is there I mean title is in the input of the user whenever the user inputs the title I mean the user is doing it and the user input can be risky sometimes so we always need to make sure that we trim it and then we want content content will be of the type array and here you might notice that I'm not entering the required type as true why because content is not necessarily required for instance when we create our application or create a document sorry when we click over here the content is going to be empty so for that I can mention another property called default so what do I want in the starting so what if I don't provide any value to content it's not necessarily required I don't have to give it away whenever I create the document model but I want the default to be an empty list so if I don't give it so that means when I don't mention the content it will take in an empty array and it will do the executions further on based on this now I need to create a document which will be mongoose dot model not mongo mongoose dot model please get it now we want document which is the name of the collection and we will pass in our document schema now I will just take this document and export this not document schema if you notice this then you're well on your way to go ahead now in the document or just like always we are going to import express so we'll have constant express is equal to require express then we are going to have constant document which is equal to require dot dot slash models slash document I'm importing the model then I'm going to create my own document router so I'll have constant document router is equal to require not require sorry express dot router correct now I can go ahead now so I'll have document router dot post and here I need to mention the URL first so I'll have doc slash create not URL path then the auth middleware let me see if I can import it I can't seem to import this so I think I'll have to import it like this so I'll have auth is equal to require dot dot slash middleware slash auth after that we can have asynchronous request response and then we're going to have a semicolon and I think I wasn't able to import because I was missing this I was keeping this parenthesis in between when I remove that I will be able to import great so now after this obviously the try and the catch block right away we are just going to mention the catch block so I'll just copy this paste it in here and now in the try we want to create the document so what is the document going to be well let document is equal to new document we are going to create the object of the new document and then store it to database very simple stuff we did this for the user as well so if you want you can pause and go ahead and try to remind yourself how to do that alright if you weren't able to do it no problem it's still the start so we can just follow along so we'll have created at from the request dot body why are we having that because created at is time based now since it's time based there can be some delay from the server from the client side from the client side when the data comes and we post it to the server there can be some delay due to which the created at function I mean the created at variable will have different time zones we don't want that delay so right away we are just taking from the client side and sending it to the server side we don't want two different values in the client and the server side that's why now here first of all we want to pass in the UID which is going to be request dot user you can see if it was UID then we could have done it this way but since it's request dot user which contains the ID of the user because we add the auth middle where here only authenticated person will be able to accept our application access our application now in the title well what should the first title be it should be untitled document right whenever we create an document we want it to be untitled document and then we want created at after that we are just going to do document is equal to document dot save and we want to do await because it's asynchronous process promise and then we can just do res dot json document easy enough and document will automatically generate the ID for us and all of that stuff which will be really helpful for us later on but here we have it now we just need to export this document router and go to our index dot js file where here I'm going to use I'll use it after auth router so I'll have app dot use document router the matter doesn't really matter but auth router if it's first I feel better now I can go to my repository and here create document repository dot dot file so here first of all I'll have to create my class called document repository then I'm going to have final client underscore client then I'm going to create a constructor out of this so let's quickly create that and here I can't seem to use this anymore so I'm just going to have client and then client is equal to client great now what I can do is create a document so which will be future error model now we will just return error model just literally everywhere except where we don't want to handle the errors or anything I'll do that in a few functions but I'll let you know you'll have to do it if you want your application to be better anyways so here I'm going to have asynchronous try and catch block because while sending the HTTP request there can be some errors and here I'm going to copy most of the things from auth repository but again I would recommend you to not copy and write it on your own it would be better for you but here I'm just going to literally copy all the boilerplate code I've written all of that so I would recommend you to write it too but anyways we don't need all of this stuff let's remove the bracket from the bottom as well now let's save this much so what do we want to do well we want to share a post request we want to import this host variable as well but now here we want slash doc slash create then we want the headers and now we'll always need the token so we'll always have to accept this from the parameter we can't do this over here because I'm not making the ref calls in my repository classes but here I also need to pass in a body correct so the body is going to be let's just get it okay so the body is going to be created at and now I'm just going to send in date time dot now dot milliseconds since epoch also we need to json encode this because we are sending the body we can't just send a map right we can't send an object we want to encode it so we'll have json encode and here also I'm going to encode this now after I get my response I'll check if it's case 200 if it's case 200 then I don't want to do any of this stuff I want my data to be very simply document model and I will have to create that document model as well so here I'm going to quickly create my document model you can see how helpful models are even in dot even in mongoose I hope you're getting the hang of them so here I'm going to have class document model what all stuff are we going to have we have already decided that in the document model in our mongoose file a user id created at title and content let me just have this as well so let's quickly type all of that out final string title final string uid final list content and I'm not giving this list any type you might notice I'm not doing list of string I'm not doing list of int we don't know what the type is because it can be literally anything it can not be just string you know it can be anything that's how the document that you're going to create will work because there are going to be bullet points there are going to be tick marks there is going to be well bolding italicizing changing font size changing font family all of that will be very different so it's just going to be list which is dynamic can have any value also we are going to have date time created at and finally the thing that we have not mentioned here so let's remove this now it's useless now so we'll just have final string id now we can take this bulb icon generate a constructor we can take this bulb icon generate json serialization but here in the from map function always make sure that this id is map underscore id don't change this uid now because this uid will be the uid because in the document we have created this uid property which is the user id but the id property is the id of the document uid is the user id of the document that we are storing so make sure to change this now we can save this and in the document repository we'll have the data as document model dot from json res dot body and here we don't have to do that json encode and decode thing because from json will do that but we had to do it earlier because we had two things returning earlier which if you go here i can again show it to you the user and the token but here we are just sending off the document great so now here let's remove all of this let's break it out and i think this is pretty much it this is our function to create a new document so i can go to my screens folder in the home screen and here i will create a function called void create document so what is this going to be well first of all let's just make it asynchronous because we are going to call the create document function and then we are going to first of all get the token because we want to pass in the token we'll have ref so let's get the ref ref dot read and then we are going to have auth repository provider dot i don't think we need auth repository we need user provider dot token and this user can be null but now it cannot be null because we are in the home screen we are on the home screen only only when the token is not null so we want to not get this null check operator error now we are going to get navigator which will be route master dot of context we are not using build context anymore and we are using i mean sorry we are not using navigator dot of context we are using route master dot of context we also need a snack bar so we will have navigator dot of context then we are going to get the error model which is going to be await ref dot read now we are going to read auth repository provider and call get i don't know why i keep calling auth repository provider it's over and done we need to create the provider for document repository so we'll have final document repository provider which is equal to provider ref and then we can return from this document repository instance and then client we can pass it in easy now we can go to the home screen and here we can pass in document repository provider instead now we can finally call create document and pass in our token just calling the simple function not a very weird task now after that we are going to check if error model dot data is not equal to null so if the error model dot data is not null then we are going to use navigator dot push and push it to the document screen so we'll have slash document slash dollar error model dot data dot id why can we use the id because we know it's going to be an instance of the document model class whenever we use data dot id correct now we need elsewhere we are going to have snackbar dot show ok we don't need navigator of we need scaffold messenger of i'm not sure what i'm doing so here we'll have scaffold messenger then we can do snackbar dot show snackbar and then pass in snackbar the content here is going to be a text saying well whatever error is there correct so we'll just have error model dot error and now it cannot be null because we have already made the checks for it great now we just need to link this to our button here so we'll have like this create document pass in the build context pass in the widget ref and there we are but now if we do that i think it will create the document but it will tell us that the route was not found if i do this ok we don't get anything let's see if we get any error nothing so let's go to our document model sorry in our document repository we'll go down here and in the default we are going to well have the error handling part done so that we know what the error is or you can just even print it out but never mind since you're here we don't need a break after default but if you put in no problem here in the data we are going to pass in null but the error is going to be whatever data we got from here so we're just going to pass interest dot body now ok i think we didn't even restart our application that's why it sent us the error but anyways let's start it if we do this you can see page document and this unique id you can see it wasn't found so that means it's working we got the unique id passed in and if we go to our mongo db you can see that the document was already present there so now why is this route problem coming in well pretty simple error the reason for that is you have not registered in the logged in route make sure that you pass it in the logged in route so here what we are going to do is slash document slash id that's what you need to pass in slash document that's what it is slash document and then our id so this is the id you need to pass in this colon this is called a slug so make sure that you pass it in and then we get a route so we can use constant material page and then in the child we will pass in the document screen and in the document screen we want to pass in the id which will be route dot path parameters and there we are going to access the id and this cannot be a constant so let's just remove that and this can be of the type string nullable so let's make sure that it's not nullable or if there is what we can do is just an empty string simple enough so here we have it material page child document screen so whatever we have passed in here we need to pass in over here and this is path parameters that means you can have multiple ids like this for instance if you want slash dollar something else you can do that as well but here the route dot parameter will become like this it will become something else over here so you have to pass in the same thing after this colon anyway so now after having this done let's restart our application and now if i well go back we don't want to go on the document screen i click on create and you can see i'm coming on this screen where our document id and we're not seeing anything else because here i've passed in something else over here and that's causing the error now if i remove this out and refresh my application close the file also here i'll pass in localhost 3000 i'll click on create and here you can see i'm going to the other screen and the ids are similar that means that this stuff is working the navbar is also gone cool stuff but as you could see in the router dot file even if we added another part another part and click on saved then reload our file and do this we go here but we are still on the same screen even though we are here it doesn't go to the other screen so that's a really cool feature i like it then we can restart our application and whenever we go you can see it automatically restarted and we came on this screen cool now i can again go to the localhost 3000 which is our starting port now here we need to display all the available documents i mean the documents that i have created not anyone else i want the documents created by me so that i can open them anytime i want so let's get into it so now to display them what i'm going to do is go to the document or js route and here create my route very first route called document router dot get my very first get route in the document file so here we want to pass in the url so i'm just going to pass in doc slash me authentication asynchronous request response and the simple route creation after that i want the try and catch block so here i'm going to have that very quickly also i'm going to have this pasted over here now in the try block i want to get all the documents created by me how am i going to get that just think about it did you get it if you didn't then simple enough you just need to do await document dot find and now we want to find all the documents created by me if my user id which is uid in the document i've saved it like that correct the uid is saved as request dot user's id i mean the uid over here that's saved in the document collection is the same as the request dot user that means the user id then we want to get them so we will find them find will return to us a list of document even if it is one document it will return as a list of one document and then we are just going to rest dot json and documents good enough now our route is created now we just need to go to our document repository and here create a very simple thing we will just have something like this but instead of creating a document we are going to get the documents so we are going to have get document so here we are going to send a response so it's going to be post is going to be get actually and we don't need to pass in a body the header is going to be exhaust token and here the docs slash me will come in not docs slash create i want to get docs of mine now switch rest dot status code case 200 and then the error will be this but before that we need to return the document the rest dot body will return to us the list of all the document we don't want to return a list we want to well return one document from the model and then put it in a list here if you do that it will give you an error because rest dot body will be list and this accepts a string not a list correct so here first of all we will have to create a very simple model called document models list let's call this documents initially set to an empty list then we will do for and i is equal to zero i is less than json decode response dot body dot length i plus plus so what we have done we have decoded the json so that we can get the length after we do decode the json of res dot body we can get access to the link so what is the length of the list correct we'll get that and we loop through it and every time we go through one object in the list we want to add that so we'll have documents dot add and we'll add document model dot from json exactly this line right let's just pass in but instead of res dot body we are going to pass in that whole line that we had created earlier as well it's going to be json decode response dot body at i but this will be enclosed by json encode pass it in and then add it in also here we need to pass in document dot model dot from json and then we'll pass in all of this stuff because we want it to be a type of document model correct now we can just pass in documents over here easy enough after saving it i think everything is pretty much done so for this how are you going to do it well there are two approaches you can take there is a provider known as future provider and river port which will allow you to make your boilerplate list but you can look into that in some of my other videos but in this video i'm just going to go ahead with a simple future builder i'm going to go in the document screen instead uh sorry in the home screen and instead of having a centered text saying this i'm going to have my big future builder ready this future builder will have builder it's going to be context and snapshot and a future which will be ref dot watch and we'll have document repository provider dot get documents then we want to provide it with a token so what is the token going to be well it's going to be ref dot watch user provider which can be null dot token a very big line indeed i know but we are just watching the documentary repository provider now we have instance of document repository then we are calling get documents because we have that class basically and then we can use ref dot watch to get the token because it needs a token now here in the builder what we are going to have is very simple if where we will check if snapshot dot connection state is equal to connection state dot waiting then what do we do if the connection state is waiting i want it to have a loader showing up so i'm going to create my custom loader here which will be called in the common tab in the widgets folder called loader dot dot this loader will be importing material dot creating a stateless widget we'll call this loader and this will return a centered child of circular progress indicator this is also going to be a constant so we'll save this much then we can take this loader return a constant loader after that we are going to return a list view builder which will have context and an index and we'll save this much then we also need an item count and the item count is going to be snapshot dot data dot docs dot link and this data here cannot be accessed because we have not given future builder a type we need to give future builder a type which will be error model import that and this can be null and yeah we are getting this error because it's not docs but it's data so when we pass in data now the error fixes now you don't even need this so we can remove this line and it still works so now in our item builder first of all i'm getting my document model because well this is a list view builder i have the item builder and we are getting list of documents correct now i want to get a particular document so for that i'm going to do document is equal to snapshot dot data dot data dot docs i'm not sure why i'm using docs continuously but it's dot data at index now i have access to the document so what i can do is return a card of child center and the text will be center i mean the text is going to be document dot title because whenever we see a card we want the title to be there correct and we need a style which will be constant text trial which will be font size 17 i'm going to make it a bit bigger so that you know it looks cool also here we are returning so we want a semicolon now i'll save this much and see what i'm getting so i'll just refresh my application and here you can see untitled document these many are showing up which is actually correct because i created many documents too because i thought it was a bug in my application but with you if you created clicked on this once then you might have just one but anyways there are a lot of things to fix first of all the height of the card the height of the card right now is just what the text size is i want it to be a bit bigger than the text size correct so for that i'm going to wrap my card widget with a widget known as size box so that i can give it a height of 50 now if i save this much and again reload my application now it looks much bigger and much better now i want to reduce the size of this if i pass in the width over here it won't work for example if i give it a width of 200 and save it and then restart the app you can see nothing really works so i'm going to remove this but give list view builder a sized box widget so we'll have wrap with widget call it size box and then give it a width of 600 now i'm going to save it reload the application and here we have it our doc our card is now 600 width i want this to shift in the center right so i'm just going to wrap this size box with a centered widget and save it now again restart the app and here it is in the center pretty cool i also want some margin from the top right even from here even from here so what am i going to do well i'm going to replace this sized box with a container so that i can give it a margin when i don't have to give it a margin i'm going to use a size box but otherwise i will just use a container now i'll have constant edge inserts dot only and from the top i want 10 of margin if i restart now you can see it looks much better it's not stuck to our navigation bar it is cooler now whenever i click on this i want to go to the document screen and well our magic will start the document socket connection how are we going to achieve that very simple enough we are just going to wrap the center widget with a widget called as inkwell why am i using inkwell because i want the on tap property and why am i not using gesture detector instead let me show you if i restart the app you can see whenever i click on this right now it's giving me this because i don't have to wrap it with the centered in the list view builder let me remove this widget i have to wrap it inside of my card because i want to when i click on this one card i want this hover effect to come in right now it's for the entire screen if i restart nothing shows up because i want to pass in and on tap as well only then will the hover and the splash effect come in when i restart you can see all of this cool cool things happening it is really cool now whenever i click on this i want to navigate to the document screen so for that we are just going to use route master correct so i'm going to create another function here called void navigate to document we are going to have a build context uh then the document id as well because we don't know what and where to move right we want the document id and we will only have access when we know which card was clicked so we are going to have route master dot of context dot push then we will use slash document slash dollar document id now why did i use push instead of replace when i push i get access to this back button but when i use replace i don't get access to this back button that means i cannot go back i don't it will replace the current screen i want to push it so that you know it's kind of a stack if i go back i can go back but with the replace i can't go back there's no looking back now we can go back to our inkwell widget and you'll have navigate to document pass in the build context pass in the document dot id and done now i'll restart my application and whenever i click here i go to this screen if i click over here i go to this one i go to this one you can see all of these ids are different from each other so this is the screen of our application now the next part is over here creating our nav bar and here we'll be able to change our title and we will be able to display you know the google docs icon all that styling stuff after that we will get into our text editor which is a cool thing because it's so easy let's dive into it really quick all right so first of all i'm going to close my terminal and close all the save files and then i'm going to go to the document screen and now let's think how our design should look like this is how the design should look like well what do we have here well first of all we have an app bar which has a different color than this because this is pure white and by default flutter is not giving us the pure white background color then we need our editing tools but before that you can see this line part here that part is not because of the elevation or anything that line is basically because of the color so we need to add that color below the app bar as well but first let's start with the app bar we want a google docs icon we have already installed that in a flutter project here you can see when we were installing the google logo and then we want this text input field this is a text input field not anything else because you can edit this title and then finally at the end we just want the share icon should be very easy to do for us so let's get started with it so here in the scaffold i'm going to return an app bar so let's have an app bar and in the app bar first of all we are going to change the background color so we'll pass in the background color as k white color and then we want the elevation to be set to zero now let's see how it's looking i'll go i'll have to sign in and actually i can't sign in because i logged in from another port see you when i go to the 3000 port all right so our browser is there with us now let's click on sign in with google here i have to enter my email i'll see after i log in here i've clicked on a document and here you can see i'm getting the id and even the app bar that's looking good now let's try to make some changes here as well i'm going to close the terminal now in the actions because i want to add your the share button so i'm going to click on actions and then add the button elevated button dot icon again we need the icon button because if you go over here we have the lock icon and then the share button so let's quickly create that onpress will be empty for now then we are going to have icon of icons dot lock lock not local also i'm going to set a color to it so let's pass in the color of k black color after that save it this is going to be constant then here we need a constant text and then it's going to be called share after we share it and let's try to restart our app here we have the share button now we need to decrease its size and stuff and even before doing that let's just change this black color to the normal color that looks much better yep now we just need to reduce the lock icon size so we can have size as 16 and then save it restart and this looks much better now we just need to make sure that we reduce its size to reduce its size you can to take two approaches well give it a size directly by passing in the style otherwise you can just do control shift r wrap it with a widget called padding and give it a padding of eight then restart the app and if you see this is looking better but i want it much better so i'm just going to convert it to 10 and restart again as you can see this looks much better to me now i want this to be of a different blue color not the original blue color i have to make some changes so i can go to my colors dot file and here i'm going to create k blue color which is equal to color dot from rgbo which means red green blue opacity so it's going to be 26 115 232 1 and if you're wondering where this color is coming from well it's just extracted from the google docs share button itself so here in the button we're going to pass in style as elevated button dot style from and then we can pass in the color of background so we'll have background color as k blue color see now if i restart the app and go over here this looks like a more stylish button now we need to add the title so what is the title going to be these two things the text input and the docs button or docs icon sorry so let's quickly add them below our actions we are going to have a title and in the title we are going to have a row in that row children and the first child is the icon itself so it's going to be image dot asset and then we will pass provide the asset which is asset slash images slash docs logo dot png now let's save this much restart and here we have it now it's too big so we'll decrease its height so you'll have height as 40 and then save it again restart the app here we have the docs i can fitting good enough after having this i can leave a space so i'll have constant size box with of let's say 10 after which i can add another one which is text field now since we are in a row text field works this way that it will try to get everything in the row but we don't give everything over here because this is a docs icon so what are we going to do about it well we have to wrap it with expanded but if we wrap it with expanded this text field will go till here i don't want that i want to give it a specific width so for exactly that we are going to add a size box which will have a width and the width here is going to be 100 let's say then in the text field we are going to pass in a decoration which will be constant input decoration and that will say that border should be input border dot none then there should be content padding and the content padding will be edge insets dot only from the left side 10 then save it restart the app and we don't really see our text field and we're not getting any error for it as well to give it some value what we have to do is create a controller so we'll have text field controller it's called text editing controller my bad then we're going to call this title controller which will be equal to text editing controller and we are going to pass in an initial value now what is the initial value going to be we can pass it through text argument this will be just untitled document you later on we are going to use this so that we can give it the initial text of something else which is taken from the database because even if it's untitled document in the database we are storing it as untitled document right but for now let's just keep this we are also going to call the dispose method here we are going to have title controller dot dispose now we can take this title controller go down and pass to it the controller which is title controller now we can restart the app and we have our nice text field but 100 is too small of it so i'm going to pass in 180 i'll restart and this looks much better i can change the document and everything but still it doesn't look very good because we don't know we have come over here or this even exists right i mean if i click on it it automatically starts to serve like a cursor it puts on it i want it to have some border so for that i'm going to add focus border so whenever the user clicks on this they will see a border now what will the border be outline input border and then we are going to have border side let me have border side of border side and the color is going to be k blue color let me put some trailing commas and then restart the app now if i click over here you can see this works well when i focus it it looks good now below this part here i want to add a border you can see you can see that there is a border here so that there is a clear distinction to make that clear distinction how are we going to do it well app bar doesn't support anything like that except it has an argument called bottom with bottom you can pass in a container but the problem is bottom accepts a type of preferred size widget we can add to it an app bar and it wouldn't throw us an error but i don't want an app bar i want a simple border so for that i'm going to create my own preferred size and in that i want to pass in a child and a preferred size now what is my preferred size going to be well it's just constant size dot from height one so whatever width is there keep all of it and i just want to increase the height by how much one and there is a child now the child is going to be a simple border so we can have container decoration box decoration and we can pass in a border which will be border dot all now here what color are we going to choose well it's going to be gray color correct so again let's go to our colors here we are going to have variable k gray color if you're wondering why i don't have constant here you'll understand right now when i use colors dot gray dot shade 800 this is not a constant shade 800 is not a constant it is variable if i put constant over here you can see it throws an error so i'm going to pass in variable k gray color now why do i want shade 800 because when i use k gray uh just the gray color it's too prominent i want it to be a less prominent one so i'm going to use the lesser shade now i can take this pass it in here and what is the color going to be well k gray color also here i want the width to be minimized so i'm just going to pass in 0.1 now we are getting this error to resolve this error we just need to push the preferred size at the top and not at the ear because widget child should always be at the last that's what the error prompt says to us so let's just follow that right now if i restart it everything looks good but now still there's not too much padding from the top over here so in the app bar uh wherever we had our app bar let's go at the top and in the title we are going to wrap our row with padding after we wrap the row with padding here we just need to pass in dot symmetric and vertical we can do eight let's say nine and then we can restart our app now this looks much more better there is some padding from the top and it looks much more organized all right having this done now we need to set up our controller or you can save our text editor the main part of our application how are we going to do that well obviously we can't use the text field over here that's just very useless so for that editor we are going to use something known as a quill editor and what is a quill editor well you can find it here flutter quill 6.0.0 published just three days ago so this there might be some code that might be a bit different from uh what i've written earlier because i wasn't using 6.0.0 but let's hope not anyways this flutter quill uh is like built on quill quill is something used in some javascript frameworks i've built it i've built a text editor with the quill js itself uh and even with react quill when i was using react it's a very powerful tool and i can completely rely on it if you want to check out you can check this out but we are going to use this flutter quill it's going to provide us with nice widgets and controllers which will make our lives much more easier now to set it up well let's just go to the documentation you can see they've literally provided the entire code we are going to use so let's just copy it in the body we are going to paste it now we need to import this so let's import quill we need to create this controller and also remove this container let's see we don't have that option to remove the container so let's quickly remove it by ourselves now we need to create the controller for our quill so how are we going to do that you can check out the documentation again it's written over there but what we are going to do is while importing quill first of all we are going to use it as quill okay because this has some package which will interfere with our material package and we don't want that correct now we can just use quill like this now let's create this controller so we'll have quill dot quill controller and let's call this underscore controller let me have quill here passed in which will be quill controller dot basic let me pass this in easy also make this final for now later on we are definitely going to change we are going to make all of these controllers late when we use the socket iopart but for now let's just keep it the way it is now we can take this controller and we have it now let's try to restart our app it will or it should throw us an error it does not have any error so let's just keep it as it is or it should throw us an error it doesn't it shows us the toolbar correctly which is great but now you can see we are not getting any text editor as such why well it's because of the sizing issues what i'm going to do is over here remove this comment first and instead of expanded and like this what i'm going to do is wrap this widget with another widget known as a sized box size box will will give it give it a fixed width which will be 750 then we can restart our application now you can see we have certain width in our application it might not be visible but the cursor is very visible now to make this more prominent we will have to wrap it with the card right so that we can give it a bit of elevation and change its color so the quill part we are just going to go ahead and wrap it with the widget card now let's restart you can see some changes it's much more elevated and visible but now we are going to give it a color color is going to be k white color that's probably the default color as well then we will increase its elevation to 5 then restart the application and it's much much more easier to read i mean much much more prominent but now it's stuck at the top and it's not even centered so to make it centered first of all you can wrap this column with centered widget then restart it's at the center now then we need to leave some space from the top so we'll have constant so we'll have constant size box height 10 and let's leave some space between these controllers as well so now it looks much better now we just need to wrap it with a padding widget because you can see our cursor is right over here we want it somewhere over here so for that we have to wrap our quill editor with padding widget not our card widget because if we wrap card this will get padding from all of these sides we don't want that we want only from this quill editor so i'm going to wrap it with a widget called padding and the padding is going to be 30 from all the sides now this looks much better you can type anything you can bold it italicize it whatever good stuff you saw in the intro as well you can also pass in snippets of code if i've not already told it to you anyways so if i remove all of this let's remove it we have our text editor set up now the next part is whenever we change the stuff over here we want it to change in our database as well and it should be reflected as well so let's get into it so to update the title what we are going to do is close all the saved documents all the files and then we are going to go to document.js route and here create a new route well it's going to be very similar it's going to be the same post request so let's copy this line again if you should type it but here i'm just going to do dots slash doc slash title then here i'm going to take in the id and the title from request.body because every document will have their own id i want to go to that document find that id and then update their title correct i mean i will find the document by their id and then update their title so here what i'm going to do is constant or document is equal to await document dot find by id and update this is another method basically we find by id and then update whatever field we want to update so here i'm just going to pass in first of all the id and then i'm going to pass in the title and that's pretty much it now we have updated the document i just need to do res.json document because i don't even have to do this it already updates it and does all the stuff behind the scenes we just need to return this document and we're done easy enough now we can go to our document repository and here create another function to update the document so i'm just going to copy this entire function let's go down and here paste it in so this is going to be called update document here we are going to get the token along with that we also need the id and we also need the title now since there are three parameters what i like to do is make them named arguments so that it's easier for us i'll just pass in required everywhere and then save it also let's put a comma here so that the formatting does this work all right so we have the error model there now we will have a response we'll post but here it will be host doc title then we'll pass in our token because here we have passed in the auth middleware then we want our body but in the body this time we are going to have we'll remove this line and then we'll have id we'll pass in the id then we are going to have a title and the title will be title all of them from the parameters here i don't think we even need the update document part we'll just do it void because we know there are very less chances of this not working so i'm just going to remove all of this i'm not going to return anything but if you want you can just go ahead and do the error handling part it's much better and much easier and it's good to do always but i prefer not to do it this time and it's not update document it's actually update title let's remove this line we'll just do this part but obviously again i'll tell you error handling you should do it i'm not doing it i just don't want to waste much more time great now i will go ahead in the document screen here i'll create a function to call that method void update title we will need widget ref so that we can call the document repository so i'll have ref dot read document repository provider dot create or update title then we need to pass in the token which is ref dot read let's find the user provider and then we'll just pass in the token and this can be nonnullable because we are logged in then we want the document id don't confuse it with the user id we want the document id which we are going to get from widget dot id whatever we are getting from the constructor correct because that's the document id as well and then we need the updated title so that means what do we need to update it to well we are going to get that whenever the user submits this field correct so what are we going to have well we will just get the value from your string title now whenever the user clicks on enter that means that the user does this and clicks on enter then we want the text field to get updated so for that we are going to have an on submitted but on submitted option this will give us a value so whenever the on submitted part is triggered what value will we receive well the entire string there so here what i'm going to do is call this document to do is call this function called update title pass in the widget ref and the title will be value great now let's restart the application and here i'm going to store it as titled document i'm going to click on enter and nothing really happens if we restart our application we see nothing so there is no way of knowing for the user as well that is it saved so exactly for that we also need to retrieve the content of the document so whatever is passed to it we want to update it as well whenever we refresh the document because here i've passed in the title it's stored in the database as well i'm very sure about that right now but i want to display it whenever we refresh or come to this document so how we going to do that we're going to go to the document.js part i'm going to copy this get route and then i'm just going to get this document what is this document well whatever document we have we want to get the data of this document so we are just going to fetch the data by its id and then just return it out so here how do we get the document id there's no way because this is a get route get routes don't have body so how will i access the id so for that there is the slug part now this might be very familiar because in the router dot dot part we have done the same thing as i said the routing part is very similar in node.js react router dom everything so here we have id now we can access this id that's whatever is passed to it also let's remove this we don't need me so we have slash docs and then we need to pass in the id now to get access to this id what we can do is just use request dot parents dot id with this we have access to the id of whatever is passed through it so we are passing the document id in the url of the route itself because we don't have access to request dot body over here now what am i going to do well find by id i'm just going to fetch it so this is going to be a constant document and then just return this document easy enough now again i'll go to my document repository and i will create the get function for our content as well so let's copy this get route because it's going to be very similar let's paste it here then we are going to call this get document by id then we want the token and also the id of the document document then we are going to do get but here we are not going to have docs slash me we are going to have doc at id because that's the route right document and this will make sure that we have access to request dot params dot id this is basically request dot parameter that this is like what parameter is passed to it i call it slug same thing then we will pass in the header the token because we have the auth middleware then the case 200 but here we don't have a list of document we just have a single document so for that what are we going to do well simple enough it's much simpler than what we have done before we'll just remove all the for loops and stuff also remove all of this and here we are just going to have response dot body and we'll pass it in as the data as well you can see this looks much much better document model dot from json dress dot body because this will return to us a single body we have used find by id not find this will return to us a list but this will return just a single document because ids are unique in mongo db we have the default one as well but here i don't want to throw this error what i want to say instead is that this document doesn't exist please try again later that's the only possible conclusion for us because if the user goes to this route let's say 44 then we want to tell them that yeah this route doesn't even exist in our mongo db or it's not accessible to you but accessible to someone else correct or it's not accessible to you but accessible to someone else correct but that's not the feature we are looking forward to we are just saying that this document does not exist in the entire app so we are just going to throw an error when we throw an error it goes to the catch block and here we are anyways having the error model created so here i'm just throwing this document does not exist that's it and here let's add another one please create a new one this sounds much much better right now we can go to the document screen and here we will call this function in the init state because whenever our application reloads we want it to show that's when init state also loads up right so here i'm going to create the function called fetch document data now i'm going to copy this function go down here i have fetch document data and here it's going to be asynchronous now the first thing we need to do is get the error model and start displaying it so here i'm going to have error model error model is equal to await ref and i need access to ref so i have to and we already have that because we have a consumer state consumer state and now i just realized why do we use error model here when we also have to use it later on when using quill controller because the content of our application will also change correct whenever we type something it will start auto saving it and it will store to the database even then the content will also change so we need it there as well so instead of creating it like this i'm going to create it as a variable in this class so i'm just going to have error model like this but it will initially be null correct so that we can distinguish that the data has come or not otherwise we'll get late initialization error now we can do await ref dot read document repository provider dot get document by id then we need to pass in the token ref dot read what is our token well first of all the user provider which can't be null then the token and then the document id which is widget dot id simple we know all of this now we have access to error model and we're not creating a new one so make sure you remove that because if you put this it will create a new variable of local called error model we don't want that we want to set it to this global variable now here we are going to check if error model dot data is not equal to null so i'm making sure error model is not null because here error model will get some value so error model will definitely not be nullier but error model dot data can be null so if it's not null then what do we do if there is no null that means that means we have successfully got the document model that means the correct document and the data so what we can do is just use title controller dot text is equal to error model dot data dot title this might be null might not be accessible here but you can just use as document model and wrap it with a parenthesis so that it automatically identifies and then later on you can use any of the function correct so i'm just going to do that and i'm also going to call the set state function if i call the set state function it will rebuild the widget and after rebuilding it it will show us the current proper title so if i restart my application let's see over here i'm still getting title document and i just realized why this is not working i have to remove this actually let's just go to the local os 3000 and now you can see title document showing up which is the updated title if i click over here it's showing title document as well if i refresh it again it's showing title document that means this part is now working we've successfully got the data now the next part and obviously before going to the next part let's try it out again if i restart my browser title document correct and if i go to the local os 3000 we have seen that already it updates the title that's pretty good anyway so this is the document and we have done all of that now the next part is whenever we write over here we do the collaborative editing part and implement the autosave functionality for that we need to jump right into sockets and we'll start off by understanding what really sockets are how are we going to use it in our application and well just writing the code for it it's pretty simple let's go so let's start off by understanding how sockets work i have my own diagram here so let's start off with the diagram here so i have my client server here again a basic backtoback client and server model so whenever the client sends some information it's usually only then the server can send information that's how http request works that's how we've been making our rest apis work right we we tell them please send us data server sends us the data but in sockets what happens is client says yeah i want a connection then the server keeps on giving the connection and then whenever we again tell the client that yeah some data has changed server keeps sending that if we set an interval server will keep doing that and you can do it as many types as you want and it's very quick as well sockets are designed for this purpose itself it's it's kind of like a wrapper around around http not really but you can consider it that way it has it is http but with more features which is real time so whenever we get some data it's going to be real time and it will keep on sending the data to us every bit of information so if the client suppose says yeah i want to start listening to it so client said i want to listen the server will send out the data whenever some data changes we can make sure that server sends it back to them correct but how and why are we using sockets for like multiple users for example we have client over here suppose this is another client and they're all attached to the same document so we have three clients who are attached to the same document for example this is my ios phone this is my web and this is my android phone they're all connected to the same document so first of all we need to make sure that they are connected to the same document only then will the sockets work and they are also obviously having the same server which is our custom server but since they've joined the same document id we have to make sure that socket joins their id they all have their own sockets correct so we need to make sure the sockets join their id and after which if this client the web client tells yeah there is some change please send this to all the user the server will send it here here and here if it was http and if web send the server request server would send it to only this part only back to the client but with sockets we can make sure that every client gets that information if there is a change we can broadcast it to all three of them right but what if i want to send it to only two of them or only to the ones that are there in the room or only to the ones that are not there in the room well you obviously wouldn't want that but what if you want to do that well there are many options on that and we're going to look into it socket provides all of that to us but i hope the simple explanation was clear if there are three clients if we use http and if one client sends some data to the server it will only be sent back to that user it won't be sent to everyone in that room correct but with socket we can send it to everyone now how are we going to connect to socket well for that we are going to have socket io client this is from the client and from the server side both you can see that we are sending from the client and we are getting from the server as well so we are going to use socket client on both the sides on with flutter we are going to use this and with node.js we've already installed it socket io 2.3.0 this is very important 2.3.0 as i've already mentioned it to you you can see here port of awesome now javascript node.js library socket io client version 2.01 to version 3.03 in dart we need to use them as i've used 2.3.0 but there's another problem with this when i use socket io client 2.0.0 i couldn't connect to my server there was some issue from uh i don't know from where and i'm not even sure why i got i couldn't get it working but when i lowered down the version it started working so i'm going to use that version you can try with 2.0.0 if it works for you then great if it doesn't then simply go to your pubspec.yml file add this dependency but here it will be the version 1.0.2 make sure flutterpub get is run i'm going to close this dart compiler clear it off and now i'm going to create an instance of this socket io client now i can't just go on and create that instance in the document screen well first of all it's about keeping the business logic away and second part is that what if i want to use it in some other screen as well for example this document screen has some collaborative editing but i want to use that in other screen as and when i expand the app i won't i won't be able to create instances of the socket io client again and again because socket io client doesn't for some reason uh accept that so we want to make sure that one single instance of socket io client revolves around our entire app so to do that we are going to go over here in a library folder and create clients we'll have our first client called socket client dot dart and how are we going to make sure that single instance remains throughout the class for that we are going to use singleton design pattern so here we are going to have a class of socket client then we are going to have socket and we are going to import it not from dart io so let's import it again but from socket io client let's remove dot io and i'm going to use it as io instead so that there is no confusion so i'm going to have io dot socket which can be nullable socket then we are going to have a static instance of socket client that we can pass from our function then here we are going to create an uh uh socket socket client uh private constructor how are we going to do that socket client dot internal will make sure our constructor here is private and cannot be initialized now i'm going to give this socket the value so it's going to be socket is equal to io dot io that's how you connect to a uri and then you need to pass in the url so for us it's very simple it's just going to be host correct now we can have string dynamic and a map that's what it requires also here let's import our host so this is how the connection is going to be done we need to configure the socket socket and then we just need to call socket dot connect and it will connect also this has to be nonnullable now here i need to pass in some important functions for example transports and this will be web socket we need the transportation through the web socket and then we need auto connect set to false we don't want it to auto connect right we've always wanted us to connect it ourselves then this is the private constructor whenever you want it it will be called and it will connect and then you also need to provide the instance correct so how are we going to do that well we are just going to create a function for it static socket client get instance then we are going to check if the private variable instance is null then we want socket client dot internal we can call this in the class itself but we cannot call outside of this because socket client internal has become a private constructor like private variable so this in tanks basically means that if there is no instance and the instance is null then we want to create a socket client internal and that will make sure we connect otherwise we will return that same instance then we can return that instance from here also this will be private and it cannot be null so this is our socket client package now after having all of this done we need to go to over here and have socket repository dot dot all of our socket repository calls or socket calls are going to be here where we are going to send to the server just like we are our document repository and local storage repository now before going to the socket repository let's connect to our server as well we have connected to the client now we need to make sure we connect to the server so that we know yeah the connection between the client and the server is successful because we have passed in the correct port as well if we had not passed it there would be some error now let's go to the index.js file and here we need to require constant first of all HTTP because we want to create our socket server then we need to create a server which will be variable server equal to equal to HTTP dot create server and how are we going to create the server exactly for that we are going to go down and do app we need to create the server with the app with express so here we are going to pass in HTTP dot create server app and now we need to do the socket connection so what we are going to do is variable io is equal to require as you might have guessed socket dot io and this should make sure that io has some value but here i'm going to even call the function where we need to pass in the server which is our server you can see what we've done is required socket io and usually what we do is socket and then we store it in another variable called io which is equal to socket like this correct but now i've done a shorthand syntax for this and i've done it this way great now i can come over here below the mongoose call i'm going to do it io let me have io correctly dot on connection so whenever there the connection is made this is how we listen to the socket io calls io dot on connection so if the connection is made with our client side or with any other client then it will say yeah the connection has been made and here it will give access to the socket object using which we can send data to us client side as well so if the connection is made we'll get access to socket and with this socket we can send data to our client side now i can just type console dot log connected just to make sure that we have connected or not plus i also want to show you socket dot id this is the socket id that means every client that connects to it will have their own unique socket id and this can be accessed using this socket dot id even on the client side we have the socket client right even this has their own client id if you want to access that i'll show it to you but here first of all we are going to have socket repository which we are going to create using final and we are going to have socket client which is having a private variable which is going to be equal to socket client and you can see i cannot create a constructor on it you can see that so what i'm going to do is dot instance dot socket and it cannot be null because socket here will never be null because we are if there is no value we are not sending any value but if there is a value and this value can never be null because here we are just passing in a null check operator basically if there is no value it will run the connect command and it will connect it and if it will connect it and if there is a value then it will directly return that if you want to make sure that this socket client is used somewhere else you can just create a getter of this so we have socket client and we'll pass in the socket client also here the return data type will be socket now let's save this much and see what we're getting so i'm just going to make this socket repository call and use this socket client i'm going to call this socket repository so that i get to know if it's successful or not so i'm just going to do socket repository socket repository is equal to socket repository and i think this is pretty much it it should work because whenever i call this class this is going to get executed and the connection if it is made then it should print it out also here you can see we have some error over here io is not defined so we need to go up here and you can see we are naming it socket not io so let's name it io and save it now the connection is successful and we need to restart our app because why not then we can sign in with google now i'm logged in so i'll go to the title document and i'm going to the node server nothing really gets printed out so what i'm going to do is create a test call and show you a demo of how the test call will be made so basically uh whenever we uh let's not create a test call actually what i'm going to do is as i said it to you socket client has to join a server so that you know our socket and our whole server knows our whole application knows that this socket has joined this is in this room so that we can send some data to a particular room itself so that some clients listening to it will get so for example if there is this server as well but it's not connected to the same document as these three clients so it's connected to the server but by a different document id now we don't want the server to send the same data over here as well so how are we going to achieve that well by making sockets join a particular room so that a server can send data to a particular room so for that i'm going to create a function called join room then we are going to get the document id and then we are just going to use socket client dot emit join and then we need to pass in the document id because we want to join a particular document id that is the room id as well now i can go to the server and here instead of this call i can say socket dot on join so as i mentioned io dot on will listen socket client dot emit then we need to pass in what is the key like we are emitting join but we will have multiple calls in our application each call will have a different string so that would make it easier for us to make our application accessible right if everyone has the same name then how do we distinguish between the different requests sent so we have socket client dot emit and we are sending the document id so that we can join the room with that id so whenever there is a join we are not going to get we are not going to get the socket back here because socket instance is already there with us we're going to get the document id whatever document that we passed in over here we're going to get the same data but this doesn't necessarily have to be document id this can be data as well you can call this anything this is basically a variable and then we are creating the callback function so whenever we get this join what do we do well we are just going to use socket dot join method and join to this particular document id simple enough now i can go to my document screen and in here i am going to join the particular room so i'm going to have socket repository dot socket client actually i'm just going to have socket repository dot join room and we need to pass in widget dot id i'm going to do it at the top before even fetching the document data before because later on in our document data function we're going to make some uh i think socket calls so let's have it right at the top so whenever our web page reloads let's just join the room now if i go to this particular screen let's refresh there is a title document but we don't know anything because we've not logged it out so let's say console dot log join now i'll go to my socket repository again also restart my app and again go to the node terminal nothing really shows up and the reason it's not working is because if we go down here we still have app dot listen but our server is now this http dot create server so we need to start listening with this we'll replace the app with server and now you can see connected at port 3000 joined connection successful as well so everything now works we have done the socket joining part as well so this is connected now the next part is whenever we type something we need to send it to all the the users in this room how are we going to achieve that let's understand with the diagram again i'm going to remove all of this and let's start fresh so we are going to have our three clients suppose we will have one two and three clients then we have our server then suppose this one and let's just assume all of these documents are connected to the same document id and they are in the same room all right so now what will happen this client will send the data to the server that yeah i've changed something so whenever there is some change we are going to send this to the server this server is going to return it back let me change the color this will change this color i didn't know it will change the entire color but anyways this will change the this will send it back to all three of them unless unless we tell it not to send to this part because they've already made the change in their document we want the change to be made in this one and this one only we'll send from this one and they'll send it to everyone except the sender because this has already made the document change for example if i type over here this has already made the change in the document correct but the other two that are connected to this document haven't made the change yet so we will send the data to both of them but not this one otherwise this will also start typing over here and whenever they receive the data we'll make sure that quill we have the quill controller all right we have this quill controller for a reason this quill controller will take that data and make sure that it updates the content over here as well that's going to be very simple for us but there is a bit of logic there as well so i'll get to it very soon so how are we going to write the code for this well in the socket repository we are going to create a function we are going to have void typing so whenever the user types something we're going to get typing and this will be map string dynamic data it's going to be of the type map so whatever data we get it's going to be of the type map and we are going to send it over because we are going to convert whatever data we get in the format of map because it's going to be two things delta which is something like a format so you have text format you have uh let's say jason format there is a delta format as well with the delta format we can have multiple things right for example bullet points and all of those stuff bolding italicizing with delta format we can make sure that we can pass all of that data to the document or to the socket or to our mongo db as well so what am i going to do well socket client dot emit simple enough and then we are going to emit typing this one was joined this one is typing so you know what to put in the server right socket dot on typing then we are going to send off the data this data cannot be anything other than just one variable this can be a map or a string or an end but this has to be one variable that you're sending across since i have two variables to pass i'm converting it into a map format now i'll go to my index dot js file i'll have socket dot on typing so whenever i get the typing request we will get two things well it's just going to be data for now and whenever we get that data we are going to do socket dot broadcast this is something new now what is this broadcast broadcast basically means that the data will which we are sending to from the client to the server will be sent to everyone except the sender itself exactly what we want if this sender this is the sender then we want the data to go to everyone except the sender so that's what broadcast will do then we can have dot two which means we will send it to a particular room only if we don't add two it will send it to everyone be it like a third client as well which is not connected to the same client as these three but is some other document itself even this but this server will tell okay you didn't tell me to send it to this room so i'm sending the data to this one as well but wouldn't that be confusing right because this document doesn't even care about it so yeah here we are going to have socket dot broadcast dot two data dot room we can access objects using data dot room and this is what we are going to pass in we want to pass in the room id so that we can broadcast to a particular room and we are going to send in the data a data which is the delta so here we are going to have dot emit and we are going to have changes so these were the changes take back your data after sending it across again i'll do it on the socket repository part what am i going to do well i'm going to create a change listener we have emitted here but for the first time we are sending some data from the server to the client side you can see these arrows we are sending from the data from the server to the client side so this client side has to listen to it as well so we are going to have void change listener then we are going to well have a function here we are going to have socket client dot on changes what is the name here changes so we are going to have changes and then we will pass in the data but what data do we do need to pass in well we don't need to pass in anything basically we will send in a function which will return the map whatever data we get here it's going to return that same data so that it can be accessed in our ui file and make the changes over there because we need to compose right so whatever data we get here we need to add that to the quill document we can't access the quill document from our socket repository so what we're going to do is accept the function function of map string dynamic call that function and we are going to send that function across which is data so basically whenever we get any changes we are going to get this data we are going to call this function which has data map in it and we're going to pass that out so if we call this change listener in our in its state in the document screen let's do that here we are going to have socket repository dot change listener and you can see we have something known as p0 which is basically data so whenever we add change listener we need we will pass in some data we will get some data and with this data what function do we need to run well we basically need to tell controller right now the controller has some value so right now what i'm going to do is make this nullable also remove the final call here so basically this controller i'm going to give it some value after fetching the document correct see here i'm just going to have if the data is not null then we will have controller equal to quill dot quill controller controller document okay so we need to pass in the document now what is the document going to be well it's just going to be error model dot data dot content because it is a document model dot content dot is empty so if it's empty if the content is empty what do we want because this document cannot accept and like it cannot accept empty document created from the delta so here we will just pass in an empty document but if the data is not empty then we need to create this document from that delta and then how are we going to create the delta well we are going to create the delta from document dot from the json file not document sorry we are going to create the delta from json and we are going to pass in the json which is error model dot data dot content i hope that was clear enough and you can see even selection is needed so selection is going to be constant text selection dot collapsed and we will pass in the offset as zero so here we are basically checking if the data is not null then the title controller text should be this and then we will set in the value of quill controller to be this so if the content is not empty right now it is empty so we will pass in a document which is empty but if it is not empty then we will pass in document from delta and we are going to create delta from the json file and json and we are going to pass in the content but this content we are sure that it's json of delta is because we are going to store it that way again now in the change listener that we wanted to work on we are just going to use controller dot compose so whenever we get some data we want to compose it right we want to make sure that controller can update the document and now after this we don't need to call set state because compose within itself calls notify listeners with notify listeners it will notify this quill controller also here you need to pass in that it's not null but before that we need to make a connect correction that if the quill controller quill let's say controller is not equal to null then but if it is null then we want to return a scaffold with the body as the loader as the loader also here it will be a constant scaffold we can go at the bottom pass in nonnullable now because here if it is null then we are going to return a loader now we can go back to the top here and compose it we know that it will refresh the document itself not the entire widget so we are saved there as well now here in the delta it will be delta dot from and this will be quill dot delta dot from json and then we will pass in the data which is going to be data at delta that's how we will send in the information when we create that function you will get to know but basically this is how our data is going to look like as i said it's going to have two properties delta and room so delta is over here now the text selection is going to be controller dot selection and if it is null then we want to use our own value constant text selection dot collapse offset zero and the source here is going to be change source dot remote this is going to be very important in our application also here we'll pass in quill this is going to be very essential for our application i'll let you know why but basically we've composed this now we have quill dot change source dot remote this can be local as well but this will be remote i'll tell you why when we create now the typing function so now how do we listen to the changes in our document so whenever i type how do we how do i listen to it well what you can do is whenever we fetch the document after that we can just have controller dot document dot changes dot listen and you can see as easy as it gets whenever there is a change in our document we are listening to it and we have access to the event and this event is a tuple which gives us delta delta and a change source delta the first delta is going to be the delta telling us the entire new controller document so this is the entire content of the document then we have second which is the changes that are made from the previous part basically this is the entire document if i type like this and then i again type this you can see this is the entire content of the document so it will every time so it will every time there is a change delta the first delta in this tuple will give us this entire part but the second delta will give us only this s which is the change that is made and third is the chain source so what is the source that had the chain is it local if it is local that means that we have typed it over here correct so we have type but if it's remote when is it going to be remote whenever we have composed this so it's going to be composition from this change listener so whenever we send data from here to our server which will send it over here we can compose this data and send in remote that means that the document will change again right so here we are composing it and when we compose it the document will again change because this content over here will change that means this function will be triggered again because document.changes.listen i mean it won't happen on this document but what if we have our second browser as well we are listening there we are listening there what we did was suppose let me just bring it up i'm going to bring it up like this suppose i have localhost 3000 here as well i'll bring both of them together here so suppose both of them are linked to the same file now if i'd make the change over here let's say a then it will change over here as well correct that's how our logic works right now but when it changes over here this document will get notified that yeah this has changed this will get triggered then this will again send it to a server server will again send it to all the clients that are connected which means this one and this one will also get the a then again the loop will happen this will send it across over here this will send it across over here like this and by just pressing one key of a we have gotten an infinite loop now to escape that we have this chain source so if the chain source is remote we have passed in over here if this is remote that means we have got it from this part that means we just have to return from this document we don't have to make any changes we don't have to send anything to the server again but if it is local then we want to send it to the server so let's add that logic here well first of all we need to check if the data dot item let me get this event so event dot item three is equal to quill dot change source dot local if it is local then only we have to send it to the server so we'll have map string dynamic map is equal to this then we can have a delta property and in this delta property we can pass in event dot item two now why are we passing item two as i said item two will get you the changed part we don't always want to get the whole uh you can say whole text over here because what if our paragraph gets like suppose a thousand characters long we don't always want to refresh thousand characters when we just type one character right if i if suppose this is thousand characters i type this a over here q over here it will rebuild this entire part why do i do that instead with compose what we can do if you just go up here you can see compose will make sure that it will take all the item tools basically all the deltas that are changed it will compose them with the existing deltas then we are going to pass in the room and the room is going to be widget dot id and then we are going to second it across so for that we have already created our function socket repository dot typing and we'll pass in our map as the data after sending this i can go to my dart i can restart now you can see i'm logged in so if i go to this document but before going to this document what i'm going to do is create a new window altogether where i can test this app again but since i'm already logged in from the same device it will think that i'm logged in so i'm just going to go in the just guest mode i can't go in the incognito mode because uh the cookies will be disabled there i don't want to disable them and i can't so i'll have localhost 3000 again i'll have to log in over here and make sure to log in with the same account that you had registered earlier on the google cloud platform and i'm logged in you can see there are no documents over here because i'm using it for the first time now what i'm going to do is create a new document i'm going to make sure this doc this user also gets to the same document now i can type a you can see the change is there now if you want to see it real time i can come over here let me minimize this out minimize this also and here if i type let's say a i'm getting all of it if i type in here if i bold it out italicize it underline it convert it to a code everything seems to be working so our part here is done but what if i refresh my application you can see it's empty right now but if i refresh this also it's going to be empty that just means we haven't started the auto save feature now to start the auto save feature what we are going to do is create a function for it here in our socket repository and then finally call it so we are just going to have void auto save then here we are going to get the delta so that we can tell what we need to do otherwise what we can do is the same map string dynamic technique so we can have map string dynamic data and we can do socket client dot emit save and pass in this data all right now we need to handle this in the index.js file so what are we going to do here we are going to have socket dot on save so whenever there is a save call what are we going to do well we are going to get the access to the data and here we are going to call the function which we are going to create outside of this so we are going to have constant save data is easy equal to async we're going to pass in the data to this function as well now why am i creating this extra function because well first of all i don't want to put asynchronous over here another thing it just looks cleaner here i'm going to have well let document is equal to await and we are going to call document dot find by id to save the data obviously what i'm going to do well i'm just going to find the id i'm going to find the document so i'll have delta data dot delta that is going to be the name of our content and actually here it's going to be document id because i want to find the document by its id so this will be data dot document id then we will have document dot content is equal to data dot delta then we will do document is equal to await document dot save now if you're wondering if you could have done find by id and update yes you could have done but i wanted to show you the other way you can use find by id and update and it should work just fine anyway we have data dot doc id data dot delta and there is going to be only two elements just like this one you know this had data dot this typing one has data dot content this is has data dot delta if you want you can name this data dot content as well and it should just work fine but make sure to make the appropriate changes later on now we are just going to call the save data function and we are going to pass in the data why have i not created http request for it or the or the restful api for it well that's because what if you want to show like saving or saved feature here we don't have that in our application but what if you want to show that right so you can just put io dot 2 call over here basically io dot 2 call will send it to everyone including the user itself that yeah we have made some change this has been saved socket dot broadcast 2 will send it to everyone except the sender io dot 2 will send it to everyone including the sender and if you wanted to send it to only the sender then it will be socket dot 2 or just socket it should just work but i'm not going to send anything that simple now i'm going to go to the socket repository i don't even have an on auto save listener call i'll just go to the document screen now when do i want to auto save and how will the auto save feature work well i'm just going to check my document that in every two seconds i'm going to send an auto save request auto save request that yeah it's been two seconds now let's just update the document two seconds update the document if you want you can make sure to update the document in as much time as you want five seconds ten seconds one second 500 milliseconds whatever you wish to it just depends on how many calls you want to make to the server i think two is fine it will take user to take two seconds to just go from here and then click on back so i think it's a pretty good thing so here i'm just going to well leave this part i'm going to come here i'm not going to put it in any function because if i put it in fetch document data then it will only run when it's fetching otherwise in this listen function which is basically kind of a stream if i put it over here you can see this is a stream subscription if i put it over here then whenever the user types only then will the auto save feature work we don't want that we want it to work even if the user doesn't type anything so we will have socket repository dot auto save and then we want to pass in our map what is our map going to be well it's going to consist of three things and you can see set cannot be typed so let's pass in string comma dynamic just to tell it that this is not a set this is a map all right so what is the first thing delta what is the delta going to be how am i going to retrieve the delta now i don't want delta of the changes that are made i want the delta of the entire screen to get that i can make use of the controller given by quill dot document dot two delta then i want the room id so let's see what i saved the room id as room again so i can just pass in room widget dot id and that's pretty much it it should start saving but you can see this will run only once only when the nh state function is run which is in the start i don't want to save it in the start obviously so when do how do i make it run every two seconds so i'm going to wrap it with timer dot periodic this timer is given by flutter itself so we have timer dot periodic then we need to pass in a duration how many times i mean in how many seconds should it run so it will be constant duration pass in the seconds as two and then we are going to have timer and this is going to be a function so i'm just going to copy this paste it down here and save it now you can see every two seconds this timer will run if you want you can make this one second if you want you can make this millisecond of 500 every five milliseconds it will run but i don't want that i want two seconds so let's start now obviously we need to restart so i'm going to restart from both the sides localhost 3000 over here also localhost 3000 and you can see there is some error in our server data dot delta cannot set properties of null content so let's go over here and see what's happening the problem is it couldn't find the proper id this is document dot find by id data dot doc id but we don't have anything data dot doc id we have data dot room so we are going to do data dot room now if we restart you can see it should work so let me restart my browser even this should restart all right so now i'm going to make changes in title document i'm going to share the link you know this button is not working so i'm going to make this work as well right now i'm going to send hi you can see h is now there i is also there so hey hey what's up and all of this stuff now i'm going to add the bullet points as well so and this will also contribute to the bullet points also bold one italicize one and change the color of one great now let's try to go back so when i click here i should go back so how can i make that feature work well we need to go to the document screen and whenever this button is clicked so this is the button we just need to wrap it with a widget known as gesture detectors we don't want we don't want ink well because i don't want the splash effect we'll have on tap and we'll just do route master dot route master dot of context dot replace the current screen with slash so that we go back to the slash part right and then we just need to restart when i restart this the content should all be the same but it's not restarting for us there is some bug with this i don't know what but whenever i try to do it with two browsers it always does this so i'm just going to close this i'm going to restart my browser i'm going to log in and see you again we should get our data saved and if it's not saved then we've made some mistake in our code all right so have my browsers ready two browsers i logged out of one so let me sign in again now i'll just come over here okay so now if i go to this title document you can see all of the data that we wrote is saved if i take this send it across it's still saved and if i click over here i go back to this slash now i just need to make this share work how is that going to work so whenever we click on this it should copy this to our clipboard so we have clipboard dot set data clipboard data and then we can pass in the dot then as well so what data do we need to pass in here well it's going to be text and what text do we want well hdb well basically all of this is this entire thing so let's just remove this hdb then we will have dollar widget dot id then we have dot then and after dot then we are just going to have scaffold messenger dot of context dot show snack bar then we are going to display the snack bar that yeah this has been copied link copied also put a constant there and then just well this is pretty much it let's try to restart if i you know click on the share you can see link copied if i paste it over here is the same link and i come back over here if suppose i go on a different untitled document and try to type there the same is not happening over here but i share the link away from here to here i mean of course it didn't get copied but over here if i go you can see we go back to the assa assa assa all that part great so our docs google docs is working all the displaying part is working and even it's responsive sometimes not using media query we can get you responsive websites as well so this was it for the tutorial thank you so much for watching see you in the next video you
