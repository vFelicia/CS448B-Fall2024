With timestamps:

00:00 - Dr R is back with another Advanced
00:02 - JavaScript course he'll teach you how to
00:05 - build a virtual environment entirely
00:07 - from the ground up get ready to use
00:09 - basic HTML CSS and JavaScript to craft a
00:12 - world you can use in all kinds of
00:14 - projects he'll show you how to fill the
00:16 - world with self-driving cars but you can
00:18 - fill it with anything you
00:20 - [Music]
00:28 - like
00:46 - hi and welcome to phase two of the
00:48 - self-driving car course a virtual
00:52 - world this is actually a standalone so
00:55 - you don't need to have watched phase one
00:57 - to follow along we'll start building
01:00 - this world from scratch using some basic
01:02 - HTML CSS and a lot of JavaScript and
01:06 - whether you'll fill it with self-driving
01:08 - cars or something else is completely up
01:11 - to you the focus will be on generating
01:13 - the world itself and I'll only integrate
01:16 - the self-driving car code at the end I
01:19 - made this course to prepare for phase
01:21 - three understanding AI where we'll focus
01:25 - on neural networks and other AI
01:27 - techniques I hope that by the end of
01:29 - face three you'll understand why neural
01:32 - networks work why hidden layers are
01:34 - needed and things like that but for that
01:37 - we need this fancy world to generate
01:39 - complex scenarios the one we had earlier
01:42 - is too simple to teach you all that so
01:46 - if neural networks is what you're
01:47 - waiting for be patient and enjoy phase
01:51 - two meanwhile you learn a lot of things
01:53 - in this one as well a set of skills I
01:55 - really benefited from during my PhD and
01:58 - my time at Microsoft and I'm sure
02:00 - they'll be useful to you as well in your
02:03 - career we first learn about graphs and
02:06 - I'll show you how to implement the
02:07 - spatial graph from scratch I'll also
02:10 - show you how to make an editor for it as
02:13 - well it will have a dynamic viewport so
02:15 - we can pan and zoom to edit graphs of
02:18 - virtually any size when building this
02:21 - editor I'll explain the mathematics and
02:23 - logic behind good user interfaces in
02:26 - modern pieces of software and we
02:28 - Implement something similar
02:30 - ourselves then we use geometry to
02:32 - generate the road borders around the
02:35 - graph I'll teach you about polygons and
02:37 - some useful operations using them we'll
02:40 - apply the same techniques in a slightly
02:42 - different way to generate the buildings
02:44 - and the trees as well we spent two
02:47 - lessons on these because I want to show
02:49 - you how to implement this 3D look as
02:51 - well they're not really 3D models just a
02:54 - little bit of math that gives that
02:56 - illusion then we Implement a way to add
02:59 - markings to the road this will make
03:02 - phase three even more interesting
03:03 - because we'll need to teach the car to
03:05 - respect all kind of traffic roles as
03:07 - well now we'll focus on making this
03:10 - world editor a pleasure to use
03:12 - minimizing the number of clicks and
03:14 - maximizing the amount of autogenerated
03:16 - content but I'll also make videos on how
03:19 - to load real world data from open street
03:21 - map so the car can drive in your city as
03:24 - well this is yansu the card just passed
03:27 - by kelia University of applied science
03:30 - that's the Vila campus where I'm
03:32 - currently filming and it started off at
03:34 - tiar the other campus and now it's
03:37 - heading toward City Center where I've
03:38 - marked some it companies on the map
03:42 - looks like the car is heading towards
03:43 - Arbon out which is on the other side of
03:45 - town I'll add a link to this demo in the
03:48 - description check it out it's a good way
03:50 - to learn about yansu if you plan to come
03:52 - study with us you'll find many useful
03:55 - links there as
03:56 - well oh and I'll also make a video for
03:59 - creating this mini map it really helps
04:02 - when the world is big and the mini map
04:04 - was probably the most requested feature
04:06 - I got in phase one I've tried answering
04:08 - to all requests when making this but
04:10 - there's still a few I'm leaving for
04:12 - phase three they fit better
04:14 - there now to be clear this project is
04:18 - complex especially because we're going
04:20 - to code everything ourselves and not use
04:22 - libraries it won't be easy to wrap our
04:25 - minds around at all but I divided it
04:27 - into components lesson that I believe
04:30 - are easy to understand on their own I
04:33 - consider this course to be at an
04:34 - intermediate level but I do encourage
04:36 - beginners to give it a shot as well to
04:38 - get an idea of what a more complex
04:41 - project looks like I explain everything
04:43 - the best I can and if you have
04:45 - difficulties just ask in the comments or
04:47 - on my Discord the prerequisites are high
04:50 - school math and if you have trouble with
04:53 - that this playlist will have you covered
04:55 - you also need to know some JavaScript if
04:58 - you completed phase one you'll have no
05:00 - problems here but if you need to brush
05:02 - up on it I explained some tricky
05:04 - JavaScript syntax in these sketches so
05:07 - check them out if needed I hope you're
05:09 - excited and thanks for being patient
05:11 - this long can't believe it took me over
05:14 - a year to make this but I wanted to do
05:16 - it justice since you liked phase one so
05:18 - much now let's begin I'm going to code
05:22 - everything using visual studio code and
05:25 - we'll begin somewhere in an empty folder
05:28 - on your computer
05:30 - and let's create our first file here
05:33 - it's going to be
05:35 - index
05:37 - HTML and we begin with basic HTML we
05:42 - write the doc type here and the HTML
05:47 - page
05:48 - structure in the head I'm going to add a
05:53 - title and the title of this will be the
05:56 - world
05:58 - editor this will make it appear in the
06:01 - browser Tab and let's make it also
06:05 - visible by typing it inside of the body
06:09 - in an H1
06:12 - tag like this now most of our
06:16 - functionality is going to be built on
06:18 - top of an HTML canvas element so let's
06:21 - add canvas element with ID my
06:26 - canvas onto the page as well
06:30 - now let's open this in our
06:32 - browser I'm going to be using Google
06:35 - Chrome and remember to open the
06:38 - developer tools as well it's really
06:40 - important to know if you make any
06:42 - mistakes the errors will pop up here now
06:46 - you can see here the title of the page
06:48 - is correct and the H1 tag is here but
06:52 - the canvas is not really visible it is
06:55 - there if you press this button right
06:58 - here you can find it on the page but
07:00 - it's transparent and we can see it so
07:04 - let's add some styles to this page I'm
07:07 - going to go here below the
07:10 - title and Link a CSS file like this
07:16 - called Styles
07:20 - CSS we're going to create this file
07:24 - here Styles
07:27 - CSS and for the bot
07:30 - I'm going to give it a black background
07:36 - color and I'm going to align everything
07:39 - to Center like this the H1 I'm going to
07:44 - give it a white color so that we can
07:47 - read it on the black background and set
07:50 - its font to harriel I think it looks
07:54 - better and finally the canvas I'm going
07:58 - to give it a back color that we can see
08:01 - on this black background and I'm just
08:03 - going to use this shade of green that I
08:08 - like let's save this and refresh and it
08:12 - now looks like this I'm going to make
08:14 - the canvas bigger and we're going to use
08:17 - JavaScript for
08:18 - that in index
08:22 - HTML we'll write JavaScript code here at
08:26 - the end of the body we begin with script
08:32 - tag and I'm going to set my canvas width
08:36 - to 600 and my canvas
08:40 - height also to
08:43 - 600 because it fits my screen well
08:46 - pretty much but you can choose other
08:47 - values if you want now we're going to be
08:51 - drawing on this canvas and for that
08:53 - we're going to need to access the 2D
08:57 - drawing context of this canvas like
09:01 - cell and we will draw a graph let's
09:06 - pretend that we have a way to define a
09:09 - graph like
09:12 - so and that the graph has a way to draw
09:15 - itself on a given context so we're going
09:19 - to need to implement these
09:21 - functionalities the graph itself and the
09:23 - draw method and we'll do that in a
09:27 - separate Javascript file
09:30 - I'm going to include it here we're going
09:33 - to place JavaScript files in a folder
09:35 - called JS but this is going to be a
09:38 - pretty big project so we need to think
09:40 - about code structure early
09:42 - on and I'm going to place the graph
09:46 - itself in a subfolder called math and
09:49 - then graph JS like
09:55 - so so let's create the Js folder
10:01 - first and inside of this JS folder we're
10:04 - going to create math another folder and
10:09 - inside of math we create our Javascript
10:13 - file graph. JS graphs are data
10:17 - structures made from a set of nodes also
10:20 - called vertices and a set of edges or
10:22 - links that represent relationships
10:25 - between the nodes like in a social
10:27 - network a graph can store which users
10:29 - are friends these relationships are
10:32 - bidirectional here but in other
10:34 - applications like here on YouTube I may
10:37 - be subscribed to you but you may not be
10:39 - subscribed to me there is very much to
10:42 - say about graphs like we already use
10:45 - graphs in Phase One when implementing
10:47 - the neural network there the links had
10:49 - weights so we were dealing with a
10:51 - weighted graph and there was a link
10:53 - between every input and every output so
10:56 - we used the Matrix to represent those
10:58 - relationships in memory but now we're
11:00 - going to implement a new type of graph
11:02 - called a geometric or spatial graph
11:05 - where nodes are not just abstract things
11:07 - they will represent Road intersections
11:10 - or places where the road geometry
11:12 - changes like this you can see there are
11:14 - not so many links here really so a
11:17 - matrix would be mostly empty and not the
11:19 - right choice in this case when
11:22 - implementing a spatial graph the proper
11:24 - way would be to separate the node
11:26 - metadata the points from the connections
11:29 - themselves but I think it makes things
11:31 - too complicated and since this whole
11:33 - project revolves around geometry I will
11:35 - simply say these are the points and they
11:38 - will be connected by segments with one
11:41 - point at each end so a bit
11:43 - unconventional here but I think it
11:45 - simplifies things in our case now let's
11:48 - code one of these graphs in JavaScript
11:51 - it's going to be a simple
11:54 - class and each Constructor is going to
11:58 - have two parameters we build a graph
12:01 - using
12:05 - points and
12:08 - segments I initialize them to empty
12:11 - arrays so that you can create an empty
12:13 - graph as
12:14 - well now let's store these parameters
12:19 - as
12:26 - attributes like so and in Implement our
12:29 - draw method that takes the canvas
12:32 - context as a
12:34 - parameter and I'm just going to Loop
12:37 - through all of the segments that we
12:41 - have and tell each of those segments to
12:45 - draw themselves on the canvas context we
12:48 - don't have these segment objects yet but
12:51 - they will be there and they will have
12:53 - the same kind of structure as the graph
12:55 - has it's important to be consistent with
12:59 - these things and then I'm going to do
13:02 - the same thing for the
13:05 - points like
13:07 - so and uh I draw the points after the
13:12 - segments because I don't want the
13:14 - segment lines to be on top of the points
13:17 - it doesn't look
13:19 - good now let's Implement these segment
13:22 - and point objects in index HTML I'm
13:26 - going to copy this line
13:30 - and I'm going to place these in a folder
13:32 - called Primitives points and segments
13:35 - are primitive objects so let's write
13:39 - here
13:42 - Primitives point
13:46 - and
13:49 - Primitives segment like this and inside
13:53 - of this JavaScript folder the main one
13:57 - here not inside of math
13:59 - I'm going to create a new folder called
14:03 - Primitives so it's next to the math
14:06 - folder here and in it we create a new
14:11 - file Point JS it's also going to be a
14:16 - very
14:17 - simple class Constructor takes in X and
14:23 - Y as parameters where we want the point
14:25 - to be and we set these paramet
14:30 - values as class attributes like so so
14:34 - that the object knows where it is pretty
14:37 - much and then in the draw method on the
14:40 - given context I'm also going to pass two
14:43 - more parameters to style these points a
14:45 - little bit the first one is going to be
14:48 - a size maybe 18 pixels and a color I'm
14:53 - just going to use
14:55 - black we're going to draw the points as
14:57 - circles and the circles need a radius
15:01 - I'm going to just calculate that as half
15:04 - of whatever this size is and we begin a
15:09 - path set the fill style to this color
15:15 - that we have in the parameter list and
15:18 - use the arc method of the drawing
15:21 - context and draw this at this X and this
15:26 - y we pass the radius next and the last
15:30 - two parameters specify that we want a
15:33 - full circle so starting at
15:36 - 0° and ending at
15:40 - 360° but we have to write this using
15:43 - radians that's just how the function
15:45 - works so
15:47 - 360° is 2 pi
15:51 - radians now we fill and we're done with
15:54 - this point for now let's do the same
15:57 - thing with the segment so create a new
16:00 - file called segment
16:05 - JS our segment
16:08 - class The Constructor will have points
16:12 - this time P1 and
16:14 - P2 let's save these as attributes of the
16:22 - class and Implement our draw
16:25 - method given a context and again I'm
16:29 - going to pass two parameters here as
16:31 - well the width the line withd how thick
16:35 - we want the segment to be I'm just going
16:37 - to give it a default value of two and a
16:41 - color again I will set it to Black like
16:46 - so and we begin a
16:52 - path we set the line width to the given
16:56 - width and we set the stroke style this
17:00 - time to the given color we move to the
17:05 - first
17:07 - point
17:09 - p1x P1 Y and now we're going to copy
17:14 - this
17:16 - line and line
17:22 - to P2 X P2
17:27 - Y and then we
17:30 - stroke and we're done with these core
17:33 - functionalities the only thing left to
17:35 - do is test so make sure all your files
17:39 - are saved go back to index HTML and
17:43 - let's pass some actual points to this
17:45 - graph I'm going to go
17:48 - here above where we defined the graph
17:51 - and
17:53 - say P1 is a new
17:57 - point at
17:59 - 200 200
18:01 - pixels let's copy this few more
18:05 - times and have here P2 P3 and P4 maybe
18:11 - P2 is going to be at 500 200
18:16 - then 400 400 and 100 300 and let's pass
18:24 - these as an array to our graph here as
18:27 - well
18:30 - this will be the points parameter of the
18:33 - graph and the segments will be the
18:35 - second parameter but we can actually
18:37 - test now already so save the file
18:40 - refresh the page and there's our graph
18:44 - it has the four different points this is
18:48 - the
18:49 - 200200 this is the 500 200 uh keep in
18:54 - mind that 0 0 is this top left corner so
18:57 - 5 100 200 like
19:01 - so let's add segments as well I'm going
19:05 - to go here and
19:07 - say S1 is a new
19:11 - segment between P1 and P2 and let's copy
19:16 - this two more times maybe S2 and S3
19:22 - between let's just link P1 for now P1
19:26 - with P3 and P1 with P4 and pass these as
19:33 - the second attribute
19:36 - here save and refresh and we can see now
19:41 - the segments as well let's connect these
19:44 - to as
19:45 - well so I'm going to copy this as
19:51 - S4 between P2 and P3 and passing s for
19:59 - here like
20:02 - so good now this is a static structure
20:07 - we can't really edit it in any way and
20:10 - the next thing we'll do is add some
20:11 - functionality to add points remove
20:14 - points add segments remove segments and
20:16 - so on we'll do that in a very basic Way
20:20 - by adding here buttons that just add
20:23 - some of those elements on the screen I
20:26 - want to teach it like this because it's
20:27 - how interfaces were made 30 years ago
20:31 - and then we're going to make it modern I
20:34 - want you to see how things have changed
20:36 - since
20:37 - then so let's go up here and below our
20:43 - canvas element I'm going to define a div
20:47 - with an idea of
20:49 - controls and this is going to contain
20:52 - some buttons that we can press to do
20:55 - operations with our graph the first
20:58 - first
20:59 - button on click it will call a function
21:03 - called add random
21:07 - Point let's call this button add Point
21:11 - like this give it the
21:14 - label and let's implement this add
21:17 - random Point function next I'm going to
21:19 - just make it here on top of this script
21:24 - these functions will go away at some
21:25 - point we just need them to develop the
21:28 - core functionality so I'm not going to
21:31 - worry about the code structure too much
21:34 - and add
21:36 - random
21:40 - point it's going to tell the
21:44 - graph to add a
21:47 - point the graph object will have this
21:51 - functionality so let's pass here as the
21:55 - point a new point and give it random
21:59 - coordinates so X is going to be random
22:04 - and I'm going to scale this by the width
22:08 - of the canvas so that the value is not
22:12 - between zero and one what this gives but
22:15 - between 0 and 600
22:17 - pixels and the height in the same
22:25 - way now to see this point after it was
22:29 - added we have to refresh the canvas we
22:32 - do that by clearing the whole canvas
22:36 - starting get 0 0 top left corner and
22:41 - with
22:43 - height bottom right corner and then we
22:46 - tell the graph to draw itself again so
22:49 - graph draw on the context so let's
22:54 - implement this ad Point function real
22:56 - quick we are going to go to graph
23:02 - JS and here below the Constructor we say
23:07 - add point a given
23:10 - point and we just take the points
23:15 - attribute of the class and
23:17 - push the given point like so now let's
23:21 - refresh and when we press this button
23:25 - you can see a new point was added there
23:28 - you can try pressing it multiple times
23:30 - and it's going to work pretty much
23:32 - always unless we run out of memory but
23:35 - uh that's not going to happen anytime
23:37 - soon now there is one situation that I
23:40 - want to take care of I don't want to
23:43 - have two points at the same location it
23:46 - makes no sense points are identified by
23:49 - X and Y and if you have two of them with
23:52 - the same X and Y then that's the same
23:54 - point so let's see how we do that
23:59 - we're going to need a function that
24:01 - checks if the graph already contains a
24:05 - point
24:07 - right and I'm going to write it like so
24:11 - using the array find method which finds
24:17 - inside of these
24:19 - points a
24:21 - point that
24:23 - equals the given
24:26 - point like so what happens here is that
24:29 - the find Loops through all of the points
24:32 - here and let's call them p and then
24:35 - Returns the one that equals point and if
24:38 - it doesn't find that point then it's
24:40 - going to return nothing so something and
24:44 - nothing will also correspond to true and
24:47 - false in Boolean logic and we're going
24:50 - to use this as such it's just how
24:53 - JavaScript
24:54 - works so equals here here we need to
24:59 - implement as a method to the point class
25:02 - we need to check if p is equal to the
25:05 - point somehow so inside of the point
25:09 - class I'm going to
25:11 - implement
25:13 - equals
25:16 - point and return if this x is equal to
25:21 - point x and this Y is equal to point Y
25:27 - like so
25:28 - this will only be true if point and this
25:32 - are the same and now we could go here
25:36 - and check to see if the graph contains
25:39 - the point before adding it or we could
25:43 - add the new method to the graph that
25:47 - tries to add a
25:49 - point and then maybe we monitor here the
25:53 - success did it succeed to add a point or
25:58 - not let's log this in the
26:02 - console right here so we can go inside
26:07 - of graph
26:09 - JS here and try add
26:16 - point is going to check if this point is
26:21 - not part of the graph at the
26:26 - moment then we
26:28 - add the
26:29 - point and notice here how I'm reusing
26:33 - the method we defined earlier then we
26:36 - also return
26:38 - true it was a success
26:42 - otherwise we return false like this
26:46 - let's save a refresh and when we press
26:50 - this add
26:51 - Point same thing as before happens
26:54 - pretty much but we always get here this
26:58 - true and that's because it's really
27:00 - unlikely to randomly generate another
27:03 - point on top of an existing one but to
27:07 - test we should force that to happen
27:10 - somehow so I'm going to go here in index
27:14 - HTML copy this entire function
27:18 - here paste it here in the console and
27:22 - instead of having random I'm going to
27:25 - write 0.5
27:28 - and
27:31 - 0.5 this means that I'm going to
27:34 - overwrite this function so that it
27:37 - generates the points always in the
27:39 - middle of the screen so if we press
27:41 - multiple times on that button the same
27:43 - point will come again and again to
27:45 - overwrite we have to press enter
27:49 - now and let's press this point again
27:52 - once and this is the point in the middle
27:56 - of the screen and when we try adding
27:58 - another one we get our false as well so
28:02 - it wasn't a
28:04 - success and the number of points in our
28:08 - graph
28:10 - graph
28:12 - points
28:17 - 18 doesn't
28:19 - change now we have a way to add points
28:22 - to our graph let's add segments as
28:26 - well we're going going to go here and
28:29 - copy this button and call the other one
28:34 - add
28:37 - segment and the function will be add
28:42 - random
28:43 - segment and we Define that function
28:48 - here at random
28:51 - segment this will work a little bit
28:54 - differently it first gets the points
28:57 - that we want to connect and then creates
29:00 - the segment let's get these points again
29:04 - at
29:06 - random by using floor of random
29:12 - times the number of
29:15 - points floor makes sure that we have an
29:18 - integer value and let's copy this for
29:23 - another index two
29:25 - different points and then tell the graph
29:30 - to add the
29:32 - segment a new
29:35 - segment between the
29:39 - points at index one and
29:43 - points at the index
29:46 - to like this now to see any changes
29:50 - after we press this button we also need
29:53 - this thing right here clearing and
29:55 - redrawing the graph
29:58 - so let's save this and go to graph JS to
30:01 - implement this add segment
30:04 - method we go
30:08 - here below the points section and let's
30:13 - Implement add
30:16 - segment let's call it seg and it's going
30:19 - to take the segments of the graph and
30:24 - push this new one at the end let's save
30:28 - this refresh and now when we press add
30:33 - segment it added a segment here and now
30:38 - I pressed again and nothing
30:41 - happened let's try
30:44 - again
30:45 - nothing nothing
30:48 - nothing what's wrong can you figure out
30:51 - what the problem
30:52 - is pause the video now and try to figure
30:56 - out the answer for you yourself or just
30:59 - listen to me carry
31:02 - on the issue is that here where we are
31:06 - adding these
31:08 - segments sometimes index one and index
31:11 - two could be the same so we create a
31:14 - segment from one point to itself we
31:17 - could check here and
31:21 - say success is
31:24 - false and then if index one is different
31:29 - than index
31:31 - two success is true let's also add the
31:36 - segment only in that case because a
31:39 - segment from one point and to itself
31:41 - doesn't really make sense and let's log
31:44 - this success here as
31:48 - well refresh and when we press add
31:51 - segment we get a true and we see the
31:54 - segment when it appears but
31:58 - sometimes we get the false when we try
32:01 - to link the same point to
32:03 - itself and if we press more
32:07 - times
32:08 - oh we got the true now but I didn't see
32:12 - any
32:13 - change what happened try to figure out
32:17 - what happened pause the video and now
32:20 - I'm going to tell you the
32:22 - answer
32:24 - so turns out it's possible that you add
32:28 - the same segment multiple times as well
32:32 - like maybe now this segment was just
32:36 - added again let's actually see here in
32:39 - the console the
32:44 - segments and the last segment
32:48 - between 200 200 and 100 300 I think
32:54 - that's this one here
32:57 - yeah and you can see they're exactly the
33:00 - same let's try adding few more
33:03 - segments even though they are going to
33:07 - be copies of
33:11 - themselves and now we see here 18
33:14 - segments but we can really only count 1
33:17 - 2 3 4 5 six so it doesn't make sense to
33:22 - have more than six segments here we
33:25 - wouldn't be able to see them and we
33:27 - wouldn't be able to tell that there are
33:28 - duplicates
33:31 - there this last one actually is the same
33:35 - that we had previously but in Reverse P1
33:40 - is P2 and vice versa we're going to need
33:44 - to handle that case as well so let's go
33:48 - back here and convert this into a
33:53 - Triad segment as well and move that to
33:57 - the success and have the same kind of
34:01 - structure as here pretty much let's go
34:04 - to the graph and implement this
34:09 - method
34:10 - try add
34:14 - segment and it's going to be very
34:17 - similar to the try add point but we
34:20 - first check if this contains the segment
34:24 - and if it doesn't then and we add
34:31 - segment and return
34:34 - true and here we return
34:38 - false like so this contain segment is
34:42 - going to
34:44 - be here and what we
34:50 - do is again use defined method on the
34:56 - segments this
34:58 - time I'm going to Loop through them
35:00 - using this s and find the one that
35:04 - equals the given segment like so we're
35:08 - going to need to implement equals
35:10 - functionality for the segment as well so
35:15 - here
35:17 - equals is going to
35:20 - be
35:23 - return P1
35:25 - equals seg do
35:28 - P1 and
35:31 - P2
35:33 - equals seg do
35:37 - P2 but we also want the opposite check
35:41 - if the points are flipped so we're going
35:43 - to do
35:49 - or P1 equals seg P2 and P2 equal seg
35:55 - P1 now if we we refresh and add a few
35:59 - segments we can see there false
36:01 - appearing many
36:03 - times eventually one of them will
36:08 - work okay so now we have all six of them
36:11 - here and when we go in the console and
36:14 - type graph segments they are indeed six
36:18 - so it works but before we move on this
36:22 - line of code is quite complicated here
36:24 - checking so many things and it's always
36:27 - good to try to simplify two segments are
36:30 - the same if they include the same
36:33 - points so we could make a helper method
36:37 - here called
36:39 - include
36:42 - point and return this P1
36:47 - equals point or this P2 equals point so
36:53 - now we have a way to check if the
36:55 - segment includes a point and two
36:58 - segments are equal
37:03 - if this
37:06 - includes P1 and this
37:11 - includes P2 it makes sense and if you
37:15 - save and
37:23 - refresh it still works but it's nicer to
37:27 - read in this way and you'll see that
37:29 - later we'll need this includes for other
37:32 - reasons as well now this part here where
37:35 - we check to see if the indices are
37:38 - different we could incorporate it part
37:41 - of the Triad segment so try to see if
37:45 - the points are equal and if they are it
37:48 - won't add the segment so we could
37:52 - actually have success here defined as so
37:58 - and we don't need to use let here we can
38:01 - use const again so try add segment now
38:06 - is going to not only check if it doesn't
38:10 - contain the segment but
38:13 - also
38:16 - if P1 is not
38:20 - equal
38:22 - B2 let's save refresh and try adding
38:28 - segments
38:33 - again and we still have six
38:37 - here great now let's go to index HTML
38:41 - and have a way to remove these segments
38:44 - also I'm going to copy this and say here
38:50 - remove a segment at random and
38:55 - remove segment
38:57 - like this and the function for removing
39:01 - is going to be like
39:07 - this I'm going to first check to see if
39:10 - there are any segments so
39:13 - if graph segments
39:16 - length is zero you can also have a
39:20 - methods added to the graph that check if
39:23 - it has segments or Returns the point
39:25 - count if if you want to do a really
39:27 - really proper job but this is Javascript
39:30 - then I don't bother too
39:33 - much so here I'm going to
39:37 - log no segments just as a warning that
39:41 - no bother trying to remove something
39:43 - there's nothing to
39:45 - remove and return and otherwise we are
39:49 - here where we get a random
39:53 - index from the segments this
40:00 - time and remove
40:05 - segment the one at that
40:09 - index like so we also need to copy this
40:14 - code
40:16 - here otherwise we won't see the change
40:19 - after it
40:20 - happens and now let's implement this
40:23 - remove
40:25 - segment I'm going to go here and say
40:29 - remove
40:36 - segment
40:46 - splice so splice removes elements at the
40:50 - given index here we get the index of
40:53 - this segment and I want to remove just
40:56 - one element the segment itself now you
41:00 - can add many other methods here maybe
41:03 - removing the segment by the index we
41:05 - already had the index here to begin with
41:09 - or try to remove a segment similar as
41:12 - those other ones but they won't be
41:14 - needed in our project and I'm not going
41:16 - to over engineer
41:18 - this refresh and remove
41:22 - segment okay okay okay
41:26 - okay all good and if we try one more
41:30 - time no segments written in the console
41:34 - great let's remove the points as well
41:38 - for that I'm going to add another button
41:43 - here remove
41:45 - random
41:48 - Point
41:50 - remove
41:51 - point and let's copy this remove random
41:56 - segment like this and have here remove
42:03 - random
42:05 - point if
42:06 - graph points are empty no
42:12 - points index is going to come from the
42:15 - points this
42:17 - time
42:20 - remove
42:22 - point
42:24 - graph points and let's implement the
42:28 - function remove point in the graph file
42:32 - let's copy this remove segment and put
42:34 - it here in the points section and rename
42:38 - it to
42:39 - remove point the given point and it's
42:44 - going to look inside of the points array
42:49 - and
42:49 - supplies the points index
42:53 - of point would have been faster to just
42:57 - rewrite this but I wanted to show you
43:00 - how similar these functions are now
43:03 - let's save this refresh and when we
43:06 - remove a
43:08 - point we can see it's
43:11 - gone but I'm removing all the points and
43:16 - and now we also get that message there
43:18 - but the segments are still there and
43:21 - that makes no sense how can you have
43:23 - segments between points if there are
43:26 - points so let's make it so that when we
43:29 - remove a point it also removes all the
43:32 - segments that contain this
43:36 - point so the New Logic will be
43:40 - here let's first get some
43:46 - segments with point the given
43:50 - point and then for each segment of this
43:57 - small
43:58 - list we remove the
44:02 - segment like so using the method that we
44:06 - have defined
44:08 - earlier so we need to implement this get
44:11 - segments with point and I'm going to do
44:16 - that here in the segments
44:20 - section get segments with
44:24 - point we we start off with an empty
44:30 - array and now look through all the
44:34 - segments of this
44:40 - graph
44:43 - if the segment includes this
44:48 - point then we add it to this array and
44:53 - at the end here we just return
44:56 - the array of segments that contain this
45:00 - point simple enough let's refresh and
45:04 - remove point and you can see that the
45:08 - segments connected to it are also
45:10 - gone let's try adding some
45:14 - points adding some random
45:20 - segments question for you given a number
45:23 - of points how many segments can there be
45:27 - between them like in this
45:30 - case we have 17 points how many segments
45:34 - can there be here let me know in the
45:37 - comments and now we can also try
45:39 - removing some
45:41 - segments removing some
45:44 - points good everything seems to work but
45:47 - one more useful button to have here
45:50 - would be to clear everything to remove
45:54 - everything I'm going to implement the
45:56 - method for that here it's really easy
46:00 - let's say this will be
46:02 - dispose of the
46:04 - graph and I'm just going to set the
46:07 - points and the segments to empty setting
46:11 - the length attribute like this doesn't
46:14 - generate new objects for them so it
46:16 - reuses the same array object and in
46:20 - index
46:21 - HTML let's copy this and say remove
46:25 - remove all remove all and the remove all
46:37 - function call graph
46:41 - dispose and we need to copy this again
46:44 - if we want to see the update
46:48 - refresh and it works now you could build
46:52 - an interface like this maybe when adding
46:55 - point it wouldn't just be a random point
46:57 - but have there some inputs for the X and
47:00 - the Y adding the segment maybe it can
47:04 - have a drop down for the first point and
47:07 - the second Point removing again a drop
47:10 - down with all the segments and all the
47:12 - points and that interface would work but
47:15 - it would have so many clicks and so much
47:18 - use of the keyboard that nobody would
47:21 - use it
47:22 - nowadays I will teach you how to make a
47:25 - modern interface
47:26 - so we won't need these buttons
47:29 - here let's remove them actually I will
47:33 - keep the control section here because we
47:36 - might use it later but no need for these
47:41 - functions at all all that was important
47:44 - was to have here all these useful
47:47 - methods inside of the graph
47:50 - Class A good user interface is one that
47:53 - minimizes the number of clicks and
47:55 - keyboard input I'll teach you how to
47:57 - build a graph editor that does that now
48:00 - in other courses I've considered mobile
48:02 - as well but in this series I'll focus on
48:05 - the mouse because I think it's the best
48:07 - tool when creating graphs it has two
48:09 - easy to press buttons we can use for
48:11 - adding dragging and removing
48:14 - points we'll implement the editor step
48:16 - by step adding new features when needed
48:19 - and polishing existing ones until we're
48:21 - happy with the final logic at least I'll
48:24 - be happy with it but if you're not I
48:26 - hope you'll get the skills to edit
48:28 - things in or out just the way you want
48:31 - we will Define our graph editor here
48:35 - after we have the graph and we
48:40 - initialize it like
48:43 - so new graph
48:46 - editor passing the canvas it's going to
48:50 - need that for event listeners and the
48:52 - graph and it's going to also be doing
48:55 - all the drawing on the canvas so
48:58 - actually we don't need this call anymore
49:02 - it's going to be handled by the graph
49:04 - editor and the editor is going to be
49:07 - very interactive it's going to change
49:08 - all the time depending on our Mouse
49:10 - moves and the simple way to implement
49:13 - this is using an animation Loop so a
49:17 - function that we call here and start to
49:20 - animate and it's going to be really
49:23 - simple all it does
49:26 - is it
49:28 - clears the canvas because it's going to
49:31 - redraw again and again so clearing
49:34 - starting at 0 0 and all the way to the
49:38 - canvas width and canvas height and then
49:42 - we'll have our graph
49:45 - editor display itself it knows where the
49:49 - canvas is because it has it here as a
49:52 - parameter and finally we call Quest
49:56 - animation
49:59 - frame and pass this animate call again
50:03 - and again and again it's going to be
50:05 - kind of a recursive call where the
50:08 - browser will try to recall this function
50:12 - 60 times per
50:14 - second so we're ready to implement this
50:17 - graph editor and we'll do that in a new
50:22 - file I'm just going to Define it here in
50:26 - the main JavaScript folder so it's going
50:29 - to be called graph
50:33 - editor and injs create a new file graph
50:40 - editor
50:42 - JS the class is a simple
50:46 - class and the
50:49 - Constructor will get the canvas and the
50:52 - graph as parameters now let's set these
50:56 - values as
50:58 - attributes so that the editor doesn't
51:00 - forget
51:03 - them and let's have a reference to the
51:07 - canvas drawing context as well defined
51:10 - here as a class attribute so that we
51:13 - have easy access to it like
51:16 - so and the display
51:20 - method for now let's just have it draw
51:24 - the graph
51:25 - on this
51:27 - context save the file refresh the page
51:31 - and it looks pretty much the same as
51:33 - before but now if you go to the console
51:37 - and you type for
51:38 - example
51:40 - p1.x is equal to
51:44 - 400 and press enter you're going to see
51:47 - immediately that point jump to a new
51:49 - position because it is rendering again
51:52 - and again and again all the time you
51:54 - just don't see it so we are ready to
51:56 - start adding event listeners for the
52:00 - mouse action I'm going to create a
52:04 - private function private method for this
52:07 - here so it starts with the hashtag and
52:10 - then add event
52:13 - listeners and this method is going to be
52:16 - here below the
52:19 - Constructor the first event listener we
52:21 - add to our
52:24 - canvas
52:25 - is going to be for Mouse
52:29 - down and we get the information from
52:32 - this event and write the arrow function
52:35 - so this Arrow function let's close it
52:39 - here and now implement the body the
52:42 - first thing we'll do is get the mouse
52:44 - location from the mouse down event from
52:47 - The Click so Mouse is going to be a new
52:53 - point and the information is inside of
52:56 - this
52:57 - EVT do offset X and EVT offset y are the
53:04 - XY location of the click now with this
53:07 - point we can just tell the graph to add
53:12 - the point and the code should work so
53:16 - let's refresh and click
53:18 - somewhere and there you go points added
53:22 - anywhere we want them so it's an
53:25 - improvement over the randomness we had
53:27 - previously now one thing that we'll
53:30 - really need in this editor is the
53:32 - ability to select a point and let's
53:36 - Implement that so that the last point
53:39 - that we add is also
53:42 - selected we'll have a more complex Logic
53:45 - for the selection later but now it's
53:48 - just like that to test so I'm passing
53:51 - here this selected is equal to the mouse
53:54 - and this selected will be attribute of
53:58 - the class initially null it can be null
54:02 - if we don't select anything and then in
54:05 - the display
54:06 - here let's draw it separately in a
54:10 - different way so if we do have a
54:13 - selected point I'm going to tell this
54:16 - point to draw
54:19 - itself under the context but this is
54:22 - just going to draw it on top of itself
54:24 - already it's already there from this
54:26 - graph draw so I want to specify a little
54:31 - bit different properties for this
54:33 - selected point and let's give it an
54:37 - outline we don't have this functionality
54:40 - yet so let's save this go to our Point
54:44 - primitive here and in the draw method
54:47 - add an outline here now the more
54:50 - parameters you add here the more
54:54 - difficult is going to be to remember
54:55 - their order so I like to group these as
54:59 - an object like
55:01 - this and now you could pass them in any
55:05 - order you want you just need to
55:08 - specify these properties the name of
55:12 - these properties here like what we just
55:15 - did so if you want to pass this without
55:19 - these options we write here equal to an
55:23 - empty object and then you can just
55:25 - called Draw as we did before in the
55:27 - graph now this outline I'm just going to
55:31 - go here below and if we do have an
55:36 - outline We Begin another
55:39 - path set the line width of two for
55:45 - example and let's give it a stroke style
55:49 - of
55:51 - yellow and draw a new arc at X and Y but
55:57 - our radius will be a little bit smaller
55:59 - I don't want it to be exactly the
56:01 - outline I want it to be kind of inward I
56:04 - like the look of that so let's say
56:06 - radius time
56:09 - 0.6 and again 0 2 pi for drawing a
56:15 - complete circle and again if you want
56:18 - this selected point to look different
56:22 - just make it different it's your code
56:24 - now now let's save this
56:27 - refresh and now when we click somewhere
56:31 - we're also going to have that point that
56:34 - we just added selected and this is how
56:37 - it looks like and the next thing we do
56:40 - in our logic is when we click on a point
56:44 - that is already existing I don't want to
56:48 - create a new point on it or close to it
56:52 - so I actually want to select that point
56:55 - and at the moment this doesn't happen it
56:57 - just creates a new point on top of it
57:00 - pretty much so let's see how we do that
57:04 - we first have to figure out what point
57:06 - are we hovering
57:08 - over so going back to our graph editor
57:13 - in this mouse down event listener after
57:16 - we have our Mouse
57:17 - location we get the hovered Point by
57:23 - looking at the nearest Point so we're
57:26 - going to need the function get nearest
57:29 - point from the mouse from all the graph
57:35 - points like this and then if this
57:38 - hovered Point
57:41 - exists we are going to select it like
57:47 - so and now I'm going to return so the
57:51 - code doesn't go here anymore for adding
57:53 - a new point and selecting it it just
57:58 - select let's define hover also in the
58:01 - Constructor here same as
58:04 - selected hovert initially null and what
58:08 - we need to do is implement this get
58:10 - nearest Point somewhere and what I like
58:14 - to do is create a new file and Link it
58:20 - here in index HTML it's going to be also
58:24 - part of math and we will call this new
58:28 - file
58:30 - utils JS this will have utility
58:33 - functions mostly math functions that
58:36 - will help us during our
58:38 - project so in math create a new file
58:42 - called utils
58:45 - JS and the function for getting the
58:49 - nearest
58:51 - point to a location from a set of points
58:54 - point is going to be a basic minimum
58:58 - search so we look for the minimum
59:02 - distance from our location to all the
59:05 - points and select the point with the
59:07 - minimum
59:08 - distance we do that by initializing this
59:11 - minimum distance to a very large value
59:14 - like this and the nearest Point let's
59:17 - just have it null in the beginning and
59:21 - then we Loop through all the points
59:25 - in the array like this and calculate the
59:30 - distance
59:32 - between that point and the location that
59:36 - we have here as a
59:38 - parameter if this distance was found to
59:41 - be less than our supposed minimum
59:46 - distance then minimum distance becomes
59:50 - distance and we record the point with
59:54 - this minimum distance as well in this
59:56 - nearest attribute then we go here at the
59:59 - bottom and just return
60:02 - nearest and what we still need to do is
60:05 - implement this distance function between
60:07 - two points and this is really easy we've
60:10 - done it countless times I have a special
60:13 - video about it it uses the Pythagorean
60:17 - theorem and we just return the Hot
60:21 - between the difference on X and the
60:24 - refence on y between these two points
60:27 - let's
60:28 - refresh and now when we
60:31 - click you see it selects a point it
60:35 - always selects the nearest point when we
60:38 - click somewhere but we can click
60:41 - anywhere really and maybe we would like
60:45 - to have a limit so that we are close to
60:48 - that point to actually select it because
60:50 - at the moment we can't add new points
60:53 - anymore we're always is just
60:55 - selecting so what we'll do is when we
60:58 - look for the nearest point we'll check
61:01 - also if the point is under a threshold
61:04 - so this third parameter threshold let's
61:08 - have it 10 I like to have it just a
61:10 - little bit bigger than the points so
61:13 - that you can click almost there and it's
61:15 - still going to work and then here our if
61:19 - is going to check and the distance is
61:22 - less than the threshold then it does
61:24 - everything let's save refresh and now
61:28 - when we click here it adds new points
61:31 - but when we are close to something it
61:33 - selects that point and you can still get
61:36 - nearby points if you are outside of that
61:39 - threshold but if you're close enough you
61:42 - actually select it play around with this
61:46 - and let me know what you think what
61:47 - should the proper threshold
61:50 - be now our get nearest Point function
61:54 - here should have this threshold as an
61:58 - optional value really
62:01 - because the name implies it's going to
62:03 - find the nearest no matter what so the
62:06 - threshold here I'm going to Define it to
62:09 - be this very large value that we can use
62:14 - and then in graph
62:16 - editor when we get the nearest point I'm
62:19 - going to pass here 10 like so now
62:23 - refresh the page and the code will work
62:27 - as before pretty much what would be
62:30 - really nice is to know if I'm going to
62:33 - click here will this add a new point or
62:37 - will it select the other one are we
62:39 - inside of the threshold or not and we
62:42 - should know this before doing it
62:45 - otherwise we get surprised by what
62:48 - happens so visualizing the intent is
62:52 - important I think and that's that's what
62:54 - we're going to do
62:56 - next we are going to need to define a
62:59 - new event listener for Mouse move this
63:02 - time so Mouse
63:05 - move and on every Mouse move we are just
63:09 - going to take this hovered Point like
63:13 - so and here in the display we will
63:17 - visualize this hovered Point as well in
63:20 - another
63:21 - way let's copy these lines
63:25 - and say if
63:30 - hovered draw the hovered one as well and
63:34 - this one let's emphasize it with the F
63:37 - this time so F set to true and inside of
63:42 - the point we pass now this fill as
63:47 - well by default it's
63:50 - false and at the end here I'm going to
63:54 - check if we do want this point to have a
63:57 - special kind of fill We Begin The Path
64:01 - and we draw a new
64:04 - arc again at The X and Y and the radius
64:08 - I'm going to have it smaller this
64:11 - time full
64:13 - circle and let's remember also a fill
64:17 - style I'm going to set it to yellow and
64:20 - instead of stroke I'm going to call fill
64:25 - let's save this and refresh and now when
64:28 - you move the mouse over the point you're
64:30 - going to see the highlighted point so
64:34 - you know if you see that that once you
64:36 - click it's going to select it and if
64:39 - you're close but you don't see that and
64:42 - you're going to click it's going to
64:44 - create the new point so the interface is
64:47 - not surprising anymore it's much more
64:49 - useful for the
64:51 - user I don't like this point I think
64:53 - it's too close to that one so I would
64:55 - like to remove it somehow and I'm going
64:58 - to implement removing of points by right
65:01 - clicking on the
65:04 - points we go to our graph
65:07 - editor in our Mouse down here and
65:11 - actually we don't need this hovered
65:14 - anymore because it's already happening
65:16 - here on Mouse move so we could remove it
65:22 - entirely and nothing will change
65:25 - everything will still
65:27 - work and to implement the right click
65:30 - we're going to go here at the top and
65:32 - check if we press the right click or not
65:35 - that information is also part of the
65:38 - event and we do if event button is
65:44 - two this means right click and I write
65:49 - here a comment because I always forget
65:51 - which is which then if if this
65:58 - hovered I'm going to say graph remove
66:03 - point this hovered like so and the logic
66:08 - from here is if we have
66:12 - pressed
66:14 - zero which is left
66:17 - click now you maybe know why I'm
66:20 - confused about these numbers sometimes
66:23 - let's save
66:24 - refresh and now when we right
66:27 - click something happened you actually
66:31 - don't see this but I have this menu
66:34 - appearing on the
66:36 - canvas and let's get rid of that so to
66:40 - get rid of this rightclick menu I'm
66:43 - going to add here another event
66:49 - listener for context
66:53 - menu
66:54 - and the function I'm going to pass is
66:58 - going to call prevent default this is
67:01 - just going to prevent that menu from
67:02 - coming up now let's test again clicking
67:06 - on the same
67:11 - point it removed the
67:14 - segments connected to that point but not
67:16 - the point oh also the point but for some
67:21 - reason the point is still
67:24 - visible until I move my mouse away from
67:27 - it and that's because when we remove the
67:31 - point here from the graph we still have
67:34 - selected and hovered there you could do
67:38 - here a more complex code or you could
67:42 - reactor this saying this hashtag remove
67:48 - point and now go somewhere here below
67:51 - and Implement a private method for
67:53 - remove
67:56 - point that calls the same thing we had
68:00 - before the method we implemented for the
68:03 - graph also sets hovered to
68:08 - n and selected to know to get the proper
68:12 - interface let's refresh and now when I
68:16 - remove it really goes away and no weird
68:20 - artifacts
68:22 - coming
68:26 - now if you test this and for example
68:29 - remove this
68:30 - point you see it also unselected that
68:34 - point any point that is selected will be
68:38 - unselected because we just said this
68:41 - should be null but maybe we want that
68:43 - point to stay selected not make the user
68:45 - have to work again if they want to
68:47 - select it again for some reason so we
68:50 - can easily check for that here and say
68:53 - that if this
68:55 - selected is that
69:00 - point then we Mark selected as null we
69:04 - don't have a selected Point anymore
69:05 - because we removed the one that was
69:08 - selected
69:12 - refresh remove that and it's still
69:15 - selected but if we remove this one then
69:18 - it goes away and no weird artifacts are
69:20 - there okay great does this work
69:24 - in all possible
69:27 - situations well one thing that you'll
69:29 - notice is if you add a point here and
69:33 - right click on it
69:36 - now it doesn't remove it it doesn't go
69:39 - away even after I move the mouse and
69:43 - that's because we're removing points
69:45 - that we hover
69:47 - over our hover is updated here on Mouse
69:52 - move but when we add a new point it's
69:56 - not yet assigned to that point even
69:58 - though our Mouse is hovering over it so
70:02 - we could do that
70:06 - here like
70:09 - so and now creating a point and right
70:13 - clicking on it will indeed remove that
70:16 - point as well small things like this are
70:19 - what makes a interface not just good but
70:22 - really good and people will choose you
70:24 - over somebody else making one now
70:28 - correcting points is possible already if
70:32 - we want this point to be a little bit
70:33 - more to the right we just remove it and
70:36 - recreate it a little bit more to the
70:38 - right but dragging would make this much
70:42 - easier to work with so let's add drag
70:45 - functionality next and in Mouse
70:50 - down when we hover over some something
70:54 - here on left click I want to also enable
70:57 - dragging for that
70:59 - point so let's say this dragging is true
71:05 - and this is going to be another
71:07 - attribute
71:09 - here false by
71:12 - default and as we
71:15 - move if we are
71:21 - dragging the selected point
71:25 - X and Y are going to come from our Mouse
71:28 - location like
71:31 - this now we also want to release of the
71:34 - points somehow and I'm going to do that
71:37 - with another event listener here let's
71:39 - just copy the context menu and this will
71:42 - be for Mouse up like
71:46 - this and what we do in it
71:50 - is this
71:52 - dragging is false and we don't really
71:55 - use this event here so we can remove it
72:00 - now refresh and if I'm going to click
72:02 - and
72:04 - drag this works so I can add points I
72:08 - can drag
72:12 - points and it works just as
72:16 - expected so far we've figured out the
72:19 - points and it's time to move on to the
72:21 - segments as well create new segments and
72:24 - when building roads a very common thing
72:29 - what you have to do is generate the
72:32 - shape of the road like this and you
72:35 - really get a lot of help if the
72:36 - interface is going to generate a new
72:39 - segment between the current point and
72:43 - this new point that you're going to add
72:46 - at each time so let's do
72:50 - that we are going to go to this Mouse
72:53 - down event listener and here when adding
72:57 - a new point just before settings
73:00 - selected to that point we're going to
73:02 - use the previous value of selected if it
73:06 - exists and add a segment between that
73:08 - and the mouse location so I'm going to
73:12 - do this
73:14 - if there is a
73:18 - selected let's try to add the
73:22 - segment
73:24 - new
73:25 - segment selected at The Mouse and the
73:29 - reason why I have Trad segment here is
73:32 - so that I handle things like clicking on
73:34 - the same point multiple times or
73:37 - clicking between the points multiple
73:39 - times which would otherwise add a lot of
73:42 - segments that are overlapping or
73:44 - invisible or something like that now
73:48 - let's save refresh and if I start to
73:52 - click you can see those segments added
73:56 - there just
73:58 - fine but maybe I would also like to add
74:02 - the segment between things that exist
74:05 - already like these
74:09 - ones so let's copy this
74:14 - code also here when just selecting
74:17 - points so before this selected is set to
74:21 - what is hovered we
74:25 - try to add a new segment between this
74:28 - selected and this hovered this
74:31 - time let's save refresh and now I'm
74:35 - going to select this and
74:39 - this seems to work now if I'm going to
74:43 - continue like
74:45 - this at some point I have a problem
74:48 - because maybe I want to connect these
74:51 - two points next
74:54 - and clicking this point or this point is
74:58 - going to add a new segment here
75:00 - something I don't want and the reason
75:03 - for that is I have no way of unselecting
75:07 - points at the
75:08 - moment so if we would unselect points we
75:12 - would unselect this one before clicking
75:15 - on this one and then this weird segment
75:18 - wouldn't happen here so maybe we go up
75:22 - here when we right click and if we are
75:25 - not hovering over
75:27 - anything we do an
75:30 - else this selected is
75:34 - no okay and now I'm just going to try to
75:38 - recreate a little bit that click
75:41 - somewhere else with the right click and
75:44 - now I can click on this point and then
75:47 - this point and get the segment that I
75:49 - want now the code that we have here is
75:53 - pretty much the same this part and this
75:57 - part is identical I'm going to implement
76:01 - a method for selecting a point so this
76:06 - is going to be
76:09 - here a private method select point and
76:13 - in it I'm going to copy one of
76:21 - these and pass this point properly so
76:24 - instead of mouse point
76:27 - point and now up here this duplicate
76:32 - from here we just remove and say this
76:36 - select this
76:39 - hovered and here we
76:42 - say this
76:44 - select
76:47 - Mouse and everything should work the
76:49 - same as before selecting points and
76:53 - selecting
76:57 - points connecting
77:01 - them everything pretty
77:03 - much one thing that we did before for
77:07 - the points this intent showing what
77:10 - happens when you click somewhere would
77:12 - be really useful for the segments as
77:16 - well like now we have this point
77:18 - selected and if we would click here with
77:20 - the left click it will connect them but
77:23 - maybe we forget or maybe the user is new
77:26 - and doesn't want that connection to
77:29 - happen but he does it anyway then this
77:33 - is going to be annoying because what the
77:35 - user has to do now to undo everything is
77:39 - pretty much remove this point and now
77:42 - recreate oh no it selected that one
77:46 - because it was already
77:48 - selected remove this point click it here
77:52 - and connected to
77:54 - that so maybe the user just wanted to
77:57 - select this like so without having
78:00 - anything else selected but if they don't
78:02 - see the intent that having this point
78:06 - here selected is going to create a new
78:09 - segment here then they don't know that
78:12 - they may be surprised by what happens
78:14 - and then a lot of work is
78:16 - needed so I will show this intent of
78:20 - creating a new segment somehow
78:23 - for that we need access to where the
78:26 - mouse is in the drawing section here so
78:31 - I'm going to take the mouse from Mouse
78:34 - move here and make it as an attribute of
78:39 - the class so this mouse is going to be
78:42 - that and I'm going to put this dot in
78:46 - front of everywhere we use Mouse pretty
78:49 - much and actually the mouse that we C
78:52 - calculate here as well it's not needed
78:55 - because we move the mouse before
78:59 - pressing it so we're always going to
79:01 - have it more or less and here this mouse
79:06 - this mouse this mouse I think this is
79:09 - all of them and let's define it here at
79:13 - the
79:14 - top and set it to n like this and with
79:19 - this mouse we can
79:21 - go in the display here before drawing
79:26 - this selected note and let's say we
79:31 - create a new
79:32 - segment from this selected to this mouse
79:37 - and draw it using the context save and
79:42 - refresh and now when we have a point
79:45 - selected you can see this line creeping
79:48 - out so it does tell us that something is
79:52 - going to happen there when you click
79:55 - here it's going to create the segment on
79:58 - that line and when you're going to click
80:01 - here I would actually like this line to
80:05 - snap to that point when I see that point
80:09 - hovered I also want this line to appear
80:12 - there as well so let's do
80:16 - that we will get our
80:21 - intent is the
80:24 - hovered if the hovered
80:27 - exists otherwise the mouse and now we
80:30 - pass here this intent instead of the
80:33 - mouse
80:38 - refresh and now you can see that intent
80:42 - jumping there but this segment that we
80:44 - are drawing here as the intent looks too
80:47 - much like the other ones so let's make
80:49 - it look like a dashed
80:51 - line I'm going to pass here
80:56 - also Dash options three and three and an
81:00 - array this means three pixels of line
81:03 - and three pixels of space and save this
81:08 - and we have to modify our segment
81:10 - primitive to know to show this as well
81:14 - and this starts to have again many
81:16 - parameters so I'm going to group them as
81:18 - an object as we did before so
81:23 - Dash by default it's going to be empty
81:27 - and we do this so that we can just draw
81:30 - the segments without passing any of
81:32 - these
81:33 - parameters now the dash
81:36 - here we set line Dash to the given Dash
81:41 - and after we do the stroke here at the
81:44 - end I like to copy this and reset the
81:48 - dash so it doesn't affect all following
81:51 - drawings many people like to use here uh
81:54 - context save and restore at the end so
81:57 - that everything gets reset but I find it
82:00 - a little bit slower on my computer now
82:03 - let's
82:08 - test and we can see that situation from
82:11 - before so anybody using this would know
82:15 - that clicking here would create that but
82:17 - if they right click and now click there
82:20 - it selects the thing with without any
82:23 - surprise
82:25 - happening so if we test this a little
82:28 - bit
82:29 - more
82:32 - aha did you spot that let's make what we
82:36 - had
82:37 - before here I wanted to actually select
82:41 - the point that I'm
82:43 - hovering and for that I did a right
82:47 - click but right click didn't unselect
82:51 - this one it it actually removed that
82:55 - point so the priorities are different
82:58 - here I would like to unselect first and
83:02 - then delete deleting is
83:05 - more troubling if you do the wrong thing
83:08 - than having a point unselected so going
83:12 - back to this graph editor I'm going to
83:15 - redo the logic here for right click
83:19 - let's remove
83:21 - it
83:27 - if it's selected we unselected else if
83:31 - we are hovering over
83:35 - something we remove the point that is
83:39 - hovered like that save and
83:48 - refresh yeah and now I can select this
83:51 - one
83:55 - even if I'm right clicking over
83:58 - something it doesn't remove it okay test
84:01 - it out let me know what do you think is
84:03 - this a good interface do you want to
84:05 - make it better how do you make it better
84:08 - what is wrong with it write in the
84:10 - comments and let's see if we can get an
84:13 - even better one to work now before
84:16 - moving on to something else I do want to
84:19 - mention a little bit about code cleanup
84:22 - here
84:23 - so this ad event listeners function is
84:26 - kind of long it doesn't fit on one page
84:30 - that's kind of the rule make it fit on
84:32 - one page so that scrolling is not needed
84:34 - when looking up logic so these event
84:37 - listeners for Mouse down Mouse move
84:40 - could be extracted as their own
84:44 - methods I'm going
84:46 - to cut everything here inside of the
84:51 - mouse down
84:52 - event listener call back and create here
84:57 - handle Mouse down private method for
85:01 - this and paste inside it the previous
85:06 - code now here instead of having
85:12 - this Anonymous function we just say
85:15 - handle Mouse down and if we save and
85:20 - refresh and click it doesn't
85:25 - work there's an error here and if we
85:28 - press here we can see where this error
85:32 - happens let's put a break point and
85:36 - click
85:38 - again and inspect this you can see this
85:44 - here is the canvas it basically points
85:49 - to the canvas but we don't want that I I
85:52 - mean the canvas doesn't have a graph the
85:56 - graph editor has a graph and when you
85:59 - exit this scope where this referred to
86:03 - the graph
86:05 - editor now this inside of this function
86:09 - refers to the Target of this event to
86:11 - the
86:12 - graph so we need to tell this function
86:15 - that this should be this and the way to
86:19 - do that in JavaScript is with bind
86:23 - bind this and in this way it will send
86:27 - this this to this
86:31 - function and it's going to work again
86:34 - save refresh and click and now when we
86:39 - hover this it's the graph editor again
86:43 - so removing the break point pressing
86:46 - display the point actually appears
86:49 - there and everything still works we do
86:53 - the same thing also for this mouse move
86:55 - so I'm just going to cut this and
86:59 - Implement handle Mouse
87:04 - move for the event paste this here and
87:09 - here let's just
87:11 - say this handle Mouse move
87:17 - bind this save refresh
87:24 - and everything still
87:31 - works this graph editor is nice but I'd
87:34 - like to make larger graphs as well and
87:36 - my screen size is not that big so I'll
87:40 - teach you how to make a viewport that
87:42 - can be zoomed and panned around to allow
87:45 - editing outside the initial region as
87:47 - well it's going to be like in Photoshop
87:49 - where you can draw like that
87:52 - then we can really make anything we want
87:55 - and it would be a shame to lose a large
87:57 - graph like that so I'll teach you how to
88:00 - save it so it doesn't disappear when we
88:02 - refresh the page now let's begin and get
88:05 - the bird's ey view of the graph we'll
88:09 - initialize the
88:12 - viewport here before the graph
88:17 - editor like
88:19 - so giving it the canvas to work
88:24 - with I will also implement this in a
88:28 - separate file next to this graph editor
88:31 - here also in the JS
88:34 - directory so let's go to
88:37 - JS and
88:40 - viewport JS this is also a
88:44 - class and the Constructor takes the
88:49 - canvas as a parameter let's store it as
88:53 - an attribute like
88:56 - so and let's get a reference to the to
89:00 - the drawing context here as
89:03 - well now the first thing we'll Implement
89:05 - is the zoom and let's have an attribute
89:09 - for this by default it's set to
89:11 - one and add event listeners to change
89:16 - the
89:17 - zoom very similar structure to what we
89:20 - did previous lay in the graph
89:24 - editor but here we'll use different
89:27 - things we're going to listen for the
89:29 - mouse wheel the wheel is going to change
89:32 - the
89:35 - zoom so let's add an event listener to
89:38 - the
89:40 - canvas for the mouse
89:43 - wheel and have a separate callback
89:47 - function called handle Mouse
89:49 - wheel and we bind it
89:52 - to this so that it knows what this
89:57 - is and let's define this handle Mouse
90:01 - wheel with an event here below and let's
90:06 - log this
90:08 - event Delta y property and see what it
90:14 - looks like in the console save refresh
90:19 - and now when you scroll upward
90:22 - you can see minus 125 appears on my
90:26 - computer and
90:29 - downwards
90:31 - 125 we're only interested in that sign
90:34 - plus or minus so I'm going to go back
90:36 - here and say the direction in which we
90:41 - are going to change our Zoom is going to
90:43 - be coming from this
90:47 - sign like this and let's update our Zoom
90:51 - with with this direction so s function
90:55 - from the math library is either 1 or
90:58 - minus one depending on if the value is
91:02 - positive or negative and let's log here
91:05 - this Zoom save refresh and now when you
91:10 - scroll up you're going to get lower and
91:13 - lower values when you scroll down you're
91:17 - going to get higher and higher values
91:19 - and I'm really only interested in this
91:22 - range from one to
91:26 - something maybe one to five I think
91:29 - that's going to be a good range to work
91:31 - with so we will disregard zero and
91:34 - negative numbers and positive ones and
91:37 - we want the zoom to
91:39 - change slower than this so not just by
91:43 - one increment each time so what we'll do
91:47 - here is I'm going to define a step how
91:51 - much much do we want the zoom to change
91:53 - in that direction maybe
91:56 - 0.1 and then here the direction we can
91:59 - multiply it by that step we can also cap
92:03 - the zoom in a specific interval by
92:06 - writing Zoom is the maximum between one
92:12 - and the minimum between five and the
92:15 - actual Zoom value it's a oneliner that
92:18 - keeps it between 1 and five so let's
92:22 - save refresh and see if it works so
92:25 - scrolling up keeps it at one and going
92:29 - down goes down until five so scrolling
92:34 - down is going to zoom out five times
92:38 - basically if that makes
92:41 - sense you could keep these as attributes
92:45 - like mean Zoom Max Zoom whatever I'm
92:47 - just going to keep it like this because
92:49 - usually you don't change these once you
92:51 - implement it and it works the way you
92:53 - want so let's remove now this console
92:56 - log from here save this file again and
92:59 - inside index HTML change the canvas
93:04 - properties based on this viewport
93:07 - information I'm going to go here after
93:11 - clearing the rectangle and save the
93:16 - state and then do a
93:18 - scale with the inverse of this viewport
93:22 - Zoom like
93:25 - this because I want to zoom out
93:28 - basically and then here restore this
93:32 - save and restore are important because
93:34 - this scale is going to be called on each
93:36 - frame so if we don't do anything about
93:38 - it it's just going to scale again and
93:40 - again and again and again on top of each
93:42 - other making some weird effect to happen
93:45 - let's save this refresh and now when we
93:49 - zoom out so I'm doing
93:54 - this yeah this seems to work just fine
93:58 - but um if you click somewhere like here
94:03 - you're going to see that the point
94:05 - doesn't come where it should come and uh
94:08 - we need to fix that the way we get the
94:12 - mouse should take into consideration the
94:14 - zoom as well so I'm going to go to
94:17 - viewport and give it away to get the
94:22 - mouse information it knows what its Zoom
94:25 - is so get
94:28 - mouse given this event information we
94:32 - return a new
94:36 - Point typically we had this offset X and
94:40 - Y but now we're going to multiply it by
94:43 - the zoom and that's going to fix the
94:47 - problem and we need to call this get
94:50 - mouse in the the graph editor where we
94:53 - need the mouse information the mouse
94:56 - location so the graph editor needs to
94:59 - know about this viewport not about the
95:02 - canvas I'm going to change the way that
95:06 - we initialize it here with the viewport
95:09 - and that means we have to go in graph
95:11 - editor JS in the Constructor here change
95:15 - this to be a viewport viewport viewport
95:18 - and the canvas which we do need is going
95:21 - to come from the
95:26 - viewport like
95:27 - that now here where we get this mouse
95:33 - information we just take
95:36 - it from this viewport get
95:41 - mouse using this event information
95:45 - refresh and now zoom out a bit and when
95:48 - we
95:49 - click it works as
95:52 - expected one thing that we should fix at
95:56 - this point is when you zoom out a lot
95:58 - like that it becomes really difficult to
96:01 - click on the points here you have to be
96:03 - very very close so this threshold here
96:07 - of 10 gets shrunk because of this zoom
96:12 - out F so you want an Adaptive threshold
96:16 - basically and you can fix that by
96:19 - multiplying here with the zoom as well
96:23 - what happens now when we refresh and
96:26 - zoom out a bit you can
96:28 - see that point starts to be
96:32 - hovered when we are closer than 10
96:35 - pixels away from it but we're not really
96:38 - hovering it we just get close to it the
96:42 - same distance that we had previously
96:44 - making it much easier to interact with
96:46 - those points but maybe we don't want
96:49 - this maybe we do want to um have zoomed
96:53 - in view like this when editing to be
96:55 - more precise and now just drag to go to
96:59 - that part of the space where the points
97:01 - are and we're going to implement drag
97:03 - also using the mouse wheel but we're
97:06 - going to click on it and drag by holding
97:09 - the mouse wheel
97:12 - so this middle button will control the
97:15 - offset of the
97:17 - viewport let's define this offset
97:22 - at the top and by default it's going to
97:24 - be Z 0 and we're going to need also a
97:31 - way to store the drag information we're
97:34 - going to be dragging the viewport and we
97:37 - need to know where we started where we
97:39 - ended and compute some kind of
97:41 - differences and add them into the
97:50 - offset
97:53 - like
97:57 - so and I'm also going to add here a way
98:01 - to know if we are actively dragging or
98:04 - not then this event listener for Mouse
98:07 - wheel we're going to copy
98:09 - it three more times so that we have one
98:13 - for
98:14 - Mouse down handle Mouse
98:20 - down
98:21 - Mouse move handle Mouse
98:26 - move and mouse up handle
98:30 - Mouse up and we Define these below here
98:35 - as
98:36 - well so handle Mouse
98:40 - down given the event it's going to first
98:44 - check is it the middle Mouse button that
98:47 - we are pressing is it this one not these
98:49 - other two because then it would
98:51 - interfere with the graph
98:53 - editor so if event button is one this is
98:59 - the middle
99:04 - button then we set the start of the drag
99:09 - to this get
99:11 - mouse EVT this get mouse will have the
99:15 - correct information no matter what the
99:17 - zoom level
99:19 - is then we also say that the drag has
99:25 - started has been
99:27 - activated now on Mouse
99:31 - move we will only do
99:35 - something if this drag is
99:39 - active and we will calculate the end
99:43 - location of the current action so the
99:46 - current Mouse location pretty much and
99:50 - I'm going to to write this in this end
99:54 - attribute
99:55 - here this get mouse EVT so start and end
100:01 - are different after the drag has started
100:03 - and you continue to move the mouse and
100:06 - from start to end that gives you the
100:08 - offset of your current drag and I'm
100:12 - going to store that offset here you just
100:15 - calculate the difference and this is
100:18 - going to use vectors the difference
100:22 - between the drag end and the drag start
100:26 - so this Vector essentially you can
100:28 - imagine it starting at drag start and
100:31 - ending at drag end it tells you how much
100:34 - the offset will change when you release
100:38 - the mouse which is the next thing that
100:41 - we'll
100:42 - do the mouse up event
100:47 - handler if we are inside of an active
100:51 - drag
100:52 - again we
100:55 - add to the existing
101:00 - offset the drag
101:05 - offset and we also reset the drag
101:08 - information here so what we have here at
101:10 - the top this drag is equal to that I'm
101:14 - just going to past it
101:15 - here like so and we need to implement
101:19 - these simple Vector operations
101:21 - here so math
101:25 - utils I'm going to go here below this
101:28 - distance and
101:30 - say add P1 and
101:35 - P2 return new point where we just add
101:40 - the X and add the Y and for subtract I'm
101:45 - just going to copy that
101:49 - subtract and put here minus
101:53 - minus and everything's going to work but
101:56 - we still need to use this offset
101:58 - somewhere so here in index
102:01 - HTML after we
102:03 - scale we are going to also
102:08 - translate viewport offset
102:12 - X viewport offset y save the file
102:18 - refresh the page and now I'm going to
102:22 - press the middle Mouse
102:24 - button move it here and release the
102:28 - middle Mouse button and when I do that
102:32 - the drag has happened but of course you
102:34 - would like to see the drag as it's
102:37 - happening so you want to get the
102:40 - cumulative offset of the current drag
102:44 - action and the stored offset information
102:48 - this works otherwise I'm now going to
102:50 - drag everything back and like this and
102:54 - like that and some interfaces do work
102:57 - like this they don't show the current
102:59 - action to keep the processor usage low
103:04 - but nowadays pretty much everybody
103:06 - expects to see what is really happening
103:09 - at a glance so I'm going to take this
103:17 - offset including the drag
103:21 - and I'm going to have the viewport
103:23 - computed for me so get offset will add
103:27 - viewport offset and the viewport drag
103:30 - offset together and here we just keep
103:33 - this so going to viewport
103:38 - JS below get mouse we will also have get
103:44 - offset which adds this
103:49 - offset the this drag offset like this
103:54 - now save this refresh and as I'm
103:57 - dragging you can see the motion like
104:02 - this and you can feel it a little bit
104:06 - lagging
104:08 - here and that's because our animation
104:12 - Loop here reenders itself pretty much 60
104:16 - frames per second but your mouse
104:18 - movement is a little bit faster than
104:20 - that so you can see the location of the
104:23 - points dragging a bit and you could get
104:26 - a faster interface update if you link
104:30 - this rendering to
104:33 - the mouse move event but I prefer to use
104:37 - this animation Loop here because at the
104:40 - end there will be things in this world
104:42 - that animate like the car movement and
104:44 - and whatever so this structure here is
104:48 - more in line with what we did in phase
104:50 - one of of the
104:53 - course now zooming out here bothers me a
104:57 - little bit because I'm very used for the
105:01 - zooming to happen from the center
105:04 - somehow not the top left corner so if my
105:07 - object is here and I'm going to zoom in
105:10 - now I expect to keep it in
105:13 - frame and it doesn't happen so we need
105:16 - to consider where the center of the
105:19 - viewport is as
105:21 - well I'm going to go to viewport JS at
105:25 - the top and above this offset let's
105:30 - get a reference to the center point of
105:34 - the canvas so half the canvas width and
105:37 - half the
105:39 - canvas
105:41 - height and now in index
105:43 - HTML before we do the scale so the
105:47 - original width and height of the canvas
105:50 - is going to
105:51 - be what it is and not affected by the
105:54 - scale we
105:57 - translate to this Center at first save
106:02 - and refresh and you'll see that things
106:05 - have moved that way by half the canvas
106:08 - width and half the canvas height so this
106:11 - point here is now 0
106:14 - 0 if we drag everything in the middle
106:18 - though and zoom out and in like this we
106:22 - do get what we want so what we need to
106:26 - do is this initial offset that we have
106:29 - in the beginning it should be directed
106:32 - that way by how much this Center is
106:36 - offset so we're going to go to viewport
106:39 - JS here and our offset here is actually
106:43 - going to be equal to
106:47 - scale this
106:49 - Center by minus one so basically it's
106:53 - going to be a point with minus canvas
106:55 - width / two and minus canvas height
106:58 - divided by two but now I have an
107:01 - opportunity to implement this scale
107:04 - function for vectors here in
107:08 - utils it's a little bit different than
107:10 - add and subtract because it takes the
107:12 - point as a parameter and the second
107:15 - parameter is a scaler it's a simple
107:18 - number it's not a point with X and Y
107:21 - and what we do with it is
107:24 - just
107:27 - multiply both P of X and P of Y like
107:33 - this save and refresh and now the
107:37 - initial view is
107:39 - correct zooming out and zooming
107:43 - in is as
107:49 - expected
107:54 - but clicking is not so now we have to
107:57 - consider also the offset when we
108:01 - calculate the mouse location in the
108:03 - viewport
108:06 - here we do that by subtracting
108:10 - here this offset X and here this offset
108:19 - y and here we also have to consider that
108:22 - Center information as well so I'm going
108:25 - to put in
108:26 - parenthesis minus Center this is
108:32 - before stretching it with the with the
108:34 - zoom and the same happens
108:39 - here with the
108:41 - center y like that save and refresh and
108:47 - now let's zoom and move somewhere and
108:50 - when when we click everything seems to
108:53 - work and you can now edit these points
108:56 - by zooming in and working on different
108:59 - parts of the
109:02 - screen H but now this
109:05 - intent doesn't show well you can see how
109:09 - while I'm dragging here something
109:12 - strange happens to this intent to this
109:16 - line it's fine when I'm not dragging
109:19 - it's always at the mouse location but if
109:21 - I start here and move to the right a
109:25 - little bit it seems to go to the right
109:29 - even more and same happens like this the
109:32 - mouse is always in the middle of the
109:35 - starting point where we began the
109:37 - dragging
109:39 - here and whatever the
109:43 - current tip of that dotted line is there
109:47 - so what we want to do is actually subtra
109:50 - ract the drag offset in this
109:52 - case and I'm going to go to graph editor
109:57 - here where we get the mouse and say that
110:01 - yes we want the mouse by subtracting the
110:05 - drag offet so this get mouse needs an
110:08 - update here where we subtract that drag
110:14 - offset so this is going to be false by
110:17 - default we like this functionality all
110:19 - the time
110:20 - except while we are doing the drag there
110:24 - so here instead of return we are going
110:27 - to
110:28 - say Point
110:30 - p is the new point and what we return is
110:36 - depending on this second parameter if
110:39 - it's true then we do subtract from P
110:43 - this drag offset otherwise it's just p
110:47 - as
110:48 - before save this
110:52 - refresh and now if we select something
110:55 - and
110:56 - drag we can see that it's always still
110:59 - pointing at the mouse apart from that
111:02 - small delay caused by the animation
111:08 - tuop yeah this is quite
111:11 - good but what we really need to take
111:14 - care of is
111:16 - here this animate function is really
111:20 - getting complicated and all of this kind
111:22 - of functionality should be really taken
111:25 - care of um by the
111:27 - viewport the problem is we have this
111:31 - graph editor display wrapped between the
111:33 - restore and everything else and one way
111:37 - to solve this problem is actually move
111:40 - it at the dop so the restore happens
111:44 - before the save and if you think about
111:47 - it it does make sense so now all this
111:51 - code from here before this is going to
111:55 - be cut I'm going to cut it and it's
111:57 - still there it's in my clipboard so
112:00 - don't lose it and we're going to just
112:04 - call
112:05 - viewport reset so we reset the viewport
112:09 - and then we
112:10 - display now this reset functionality I'm
112:13 - going to implement it
112:18 - here and say
112:28 - reset let's just paste
112:31 - everything
112:32 - and CTX will not be recognized so we
112:36 - have to say this dot CTX pretty much
112:40 - everywhere where we see
112:43 - CTX and my canvas it is a global
112:47 - variable but we have our own
112:50 - local one that we can
112:54 - use like this and viewport here it's
112:59 - just this so this this this this and
113:03 - this
113:05 - save refresh and now everything should
113:10 - still work as
113:18 - before
113:23 - but the code is much cleaner and now you
113:26 - are free to make any size graph you
113:29 - want and um might be useful to have a
113:33 - way to save this and this is not really
113:36 - a great graph here so maybe also
113:39 - removing it a button that deletes
113:42 - everything so let's have two buttons
113:44 - here for the save and for removing
113:47 - everything otherwise you'd have to right
113:49 - click click a lot and you don't want to
113:51 - do that in these kind of
113:53 - situations we're going to go to index
113:58 - HTML where our controls were in the very
114:03 - beginning and let's define a
114:06 - button it will
114:10 - dispose of the
114:14 - graph and I'm going to copy this the
114:17 - other one will be save
114:21 - and these buttons will stay there in the
114:23 - end so I'm going to style them a little
114:26 - bit better I'm going to use emojis and
114:31 - this is just a trash can emoji and this
114:34 - one here it's going to be the save Emoji
114:38 - so this dispose function let's implement
114:41 - it here
114:43 - below
114:46 - dispose and it's going to tell the
114:49 - graphic Editor to dispose itself and the
114:54 - reason I do this is that here inside of
114:57 - the graph editor
115:01 - now Above This display it's going to
115:04 - have another public method called
115:08 - dispose and in it we tell the graph to
115:13 - dispose but we also want to reset hover
115:16 - then select it so I'm going to say
115:19 - selected is null and hovered is null
115:25 - like that that's it for this pose so
115:28 - let's go back to index HTML and also
115:31 - handle the save function this one is
115:34 - just going to store the current version
115:37 - of the graph in local storage so local
115:41 - storage set item the
115:44 - graph and I will use Json stringify to
115:48 - convert the graph into a string because
115:52 - local storage only works with
115:54 - strings let's
115:56 - save refresh and let's try
116:02 - dispose seems to work and let's create a
116:06 - new graph
116:08 - here maybe just going to
116:12 - say
116:14 - hi and save it now when we save it we
116:19 - should be able to see it here inside of
116:22 - local storage get
116:25 - item
116:27 - graph like this we see the points and
116:31 - the and the segments just fine but when
116:35 - we
116:36 - refresh the old one comes again the one
116:40 - with the hardcoded values even
116:42 - though the one we stored is still there
116:46 - so we just need to load this information
116:49 - inside of the graph instead of the
116:51 - hardcoded
116:52 - values I'm going to go back here and
116:56 - let's remove these hardcoded things from
116:59 - here leave this as an empty
117:02 - graph for now and what we do is we check
117:06 - to see is there this string information
117:10 - inside of the local
117:13 - storage and if there is we get the info
117:17 - object containing the points
117:20 - and the segments by parsing it using
117:24 - Json
117:25 - parse or it's null if the local storage
117:29 - doesn't contain the
117:30 - graph and now here the graph will either
117:36 - be what is in graph info or this one if
117:39 - graph info is null so let's
117:42 - say graph
117:46 - info and if it exists we have
117:49 - have a new graph with the points and the
117:54 - segments from graph info so we load that
117:59 - original graph that is stored in local
118:01 - storage save and
118:05 - refresh it doesn't work the problem is
118:09 - the things that we have in local storage
118:11 - here are just objects called points and
118:15 - segments but they are not really points
118:18 - and segments
118:20 - in the same way that we expect them to
118:22 - be they don't have for example a draw
118:25 - method this is all they have so we need
118:28 - to convert this information
118:31 - into points and segment
118:36 - objects I'm going to do that by using
118:41 - um static method called
118:45 - load that we're going to add to the
118:48 - graph given some information it's going
118:50 - to create a graph for us so in graph JS
118:54 - below the Constructor let's define it
118:57 - here static load info so we call this
119:03 - function with capital graph as you seen
119:07 - here and this function belongs to the
119:11 - class not to the instances like all the
119:14 - other ones and what we do in it is we
119:17 - prepare our point
119:20 - and our
119:22 - segments with the information from this
119:25 - info so I'm going to get the point
119:29 - information of each individual point
119:32 - from the info points and just say push a
119:36 - new
119:38 - point with Point info X and point info y
119:42 - so what happens now is I'm generating a
119:45 - point with the same information from the
119:48 - Json
119:50 - object and same thing with the segment
119:53 - as well segment info of info
119:59 - segments segments push new
120:03 - segment segment info P1 segment info P2
120:09 - like this and now with this information
120:12 - we can return a new
120:14 - graph like this so it's not just passing
120:18 - in info points and info segments but
120:21 - actual points and segment objects in two
120:25 - different arrays let's save refresh and
120:29 - look at that just as we
120:37 - expected JavaScript is killing me with
120:40 - this uh serialization stuff to be
120:43 - honest the problem
120:47 - is these p P1 and P2
120:51 - points are not points they are again
120:55 - objects that have an X and Y but they
120:58 - are not the same points from here even
121:01 - though they should
121:04 - be so we have to take care of that I'm
121:07 - going to remove these from here and we
121:11 - need to find in this
121:14 - points array the same points that
121:17 - correspond to P1 and P2 from the Json
121:21 - info so let's
121:26 - find point that was equal to this P1 in
121:30 - the list of points that we created and
121:35 - also P2 like so save and
121:40 - refresh and now everything looks as
121:47 - expected I really don't like that you
121:49 - have to do so much work to get this to
121:53 - work but it is what it is if you know a
121:56 - better way of doing this do let me know
121:59 - actually I know a better way of doing
122:01 - this we can refactor a little bit and
122:05 - say here for example the
122:08 - points we can just use the map method
122:13 - and go through each point I and create a
122:18 - new one so this I stands for Json info
122:23 - and we create new points using that
122:26 - information in one line so we don't need
122:29 - this for Loop
122:30 - anymore and we can even do the same
122:33 - thing for the segments as well so the
122:36 - info segments we can remap them to
122:39 - actual segments each segment I is going
122:42 - to be a new
122:46 - segment and here we just paste this
122:50 - information like
122:53 - so and make sure that this seg info is
122:57 - high
123:01 - now and we don't need this second for
123:04 - Loop anymore so a little bit more
123:07 - concise save refresh and everything
123:12 - still works it's just a little bit nicer
123:14 - structure
123:15 - here we could design the road border now
123:19 - like this but it kind of looks like a
123:22 - child made them making sure Road borders
123:26 - have the same thickness everywhere is
123:28 - important and not fun so today I'll
123:31 - teach you how to use geometry to wrap
123:33 - the graph segments in what I'm going to
123:36 - call envelopes they're just polygons
123:39 - with more points here to make them look
123:41 - round we then compute the union of these
123:43 - polygons to keep just the outer segments
123:47 - this solution keeps the number of clicks
123:48 - to a minimum and makes the World
123:50 - building very satisfying I think now
123:54 - let's get this show on the
123:56 - road I'm going to draw a simple
123:59 - graph that kind of looks like the letter
124:03 - J save it and now let's Implement a
124:07 - functionality that creates a polygon
124:09 - using these
124:11 - points we're going to test this
124:15 - functionality here after displaying the
124:18 - graph
124:19 - editor like so creating a new polygon
124:22 - with the graph
124:25 - points and drawing it on the context so
124:29 - we need to implement a polygon and give
124:31 - it the draw method same as the other
124:35 - Primitives speaking of which the polygon
124:38 - is also going to be a primitive
124:44 - here and let's create the
124:47 - file
124:50 - polygon
124:52 - JS now the polygon is also a simple
124:57 - class and in the
125:00 - Constructor I'm going to pass the
125:04 - points and store them as an
125:09 - attribute like so and the draw method
125:13 - I'm going to give it the context and
125:15 - some options with uh default stroke
125:19 - set to Blue and the line width of two
125:25 - and I want it to be transparent let's
125:27 - set it to a
125:31 - transparent
125:33 - blue fail style like
125:37 - this now inside of the draw method We
125:41 - Begin the
125:44 - path we set the fil style to the fill
125:50 - attribute the stroke style to the
125:54 - stroke and the line withd to the line
126:00 - WID Now we move
126:03 - to the first point like
126:10 - this and use a for
126:14 - Loop to essentially create line
126:19 - to all the other points one by one until
126:23 - we've connected all of
126:27 - them so CTX line
126:30 - to points of
126:35 - i x and points of I of Y like this and
126:41 - now we close the
126:44 - path this will draw the line back to the
126:47 - first point and then and I want to fill
126:50 - and also stroke this
126:53 - time let's save and refresh the page and
126:57 - now we get this so the graph is still
127:00 - there but now we also see this polygon
127:05 - this blue polygon on top of the graph
127:07 - points and if I'm going to add some more
127:10 - points
127:11 - here and play a little bit with these
127:15 - points maybe connect these ones you can
127:18 - see the graph starts to appear here in
127:20 - the
127:22 - middle but the polygon and the graph are
127:25 - two different things it's not the same
127:29 - kind of structure the graph can have
127:31 - these branching elements here now the
127:35 - next thing I want to do is create a
127:38 - polygon
127:40 - along one of these graph segments so
127:44 - somehow enveloping it in a polygon and
127:48 - and we're going to do that by creating
127:52 - another object called
127:54 - envelope and it's going to be
127:57 - used like this new
128:03 - envelope graph segments of zero the
128:06 - first segment and let's give this a
128:09 - width and the width of 80 pixels and
128:14 - draw it on the context like so as before
128:20 - we Define here another
128:24 - primitive
128:26 - envelope in
128:28 - our
128:31 - envelope
128:34 - JS class
128:38 - envelope and the Constructor is going to
128:41 - take the parameter of the segment and
128:44 - I'm going to refer to this as skeleton
128:46 - it's like the inside of the envelope and
128:49 - the second parameter is going to be the
128:51 - width of this envelope let's store this
128:56 - skeleton as an
128:59 - attribute and we'll use the width to
129:04 - generate the
129:07 - polygon like so in a private method
129:10 - called generate
129:13 - polygon like
129:15 - this now we're going to be working with
129:19 - the points of this skeleton and I don't
129:22 - want to type this skeleton P1 this
129:24 - skeleton P2 all the time so I'll just
129:28 - use the destructuring
129:31 - assignment like this and now we can just
129:34 - use B1 and B2 we also need the
129:40 - radius half of the
129:43 - width and the angle between P1 and P2
129:48 - two we can get it with ar tangent 2
129:54 - method between the difference of those
129:57 - points like
129:58 - that now we're going to need an angle
130:01 - that is offset by 90° and actually
130:05 - offset 90° clockwise and
130:08 - counterclockwise so I'm going to refer
130:11 - to that
130:12 - angle like this and just add half pi to
130:17 - Al Al and let's copy this below and say
130:22 - here Alpha
130:24 - counterclockwise and put a minus here
130:27 - for minus
130:29 - 90° and now we can start to get points
130:32 - that are offset so from P1 we are going
130:36 - to get a point P1
130:39 - CCW offset
130:42 - counterclockwise by
130:44 - translating P1 according to Alpha CC W
130:50 - by the radius this is going to be the
130:53 - offset that we move it along the angle
130:56 - from this given point B1 we're going to
131:00 - need to implement this translate method
131:02 - but I'm just going to first use it here
131:05 - to define the other similar points P2
131:09 - CCW coming from
131:13 - P2 and then P2
131:17 - CW coming from P2 and Alpha CW and P1 CW
131:25 - coming from P1 Alpha CW like this and
131:30 - these are the points that we will use to
131:32 - create our polygon
131:35 - so we return a new polygon with this
131:40 - array of
131:44 - points like so let's implement this
131:47 - Translate method and maybe we'll also
131:50 - extract this angle function because this
131:53 - is kind of cryptic here like if you
131:55 - don't know the formula what is this
131:57 - doing so inside of math and utils I'm
132:01 - going to go here at the bottom and
132:06 - Implement our translate
132:15 - method which returns a new point
132:21 - relative to the given location we add
132:26 - and now we have to use the trigonometric
132:28 - Circle and remember that on the X it's
132:30 - the
132:32 - coine of the angle and we multiplied
132:36 - this cosine by the offset how much we
132:38 - want to move it because cosine is
132:40 - between 0 and 1 so multiplying this is
132:43 - going to move the
132:47 - point
132:50 - a total of
132:53 - offset on X and Y respectively so
132:56 - diagonally now that angle function is
132:59 - going to be really easy given a point we
133:02 - just output its
133:07 - angle like this and back here we can
133:11 - replace this with angle and then we can
133:14 - just subtract the two points because
133:16 - that's what this is doing so let's put
133:20 - here
133:21 - angle subtract P1
133:26 - P2 and to draw the envelope we also need
133:29 - to give it a draw method
133:31 - here and for now this is just going to
133:35 - tell the polygon to draw itself now save
133:39 - this and
133:40 - refresh and we get this you can see now
133:43 - this polygon
133:46 - forming surrounding only the first
133:49 - segment of the graph the others are
133:52 - ignored for now but I want this polygon
133:55 - to have curved sides like that here
133:59 - surrounding this because round roads are
134:02 - just
134:03 - nicer so let's figure out how to do that
134:07 - here I'm going to first collect some
134:10 - points around
134:12 - P1 I do that by defining here an array
134:15 - called points and now let's loop from
134:20 - alpha
134:22 - counterclockwise to Alpha
134:25 - clockwise and increase this I with a
134:29 - step we'll Define that in a
134:31 - second and then push into this
134:35 - points translating P1 at this I
134:41 - angle by the
134:44 - radius and this step is going to be a
134:47 - fraction
134:49 - of Pi actually I like to use Pi when
134:54 - dealing with circles and let's try to
134:57 - see what these points look like so I'm
135:01 - going to pass here points instead and we
135:05 - really don't need these other variables
135:06 - they were just there to learn how this
135:09 - works save and
135:12 - refresh and now we get this we get some
135:16 - kind of curviness here we can actually
135:18 - control this by this value if we put
135:21 - here 10 for
135:23 - example we're going to get a much more
135:26 - curvy shape and let's do the same thing
135:31 - with P2 as well so I'm going to copy
135:37 - this
135:39 - below and this doesn't change but here
135:42 - we are going to use
135:44 - P2 and it's on the opposite side so
135:49 - 180° difference and I'm going to add
135:54 - here matte pi plus I like this and save
136:01 - refresh and now we get
136:10 - this this is actually a parameter how
136:13 - round we want this shape to be and we
136:16 - could replace this with
136:20 - roundness and here let's pass it as
136:23 - parameter roundness and I'm going to
136:26 - pass it also here and here maybe give it
136:30 - a default value of something let's try
136:36 - let's try what happens with zero like
136:38 - zero
136:41 - roundness this doesn't really look
136:44 - good let's try
136:46 - one it's what we had previously and this
136:50 - is actually what I would assume to have
136:53 - if the roundness is zero as well so I'm
136:56 - going to go here and do this kind of
137:03 - trickery to avoid that zero situation
137:07 - because it doesn't make any sense and
137:10 - now when we set zero
137:12 - here it's actually going to look like
137:16 - one
137:19 - so when moving it like this there seems
137:22 - to be some problem and it happens
137:26 - because here sometimes I doesn't exactly
137:31 - reach Alpha uncore CW this happens
137:35 - because how floating Point numbers work
137:39 - and sometimes you just get a value that
137:42 - is below that and the next value adding
137:46 - step exceeds feeds that so it never hits
137:49 - exactly there and then you're far from
137:52 - this end result we can fix this by
137:55 - adding a small Epsilon value and I'm
137:59 - making it here a fraction of the step we
138:03 - add this Epsilon value
138:06 - here to this and in that way we
138:10 - guarantee that we include this final
138:12 - angle there and we don't go overboard
138:15 - because it's just half a step in this
138:18 - case so I'm going to save this refresh
138:22 - and now no more strange artifacts like
138:26 - that
138:26 - coming I'm going to keep this default
138:29 - roundness here to one because it somehow
138:33 - makes sense you can create an envelope
138:35 - without a roundness and we can play with
138:38 - the parameters here as well if we want
138:41 - maybe set a width of 200 and let's give
138:45 - it a roundness of 20 see how it looks
138:50 - like okay really round large shape
138:58 - there now I really want to generate
139:01 - these envelopes for everything and it's
139:05 - time to start thinking about defining
139:07 - our world object the one that will
139:10 - contain the roads and all the other
139:12 - components there because these envelopes
139:15 - are going to be part of what is required
139:18 - to build that world so let's implement
139:22 - this world object containing all the
139:25 - things and in there have a way to
139:28 - generate all the envelopes for all the
139:31 - graph
139:34 - segments I'm going to go here below this
139:40 - graph definition
139:42 - and instantiate the world with the graph
139:46 - the world will be based on this graph
139:49 - and now I want this world to
139:51 - automatically update every time we
139:55 - change some things every time we edit
139:57 - the graph and I'm going to add this call
140:03 - here to generate the world and also to
140:06 - draw the world and I'm doing it before
140:09 - the graph editor because it's going to
140:11 - contain things and I want to still see
140:13 - the editing tools on top of that let's
140:16 - now
140:19 - import a new file called
140:22 - World JS and this is going to be here in
140:28 - the root JS directory so next to the
140:31 - editor and the
140:35 - viewport and the class is going to be
140:38 - also relatively simple for now it's
140:42 - going to become quite complex by the end
140:45 - of this course I'm going to pass here
140:49 - some default parameters like the road
140:52 - width and
140:54 - roundness and let's store
140:58 - these things as
141:01 - attributes as
141:07 - well and
141:14 - roundness and now I want to store these
141:17 - envelopes to generate these
141:19 - envelopes uh we will generate them in
141:22 - this class attribute which is empty by
141:26 - default
141:28 - and the
141:30 - generation will happen here we generate
141:33 - them with this generate method and if
141:36 - they're already generated because we do
141:39 - this in a in a loop in in the animation
141:42 - Loop we empty this array to begin with
141:47 - because we are going to regenerate them
141:49 - again and again on each frame maybe we
141:51 - change the editor and then we want the
141:53 - changes to reflect in the world that we
141:56 - create so let's Loop through all the
141:59 - segments
142:04 - now like this and push into this
142:09 - envelopes array a new
142:13 - envelope
142:14 - from this seg
142:17 - and with the road width and Road
142:25 - roundness attributes from above and now
142:29 - this world is also going to need a draw
142:32 - method and I am just going to for now
142:37 - Loop through all of these
142:43 - envelopes and draw
142:45 - them on the context one by one let's
142:50 - refresh and now we get
142:53 - this
142:55 - um funny to play with
142:58 - this reminds me a little bit of this uh
143:01 - quop game I made in uh live stream
143:08 - once all
143:10 - right now the thing we need to deal with
143:13 - next are these sections here these kind
143:16 - of inter sections between these
143:19 - envelopes they need to somehow disappear
143:22 - and all of these envelopes should form a
143:25 - union a single shape that doesn't have
143:29 - any kind of overlapping Parts the first
143:33 - step in that is actually detecting these
143:36 - intersecting points all these small
143:38 - intersecting points between the
143:41 - envelopes and we are going to do that
143:44 - for the first two envelopes to begin
143:47 - with maybe I remove this part from here
143:50 - and save a simpler version of the graph
143:53 - to avoid confusion so let's find all
143:56 - these intersecting points here
144:00 - somehow we'll store these
144:04 - intersections here in an
144:08 - attribute and the function that will do
144:12 - this is called break it's going to be a
144:15 - static method inside of the polygon
144:18 - class and it's going to take two
144:22 - polygons and break them you'll see what
144:26 - that means soon enough but it will
144:29 - return these intersections that I was
144:31 - talking about so here we are going to
144:35 - draw also these intersections after the
144:39 - envelopes maybe
144:41 - int int and this intersections here and
144:46 - and they will appear on the canvas after
144:49 - we implement this break method let's go
144:53 - to polygon JS and it would be useful to
144:57 - have the segments of this polygon as
145:00 - well the sides of the polygon having
145:03 - them readily available here is going to
145:05 - make implementing the brake function
145:07 - easier so in the Constructor I will also
145:11 - get the
145:12 - segments by
145:15 - looping starting at one through all the
145:20 - points like this and pushing into the
145:23 - segments
145:24 - array a new
145:29 - segment between the previous
145:33 - point and the current point and I want
145:38 - this to Loop so when I is going to be
145:42 - equal to points do length then points of
145:45 - I would return an error but doing this
145:48 - is going to return the remainder when
145:51 - dividing by that so this will jump to
145:54 - zero instead of giving an error and
145:57 - that's going to loop around and connect
145:59 - back to the first point which is what we
146:02 - want to have that segment as well and
146:04 - now we can Implement that static method
146:08 - called break that takes two poies poly
146:11 - one and poly two and really only uses
146:15 - the segments of those
146:17 - so let me just take poly one
146:21 - segments and poly
146:24 - two segments like this and now Define
146:30 - the
146:32 - intersections that we want to
146:34 - find and find them by looping through
146:38 - all the segments of the first
146:42 - polygon and for each segment we check to
146:45 - see if it intersect any segment of the
146:48 - second polygon so we need this other for
146:51 - Loop here as
146:57 - well and
147:00 - then we get the
147:06 - intersection
147:11 - between
147:13 - P1 P2 of the first segment
147:17 - and
147:20 - P1
147:22 - P2 of the second
147:24 - segment and
147:27 - then we check here if the intersection
147:30 - exists because sometimes segments don't
147:33 - intersect and if the offset is different
147:38 - from one and different from zero this
147:42 - means that they don't intersect exactly
147:45 - at the tip
147:47 - which is a situation we want to avoid
147:51 - then we get the
147:55 - point from this intersection object
147:59 - you'll see that in a second and
148:04 - push to the
148:06 - intersections this point and then return
148:13 - intersections like this now I'm going to
148:15 - go to utils JS and add this get
148:19 - intersection function and I'm just going
148:22 - to go down here and paste so this
148:27 - function I'm not going to explain I
148:31 - already have a special video about it
148:33 - and it was part of phase one of the
148:35 - self-driving car course so if you took
148:38 - phase one then you already know what
148:40 - this is it also includes this linear
148:43 - interpolation function which I also have
148:45 - a video about and we also Al used in
148:47 - phase one I will link to this code
148:50 - somewhere in the description so you can
148:52 - copy it now but let's see if it
148:55 - works and it does show some points here
148:59 - let's make them a little different
149:01 - looking so we don't confuse them with
149:03 - the graph points so here when we draw
149:07 - the intersection I'm going to say color
149:12 - it red and uh make it smaller I think
149:16 - the red color is enough
149:19 - striking and now we get
149:22 - this
149:31 - yep seems like it
149:34 - works and what we'll do next is we're
149:38 - not done with this break method here it
149:42 - doesn't just create the intersections
149:44 - but it's also going to break break these
149:47 - segments so that for example this
149:50 - segment here on the side of this
149:52 - envelope is going to be divided into
149:55 - this segment and this segment after that
149:58 - we're going to take the segments that
150:00 - are contained inside of another envelope
150:04 - and remove them that's how we're going
150:06 - to do the cleaning so let's do this
150:11 - breaking at this intersection
150:14 - Point here after after we have this
150:17 - intersection
150:19 - point I'm going
150:22 - to keep a reference to P2 of Segment
150:28 - 1 and replace P2 of Segment 1 with this
150:34 - so what we did now is instead of having
150:37 - this large segment we just replaced the
150:40 - end point to be here this space here is
150:44 - empty and we need to create create a new
150:47 - segment that starts now here and ends at
150:50 - that place that's why we kept the
150:53 - reference to the original P2 we need to
150:56 - use it now and we do that by using
151:00 - splice at I + one so the next segment
151:05 - and we don't remove anything splice
151:08 - expects here how many things to remove
151:11 - from the array we don't want to remove
151:13 - anything we want to add a new
151:16 - segment starting at the
151:19 - intersection and
151:21 - until what was P2 previously and we do
151:25 - this also for the other segment where
151:30 - the intersection
151:31 - happened so I'm going to copy this
151:35 - without this let because I just want to
151:39 - reassign this auxiliary variable to
151:41 - something else and this is going to be
151:44 - seg 2 of
151:47 - J and SE 2 of J SE 2 splice at j+ one
151:58 - and this should work but we need a good
152:00 - way to test this and I'm going to do
152:03 - that here I will Implement a way to draw
152:07 - the segments by using different colors
152:11 - and in that way we know if it's the same
152:14 - segment that continues after the
152:16 - intersection point or something else so
152:20 - going through all the segments I will
152:22 - draw them on the
152:24 - context with the
152:26 - color get random color and this let's go
152:31 - to utils again I'm going to paste
152:34 - something again we used it in Phase One
152:37 - to draw cars in different
152:39 - colors let's also go to envelope
152:43 - JS here and after we draw the poy
152:47 - normally I'm also going to draw segments
152:52 - with this debugging function we just
152:55 - implemented so
152:58 - refresh and now we get this crazy thing
153:01 - with a lot of colors going around let's
153:04 - make these segments wider I think they
153:07 - are not very visible as such so I'm
153:11 - going to pass here inside of the polygon
153:14 - JS draw segment
153:17 - also
153:18 - um width of
153:22 - five now
153:24 - refresh looks a little better I'm
153:26 - actually going to remove the
153:28 - intersections we don't need them anymore
153:30 - we know they work and actually this
153:34 - breake function doesn't need to collect
153:37 - and return the intersections it just
153:39 - needs to break the polygons so I'm going
153:44 - to remove this part from here here as
153:47 - well it uses the get intersection
153:50 - function but it doesn't collect the
153:51 - points we don't need that and inside of
153:55 - world JS I'm going to
153:58 - stop using the intersections there
154:02 - refresh and things move a lot but you
154:05 - can kind of tell that this color here is
154:08 - not the same as this color here and here
154:11 - there are quite many small changes as
154:14 - well you can debug this better by typing
154:17 - debugger in the console and this is
154:20 - going to instantaneously stop what is
154:23 - happening here and you can see this
154:25 - green red orange and pinkish color here
154:30 - and a lot of these small changes here
154:32 - every time something intersects so the
154:35 - code seems to
154:37 - work but only for the first two
154:40 - envelopes if I'm going to draw here
154:43 - another one you can see
154:49 - this segment here is not affected this
154:51 - segment here is not affected and same
154:54 - for the small ones here so this is the
154:57 - difference what we did now breaking the
155:00 - polygon segments at the intersection
155:03 - points contrary to what we have on the
155:06 - right and what we're going to do next is
155:09 - do the same thing on the right and for
155:11 - every possible combination of
155:15 - envelopes instead of having here polygon
155:18 - break we are going to remove this line
155:21 - and have polygon multi
155:25 - break and I will take all
155:29 - the
155:31 - polies from all the envelopes and send
155:34 - as a parameter one
155:37 - array now this multi Brak inside of
155:40 - polygon JS let's add it here at the
155:43 - top is a static method
155:47 - that gets this array of
155:51 - Poes and I'm just going to
155:55 - Loop through the
155:58 - polies excluding the last
156:02 - one and then for each of these Poes loop
156:07 - again starting at i+ one so I'm not
156:11 - going to compare Poes twice I'm just
156:15 - going to compare
156:16 - every poly with all that follow
156:19 - afterwards and that means we don't do
156:22 - unnecessary
156:23 - work and this one will go all the way
156:26 - until the
156:29 - end and now we use the previous method
156:33 - break between Poes of I and Poes of J
156:37 - like this and if we save and refresh
156:41 - let's add again this other segment here
156:45 - and call here
156:49 - debugger we can see now that this
156:52 - intersection is
156:55 - breaking everywhere as it should and
156:58 - what we'll do next is calculate a union
157:01 - of all the segments that are not inside
157:07 - some other envelope so this segment will
157:09 - disappear this will disappear this will
157:12 - disappear this small one here will
157:14 - disappear these will disappear because
157:16 - they're in this envelope and these will
157:19 - disappear because they're also in this
157:21 - envelope these disappear because they're
157:23 - in this envelope so everything that is
157:26 - inside some envelope will
157:29 - disappear and the result from this will
157:32 - just be a set of segments that we keep
157:36 - it will not be a polygon anymore because
157:39 - for example the resulting shape here
157:43 - would actually be a polygon it would
157:45 - start like this and go like this around
157:49 - and then have a concavity here but if
157:52 - you think about this shape here it would
157:54 - be a polygon that also has a hole and
157:58 - that's a more complex structure and I
158:00 - don't want to get into
158:01 - that so let's Implement our Union
158:06 - function maybe we save this graph as
158:11 - well and
158:13 - here we start off
158:16 - this Union
158:18 - process with the given Poes with a multi
158:23 - break so we break them to get the
158:26 - individual segments and now let's
158:29 - collect the segments that we wish to
158:32 - keep in this array I'm going to scroll
158:35 - down because this is going to be a
158:37 - longer
158:39 - function so looping through all of the
158:44 - polies one by one
158:47 - one and now looping through
158:52 - all of the segments of a given
158:57 - poly we have to figure out if we keep
159:00 - this segment or not so I'm going to say
159:03 - keep is true for now but if this segment
159:07 - is inside another envelope another
159:11 - polygon here then we don't keep it so
159:16 - let's Loop through the Poes again
159:19 - through all of
159:21 - them but ignore
159:25 - here the
159:27 - situation when I is equal to J so we
159:30 - don't want to check if a segment is
159:32 - inside of its polygon it makes no sense
159:37 - and in that case when it's different
159:39 - then we check if it does
159:43 - contain this segment
159:46 - if one of these Poes contains this
159:50 - segment this seg right here then we
159:53 - don't keep it anymore we say keep is
159:56 - false and we can break here to save some
160:00 - computational time because it could be
160:03 - inside several
160:06 - envelopes and here if we keep then I'm
160:10 - going to push it to the kept segments
160:17 - like so and at the end here we return
160:20 - these kept segments so it's a longish
160:25 - function but um it is what it is I'm not
160:29 - going to refactor it
160:30 - anymore what we need to do next is
160:33 - implement this contains segment function
160:36 - so how do we check if this segment is
160:39 - inside something else and because these
160:44 - segments that are in inside are entirely
160:47 - inside something else I'm going to
160:49 - simplify this and only work with the
160:52 - middle point of the segment so the
160:54 - average of the endpoint locations
160:58 - here what that means is that this
161:01 - contain segment is going to
161:05 - transfer its
161:09 - functionality to another method called
161:11 - contains point which is a simpler thing
161:14 - to do now this is not really a great
161:18 - implementation
161:20 - because sometimes the segment may be
161:23 - just partially inside but for our needs
161:26 - it's going to be okay the only problem
161:28 - is the name of this method right here
161:32 - contains segment is a little bit
161:36 - misleading because it only checks if the
161:38 - midpoint is contained inside it and the
161:41 - average function here it's just a simple
161:44 - thing that we add quickly here in utils
161:47 - let's move it next to the other point
161:50 - Vector
161:52 - operations so average of two
161:55 - points I'm just going to return
161:59 - here new Point p1x + p2x ided by 2 and
162:06 - P1 y + P2 y / by two like
162:10 - this and now we can go back and
162:13 - implement the content
162:18 - Point
162:21 - algorithm for this we're going to need
162:23 - an outer point that outer point I'm just
162:27 - going to Define as a point that is far
162:30 - away in the top left maybe minus 1,000
162:34 - minus 1,000 I just hope nobody goes
162:37 - there and draws the graph in that area
162:40 - it's going to make some small glitches
162:42 - happen I guess and then what we're going
162:44 - to do is we're going to check how many
162:47 - times this line segment from point to
162:51 - this outer Point intersects the
162:55 - polygon if it intersects one time then
162:58 - it means that we are inside but polygons
163:01 - can be quite complex shapes sometimes
163:04 - this line segment may cross it multiple
163:07 - times maybe it goes outside and then
163:10 - inside again and then outside again but
163:13 - if it's always going to be an odd number
163:16 - of times then that means that we are
163:19 - still inside the polygon if it's an even
163:22 - number of times it means we're outside
163:24 - of the polygon we just crossed it to go
163:27 - in and then out then we reach this outer
163:30 - point and even number of
163:33 - intersections so that's how the
163:35 - algorithm is going to go I'm going to
163:38 - Define here
163:41 - intersection
163:43 - count set it to zero
163:46 - and go through all the segments of this
163:50 - polygon and
163:52 - calculate the number of
163:56 - intersections from Outer point
164:00 - point to P1 and P2 of this segment and
164:06 - if there is this
164:07 - intersection I'm going to increase the
164:11 - intersection
164:13 - count like this and at the end we just
164:18 - return if the intersection
164:20 - count if the remainder when dividing by
164:24 - two is zero then this doesn't contain
164:27 - the point because it's even but if it's
164:31 - one then this does contain the point so
164:35 - we are done with our method
164:38 - now to test we need to
164:43 - assign these new segments to some object
164:46 - here and I'm going to call
164:50 - this road
164:54 - borders like so and here we are going to
165:00 - say Road borders is equal to
165:05 - polygon
165:07 - Union of all the
165:09 - Poes and in the draw method I'm going to
165:13 - Loop through all of the segments of this
165:18 - road
165:22 - borders and draw
165:24 - them under
165:29 - context maybe we give them some clearer
165:33 - style here let's give a white color
165:38 - and a width of four so the line is
165:42 - thicker let's save refresh fresh and now
165:47 - you can see here these white sections
165:51 - are only on the outsides of the
165:57 - envelopes let's set um larger roundness
166:00 - maybe
166:04 - 10 and now you can see these white
166:07 - sections are here curving quite nicely
166:10 - around this
166:13 - shape let's Style this to look more like
166:16 - a road I'm going to make the envelopes
166:19 - um gray let's remove also this crazy
166:22 - colorful highlighting there
166:25 - so the envelopes here I'm going to style
166:29 - them with the
166:30 - fill of BBB so this is light gray and
166:37 - the stroke is going to be also the same
166:41 - this means we have to pass options to
166:44 - the envelope draw method as well because
166:47 - it doesn't have them at the moment so
166:50 - options and let's pass these to the poly
166:54 - so that it's going to use the same
166:56 - options and we don't need this draw
166:59 - segments anymore for the colorful
167:02 - highlighting
167:04 - refresh and now it looks like this and
167:06 - you can play around with it and see that
167:09 - it does behave quite nicely as you would
167:13 - expect but I would like to add a little
167:17 - bit more of a region here that is gray
167:21 - so that this white border of the road is
167:24 - not exactly on the border of the road
167:26 - but the road continues just a little bit
167:28 - it's just a marking to do that I'm going
167:31 - to go back here and give also um line
167:36 - width of
167:38 - maybe 15 to the
167:41 - envelopes and now we see here this
167:44 - margin like that and I would also like
167:47 - to draw the mid lines on the road as
167:51 - dashed lines so for that we're going to
167:55 - go
167:56 - here and loop through all of the
168:00 - segments of the
168:05 - graph and draw each
168:08 - segment also with white and also maybe
168:13 - for and a dash of 10
168:17 - 10 save
168:20 - refresh and something happens here but
168:23 - this um graph editor is blocking and I
168:26 - can't really see what is happening maybe
168:29 - we go to index
168:31 - HTML and um let's try commenting out
168:35 - this graph
168:36 - editor yeah and uh graph editor actually
168:41 - still
168:42 - works even without displaying the the
168:47 - things there so you could leave it like
168:49 - this but I don't like it I don't get
168:52 - those intense marked in any way like if
168:55 - I'm hovering something or what is going
168:57 - to happen when I click here uhuh
169:00 - something weird happened I didn't know
169:03 - that because I don't have my editor
169:05 - anymore so I will remove this and I will
169:08 - just go here and add um transparency for
169:11 - the editor I think that this is going to
169:14 - be
169:16 - enough so now I still see it but it's
169:18 - not anymore the main thing
169:22 - there the roads are more emphasized
169:26 - we're going to add some decorative items
169:28 - next the buildings and the trees and
169:31 - we'll just focus on the basis first
169:33 - fancy stuff comes later now with few
169:36 - modifications we could use the same
169:38 - graph editing tools to generate the
169:40 - bases of the buildings as well but I
169:43 - think it's really tedious as especially
169:45 - if you plan to build really big worlds
169:47 - and if you want things to align just
169:49 - right so we'll reuse the functionalities
169:52 - we already have and Implement an
169:54 - algorithm to procedurally generate
169:56 - buildings next to the roads and then
169:58 - just Place trees randomly where they fit
170:01 - this solution does have a downside that
170:04 - you cannot have a building exactly the
170:06 - way you want it but I think it really
170:08 - compensates for that because generating
170:11 - everything becomes so fast and easy that
170:13 - you actually could build Rome in one
170:17 - day let's go to world
170:21 - JS and here in the Constructor add some
170:25 - more properties for generating buildings
170:29 - I'm going to align these a little bit
170:32 - different because there will be quite
170:34 - many things appearing
170:37 - here first one is the building
170:42 - width and then the building minimum
170:46 - length the length will vary depending on
170:50 - the size of the road
170:52 - segment I want to have a minimum value
170:55 - and in this case setting it the same as
170:57 - the building width means that in the
171:00 - worst case we will have a square
171:03 - building otherwise it's just going to go
171:06 - alongside the road and the spacing is so
171:09 - buildings don't get stuck to each other
171:11 - now let's set these values here as
171:15 - attributes of the
171:19 - world like so building
171:22 - width to minimum
171:30 - length and the
171:36 - spacing and let's store the
171:40 - buildings
171:42 - here in this array
171:45 - now we'll generate the buildings inside
171:48 - of the generate function
171:51 - here by typing buildings is equal to
171:56 - this generate buildings we'll write all
172:00 - the functionality in this private method
172:04 - the algorithm will go like this we first
172:07 - generate some thicker envelopes and use
172:09 - the same processes before to get the
172:11 - outer segments from these we keep those
172:14 - is long enough to support at least one
172:17 - building and if they're really long we
172:19 - divide them into multiple supports like
172:21 - this we then generate a poly around each
172:25 - of these using envelopes again and do a
172:27 - little bit of fine tuning you'll
172:30 - see
172:34 - generate buildings let's first get these
172:38 - thicker
172:42 - envelopes I'm just going to call them
172:44 - temporary envelopes because we don't
172:46 - need them
172:50 - afterwards from the graph segments we
172:53 - take each segment one by one and create
172:57 - an envelope using it and push it to this
173:00 - temporary envelopes so the envelope that
173:04 - we're going to create has the segment as
173:08 - the skeleton but then the width we have
173:10 - to calculate so it's going to be the
173:14 - Road
173:16 - width and then I'm going to add here the
173:18 - building
173:22 - width and then the
173:27 - spacing twice and finally the roundness
173:32 - I'm just going to use the same one from
173:34 - the
173:37 - road now let's return these envelopes
173:41 - for now these are not buildings just yet
173:44 - they here just envelopes but we will use
173:47 - the result of this method and the
173:50 - contents of this buildings array to
173:53 - debug and we are going to display now
173:56 - those envelopes even though here I'm
173:59 - already going to
174:01 - WR as if they are
174:08 - buildings save and
174:11 - refresh and we see this it's uh not
174:15 - really clear but um these are some
174:19 - thicker envelopes than the ones used to
174:22 - define the road so next step is to avoid
174:26 - these inner segments here so we do the
174:28 - union of these envelope
174:32 - poies
174:34 - here and those remaining segments will
174:38 - be guides I will refer to them as guides
174:42 - here and they will be computed by doing
174:46 - the Union on these temporary
174:50 - envelopes so I map
174:53 - here just the
174:55 - police let's paste this here and
175:00 - debug and now you can see these guides
175:03 - appearing
175:05 - here as segments this
175:09 - time and the buildings are going to be
175:11 - generated on them but not on all all of
175:14 - them only if the guide is longer than
175:18 - the minimum length of the building so
175:22 - let's filter out these very small
175:24 - segments here in the curvy areas and
175:27 - anything that is too short to support
175:29 - the
175:30 - building we are going to Loop through
175:34 - the guides that we
175:43 - have
175:45 - let's just take it here like
175:48 - so and if the length of this segment is
175:52 - less than the minimum length of the
175:56 - building then we are going to remove
175:59 - that I will remove the guide at
176:03 - I one of them and then we also have to
176:07 - do I minus minus here because when
176:10 - removing something from an array it's
176:12 - going to shift everything over this so
176:14 - then the index at I where we are will
176:18 - have some new item that also needs to be
176:20 - checked so if we let I increase which it
176:24 - will for the next step it's going to
176:26 - skip that one unless we decrease as well
176:29 - now this segment here we need the way to
176:33 - calculate its length and it's really
176:35 - easy we just go to The Primitives
176:38 - segment and Implement a length method
176:43 - here that will just return the
176:47 - distance between this P1 and this P2 now
176:52 - we can save and
176:54 - refresh and you can see it looks
176:57 - different these are the only places
176:59 - where buildings can appear in this
177:01 - scenario The Next Step will be to
177:04 - generate the supports for those
177:06 - buildings so for example this segment
177:10 - here is quite long and it's probably
177:13 - going to
177:14 - support multiple buildings and I want to
177:18 - get small segments that we can use as a
177:22 - way to define the buildings around them
177:25 - using envelopes again you'll see now
177:29 - let's say that we could fit three
177:31 - buildings here I want them to start from
177:34 - here and here and also have the spacing
177:38 - in between and the logic for what we're
177:41 - going to implement next is going to be
177:43 - much easier I if we consider a little
177:46 - bit of extra spacing at the end as well
177:49 - because then we can think of a building
177:51 - as the building and its spacing the
177:54 - building and its spacing the building
177:56 - and its spacing and that will help in
177:59 - writing the
178:02 - code so let's go back to World JS here
178:07 - and Define these
178:12 - supports that we need to calculate
178:15 - next and loop through all the segments
178:20 - of the guides and for each segment let's
178:24 - calculate that length with a little bit
178:26 - of extra spacing
178:28 - there so it's the length of the segment
178:31 - plus this
178:34 - spacing and now we can find out how many
178:36 - buildings would fit so the building
178:40 - count is going to be ma.
178:45 - floor of the length divided
178:50 - by this building minimum length plus
178:54 - this
178:55 - spacing and now that we know how many
178:57 - buildings there are we can find out what
179:00 - is the actual length of the buildings so
179:04 - the buildings on this segment will have
179:06 - a length equal to the length of this
179:10 - total segment with the extra spacing
179:12 - divided by the building
179:15 - count but now we have the building and
179:19 - the spacing included in this length so
179:22 - let's subtract this spacing as well and
179:26 - we can proceed to generate the supports
179:29 - along this segment with this building
179:32 - length that we
179:33 - calculated so to do that I'm first going
179:36 - to focus on the first support so let's
179:40 - get the direction of this segment we're
179:43 - going to
179:46 - needed and then two points q1 is going
179:51 - to be segment
179:54 - B1 and Q2 is going to be according to
180:00 - segment q1 we move along this direction
180:04 - the length of this building length so
180:08 - what we're going to do is add to
180:10 - q1 scaling this direction vector
180:15 - by the building length and add this
180:19 - segment to
180:21 - the
180:24 - supports like so let's implement this
180:27 - direction Vector it's also easy going to
180:33 - be
180:36 - calculated by
180:41 - normalizing because I don't want this
180:43 - vector Vector to contain any magnitude
180:45 - any distance really it's going to have a
180:48 - distance of one a magnitude of one and
180:51 - we just get it by
180:54 - subtracting P1 from P2 like this so this
180:57 - is going to be the vector from P1 to P2
181:00 - and it's going to be normalized so it's
181:02 - just the direction there this
181:04 - normalization we don't have it
181:06 - implemented just yet but it's easy to do
181:09 - we just go to
181:12 - utils and maybe here below the
181:19 - scale we normalize
181:22 - P by just scaling p with the inverse of
181:28 - its length of its magnitude and now this
181:33 - magnitude it's just the distance to the
181:35 - origin so I'm going to implemented using
181:39 - the hypotenuse there and I'm only going
181:42 - to pass X and Y because the difference
181:45 - is X and Y the other point is the origin
181:48 - and
181:50 - refresh I have a typo
181:54 - here World JS
181:57 - floor
181:59 - refresh and now it works looks pretty
182:02 - much same as before but if we make one
182:05 - segment
182:06 - longer it doesn't work I forgot to pass
182:10 - here the supports to the return
182:15 - as
182:16 - well okay now if we make this segment
182:21 - longer you can see that only the first
182:24 - support for the buildings along this
182:26 - line is shown and same happens
182:30 - here so let's do the other
182:34 - ones we just Loop here starting from the
182:39 - second building until we reach the
182:43 - building
182:46 - count and update these q1 and Q2 so q1
182:51 - is going to become
182:53 - Q2 but we add the
182:56 - spacing in the direction of the
182:59 - direction
183:01 - vector and Q2 is going to be q1 now but
183:05 - we
183:06 - add in the direction Vector the length
183:10 - of the building this
183:12 - time and
183:14 - we add a new
183:16 - support segment between q1 and Q2 let's
183:21 - save this
183:23 - refresh and
183:27 - now we can see these supports for the
183:31 - buildings appearing there let's generate
183:34 - the base for each of them using the
183:38 - envelope with no roundness we are going
183:40 - to get a rectangular Reg there a
183:44 - polygon so here after we're done with
183:49 - these supports I'm going to
183:51 - write
183:53 - bases like this and looping through all
183:57 - of the
184:00 - supports I'm going to push a new
184:05 - envelope from this segment with the
184:08 - building
184:10 - width as a width no roundness because
184:13 - it's going to default to just a
184:16 - rectangular shape and then I take from
184:19 - here the polygon I don't want to use
184:21 - envelopes here I just want the polygon
184:24 - I'm using the envelope Constructor to
184:26 - get the polygon that I want pretty much
184:29 - and now let's remember to return these
184:33 - bases and
184:36 - refresh
184:42 - yeah
184:46 - this looks nice but here there are some
184:50 - intersecting bases
184:53 - and I'm just going to remove one of them
184:55 - if this happens so let's go back here
184:59 - and say
185:03 - looping between all pairs of bases to
185:07 - find those that intersect if some of
185:10 - them intersect I'm going to Loop through
185:13 - all all of them except for the last one
185:15 - and now all following ones so starting
185:18 - with j at I + one and going until the
185:22 - Bas is length to include the final one
185:25 - as well and now we check to see if bases
185:29 - of I intersects the poly bases of J and
185:34 - if it does I'm going to
185:37 - remove let's say basis of J because it's
185:40 - the second forward Loop there and
185:43 - decrease from the second for Loop
185:45 - because of the same issue mentioned
185:47 - previously now this intersects poly we
185:50 - need to implement and we're going to go
185:53 - in polygon
185:57 - JS somewhere here maybe and type
186:02 - intersects
186:03 - poly a given poly and we're going to
186:07 - look through all of these
186:11 - segments and all of the Poes
186:18 - segments and we check to see if there is
186:22 - any intersection between any of
186:25 - these in theory it's possible to have a
186:28 - polygon inside another so their edges
186:32 - their segments don't intersect but we
186:35 - are not going to have that situation
186:36 - because of the sizes that we have
186:39 - defined and um topology of the network
186:43 - so let's return true here and return
186:49 - false here now let's go back here and
186:53 - before I refresh I'm going to save this
186:56 - state so that when I refresh I'm going
186:59 - to have this same situation and let's
187:01 - refresh now and see what
187:05 - happens so this one Building from here
187:08 - disappeared it's okay if we have empty
187:10 - spaces like this sometimes we're going
187:13 - to fill them with trees you'll
187:16 - see now let's test a little
187:19 - bit oh oh there is some weird fidgeting
187:25 - happening there on that
187:29 - side let me try to isolate when it
187:32 - happens like this one there should
187:34 - definitely be a building there I'm going
187:37 - to save this state and try to fix it the
187:42 - problem is is actually inside of
187:46 - our get intersection function here and
187:51 - it's not really a problem of the logic
187:54 - or the math but it has to do with
187:57 - floating Point
187:58 - numbers sometimes this bottom here is
188:03 - basically zero but because of how
188:05 - floating Point numbers work it's not
188:08 - exactly zero it's very very close to it
188:11 - and that's the situation
188:13 - that you see here the building
188:15 - disappears here because that triggers
188:18 - that bottom to be close to zero instead
188:21 - of zero so some kind of fake
188:23 - intersection appears there and I'm going
188:26 - to fix this by just using here a small
188:30 - Epsilon value and instead of saying here
188:32 - bottom different than zero I'm going to
188:36 - say absolute value of the bottom because
188:40 - it can be either way is is greater than
188:45 - Epsilon and let's refresh and see what
188:47 - happens
188:50 - here and the problem is gone and you
188:53 - will see that there is no more fidgeting
188:58 - happening now let's move on and generate
189:02 - trees in this
189:04 - region I'm going to close some of these
189:08 - tabs I have open here at the top and go
189:12 - back to The Constructor here in World JS
189:16 - and prepare a holder for these
189:20 - trees and they will be generated
189:27 - here
189:29 - generate
189:31 - trees in a new private
189:34 - method generate
189:37 - trees and let's start by giving this uh
189:40 - parameter and say we want to generate 10
189:44 - trees somewhere in the region occupied
189:47 - by our graph now the way this will work
189:51 - is it's going to prepare a trees array
189:55 - here and while the length of this array
189:59 - is less than the count it's going to try
190:01 - to add more trees here and for now they
190:06 - will be just simple
190:08 - points and I will randomize the location
190:13 - using lurp so I'm going to lurp between
190:16 - the left side of the region the right
190:20 - side of the region and then from the top
190:22 - to the bottom and these Left Right top
190:28 - bottom we will need to Define
190:32 - above but basically randomly generating
190:36 - trees within the region is what we're
190:38 - doing here and let's push the tree into
190:42 - this dis array and return trees like so
190:47 - now for this Left Right top and bottom
190:51 - top is going to be this point right here
190:54 - it's the minimum y value of the
190:57 - buildings and these um envelopes
191:01 - sometimes the envelope could be the
191:03 - topmost thing like
191:11 - maybe and this situation right here and
191:15 - same goes for the bottom so we need all
191:17 - the points coming from the envelopes
191:20 - forming the road and the polygons
191:24 - forming the buildings for the road I'm
191:27 - actually going to use the segments from
191:29 - the road borders that we have
191:32 - already so here let's take those points
191:36 - into a
191:38 - variable points is equal to and here I'm
191:42 - going to form an array with from the
191:46 - road
191:47 - borders let's map each segment so that
191:53 - P1 and P2 go in a new array and after
191:58 - all of them are here in an array so an
192:02 - array of pairs of points also arrays we
192:06 - can flatten that into one single array
192:11 - of points
192:14 - and we do a similar thing also for the
192:17 - buildings but here we
192:20 - map the points because they are
192:23 - available as uh part of the Poley and we
192:27 - flatten these as well otherwise we're
192:29 - going to have a big array of small
192:32 - arrays with four
192:34 - elements okay and now we get left right
192:39 - top and bottom so left is going to be
192:44 - the minimum
192:45 - value we map again from these points so
192:49 - that we only take the x value and we
192:53 - spread here the spread is used just to
192:56 - take individual items not the whole
192:58 - array and we've used it everywhere here
193:02 - and um let's do the same thing for the
193:07 - right but with the maximum
193:11 - here and let's copy both of
193:15 - these for the
193:18 - top with the Y value here and the
193:24 - bottom with the Y value here so minan
193:28 - max min max is uh okay here and let's
193:32 - draw these trees so similar how we do
193:36 - the buildings here I'm going
193:39 - to Loop and say that
193:45 - through all the trees draw the tree they
193:48 - are points for now now let's
193:52 - refresh and you can see something funny
193:55 - happening here they're generating again
193:58 - and again and again and again at each
194:00 - frame
194:02 - because here in index
194:05 - HTML we do generate on each frame and
194:09 - because we use Randomness we get this
194:11 - funny effect going on but it's kind of
194:15 - okay because it does show us that the
194:17 - region where they're appearing is indeed
194:21 - what we expect it's probably time to
194:24 - stop generating this graph again and
194:27 - again on each frame it's very processor
194:30 - intensive and only generated if it
194:33 - changes for that we're going to go here
194:36 - and calculate the hash for the graph a
194:39 - kind of unique
194:41 - identifier so let's say that the old
194:45 - graph hash is the
194:48 - graph hash we're going to implement this
194:51 - function soon and this is going to be
194:53 - the one when the page loads in the
194:56 - beginning and here before generate we
194:59 - are going to check if the graph hash is
195:03 - different than the old graph
195:06 - hash then we generate and all the graph
195:10 - hash gets updated to the graph hash like
195:14 - so let's close this and invent this
195:18 - better and the hash I'm just going to
195:21 - stringify the graph so in graph JS
195:26 - here at the top I'm going to add the
195:30 - hash function that only converts this
195:33 - into a
195:36 - string let's
195:38 - refresh and you can see now the points
195:42 - is dark points here are now the trees
195:45 - and every time we change the graph they
195:49 - actually get
195:51 - regenerated so what we did
195:54 - works next will be avoid generating
195:58 - trees in these illegal places like on
196:02 - the road here or inside of this
196:05 - building let's go to world
196:08 - JS where we generate the trees
196:12 - and above this Loop I'm going to have a
196:16 - holder for these illegal poys where we
196:20 - don't want things to be inside
196:23 - so illegal
196:26 - poce a new array and here I'm going to
196:30 - spread the buildings they are Poes still
196:34 - at this stage later we're going to
196:36 - actually make a building class for each
196:38 - of them so we'll have to refactor this
196:40 - code a little bit but now this works
196:44 - just fine and from the envelopes I'm
196:47 - going to take each individual po like
196:52 - this so let's check to see if the points
196:56 - that we are adding here should be kept
196:59 - as a tree or not and I'm going to
197:02 - implement this like so keep is true by
197:07 - default and then looping through the
197:10 - illegal Poes
197:15 - if this
197:17 - poly contains the
197:20 - point
197:24 - P then we say we don't keep it keep is
197:29 - false and we can also break here because
197:32 - it's enough that the tree is in one poly
197:35 - it's not going to be inside another one
197:37 - as well so no point to look for another
197:39 - one in this case and here here I'm going
197:43 - to wrap this
197:46 - in his keep then push the tree to the
197:52 - trees otherwise this is going to try
197:54 - again and again until you reach that
197:57 - count let's save and
198:01 - refresh and now the trees don't
198:03 - intersect those and we could try also
198:07 - changing the graph a little bit just to
198:09 - see multiple Generations and it doesn't
198:13 - seem like any intersection is happening
198:17 - so the trees are
198:18 - in almost okay places the problem is
198:22 - these trees also have a size right so
198:26 - maybe this is too small of a space for
198:30 - the tree to be in and that's what we are
198:33 - going to need to do next let's define
198:36 - the size for these trees here as
198:41 - another
198:43 - parameter and I'm going to save it here
198:47 - as a
198:52 - attribute and when drawing the trees
198:55 - let's also give them
198:58 - this size so that
199:02 - we see them properly and I'm going to
199:05 - give them a color that is transparent
199:09 - black so that we see intersections
199:13 - between trees as well that's another
199:16 - thing that we're going to look out for
199:18 - close this save and
199:23 - refresh and now you see those things
199:26 - that I was talking about so these trees
199:28 - first of all they intersect and then
199:30 - also they hit the other objects there so
199:34 - we need to take care of these
199:37 - somehow let's first take care of these
199:40 - trees that intersect so if a tree is too
199:44 - close to another tree then we just don't
199:47 - generate it there we try to generate it
199:50 - again so back in the generate Tre
199:54 - function here just before we decide if
199:57 - we keep the point or not I'm going to
200:00 - say if we have kept it so far we are
200:05 - going to Loop through all of the
200:10 - trees and if the distance from the
200:15 - tree to this point that we want to
200:18 - decide on is less than the size of the
200:23 - tree then we don't keep
200:27 - it we can also break save and
200:33 - refresh and now the trees shouldn't
200:36 - intersect each other anymore because we
200:39 - said that the distance between the trees
200:42 - should be bigger than a tree so that
200:47 - problem is solved but let's also solve
200:49 - the problem of being too close to the
200:51 - road or too close to the building
200:56 - Poes so here where we check if the
201:00 - illegal poies contain the point I'm also
201:03 - going to check
201:05 - or the
201:07 - distance from the poly to the point is
201:11 - less than half the tree size so here we
201:15 - just need the radius let's save and
201:19 - implement this distance to point
201:21 - function inside of the
201:26 - polygon maybe
201:29 - here distance to
201:32 - point for a
201:35 - polygon is going to return the minimum
201:40 - distance between the point point and all
201:42 - its
201:44 - segments so I'm just going to map
201:46 - through all the segments and return the
201:49 - distance to the point from that segment
201:52 - and then spread and return the minimum
201:54 - of that let's save and now we have to
201:58 - implement the distance from a point to
202:01 - the segment so we go to the segment
202:05 - file maybe somewhere
202:10 - here and I'm going to paste some code
202:14 - this code is explained in my other video
202:17 - and I'm not going to go through it now
202:19 - you can also copy this code from a link
202:22 - in the description and notice one thing
202:26 - that the distance to point uses this
202:29 - project Point function here so that's
202:32 - why there are two methods that I pasted
202:35 - here and also one more Vector operation
202:39 - the dot product needs to be add added in
202:42 - utils so save this file and then in
202:46 - utils where our Vector operations
202:50 - are maybe somewhere
202:54 - here I'm going to paste this dot product
202:58 - now let's save and
203:02 - refresh and you can see where the trees
203:04 - are now this is a time when you should
203:08 - be a little bit careful because well if
203:12 - your space is so
203:15 - small that the trees wouldn't be
203:19 - possible to fit you're going to get an
203:22 - error and not really an error but a
203:25 - problem with the execution your while
203:31 - here will never end because trees's
203:34 - length will never reach count
203:37 - so that's why I've used only a few trees
203:40 - until now we would like to write this in
203:43 - a way that it doesn't depend on a count
203:47 - but on something else because if I'm
203:50 - going to make now a very big graph here
203:53 - like so it's still going to generate 10
203:56 - trees but much of this space is going to
204:00 - be empty 10 trees in a very very big
204:04 - city will be will be nothing so the way
204:08 - we will rewrite this is not having a
204:12 - counter here but having a try count here
204:18 - so what we will do is we will try to add
204:22 - trees and if at some point we tried a
204:26 - lot we just assume there are enough
204:29 - trees we can't add
204:31 - anymore so what we do here is try count
204:34 - set it to zero and here let's
204:38 - say while we try for 100 100
204:43 - times we're going to do all of this if
204:46 - we manage to find the space for a tree
204:49 - then we reset the try
204:52 - count and then increase the try count on
204:57 - each step this is very important
204:59 - otherwise we have an infinite loop again
205:02 - now refresh the
205:04 - page and you can see the trees and they
205:08 - are 1 2 3 4 5 6 7 8 9 10 10 11 12 13 14
205:14 - but the number of trees will really
205:16 - depend on the size of the area here
205:21 - really and uh come to think about it
205:25 - there are some
205:26 - situations like I don't really care what
205:30 - is here in this section it's so far away
205:32 - from the road if I think about our
205:34 - self-driving scenario we will mostly
205:37 - just watch what happens on the road and
205:40 - we might see some trees here here maybe
205:42 - here if we zoom out a bit but our Focus
205:45 - will be on the road so generating trees
205:48 - so far away is kind of a waste of
205:52 - memory and I'm going to add a control
205:56 - for that so let's go here and add
206:01 - another filtering
206:03 - step if we still keep the tree up to
206:07 - this point we are going to check if it's
206:10 - close to something
206:12 - by default we say that is false and then
206:16 - Loop through all of the illegal polies
206:21 - again and if the distance from the
206:26 - poly to the
206:28 - point is less than I'm going to put here
206:32 - tree size * 2 so that I can fit up to
206:36 - two trees uh away from the from the
206:40 - items then I say yes there is something
206:45 - nearby we are closed to something and we
206:48 - can break we don't need to look further
206:50 - and here I'm going to say keep is this
206:54 - close to
206:56 - something now save
207:04 - refresh and you can see now the trees no
207:07 - longer get generated in these sections
207:12 - now this piece of code with all this
207:14 - filtering is a little bit long it's
207:18 - quite long actually maybe should
207:20 - refactor it somehow extract these as
207:23 - functions but I'm just going to add here
207:26 - some comments so this is going to be a
207:30 - check if the tree is inside or nearby
207:35 - the
207:36 - building or the
207:39 - road and then here
207:43 - check if
207:45 - Trees Too
207:47 - Close to other
207:51 - trees and
207:54 - here avoiding trees in the middle of
208:02 - nowhere so I think this is fine let's
208:05 - save refresh and test
208:10 - again
208:19 - sometimes these buildings can still be
208:22 - quite close to each other and I don't
208:25 - like that very much that uh spacing is
208:28 - not preserved also here between these
208:31 - ones because there's this point here on
208:34 - this otherwise straight line let me save
208:38 - this state so that I have it for f
208:41 - future testing and go where we generate
208:45 - the
208:48 - buildings here we check to see if it
208:52 - intersects the poly but we can also pass
209:04 - now if the bases of I distance to
209:09 - poly base of
209:12 - J is less than this spacing that's also
209:17 - a problem and we need this distance to
209:20 - poly function implemented in polygon JS
209:24 - but it's going to be quite easy we
209:31 - just go
209:33 - through all the
209:40 - points
209:41 - and say that for each point we take out
209:44 - the distance to that
209:47 - poy so now the distance between two Poes
209:50 - is actually the distance between the
209:52 - closest points it's not exactly what we
209:56 - want because sometimes you might have
209:58 - poies that are offset a little bit and
210:01 - then the distance will appear to be this
210:04 - um even though they are touching but it
210:09 - doesn't matter very much in our case
210:12 - because of how aligned the things are
210:14 - and for this we would need to have a way
210:17 - to calculate distance between two
210:19 - segments and I don't have a tutorial for
210:21 - that yet so it's just going to have to
210:24 - do let's save and
210:27 - refresh and now you can see here that
210:30 - building is gone it's going to leave an
210:34 - empty space there but it's just fine
210:37 - maybe it's going to get filled by some
210:39 - tree like now there will be trees
210:43 - there let's
210:48 - test
210:49 - uhuh there's also one more problem here
210:54 - these buildings are now leaving gaps
210:57 - here again and this is because of that
210:59 - floating Point Number issue sometimes
211:03 - the buildings that are like this and
211:05 - should have a spacing there don't have
211:08 - it because when we calculate the
211:09 - distance now because of the floating
211:11 - Point values just appear a little bit
211:14 - short so back here in World JS instead
211:19 - of just spacing I'm going to add a small
211:22 - Epsilon here as
211:25 - well
211:27 - so
211:28 - minus the Epsilon save let's save this
211:34 - state and
211:37 - refresh and now you can see that those
211:40 - buildings don't have the Gap
211:46 - there what if you want things to look 3D
211:50 - well you could refactor this entire app
211:52 - to use a 3D rendering engine some people
211:55 - already ported the code in Phase One to
211:57 - use 3js or even used other programming
212:00 - languages to do it so what I'm going to
212:03 - teach you now is not the only way to do
212:05 - it and I'm not really sure I recommend
212:07 - it I mean if you really want to make
212:10 - something three the user Library it will
212:13 - take care of cameras lights and a bunch
212:15 - of other things making the end result
212:17 - more professional but I think teaching
212:20 - you this is still interesting because I
212:22 - like the way it looks and getting this
212:25 - to work was actually easier than I
212:27 - thought you may also find the math
212:29 - interesting since it touches on some
212:31 - principles of how 3D renderers work even
212:34 - though they mostly use triangles or
212:36 - boxal and we won't be doing any of
212:38 - that I promise I'll stop here and we
212:41 - won't go to higher dimensional
212:44 - spaces get it no because I have that
212:48 - video on how to calculate distances
212:50 - between points in higher dimensions and
212:52 - no no no let's start converting our
212:57 - tree points here into actual trees so
213:03 - instead of pushing just P here we're
213:06 - going to push a new tree at be with this
213:12 - given tree
213:13 - size let's go to index HTML and import a
213:19 - tree object and I'm going to copy here
213:22 - this viewport and the trees will be
213:25 - inside of
213:28 - items slash tree the buildings will be
213:32 - also in items so let's go inside of JS
213:36 - and
213:38 - create the items
213:42 - folder and then inside the items we are
213:45 - going to have
213:47 - our
213:49 - threejs and this is going to be just a
213:52 - simple class again with a
213:58 - Constructor at the given center with the
214:01 - given size let's also store these
214:06 - attributes
214:08 - Center and the size
214:11 - and by the size I mean the size of the
214:13 - base of the tree
214:15 - so let's make it the
214:19 - year and the draw method for now is just
214:23 - going
214:25 - to draw a point at the
214:28 - center with the given size and let's
214:32 - make it green this time so that we know
214:35 - when we test if it if it works or if
214:38 - we're testing some wrong version now
214:41 - this code won't work directly we need to
214:44 - refactor a little bit here in World JS
214:48 - you see here where we are checking to
214:50 - see if we're too close to other trees
214:52 - distance between tree and point makes no
214:56 - sense so we need to take here instead of
214:59 - tree we add tree do Center and also when
215:05 - drawing here at the bottom everything we
215:08 - don't need to pass these styles to the
215:11 - tree anymore because the tree knows to
215:13 - draw itself so let's save this and
215:16 - refresh and now the circles here are
215:21 - green I'm going to teach you how to make
215:23 - them look 3D is next let's begin by
215:28 - drawing a line at an offset a segment at
215:32 - an offset here so inside of tree JS we
215:37 - are going
215:39 - to
215:42 - calculate the top of the
215:45 - tree as the center but adding an offset
215:49 - so it's going to be to the top left
215:52 - towards the top left this offset by 40
215:56 - on X and 4 and Y and now let's draw a
215:59 - segment from Center to
216:03 - top like this save
216:07 - refresh and you can see this it kind of
216:09 - looks like
216:11 - sticks going up from this circle but we
216:15 - are watching all of them from the same
216:17 - angle and we don't really want that we
216:20 - want the angle to change depending on
216:22 - our Viewpoint here so these should look
216:24 - like that but these should go the other
216:28 - direction so we need to know this
216:30 - direction from the Viewpoint to the
216:32 - center of the tree we're going to
216:35 - implement our 3d effect based on this
216:38 - simple fact if the Viewpoint is above
216:40 - the item the top and the bottom align
216:43 - perfectly but if they're not there's a
216:46 - bigger offset here than here let's go
216:49 - back here and do just that I'm going to
216:53 - calculate here this
216:58 - difference as the difference between the
217:02 - center and
217:04 - the a
217:06 - Viewpoint now this Viewpoint is
217:09 - something we need access to and I'm
217:12 - going to pass it here like this so the
217:16 - world needs to give it to the tree
217:20 - somehow and the world has to get it from
217:24 - somewhere so it's going to be past here
217:28 - and in index
217:29 - HTML in animate where we're doing the
217:32 - drawing this is where we calculate the
217:34 - Viewpoint and we get it from the offset
217:37 - of the viewport but it's actually the
217:39 - opposite of the offset at the view part
217:44 - so we
217:46 - do this Viewpoint is scaling the
217:52 - viewport offset by minus one and we pass
217:57 - it
217:58 - here to the world like
218:01 - that save
218:04 - refresh and um it doesn't work I think
218:08 - we forgot here to pass this
218:11 - diff here instead of our outc coded
218:15 - value there
218:17 - refresh and now we get something more
218:21 - like it it looks like these trees are
218:25 - really really tall things
218:28 - here maybe too much basically if we
218:32 - focus on this one tree here it's now
218:36 - this distance from the center and it's
218:38 - going to have this length the same
218:41 - distance as that so it's way too much
218:44 - maybe we can go with half or or even
218:48 - less so I'm going to go here inside of
218:51 - 3js and this difference I'm going to
218:56 - scale it I will type here scale the
219:02 - difference by
219:04 - 0.5 save
219:07 - refresh and now this effect is not so
219:11 - pronounced
219:13 - anymore so I think it can be even a
219:16 - little bit less and we can take this out
219:20 - and call it
219:23 - maybe height
219:26 - coefficient and this is going to be here
219:29 - a
219:30 - parameter and it will control the height
219:33 - pretty much let's set it to
219:36 - 0.3 and here height coefficient
219:41 - equals the height coefficient so that
219:44 - the tree knows how tall it is safe and
219:51 - refresh this looks about
219:54 - right now we're going to start styling
219:57 - these trees and we're going to form them
219:59 - from many levels stacked on top of each
220:03 - other we're going to go
220:05 - here and let's define our
220:11 - level count how many levels we want the
220:14 - trees to have I'm going to put seven and
220:18 - um let's loop from Level
220:23 - zero to level
220:26 - count level
220:29 - Plus+ and get a t value that we will use
220:34 - in
220:35 - interpolation so this is going to be
220:37 - between zero and one maybe should take
220:42 - special consideration here when dividing
220:44 - by zero if level count is one but I
220:48 - don't bother with that
220:50 - now and then the point that we will use
220:54 - at each of these levels is going to come
220:57 - from linear interpolation between the
221:01 - center and the top that we calculated
221:04 - previously using this T
221:08 - value and now we we can just say
221:12 - Point
221:13 - draw in the same way that we did the
221:16 - center and actually we don't need to
221:20 - draw the center anymore because it's
221:22 - already taken care of at level zero
221:26 - that's the bottommost circle now so
221:30 - let's implement this lurp 2D function
221:32 - it's actually not here yet in utils we
221:36 - have lurp but this slurp to the is
221:40 - just lurp applied on the X and Y
221:46 - components of the two
221:49 - points
221:52 - so like
221:56 - this save
221:59 - refresh and now we
222:02 - see kind of like a
222:05 - cylinder there made of seven different
222:10 - circles on top of each other let's give
222:13 - them a different color so that they come
222:16 - brighter towards the top and we go back
222:20 - here in tree JS I don't think we need
222:23 - this segment here anymore instead we go
222:27 - here and say the color is equal to and
222:31 - we're going to interpolate again using
222:34 - the simple lurp this time for just the
222:39 - green green value in this color so we're
222:43 - going to go between 50 and 200 these are
222:46 - just values that I like how they how
222:49 - they
222:50 - look and I added some values for red and
222:55 - for blue as well they are quite low
222:58 - values so they just control the shade a
223:01 - little bit and now this color we can
223:04 - actually just pass it here like so save
223:08 - refresh and now this cylinder looks like
223:12 - that next step we also interpolate the
223:15 - size so it becomes smaller towards the
223:18 - top and um we do that
223:23 - here size lurp between this size and 40
223:30 - I just chose as a value that looks good
223:32 - to me but you can play with these values
223:35 - if you want now let's pass this
223:38 - size here I I think this should work
223:41 - save
223:43 - refresh and now the trees look like
223:47 - that they start to resemble
223:52 - something like what trees are supposed
223:55 - to look like at least these kind of uh
223:57 - Christmas trees let's make them look a
224:00 - little bit more fuzzy so this is too
224:02 - abstract for my taste and we're going to
224:05 - instead of drawing perfect circles here
224:08 - we're going to draw some kind of noisy
224:10 - circles uh you'll
224:13 - see basically here instead of using
224:16 - points to define the levels we remove
224:18 - that and let's use Poes instead
224:23 - and I'm going to make a private method
224:27 - generate level one level from the point
224:31 - and with the given size and let's say
224:34 - poly. draw at
224:37 - CTX let me give here the color and I
224:41 - don't want to use any stroke style for
224:44 - the tree so I'm putting here one with
224:48 - Alpha zero and now we can go up here and
224:52 - implement the
224:54 - generate level
224:58 - method where we just draw circle like
225:02 - shape around this point with
225:07 - this size so now let
225:10 - me take points here that we will put on
225:15 - the circle shape and the radius will be
225:19 - half of the
225:21 - size and now I'm going to loop with this
225:25 - a variable for angle starting at zero
225:30 - and going all the way to 360° or 2 pi
225:35 - radians and I will increase a by Pi ided
225:40 - by 16 so this means we will have 32
225:45 - points along the circle and here we need
225:50 - to not use just a fixed radius otherwise
225:53 - it's going to be a circle but we will
225:56 - get a noisy radius where we just
225:59 - multiply the
226:01 - radius by math dot random like this and
226:06 - then we push to the points a point where
226:10 - we translate our original point at the
226:14 - given
226:16 - angle with the
226:18 - noisy
226:20 - radius like so and let's return here a
226:25 - new
226:26 - polygon with these points now save and
226:30 - refresh and uh you will see some funny
226:33 - stuff happening here maybe if we type
226:38 - debugger in the cons so we get a better
226:40 - idea of how these trees look like
226:43 - because the radius now is between zero
226:46 - and the tree size you get these spiky
226:48 - spiky look to the
226:50 - trees I guess it could be okay but I
226:54 - don't like it that much instead what
226:56 - we're going to do is add a lurp here
227:00 - between 0.5 and one so that we just get
227:04 - the upper half of random pretty much so
227:09 - between 0.5 and one are the random
227:12 - values if we
227:14 - do this save and
227:19 - refresh and now this looks more like
227:23 - what I want but of course they shouldn't
227:25 - be fidgeting like this
227:27 - and this is an annoying situation here
227:31 - because many programming languages do
227:33 - have a way to Generate random numbers
227:35 - with a fixed seed and you could do that
227:38 - fairly easy
227:40 - but not in JavaScript so I had to come
227:43 - up with something that generates kind of
227:47 - random numbers but always the same thing
227:50 - for each tree so that when redrawing it
227:54 - doesn't re generate the tree like
227:58 - that and I have a quick fix here for
228:03 - that so my kind
228:07 - of random number that I will generate
228:11 - comes from this very
228:14 - simple
228:16 - mathematical
228:20 - formula
228:23 - okay and now we pass it
228:26 - here instead of this actual
228:29 - random save
228:32 - refresh and now the trees don't shake
228:36 - like that anymore so this formula
228:39 - is um I'm not going to go too deep into
228:43 - it but cosine gives you a value between
228:47 - minus one and one square the cosine is
228:50 - going to give you a value between 0 and
228:53 - one so same as the random that we had
228:56 - previously and inside of this
228:59 - cosine I mixed together the
229:04 - angle with the center of the tree and
229:07 - with the sze and what this means is that
229:10 - each level of the tree is going to look
229:12 - a little bit different because the size
229:14 - contributes to it each part of the level
229:21 - according to the angle is going to look
229:23 - different because a contributes to it
229:25 - and I'm also offsetting a by this Center
229:29 - X location of the tree so that two trees
229:33 - don't look the same if you remove for
229:36 - example this part here all of the trees
229:39 - will look the same if I remember right
229:43 - let's save and
229:46 - refresh so you can see all of them have
229:49 - here this Spike Spike Spike spike
229:52 - because the center location doesn't
229:55 - affect in any way and same goes for
229:57 - other values I also have some hack here
230:00 - with remainder when dividing by 17
230:03 - because it's a prime number and also it
230:07 - adds a little bit of fuzziness to the
230:09 - result but still if you save and refresh
230:13 - you will see that there is some kind of
230:16 - pattern to how these trees are being
230:18 - generated they are not exactly the same
230:21 - but they do have some similarities like
230:24 - maybe two of these thicker branches here
230:28 - and here and here and all of them kind
230:32 - of seem to have that you can find some
230:35 - pattern there these are not really
230:37 - random numbers they are just random Mish
230:41 - numbers and they are influenced a lot by
230:43 - how the cosign looks like so that's why
230:46 - you get this periodic change there
230:49 - anyway it's just a function I mushed
230:52 - there together to get this to work
230:54 - alternatively you could also save these
230:57 - levels when you generate the tree and
231:00 - then just draw it but I didn't want to
231:03 - bother with that it would have been more
231:04 - work explaining
231:06 - things now one thing that we could have
231:09 - here in the Constructor is also defining
231:14 - the base of the tree so I'm just going
231:17 - to call here generate level at the
231:21 - center and with the size this is already
231:25 - happening here when level is zero but
231:28 - now I'm storing that as the base of the
231:31 - tree and this is
231:33 - important because this base of the tree
231:36 - is something that the car
231:39 - May interact with like if it hits this
231:42 - base of the tree then it hits the tree
231:44 - pretty much so the base is giving us
231:48 - segments here on the side of the tree on
231:51 - the bottommost level that we could
231:55 - use now I'm going to remove this it's
231:57 - just for debugging so you see what the
231:59 - base was and we're going to continue to
232:03 - generate the buildings next so let's
232:07 - close this tree and the details and in
232:10 - World
232:12 - JS here this is the end of the generate
232:16 - buildings method instead of just having
232:19 - the bases of the buildings those
232:22 - polygons we are going to map
232:26 - these to new
232:30 - buildings as well and we're going to do
232:33 - very similar things for the buildings
232:35 - starting with let's fix the situations
232:39 - where buildings were poly
232:43 - previously so in the
232:46 - generate trees method here we are using
232:50 - the buildings as Poes we are accessing
232:53 - here the points directly but the
232:55 - building will also have a base like we
232:59 - added for the trees just now and that's
233:02 - how we will get the points from now on
233:06 - and also here illegal poies it's not
233:10 - just getting the buildings those are
233:12 - going to be new objects so what we do
233:15 - here is take out just the base from
233:19 - these buildings and now we have the Poes
233:23 - here to work with in the draw method
233:27 - below we also have to pass this
233:30 - Viewpoint to the buildings they'll also
233:33 - have a 3D look and let's go to index
233:37 - HTML
233:39 - and include the building similarly as we
233:42 - include the tree
233:44 - here building JS inside of items here
233:50 - where the tree
233:52 - is
233:53 - building JS and let's define the
233:56 - building class
233:59 - so simple class with the
234:03 - Constructor getting a poly for the base
234:07 - and a height
234:09 - coefficient let's set it 0.4 a little
234:12 - bit taller than the trees just to see
234:15 - how it looks like and now let's store
234:19 - this base
234:22 - here and the height
234:27 - coefficient and uh write a simple draw
234:30 - method CTX and the
234:33 - Viewpoint and
234:36 - draw the
234:37 - base and the context and let's make it
234:43 - white and uh grayish light gray stroke
234:49 - so let's just debug to see if our
234:52 - refactoring caused any issues save and
234:57 - refresh and now the buildings are white
235:01 - but no 3d effect just
235:04 - yet for that I'm going to go here at the
235:07 - top and calculate the top points on the
235:11 - ceiling of the
235:13 - building
235:15 - so top
235:18 - points is taking the base
235:24 - points and remapping each point to
235:28 - something else and here we type add this
235:34 - point scale
235:37 - subtract p
235:41 - Viewpoint this height
235:46 - coefficient like so and the ceiling is
235:50 - going to be a new
235:54 - polygon from these top points this
235:58 - formula here is the same that we used
236:01 - here in 3js but it's divided so we have
236:06 - first add scale SC and then this diff is
236:11 - subtract of that
236:14 - so add scale
236:17 - subtract it's the same thing now let's
236:20 - draw the ceiling as well I'm going to do
236:23 - the same thing as with the base but the
236:27 - ceiling save and
236:30 - refresh and now you can see that
236:34 - floating ceiling there over the
236:37 - buildings
236:39 - over the building base let's do the
236:43 - sides as
236:45 - well I'm going to go here after we have
236:48 - the
236:49 - ceiling and the
236:54 - sides are going to be polygons as well
236:57 - and we will make these sides by
236:59 - connecting two points two consecutive
237:02 - points from the base with two
237:04 - consecutive points from the ceiling but
237:07 - in reverse order in the ceiling you'll
237:10 - see
237:14 - so we do
237:18 - this looping through all the
237:22 - points like that and let me just write
237:26 - here next I for I + one basically but
237:31 - also make it loop around so I'm going to
237:36 - take the reminder when
237:39 - considering the length of this array so
237:42 - the last point is going to have next the
237:46 - first point in this polygon of the base
237:50 - and now let's generate these sides one
237:54 - by one inside of this for Loop so it's
237:56 - going to be a
237:58 - poly new
238:01 - polygon like this and first
238:05 - point base points of IE and then base
238:10 - points of next
238:13 - eye and then the ceiling points but
238:16 - they're already in that top points and
238:18 - it's shorter to right so top
238:22 - points next eye and top
238:26 - points I so basically bottom and then
238:30 - top reverse and let's add this poly to
238:34 - the
238:36 - sides and now before drawing the ceiling
238:39 - we're going to go here and draw all the
238:43 - sides one by one let me just copy this
238:48 - here and this is side I'll use the same
238:53 - style save and
238:57 - refresh and
239:00 - um some things look really good like
239:03 - this but some of them look like these I
239:07 - don't know empty boxes here and some are
239:11 - even over the other ones it's um a
239:15 - little bit confusing what is going on
239:18 - but uh the thing is this side here it's
239:23 - being drawn and after that this side
239:28 - here it's being drawn so you see this
239:32 - line from this side on the right on top
239:35 - of this side that should actually block
239:38 - that side on the
239:40 - right this means that we need to draw
239:42 - these sides in a way that makes sense
239:46 - the backmost ones first and then the
239:50 - front ones second so we will sort the
239:54 - sides of this building so that the
239:57 - further away ones are going to be in the
240:00 - beginning they get drawn first and then
240:02 - the closest ones to this Viewpoint are
240:06 - going to be second
240:08 - we do that
240:12 - here calling
240:14 - sort and the call back function will be
240:18 - this one uh comparison function that
240:20 - takes a and b to polygons this time and
240:26 - we write the result to be distance to
240:30 - point to the
240:32 - Viewpoint minus a distance to
240:37 - point
240:39 - Viewpoint so we're sorting all of the
240:42 - sides all of the polygons according to
240:45 - the distance to the viewpoint but
240:47 - because we write it in this way with B
240:49 - uh first and a second it means that we
240:52 - sort in reverse order so the closest
240:56 - ones are going to be the last ones to
241:00 - draw let's save and
241:04 - refresh and now you don't see that
241:07 - problem that kind of
241:08 - empty box look anymore but we still have
241:11 - some problems like this building being
241:14 - drawn before this
241:16 - building the same logic goes here for
241:19 - the buildings as well but we're going to
241:21 - use the base poy to decide which
241:25 - building to draw first and actually
241:28 - trees as well so here the tree goes
241:32 - underneath the building so we need to
241:35 - group trees and buildings together and
241:38 - do this
241:39 - sorting via their
241:42 - base at the same time to get the 3d
241:46 - effect to work so I'm going to go back
241:49 - to World JS here and let's combine these
241:54 - items into one array I'm going to write
241:58 - here
241:59 - items
242:01 - buildings and
242:05 - trees and let's pass here
242:09 - items and this is
242:12 - item
242:14 - item we don't need the second Loop
242:16 - anymore because we're now drawing them
242:18 - with the single Loop let's just see if
242:21 - this works it should be so that now the
242:23 - trees are over the buildings because
242:26 - they are drawn later save
242:31 - refresh so yeah same problems as before
242:35 - but now trees are over the build
242:38 - buildings so let's do that sorting now
242:41 - for these items here and it's the same
242:45 - thing
242:47 - really sorting the items same kind of
242:51 - function but now we tell the
242:58 - Poes the base of these objects to
243:01 - calculate the distance to the
243:05 - point save and the refresh
243:11 - and now this looks
243:15 - proper you can see this tree here
243:18 - between this building and this other
243:20 - building quite nicely and it changed
243:23 - relationship now so now
243:26 - it's drawn before this
243:30 - building now it's drawn after this
243:33 - building so this works just fine you can
243:36 - see sometimes these uh weird lines here
243:38 - but these are actually from the graph
243:41 - editor um it's not any glitch or
243:44 - anything like that they won't appear
243:47 - when we just use the world without the
243:49 - editor
243:51 - showing now you can style these however
243:54 - you want you can go further and make
243:57 - them look even nicer I will have a
244:00 - special video for channel members and
244:03 - they will get to see how I made them
244:05 - have roofs and also how to make a more
244:09 - realistic 3d effect because this one if
244:13 - you pay attention what happens here
244:16 - these buildings just get taller and
244:18 - taller like that and if your viewport is
244:20 - bigger and bigger they will just look
244:24 - really crazy so something is not right
244:27 - here you shouldn't exceed a size when
244:30 - looking at the building like this and
244:33 - the building should have a proper height
244:35 - not a height coefficient what whatever
244:38 - that meets so I will have a special
244:42 - video for that it's not going to be very
244:44 - long so not too much content in it but
244:48 - uh the code from that I will put now and
244:51 - mix it together with this one and you
244:54 - can look at it afterwards and selfstudy
244:57 - it even if you don't watch that video
244:59 - the worlds we can create now are much
245:02 - more complicated than that straight line
245:04 - we had in phase one but adding some
245:06 - traffic rules here will really give us a
245:09 - lot of flexibility in phase three we'll
245:11 - be able to teach the car all kinds of
245:13 - things because our world is really 2D
245:17 - apart from these tricks here we will
245:19 - enforce these rules as markings on the
245:21 - road I'll show you a clever way of
245:24 - adding the markings so they snap to the
245:26 - road and always have the correct
245:28 - orientation we're not going to have our
245:31 - users worry about things like that they
245:33 - should work as little as possible to get
245:36 - something nice try remember that as the
245:40 - general rule we're going to start adding
245:43 - markings to the world and we'll begin
245:46 - with stop markings but to do this we're
245:49 - going to need another editor um a stop
245:52 - editor and a way to change from the
245:56 - graph editing mode to the stop editing
245:58 - mode I'm going to do that here by adding
246:02 - two buttons for that they're going to be
246:04 - mutually
246:06 - exclusive let's start by adding an empty
246:10 - space to separate from the save and load
246:12 - functionalities and the first button
246:15 - it's going to have an ID this time
246:18 - because we're going to change the way it
246:20 - looks soon in
246:21 - JavaScript and uh we need to access it
246:24 - and when we click we're going to set the
246:27 - mode to the graph so this will enable
246:30 - the graph editing
246:33 - tools and the second button is going to
246:36 - have an ID stop BTN and onclick it's
246:41 - going to set the mode to
246:46 - stop let me close this tag and I'm going
246:50 - to style these buttons using emojis
246:53 - again for the graph and one for the Stop
246:57 - like this let's save and
247:01 - refresh the buttons are here but uh
247:05 - let's style the buttons a bit better
247:07 - they have this default view and I don't
247:10 - really like it let's make them bigger at
247:12 - least in
247:14 - Styles I'm going to add a style for the
247:19 - buttons let's put the background color
247:23 - white for maximum contrast and the font
247:27 - size 20
247:30 - pixels
247:32 - refresh and they're bigger but I would
247:34 - like them to look Square as well and I
247:38 - found that adding here a padding of
247:43 - 5775 does the trick
247:47 - refresh and it's fine but this border
247:50 - here that the button has is a little bit
247:53 - uh nerdy and I will remove it and also
247:56 - add rounded Corners as well so here
248:00 - border set to none and Border
248:05 - radius
248:06 - five and
248:09 - refresh looks much better now this
248:12 - button and maybe this one too the
248:14 - contrast is not so good it's not so easy
248:17 - for me to see this button I'm going to
248:19 - add also a drop shadow on the bottom
248:22 - right so let's have a text Shadow one
248:27 - one
248:29 - black and I like buttons to have this uh
248:34 - hand cursor when you're hovering them so
248:36 - let me add all also here this
248:39 - cursor pointer save and
248:43 - refresh and now this looks good and
248:47 - feels good I think but pressing them
248:50 - does nothing this set mode is not
248:53 - defined yet so let's define it I'm going
248:56 - to go in index HTML here at the bottom
249:01 - and say set
249:03 - mode and the first thing that it will do
249:07 - is is
249:09 - disable any editor all the editors
249:12 - disable everything and then we're going
249:14 - to have a switch case that will enable
249:17 - the one with the given mode but let's
249:20 - handle first this disable editors and
249:23 - only visually so make the buttons look
249:28 - disabled if they are disabled and I'm
249:31 - going to start with the graph button and
249:33 - give it a gray background color and I'm
249:37 - also going to remove the colors in the
249:39 - Emojis by passing a
249:43 - grayscale
249:47 - filter with the 100% like this and this
249:51 - we have to do also for the Stop button
249:54 - so stop
249:58 - button and stop button now if we save
250:02 - and refresh press one of these buttons
250:05 - no more error there and both them are
250:08 - disabled now because this set mode was
250:11 - called so after they're disabled let's
250:14 - enable the one that has been clicked
250:17 - depending on this mode so switch
250:20 - depending on the mode if it was the
250:24 - graph I'm going to set the background
250:27 - color of the graph button back to
250:33 - White and
250:35 - remove the filter
250:40 - as well and let's break now I will copy
250:43 - this also for the
250:47 - stop using the stop
250:51 - button stop button save and refresh and
250:57 - clicking on them now
250:59 - toggles the behavior but when we refresh
251:03 - the page one of them should be selected
251:05 - and I'm going to enable this
251:07 - graph by default so I will go above here
251:13 - where we before we start the animation
251:16 - Loop and I will type set
251:20 - mode graph and now we can start talking
251:23 - about the functionality as well not just
251:26 - the look and feel so what we want to
251:30 - happen here in set mode is
251:33 - to enable the graph editor if we Press
251:37 - On the graph button and let's add this
251:40 - functionality to our graph editor it
251:43 - doesn't have it
251:45 - yet enable and here disable editors it's
251:50 - also going to need a way to disable
251:55 - it let's save and go inside
252:00 - our graph editor and the first thing
252:03 - we'll do is remove this call to adding
252:07 - event listeners because we want that to
252:11 - happen in the enable method so
252:15 - enable we add event
252:20 - listeners like this and then the disa is
252:24 - going to
252:27 - remove event
252:31 - listeners like
252:33 - that remove event listeners should look
252:36 - very much like ad event listeners but
252:39 - with
252:40 - remove in all of
252:44 - these parts so
252:48 - remove like this let's save and
252:53 - refresh and now we are able to edit the
252:58 - graph here to create a graph and when we
253:01 - switch to the stop editing mode which
253:03 - doesn't yet exist but it should disable
253:06 - the graph
253:08 - editor we still can edit the
253:13 - graph the problem is here when we add
253:17 - event listeners and we call bind on
253:21 - this method it creates a new method
253:26 - where this inside of it is
253:29 - this so remove event listener expects to
253:33 - get the exact same thing here when
253:35 - removing it not to create a new copy of
253:39 - handle Mouse down with this bound into
253:42 - it this is a problem and we're going to
253:45 - need to fix it and the best way I know
253:47 - how is just to store this version of the
253:50 - function here as an attribute and then
253:53 - use the
253:54 - attribute here and here so hopefully you
253:59 - get the point I'm going to store here
254:02 - the bound Mouse
254:04 - down function and let's just copy this
254:08 - from
254:12 - here and now put
254:15 - this
254:17 - here and
254:22 - here the second one is going to
254:25 - be bound Mouse
254:30 - move and we're going to cut this from
254:35 - here and copy
254:38 - this
254:40 - here and
254:42 - here and we have to do something for
254:45 - these as well because they're Anonymous
254:47 - functions so actually here we create a
254:49 - function and here it's another function
254:52 - they just do the same thing but it's not
254:55 - the same function that we want to remove
254:57 - here as well
255:00 - so let's do the mouse up is
255:06 - next
255:07 - Mouse up is um I have it here the last
255:11 - one let's actually rearrange these
255:16 - because I think it's more logical to
255:19 - have the order like this with the mouse
255:23 - Events first and then this context menu
255:25 - at the end and let me cut
255:30 - this here and now we pass this here and
255:36 - here
255:38 - here and finally context
255:43 - menu context menu I think could be also
255:46 - removed forever we never really need the
255:48 - context menu in this application but uh
255:52 - I'm not going to bother with that now I
255:54 - just keep this consistent and make sure
255:58 - that all the listeners are added and
256:00 - removed like
256:04 - this now
256:05 - save refresh try to add the
256:10 - graph change to this
256:14 - stop try to add more
256:17 - points and it doesn't work we can't
256:20 - select points we can't do anything with
256:22 - the graph anymore now but if we reenable
256:27 - it we can and disabling it
256:32 - again has this weird artifact now
256:35 - because we still have a select point
256:37 - there so I'm going to go here where the
256:41 - disable is and let's pass also selected
256:46 - is
256:47 - false and hovered is
256:51 - false save
256:54 - refresh and let's
256:56 - try one more
256:59 - time when pressing this that line
257:02 - disappeared so no more problem and we
257:06 - can can actually Define a new graph here
257:09 - to use because it's time to implement
257:13 - the stop marking as
257:17 - well and we should add stops on
257:21 - something I'm going to keep this format
257:23 - now let's save it so when we refresh it
257:26 - loads this graph now and we can begin to
257:29 - implement the stop editor we're going to
257:33 - go in index
257:35 - HTML and um
257:37 - it's going to work pretty much like this
257:39 - graph editor Let me just copy this
257:43 - instantiation here and say stop editor
257:47 - is a new stop
257:49 - editor but adding the stop markings on
257:53 - the road is going to need some
257:54 - information about the road itself not
257:56 - just that graph so how big the road is
257:59 - and something like that so we're going
258:02 - to pass here instead of graph world for
258:06 - this one
258:08 - otherwise um here when we do the display
258:11 - for the graph editor we're also going to
258:14 - have a display for our stop
258:17 - editor dispose I'm not going to deal
258:20 - with this now we will handle it a little
258:22 - bit later but then here this enable
258:27 - needs to happen here for the stop as
258:33 - well and the disable here
258:40 - let's implement the stop editor in a
258:43 - separate file and we will have more
258:46 - editors now so I'm going to move graph
258:50 - editor and the stop editor into a new
258:52 - folder let's call this
258:57 - editors and I'm going to move this
259:01 - editors here above the items so that
259:04 - these files that are directly in
259:06 - JavaScript are grouped together and
259:09 - let's copy this graph editor with
259:13 - a stop
259:15 - editor and create now the new folder
259:19 - injs called
259:22 - editors move graph editor inside it and
259:26 - create the new file stop
259:30 - editor JS next to it now this
259:34 - functionality will be quite similar to
259:37 - the graph
259:38 - editor so we will be copying some things
259:41 - from there but let's first handle this
259:43 - Constructor passing the viewport and the
259:46 - world which is a little bit different
259:49 - and store the
259:52 - viewport and the world as object
259:59 - attributes
260:00 - and also add here a reference to the
260:03 - viewport canvas and and a reference to
260:08 - the
260:11 - context stop editor will also have a
260:14 - display method and these items will come
260:17 - in handy for that now let's go to graph
260:20 - editor and I'm going to copy enable
260:25 - disable and adding removing the event
260:29 - listeners I think they are pretty much
260:32 - the
260:34 - same like this but but um this selected
260:38 - and hovered will make no sense here and
260:41 - we actually won't have a mouse up event
260:45 - listener this editor is going to be
260:48 - simpler than the graph editor so Mouse
260:51 - up won't be needed and we won't be
260:54 - dragging
261:00 - anything and let's begin to implement
261:03 - this mouse move private method here
261:07 - handle Mouse move I'm going to copy it
261:10 - from graph
261:17 - editor here and to begin with I want to
261:21 - win hovering the mouse over some of
261:25 - these segments to highlight that segment
261:29 - the thing is these stops will be added
261:33 - on the roads themselves so we're going
261:35 - to use them as guides otherwise it's
261:38 - going to be very difficult to place that
261:42 - stop exactly at the location and the end
261:45 - result won't look good so we're going to
261:47 - use the segments that exist already as
261:51 - some kind of guides and our interface
261:54 - for using this stop editor is going to
261:56 - be much easier to use much more user
261:59 - friendly so we begin by finding what is
262:03 - the nearest segment where we want to add
262:05 - this stop
262:07 - on so this get nearest point is going to
262:10 - change to a get nearest
262:13 - segment and we're going to store that
262:16 - segment in a
262:20 - constant get
262:22 - nearest
262:24 - segment and here let me align these a
262:28 - little bit better they go out of the
262:31 - screen and it's going to use the graph
262:35 - segments but here we don't have this
262:39 - graph directly we have the world so the
262:43 - graph is part of this
262:46 - world
262:49 - graph segments like this and this
262:52 - dragging part we don't need
262:55 - it what we do need to do is check if we
262:58 - do get a segment if there is a nearest
263:01 - segment under this threshold and if
263:03 - there is I'm going to Define
263:07 - find an attribute called intent again I
263:10 - want to show where the marking would
263:13 - appear if we would click the
263:16 - button so the intent for now is going to
263:20 - be the segment itself otherwise it's
263:23 - going to be
263:26 - null like this and let's take out Mouse
263:30 - and intent as attributes up here as
263:35 - well
263:42 - now to see this intent we need to
263:44 - implement the display method as
263:50 - well if there is an
263:54 - intent I'm just going to draw it on the
263:58 - context with
264:01 - default
264:03 - styling and we still need to implement
264:05 - this yet nearest segment function it's
264:09 - going to be in math utils at the top
264:13 - next to the first function we
264:15 - implemented in this file which was get
264:17 - nearest point and now we're also going
264:20 - to have get
264:22 - nearest
264:24 - segment which takes the location and a
264:27 - list of
264:28 - segments same threshold and here we Loop
264:32 - through each segment of
264:37 - segments and when we calculate the
264:39 - distance we can't use this Pythagorean
264:42 - theorem implementation to get the
264:44 - hypotenuse we have to call from the
264:47 - segment the distance to point instead
264:53 - and here the nearest will not be a point
264:55 - it's going to be the segment that has
264:58 - been found with the smaller distance
265:00 - again and again eventually leading to
265:04 - the one with the smallest distance
265:07 - now if we save and
265:09 - refresh we get an error here in the stop
265:12 - editor because it doesn't have yet a
265:16 - handle Mouse down method
265:19 - so let's just add an empty one here for
265:23 - now we will handle it
265:26 - later save and refresh and switch to the
265:31 - stop
265:33 - editor and now you can see that segment
265:36 - being highlighted the nearest segment to
265:38 - our Mouse location it's not a strong
265:42 - highlight but there is a
265:44 - highlight so I want the stop to be
265:48 - generated at the location centered
265:51 - exactly on that segment so next thing
265:54 - we'll do is Project our Mouse location
265:57 - on that nearest segment if there is a
265:59 - nearest segment here to get one point
266:02 - the center of the stop marking for that
266:06 - will go here when we have the segment
266:09 - available and I'm just going to
266:13 - project the point on the
266:18 - segment by doing this and the projection
266:22 - may also fall outside of the segment so
266:25 - that would be a weird uh error there and
266:29 - I'm going to check here if the offset is
266:31 - really between zero and one so if the
266:34 - projected Point Falls indeed on the
266:36 - segment not on the support line and in
266:40 - this case the intent is going to become
266:42 - the projected Point otherwise it's going
266:47 - to be null
266:51 - again save refresh switch to the stop
266:57 - editor and now we get a point there and
267:01 - we don't have to worry about is the
267:03 - mouse exactly there or not it's always
267:06 - going to be perfectly centered just as
267:08 - we want
267:09 - it and now it's time to define the
267:12 - marking itself so it's going to be a
267:15 - polygon but I'm going to have a
267:17 - specialized object for it a stop object
267:21 - for storing and drawing the stop
267:25 - marking so here we're going to need to
267:28 - pass
267:30 - some properties to that the first one is
267:35 - going to be
267:37 - the point itself so as before but I want
267:40 - the marking to orient nicely according
267:43 - to the segment that it's on so I'm also
267:48 - going to pass here the direction Vector
267:51 - of this segment and then a width and
267:54 - height I want the width to span the
267:56 - whole Road really and the height let's
268:01 - just use a factor of that like half the
268:03 - road width at least for now
268:06 - now to Define this stop marking we go to
268:09 - index
268:10 - HTML and we're going to do that in uh
268:13 - folder called markings so let me just
268:17 - copy maybe viewport here and say
268:23 - markings stop let's close some of these
268:28 - folders here and create a new one in
268:33 - JS
268:34 - markings
268:36 - and in it our
268:38 - file stop JS like this the stop class is
268:44 - also going to be quite simple but the
268:47 - Constructor has four parameters now so
268:50 - it's the center location the direction
268:54 - Vector the width and the
268:58 - height of this
269:03 - polygon let's store these as attributes
269:07 - and then generate that
269:10 - polygon
269:16 - somehow so the direction Vector is
269:18 - already
269:22 - normalized which is
269:25 - nice and height and now first thing for
269:30 - that polygon I'm going to get a support
269:33 - and it's going to be on the segment and
269:35 - and height half of the height towards
269:38 - the front of the segment and half of the
269:41 - height towards the back of the segment
269:44 - so we are going to Define this support
269:48 - as a new segment relative to this center
269:52 - location by translating Center at the
269:56 - angle of this direction
270:00 - Vector half the
270:03 - height and the second point
270:06 - is going to be the same but at a
270:10 - different angle the opposite angle you
270:12 - can either add um Pi here or say that
270:16 - you want to
270:17 - translate opposite way with the minus
270:20 - here let's debug and implement the draw
270:23 - method for this stop where we just draw
270:27 - this um support for
270:31 - now save refresh change to the stop
270:36 - editor and hard to see but it's there
270:41 - this support Vector with half the road
270:45 - width as its
270:48 - height let's convert it into a polygon
270:51 - and to do that I'm going to really use
270:55 - the envelope trick again so we Define a
270:59 - new envelope with this
271:02 - support vector and the width parameter
271:06 - and no roundness I don't need any
271:09 - roundness here and just take the poly
271:12 - from this envelope
271:15 - object and we debug Now by drawing this
271:18 - poly instead save refresh select the
271:22 - stop
271:23 - editor and there it
271:28 - is and I just realized that I don't want
271:31 - this stop marking to be the whole Road I
271:36 - want it to be just on half of the road
271:38 - here for the cars that go this way and
271:42 - they need to stop in this
271:43 - intersection so we're going to need to
271:46 - fix that but this is still useful this
271:50 - could be another marking like maybe the
271:53 - crossing it's pretty much exactly what
271:56 - the crossing should look like but for
271:58 - the stop marking we need some other
272:01 - guides not these graph
272:04 - segments we need something
272:07 - here in the middle between the borders
272:10 - of the road and the graph segment so
272:14 - let's define those new Lane guides the
272:18 - middle of the lane the right lane and
272:20 - the left lane so they will be Lane
272:24 - guides in the stop
272:26 - editor instead of using these we will
272:30 - pass
272:31 - Lane
272:33 - guides and we have to to go to world JS
272:37 - and Define
272:38 - them I will store them here as an
272:46 - array and Below generate here we're
272:50 - going to need the function to generate
272:52 - them it's a private method generate Lane
272:56 - guides and I'm going to use the same
273:00 - trick that we used with the generating
273:04 - buildings with these
273:07 - envelopes so I will copy this here as
273:11 - well these envelopes will be
273:17 - actually half the road WID like this and
273:23 - now we're going to take the union again
273:27 - so avoid those intersecting
273:33 - Parts as before
273:38 - by considering the poly of every
273:41 - envelope and just returning these
273:44 - segments we call this method
273:47 - here and um same as we did with the
273:50 - envelopes before let's empty the lane
273:54 - guides if they exist from a previous
273:59 - rendering and
274:01 - then push I'm just going to spread here
274:05 - the result of generate Lane
274:09 - guides push can actually push multiple
274:12 - things if you pass them individually not
274:15 - as an not as an
274:17 - array and let's quickly debug that these
274:21 - look as they should I'm just going to go
274:23 - here at the end of the draw method and
274:29 - say looping through all of the lane
274:33 - guides segments
274:37 - drawing them in
274:40 - Red Save and refresh and they look good
274:46 - and now when we switch to the stop
274:49 - editor you can see it's centering now on
274:52 - these um Lane guides but the width
274:56 - should be smaller so going back to the
274:59 - stop
275:00 - editor Road width divided by two save
275:05 - refresh switch to the stop
275:09 - editor and now it's good let's remove
275:12 - these
275:17 - guides and start styling our stop
275:21 - marking here I'm going to draw a rotated
275:25 - text saying stop so for that we need to
275:29 - do the translate and rotate trick we
275:34 - first translate to Center X and Center
275:40 - Y and then rotate by the angle of this
275:45 - direction
275:47 - Vector let's begin a
275:50 - path and I'm going to style the text
275:54 - by centering the basine and
276:00 - also horizontally way like this and it's
276:05 - going to be a white
276:08 - text and it will
276:11 - say stop at 0 0 because this translate
276:16 - is already moving us to where we need to
276:18 - be and rotate helps us out as well now
276:22 - let's remember to restore to the
276:25 - original state without these
276:26 - translations and rotations save refresh
276:31 - select the stop editor and you can see
276:35 - now this stop text appearing there but
276:38 - it should be rotated so I'm going to
276:41 - subtract half pi from that and um let's
276:46 - make it also
276:48 - bigger here we
276:52 - subtract
276:53 - 90° and um let's set the font
276:59 - size to be a fraction of the
277:03 - height I I think this should look
277:07 - good save refresh stop
277:12 - editor yeah let's make it bald as
277:20 - well refresh stop editor and good and
277:25 - typically these markings are stretched a
277:27 - lot when they're displayed under the
277:29 - road so that when you're driving and
277:31 - they are stretched like this you
277:33 - actually see them
277:35 - normally somehow unstretched while
277:38 - driving so let's do that as well here
277:42 - after we rotate I'm going to scale this
277:46 - not horizontally but vertically by a
277:49 - factor of two and vertically here means
277:52 - in the new frame of reference after
277:54 - rotating so save refresh stop
277:59 - editor I think we can do even even more
278:02 - maybe
278:03 - three refresh
278:05 - stop
278:07 - editor and uh for some reason it doesn't
278:10 - align exactly how I want it I'm going to
278:13 - give it an
278:15 - offset
278:19 - here and now it's
278:21 - good let's draw also the line on top of
278:25 - it that's the line that the cars
278:27 - shouldn't um shouldn't cross so that's
278:30 - going to be the Border here I will store
278:33 - it as an attribute because this border
278:35 - is really important for the cars to know
278:38 - about so let's put it here at the top
278:43 - and it's going to be the first segment
278:45 - of the
278:47 - poly and now drawing this we don't need
278:51 - to draw the poly anymore it was there
278:53 - just for
278:55 - reference and this one we style I'm
278:59 - going to give it thickness five and
279:03 - white like the rest of the marking save
279:08 - refresh stop
279:10 - editor oh it's not that segment it
279:14 - should be the other one so uh segments
279:17 - of two refresh stop
279:21 - editor that's how we want it but we want
279:24 - to add it not just see this intent here
279:28 - so let's do that next and um we're going
279:32 - to need to go to the stop editor Mouse
279:35 - down and start to implement it so if we
279:39 - are going to press left
279:45 - click
279:47 - left
279:48 - click and if we have an intent
279:53 - here then
279:56 - markings
279:58 - push this intent and I'm going to also
280:02 - delete this intent set it to null
280:06 - in case somebody presses multiple times
280:08 - in the same spot now for this markings
280:11 - I'm going to do a trick here and say
280:16 - that this markings comes from the
280:20 - world markings taking advantage of
280:24 - references here World markings doesn't
280:27 - exist yet so we need to go to world at
280:30 - the top and the world is going
280:33 - to contain
280:36 - markings it's going to be an empty array
280:39 - in the beginning and then in the draw
280:44 - method after drawing these um envelopes
280:49 - the gray
280:50 - F I'm going to draw the
281:00 - markings like
281:03 - so save refresh stop editor and now
281:08 - clicking actually adds the stop there at
281:12 - the
281:14 - intersection now saving doesn't work yet
281:17 - if we save nothing really happens except
281:20 - for saving the graph structure for the
281:24 - markings we're going to have to do
281:26 - something else we're going to implement
281:28 - saving for the markings and actually for
281:31 - the whole world a little bit later it
281:34 - makes sense to group everything together
281:37 - in one one spot but for now we can test
281:40 - them by just still using these uh
281:43 - buttons and and clicking it's not too
281:45 - much trouble I think we added markings
281:49 - how about removing them as well maybe on
281:52 - right
281:53 - click so let's go back to our stop
281:59 - editor and here on Mouse
282:03 - down
282:05 - if the event button is two so the right
282:12 - click we are going to look through all
282:15 - of the
282:21 - markings one by
282:24 - one get the
282:26 - poly of that marking
282:30 - for ease of use and check to see if we
282:34 - clicked inside the poly so if we clicked
282:37 - inside the poly of any marking that
282:39 - marking will be removed so if poly
282:43 - contains Point our Mouse
282:47 - location we
282:53 - splice at
282:55 - I one element we remove it and
283:00 - um now we can just return we don't have
283:03 - to do IUS minus here because we return
283:07 - anyways save refresh stop editor add
283:12 - some
283:13 - stops and remove some
283:17 - stops seems to work but one thing that
283:19 - we should still deal with is um this
283:24 - thing deleting the graph leaves the
283:27 - markings there let's clear them as well
283:31 - so going to index HTML l in our dispose
283:36 - function I'm also going to say World
283:41 - markings length is zero and now if we
283:45 - save refresh stop editor add some
283:49 - markings
283:51 - here and then we
283:54 - remove they all go away one thing that
283:57 - you probably have
284:00 - noticed is that markings can exist
284:04 - without the
284:06 - graph
284:08 - or outside of the graph like this I
284:12 - won't bother with
284:14 - that they are not tied to the graph in
284:17 - any way users should just add those
284:20 - markings after they are happy with the
284:23 - graph structure and in a way it's kind
284:25 - of what happens in the real world as
284:27 - well you may end up with markings in
284:30 - some strange locations for weird reasons
284:33 - I tried coming coming to A solution that
284:35 - is more friendly with this part but it
284:38 - was way too much trouble to teach it and
284:41 - um I gave up instead I'm going to show
284:44 - you how to add some other markings so
284:47 - let's make Crossings Road Crossings next
284:52 - and the way we'll do that is pretty much
284:55 - the same that we did everything up till
284:58 - now for the Stop we have to do it again
285:01 - for the crossing and after that we are
285:04 - going to have a step where I'm going to
285:06 - teach you about refactoring and see the
285:09 - similarities between those and remove
285:11 - the duplicate code you'll
285:14 - see so here let's copy this stop button
285:19 - and call it
285:22 - Crossing button set mode to
285:26 - Crossing and I will put here an emoji of
285:30 - this person
285:32 - walking and now every time this stop
285:35 - button is used I'm going to look for
285:38 - that and
285:40 - enter another entry for the
285:45 - crossing
285:46 - crossing BTN Crossing BTN we will have
285:52 - also a Crossing
285:55 - editor Crossing editor
285:58 - enable and then here this
286:03 - code Crossing
286:06 - BTN Crossing
286:09 - BTN
286:11 - Crossing editor let's look also for this
286:14 - stop editor it has been also used here
286:18 - with this display
286:21 - so Crossing
286:27 - editor
286:29 - display and of course here where we
286:31 - initialize it to uh new Crossing
286:39 - editor
286:40 - Crossing
286:44 - editor and importing the file so I'm
286:48 - going to copy this stop editor here and
286:52 - say Crossing
286:55 - editor and marking stop we will copy it
286:59 - to
287:00 - markings
287:02 - Crossing and in instead of making new
287:05 - files for crossing and Crossing editor
287:07 - I'm just going to Copy Stop and stop
287:11 - editor so let's copy this stop editor
287:16 - and rename it to
287:19 - Crossing
287:21 - editor and let's Copy Stop
287:24 - JS and rename it to
287:28 - rossing JS and in Crossing JS let's edit
287:32 - this real quick so here Crossing now I
287:37 - won't bother with styling it just yet
287:40 - instead I will just draw here the poly
287:44 - without any special Styles and remove
287:47 - what we had previously for for the stop
287:52 - so we're done with this Crossing for now
287:55 - and in Crossing editor we have to rename
287:58 - this to
288:00 - Crossing editor and we already know the
288:03 - things that we need to change to get it
288:05 - to work
288:06 - differently here instead of the lane
288:10 - guides we are going to have to use the
288:13 - graph segments again because it will
288:17 - Center in the middle of the road and
288:20 - here the width should be the full Road
288:24 - width and the object that we create is
288:27 - not a stop it's a crossing the one we
288:30 - just
288:31 - created let's save refresh
288:34 - and now we have the button here and they
288:37 - seem to toggle just fine and when we try
288:41 - adding a Crossing it looks like this but
288:44 - adding a
288:45 - stop still looks polished like what we
288:49 - had it
288:50 - previously removing things Works without
288:54 - actually changing to the other one I
288:56 - find this as a useful thing because it's
289:02 - sometimes uh quite often that you want
289:05 - to add a Crossing very close or instead
289:10 - of an existing other marking so then you
289:14 - can just right click even though you
289:16 - have the crossing editor selected and
289:19 - remove the Stop and create the crossing
289:21 - where you want it
289:23 - so I think this is actually a pro even
289:27 - though the logic wasn't necessarily
289:29 - planned like that now let's style these
289:33 - cross cring in a nice way for that we're
289:36 - going to get a line that is
289:38 - perpendicular to this support line that
289:41 - we had
289:43 - previously and then style that
289:46 - perpendicular line in some way so let's
289:50 - go to Crossing JS
289:53 - here
289:55 - and we don't need this poly
289:59 - anymore we will just get this
290:02 - perpendicular line
290:04 - line from this direction
290:09 - Vector this will also return a vector
290:12 - perpendicular to that one and the logic
290:15 - is actually quite similar to this but I
290:17 - want to avoid using translate and the
290:20 - angle and show you another
290:22 - implementation using vectors and teach
290:25 - you the formula for this perpendicular
290:27 - Vector as well so you could implement it
290:29 - the same way but I want to teach you
290:32 - things so let's have here the line a new
290:40 - segment and now we add to the center
290:45 - point and we scale this perpendicular
290:49 - vector by half the width and then copy
290:53 - this and scale it by half the width but
290:57 - with a minus in front in the other
290:59 - direction so you can see similarities
291:01 - here very much and then let's draw this
291:07 - line now let's implement this
291:09 - perpendicular function it's going to be
291:12 - in math utils
291:18 - maybe here next to
291:21 - translate and it's a really easy given a
291:25 - point we
291:27 - just flip it so to
291:31 - speak by changing these coordinates in
291:36 - this
291:36 - way save
291:39 - refresh select the crossing editor and
291:43 - now we get this perpendicular line there
291:46 - all we need to do is style it pretty
291:49 - much so let's go back to our Crossing JS
291:54 - and add here some
291:57 - Styles like so the width is going to be
292:02 - the height of
292:04 - this marking if that makes sense let's
292:08 - save and
292:10 - refresh select this Crossing editor and
292:13 - now you see it at its
292:15 - full
292:17 - height with the width of the line this
292:19 - is a very thick line now and next we are
292:23 - going to make it white and give it a
292:27 - dashed property like this let's save
292:30 - refresh select the crossing editor and
292:34 - now it looks like that when the cars are
292:37 - driving they will need to make a note of
292:39 - this border and this border here
292:43 - so two borders are needed now we have to
292:47 - record both of them here and I'm going
292:49 - to put them in an
292:51 - array like
292:58 - this let's debug see what we did is
293:02 - working or not I'm going
293:04 - to try
293:06 - to draw here all these
293:11 - borders save refresh Crossing
293:15 - editor and they look okay so no need for
293:19 - this debug
293:20 - anymore and we are done with this
293:23 - Crossing as well but look at this
293:25 - Crossing especially this part right here
293:28 - and the
293:31 - stop this part right here they are
293:34 - pretty much the same and now the stop
293:37 - editor even worse stop editor is very
293:41 - much like the crossing
293:46 - editor the only difference are
293:49 - these Target segments that we use here
293:53 - and the type of marking that is
293:56 - created so let's begin by refactoring
293:59 - this stop editor and the crossing editor
294:02 - into um so-called marking editor and
294:06 - then we inherit from that most of the
294:09 - same
294:10 - functionality let's copy this stop
294:14 - editor like this rename it to
294:19 - marking
294:21 - editor and here at the top this will be
294:25 - marking editor and here where we get
294:29 - these this nearest segment we just pass
294:34 - this target
294:37 - segments the target segments will come
294:40 - from the Constructor so this marking
294:42 - editor will be told what segments to
294:45 - look for and it's going to store them
294:50 - here in an attribute of this
294:55 - object and the second thing that we need
294:58 - to do is add here a method for creating
295:01 - a marker this should be a Dynamic method
295:04 - that will be overwritten by the stop
295:06 - editor and the crossing editor in a
295:08 - different way so this one needs the
295:13 - center location of the marker and the
295:16 - direction and that's it the width and
295:18 - height are things that those subclasses
295:22 - that will inherit from this super class
295:25 - will worry about so I just return here
295:31 - this Center as a point just to have some
295:33 - something but this function will be
295:35 - overwritten to be
295:39 - overwritten by the sub
295:41 - classes so with this create marking
295:45 - function in place we are going to call
295:49 - it
295:50 - here this create
295:54 - marking and it doesn't need these last
295:57 - two parameters and we are done with this
296:00 - marking editor now we go to stop editor
296:04 - and
296:06 - extend so extends marking
296:11 - editor like this and instead of doing
296:15 - anything here in the Constructor we just
296:18 - say super viewport world and the target
296:23 - segments will be the world Lane guides
296:26 - in this
296:28 - case everything else just goes away
296:32 - because
296:33 - after extending marking editor the
296:36 - functionality is there all we need to do
296:40 - is overwrite the create
296:43 - marking
296:44 - method given
296:47 - these
296:48 - properties and I'm going to return a new
296:53 - stop in this case at the center and
296:58 - Direction
296:59 - vector and now we can pass here the row
297:03 - width divided by two and the road width
297:08 - divided by two this square shape of the
297:12 - stop marking and that's it now inside of
297:17 - the crossing editor we do the exact same
297:21 - thing we
297:23 - extend marking editor like this we
297:28 - remove the contents of the
297:30 - Constructor super with the viewport P
297:33 - world and the world graph segments this
297:37 - time so this is the difference and
297:40 - remove all this
297:44 - code implement the create marking
297:48 - function over write it
297:50 - actually it is already there it's just
297:52 - returning Center if we don't do
297:56 - this and return a new Crossing this time
298:01 - at the center according to the direction
298:05 - vector and the full Road width this
298:11 - time and the road width divided by two
298:15 - and we're done with this refactoring we
298:17 - just need to include the marking editor
298:20 - as well so here in index we should
298:25 - include it before the other editors so
298:29 - that inheriting it is possible I'm going
298:32 - to put it here at the top above graph
298:35 - editor and say marking editor save
298:41 - refresh and
298:46 - now everything still works as before but
298:50 - the code is much much better and we can
298:53 - do even better we can refactor the
298:56 - marking as well so in the same way we
299:01 - are going to copy stop
299:06 - here rename this to
299:13 - marking
299:15 - marking and the border is something that
299:18 - is different between all of these
299:20 - markings so I will not have it there and
299:23 - the draw method for this marking we are
299:26 - not supposed to draw these objects just
299:29 - inherit from them but if we do maybe we
299:33 - draw this poly here instead
299:37 - so poly draw and I'm just going to use
299:40 - default styling remove this it's part of
299:44 - the stop
299:47 - drawing and that's it now in stop JS we
299:52 - can
299:54 - extend
299:56 - marking
299:59 - and here we call Super with all of these
300:05 - parameters like
300:07 - so and we don't need any of this except
300:10 - for the Border
300:12 - there so not so much code removal as in
300:16 - the other part but there is some still
300:19 - and let's do the same for the crossing
300:21 - here so
300:23 - extends
300:25 - marking remove this type
300:30 - super copy paste semicolon and now we
300:35 - need to include this marking as well so
300:38 - in the same way I'm going to include it
300:40 - on top of
300:42 - this so markings
300:45 - marking JS save refresh and add some of
300:51 - these markings
300:53 - here works just as before but uh we can
300:57 - do even more
300:59 - refactoring here inside of index HTML
301:02 - you remember all this tedious stuff that
301:06 - we had to do like the stop editors
301:08 - checking where it is and adding the next
301:11 - one next to it in all places and the
301:13 - stop button these buttons and editors
301:17 - I'm going to group them in an object
301:21 - called
301:22 - tools so tools is going to contain now a
301:27 - tool for the
301:29 - graph and this one will have access to
301:33 - the button and the graph
301:38 - editor now the same goes for the stop a
301:41 - button for the Stop is stored here and
301:45 - the editor for the Stop is stored here
301:48 - and finally the crossing the button for
301:52 - the crossing we added here and the
301:55 - editor for the
301:58 - crossing we add it here as well and with
302:02 - this object we can Loop through these
302:05 - values here so instead of having three
302:10 - displays here or like so we can
302:14 - just
302:18 - Loop through all of the tools like
302:22 - this then take the tool editor and
302:27 - display we are not gaining much like
302:30 - three lines here and three lines here
302:33 - these go away but when more editors are
302:37 - going to be added there this will make a
302:39 - difference and of course the effort of
302:42 - typing something new here and
302:44 - remembering that you have to type
302:46 - something there goes away with this
302:49 - implementation now we're going to copy
302:51 - this
302:54 - again here in disable
302:56 - editors here we want to disable not
303:01 - display
303:03 - but also this code for the button we can
303:07 - copy it here and just say
303:10 - tool
303:17 - button tool button and all this code
303:20 - goes away and it should be the same
303:23 - thing now this switch case here becomes
303:28 - much simpler because these values here
303:32 - match those from the tools that I
303:36 - defined on top this was on
303:39 - purpose and that means we don't need the
303:41 - switch at all anymore we just remove it
303:45 - align this
303:47 - better and this is going to be the
303:51 - tool from this mode
303:57 - button style background color style
304:00 - filter and here we enable not the button
304:03 - but the editor instead now save the file
304:08 - refresh the page
304:11 - and everything still works just fine
304:15 - there's something a little bit more that
304:18 - we could do is that
304:21 - this copying here can also be omitted if
304:26 - we just pass directly
304:29 - here the instantiation
304:33 - of the
304:35 - object like
304:45 - so so these are not needed
304:48 - anymore but uh this graph editor is
304:52 - actually called here in this
304:55 - pose so
304:58 - let's remove this but also edit this
305:02 - pose here and say tools
305:05 - graph
305:07 - editor dis poose save refresh try to add
305:12 - some
305:15 - markings and when we press this
305:18 - pose everything still
305:20 - works now the next marking we are going
305:23 - to add is not a kind of marking that you
305:26 - find on the roads really it's going to
305:28 - be a start marking where the
305:31 - self-driving cars are going to spawn at
305:35 - so we're going to need that in the
305:37 - future and let's see how quickly we can
305:40 - Implement that now that we have this
305:43 - better code structure here we are going
305:46 - to go at the top where the buttons are
305:50 - and I'm going to copy this one and say
305:55 - start
305:57 - BTN set Mode start and repl this Emoji
306:03 - here I'm going to use a blue car because
306:06 - my car is blue and now here in the tools
306:11 - we are going to have to add a new
306:16 - entry for
306:18 - the
306:21 - start using start
306:24 - BTN and start
306:28 - editor we also have to include these two
306:32 - new files here
306:34 - so let me copy this stop editor
306:39 - here call it start
306:43 - editor and this stop marking
306:46 - here call
306:49 - it start and to implement this we just
306:53 - copy the stop editor from here rename it
306:58 - to start
307:01 - editor and the only change we do here is
307:05 - rename start
307:08 - editor and this is going to create a new
307:12 - start and then
307:14 - here copying the stop
307:18 - marking as the
307:21 - start renaming this to start and this
307:25 - marking will not have any
307:28 - border instead it's going to have an
307:30 - image we just display the picture of the
307:33 - car that I drew in phase one of the
307:35 - course so let's store here an image New
307:41 - Image and set its source to
307:46 - car.png and in draw we don't need this
307:50 - border we also don't need this
307:54 - scale but we do go between the
307:57 - rotation and the restore point here and
308:01 - here we draw the
308:03 - image we draw the
308:05 - image like so and 0 0 would Center it so
308:10 - that the top left corner of the image is
308:13 - going to be at this center point so we
308:16 - need to offset it by half its
308:18 - width and half its
308:22 - height I've added an image of a car now
308:28 - here it's this one so we can save
308:32 - refresh and now this button is here
308:36 - toggling seems to work just fine and the
308:39 - car appears there so here we're telling
308:42 - the system cars will come at this
308:45 - location and of course maybe they should
308:49 - respect some of these markings as well
308:53 - now I will Implement four more markings
308:56 - but I will fast forward this
309:01 - part
309:09 - this is what I have now there are quite
309:11 - many uh new things here there is a yield
309:15 - which is quite similar to stop also a
309:17 - barking here the target is where cars
309:21 - are supposed to go and probably the most
309:24 - complicated one is this traffic light
309:27 - here which has a little bit of logic of
309:30 - how to change the colors
309:33 - um I will make a special video for the
309:35 - channel members showing the full process
309:37 - but uh otherwise you can take the code
309:40 - after this lesson and inspect it
309:42 - yourself it's not rocket science but uh
309:46 - the code structure could be a little bit
309:48 - better for the logic of these lights I
309:51 - just didn't bother with it because I'm
309:53 - not even sure if we will use them in
309:56 - phase three it depends how good our
309:59 - neural network works so
310:02 - let's
310:04 - see so far we've been saving the grass
310:07 - in local storage and regenerating
310:09 - everything based on that when the page
310:11 - loads but in this way we lose the
310:14 - markings also we can't save multiple
310:17 - worlds like this and the trees appear
310:20 - randomly and maybe you don't want that
310:23 - not to mention that the worlds can be
310:25 - quite big and generating them when the
310:27 - page loads can be time consuming you'll
310:30 - see when we work with real world data
310:31 - I'm not patient enough to draw such a
310:33 - large graph now so I think that having a
310:36 - way to store the information in actual
310:38 - World files and loading them afterwards
310:41 - is a must you'll see it really Saves the
310:52 - Day done now you have a nice world like
310:56 - this and you want to store it save it
311:00 - somehow with everything all the markings
311:03 - everything we'll do that using local
311:05 - storage as well so we're going to store
311:09 - here as the world
311:14 - item
311:15 - stringify the
311:18 - world it's now here if we
311:22 - type get
311:26 - item world all the information is here
311:30 - from absolutely everything so I
311:33 - shouldn't lose all the things that I
311:35 - have here but of course we need to add
311:37 - this functionality to the save button as
311:41 - well so let's do
311:44 - that inside the save function here
311:48 - instead of saving the graph we're going
311:50 - to
311:52 - save the
311:56 - world and loading the world when the
311:59 - application starts it's going to be
312:02 - pretty similar to what we have done here
312:04 - by loading the graph but we replace
312:07 - these so World string is what comes from
312:13 - world and then World
312:16 - info we take here World
312:20 - string like so and now I'm going to keep
312:23 - this for reference but the way we Define
312:26 - the world and the graph is going to be a
312:29 - little opposite way so so first the
312:33 - world is going to come from World info
312:37 - if it exists then world is going to load
312:42 - from World info in the same way we were
312:44 - loading the graph earlier and otherwise
312:48 - Define a new world with an empty graph
312:52 - like
312:53 - this so now this graph is going to come
312:58 - from the world instead
313:02 - and we don't need this code anymore now
313:05 - World load this is what we're going to
313:08 - do today focus on how to load the
313:11 - information stored there as a Json
313:14 - string so let's go and open world JS and
313:19 - just below the Constructor I'm going to
313:22 - implement here a
313:24 - static method called load with the info
313:29 - and then just return a new world
313:33 - where we load the graph from the info
313:36 - graph like this this is the quickest
313:38 - thing that we could do and get something
313:40 - that actually works now if I go back
313:44 - here and
313:46 - refresh you're going to see the shape is
313:50 - still here but the markings are not
313:54 - there and also every time we refresh the
313:58 - trees are a little bit different so
314:01 - that's something that I don't really
314:03 - like maybe we want to keep the tree
314:05 - locations so that everything is exactly
314:07 - as we as we know it and the markings of
314:10 - course are gone and one more issue with
314:13 - this implementation is that now we do
314:16 - call the world
314:18 - Constructor which calls generate and
314:22 - this does a lot of work really a lot of
314:25 - work for big Maps this can take even
314:29 - minutes and you'll see that later when
314:31 - we we work with real world data but
314:35 - basically when we load this it shouldn't
314:38 - need to generate anything we should just
314:40 - be able to restore all the generated
314:43 - items from this information and that's
314:47 - what we are going to do next so let's
314:51 - begin here
314:53 - by defining an empty world first one
314:59 - that does call generate since the graph
315:02 - is empty there's nothing there really
315:05 - and then start populating the items so
315:09 - the graph this first item right here
315:12 - this one is going to come from loading
315:16 - the graph from the information like that
315:19 - and here we just return this world that
315:22 - only contains the graph at the
315:24 - moment save and refresh and now we get
315:29 - this and this is okay the world just
315:33 - shows the graph because the other things
315:36 - are empty so envelopes Road borders
315:39 - buildings these are not there not yet at
315:42 - least and we're going to need to
315:44 - populate them also these properties
315:46 - should come from our local storage but
315:50 - one thing that you should note is that
315:52 - when I drag this things start appearing
315:55 - again because the generate starts to
315:58 - function again the at from here inside
316:03 - of animate when the graph changes the
316:05 - world does regenerate based on the graph
316:08 - so just for you to know that this is
316:11 - expected
316:13 - Behavior so let's begin by taking all of
316:18 - these attributes now
316:21 - from the info here so this world is also
316:25 - going to get the road width roundness
316:28 - building width minimum length spacing
316:32 - and the tree size from
316:34 - the
316:39 - info in case we want to generate roads
316:43 - with different properties here then they
316:45 - will come from the local storage and now
316:49 - we proceed to generate these
316:52 - envelopes and the way we do that is the
316:55 - same way we did for the graph this load
316:58 - method we have to implement load methods
317:00 - for the envelope
317:02 - as well and make them proper objects not
317:06 - just raw information from this info here
317:10 - so I'm going to say that the world
317:13 - envelopes are going to be coming from
317:16 - the info envelopes which are just info
317:20 - not actual envelopes where we map them
317:23 - so that each element e is going to
317:27 - be envelope load that information
317:32 - now we go to the envelope primitive here
317:37 - and we have to implement a load for it
317:40 - because this generate polygon is also
317:43 - quite an expensive function and I don't
317:45 - want to just call envelope with that
317:48 - information the skeleton for example and
317:52 - regenerate it I'm going to implement
317:55 - here a way to create an empty envelope
317:58 - one that if we don't pass a skeleton
318:03 - then none of these
318:06 - happen and our static function for
318:09 - loading is just going to get the
318:12 - information and
318:15 - generate an empty envelope it will have
318:19 - the type of object envelope and it will
318:22 - have for example the draw and this other
318:25 - method in it but then the skeleton of
318:29 - this envelope is just going to come from
318:31 - from the info by generating a new
318:34 - skeleton from
318:36 - the P1 and P2 of info skeleton like this
318:42 - now technically these should be also
318:44 - cast as points but I think it's going to
318:46 - be okay and then the
318:49 - poly we have to add a polygon load
318:55 - method from this info
318:58 - poly and now we can return this envelope
319:02 - like so and the polygon load method here
319:06 - at the
319:08 - top a static load given the
319:13 - info I'm going to return a new
319:17 - polygon from these info points but I am
319:21 - mapping them now to actual point objects
319:25 - this is important otherwise some errors
319:27 - will
319:28 - come now save re
319:32 - refresh and I have some errors here
319:36 - because
319:37 - I accidentally forgot to
319:41 - remove
319:43 - this I wanted to replace this with World
319:47 - previously and I made the mistake save
319:51 - and refresh and now the envelopes are
319:54 - showing as well now the next thing here
319:57 - in line is the road
319:59 - borders this is is not so demanding
320:02 - because they are just segments so Road
320:07 - borders
320:08 - is Road
320:10 - borders map each border to a new
320:15 - segment P1 and P2 and again I don't
320:20 - bother casting these as points we don't
320:23 - call any methods of those points in our
320:25 - code so I just save some time by not
320:28 - knowing it but the proper implementation
320:31 - would have that cast also here and maybe
320:34 - segment end point should have also this
320:37 - load functionality there that would be
320:39 - the most proper but um I'm starting to
320:43 - want to end this so I can focus on phase
320:46 - three now here the buildings are
320:49 - next let's write here World
320:55 - buildings info
320:57 - buildings
321:00 - map new building by loading it we have
321:04 - to do this here but it's straightforward
321:07 - so in our building item here just give
321:12 - it a static method that loads this
321:16 - info and we return a new building This
321:22 - Time by loading the
321:24 - polygon of the info
321:27 - base and here we have to specify the
321:31 - height as well so that the building
321:32 - remembers its height from the original
321:35 - info we didn't really play with
321:37 - different Heights or anything like that
321:39 - but this makes the code more proper
321:42 - let's save and refresh and now the
321:45 - buildings are there as well without the
321:47 - need to generate
321:49 - them next we
321:52 - have the
321:54 - trees let's do something
321:57 - also here I'm just going to go through
322:01 - each
322:03 - tree and generate the new tree here I
322:07 - don't think it needs any load because
322:10 - the processing that happens for trees is
322:13 - actually in the in the draw so if I open
322:16 - here tree
322:18 - ejs this generate level is called here
322:22 - while drawing and all we need to do here
322:25 - really is initialize this generating the
322:28 - first is just creating a single poly
322:31 - basically so not much trouble to just
322:34 - reinitialize the trees trees can be
322:37 - quite problematic in the generation
322:40 - process because here generate takes a
322:45 - lot of effort for the trees if you
322:47 - remember we had this while loop here
322:50 - that tries to add a lot a lot of trees
322:53 - and it's going to try again and again
322:54 - and again and then reset and again and
322:56 - again but now we are going
322:59 - to tell
323:03 - here which locations to use so that part
323:08 - is gone and if we refresh now we'll
323:11 - actually see that every time we refresh
323:14 - the trees are going to be at the same
323:18 - locations always because now there's no
323:21 - more Randomness at play when loading
323:23 - this world from local storage now for
323:26 - the markings to work we also need those
323:29 - Lane guides they are next in line here
323:34 - actually so let's take the lane guides
323:37 - as
323:40 - well Lane
323:44 - guides we map
323:46 - them two new
323:49 - segments with the same points and now
323:52 - the only thing left are these markings
323:55 - here and um this will be a
323:59 - problem because if I'm going to inspect
324:03 - them here World info markings the ones
324:07 - that I
324:09 - saved we can see that there's no
324:12 - information here telling what type of
324:16 - marking this is the type of object
324:20 - doesn't serialize in JavaScript oh yeah
324:23 - I can tell that this is a traffic light
324:26 - and it was saved with the state of red
324:29 - but um
324:32 - yeah it's just guesswork for many of
324:34 - these or this image I can tell that it's
324:37 - the start because it's the only one that
324:39 - has an image this has two borders so
324:44 - might be a parking or I don't know
324:46 - Crossing could be as well so we actually
324:50 - need to store the type of these markings
324:55 - with the object as well as an attribute
324:58 - and that means we have to open up these
325:01 - markings
325:03 - again and edit all of them and tell this
325:07 - one that this type is a
325:11 - Crossing save and this
325:16 - type is a
325:19 - light and
325:21 - save and this one it's a marking that
325:25 - hasn't
325:27 - been inherited from and shouldn't really
325:30 - be used like this but I will give it a
325:33 - type also for
325:36 - consistency and then this
325:39 - is uh par
325:45 - King and this
325:49 - is
325:52 - start and this
325:58 - is a stop
326:03 - this
326:07 - is
326:10 - Target and this
326:15 - is
326:18 - yield and now if we go back here we need
326:22 - to generate the world and save it with
326:26 - markings that have this type so the
326:28 - original ones
326:29 - are lost forever pretty much let's
326:34 - refresh and add new markings I hope I
326:38 - remember where I put them
326:40 - before these were the traffic lights and
326:44 - um I think I had the parking here maybe
326:49 - I had the crossing somewhere here I
326:51 - don't really know car was starting here
326:54 - I
326:55 - think let's put um let's put the stop
327:00 - let's put it here because this kind of
327:02 - looks like a priority line I think I'm
327:04 - happy with this so let's save again and
327:07 - refresh and the markings are not there
327:10 - but now if we do look in the information
327:14 - that they
327:15 - have the type is there so I do know this
327:20 - thing with two borders now it's a
327:23 - Crossing so we do have what we need to
327:26 - load them into memory as proper objects
327:31 - I'm going to close all of these open
327:34 - files
327:36 - now and in World JS let's write
327:41 - this world
327:44 - markings we remap the information from
327:48 - the markings to marking
327:51 - load M like so and we have to implement
327:55 - this load method next so inside of
328:00 - marking
328:02 - JS
328:06 - here static load the info and here we
328:11 - have to do a switch based on that type
328:14 - that we now have so switch info type and
328:19 - just going to take these in order from
328:22 - here case
328:26 - Crossing return new
328:29 - Crossing
328:31 - at
328:33 - the info center X info center y we have
328:40 - to create a new point and this is the
328:43 - direction Vector
328:47 - X Direction
328:50 - Vector
328:52 - Y and uh the width and the height are
328:56 - like that and I have to copy this for
328:59 - all of them pretty much
329:00 - much and it would be quite a lot
329:04 - of code here and many many lines so I'm
329:10 - going to extract these two longer ones
329:13 - at the top it's going to
329:16 - be the same for all of them all of them
329:19 - have this center
329:24 - location and
329:26 - this direction Vector there for sure
329:30 - short I'm just going
329:32 - to put this one
329:34 - here and
329:37 - now here we can type
329:41 - point
329:42 - there and
329:45 - with and
329:50 - height and close this in one line which
329:53 - is much nicer I think and we can copy
329:59 - this
330:01 - seven times this is going to be now
330:07 - light
330:10 - light
330:12 - marking
330:15 - marking
330:18 - parking
330:21 - parking
330:23 - start
330:25 - start
330:27 - stop
330:29 - stop
330:33 - Target Target and
330:37 - yield
330:39 - yield let's save and
330:43 - refresh and there they are our markings
330:46 - are now here great so this now works but
330:51 - what if we want to store many scenarios
330:54 - many worlds we want to play with this
330:56 - and create a bunch of different worlds
330:59 - I'm going to teach you how to stored
331:00 - them as a file and then load them from
331:03 - the file that you stored them
331:06 - in this is also going to help with
331:09 - memory problems if the world is too big
331:12 - and it doesn't fit in local
331:16 - storage so here inside of this save I'm
331:20 - going to go at the top and uh Define an
331:26 - a
331:29 - tag
331:31 - which we will artificially click to
331:36 - download a world
331:39 - file now the Syntax for this I won't
331:43 - explain in too much detail but basically
331:47 - we will use Json here so I am going to
331:50 - specify that we use application Json and
331:54 - um just in case
331:57 - utf8 and we encode this
332:01 - information like that coming from the
332:05 - string of the current world
332:08 - object now here we generate the file
332:12 - name and it's going to be name. World by
332:16 - default but depending on your browser
332:18 - settings you're may be asked to enter
332:20 - the name when you save the
332:22 - file and then here I'm going to set the
332:27 - attribute to download and pass this file
332:30 - name as well and now we can trigger
332:34 - click which is going to start the
332:36 - download so when we press the save
332:38 - button all this will happen and it will
332:40 - put the world information in a file
332:42 - called
332:43 - name.or but you can change this name
332:46 - just the extension world is important
332:50 - let's now save and refresh and let's
332:54 - save this world
332:56 - file you probably don't see these uh
333:00 - screens here where I'm entering the name
333:03 - but it did save somewhere on my computer
333:06 - so this I have a backup of it and now
333:09 - let's remove it and try to have a new
333:13 - world maybe different looking let's just
333:16 - use this kind
333:17 - of square shape and maybe give it a
333:21 - diagonal like so and let's save this one
333:25 - as well and I'm going to use a new name
333:27 - for that and now when we refresh here I
333:32 - am going to get the new one the first
333:34 - one is lost basically but we can get it
333:38 - back if we Implement load functionality
333:41 - from a
333:42 - file and I'm going to do that here below
333:45 - the save
333:47 - function we are going to have another
333:49 - function called
333:51 - load and this is going to be linked to
333:55 - U file input you'll see we get the first
333:59 - first file from
334:02 - there and if there is no file let's just
334:06 - give here a quick alert that you haven't
334:08 - selected
334:12 - anything and return we don't want to get
334:16 - to this part of the code here so we
334:19 - begin to read the information from the
334:23 - file and we read it s
334:28 - text then unload I'm going to pass this
334:32 - callback function here given an event as
334:35 - the parameter I will take the
334:39 - content of
334:43 - this file like this and parse it because
334:48 - it's a string by
334:53 - default and now we can use this
334:56 - information to load a new world so world
335:00 - is going to be load this new
335:04 - data and what I'm going to do now to
335:08 - prevent reinitializing a bunch of
335:10 - objects is I'm going to set this
335:14 - information in local storage
335:19 - here and then reload the page so
335:23 - basically this button is going to reload
335:26 - the page after it stored the world in
335:30 - the new local storage item here but uh
335:33 - one thing we still need to do is this
335:35 - world needs to be reassigned to
335:38 - something else and it's a const so going
335:42 - back up here I'm going to change this
335:45 - world into a let and this should work to
335:49 - call this function we're going to need
335:53 - um file input and I'm going to put it
335:57 - here and give it also a label
336:00 - for this file
336:02 - input and the class I'm going to make it
336:05 - look like the other buttons in CSS
336:08 - otherwise it's very ugly I think and um
336:13 - I will use
336:14 - this emoji of a folder here and the
336:19 - input
336:20 - itself let's put it like this the type
336:24 - will be file and ID is this file input
336:30 - it will accept files of type world and
336:35 - unchange we call our load with the event
336:40 - information which file did we select now
336:44 - if we save and refresh we're going to
336:46 - see here some quite bad layout
336:50 - happening but let's see if it works so
336:53 - pressing this it asks me to select the
336:57 - file and I'm going to select the first
336:59 - one that I had
337:02 - previously and I got it
337:05 - back great only thing now to style this
337:09 - to make it look like the other buttons
337:12 - and I do that in Styles CSS I'm just
337:17 - going to reuse this
337:19 - style like
337:23 - so and the default styles for these are
337:27 - a little bit different I'm going to for
337:29 - for both of them to have this inline
337:32 - block
337:35 - display and um I want to hide the
337:39 - contents of the file type
337:46 - input as well so we just see that emoji
337:50 - there save refresh and now it looks like
337:53 - that and when we refresh the page we
337:56 - still have this world but now I can
338:00 - change to the other one we created and
338:03 - it's here every time we refresh it's
338:06 - still this one until we change to
338:09 - another one I'm now constantly selecting
338:13 - different files there but you don't see
338:15 - those windows my recorder doesn't catch
338:18 - them one thing I would like when storing
338:21 - these worlds is also to keep
338:24 - the viewport information part of the
338:28 - world itself like how should it be
338:31 - presented because here it doesn't show
338:34 - everything and I always seem to scroll
338:38 - zoom out like this so maybe this world
338:41 - should look like this by default we can
338:44 - do that by storing the viewport zoom and
338:47 - offset information part of the world
338:50 - itself let's go back to index HTML in
338:53 - our save function and here at the top
338:59 - I'm going to do just that
339:02 - world Zoom his viewport
339:06 - Zoom World offset is
339:10 - viewport
339:11 - offset and now let's save this refresh
339:16 - and put again this reference Here and
339:20 - Now save again I'm going to overwrite
339:22 - the previous
339:24 - worlds that's one and the other
339:28 - one
339:32 - like this so now they should have that
339:34 - information in them but if we refresh
339:37 - the viewport isn't adapting to it so we
339:41 - have to do that and also make sure that
339:44 - the world is going to load that
339:46 - information from the info so inside of
339:49 - world JS here I'm going to also type
339:53 - World Zoom comes from the info zoom and
339:58 - World offset comes from info
340:01 - offset and back in index HTML where we
340:06 - Define our viewport here let's pass it
340:10 - also to zoom and the offset of the world
340:15 - and handle it inside of viewport JS in
340:19 - the Constructor these will have some
340:21 - default values in case they don't
340:26 - exist but otherwise here let's just
340:30 - pass that and the offset this is fine if
340:33 - the offset is not specified so I'm just
340:36 - going to say if there is an offset set
340:39 - it to that offset otherwise whatever we
340:42 - had previously save refresh and now we
340:46 - get this exactly as we wanted and the
340:49 - other
340:52 - one works as
340:56 - well thanks for watching if you want to
340:59 - learn how to integrate the self-driving
341:01 - car with this new world watch this video
341:03 - on my channel you may also want to watch
341:06 - these other two videos that teach how to
341:08 - use real world data from open street map
341:11 - and how to create the mini map I hope
341:14 - you liked this course and if you did
341:16 - please remember to like subscribe to me
341:18 - and to free code camp and share the
341:20 - course with others so they can learn as
341:22 - well see you guys and stay tuned for
341:25 - phase three it will start soon I promise

Cleaned transcript:

Dr R is back with another Advanced JavaScript course he'll teach you how to build a virtual environment entirely from the ground up get ready to use basic HTML CSS and JavaScript to craft a world you can use in all kinds of projects he'll show you how to fill the world with selfdriving cars but you can fill it with anything you like hi and welcome to phase two of the selfdriving car course a virtual world this is actually a standalone so you don't need to have watched phase one to follow along we'll start building this world from scratch using some basic HTML CSS and a lot of JavaScript and whether you'll fill it with selfdriving cars or something else is completely up to you the focus will be on generating the world itself and I'll only integrate the selfdriving car code at the end I made this course to prepare for phase three understanding AI where we'll focus on neural networks and other AI techniques I hope that by the end of face three you'll understand why neural networks work why hidden layers are needed and things like that but for that we need this fancy world to generate complex scenarios the one we had earlier is too simple to teach you all that so if neural networks is what you're waiting for be patient and enjoy phase two meanwhile you learn a lot of things in this one as well a set of skills I really benefited from during my PhD and my time at Microsoft and I'm sure they'll be useful to you as well in your career we first learn about graphs and I'll show you how to implement the spatial graph from scratch I'll also show you how to make an editor for it as well it will have a dynamic viewport so we can pan and zoom to edit graphs of virtually any size when building this editor I'll explain the mathematics and logic behind good user interfaces in modern pieces of software and we Implement something similar ourselves then we use geometry to generate the road borders around the graph I'll teach you about polygons and some useful operations using them we'll apply the same techniques in a slightly different way to generate the buildings and the trees as well we spent two lessons on these because I want to show you how to implement this 3D look as well they're not really 3D models just a little bit of math that gives that illusion then we Implement a way to add markings to the road this will make phase three even more interesting because we'll need to teach the car to respect all kind of traffic roles as well now we'll focus on making this world editor a pleasure to use minimizing the number of clicks and maximizing the amount of autogenerated content but I'll also make videos on how to load real world data from open street map so the car can drive in your city as well this is yansu the card just passed by kelia University of applied science that's the Vila campus where I'm currently filming and it started off at tiar the other campus and now it's heading toward City Center where I've marked some it companies on the map looks like the car is heading towards Arbon out which is on the other side of town I'll add a link to this demo in the description check it out it's a good way to learn about yansu if you plan to come study with us you'll find many useful links there as well oh and I'll also make a video for creating this mini map it really helps when the world is big and the mini map was probably the most requested feature I got in phase one I've tried answering to all requests when making this but there's still a few I'm leaving for phase three they fit better there now to be clear this project is complex especially because we're going to code everything ourselves and not use libraries it won't be easy to wrap our minds around at all but I divided it into components lesson that I believe are easy to understand on their own I consider this course to be at an intermediate level but I do encourage beginners to give it a shot as well to get an idea of what a more complex project looks like I explain everything the best I can and if you have difficulties just ask in the comments or on my Discord the prerequisites are high school math and if you have trouble with that this playlist will have you covered you also need to know some JavaScript if you completed phase one you'll have no problems here but if you need to brush up on it I explained some tricky JavaScript syntax in these sketches so check them out if needed I hope you're excited and thanks for being patient this long can't believe it took me over a year to make this but I wanted to do it justice since you liked phase one so much now let's begin I'm going to code everything using visual studio code and we'll begin somewhere in an empty folder on your computer and let's create our first file here it's going to be index HTML and we begin with basic HTML we write the doc type here and the HTML page structure in the head I'm going to add a title and the title of this will be the world editor this will make it appear in the browser Tab and let's make it also visible by typing it inside of the body in an H1 tag like this now most of our functionality is going to be built on top of an HTML canvas element so let's add canvas element with ID my canvas onto the page as well now let's open this in our browser I'm going to be using Google Chrome and remember to open the developer tools as well it's really important to know if you make any mistakes the errors will pop up here now you can see here the title of the page is correct and the H1 tag is here but the canvas is not really visible it is there if you press this button right here you can find it on the page but it's transparent and we can see it so let's add some styles to this page I'm going to go here below the title and Link a CSS file like this called Styles CSS we're going to create this file here Styles CSS and for the bot I'm going to give it a black background color and I'm going to align everything to Center like this the H1 I'm going to give it a white color so that we can read it on the black background and set its font to harriel I think it looks better and finally the canvas I'm going to give it a back color that we can see on this black background and I'm just going to use this shade of green that I like let's save this and refresh and it now looks like this I'm going to make the canvas bigger and we're going to use JavaScript for that in index HTML we'll write JavaScript code here at the end of the body we begin with script tag and I'm going to set my canvas width to 600 and my canvas height also to 600 because it fits my screen well pretty much but you can choose other values if you want now we're going to be drawing on this canvas and for that we're going to need to access the 2D drawing context of this canvas like cell and we will draw a graph let's pretend that we have a way to define a graph like so and that the graph has a way to draw itself on a given context so we're going to need to implement these functionalities the graph itself and the draw method and we'll do that in a separate Javascript file I'm going to include it here we're going to place JavaScript files in a folder called JS but this is going to be a pretty big project so we need to think about code structure early on and I'm going to place the graph itself in a subfolder called math and then graph JS like so so let's create the Js folder first and inside of this JS folder we're going to create math another folder and inside of math we create our Javascript file graph. JS graphs are data structures made from a set of nodes also called vertices and a set of edges or links that represent relationships between the nodes like in a social network a graph can store which users are friends these relationships are bidirectional here but in other applications like here on YouTube I may be subscribed to you but you may not be subscribed to me there is very much to say about graphs like we already use graphs in Phase One when implementing the neural network there the links had weights so we were dealing with a weighted graph and there was a link between every input and every output so we used the Matrix to represent those relationships in memory but now we're going to implement a new type of graph called a geometric or spatial graph where nodes are not just abstract things they will represent Road intersections or places where the road geometry changes like this you can see there are not so many links here really so a matrix would be mostly empty and not the right choice in this case when implementing a spatial graph the proper way would be to separate the node metadata the points from the connections themselves but I think it makes things too complicated and since this whole project revolves around geometry I will simply say these are the points and they will be connected by segments with one point at each end so a bit unconventional here but I think it simplifies things in our case now let's code one of these graphs in JavaScript it's going to be a simple class and each Constructor is going to have two parameters we build a graph using points and segments I initialize them to empty arrays so that you can create an empty graph as well now let's store these parameters as attributes like so and in Implement our draw method that takes the canvas context as a parameter and I'm just going to Loop through all of the segments that we have and tell each of those segments to draw themselves on the canvas context we don't have these segment objects yet but they will be there and they will have the same kind of structure as the graph has it's important to be consistent with these things and then I'm going to do the same thing for the points like so and uh I draw the points after the segments because I don't want the segment lines to be on top of the points it doesn't look good now let's Implement these segment and point objects in index HTML I'm going to copy this line and I'm going to place these in a folder called Primitives points and segments are primitive objects so let's write here Primitives point and Primitives segment like this and inside of this JavaScript folder the main one here not inside of math I'm going to create a new folder called Primitives so it's next to the math folder here and in it we create a new file Point JS it's also going to be a very simple class Constructor takes in X and Y as parameters where we want the point to be and we set these paramet values as class attributes like so so that the object knows where it is pretty much and then in the draw method on the given context I'm also going to pass two more parameters to style these points a little bit the first one is going to be a size maybe 18 pixels and a color I'm just going to use black we're going to draw the points as circles and the circles need a radius I'm going to just calculate that as half of whatever this size is and we begin a path set the fill style to this color that we have in the parameter list and use the arc method of the drawing context and draw this at this X and this y we pass the radius next and the last two parameters specify that we want a full circle so starting at 0° and ending at 360° but we have to write this using radians that's just how the function works so 360° is 2 pi radians now we fill and we're done with this point for now let's do the same thing with the segment so create a new file called segment JS our segment class The Constructor will have points this time P1 and P2 let's save these as attributes of the class and Implement our draw method given a context and again I'm going to pass two parameters here as well the width the line withd how thick we want the segment to be I'm just going to give it a default value of two and a color again I will set it to Black like so and we begin a path we set the line width to the given width and we set the stroke style this time to the given color we move to the first point p1x P1 Y and now we're going to copy this line and line to P2 X P2 Y and then we stroke and we're done with these core functionalities the only thing left to do is test so make sure all your files are saved go back to index HTML and let's pass some actual points to this graph I'm going to go here above where we defined the graph and say P1 is a new point at 200 200 pixels let's copy this few more times and have here P2 P3 and P4 maybe P2 is going to be at 500 200 then 400 400 and 100 300 and let's pass these as an array to our graph here as well this will be the points parameter of the graph and the segments will be the second parameter but we can actually test now already so save the file refresh the page and there's our graph it has the four different points this is the 200200 this is the 500 200 uh keep in mind that 0 0 is this top left corner so 5 100 200 like so let's add segments as well I'm going to go here and say S1 is a new segment between P1 and P2 and let's copy this two more times maybe S2 and S3 between let's just link P1 for now P1 with P3 and P1 with P4 and pass these as the second attribute here save and refresh and we can see now the segments as well let's connect these to as well so I'm going to copy this as S4 between P2 and P3 and passing s for here like so good now this is a static structure we can't really edit it in any way and the next thing we'll do is add some functionality to add points remove points add segments remove segments and so on we'll do that in a very basic Way by adding here buttons that just add some of those elements on the screen I want to teach it like this because it's how interfaces were made 30 years ago and then we're going to make it modern I want you to see how things have changed since then so let's go up here and below our canvas element I'm going to define a div with an idea of controls and this is going to contain some buttons that we can press to do operations with our graph the first first button on click it will call a function called add random Point let's call this button add Point like this give it the label and let's implement this add random Point function next I'm going to just make it here on top of this script these functions will go away at some point we just need them to develop the core functionality so I'm not going to worry about the code structure too much and add random point it's going to tell the graph to add a point the graph object will have this functionality so let's pass here as the point a new point and give it random coordinates so X is going to be random and I'm going to scale this by the width of the canvas so that the value is not between zero and one what this gives but between 0 and 600 pixels and the height in the same way now to see this point after it was added we have to refresh the canvas we do that by clearing the whole canvas starting get 0 0 top left corner and with height bottom right corner and then we tell the graph to draw itself again so graph draw on the context so let's implement this ad Point function real quick we are going to go to graph JS and here below the Constructor we say add point a given point and we just take the points attribute of the class and push the given point like so now let's refresh and when we press this button you can see a new point was added there you can try pressing it multiple times and it's going to work pretty much always unless we run out of memory but uh that's not going to happen anytime soon now there is one situation that I want to take care of I don't want to have two points at the same location it makes no sense points are identified by X and Y and if you have two of them with the same X and Y then that's the same point so let's see how we do that we're going to need a function that checks if the graph already contains a point right and I'm going to write it like so using the array find method which finds inside of these points a point that equals the given point like so what happens here is that the find Loops through all of the points here and let's call them p and then Returns the one that equals point and if it doesn't find that point then it's going to return nothing so something and nothing will also correspond to true and false in Boolean logic and we're going to use this as such it's just how JavaScript works so equals here here we need to implement as a method to the point class we need to check if p is equal to the point somehow so inside of the point class I'm going to implement equals point and return if this x is equal to point x and this Y is equal to point Y like so this will only be true if point and this are the same and now we could go here and check to see if the graph contains the point before adding it or we could add the new method to the graph that tries to add a point and then maybe we monitor here the success did it succeed to add a point or not let's log this in the console right here so we can go inside of graph JS here and try add point is going to check if this point is not part of the graph at the moment then we add the point and notice here how I'm reusing the method we defined earlier then we also return true it was a success otherwise we return false like this let's save a refresh and when we press this add Point same thing as before happens pretty much but we always get here this true and that's because it's really unlikely to randomly generate another point on top of an existing one but to test we should force that to happen somehow so I'm going to go here in index HTML copy this entire function here paste it here in the console and instead of having random I'm going to write 0.5 and 0.5 this means that I'm going to overwrite this function so that it generates the points always in the middle of the screen so if we press multiple times on that button the same point will come again and again to overwrite we have to press enter now and let's press this point again once and this is the point in the middle of the screen and when we try adding another one we get our false as well so it wasn't a success and the number of points in our graph graph points 18 doesn't change now we have a way to add points to our graph let's add segments as well we're going going to go here and copy this button and call the other one add segment and the function will be add random segment and we Define that function here at random segment this will work a little bit differently it first gets the points that we want to connect and then creates the segment let's get these points again at random by using floor of random times the number of points floor makes sure that we have an integer value and let's copy this for another index two different points and then tell the graph to add the segment a new segment between the points at index one and points at the index to like this now to see any changes after we press this button we also need this thing right here clearing and redrawing the graph so let's save this and go to graph JS to implement this add segment method we go here below the points section and let's Implement add segment let's call it seg and it's going to take the segments of the graph and push this new one at the end let's save this refresh and now when we press add segment it added a segment here and now I pressed again and nothing happened let's try again nothing nothing nothing what's wrong can you figure out what the problem is pause the video now and try to figure out the answer for you yourself or just listen to me carry on the issue is that here where we are adding these segments sometimes index one and index two could be the same so we create a segment from one point to itself we could check here and say success is false and then if index one is different than index two success is true let's also add the segment only in that case because a segment from one point and to itself doesn't really make sense and let's log this success here as well refresh and when we press add segment we get a true and we see the segment when it appears but sometimes we get the false when we try to link the same point to itself and if we press more times oh we got the true now but I didn't see any change what happened try to figure out what happened pause the video and now I'm going to tell you the answer so turns out it's possible that you add the same segment multiple times as well like maybe now this segment was just added again let's actually see here in the console the segments and the last segment between 200 200 and 100 300 I think that's this one here yeah and you can see they're exactly the same let's try adding few more segments even though they are going to be copies of themselves and now we see here 18 segments but we can really only count 1 2 3 4 5 six so it doesn't make sense to have more than six segments here we wouldn't be able to see them and we wouldn't be able to tell that there are duplicates there this last one actually is the same that we had previously but in Reverse P1 is P2 and vice versa we're going to need to handle that case as well so let's go back here and convert this into a Triad segment as well and move that to the success and have the same kind of structure as here pretty much let's go to the graph and implement this method try add segment and it's going to be very similar to the try add point but we first check if this contains the segment and if it doesn't then and we add segment and return true and here we return false like so this contain segment is going to be here and what we do is again use defined method on the segments this time I'm going to Loop through them using this s and find the one that equals the given segment like so we're going to need to implement equals functionality for the segment as well so here equals is going to be return P1 equals seg do P1 and P2 equals seg do P2 but we also want the opposite check if the points are flipped so we're going to do or P1 equals seg P2 and P2 equal seg P1 now if we we refresh and add a few segments we can see there false appearing many times eventually one of them will work okay so now we have all six of them here and when we go in the console and type graph segments they are indeed six so it works but before we move on this line of code is quite complicated here checking so many things and it's always good to try to simplify two segments are the same if they include the same points so we could make a helper method here called include point and return this P1 equals point or this P2 equals point so now we have a way to check if the segment includes a point and two segments are equal if this includes P1 and this includes P2 it makes sense and if you save and refresh it still works but it's nicer to read in this way and you'll see that later we'll need this includes for other reasons as well now this part here where we check to see if the indices are different we could incorporate it part of the Triad segment so try to see if the points are equal and if they are it won't add the segment so we could actually have success here defined as so and we don't need to use let here we can use const again so try add segment now is going to not only check if it doesn't contain the segment but also if P1 is not equal B2 let's save refresh and try adding segments again and we still have six here great now let's go to index HTML and have a way to remove these segments also I'm going to copy this and say here remove a segment at random and remove segment like this and the function for removing is going to be like this I'm going to first check to see if there are any segments so if graph segments length is zero you can also have a methods added to the graph that check if it has segments or Returns the point count if if you want to do a really really proper job but this is Javascript then I don't bother too much so here I'm going to log no segments just as a warning that no bother trying to remove something there's nothing to remove and return and otherwise we are here where we get a random index from the segments this time and remove segment the one at that index like so we also need to copy this code here otherwise we won't see the change after it happens and now let's implement this remove segment I'm going to go here and say remove segment splice so splice removes elements at the given index here we get the index of this segment and I want to remove just one element the segment itself now you can add many other methods here maybe removing the segment by the index we already had the index here to begin with or try to remove a segment similar as those other ones but they won't be needed in our project and I'm not going to over engineer this refresh and remove segment okay okay okay okay all good and if we try one more time no segments written in the console great let's remove the points as well for that I'm going to add another button here remove random Point remove point and let's copy this remove random segment like this and have here remove random point if graph points are empty no points index is going to come from the points this time remove point graph points and let's implement the function remove point in the graph file let's copy this remove segment and put it here in the points section and rename it to remove point the given point and it's going to look inside of the points array and supplies the points index of point would have been faster to just rewrite this but I wanted to show you how similar these functions are now let's save this refresh and when we remove a point we can see it's gone but I'm removing all the points and and now we also get that message there but the segments are still there and that makes no sense how can you have segments between points if there are points so let's make it so that when we remove a point it also removes all the segments that contain this point so the New Logic will be here let's first get some segments with point the given point and then for each segment of this small list we remove the segment like so using the method that we have defined earlier so we need to implement this get segments with point and I'm going to do that here in the segments section get segments with point we we start off with an empty array and now look through all the segments of this graph if the segment includes this point then we add it to this array and at the end here we just return the array of segments that contain this point simple enough let's refresh and remove point and you can see that the segments connected to it are also gone let's try adding some points adding some random segments question for you given a number of points how many segments can there be between them like in this case we have 17 points how many segments can there be here let me know in the comments and now we can also try removing some segments removing some points good everything seems to work but one more useful button to have here would be to clear everything to remove everything I'm going to implement the method for that here it's really easy let's say this will be dispose of the graph and I'm just going to set the points and the segments to empty setting the length attribute like this doesn't generate new objects for them so it reuses the same array object and in index HTML let's copy this and say remove remove all remove all and the remove all function call graph dispose and we need to copy this again if we want to see the update refresh and it works now you could build an interface like this maybe when adding point it wouldn't just be a random point but have there some inputs for the X and the Y adding the segment maybe it can have a drop down for the first point and the second Point removing again a drop down with all the segments and all the points and that interface would work but it would have so many clicks and so much use of the keyboard that nobody would use it nowadays I will teach you how to make a modern interface so we won't need these buttons here let's remove them actually I will keep the control section here because we might use it later but no need for these functions at all all that was important was to have here all these useful methods inside of the graph Class A good user interface is one that minimizes the number of clicks and keyboard input I'll teach you how to build a graph editor that does that now in other courses I've considered mobile as well but in this series I'll focus on the mouse because I think it's the best tool when creating graphs it has two easy to press buttons we can use for adding dragging and removing points we'll implement the editor step by step adding new features when needed and polishing existing ones until we're happy with the final logic at least I'll be happy with it but if you're not I hope you'll get the skills to edit things in or out just the way you want we will Define our graph editor here after we have the graph and we initialize it like so new graph editor passing the canvas it's going to need that for event listeners and the graph and it's going to also be doing all the drawing on the canvas so actually we don't need this call anymore it's going to be handled by the graph editor and the editor is going to be very interactive it's going to change all the time depending on our Mouse moves and the simple way to implement this is using an animation Loop so a function that we call here and start to animate and it's going to be really simple all it does is it clears the canvas because it's going to redraw again and again so clearing starting at 0 0 and all the way to the canvas width and canvas height and then we'll have our graph editor display itself it knows where the canvas is because it has it here as a parameter and finally we call Quest animation frame and pass this animate call again and again and again it's going to be kind of a recursive call where the browser will try to recall this function 60 times per second so we're ready to implement this graph editor and we'll do that in a new file I'm just going to Define it here in the main JavaScript folder so it's going to be called graph editor and injs create a new file graph editor JS the class is a simple class and the Constructor will get the canvas and the graph as parameters now let's set these values as attributes so that the editor doesn't forget them and let's have a reference to the canvas drawing context as well defined here as a class attribute so that we have easy access to it like so and the display method for now let's just have it draw the graph on this context save the file refresh the page and it looks pretty much the same as before but now if you go to the console and you type for example p1.x is equal to 400 and press enter you're going to see immediately that point jump to a new position because it is rendering again and again and again all the time you just don't see it so we are ready to start adding event listeners for the mouse action I'm going to create a private function private method for this here so it starts with the hashtag and then add event listeners and this method is going to be here below the Constructor the first event listener we add to our canvas is going to be for Mouse down and we get the information from this event and write the arrow function so this Arrow function let's close it here and now implement the body the first thing we'll do is get the mouse location from the mouse down event from The Click so Mouse is going to be a new point and the information is inside of this EVT do offset X and EVT offset y are the XY location of the click now with this point we can just tell the graph to add the point and the code should work so let's refresh and click somewhere and there you go points added anywhere we want them so it's an improvement over the randomness we had previously now one thing that we'll really need in this editor is the ability to select a point and let's Implement that so that the last point that we add is also selected we'll have a more complex Logic for the selection later but now it's just like that to test so I'm passing here this selected is equal to the mouse and this selected will be attribute of the class initially null it can be null if we don't select anything and then in the display here let's draw it separately in a different way so if we do have a selected point I'm going to tell this point to draw itself under the context but this is just going to draw it on top of itself already it's already there from this graph draw so I want to specify a little bit different properties for this selected point and let's give it an outline we don't have this functionality yet so let's save this go to our Point primitive here and in the draw method add an outline here now the more parameters you add here the more difficult is going to be to remember their order so I like to group these as an object like this and now you could pass them in any order you want you just need to specify these properties the name of these properties here like what we just did so if you want to pass this without these options we write here equal to an empty object and then you can just called Draw as we did before in the graph now this outline I'm just going to go here below and if we do have an outline We Begin another path set the line width of two for example and let's give it a stroke style of yellow and draw a new arc at X and Y but our radius will be a little bit smaller I don't want it to be exactly the outline I want it to be kind of inward I like the look of that so let's say radius time 0.6 and again 0 2 pi for drawing a complete circle and again if you want this selected point to look different just make it different it's your code now now let's save this refresh and now when we click somewhere we're also going to have that point that we just added selected and this is how it looks like and the next thing we do in our logic is when we click on a point that is already existing I don't want to create a new point on it or close to it so I actually want to select that point and at the moment this doesn't happen it just creates a new point on top of it pretty much so let's see how we do that we first have to figure out what point are we hovering over so going back to our graph editor in this mouse down event listener after we have our Mouse location we get the hovered Point by looking at the nearest Point so we're going to need the function get nearest point from the mouse from all the graph points like this and then if this hovered Point exists we are going to select it like so and now I'm going to return so the code doesn't go here anymore for adding a new point and selecting it it just select let's define hover also in the Constructor here same as selected hovert initially null and what we need to do is implement this get nearest Point somewhere and what I like to do is create a new file and Link it here in index HTML it's going to be also part of math and we will call this new file utils JS this will have utility functions mostly math functions that will help us during our project so in math create a new file called utils JS and the function for getting the nearest point to a location from a set of points point is going to be a basic minimum search so we look for the minimum distance from our location to all the points and select the point with the minimum distance we do that by initializing this minimum distance to a very large value like this and the nearest Point let's just have it null in the beginning and then we Loop through all the points in the array like this and calculate the distance between that point and the location that we have here as a parameter if this distance was found to be less than our supposed minimum distance then minimum distance becomes distance and we record the point with this minimum distance as well in this nearest attribute then we go here at the bottom and just return nearest and what we still need to do is implement this distance function between two points and this is really easy we've done it countless times I have a special video about it it uses the Pythagorean theorem and we just return the Hot between the difference on X and the refence on y between these two points let's refresh and now when we click you see it selects a point it always selects the nearest point when we click somewhere but we can click anywhere really and maybe we would like to have a limit so that we are close to that point to actually select it because at the moment we can't add new points anymore we're always is just selecting so what we'll do is when we look for the nearest point we'll check also if the point is under a threshold so this third parameter threshold let's have it 10 I like to have it just a little bit bigger than the points so that you can click almost there and it's still going to work and then here our if is going to check and the distance is less than the threshold then it does everything let's save refresh and now when we click here it adds new points but when we are close to something it selects that point and you can still get nearby points if you are outside of that threshold but if you're close enough you actually select it play around with this and let me know what you think what should the proper threshold be now our get nearest Point function here should have this threshold as an optional value really because the name implies it's going to find the nearest no matter what so the threshold here I'm going to Define it to be this very large value that we can use and then in graph editor when we get the nearest point I'm going to pass here 10 like so now refresh the page and the code will work as before pretty much what would be really nice is to know if I'm going to click here will this add a new point or will it select the other one are we inside of the threshold or not and we should know this before doing it otherwise we get surprised by what happens so visualizing the intent is important I think and that's that's what we're going to do next we are going to need to define a new event listener for Mouse move this time so Mouse move and on every Mouse move we are just going to take this hovered Point like so and here in the display we will visualize this hovered Point as well in another way let's copy these lines and say if hovered draw the hovered one as well and this one let's emphasize it with the F this time so F set to true and inside of the point we pass now this fill as well by default it's false and at the end here I'm going to check if we do want this point to have a special kind of fill We Begin The Path and we draw a new arc again at The X and Y and the radius I'm going to have it smaller this time full circle and let's remember also a fill style I'm going to set it to yellow and instead of stroke I'm going to call fill let's save this and refresh and now when you move the mouse over the point you're going to see the highlighted point so you know if you see that that once you click it's going to select it and if you're close but you don't see that and you're going to click it's going to create the new point so the interface is not surprising anymore it's much more useful for the user I don't like this point I think it's too close to that one so I would like to remove it somehow and I'm going to implement removing of points by right clicking on the points we go to our graph editor in our Mouse down here and actually we don't need this hovered anymore because it's already happening here on Mouse move so we could remove it entirely and nothing will change everything will still work and to implement the right click we're going to go here at the top and check if we press the right click or not that information is also part of the event and we do if event button is two this means right click and I write here a comment because I always forget which is which then if if this hovered I'm going to say graph remove point this hovered like so and the logic from here is if we have pressed zero which is left click now you maybe know why I'm confused about these numbers sometimes let's save refresh and now when we right click something happened you actually don't see this but I have this menu appearing on the canvas and let's get rid of that so to get rid of this rightclick menu I'm going to add here another event listener for context menu and the function I'm going to pass is going to call prevent default this is just going to prevent that menu from coming up now let's test again clicking on the same point it removed the segments connected to that point but not the point oh also the point but for some reason the point is still visible until I move my mouse away from it and that's because when we remove the point here from the graph we still have selected and hovered there you could do here a more complex code or you could reactor this saying this hashtag remove point and now go somewhere here below and Implement a private method for remove point that calls the same thing we had before the method we implemented for the graph also sets hovered to n and selected to know to get the proper interface let's refresh and now when I remove it really goes away and no weird artifacts coming now if you test this and for example remove this point you see it also unselected that point any point that is selected will be unselected because we just said this should be null but maybe we want that point to stay selected not make the user have to work again if they want to select it again for some reason so we can easily check for that here and say that if this selected is that point then we Mark selected as null we don't have a selected Point anymore because we removed the one that was selected refresh remove that and it's still selected but if we remove this one then it goes away and no weird artifacts are there okay great does this work in all possible situations well one thing that you'll notice is if you add a point here and right click on it now it doesn't remove it it doesn't go away even after I move the mouse and that's because we're removing points that we hover over our hover is updated here on Mouse move but when we add a new point it's not yet assigned to that point even though our Mouse is hovering over it so we could do that here like so and now creating a point and right clicking on it will indeed remove that point as well small things like this are what makes a interface not just good but really good and people will choose you over somebody else making one now correcting points is possible already if we want this point to be a little bit more to the right we just remove it and recreate it a little bit more to the right but dragging would make this much easier to work with so let's add drag functionality next and in Mouse down when we hover over some something here on left click I want to also enable dragging for that point so let's say this dragging is true and this is going to be another attribute here false by default and as we move if we are dragging the selected point X and Y are going to come from our Mouse location like this now we also want to release of the points somehow and I'm going to do that with another event listener here let's just copy the context menu and this will be for Mouse up like this and what we do in it is this dragging is false and we don't really use this event here so we can remove it now refresh and if I'm going to click and drag this works so I can add points I can drag points and it works just as expected so far we've figured out the points and it's time to move on to the segments as well create new segments and when building roads a very common thing what you have to do is generate the shape of the road like this and you really get a lot of help if the interface is going to generate a new segment between the current point and this new point that you're going to add at each time so let's do that we are going to go to this Mouse down event listener and here when adding a new point just before settings selected to that point we're going to use the previous value of selected if it exists and add a segment between that and the mouse location so I'm going to do this if there is a selected let's try to add the segment new segment selected at The Mouse and the reason why I have Trad segment here is so that I handle things like clicking on the same point multiple times or clicking between the points multiple times which would otherwise add a lot of segments that are overlapping or invisible or something like that now let's save refresh and if I start to click you can see those segments added there just fine but maybe I would also like to add the segment between things that exist already like these ones so let's copy this code also here when just selecting points so before this selected is set to what is hovered we try to add a new segment between this selected and this hovered this time let's save refresh and now I'm going to select this and this seems to work now if I'm going to continue like this at some point I have a problem because maybe I want to connect these two points next and clicking this point or this point is going to add a new segment here something I don't want and the reason for that is I have no way of unselecting points at the moment so if we would unselect points we would unselect this one before clicking on this one and then this weird segment wouldn't happen here so maybe we go up here when we right click and if we are not hovering over anything we do an else this selected is no okay and now I'm just going to try to recreate a little bit that click somewhere else with the right click and now I can click on this point and then this point and get the segment that I want now the code that we have here is pretty much the same this part and this part is identical I'm going to implement a method for selecting a point so this is going to be here a private method select point and in it I'm going to copy one of these and pass this point properly so instead of mouse point point and now up here this duplicate from here we just remove and say this select this hovered and here we say this select Mouse and everything should work the same as before selecting points and selecting points connecting them everything pretty much one thing that we did before for the points this intent showing what happens when you click somewhere would be really useful for the segments as well like now we have this point selected and if we would click here with the left click it will connect them but maybe we forget or maybe the user is new and doesn't want that connection to happen but he does it anyway then this is going to be annoying because what the user has to do now to undo everything is pretty much remove this point and now recreate oh no it selected that one because it was already selected remove this point click it here and connected to that so maybe the user just wanted to select this like so without having anything else selected but if they don't see the intent that having this point here selected is going to create a new segment here then they don't know that they may be surprised by what happens and then a lot of work is needed so I will show this intent of creating a new segment somehow for that we need access to where the mouse is in the drawing section here so I'm going to take the mouse from Mouse move here and make it as an attribute of the class so this mouse is going to be that and I'm going to put this dot in front of everywhere we use Mouse pretty much and actually the mouse that we C calculate here as well it's not needed because we move the mouse before pressing it so we're always going to have it more or less and here this mouse this mouse this mouse I think this is all of them and let's define it here at the top and set it to n like this and with this mouse we can go in the display here before drawing this selected note and let's say we create a new segment from this selected to this mouse and draw it using the context save and refresh and now when we have a point selected you can see this line creeping out so it does tell us that something is going to happen there when you click here it's going to create the segment on that line and when you're going to click here I would actually like this line to snap to that point when I see that point hovered I also want this line to appear there as well so let's do that we will get our intent is the hovered if the hovered exists otherwise the mouse and now we pass here this intent instead of the mouse refresh and now you can see that intent jumping there but this segment that we are drawing here as the intent looks too much like the other ones so let's make it look like a dashed line I'm going to pass here also Dash options three and three and an array this means three pixels of line and three pixels of space and save this and we have to modify our segment primitive to know to show this as well and this starts to have again many parameters so I'm going to group them as an object as we did before so Dash by default it's going to be empty and we do this so that we can just draw the segments without passing any of these parameters now the dash here we set line Dash to the given Dash and after we do the stroke here at the end I like to copy this and reset the dash so it doesn't affect all following drawings many people like to use here uh context save and restore at the end so that everything gets reset but I find it a little bit slower on my computer now let's test and we can see that situation from before so anybody using this would know that clicking here would create that but if they right click and now click there it selects the thing with without any surprise happening so if we test this a little bit more aha did you spot that let's make what we had before here I wanted to actually select the point that I'm hovering and for that I did a right click but right click didn't unselect this one it it actually removed that point so the priorities are different here I would like to unselect first and then delete deleting is more troubling if you do the wrong thing than having a point unselected so going back to this graph editor I'm going to redo the logic here for right click let's remove it if it's selected we unselected else if we are hovering over something we remove the point that is hovered like that save and refresh yeah and now I can select this one even if I'm right clicking over something it doesn't remove it okay test it out let me know what do you think is this a good interface do you want to make it better how do you make it better what is wrong with it write in the comments and let's see if we can get an even better one to work now before moving on to something else I do want to mention a little bit about code cleanup here so this ad event listeners function is kind of long it doesn't fit on one page that's kind of the rule make it fit on one page so that scrolling is not needed when looking up logic so these event listeners for Mouse down Mouse move could be extracted as their own methods I'm going to cut everything here inside of the mouse down event listener call back and create here handle Mouse down private method for this and paste inside it the previous code now here instead of having this Anonymous function we just say handle Mouse down and if we save and refresh and click it doesn't work there's an error here and if we press here we can see where this error happens let's put a break point and click again and inspect this you can see this here is the canvas it basically points to the canvas but we don't want that I I mean the canvas doesn't have a graph the graph editor has a graph and when you exit this scope where this referred to the graph editor now this inside of this function refers to the Target of this event to the graph so we need to tell this function that this should be this and the way to do that in JavaScript is with bind bind this and in this way it will send this this to this function and it's going to work again save refresh and click and now when we hover this it's the graph editor again so removing the break point pressing display the point actually appears there and everything still works we do the same thing also for this mouse move so I'm just going to cut this and Implement handle Mouse move for the event paste this here and here let's just say this handle Mouse move bind this save refresh and everything still works this graph editor is nice but I'd like to make larger graphs as well and my screen size is not that big so I'll teach you how to make a viewport that can be zoomed and panned around to allow editing outside the initial region as well it's going to be like in Photoshop where you can draw like that then we can really make anything we want and it would be a shame to lose a large graph like that so I'll teach you how to save it so it doesn't disappear when we refresh the page now let's begin and get the bird's ey view of the graph we'll initialize the viewport here before the graph editor like so giving it the canvas to work with I will also implement this in a separate file next to this graph editor here also in the JS directory so let's go to JS and viewport JS this is also a class and the Constructor takes the canvas as a parameter let's store it as an attribute like so and let's get a reference to the to the drawing context here as well now the first thing we'll Implement is the zoom and let's have an attribute for this by default it's set to one and add event listeners to change the zoom very similar structure to what we did previous lay in the graph editor but here we'll use different things we're going to listen for the mouse wheel the wheel is going to change the zoom so let's add an event listener to the canvas for the mouse wheel and have a separate callback function called handle Mouse wheel and we bind it to this so that it knows what this is and let's define this handle Mouse wheel with an event here below and let's log this event Delta y property and see what it looks like in the console save refresh and now when you scroll upward you can see minus 125 appears on my computer and downwards 125 we're only interested in that sign plus or minus so I'm going to go back here and say the direction in which we are going to change our Zoom is going to be coming from this sign like this and let's update our Zoom with with this direction so s function from the math library is either 1 or minus one depending on if the value is positive or negative and let's log here this Zoom save refresh and now when you scroll up you're going to get lower and lower values when you scroll down you're going to get higher and higher values and I'm really only interested in this range from one to something maybe one to five I think that's going to be a good range to work with so we will disregard zero and negative numbers and positive ones and we want the zoom to change slower than this so not just by one increment each time so what we'll do here is I'm going to define a step how much much do we want the zoom to change in that direction maybe 0.1 and then here the direction we can multiply it by that step we can also cap the zoom in a specific interval by writing Zoom is the maximum between one and the minimum between five and the actual Zoom value it's a oneliner that keeps it between 1 and five so let's save refresh and see if it works so scrolling up keeps it at one and going down goes down until five so scrolling down is going to zoom out five times basically if that makes sense you could keep these as attributes like mean Zoom Max Zoom whatever I'm just going to keep it like this because usually you don't change these once you implement it and it works the way you want so let's remove now this console log from here save this file again and inside index HTML change the canvas properties based on this viewport information I'm going to go here after clearing the rectangle and save the state and then do a scale with the inverse of this viewport Zoom like this because I want to zoom out basically and then here restore this save and restore are important because this scale is going to be called on each frame so if we don't do anything about it it's just going to scale again and again and again and again on top of each other making some weird effect to happen let's save this refresh and now when we zoom out so I'm doing this yeah this seems to work just fine but um if you click somewhere like here you're going to see that the point doesn't come where it should come and uh we need to fix that the way we get the mouse should take into consideration the zoom as well so I'm going to go to viewport and give it away to get the mouse information it knows what its Zoom is so get mouse given this event information we return a new Point typically we had this offset X and Y but now we're going to multiply it by the zoom and that's going to fix the problem and we need to call this get mouse in the the graph editor where we need the mouse information the mouse location so the graph editor needs to know about this viewport not about the canvas I'm going to change the way that we initialize it here with the viewport and that means we have to go in graph editor JS in the Constructor here change this to be a viewport viewport viewport and the canvas which we do need is going to come from the viewport like that now here where we get this mouse information we just take it from this viewport get mouse using this event information refresh and now zoom out a bit and when we click it works as expected one thing that we should fix at this point is when you zoom out a lot like that it becomes really difficult to click on the points here you have to be very very close so this threshold here of 10 gets shrunk because of this zoom out F so you want an Adaptive threshold basically and you can fix that by multiplying here with the zoom as well what happens now when we refresh and zoom out a bit you can see that point starts to be hovered when we are closer than 10 pixels away from it but we're not really hovering it we just get close to it the same distance that we had previously making it much easier to interact with those points but maybe we don't want this maybe we do want to um have zoomed in view like this when editing to be more precise and now just drag to go to that part of the space where the points are and we're going to implement drag also using the mouse wheel but we're going to click on it and drag by holding the mouse wheel so this middle button will control the offset of the viewport let's define this offset at the top and by default it's going to be Z 0 and we're going to need also a way to store the drag information we're going to be dragging the viewport and we need to know where we started where we ended and compute some kind of differences and add them into the offset like so and I'm also going to add here a way to know if we are actively dragging or not then this event listener for Mouse wheel we're going to copy it three more times so that we have one for Mouse down handle Mouse down Mouse move handle Mouse move and mouse up handle Mouse up and we Define these below here as well so handle Mouse down given the event it's going to first check is it the middle Mouse button that we are pressing is it this one not these other two because then it would interfere with the graph editor so if event button is one this is the middle button then we set the start of the drag to this get mouse EVT this get mouse will have the correct information no matter what the zoom level is then we also say that the drag has started has been activated now on Mouse move we will only do something if this drag is active and we will calculate the end location of the current action so the current Mouse location pretty much and I'm going to to write this in this end attribute here this get mouse EVT so start and end are different after the drag has started and you continue to move the mouse and from start to end that gives you the offset of your current drag and I'm going to store that offset here you just calculate the difference and this is going to use vectors the difference between the drag end and the drag start so this Vector essentially you can imagine it starting at drag start and ending at drag end it tells you how much the offset will change when you release the mouse which is the next thing that we'll do the mouse up event handler if we are inside of an active drag again we add to the existing offset the drag offset and we also reset the drag information here so what we have here at the top this drag is equal to that I'm just going to past it here like so and we need to implement these simple Vector operations here so math utils I'm going to go here below this distance and say add P1 and P2 return new point where we just add the X and add the Y and for subtract I'm just going to copy that subtract and put here minus minus and everything's going to work but we still need to use this offset somewhere so here in index HTML after we scale we are going to also translate viewport offset X viewport offset y save the file refresh the page and now I'm going to press the middle Mouse button move it here and release the middle Mouse button and when I do that the drag has happened but of course you would like to see the drag as it's happening so you want to get the cumulative offset of the current drag action and the stored offset information this works otherwise I'm now going to drag everything back and like this and like that and some interfaces do work like this they don't show the current action to keep the processor usage low but nowadays pretty much everybody expects to see what is really happening at a glance so I'm going to take this offset including the drag and I'm going to have the viewport computed for me so get offset will add viewport offset and the viewport drag offset together and here we just keep this so going to viewport JS below get mouse we will also have get offset which adds this offset the this drag offset like this now save this refresh and as I'm dragging you can see the motion like this and you can feel it a little bit lagging here and that's because our animation Loop here reenders itself pretty much 60 frames per second but your mouse movement is a little bit faster than that so you can see the location of the points dragging a bit and you could get a faster interface update if you link this rendering to the mouse move event but I prefer to use this animation Loop here because at the end there will be things in this world that animate like the car movement and and whatever so this structure here is more in line with what we did in phase one of of the course now zooming out here bothers me a little bit because I'm very used for the zooming to happen from the center somehow not the top left corner so if my object is here and I'm going to zoom in now I expect to keep it in frame and it doesn't happen so we need to consider where the center of the viewport is as well I'm going to go to viewport JS at the top and above this offset let's get a reference to the center point of the canvas so half the canvas width and half the canvas height and now in index HTML before we do the scale so the original width and height of the canvas is going to be what it is and not affected by the scale we translate to this Center at first save and refresh and you'll see that things have moved that way by half the canvas width and half the canvas height so this point here is now 0 0 if we drag everything in the middle though and zoom out and in like this we do get what we want so what we need to do is this initial offset that we have in the beginning it should be directed that way by how much this Center is offset so we're going to go to viewport JS here and our offset here is actually going to be equal to scale this Center by minus one so basically it's going to be a point with minus canvas width / two and minus canvas height divided by two but now I have an opportunity to implement this scale function for vectors here in utils it's a little bit different than add and subtract because it takes the point as a parameter and the second parameter is a scaler it's a simple number it's not a point with X and Y and what we do with it is just multiply both P of X and P of Y like this save and refresh and now the initial view is correct zooming out and zooming in is as expected but clicking is not so now we have to consider also the offset when we calculate the mouse location in the viewport here we do that by subtracting here this offset X and here this offset y and here we also have to consider that Center information as well so I'm going to put in parenthesis minus Center this is before stretching it with the with the zoom and the same happens here with the center y like that save and refresh and now let's zoom and move somewhere and when when we click everything seems to work and you can now edit these points by zooming in and working on different parts of the screen H but now this intent doesn't show well you can see how while I'm dragging here something strange happens to this intent to this line it's fine when I'm not dragging it's always at the mouse location but if I start here and move to the right a little bit it seems to go to the right even more and same happens like this the mouse is always in the middle of the starting point where we began the dragging here and whatever the current tip of that dotted line is there so what we want to do is actually subtra ract the drag offset in this case and I'm going to go to graph editor here where we get the mouse and say that yes we want the mouse by subtracting the drag offet so this get mouse needs an update here where we subtract that drag offset so this is going to be false by default we like this functionality all the time except while we are doing the drag there so here instead of return we are going to say Point p is the new point and what we return is depending on this second parameter if it's true then we do subtract from P this drag offset otherwise it's just p as before save this refresh and now if we select something and drag we can see that it's always still pointing at the mouse apart from that small delay caused by the animation tuop yeah this is quite good but what we really need to take care of is here this animate function is really getting complicated and all of this kind of functionality should be really taken care of um by the viewport the problem is we have this graph editor display wrapped between the restore and everything else and one way to solve this problem is actually move it at the dop so the restore happens before the save and if you think about it it does make sense so now all this code from here before this is going to be cut I'm going to cut it and it's still there it's in my clipboard so don't lose it and we're going to just call viewport reset so we reset the viewport and then we display now this reset functionality I'm going to implement it here and say reset let's just paste everything and CTX will not be recognized so we have to say this dot CTX pretty much everywhere where we see CTX and my canvas it is a global variable but we have our own local one that we can use like this and viewport here it's just this so this this this this and this save refresh and now everything should still work as before but the code is much cleaner and now you are free to make any size graph you want and um might be useful to have a way to save this and this is not really a great graph here so maybe also removing it a button that deletes everything so let's have two buttons here for the save and for removing everything otherwise you'd have to right click click a lot and you don't want to do that in these kind of situations we're going to go to index HTML where our controls were in the very beginning and let's define a button it will dispose of the graph and I'm going to copy this the other one will be save and these buttons will stay there in the end so I'm going to style them a little bit better I'm going to use emojis and this is just a trash can emoji and this one here it's going to be the save Emoji so this dispose function let's implement it here below dispose and it's going to tell the graphic Editor to dispose itself and the reason I do this is that here inside of the graph editor now Above This display it's going to have another public method called dispose and in it we tell the graph to dispose but we also want to reset hover then select it so I'm going to say selected is null and hovered is null like that that's it for this pose so let's go back to index HTML and also handle the save function this one is just going to store the current version of the graph in local storage so local storage set item the graph and I will use Json stringify to convert the graph into a string because local storage only works with strings let's save refresh and let's try dispose seems to work and let's create a new graph here maybe just going to say hi and save it now when we save it we should be able to see it here inside of local storage get item graph like this we see the points and the and the segments just fine but when we refresh the old one comes again the one with the hardcoded values even though the one we stored is still there so we just need to load this information inside of the graph instead of the hardcoded values I'm going to go back here and let's remove these hardcoded things from here leave this as an empty graph for now and what we do is we check to see is there this string information inside of the local storage and if there is we get the info object containing the points and the segments by parsing it using Json parse or it's null if the local storage doesn't contain the graph and now here the graph will either be what is in graph info or this one if graph info is null so let's say graph info and if it exists we have have a new graph with the points and the segments from graph info so we load that original graph that is stored in local storage save and refresh it doesn't work the problem is the things that we have in local storage here are just objects called points and segments but they are not really points and segments in the same way that we expect them to be they don't have for example a draw method this is all they have so we need to convert this information into points and segment objects I'm going to do that by using um static method called load that we're going to add to the graph given some information it's going to create a graph for us so in graph JS below the Constructor let's define it here static load info so we call this function with capital graph as you seen here and this function belongs to the class not to the instances like all the other ones and what we do in it is we prepare our point and our segments with the information from this info so I'm going to get the point information of each individual point from the info points and just say push a new point with Point info X and point info y so what happens now is I'm generating a point with the same information from the Json object and same thing with the segment as well segment info of info segments segments push new segment segment info P1 segment info P2 like this and now with this information we can return a new graph like this so it's not just passing in info points and info segments but actual points and segment objects in two different arrays let's save refresh and look at that just as we expected JavaScript is killing me with this uh serialization stuff to be honest the problem is these p P1 and P2 points are not points they are again objects that have an X and Y but they are not the same points from here even though they should be so we have to take care of that I'm going to remove these from here and we need to find in this points array the same points that correspond to P1 and P2 from the Json info so let's find point that was equal to this P1 in the list of points that we created and also P2 like so save and refresh and now everything looks as expected I really don't like that you have to do so much work to get this to work but it is what it is if you know a better way of doing this do let me know actually I know a better way of doing this we can refactor a little bit and say here for example the points we can just use the map method and go through each point I and create a new one so this I stands for Json info and we create new points using that information in one line so we don't need this for Loop anymore and we can even do the same thing for the segments as well so the info segments we can remap them to actual segments each segment I is going to be a new segment and here we just paste this information like so and make sure that this seg info is high now and we don't need this second for Loop anymore so a little bit more concise save refresh and everything still works it's just a little bit nicer structure here we could design the road border now like this but it kind of looks like a child made them making sure Road borders have the same thickness everywhere is important and not fun so today I'll teach you how to use geometry to wrap the graph segments in what I'm going to call envelopes they're just polygons with more points here to make them look round we then compute the union of these polygons to keep just the outer segments this solution keeps the number of clicks to a minimum and makes the World building very satisfying I think now let's get this show on the road I'm going to draw a simple graph that kind of looks like the letter J save it and now let's Implement a functionality that creates a polygon using these points we're going to test this functionality here after displaying the graph editor like so creating a new polygon with the graph points and drawing it on the context so we need to implement a polygon and give it the draw method same as the other Primitives speaking of which the polygon is also going to be a primitive here and let's create the file polygon JS now the polygon is also a simple class and in the Constructor I'm going to pass the points and store them as an attribute like so and the draw method I'm going to give it the context and some options with uh default stroke set to Blue and the line width of two and I want it to be transparent let's set it to a transparent blue fail style like this now inside of the draw method We Begin the path we set the fil style to the fill attribute the stroke style to the stroke and the line withd to the line WID Now we move to the first point like this and use a for Loop to essentially create line to all the other points one by one until we've connected all of them so CTX line to points of i x and points of I of Y like this and now we close the path this will draw the line back to the first point and then and I want to fill and also stroke this time let's save and refresh the page and now we get this so the graph is still there but now we also see this polygon this blue polygon on top of the graph points and if I'm going to add some more points here and play a little bit with these points maybe connect these ones you can see the graph starts to appear here in the middle but the polygon and the graph are two different things it's not the same kind of structure the graph can have these branching elements here now the next thing I want to do is create a polygon along one of these graph segments so somehow enveloping it in a polygon and and we're going to do that by creating another object called envelope and it's going to be used like this new envelope graph segments of zero the first segment and let's give this a width and the width of 80 pixels and draw it on the context like so as before we Define here another primitive envelope in our envelope JS class envelope and the Constructor is going to take the parameter of the segment and I'm going to refer to this as skeleton it's like the inside of the envelope and the second parameter is going to be the width of this envelope let's store this skeleton as an attribute and we'll use the width to generate the polygon like so in a private method called generate polygon like this now we're going to be working with the points of this skeleton and I don't want to type this skeleton P1 this skeleton P2 all the time so I'll just use the destructuring assignment like this and now we can just use B1 and B2 we also need the radius half of the width and the angle between P1 and P2 two we can get it with ar tangent 2 method between the difference of those points like that now we're going to need an angle that is offset by 90° and actually offset 90° clockwise and counterclockwise so I'm going to refer to that angle like this and just add half pi to Al Al and let's copy this below and say here Alpha counterclockwise and put a minus here for minus 90° and now we can start to get points that are offset so from P1 we are going to get a point P1 CCW offset counterclockwise by translating P1 according to Alpha CC W by the radius this is going to be the offset that we move it along the angle from this given point B1 we're going to need to implement this translate method but I'm just going to first use it here to define the other similar points P2 CCW coming from P2 and then P2 CW coming from P2 and Alpha CW and P1 CW coming from P1 Alpha CW like this and these are the points that we will use to create our polygon so we return a new polygon with this array of points like so let's implement this Translate method and maybe we'll also extract this angle function because this is kind of cryptic here like if you don't know the formula what is this doing so inside of math and utils I'm going to go here at the bottom and Implement our translate method which returns a new point relative to the given location we add and now we have to use the trigonometric Circle and remember that on the X it's the coine of the angle and we multiplied this cosine by the offset how much we want to move it because cosine is between 0 and 1 so multiplying this is going to move the point a total of offset on X and Y respectively so diagonally now that angle function is going to be really easy given a point we just output its angle like this and back here we can replace this with angle and then we can just subtract the two points because that's what this is doing so let's put here angle subtract P1 P2 and to draw the envelope we also need to give it a draw method here and for now this is just going to tell the polygon to draw itself now save this and refresh and we get this you can see now this polygon forming surrounding only the first segment of the graph the others are ignored for now but I want this polygon to have curved sides like that here surrounding this because round roads are just nicer so let's figure out how to do that here I'm going to first collect some points around P1 I do that by defining here an array called points and now let's loop from alpha counterclockwise to Alpha clockwise and increase this I with a step we'll Define that in a second and then push into this points translating P1 at this I angle by the radius and this step is going to be a fraction of Pi actually I like to use Pi when dealing with circles and let's try to see what these points look like so I'm going to pass here points instead and we really don't need these other variables they were just there to learn how this works save and refresh and now we get this we get some kind of curviness here we can actually control this by this value if we put here 10 for example we're going to get a much more curvy shape and let's do the same thing with P2 as well so I'm going to copy this below and this doesn't change but here we are going to use P2 and it's on the opposite side so 180° difference and I'm going to add here matte pi plus I like this and save refresh and now we get this this is actually a parameter how round we want this shape to be and we could replace this with roundness and here let's pass it as parameter roundness and I'm going to pass it also here and here maybe give it a default value of something let's try let's try what happens with zero like zero roundness this doesn't really look good let's try one it's what we had previously and this is actually what I would assume to have if the roundness is zero as well so I'm going to go here and do this kind of trickery to avoid that zero situation because it doesn't make any sense and now when we set zero here it's actually going to look like one so when moving it like this there seems to be some problem and it happens because here sometimes I doesn't exactly reach Alpha uncore CW this happens because how floating Point numbers work and sometimes you just get a value that is below that and the next value adding step exceeds feeds that so it never hits exactly there and then you're far from this end result we can fix this by adding a small Epsilon value and I'm making it here a fraction of the step we add this Epsilon value here to this and in that way we guarantee that we include this final angle there and we don't go overboard because it's just half a step in this case so I'm going to save this refresh and now no more strange artifacts like that coming I'm going to keep this default roundness here to one because it somehow makes sense you can create an envelope without a roundness and we can play with the parameters here as well if we want maybe set a width of 200 and let's give it a roundness of 20 see how it looks like okay really round large shape there now I really want to generate these envelopes for everything and it's time to start thinking about defining our world object the one that will contain the roads and all the other components there because these envelopes are going to be part of what is required to build that world so let's implement this world object containing all the things and in there have a way to generate all the envelopes for all the graph segments I'm going to go here below this graph definition and instantiate the world with the graph the world will be based on this graph and now I want this world to automatically update every time we change some things every time we edit the graph and I'm going to add this call here to generate the world and also to draw the world and I'm doing it before the graph editor because it's going to contain things and I want to still see the editing tools on top of that let's now import a new file called World JS and this is going to be here in the root JS directory so next to the editor and the viewport and the class is going to be also relatively simple for now it's going to become quite complex by the end of this course I'm going to pass here some default parameters like the road width and roundness and let's store these things as attributes as well and roundness and now I want to store these envelopes to generate these envelopes uh we will generate them in this class attribute which is empty by default and the generation will happen here we generate them with this generate method and if they're already generated because we do this in a in a loop in in the animation Loop we empty this array to begin with because we are going to regenerate them again and again on each frame maybe we change the editor and then we want the changes to reflect in the world that we create so let's Loop through all the segments now like this and push into this envelopes array a new envelope from this seg and with the road width and Road roundness attributes from above and now this world is also going to need a draw method and I am just going to for now Loop through all of these envelopes and draw them on the context one by one let's refresh and now we get this um funny to play with this reminds me a little bit of this uh quop game I made in uh live stream once all right now the thing we need to deal with next are these sections here these kind of inter sections between these envelopes they need to somehow disappear and all of these envelopes should form a union a single shape that doesn't have any kind of overlapping Parts the first step in that is actually detecting these intersecting points all these small intersecting points between the envelopes and we are going to do that for the first two envelopes to begin with maybe I remove this part from here and save a simpler version of the graph to avoid confusion so let's find all these intersecting points here somehow we'll store these intersections here in an attribute and the function that will do this is called break it's going to be a static method inside of the polygon class and it's going to take two polygons and break them you'll see what that means soon enough but it will return these intersections that I was talking about so here we are going to draw also these intersections after the envelopes maybe int int and this intersections here and and they will appear on the canvas after we implement this break method let's go to polygon JS and it would be useful to have the segments of this polygon as well the sides of the polygon having them readily available here is going to make implementing the brake function easier so in the Constructor I will also get the segments by looping starting at one through all the points like this and pushing into the segments array a new segment between the previous point and the current point and I want this to Loop so when I is going to be equal to points do length then points of I would return an error but doing this is going to return the remainder when dividing by that so this will jump to zero instead of giving an error and that's going to loop around and connect back to the first point which is what we want to have that segment as well and now we can Implement that static method called break that takes two poies poly one and poly two and really only uses the segments of those so let me just take poly one segments and poly two segments like this and now Define the intersections that we want to find and find them by looping through all the segments of the first polygon and for each segment we check to see if it intersect any segment of the second polygon so we need this other for Loop here as well and then we get the intersection between P1 P2 of the first segment and P1 P2 of the second segment and then we check here if the intersection exists because sometimes segments don't intersect and if the offset is different from one and different from zero this means that they don't intersect exactly at the tip which is a situation we want to avoid then we get the point from this intersection object you'll see that in a second and push to the intersections this point and then return intersections like this now I'm going to go to utils JS and add this get intersection function and I'm just going to go down here and paste so this function I'm not going to explain I already have a special video about it and it was part of phase one of the selfdriving car course so if you took phase one then you already know what this is it also includes this linear interpolation function which I also have a video about and we also Al used in phase one I will link to this code somewhere in the description so you can copy it now but let's see if it works and it does show some points here let's make them a little different looking so we don't confuse them with the graph points so here when we draw the intersection I'm going to say color it red and uh make it smaller I think the red color is enough striking and now we get this yep seems like it works and what we'll do next is we're not done with this break method here it doesn't just create the intersections but it's also going to break break these segments so that for example this segment here on the side of this envelope is going to be divided into this segment and this segment after that we're going to take the segments that are contained inside of another envelope and remove them that's how we're going to do the cleaning so let's do this breaking at this intersection Point here after after we have this intersection point I'm going to keep a reference to P2 of Segment 1 and replace P2 of Segment 1 with this so what we did now is instead of having this large segment we just replaced the end point to be here this space here is empty and we need to create create a new segment that starts now here and ends at that place that's why we kept the reference to the original P2 we need to use it now and we do that by using splice at I + one so the next segment and we don't remove anything splice expects here how many things to remove from the array we don't want to remove anything we want to add a new segment starting at the intersection and until what was P2 previously and we do this also for the other segment where the intersection happened so I'm going to copy this without this let because I just want to reassign this auxiliary variable to something else and this is going to be seg 2 of J and SE 2 of J SE 2 splice at j+ one and this should work but we need a good way to test this and I'm going to do that here I will Implement a way to draw the segments by using different colors and in that way we know if it's the same segment that continues after the intersection point or something else so going through all the segments I will draw them on the context with the color get random color and this let's go to utils again I'm going to paste something again we used it in Phase One to draw cars in different colors let's also go to envelope JS here and after we draw the poy normally I'm also going to draw segments with this debugging function we just implemented so refresh and now we get this crazy thing with a lot of colors going around let's make these segments wider I think they are not very visible as such so I'm going to pass here inside of the polygon JS draw segment also um width of five now refresh looks a little better I'm actually going to remove the intersections we don't need them anymore we know they work and actually this breake function doesn't need to collect and return the intersections it just needs to break the polygons so I'm going to remove this part from here here as well it uses the get intersection function but it doesn't collect the points we don't need that and inside of world JS I'm going to stop using the intersections there refresh and things move a lot but you can kind of tell that this color here is not the same as this color here and here there are quite many small changes as well you can debug this better by typing debugger in the console and this is going to instantaneously stop what is happening here and you can see this green red orange and pinkish color here and a lot of these small changes here every time something intersects so the code seems to work but only for the first two envelopes if I'm going to draw here another one you can see this segment here is not affected this segment here is not affected and same for the small ones here so this is the difference what we did now breaking the polygon segments at the intersection points contrary to what we have on the right and what we're going to do next is do the same thing on the right and for every possible combination of envelopes instead of having here polygon break we are going to remove this line and have polygon multi break and I will take all the polies from all the envelopes and send as a parameter one array now this multi Brak inside of polygon JS let's add it here at the top is a static method that gets this array of Poes and I'm just going to Loop through the polies excluding the last one and then for each of these Poes loop again starting at i+ one so I'm not going to compare Poes twice I'm just going to compare every poly with all that follow afterwards and that means we don't do unnecessary work and this one will go all the way until the end and now we use the previous method break between Poes of I and Poes of J like this and if we save and refresh let's add again this other segment here and call here debugger we can see now that this intersection is breaking everywhere as it should and what we'll do next is calculate a union of all the segments that are not inside some other envelope so this segment will disappear this will disappear this will disappear this small one here will disappear these will disappear because they're in this envelope and these will disappear because they're also in this envelope these disappear because they're in this envelope so everything that is inside some envelope will disappear and the result from this will just be a set of segments that we keep it will not be a polygon anymore because for example the resulting shape here would actually be a polygon it would start like this and go like this around and then have a concavity here but if you think about this shape here it would be a polygon that also has a hole and that's a more complex structure and I don't want to get into that so let's Implement our Union function maybe we save this graph as well and here we start off this Union process with the given Poes with a multi break so we break them to get the individual segments and now let's collect the segments that we wish to keep in this array I'm going to scroll down because this is going to be a longer function so looping through all of the polies one by one one and now looping through all of the segments of a given poly we have to figure out if we keep this segment or not so I'm going to say keep is true for now but if this segment is inside another envelope another polygon here then we don't keep it so let's Loop through the Poes again through all of them but ignore here the situation when I is equal to J so we don't want to check if a segment is inside of its polygon it makes no sense and in that case when it's different then we check if it does contain this segment if one of these Poes contains this segment this seg right here then we don't keep it anymore we say keep is false and we can break here to save some computational time because it could be inside several envelopes and here if we keep then I'm going to push it to the kept segments like so and at the end here we return these kept segments so it's a longish function but um it is what it is I'm not going to refactor it anymore what we need to do next is implement this contains segment function so how do we check if this segment is inside something else and because these segments that are in inside are entirely inside something else I'm going to simplify this and only work with the middle point of the segment so the average of the endpoint locations here what that means is that this contain segment is going to transfer its functionality to another method called contains point which is a simpler thing to do now this is not really a great implementation because sometimes the segment may be just partially inside but for our needs it's going to be okay the only problem is the name of this method right here contains segment is a little bit misleading because it only checks if the midpoint is contained inside it and the average function here it's just a simple thing that we add quickly here in utils let's move it next to the other point Vector operations so average of two points I'm just going to return here new Point p1x + p2x ided by 2 and P1 y + P2 y / by two like this and now we can go back and implement the content Point algorithm for this we're going to need an outer point that outer point I'm just going to Define as a point that is far away in the top left maybe minus 1,000 minus 1,000 I just hope nobody goes there and draws the graph in that area it's going to make some small glitches happen I guess and then what we're going to do is we're going to check how many times this line segment from point to this outer Point intersects the polygon if it intersects one time then it means that we are inside but polygons can be quite complex shapes sometimes this line segment may cross it multiple times maybe it goes outside and then inside again and then outside again but if it's always going to be an odd number of times then that means that we are still inside the polygon if it's an even number of times it means we're outside of the polygon we just crossed it to go in and then out then we reach this outer point and even number of intersections so that's how the algorithm is going to go I'm going to Define here intersection count set it to zero and go through all the segments of this polygon and calculate the number of intersections from Outer point point to P1 and P2 of this segment and if there is this intersection I'm going to increase the intersection count like this and at the end we just return if the intersection count if the remainder when dividing by two is zero then this doesn't contain the point because it's even but if it's one then this does contain the point so we are done with our method now to test we need to assign these new segments to some object here and I'm going to call this road borders like so and here we are going to say Road borders is equal to polygon Union of all the Poes and in the draw method I'm going to Loop through all of the segments of this road borders and draw them under context maybe we give them some clearer style here let's give a white color and a width of four so the line is thicker let's save refresh fresh and now you can see here these white sections are only on the outsides of the envelopes let's set um larger roundness maybe 10 and now you can see these white sections are here curving quite nicely around this shape let's Style this to look more like a road I'm going to make the envelopes um gray let's remove also this crazy colorful highlighting there so the envelopes here I'm going to style them with the fill of BBB so this is light gray and the stroke is going to be also the same this means we have to pass options to the envelope draw method as well because it doesn't have them at the moment so options and let's pass these to the poly so that it's going to use the same options and we don't need this draw segments anymore for the colorful highlighting refresh and now it looks like this and you can play around with it and see that it does behave quite nicely as you would expect but I would like to add a little bit more of a region here that is gray so that this white border of the road is not exactly on the border of the road but the road continues just a little bit it's just a marking to do that I'm going to go back here and give also um line width of maybe 15 to the envelopes and now we see here this margin like that and I would also like to draw the mid lines on the road as dashed lines so for that we're going to go here and loop through all of the segments of the graph and draw each segment also with white and also maybe for and a dash of 10 10 save refresh and something happens here but this um graph editor is blocking and I can't really see what is happening maybe we go to index HTML and um let's try commenting out this graph editor yeah and uh graph editor actually still works even without displaying the the things there so you could leave it like this but I don't like it I don't get those intense marked in any way like if I'm hovering something or what is going to happen when I click here uhuh something weird happened I didn't know that because I don't have my editor anymore so I will remove this and I will just go here and add um transparency for the editor I think that this is going to be enough so now I still see it but it's not anymore the main thing there the roads are more emphasized we're going to add some decorative items next the buildings and the trees and we'll just focus on the basis first fancy stuff comes later now with few modifications we could use the same graph editing tools to generate the bases of the buildings as well but I think it's really tedious as especially if you plan to build really big worlds and if you want things to align just right so we'll reuse the functionalities we already have and Implement an algorithm to procedurally generate buildings next to the roads and then just Place trees randomly where they fit this solution does have a downside that you cannot have a building exactly the way you want it but I think it really compensates for that because generating everything becomes so fast and easy that you actually could build Rome in one day let's go to world JS and here in the Constructor add some more properties for generating buildings I'm going to align these a little bit different because there will be quite many things appearing here first one is the building width and then the building minimum length the length will vary depending on the size of the road segment I want to have a minimum value and in this case setting it the same as the building width means that in the worst case we will have a square building otherwise it's just going to go alongside the road and the spacing is so buildings don't get stuck to each other now let's set these values here as attributes of the world like so building width to minimum length and the spacing and let's store the buildings here in this array now we'll generate the buildings inside of the generate function here by typing buildings is equal to this generate buildings we'll write all the functionality in this private method the algorithm will go like this we first generate some thicker envelopes and use the same processes before to get the outer segments from these we keep those is long enough to support at least one building and if they're really long we divide them into multiple supports like this we then generate a poly around each of these using envelopes again and do a little bit of fine tuning you'll see generate buildings let's first get these thicker envelopes I'm just going to call them temporary envelopes because we don't need them afterwards from the graph segments we take each segment one by one and create an envelope using it and push it to this temporary envelopes so the envelope that we're going to create has the segment as the skeleton but then the width we have to calculate so it's going to be the Road width and then I'm going to add here the building width and then the spacing twice and finally the roundness I'm just going to use the same one from the road now let's return these envelopes for now these are not buildings just yet they here just envelopes but we will use the result of this method and the contents of this buildings array to debug and we are going to display now those envelopes even though here I'm already going to WR as if they are buildings save and refresh and we see this it's uh not really clear but um these are some thicker envelopes than the ones used to define the road so next step is to avoid these inner segments here so we do the union of these envelope poies here and those remaining segments will be guides I will refer to them as guides here and they will be computed by doing the Union on these temporary envelopes so I map here just the police let's paste this here and debug and now you can see these guides appearing here as segments this time and the buildings are going to be generated on them but not on all all of them only if the guide is longer than the minimum length of the building so let's filter out these very small segments here in the curvy areas and anything that is too short to support the building we are going to Loop through the guides that we have let's just take it here like so and if the length of this segment is less than the minimum length of the building then we are going to remove that I will remove the guide at I one of them and then we also have to do I minus minus here because when removing something from an array it's going to shift everything over this so then the index at I where we are will have some new item that also needs to be checked so if we let I increase which it will for the next step it's going to skip that one unless we decrease as well now this segment here we need the way to calculate its length and it's really easy we just go to The Primitives segment and Implement a length method here that will just return the distance between this P1 and this P2 now we can save and refresh and you can see it looks different these are the only places where buildings can appear in this scenario The Next Step will be to generate the supports for those buildings so for example this segment here is quite long and it's probably going to support multiple buildings and I want to get small segments that we can use as a way to define the buildings around them using envelopes again you'll see now let's say that we could fit three buildings here I want them to start from here and here and also have the spacing in between and the logic for what we're going to implement next is going to be much easier I if we consider a little bit of extra spacing at the end as well because then we can think of a building as the building and its spacing the building and its spacing the building and its spacing and that will help in writing the code so let's go back to World JS here and Define these supports that we need to calculate next and loop through all the segments of the guides and for each segment let's calculate that length with a little bit of extra spacing there so it's the length of the segment plus this spacing and now we can find out how many buildings would fit so the building count is going to be ma. floor of the length divided by this building minimum length plus this spacing and now that we know how many buildings there are we can find out what is the actual length of the buildings so the buildings on this segment will have a length equal to the length of this total segment with the extra spacing divided by the building count but now we have the building and the spacing included in this length so let's subtract this spacing as well and we can proceed to generate the supports along this segment with this building length that we calculated so to do that I'm first going to focus on the first support so let's get the direction of this segment we're going to needed and then two points q1 is going to be segment B1 and Q2 is going to be according to segment q1 we move along this direction the length of this building length so what we're going to do is add to q1 scaling this direction vector by the building length and add this segment to the supports like so let's implement this direction Vector it's also easy going to be calculated by normalizing because I don't want this vector Vector to contain any magnitude any distance really it's going to have a distance of one a magnitude of one and we just get it by subtracting P1 from P2 like this so this is going to be the vector from P1 to P2 and it's going to be normalized so it's just the direction there this normalization we don't have it implemented just yet but it's easy to do we just go to utils and maybe here below the scale we normalize P by just scaling p with the inverse of its length of its magnitude and now this magnitude it's just the distance to the origin so I'm going to implemented using the hypotenuse there and I'm only going to pass X and Y because the difference is X and Y the other point is the origin and refresh I have a typo here World JS floor refresh and now it works looks pretty much same as before but if we make one segment longer it doesn't work I forgot to pass here the supports to the return as well okay now if we make this segment longer you can see that only the first support for the buildings along this line is shown and same happens here so let's do the other ones we just Loop here starting from the second building until we reach the building count and update these q1 and Q2 so q1 is going to become Q2 but we add the spacing in the direction of the direction vector and Q2 is going to be q1 now but we add in the direction Vector the length of the building this time and we add a new support segment between q1 and Q2 let's save this refresh and now we can see these supports for the buildings appearing there let's generate the base for each of them using the envelope with no roundness we are going to get a rectangular Reg there a polygon so here after we're done with these supports I'm going to write bases like this and looping through all of the supports I'm going to push a new envelope from this segment with the building width as a width no roundness because it's going to default to just a rectangular shape and then I take from here the polygon I don't want to use envelopes here I just want the polygon I'm using the envelope Constructor to get the polygon that I want pretty much and now let's remember to return these bases and refresh yeah this looks nice but here there are some intersecting bases and I'm just going to remove one of them if this happens so let's go back here and say looping between all pairs of bases to find those that intersect if some of them intersect I'm going to Loop through all all of them except for the last one and now all following ones so starting with j at I + one and going until the Bas is length to include the final one as well and now we check to see if bases of I intersects the poly bases of J and if it does I'm going to remove let's say basis of J because it's the second forward Loop there and decrease from the second for Loop because of the same issue mentioned previously now this intersects poly we need to implement and we're going to go in polygon JS somewhere here maybe and type intersects poly a given poly and we're going to look through all of these segments and all of the Poes segments and we check to see if there is any intersection between any of these in theory it's possible to have a polygon inside another so their edges their segments don't intersect but we are not going to have that situation because of the sizes that we have defined and um topology of the network so let's return true here and return false here now let's go back here and before I refresh I'm going to save this state so that when I refresh I'm going to have this same situation and let's refresh now and see what happens so this one Building from here disappeared it's okay if we have empty spaces like this sometimes we're going to fill them with trees you'll see now let's test a little bit oh oh there is some weird fidgeting happening there on that side let me try to isolate when it happens like this one there should definitely be a building there I'm going to save this state and try to fix it the problem is is actually inside of our get intersection function here and it's not really a problem of the logic or the math but it has to do with floating Point numbers sometimes this bottom here is basically zero but because of how floating Point numbers work it's not exactly zero it's very very close to it and that's the situation that you see here the building disappears here because that triggers that bottom to be close to zero instead of zero so some kind of fake intersection appears there and I'm going to fix this by just using here a small Epsilon value and instead of saying here bottom different than zero I'm going to say absolute value of the bottom because it can be either way is is greater than Epsilon and let's refresh and see what happens here and the problem is gone and you will see that there is no more fidgeting happening now let's move on and generate trees in this region I'm going to close some of these tabs I have open here at the top and go back to The Constructor here in World JS and prepare a holder for these trees and they will be generated here generate trees in a new private method generate trees and let's start by giving this uh parameter and say we want to generate 10 trees somewhere in the region occupied by our graph now the way this will work is it's going to prepare a trees array here and while the length of this array is less than the count it's going to try to add more trees here and for now they will be just simple points and I will randomize the location using lurp so I'm going to lurp between the left side of the region the right side of the region and then from the top to the bottom and these Left Right top bottom we will need to Define above but basically randomly generating trees within the region is what we're doing here and let's push the tree into this dis array and return trees like so now for this Left Right top and bottom top is going to be this point right here it's the minimum y value of the buildings and these um envelopes sometimes the envelope could be the topmost thing like maybe and this situation right here and same goes for the bottom so we need all the points coming from the envelopes forming the road and the polygons forming the buildings for the road I'm actually going to use the segments from the road borders that we have already so here let's take those points into a variable points is equal to and here I'm going to form an array with from the road borders let's map each segment so that P1 and P2 go in a new array and after all of them are here in an array so an array of pairs of points also arrays we can flatten that into one single array of points and we do a similar thing also for the buildings but here we map the points because they are available as uh part of the Poley and we flatten these as well otherwise we're going to have a big array of small arrays with four elements okay and now we get left right top and bottom so left is going to be the minimum value we map again from these points so that we only take the x value and we spread here the spread is used just to take individual items not the whole array and we've used it everywhere here and um let's do the same thing for the right but with the maximum here and let's copy both of these for the top with the Y value here and the bottom with the Y value here so minan max min max is uh okay here and let's draw these trees so similar how we do the buildings here I'm going to Loop and say that through all the trees draw the tree they are points for now now let's refresh and you can see something funny happening here they're generating again and again and again and again at each frame because here in index HTML we do generate on each frame and because we use Randomness we get this funny effect going on but it's kind of okay because it does show us that the region where they're appearing is indeed what we expect it's probably time to stop generating this graph again and again on each frame it's very processor intensive and only generated if it changes for that we're going to go here and calculate the hash for the graph a kind of unique identifier so let's say that the old graph hash is the graph hash we're going to implement this function soon and this is going to be the one when the page loads in the beginning and here before generate we are going to check if the graph hash is different than the old graph hash then we generate and all the graph hash gets updated to the graph hash like so let's close this and invent this better and the hash I'm just going to stringify the graph so in graph JS here at the top I'm going to add the hash function that only converts this into a string let's refresh and you can see now the points is dark points here are now the trees and every time we change the graph they actually get regenerated so what we did works next will be avoid generating trees in these illegal places like on the road here or inside of this building let's go to world JS where we generate the trees and above this Loop I'm going to have a holder for these illegal poys where we don't want things to be inside so illegal poce a new array and here I'm going to spread the buildings they are Poes still at this stage later we're going to actually make a building class for each of them so we'll have to refactor this code a little bit but now this works just fine and from the envelopes I'm going to take each individual po like this so let's check to see if the points that we are adding here should be kept as a tree or not and I'm going to implement this like so keep is true by default and then looping through the illegal Poes if this poly contains the point P then we say we don't keep it keep is false and we can also break here because it's enough that the tree is in one poly it's not going to be inside another one as well so no point to look for another one in this case and here here I'm going to wrap this in his keep then push the tree to the trees otherwise this is going to try again and again until you reach that count let's save and refresh and now the trees don't intersect those and we could try also changing the graph a little bit just to see multiple Generations and it doesn't seem like any intersection is happening so the trees are in almost okay places the problem is these trees also have a size right so maybe this is too small of a space for the tree to be in and that's what we are going to need to do next let's define the size for these trees here as another parameter and I'm going to save it here as a attribute and when drawing the trees let's also give them this size so that we see them properly and I'm going to give them a color that is transparent black so that we see intersections between trees as well that's another thing that we're going to look out for close this save and refresh and now you see those things that I was talking about so these trees first of all they intersect and then also they hit the other objects there so we need to take care of these somehow let's first take care of these trees that intersect so if a tree is too close to another tree then we just don't generate it there we try to generate it again so back in the generate Tre function here just before we decide if we keep the point or not I'm going to say if we have kept it so far we are going to Loop through all of the trees and if the distance from the tree to this point that we want to decide on is less than the size of the tree then we don't keep it we can also break save and refresh and now the trees shouldn't intersect each other anymore because we said that the distance between the trees should be bigger than a tree so that problem is solved but let's also solve the problem of being too close to the road or too close to the building Poes so here where we check if the illegal poies contain the point I'm also going to check or the distance from the poly to the point is less than half the tree size so here we just need the radius let's save and implement this distance to point function inside of the polygon maybe here distance to point for a polygon is going to return the minimum distance between the point point and all its segments so I'm just going to map through all the segments and return the distance to the point from that segment and then spread and return the minimum of that let's save and now we have to implement the distance from a point to the segment so we go to the segment file maybe somewhere here and I'm going to paste some code this code is explained in my other video and I'm not going to go through it now you can also copy this code from a link in the description and notice one thing that the distance to point uses this project Point function here so that's why there are two methods that I pasted here and also one more Vector operation the dot product needs to be add added in utils so save this file and then in utils where our Vector operations are maybe somewhere here I'm going to paste this dot product now let's save and refresh and you can see where the trees are now this is a time when you should be a little bit careful because well if your space is so small that the trees wouldn't be possible to fit you're going to get an error and not really an error but a problem with the execution your while here will never end because trees's length will never reach count so that's why I've used only a few trees until now we would like to write this in a way that it doesn't depend on a count but on something else because if I'm going to make now a very big graph here like so it's still going to generate 10 trees but much of this space is going to be empty 10 trees in a very very big city will be will be nothing so the way we will rewrite this is not having a counter here but having a try count here so what we will do is we will try to add trees and if at some point we tried a lot we just assume there are enough trees we can't add anymore so what we do here is try count set it to zero and here let's say while we try for 100 100 times we're going to do all of this if we manage to find the space for a tree then we reset the try count and then increase the try count on each step this is very important otherwise we have an infinite loop again now refresh the page and you can see the trees and they are 1 2 3 4 5 6 7 8 9 10 10 11 12 13 14 but the number of trees will really depend on the size of the area here really and uh come to think about it there are some situations like I don't really care what is here in this section it's so far away from the road if I think about our selfdriving scenario we will mostly just watch what happens on the road and we might see some trees here here maybe here if we zoom out a bit but our Focus will be on the road so generating trees so far away is kind of a waste of memory and I'm going to add a control for that so let's go here and add another filtering step if we still keep the tree up to this point we are going to check if it's close to something by default we say that is false and then Loop through all of the illegal polies again and if the distance from the poly to the point is less than I'm going to put here tree size * 2 so that I can fit up to two trees uh away from the from the items then I say yes there is something nearby we are closed to something and we can break we don't need to look further and here I'm going to say keep is this close to something now save refresh and you can see now the trees no longer get generated in these sections now this piece of code with all this filtering is a little bit long it's quite long actually maybe should refactor it somehow extract these as functions but I'm just going to add here some comments so this is going to be a check if the tree is inside or nearby the building or the road and then here check if Trees Too Close to other trees and here avoiding trees in the middle of nowhere so I think this is fine let's save refresh and test again sometimes these buildings can still be quite close to each other and I don't like that very much that uh spacing is not preserved also here between these ones because there's this point here on this otherwise straight line let me save this state so that I have it for f future testing and go where we generate the buildings here we check to see if it intersects the poly but we can also pass now if the bases of I distance to poly base of J is less than this spacing that's also a problem and we need this distance to poly function implemented in polygon JS but it's going to be quite easy we just go through all the points and say that for each point we take out the distance to that poy so now the distance between two Poes is actually the distance between the closest points it's not exactly what we want because sometimes you might have poies that are offset a little bit and then the distance will appear to be this um even though they are touching but it doesn't matter very much in our case because of how aligned the things are and for this we would need to have a way to calculate distance between two segments and I don't have a tutorial for that yet so it's just going to have to do let's save and refresh and now you can see here that building is gone it's going to leave an empty space there but it's just fine maybe it's going to get filled by some tree like now there will be trees there let's test uhuh there's also one more problem here these buildings are now leaving gaps here again and this is because of that floating Point Number issue sometimes the buildings that are like this and should have a spacing there don't have it because when we calculate the distance now because of the floating Point values just appear a little bit short so back here in World JS instead of just spacing I'm going to add a small Epsilon here as well so minus the Epsilon save let's save this state and refresh and now you can see that those buildings don't have the Gap there what if you want things to look 3D well you could refactor this entire app to use a 3D rendering engine some people already ported the code in Phase One to use 3js or even used other programming languages to do it so what I'm going to teach you now is not the only way to do it and I'm not really sure I recommend it I mean if you really want to make something three the user Library it will take care of cameras lights and a bunch of other things making the end result more professional but I think teaching you this is still interesting because I like the way it looks and getting this to work was actually easier than I thought you may also find the math interesting since it touches on some principles of how 3D renderers work even though they mostly use triangles or boxal and we won't be doing any of that I promise I'll stop here and we won't go to higher dimensional spaces get it no because I have that video on how to calculate distances between points in higher dimensions and no no no let's start converting our tree points here into actual trees so instead of pushing just P here we're going to push a new tree at be with this given tree size let's go to index HTML and import a tree object and I'm going to copy here this viewport and the trees will be inside of items slash tree the buildings will be also in items so let's go inside of JS and create the items folder and then inside the items we are going to have our threejs and this is going to be just a simple class again with a Constructor at the given center with the given size let's also store these attributes Center and the size and by the size I mean the size of the base of the tree so let's make it the year and the draw method for now is just going to draw a point at the center with the given size and let's make it green this time so that we know when we test if it if it works or if we're testing some wrong version now this code won't work directly we need to refactor a little bit here in World JS you see here where we are checking to see if we're too close to other trees distance between tree and point makes no sense so we need to take here instead of tree we add tree do Center and also when drawing here at the bottom everything we don't need to pass these styles to the tree anymore because the tree knows to draw itself so let's save this and refresh and now the circles here are green I'm going to teach you how to make them look 3D is next let's begin by drawing a line at an offset a segment at an offset here so inside of tree JS we are going to calculate the top of the tree as the center but adding an offset so it's going to be to the top left towards the top left this offset by 40 on X and 4 and Y and now let's draw a segment from Center to top like this save refresh and you can see this it kind of looks like sticks going up from this circle but we are watching all of them from the same angle and we don't really want that we want the angle to change depending on our Viewpoint here so these should look like that but these should go the other direction so we need to know this direction from the Viewpoint to the center of the tree we're going to implement our 3d effect based on this simple fact if the Viewpoint is above the item the top and the bottom align perfectly but if they're not there's a bigger offset here than here let's go back here and do just that I'm going to calculate here this difference as the difference between the center and the a Viewpoint now this Viewpoint is something we need access to and I'm going to pass it here like this so the world needs to give it to the tree somehow and the world has to get it from somewhere so it's going to be past here and in index HTML in animate where we're doing the drawing this is where we calculate the Viewpoint and we get it from the offset of the viewport but it's actually the opposite of the offset at the view part so we do this Viewpoint is scaling the viewport offset by minus one and we pass it here to the world like that save refresh and um it doesn't work I think we forgot here to pass this diff here instead of our outc coded value there refresh and now we get something more like it it looks like these trees are really really tall things here maybe too much basically if we focus on this one tree here it's now this distance from the center and it's going to have this length the same distance as that so it's way too much maybe we can go with half or or even less so I'm going to go here inside of 3js and this difference I'm going to scale it I will type here scale the difference by 0.5 save refresh and now this effect is not so pronounced anymore so I think it can be even a little bit less and we can take this out and call it maybe height coefficient and this is going to be here a parameter and it will control the height pretty much let's set it to 0.3 and here height coefficient equals the height coefficient so that the tree knows how tall it is safe and refresh this looks about right now we're going to start styling these trees and we're going to form them from many levels stacked on top of each other we're going to go here and let's define our level count how many levels we want the trees to have I'm going to put seven and um let's loop from Level zero to level count level Plus+ and get a t value that we will use in interpolation so this is going to be between zero and one maybe should take special consideration here when dividing by zero if level count is one but I don't bother with that now and then the point that we will use at each of these levels is going to come from linear interpolation between the center and the top that we calculated previously using this T value and now we we can just say Point draw in the same way that we did the center and actually we don't need to draw the center anymore because it's already taken care of at level zero that's the bottommost circle now so let's implement this lurp 2D function it's actually not here yet in utils we have lurp but this slurp to the is just lurp applied on the X and Y components of the two points so like this save refresh and now we see kind of like a cylinder there made of seven different circles on top of each other let's give them a different color so that they come brighter towards the top and we go back here in tree JS I don't think we need this segment here anymore instead we go here and say the color is equal to and we're going to interpolate again using the simple lurp this time for just the green green value in this color so we're going to go between 50 and 200 these are just values that I like how they how they look and I added some values for red and for blue as well they are quite low values so they just control the shade a little bit and now this color we can actually just pass it here like so save refresh and now this cylinder looks like that next step we also interpolate the size so it becomes smaller towards the top and um we do that here size lurp between this size and 40 I just chose as a value that looks good to me but you can play with these values if you want now let's pass this size here I I think this should work save refresh and now the trees look like that they start to resemble something like what trees are supposed to look like at least these kind of uh Christmas trees let's make them look a little bit more fuzzy so this is too abstract for my taste and we're going to instead of drawing perfect circles here we're going to draw some kind of noisy circles uh you'll see basically here instead of using points to define the levels we remove that and let's use Poes instead and I'm going to make a private method generate level one level from the point and with the given size and let's say poly. draw at CTX let me give here the color and I don't want to use any stroke style for the tree so I'm putting here one with Alpha zero and now we can go up here and implement the generate level method where we just draw circle like shape around this point with this size so now let me take points here that we will put on the circle shape and the radius will be half of the size and now I'm going to loop with this a variable for angle starting at zero and going all the way to 360° or 2 pi radians and I will increase a by Pi ided by 16 so this means we will have 32 points along the circle and here we need to not use just a fixed radius otherwise it's going to be a circle but we will get a noisy radius where we just multiply the radius by math dot random like this and then we push to the points a point where we translate our original point at the given angle with the noisy radius like so and let's return here a new polygon with these points now save and refresh and uh you will see some funny stuff happening here maybe if we type debugger in the cons so we get a better idea of how these trees look like because the radius now is between zero and the tree size you get these spiky spiky look to the trees I guess it could be okay but I don't like it that much instead what we're going to do is add a lurp here between 0.5 and one so that we just get the upper half of random pretty much so between 0.5 and one are the random values if we do this save and refresh and now this looks more like what I want but of course they shouldn't be fidgeting like this and this is an annoying situation here because many programming languages do have a way to Generate random numbers with a fixed seed and you could do that fairly easy but not in JavaScript so I had to come up with something that generates kind of random numbers but always the same thing for each tree so that when redrawing it doesn't re generate the tree like that and I have a quick fix here for that so my kind of random number that I will generate comes from this very simple mathematical formula okay and now we pass it here instead of this actual random save refresh and now the trees don't shake like that anymore so this formula is um I'm not going to go too deep into it but cosine gives you a value between minus one and one square the cosine is going to give you a value between 0 and one so same as the random that we had previously and inside of this cosine I mixed together the angle with the center of the tree and with the sze and what this means is that each level of the tree is going to look a little bit different because the size contributes to it each part of the level according to the angle is going to look different because a contributes to it and I'm also offsetting a by this Center X location of the tree so that two trees don't look the same if you remove for example this part here all of the trees will look the same if I remember right let's save and refresh so you can see all of them have here this Spike Spike Spike spike because the center location doesn't affect in any way and same goes for other values I also have some hack here with remainder when dividing by 17 because it's a prime number and also it adds a little bit of fuzziness to the result but still if you save and refresh you will see that there is some kind of pattern to how these trees are being generated they are not exactly the same but they do have some similarities like maybe two of these thicker branches here and here and here and all of them kind of seem to have that you can find some pattern there these are not really random numbers they are just random Mish numbers and they are influenced a lot by how the cosign looks like so that's why you get this periodic change there anyway it's just a function I mushed there together to get this to work alternatively you could also save these levels when you generate the tree and then just draw it but I didn't want to bother with that it would have been more work explaining things now one thing that we could have here in the Constructor is also defining the base of the tree so I'm just going to call here generate level at the center and with the size this is already happening here when level is zero but now I'm storing that as the base of the tree and this is important because this base of the tree is something that the car May interact with like if it hits this base of the tree then it hits the tree pretty much so the base is giving us segments here on the side of the tree on the bottommost level that we could use now I'm going to remove this it's just for debugging so you see what the base was and we're going to continue to generate the buildings next so let's close this tree and the details and in World JS here this is the end of the generate buildings method instead of just having the bases of the buildings those polygons we are going to map these to new buildings as well and we're going to do very similar things for the buildings starting with let's fix the situations where buildings were poly previously so in the generate trees method here we are using the buildings as Poes we are accessing here the points directly but the building will also have a base like we added for the trees just now and that's how we will get the points from now on and also here illegal poies it's not just getting the buildings those are going to be new objects so what we do here is take out just the base from these buildings and now we have the Poes here to work with in the draw method below we also have to pass this Viewpoint to the buildings they'll also have a 3D look and let's go to index HTML and include the building similarly as we include the tree here building JS inside of items here where the tree is building JS and let's define the building class so simple class with the Constructor getting a poly for the base and a height coefficient let's set it 0.4 a little bit taller than the trees just to see how it looks like and now let's store this base here and the height coefficient and uh write a simple draw method CTX and the Viewpoint and draw the base and the context and let's make it white and uh grayish light gray stroke so let's just debug to see if our refactoring caused any issues save and refresh and now the buildings are white but no 3d effect just yet for that I'm going to go here at the top and calculate the top points on the ceiling of the building so top points is taking the base points and remapping each point to something else and here we type add this point scale subtract p Viewpoint this height coefficient like so and the ceiling is going to be a new polygon from these top points this formula here is the same that we used here in 3js but it's divided so we have first add scale SC and then this diff is subtract of that so add scale subtract it's the same thing now let's draw the ceiling as well I'm going to do the same thing as with the base but the ceiling save and refresh and now you can see that floating ceiling there over the buildings over the building base let's do the sides as well I'm going to go here after we have the ceiling and the sides are going to be polygons as well and we will make these sides by connecting two points two consecutive points from the base with two consecutive points from the ceiling but in reverse order in the ceiling you'll see so we do this looping through all the points like that and let me just write here next I for I + one basically but also make it loop around so I'm going to take the reminder when considering the length of this array so the last point is going to have next the first point in this polygon of the base and now let's generate these sides one by one inside of this for Loop so it's going to be a poly new polygon like this and first point base points of IE and then base points of next eye and then the ceiling points but they're already in that top points and it's shorter to right so top points next eye and top points I so basically bottom and then top reverse and let's add this poly to the sides and now before drawing the ceiling we're going to go here and draw all the sides one by one let me just copy this here and this is side I'll use the same style save and refresh and um some things look really good like this but some of them look like these I don't know empty boxes here and some are even over the other ones it's um a little bit confusing what is going on but uh the thing is this side here it's being drawn and after that this side here it's being drawn so you see this line from this side on the right on top of this side that should actually block that side on the right this means that we need to draw these sides in a way that makes sense the backmost ones first and then the front ones second so we will sort the sides of this building so that the further away ones are going to be in the beginning they get drawn first and then the closest ones to this Viewpoint are going to be second we do that here calling sort and the call back function will be this one uh comparison function that takes a and b to polygons this time and we write the result to be distance to point to the Viewpoint minus a distance to point Viewpoint so we're sorting all of the sides all of the polygons according to the distance to the viewpoint but because we write it in this way with B uh first and a second it means that we sort in reverse order so the closest ones are going to be the last ones to draw let's save and refresh and now you don't see that problem that kind of empty box look anymore but we still have some problems like this building being drawn before this building the same logic goes here for the buildings as well but we're going to use the base poy to decide which building to draw first and actually trees as well so here the tree goes underneath the building so we need to group trees and buildings together and do this sorting via their base at the same time to get the 3d effect to work so I'm going to go back to World JS here and let's combine these items into one array I'm going to write here items buildings and trees and let's pass here items and this is item item we don't need the second Loop anymore because we're now drawing them with the single Loop let's just see if this works it should be so that now the trees are over the buildings because they are drawn later save refresh so yeah same problems as before but now trees are over the build buildings so let's do that sorting now for these items here and it's the same thing really sorting the items same kind of function but now we tell the Poes the base of these objects to calculate the distance to the point save and the refresh and now this looks proper you can see this tree here between this building and this other building quite nicely and it changed relationship now so now it's drawn before this building now it's drawn after this building so this works just fine you can see sometimes these uh weird lines here but these are actually from the graph editor um it's not any glitch or anything like that they won't appear when we just use the world without the editor showing now you can style these however you want you can go further and make them look even nicer I will have a special video for channel members and they will get to see how I made them have roofs and also how to make a more realistic 3d effect because this one if you pay attention what happens here these buildings just get taller and taller like that and if your viewport is bigger and bigger they will just look really crazy so something is not right here you shouldn't exceed a size when looking at the building like this and the building should have a proper height not a height coefficient what whatever that meets so I will have a special video for that it's not going to be very long so not too much content in it but uh the code from that I will put now and mix it together with this one and you can look at it afterwards and selfstudy it even if you don't watch that video the worlds we can create now are much more complicated than that straight line we had in phase one but adding some traffic rules here will really give us a lot of flexibility in phase three we'll be able to teach the car all kinds of things because our world is really 2D apart from these tricks here we will enforce these rules as markings on the road I'll show you a clever way of adding the markings so they snap to the road and always have the correct orientation we're not going to have our users worry about things like that they should work as little as possible to get something nice try remember that as the general rule we're going to start adding markings to the world and we'll begin with stop markings but to do this we're going to need another editor um a stop editor and a way to change from the graph editing mode to the stop editing mode I'm going to do that here by adding two buttons for that they're going to be mutually exclusive let's start by adding an empty space to separate from the save and load functionalities and the first button it's going to have an ID this time because we're going to change the way it looks soon in JavaScript and uh we need to access it and when we click we're going to set the mode to the graph so this will enable the graph editing tools and the second button is going to have an ID stop BTN and onclick it's going to set the mode to stop let me close this tag and I'm going to style these buttons using emojis again for the graph and one for the Stop like this let's save and refresh the buttons are here but uh let's style the buttons a bit better they have this default view and I don't really like it let's make them bigger at least in Styles I'm going to add a style for the buttons let's put the background color white for maximum contrast and the font size 20 pixels refresh and they're bigger but I would like them to look Square as well and I found that adding here a padding of 5775 does the trick refresh and it's fine but this border here that the button has is a little bit uh nerdy and I will remove it and also add rounded Corners as well so here border set to none and Border radius five and refresh looks much better now this button and maybe this one too the contrast is not so good it's not so easy for me to see this button I'm going to add also a drop shadow on the bottom right so let's have a text Shadow one one black and I like buttons to have this uh hand cursor when you're hovering them so let me add all also here this cursor pointer save and refresh and now this looks good and feels good I think but pressing them does nothing this set mode is not defined yet so let's define it I'm going to go in index HTML here at the bottom and say set mode and the first thing that it will do is is disable any editor all the editors disable everything and then we're going to have a switch case that will enable the one with the given mode but let's handle first this disable editors and only visually so make the buttons look disabled if they are disabled and I'm going to start with the graph button and give it a gray background color and I'm also going to remove the colors in the Emojis by passing a grayscale filter with the 100% like this and this we have to do also for the Stop button so stop button and stop button now if we save and refresh press one of these buttons no more error there and both them are disabled now because this set mode was called so after they're disabled let's enable the one that has been clicked depending on this mode so switch depending on the mode if it was the graph I'm going to set the background color of the graph button back to White and remove the filter as well and let's break now I will copy this also for the stop using the stop button stop button save and refresh and clicking on them now toggles the behavior but when we refresh the page one of them should be selected and I'm going to enable this graph by default so I will go above here where we before we start the animation Loop and I will type set mode graph and now we can start talking about the functionality as well not just the look and feel so what we want to happen here in set mode is to enable the graph editor if we Press On the graph button and let's add this functionality to our graph editor it doesn't have it yet enable and here disable editors it's also going to need a way to disable it let's save and go inside our graph editor and the first thing we'll do is remove this call to adding event listeners because we want that to happen in the enable method so enable we add event listeners like this and then the disa is going to remove event listeners like that remove event listeners should look very much like ad event listeners but with remove in all of these parts so remove like this let's save and refresh and now we are able to edit the graph here to create a graph and when we switch to the stop editing mode which doesn't yet exist but it should disable the graph editor we still can edit the graph the problem is here when we add event listeners and we call bind on this method it creates a new method where this inside of it is this so remove event listener expects to get the exact same thing here when removing it not to create a new copy of handle Mouse down with this bound into it this is a problem and we're going to need to fix it and the best way I know how is just to store this version of the function here as an attribute and then use the attribute here and here so hopefully you get the point I'm going to store here the bound Mouse down function and let's just copy this from here and now put this here and here the second one is going to be bound Mouse move and we're going to cut this from here and copy this here and here and we have to do something for these as well because they're Anonymous functions so actually here we create a function and here it's another function they just do the same thing but it's not the same function that we want to remove here as well so let's do the mouse up is next Mouse up is um I have it here the last one let's actually rearrange these because I think it's more logical to have the order like this with the mouse Events first and then this context menu at the end and let me cut this here and now we pass this here and here here and finally context menu context menu I think could be also removed forever we never really need the context menu in this application but uh I'm not going to bother with that now I just keep this consistent and make sure that all the listeners are added and removed like this now save refresh try to add the graph change to this stop try to add more points and it doesn't work we can't select points we can't do anything with the graph anymore now but if we reenable it we can and disabling it again has this weird artifact now because we still have a select point there so I'm going to go here where the disable is and let's pass also selected is false and hovered is false save refresh and let's try one more time when pressing this that line disappeared so no more problem and we can can actually Define a new graph here to use because it's time to implement the stop marking as well and we should add stops on something I'm going to keep this format now let's save it so when we refresh it loads this graph now and we can begin to implement the stop editor we're going to go in index HTML and um it's going to work pretty much like this graph editor Let me just copy this instantiation here and say stop editor is a new stop editor but adding the stop markings on the road is going to need some information about the road itself not just that graph so how big the road is and something like that so we're going to pass here instead of graph world for this one otherwise um here when we do the display for the graph editor we're also going to have a display for our stop editor dispose I'm not going to deal with this now we will handle it a little bit later but then here this enable needs to happen here for the stop as well and the disable here let's implement the stop editor in a separate file and we will have more editors now so I'm going to move graph editor and the stop editor into a new folder let's call this editors and I'm going to move this editors here above the items so that these files that are directly in JavaScript are grouped together and let's copy this graph editor with a stop editor and create now the new folder injs called editors move graph editor inside it and create the new file stop editor JS next to it now this functionality will be quite similar to the graph editor so we will be copying some things from there but let's first handle this Constructor passing the viewport and the world which is a little bit different and store the viewport and the world as object attributes and also add here a reference to the viewport canvas and and a reference to the context stop editor will also have a display method and these items will come in handy for that now let's go to graph editor and I'm going to copy enable disable and adding removing the event listeners I think they are pretty much the same like this but but um this selected and hovered will make no sense here and we actually won't have a mouse up event listener this editor is going to be simpler than the graph editor so Mouse up won't be needed and we won't be dragging anything and let's begin to implement this mouse move private method here handle Mouse move I'm going to copy it from graph editor here and to begin with I want to win hovering the mouse over some of these segments to highlight that segment the thing is these stops will be added on the roads themselves so we're going to use them as guides otherwise it's going to be very difficult to place that stop exactly at the location and the end result won't look good so we're going to use the segments that exist already as some kind of guides and our interface for using this stop editor is going to be much easier to use much more user friendly so we begin by finding what is the nearest segment where we want to add this stop on so this get nearest point is going to change to a get nearest segment and we're going to store that segment in a constant get nearest segment and here let me align these a little bit better they go out of the screen and it's going to use the graph segments but here we don't have this graph directly we have the world so the graph is part of this world graph segments like this and this dragging part we don't need it what we do need to do is check if we do get a segment if there is a nearest segment under this threshold and if there is I'm going to Define find an attribute called intent again I want to show where the marking would appear if we would click the button so the intent for now is going to be the segment itself otherwise it's going to be null like this and let's take out Mouse and intent as attributes up here as well now to see this intent we need to implement the display method as well if there is an intent I'm just going to draw it on the context with default styling and we still need to implement this yet nearest segment function it's going to be in math utils at the top next to the first function we implemented in this file which was get nearest point and now we're also going to have get nearest segment which takes the location and a list of segments same threshold and here we Loop through each segment of segments and when we calculate the distance we can't use this Pythagorean theorem implementation to get the hypotenuse we have to call from the segment the distance to point instead and here the nearest will not be a point it's going to be the segment that has been found with the smaller distance again and again eventually leading to the one with the smallest distance now if we save and refresh we get an error here in the stop editor because it doesn't have yet a handle Mouse down method so let's just add an empty one here for now we will handle it later save and refresh and switch to the stop editor and now you can see that segment being highlighted the nearest segment to our Mouse location it's not a strong highlight but there is a highlight so I want the stop to be generated at the location centered exactly on that segment so next thing we'll do is Project our Mouse location on that nearest segment if there is a nearest segment here to get one point the center of the stop marking for that will go here when we have the segment available and I'm just going to project the point on the segment by doing this and the projection may also fall outside of the segment so that would be a weird uh error there and I'm going to check here if the offset is really between zero and one so if the projected Point Falls indeed on the segment not on the support line and in this case the intent is going to become the projected Point otherwise it's going to be null again save refresh switch to the stop editor and now we get a point there and we don't have to worry about is the mouse exactly there or not it's always going to be perfectly centered just as we want it and now it's time to define the marking itself so it's going to be a polygon but I'm going to have a specialized object for it a stop object for storing and drawing the stop marking so here we're going to need to pass some properties to that the first one is going to be the point itself so as before but I want the marking to orient nicely according to the segment that it's on so I'm also going to pass here the direction Vector of this segment and then a width and height I want the width to span the whole Road really and the height let's just use a factor of that like half the road width at least for now now to Define this stop marking we go to index HTML and we're going to do that in uh folder called markings so let me just copy maybe viewport here and say markings stop let's close some of these folders here and create a new one in JS markings and in it our file stop JS like this the stop class is also going to be quite simple but the Constructor has four parameters now so it's the center location the direction Vector the width and the height of this polygon let's store these as attributes and then generate that polygon somehow so the direction Vector is already normalized which is nice and height and now first thing for that polygon I'm going to get a support and it's going to be on the segment and and height half of the height towards the front of the segment and half of the height towards the back of the segment so we are going to Define this support as a new segment relative to this center location by translating Center at the angle of this direction Vector half the height and the second point is going to be the same but at a different angle the opposite angle you can either add um Pi here or say that you want to translate opposite way with the minus here let's debug and implement the draw method for this stop where we just draw this um support for now save refresh change to the stop editor and hard to see but it's there this support Vector with half the road width as its height let's convert it into a polygon and to do that I'm going to really use the envelope trick again so we Define a new envelope with this support vector and the width parameter and no roundness I don't need any roundness here and just take the poly from this envelope object and we debug Now by drawing this poly instead save refresh select the stop editor and there it is and I just realized that I don't want this stop marking to be the whole Road I want it to be just on half of the road here for the cars that go this way and they need to stop in this intersection so we're going to need to fix that but this is still useful this could be another marking like maybe the crossing it's pretty much exactly what the crossing should look like but for the stop marking we need some other guides not these graph segments we need something here in the middle between the borders of the road and the graph segment so let's define those new Lane guides the middle of the lane the right lane and the left lane so they will be Lane guides in the stop editor instead of using these we will pass Lane guides and we have to to go to world JS and Define them I will store them here as an array and Below generate here we're going to need the function to generate them it's a private method generate Lane guides and I'm going to use the same trick that we used with the generating buildings with these envelopes so I will copy this here as well these envelopes will be actually half the road WID like this and now we're going to take the union again so avoid those intersecting Parts as before by considering the poly of every envelope and just returning these segments we call this method here and um same as we did with the envelopes before let's empty the lane guides if they exist from a previous rendering and then push I'm just going to spread here the result of generate Lane guides push can actually push multiple things if you pass them individually not as an not as an array and let's quickly debug that these look as they should I'm just going to go here at the end of the draw method and say looping through all of the lane guides segments drawing them in Red Save and refresh and they look good and now when we switch to the stop editor you can see it's centering now on these um Lane guides but the width should be smaller so going back to the stop editor Road width divided by two save refresh switch to the stop editor and now it's good let's remove these guides and start styling our stop marking here I'm going to draw a rotated text saying stop so for that we need to do the translate and rotate trick we first translate to Center X and Center Y and then rotate by the angle of this direction Vector let's begin a path and I'm going to style the text by centering the basine and also horizontally way like this and it's going to be a white text and it will say stop at 0 0 because this translate is already moving us to where we need to be and rotate helps us out as well now let's remember to restore to the original state without these translations and rotations save refresh select the stop editor and you can see now this stop text appearing there but it should be rotated so I'm going to subtract half pi from that and um let's make it also bigger here we subtract 90° and um let's set the font size to be a fraction of the height I I think this should look good save refresh stop editor yeah let's make it bald as well refresh stop editor and good and typically these markings are stretched a lot when they're displayed under the road so that when you're driving and they are stretched like this you actually see them normally somehow unstretched while driving so let's do that as well here after we rotate I'm going to scale this not horizontally but vertically by a factor of two and vertically here means in the new frame of reference after rotating so save refresh stop editor I think we can do even even more maybe three refresh stop editor and uh for some reason it doesn't align exactly how I want it I'm going to give it an offset here and now it's good let's draw also the line on top of it that's the line that the cars shouldn't um shouldn't cross so that's going to be the Border here I will store it as an attribute because this border is really important for the cars to know about so let's put it here at the top and it's going to be the first segment of the poly and now drawing this we don't need to draw the poly anymore it was there just for reference and this one we style I'm going to give it thickness five and white like the rest of the marking save refresh stop editor oh it's not that segment it should be the other one so uh segments of two refresh stop editor that's how we want it but we want to add it not just see this intent here so let's do that next and um we're going to need to go to the stop editor Mouse down and start to implement it so if we are going to press left click left click and if we have an intent here then markings push this intent and I'm going to also delete this intent set it to null in case somebody presses multiple times in the same spot now for this markings I'm going to do a trick here and say that this markings comes from the world markings taking advantage of references here World markings doesn't exist yet so we need to go to world at the top and the world is going to contain markings it's going to be an empty array in the beginning and then in the draw method after drawing these um envelopes the gray F I'm going to draw the markings like so save refresh stop editor and now clicking actually adds the stop there at the intersection now saving doesn't work yet if we save nothing really happens except for saving the graph structure for the markings we're going to have to do something else we're going to implement saving for the markings and actually for the whole world a little bit later it makes sense to group everything together in one one spot but for now we can test them by just still using these uh buttons and and clicking it's not too much trouble I think we added markings how about removing them as well maybe on right click so let's go back to our stop editor and here on Mouse down if the event button is two so the right click we are going to look through all of the markings one by one get the poly of that marking for ease of use and check to see if we clicked inside the poly so if we clicked inside the poly of any marking that marking will be removed so if poly contains Point our Mouse location we splice at I one element we remove it and um now we can just return we don't have to do IUS minus here because we return anyways save refresh stop editor add some stops and remove some stops seems to work but one thing that we should still deal with is um this thing deleting the graph leaves the markings there let's clear them as well so going to index HTML l in our dispose function I'm also going to say World markings length is zero and now if we save refresh stop editor add some markings here and then we remove they all go away one thing that you probably have noticed is that markings can exist without the graph or outside of the graph like this I won't bother with that they are not tied to the graph in any way users should just add those markings after they are happy with the graph structure and in a way it's kind of what happens in the real world as well you may end up with markings in some strange locations for weird reasons I tried coming coming to A solution that is more friendly with this part but it was way too much trouble to teach it and um I gave up instead I'm going to show you how to add some other markings so let's make Crossings Road Crossings next and the way we'll do that is pretty much the same that we did everything up till now for the Stop we have to do it again for the crossing and after that we are going to have a step where I'm going to teach you about refactoring and see the similarities between those and remove the duplicate code you'll see so here let's copy this stop button and call it Crossing button set mode to Crossing and I will put here an emoji of this person walking and now every time this stop button is used I'm going to look for that and enter another entry for the crossing crossing BTN Crossing BTN we will have also a Crossing editor Crossing editor enable and then here this code Crossing BTN Crossing BTN Crossing editor let's look also for this stop editor it has been also used here with this display so Crossing editor display and of course here where we initialize it to uh new Crossing editor Crossing editor and importing the file so I'm going to copy this stop editor here and say Crossing editor and marking stop we will copy it to markings Crossing and in instead of making new files for crossing and Crossing editor I'm just going to Copy Stop and stop editor so let's copy this stop editor and rename it to Crossing editor and let's Copy Stop JS and rename it to rossing JS and in Crossing JS let's edit this real quick so here Crossing now I won't bother with styling it just yet instead I will just draw here the poly without any special Styles and remove what we had previously for for the stop so we're done with this Crossing for now and in Crossing editor we have to rename this to Crossing editor and we already know the things that we need to change to get it to work differently here instead of the lane guides we are going to have to use the graph segments again because it will Center in the middle of the road and here the width should be the full Road width and the object that we create is not a stop it's a crossing the one we just created let's save refresh and now we have the button here and they seem to toggle just fine and when we try adding a Crossing it looks like this but adding a stop still looks polished like what we had it previously removing things Works without actually changing to the other one I find this as a useful thing because it's sometimes uh quite often that you want to add a Crossing very close or instead of an existing other marking so then you can just right click even though you have the crossing editor selected and remove the Stop and create the crossing where you want it so I think this is actually a pro even though the logic wasn't necessarily planned like that now let's style these cross cring in a nice way for that we're going to get a line that is perpendicular to this support line that we had previously and then style that perpendicular line in some way so let's go to Crossing JS here and we don't need this poly anymore we will just get this perpendicular line line from this direction Vector this will also return a vector perpendicular to that one and the logic is actually quite similar to this but I want to avoid using translate and the angle and show you another implementation using vectors and teach you the formula for this perpendicular Vector as well so you could implement it the same way but I want to teach you things so let's have here the line a new segment and now we add to the center point and we scale this perpendicular vector by half the width and then copy this and scale it by half the width but with a minus in front in the other direction so you can see similarities here very much and then let's draw this line now let's implement this perpendicular function it's going to be in math utils maybe here next to translate and it's a really easy given a point we just flip it so to speak by changing these coordinates in this way save refresh select the crossing editor and now we get this perpendicular line there all we need to do is style it pretty much so let's go back to our Crossing JS and add here some Styles like so the width is going to be the height of this marking if that makes sense let's save and refresh select this Crossing editor and now you see it at its full height with the width of the line this is a very thick line now and next we are going to make it white and give it a dashed property like this let's save refresh select the crossing editor and now it looks like that when the cars are driving they will need to make a note of this border and this border here so two borders are needed now we have to record both of them here and I'm going to put them in an array like this let's debug see what we did is working or not I'm going to try to draw here all these borders save refresh Crossing editor and they look okay so no need for this debug anymore and we are done with this Crossing as well but look at this Crossing especially this part right here and the stop this part right here they are pretty much the same and now the stop editor even worse stop editor is very much like the crossing editor the only difference are these Target segments that we use here and the type of marking that is created so let's begin by refactoring this stop editor and the crossing editor into um socalled marking editor and then we inherit from that most of the same functionality let's copy this stop editor like this rename it to marking editor and here at the top this will be marking editor and here where we get these this nearest segment we just pass this target segments the target segments will come from the Constructor so this marking editor will be told what segments to look for and it's going to store them here in an attribute of this object and the second thing that we need to do is add here a method for creating a marker this should be a Dynamic method that will be overwritten by the stop editor and the crossing editor in a different way so this one needs the center location of the marker and the direction and that's it the width and height are things that those subclasses that will inherit from this super class will worry about so I just return here this Center as a point just to have some something but this function will be overwritten to be overwritten by the sub classes so with this create marking function in place we are going to call it here this create marking and it doesn't need these last two parameters and we are done with this marking editor now we go to stop editor and extend so extends marking editor like this and instead of doing anything here in the Constructor we just say super viewport world and the target segments will be the world Lane guides in this case everything else just goes away because after extending marking editor the functionality is there all we need to do is overwrite the create marking method given these properties and I'm going to return a new stop in this case at the center and Direction vector and now we can pass here the row width divided by two and the road width divided by two this square shape of the stop marking and that's it now inside of the crossing editor we do the exact same thing we extend marking editor like this we remove the contents of the Constructor super with the viewport P world and the world graph segments this time so this is the difference and remove all this code implement the create marking function over write it actually it is already there it's just returning Center if we don't do this and return a new Crossing this time at the center according to the direction vector and the full Road width this time and the road width divided by two and we're done with this refactoring we just need to include the marking editor as well so here in index we should include it before the other editors so that inheriting it is possible I'm going to put it here at the top above graph editor and say marking editor save refresh and now everything still works as before but the code is much much better and we can do even better we can refactor the marking as well so in the same way we are going to copy stop here rename this to marking marking and the border is something that is different between all of these markings so I will not have it there and the draw method for this marking we are not supposed to draw these objects just inherit from them but if we do maybe we draw this poly here instead so poly draw and I'm just going to use default styling remove this it's part of the stop drawing and that's it now in stop JS we can extend marking and here we call Super with all of these parameters like so and we don't need any of this except for the Border there so not so much code removal as in the other part but there is some still and let's do the same for the crossing here so extends marking remove this type super copy paste semicolon and now we need to include this marking as well so in the same way I'm going to include it on top of this so markings marking JS save refresh and add some of these markings here works just as before but uh we can do even more refactoring here inside of index HTML you remember all this tedious stuff that we had to do like the stop editors checking where it is and adding the next one next to it in all places and the stop button these buttons and editors I'm going to group them in an object called tools so tools is going to contain now a tool for the graph and this one will have access to the button and the graph editor now the same goes for the stop a button for the Stop is stored here and the editor for the Stop is stored here and finally the crossing the button for the crossing we added here and the editor for the crossing we add it here as well and with this object we can Loop through these values here so instead of having three displays here or like so we can just Loop through all of the tools like this then take the tool editor and display we are not gaining much like three lines here and three lines here these go away but when more editors are going to be added there this will make a difference and of course the effort of typing something new here and remembering that you have to type something there goes away with this implementation now we're going to copy this again here in disable editors here we want to disable not display but also this code for the button we can copy it here and just say tool button tool button and all this code goes away and it should be the same thing now this switch case here becomes much simpler because these values here match those from the tools that I defined on top this was on purpose and that means we don't need the switch at all anymore we just remove it align this better and this is going to be the tool from this mode button style background color style filter and here we enable not the button but the editor instead now save the file refresh the page and everything still works just fine there's something a little bit more that we could do is that this copying here can also be omitted if we just pass directly here the instantiation of the object like so so these are not needed anymore but uh this graph editor is actually called here in this pose so let's remove this but also edit this pose here and say tools graph editor dis poose save refresh try to add some markings and when we press this pose everything still works now the next marking we are going to add is not a kind of marking that you find on the roads really it's going to be a start marking where the selfdriving cars are going to spawn at so we're going to need that in the future and let's see how quickly we can Implement that now that we have this better code structure here we are going to go at the top where the buttons are and I'm going to copy this one and say start BTN set Mode start and repl this Emoji here I'm going to use a blue car because my car is blue and now here in the tools we are going to have to add a new entry for the start using start BTN and start editor we also have to include these two new files here so let me copy this stop editor here call it start editor and this stop marking here call it start and to implement this we just copy the stop editor from here rename it to start editor and the only change we do here is rename start editor and this is going to create a new start and then here copying the stop marking as the start renaming this to start and this marking will not have any border instead it's going to have an image we just display the picture of the car that I drew in phase one of the course so let's store here an image New Image and set its source to car.png and in draw we don't need this border we also don't need this scale but we do go between the rotation and the restore point here and here we draw the image we draw the image like so and 0 0 would Center it so that the top left corner of the image is going to be at this center point so we need to offset it by half its width and half its height I've added an image of a car now here it's this one so we can save refresh and now this button is here toggling seems to work just fine and the car appears there so here we're telling the system cars will come at this location and of course maybe they should respect some of these markings as well now I will Implement four more markings but I will fast forward this part this is what I have now there are quite many uh new things here there is a yield which is quite similar to stop also a barking here the target is where cars are supposed to go and probably the most complicated one is this traffic light here which has a little bit of logic of how to change the colors um I will make a special video for the channel members showing the full process but uh otherwise you can take the code after this lesson and inspect it yourself it's not rocket science but uh the code structure could be a little bit better for the logic of these lights I just didn't bother with it because I'm not even sure if we will use them in phase three it depends how good our neural network works so let's see so far we've been saving the grass in local storage and regenerating everything based on that when the page loads but in this way we lose the markings also we can't save multiple worlds like this and the trees appear randomly and maybe you don't want that not to mention that the worlds can be quite big and generating them when the page loads can be time consuming you'll see when we work with real world data I'm not patient enough to draw such a large graph now so I think that having a way to store the information in actual World files and loading them afterwards is a must you'll see it really Saves the Day done now you have a nice world like this and you want to store it save it somehow with everything all the markings everything we'll do that using local storage as well so we're going to store here as the world item stringify the world it's now here if we type get item world all the information is here from absolutely everything so I shouldn't lose all the things that I have here but of course we need to add this functionality to the save button as well so let's do that inside the save function here instead of saving the graph we're going to save the world and loading the world when the application starts it's going to be pretty similar to what we have done here by loading the graph but we replace these so World string is what comes from world and then World info we take here World string like so and now I'm going to keep this for reference but the way we Define the world and the graph is going to be a little opposite way so so first the world is going to come from World info if it exists then world is going to load from World info in the same way we were loading the graph earlier and otherwise Define a new world with an empty graph like this so now this graph is going to come from the world instead and we don't need this code anymore now World load this is what we're going to do today focus on how to load the information stored there as a Json string so let's go and open world JS and just below the Constructor I'm going to implement here a static method called load with the info and then just return a new world where we load the graph from the info graph like this this is the quickest thing that we could do and get something that actually works now if I go back here and refresh you're going to see the shape is still here but the markings are not there and also every time we refresh the trees are a little bit different so that's something that I don't really like maybe we want to keep the tree locations so that everything is exactly as we as we know it and the markings of course are gone and one more issue with this implementation is that now we do call the world Constructor which calls generate and this does a lot of work really a lot of work for big Maps this can take even minutes and you'll see that later when we we work with real world data but basically when we load this it shouldn't need to generate anything we should just be able to restore all the generated items from this information and that's what we are going to do next so let's begin here by defining an empty world first one that does call generate since the graph is empty there's nothing there really and then start populating the items so the graph this first item right here this one is going to come from loading the graph from the information like that and here we just return this world that only contains the graph at the moment save and refresh and now we get this and this is okay the world just shows the graph because the other things are empty so envelopes Road borders buildings these are not there not yet at least and we're going to need to populate them also these properties should come from our local storage but one thing that you should note is that when I drag this things start appearing again because the generate starts to function again the at from here inside of animate when the graph changes the world does regenerate based on the graph so just for you to know that this is expected Behavior so let's begin by taking all of these attributes now from the info here so this world is also going to get the road width roundness building width minimum length spacing and the tree size from the info in case we want to generate roads with different properties here then they will come from the local storage and now we proceed to generate these envelopes and the way we do that is the same way we did for the graph this load method we have to implement load methods for the envelope as well and make them proper objects not just raw information from this info here so I'm going to say that the world envelopes are going to be coming from the info envelopes which are just info not actual envelopes where we map them so that each element e is going to be envelope load that information now we go to the envelope primitive here and we have to implement a load for it because this generate polygon is also quite an expensive function and I don't want to just call envelope with that information the skeleton for example and regenerate it I'm going to implement here a way to create an empty envelope one that if we don't pass a skeleton then none of these happen and our static function for loading is just going to get the information and generate an empty envelope it will have the type of object envelope and it will have for example the draw and this other method in it but then the skeleton of this envelope is just going to come from from the info by generating a new skeleton from the P1 and P2 of info skeleton like this now technically these should be also cast as points but I think it's going to be okay and then the poly we have to add a polygon load method from this info poly and now we can return this envelope like so and the polygon load method here at the top a static load given the info I'm going to return a new polygon from these info points but I am mapping them now to actual point objects this is important otherwise some errors will come now save re refresh and I have some errors here because I accidentally forgot to remove this I wanted to replace this with World previously and I made the mistake save and refresh and now the envelopes are showing as well now the next thing here in line is the road borders this is is not so demanding because they are just segments so Road borders is Road borders map each border to a new segment P1 and P2 and again I don't bother casting these as points we don't call any methods of those points in our code so I just save some time by not knowing it but the proper implementation would have that cast also here and maybe segment end point should have also this load functionality there that would be the most proper but um I'm starting to want to end this so I can focus on phase three now here the buildings are next let's write here World buildings info buildings map new building by loading it we have to do this here but it's straightforward so in our building item here just give it a static method that loads this info and we return a new building This Time by loading the polygon of the info base and here we have to specify the height as well so that the building remembers its height from the original info we didn't really play with different Heights or anything like that but this makes the code more proper let's save and refresh and now the buildings are there as well without the need to generate them next we have the trees let's do something also here I'm just going to go through each tree and generate the new tree here I don't think it needs any load because the processing that happens for trees is actually in the in the draw so if I open here tree ejs this generate level is called here while drawing and all we need to do here really is initialize this generating the first is just creating a single poly basically so not much trouble to just reinitialize the trees trees can be quite problematic in the generation process because here generate takes a lot of effort for the trees if you remember we had this while loop here that tries to add a lot a lot of trees and it's going to try again and again and again and then reset and again and again but now we are going to tell here which locations to use so that part is gone and if we refresh now we'll actually see that every time we refresh the trees are going to be at the same locations always because now there's no more Randomness at play when loading this world from local storage now for the markings to work we also need those Lane guides they are next in line here actually so let's take the lane guides as well Lane guides we map them two new segments with the same points and now the only thing left are these markings here and um this will be a problem because if I'm going to inspect them here World info markings the ones that I saved we can see that there's no information here telling what type of marking this is the type of object doesn't serialize in JavaScript oh yeah I can tell that this is a traffic light and it was saved with the state of red but um yeah it's just guesswork for many of these or this image I can tell that it's the start because it's the only one that has an image this has two borders so might be a parking or I don't know Crossing could be as well so we actually need to store the type of these markings with the object as well as an attribute and that means we have to open up these markings again and edit all of them and tell this one that this type is a Crossing save and this type is a light and save and this one it's a marking that hasn't been inherited from and shouldn't really be used like this but I will give it a type also for consistency and then this is uh par King and this is start and this is a stop this is Target and this is yield and now if we go back here we need to generate the world and save it with markings that have this type so the original ones are lost forever pretty much let's refresh and add new markings I hope I remember where I put them before these were the traffic lights and um I think I had the parking here maybe I had the crossing somewhere here I don't really know car was starting here I think let's put um let's put the stop let's put it here because this kind of looks like a priority line I think I'm happy with this so let's save again and refresh and the markings are not there but now if we do look in the information that they have the type is there so I do know this thing with two borders now it's a Crossing so we do have what we need to load them into memory as proper objects I'm going to close all of these open files now and in World JS let's write this world markings we remap the information from the markings to marking load M like so and we have to implement this load method next so inside of marking JS here static load the info and here we have to do a switch based on that type that we now have so switch info type and just going to take these in order from here case Crossing return new Crossing at the info center X info center y we have to create a new point and this is the direction Vector X Direction Vector Y and uh the width and the height are like that and I have to copy this for all of them pretty much much and it would be quite a lot of code here and many many lines so I'm going to extract these two longer ones at the top it's going to be the same for all of them all of them have this center location and this direction Vector there for sure short I'm just going to put this one here and now here we can type point there and with and height and close this in one line which is much nicer I think and we can copy this seven times this is going to be now light light marking marking parking parking start start stop stop Target Target and yield yield let's save and refresh and there they are our markings are now here great so this now works but what if we want to store many scenarios many worlds we want to play with this and create a bunch of different worlds I'm going to teach you how to stored them as a file and then load them from the file that you stored them in this is also going to help with memory problems if the world is too big and it doesn't fit in local storage so here inside of this save I'm going to go at the top and uh Define an a tag which we will artificially click to download a world file now the Syntax for this I won't explain in too much detail but basically we will use Json here so I am going to specify that we use application Json and um just in case utf8 and we encode this information like that coming from the string of the current world object now here we generate the file name and it's going to be name. World by default but depending on your browser settings you're may be asked to enter the name when you save the file and then here I'm going to set the attribute to download and pass this file name as well and now we can trigger click which is going to start the download so when we press the save button all this will happen and it will put the world information in a file called name.or but you can change this name just the extension world is important let's now save and refresh and let's save this world file you probably don't see these uh screens here where I'm entering the name but it did save somewhere on my computer so this I have a backup of it and now let's remove it and try to have a new world maybe different looking let's just use this kind of square shape and maybe give it a diagonal like so and let's save this one as well and I'm going to use a new name for that and now when we refresh here I am going to get the new one the first one is lost basically but we can get it back if we Implement load functionality from a file and I'm going to do that here below the save function we are going to have another function called load and this is going to be linked to U file input you'll see we get the first first file from there and if there is no file let's just give here a quick alert that you haven't selected anything and return we don't want to get to this part of the code here so we begin to read the information from the file and we read it s text then unload I'm going to pass this callback function here given an event as the parameter I will take the content of this file like this and parse it because it's a string by default and now we can use this information to load a new world so world is going to be load this new data and what I'm going to do now to prevent reinitializing a bunch of objects is I'm going to set this information in local storage here and then reload the page so basically this button is going to reload the page after it stored the world in the new local storage item here but uh one thing we still need to do is this world needs to be reassigned to something else and it's a const so going back up here I'm going to change this world into a let and this should work to call this function we're going to need um file input and I'm going to put it here and give it also a label for this file input and the class I'm going to make it look like the other buttons in CSS otherwise it's very ugly I think and um I will use this emoji of a folder here and the input itself let's put it like this the type will be file and ID is this file input it will accept files of type world and unchange we call our load with the event information which file did we select now if we save and refresh we're going to see here some quite bad layout happening but let's see if it works so pressing this it asks me to select the file and I'm going to select the first one that I had previously and I got it back great only thing now to style this to make it look like the other buttons and I do that in Styles CSS I'm just going to reuse this style like so and the default styles for these are a little bit different I'm going to for for both of them to have this inline block display and um I want to hide the contents of the file type input as well so we just see that emoji there save refresh and now it looks like that and when we refresh the page we still have this world but now I can change to the other one we created and it's here every time we refresh it's still this one until we change to another one I'm now constantly selecting different files there but you don't see those windows my recorder doesn't catch them one thing I would like when storing these worlds is also to keep the viewport information part of the world itself like how should it be presented because here it doesn't show everything and I always seem to scroll zoom out like this so maybe this world should look like this by default we can do that by storing the viewport zoom and offset information part of the world itself let's go back to index HTML in our save function and here at the top I'm going to do just that world Zoom his viewport Zoom World offset is viewport offset and now let's save this refresh and put again this reference Here and Now save again I'm going to overwrite the previous worlds that's one and the other one like this so now they should have that information in them but if we refresh the viewport isn't adapting to it so we have to do that and also make sure that the world is going to load that information from the info so inside of world JS here I'm going to also type World Zoom comes from the info zoom and World offset comes from info offset and back in index HTML where we Define our viewport here let's pass it also to zoom and the offset of the world and handle it inside of viewport JS in the Constructor these will have some default values in case they don't exist but otherwise here let's just pass that and the offset this is fine if the offset is not specified so I'm just going to say if there is an offset set it to that offset otherwise whatever we had previously save refresh and now we get this exactly as we wanted and the other one works as well thanks for watching if you want to learn how to integrate the selfdriving car with this new world watch this video on my channel you may also want to watch these other two videos that teach how to use real world data from open street map and how to create the mini map I hope you liked this course and if you did please remember to like subscribe to me and to free code camp and share the course with others so they can learn as well see you guys and stay tuned for phase three it will start soon I promise
