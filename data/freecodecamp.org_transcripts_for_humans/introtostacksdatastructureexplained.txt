With timestamps:

00:00 - learn all about the stack data structure
00:02 - you'll learn about its implementation
00:04 - operations and practical use cases par
00:07 - teaches this course he'll guide you
00:09 - through when and why to use Stacks
00:12 - enhancing your understanding of this
00:14 - essential data structure then he'll
00:16 - teach you the 10 most popular stack
00:18 - related interview questions to help
00:21 - prepare you for your next technical
00:23 - interview Hello friends hope you're
00:25 - having a fantastic day today so in this
00:27 - course we are going to learn everything
00:29 - that is to know about stack data
00:31 - structure stack is one of the
00:33 - fundamental data structures in computer
00:35 - science it has lot of practical
00:37 - applications and also remains one of the
00:39 - most popular type of interview questions
00:40 - that you can encounter in your technical
00:42 - interviews so my expectation is that by
00:45 - the end of this video you should be able
00:47 - to understand that what stack is when to
00:49 - use it the moment you see any type of
00:52 - interview question you should be able to
00:53 - identify that this is related to stacks
00:55 - and what are the strategies we are going
00:57 - to use to solve this problem so this
00:59 - course is is going to contain lot of
01:01 - important information we are going to
01:02 - start with understanding what stack is
01:05 - how it is implemented what are the
01:07 - benefits what are the limitations what
01:09 - are its characteristics time complexity
01:11 - space complexities and under what type
01:13 - of scenarios you should be using stack
01:16 - afterwards we are going to see 10 most
01:19 - popular stack questions that has been
01:20 - asked in technical interviews we will
01:23 - understand in depth that what those
01:24 - questions are how come stack became the
01:27 - choice of data structure for that
01:29 - particular type of scenario and how do
01:32 - we actually solve it so without any
01:33 - delay let's get
01:37 - started now very quickly let me give you
01:40 - a brief introduction about myself my
01:42 - name is par vas and I'm based in Canada
01:45 - I have been in IT industry for close to
01:46 - 10 years and I have bachelor's and
01:48 - Masters in computer science as part of
01:50 - the education I have worked at companies
01:52 - like Royal Bank of Canada and noia
01:54 - Microsoft and currently I'm working as a
01:56 - Solutions architect for the biggest
01:57 - theater chain in Canada called clex on
02:00 - the side I also run my own YouTube
02:01 - channel called destination Fang and I
02:04 - would really appreciate if you can go
02:05 - ahead and support me on that channel as
02:07 - well in my personal Hobbies I love
02:09 - watching movies playing video games uh
02:12 - going out on Hikes and doing all sorts
02:14 - of fun activities last year I became dad
02:16 - of two beautiful twin daughters and
02:18 - that's why we I have all of these teddy
02:20 - bears hanging around me so now let's get
02:23 - started with our
02:27 - course so stack is one of the
02:30 - fundamental data structures of computer
02:32 - science this is a linear data structure
02:34 - and typically Stacks are implemented
02:37 - using some sort of list function so it
02:39 - can be either array list or link list
02:41 - but the thing is stack is not just
02:42 - typical any single array or link list
02:45 - this is a special kind of list that
02:47 - contains a very specific property and
02:50 - that is called Leo property that is
02:51 - called last in first out so how does a
02:55 - stack typically works is that inside the
02:58 - stack you always have have to work with
03:01 - the values that you are entering is
03:03 - always going to end up at the bottom of
03:04 - the stack and then if you have to enter
03:06 - the next value it will remain at the top
03:09 - of the stack and you can only access the
03:11 - element that was last entered inside the
03:14 - stack so let's try to understand this
03:16 - with an example currently let's say that
03:18 - we have this an empty stack now for this
03:21 - stack if we try to add value number one
03:23 - so one is going to stay at the bottom of
03:25 - the stack and now for this stack then
03:27 - since it only contains one value if we
03:30 - have to see that what is the element
03:32 - inside the stack it will return us the
03:34 - result as one but let's say that we
03:36 - don't do that and we try to add one more
03:38 - element so if we add value number two it
03:40 - is going to come on top of value number
03:42 - one and then we add value number three
03:45 - we can add value number five something
03:46 - something something now the moment uh
03:49 - over here we decide that I want to get
03:52 - one element out from the stack so the
03:55 - moment we try to do that we cannot
03:56 - directly access this element three or
03:58 - two or 1 we will always have to access
04:01 - element number five first and once we
04:04 - kick element number five out or pop
04:06 - element number five out then only we can
04:08 - reach to element number three which
04:09 - means the last value that was entered
04:12 - inside the stack is going to remain at
04:14 - top of the stack and that is the only
04:16 - value we can access in any any given
04:19 - moment inside the stack and this special
04:21 - property of Leo actually comes in very
04:24 - handy for some very specific operations
04:27 - so before learning that let's try to
04:28 - understand that what a typical stack
04:30 - looks like in real
04:33 - world you can think of a stack of books
04:37 - or a stack of plates both of these uh
04:40 - simply un shows us that how does a
04:43 - typical stack works in the real life
04:45 - because if we have bunch of books stack
04:48 - on top of each other then we can only
04:50 - access the book that is currently
04:51 - present at the top of the stack and then
04:54 - we will start going Bottom one by one so
04:57 - same thing applies for the stack of
04:58 - plates as well and this would be the
05:01 - best way to understand that how does the
05:03 - memory is stored inside the stack and
05:05 - this is implemented using some sort of
05:07 - list
05:09 - function so inside the stack there are
05:12 - mainly three operations that we have to
05:14 - worry about first operation is called
05:16 - push operation so push means that you
05:19 - are entering some value inside the stack
05:22 - next operation is called pop operation
05:25 - pop means that some value that is
05:27 - already present inside the stack you you
05:29 - are going to access or fetch that top
05:32 - element outside of the stack and then
05:34 - that element will no longer be present
05:36 - inside the given stack and last
05:38 - operation is called Peak operation in
05:41 - the peak it is very similar to pop but
05:43 - you are not actually fetching the value
05:45 - out you are simply seeing that what is
05:47 - the current value that resides at that
05:49 - location so let's try to understand
05:51 - currently our stack is empty let me push
05:53 - one value so if I try to push value
05:55 - number three then three is going to be
05:58 - populated inside the stack then I can
06:00 - also push value number four then I can
06:02 - also push value number seven and so on
06:04 - and so forth now at this position I
06:07 - decided to do a pop operation so let me
06:09 - just simply do a pop operation the
06:11 - moment I do that the seven is actually
06:13 - going to be kicked out of the given
06:15 - stack and it is going to be return
06:16 - returned as part of the answer so now
06:19 - the seven is no longer present inside
06:21 - the given stack and it is over here that
06:23 - we are able to be fetch uh if I do pop
06:26 - operation one more time then we would
06:28 - have four also be poed as well and then
06:31 - if I try to do a push operation once
06:33 - again and try to add value number five
06:35 - then five is going to be present over
06:37 - here the moment I do Peak operation at
06:39 - this moment then I'm only going to be
06:41 - seeing that there is value number five
06:43 - currently present at the top of the
06:45 - given stack but I would still keep or
06:49 - leave this five untouch inside the stack
06:52 - I only see that what is the value
06:54 - associated with the peak operation and
06:56 - all of these three operation actually
06:58 - operates in big go off one time so there
07:01 - is a special way we actually Implement
07:03 - stack inside the list and that allow us
07:06 - to fetch complete all of these three
07:08 - operations in bigo of one time so now
07:10 - let's just take a quick look at the
07:12 - implementation for any particular given
07:17 - stack so let's start implementing the
07:19 - stack
07:23 - class we are going to use an integer
07:25 - array list to implement our stack class
07:27 - and now let's create a Constructor to to
07:29 - open an instance of the array
07:33 - list now one by one we are going to
07:35 - implement our three push pop and Peak
07:38 - method so let's start with the push
07:44 - method so for the push method we are not
07:47 - returning anything we are taking an item
07:50 - integer item as an input and we are
07:52 - simply adding it to the array list
07:54 - instance that we have
07:56 - created now for the pop method for first
07:59 - we are going to check that if the given
08:01 - items list is not empty then we need to
08:04 - return the very last element that was
08:06 - entered inside the stack or the last
08:09 - element that is currently present inside
08:10 - the item and we need to remove that from
08:12 - the existing array
08:18 - list so here for the pop method we check
08:22 - that if the given list is not empty then
08:24 - we remove the very last element that was
08:27 - entered entered inside our array list
08:29 - if that is not the case and if the given
08:31 - list is actually empty then we simply
08:34 - return the null value and same way let's
08:36 - try to implement the peak method where
08:38 - it is going to be very similar to our
08:41 - pop method the only difference is that
08:43 - instead of removing the element we
08:45 - simply need to get the value of that
08:47 - element and that's it so now we have
08:50 - implemented the three methods for our
08:52 - stack now let us also try to implement
08:54 - the ismt
08:57 - method so for the is empty method we are
09:00 - simply checking that if the given items
09:02 - array list if that is empty or not and
09:05 - that's it this is the complete
09:07 - implementation of the stack class now
09:09 - let us try to implement a main method
09:11 - and also run some operations on the
09:13 - given stack class so now we have
09:15 - implemented our main method where we are
09:17 - initializing a new stack so first of all
09:20 - we are pushing three elements onto the
09:22 - stack the values are 10 20 and 30 next
09:25 - we are going to be pecking that what is
09:27 - the top element inside the given stack
09:29 - so this should return us the answer as
09:32 - 30 because that was the very last
09:34 - element that we entered inside the list
09:36 - then we are going to pop an element once
09:38 - again that should also return the value
09:40 - 30 because that was the last element
09:42 - that was entered and then once again if
09:44 - we do the pop operation it should return
09:46 - value number 20 and in the end we are
09:48 - going to Simply see the peak operation
09:50 - so that should return value number 10 so
09:52 - let's try to run this
09:58 - code we before forgot to change the name
10:00 - let's try to run the code so we can see
10:03 - that for the very first operation the
10:04 - top element is 30 then the PO element is
10:07 - 30 then once again we pop element number
10:09 - 20 and in the end after that when we
10:12 - check for the top operation we can see a
10:14 - value number 10 so this is how stack is
10:17 - actually implemented but lucky for us
10:19 - stack is actually provided as one of the
10:22 - default application and we actually
10:24 - don't have to implement the stack class
10:26 - all the time this was just simply for
10:28 - your information
10:32 - now let's learn that what are some of
10:34 - the popular use cases that we can apply
10:37 - stack at and You by by knowing these use
10:41 - cases we would be able to quickly
10:42 - identify during our interview or any
10:44 - problem we are trying to solve to
10:46 - realize that whether stack would be a
10:48 - good choice or not so number one thing
10:51 - where you can think of using a stack is
10:53 - for any time you have to do an undo type
10:56 - of functionality so what does Undo
10:58 - functionality mean means we know that
11:00 - inside our computer or browser we have
11:03 - the functionality where it keeps track
11:05 - of every single step that we have gone
11:08 - over across any set of websites and then
11:10 - if we click the back side backspace
11:13 - button or if we do the undo button
11:15 - inside the software such as word or any
11:18 - other PowerPoint or something like that
11:19 - it is able to trace our steps back and
11:22 - then put us back to the previous state
11:24 - so how it does it is that it actually
11:27 - uses stack to store that information
11:29 - let's try to understand this with an
11:31 - example suppose we currently have an
11:33 - empty step and I'm trying to open a new
11:36 - browser session inside the Google Chrome
11:38 - so the moment I first uh go inside the
11:41 - Google Chrome I have a new empty stack
11:43 - being created now inside the Google
11:46 - first of all I decide to go to the
11:47 - Facebook website which means stack is
11:49 - going to mark that I visited the
11:51 - Facebook website right now through
11:53 - Facebook I decide to go to the x or
11:55 - Twitter website so next it is going to
11:57 - put the value of x on top of my stack
12:00 - then I decide to go to the Uber website
12:03 - so once again the same information is
12:05 - going to be recorded and so on and so
12:07 - forth now at this position of uber I
12:09 - decide to click on the back button or
12:12 - the undo button where I want to go back
12:14 - to the previous state simply the browser
12:17 - is going to pop the element that I have
12:20 - entered at the very last so this is
12:22 - going to be taken out now I'm no longer
12:24 - at the Uber place and whatever value
12:26 - located over here it is going to do a
12:28 - peak operation and bring me back to the
12:30 - uh Twitter page that I was previously
12:32 - browsing so this is a great use case now
12:35 - you can understand that how this Leo
12:38 - property last in first out property
12:40 - actually help us to solve a real world
12:43 - problem few other important use cases
12:46 - that we can think of for stack is to
12:48 - have it in the backtracking mechanism
12:50 - because how does a typically
12:52 - backtracking works is that let's try to
12:54 - understand this with a small example of
12:56 - trees so inside any given tree if you
12:59 - have to iterate over the tree you will
13:01 - have to understand that what was the
13:03 - previous state that you are iterating
13:05 - over and have you visited all of its
13:07 - children or not so let's assume that I
13:09 - have currently this type of scenario and
13:11 - I'm trying to go in the depth first
13:13 - search fashion now I know that this was
13:15 - supposed to be a course on stack but I'm
13:17 - just explaining you explaining you some
13:20 - simple theorem to understand that how
13:21 - stack can be used with different data
13:23 - structures as well so in the depth for
13:25 - search we actually go in one single
13:28 - Direction and and the moment we try to
13:30 - find some value if the value is found
13:32 - that is great if that is not found then
13:34 - we have to do the backtrack and do the
13:36 - do the same operation for the remaining
13:39 - children or remaining leaves as well so
13:41 - let's try to do that let's say that we
13:42 - are trying to find this particular
13:44 - element and we are doing a simple depth
13:47 - for search so first we are going to we
13:49 - are at we are located at this position
13:51 - so we are going to go to the left child
13:53 - once again to the left child and once
13:54 - again to the left child we did not find
13:56 - the element we were looking for but the
13:57 - thing is there might be some path that
14:00 - we haven't explored so we are going to
14:02 - do the back tracking and through this
14:04 - back tracking now we are going to see
14:06 - that hey are all the childrens of this
14:08 - particular node uh that I have tested no
14:11 - I haven't tested them so I'm going to
14:13 - check one more once again I did not find
14:15 - what I was looking for once again I'm
14:17 - going to do the backt track and through
14:19 - here I okay so now I have tested both of
14:22 - his children which means now I will need
14:23 - to do the backtrack operation once again
14:26 - and through here okay there are still
14:27 - some children that I haven't tested so I
14:29 - will go on the right and once again I
14:31 - will go on the left and I found the
14:32 - value that I was looking for and at
14:34 - every given moment a stack is going to
14:37 - keep track of every single information
14:40 - that we were iterating over so we can
14:42 - quickly backtrack to the previous
14:44 - position that we haven't iterated over
14:46 - let's try to understand this with some
14:48 - example so let's say that these values
14:49 - are a b c d e and this is f and I okay
14:54 - let's say that this is I so initially
14:56 - our stack is going to be empty then uh
14:59 - we are at position number a then we move
15:01 - to the position number B then we move to
15:03 - the position number c then we move to
15:04 - the position number D at D we realize we
15:06 - cannot go any go further anymore so we
15:09 - will pop D out and we will check that
15:12 - have we explored every single
15:13 - possibility at this C no we haven't
15:15 - checked so once again we are going to go
15:17 - to the value number e so we are going to
15:19 - add value number e over here once again
15:21 - we haven't checked all the possibilities
15:22 - uh sorry we check all the possibilities
15:24 - at e once again we come back to the C we
15:26 - check all the possibilities at C so we
15:28 - are going to remove c as well now we are
15:30 - at this position number B so for at B we
15:33 - haven't checked F so we will add F over
15:35 - here from F we haven't checked I and we
15:37 - are going to reach to the I and I was
15:40 - the item that we were looking for so we
15:41 - found our answer so we can simply say
15:43 - say that yeah this element is present
15:45 - inside this tree and we were able to
15:47 - smoothly iterate over the entire tree
15:50 - using backtracking because we had the
15:52 - stack that contained the last in first
15:55 - out property so now you start to
15:57 - understand that how specific or how
15:59 - important stack is let's try to
16:02 - understand one more use case that is
16:05 - that at any given moment you want to
16:07 - identify that whether the given sequence
16:09 - of let's say brackets or parentheses are
16:12 - they valid or are they in the correct
16:14 - order or not and doing this can very
16:17 - easily be done using Stacks how we can
16:19 - simply have a logic that whenever we
16:21 - identify an opening parenthesis we are
16:24 - simply going to add that value to the
16:25 - stack and whenever we identify a closing
16:28 - parenthesis we will remove that value
16:30 - from the stack and see that the value
16:32 - removed does it contains the same type
16:35 - of parenthesis or not so let's try to
16:37 - see the example in action and then you
16:38 - would be able to understand what I'm
16:40 - talking about so first we encountered a
16:42 - square opening bracket so we are going
16:43 - to Mark Square opening brackets then
16:45 - curly opening bracket and then a round
16:48 - round opening bracket okay so now we
16:50 - took care of all of these three elements
16:52 - now we are at this position and we
16:53 - encounter a closing bracket now the
16:55 - thing is in order for this sequence to
16:57 - be valid the closing bracket has to be
17:00 - exactly the same same way that that was
17:03 - for this particular bracket so let's try
17:06 - to do that so let's say that we pop this
17:07 - element out and over here we identify
17:10 - that for this circular closing bracket
17:13 - the value we popped out was also opening
17:15 - bracket which means this is a good
17:17 - sequence so we can move forward so now
17:19 - we no longer have this value next we
17:21 - have a a curly closing bracket so for
17:24 - curly closing bracket we realized that
17:25 - the value we popped out was also curly
17:27 - opening bracket so this is is also a
17:29 - matching pair that is good and in the
17:31 - end we found out that the last element
17:33 - is also a closing bracket that is square
17:35 - closing bracket and the value we popped
17:37 - out was also a square closing bracket so
17:39 - we found this pair which means this pair
17:41 - of parentheses is valid now the question
17:44 - is this is really important whenever you
17:46 - are building idees or compilers so
17:49 - things like intellig eclipse or jet
17:51 - brains or bunch of other compilers they
17:53 - all use this formula or the stacks to
17:56 - keep track of every single opening and
17:58 - closing bracket now imagine in this
18:00 - scenario that this last element say for
18:02 - some some reason this one is a closing
18:05 - circular closing bracket now at this
18:07 - moment we identified a circular closing
18:10 - bracket and we try to pop this element
18:12 - out and we identify that this was
18:14 - actually a square opening bracket which
18:16 - means this was a mismatch so if that is
18:18 - the case we can simply get rid of these
18:21 - uh these things saying that this was an
18:23 - invalid pair and that that is how we can
18:27 - use stack to complete these type of
18:30 - operations and we can do all sorts of
18:32 - like functional logic and all sorts of
18:34 - important fun stuff using stack so
18:37 - that's why they remain so popular in
18:39 - terms of technical interviews and now we
18:42 - are going to go ahead with the 10
18:45 - questions about Stacks that we talked
18:47 - about completing these 10 questions will
18:50 - give you the full exposure towards
18:52 - stacks these are some of the most
18:54 - popular most like and most cast problems
18:57 - uh in terms of technical interviews all
18:59 - of them are really popular lead code
19:00 - problems and they have been asked in
19:02 - interviews tons of time so without any
19:04 - delay let's get
19:05 - [Music]
19:08 - started today we are going to solve
19:10 - daily temperatures lead code problem
19:12 - that is a medium problem and also an
19:13 - extremely wellike lead code problem so
19:16 - the problem statement is quite simple we
19:18 - are given an integer array called
19:20 - temperature that represents the daily
19:22 - temperature over a certain span period
19:24 - now we need to return a new answer from
19:28 - this given temperature array such that
19:30 - any particular item in that particular
19:33 - answers array should Define that how
19:35 - many number of days you have to wait in
19:38 - order to generate a warmer temperature
19:40 - compared to that particular day's
19:43 - temperature so let's try to understand
19:45 - this with an example suppose this is the
19:47 - temperatures array we are given now in
19:49 - the input you can see that bunch of
19:51 - different values for every single day's
19:53 - temperature now if we see on this very
19:56 - first day the temperature is 73 which
19:58 - means means how many number of days we
20:00 - have to wait in order to get a warmer
20:02 - day well a warmer day is right next
20:05 - which means if we just wait one more day
20:08 - we can actually get a warmer day same
20:10 - way for 74 if we just wait one more day
20:12 - we also get a warmer day because next
20:14 - day's temperature is 75 now at the 75 if
20:17 - we have to find a warmer day then we
20:20 - have to find a day that contains higher
20:22 - temperature than 75 which means this
20:25 - temperature 76 is higher which we can
20:27 - see that that is actually 4 days away so
20:30 - over here we will have to actually wait
20:32 - 4 days in order to get a warmer day same
20:35 - way for the 71 we have to wait 2 Days in
20:38 - order to get a warmer day at position 69
20:41 - we only have to wait one day to get a
20:43 - warmer day at 72 once again we will have
20:45 - to wait just one day because next day is
20:47 - 76 which is warmer at the 76 we do not
20:51 - find any particular warmer day
20:54 - subsequently which means we cannot find
20:56 - a warmer day so we are just going to
20:58 - mark this as zero that no warmer day
21:01 - exist in front of the value 76 and last
21:04 - one is 73 so since this is the very last
21:06 - entry we don't know what the upcoming
21:08 - temperatures looks like so we are also
21:10 - going to return zero and this is the
21:12 - answer array that we need to return uh
21:15 - that defines the temp days you have to
21:18 - wait in order to get a warmer day from
21:20 - any particular
21:23 - day okay so first let's try to
21:26 - understand a Brute Force approach to
21:27 - solve this problem the idea is very
21:29 - simple we simply go to a day and then we
21:32 - keep on iterating the array until we
21:35 - find the next day that has higher
21:37 - temperature the moment we find this one
21:39 - we actually find the difference between
21:41 - the index positions and whatever the
21:43 - difference is we Mark that in the answer
21:45 - so for this first one we can mark first
21:47 - as the answer for the second one once
21:49 - again we are going to repeat the same
21:50 - process we are going to iterate over
21:52 - every single value inside the array till
21:54 - we find a higher value and which we find
21:57 - 2 days later see same way we are going
21:59 - to keep on repeating the same operation
22:01 - and eventually we would have our entire
22:03 - answer array to be populated now this is
22:06 - the most simplest method but we can
22:09 - inherently see some issues with this
22:11 - approach the number one issue is that at
22:14 - any given position we will actually have
22:16 - to Traverse over maybe the entire rest
22:18 - of the array in order to find the
22:20 - optimal solution what if uh let's assume
22:23 - that this instead of being 50 Maybe This
22:25 - Was 80 and we don't have any particular
22:27 - solution in mind we would have still
22:30 - iterated over the entire array and then
22:32 - once again in in order to find the lower
22:35 - temperature for this next element we
22:37 - would still have to iterate over the
22:39 - entire given array maybe this was 82 so
22:41 - in this this case this is an inefficient
22:44 - approach and if we see time complexity
22:46 - for Brute Force approach is going to be
22:47 - biger of n Square in the worst case
22:50 - scenarios so let's try to see if we can
22:52 - improve upon this time and space
22:54 - complexity or
22:57 - not the thing is at this given location
23:00 - at the very first moment we don't know
23:03 - that what is the temperature that is
23:05 - higher than this one because we have
23:07 - only iterated this one element right but
23:10 - what if we are at this element we can at
23:12 - least predict that how many elements
23:15 - actually has lesser temperature than
23:17 - this and based on that we can
23:19 - immediately update their temperature and
23:22 - we can immediately say that for if we
23:24 - are at let's say value number 75 then at
23:27 - 75 we should be able to tell that 74 is
23:30 - only one day away from having its warmer
23:33 - day and same way at 74 we should be able
23:36 - to tell that 73 is actually just one
23:38 - more one day away from having a warmer
23:41 - day same way at 72 we should be able to
23:44 - tell that 69 is only one day away so how
23:48 - can we actually do that for that we will
23:50 - have to find some way to actually
23:53 - iterate the array in One Direction note
23:56 - that what the current temperatures are
23:58 - and based on that we will also have to
24:00 - check that what are the immediate
24:02 - temperatures that are actually smaller
24:05 - than this current temperature or greater
24:07 - than this current temperature so that we
24:09 - can mark their answers in order to do
24:12 - that we will have to use an extra data
24:14 - structure to store the values of all the
24:17 - temperatures for which we have not been
24:19 - able to find the warmer days second
24:21 - thing is for any particular temperature
24:24 - not only we will have to find the warmer
24:26 - day we will also have to find like the
24:28 - immediate warmer day so for this 745 is
24:31 - actually greater than both 74 and 73 but
24:35 - we should not waste our time marking
24:36 - this 73 as having a warmer day as 75
24:40 - because there is 74 that is more closely
24:43 - associated with 73 which means we have
24:46 - to worry about the immediate before
24:48 - elements so we are traversing in One
24:50 - Direction but the at the very quickly we
24:53 - will have to understand that what was
24:54 - the last item we were at before moving
24:57 - to any particular previous elements so
25:00 - the best data structure in this case is
25:02 - going to be a data structure that
25:04 - contains the property of last and first
25:05 - out and the answer becomes very simple
25:08 - that we are actually going to use a
25:10 - stack to solve this problem now how we
25:12 - are going to use the stack is actually
25:15 - quite interesting let's first understand
25:17 - couple of properties number one thing is
25:19 - we are using the temperature to compare
25:22 - the difference between any two given
25:24 - values which means we are dealing with
25:26 - the value of this given array
25:28 - but in the answer we need to store that
25:31 - how many number of days are apart
25:34 - between any two entities and that we can
25:36 - find using the index values why because
25:39 - at index value 0er we have this value 73
25:42 - and at index value 1 we have this value
25:45 - 74 which means 7 uh index value zero is
25:49 - only one day away from finding a warmer
25:51 - day because index value 1 minus index
25:54 - value 0 becomes actually value number
25:56 - one so this is how we are going to find
25:58 - the answer which means in the stack it
26:01 - would make more sense to store the index
26:03 - positions rather than storing the actual
26:06 - values but using the index positions we
26:09 - can very quickly look up inside the
26:11 - array find the answer and then
26:13 - subsequently Traverse the answer so
26:15 - after this long explanation let me walk
26:18 - through the solution that I'm proposing
26:20 - So currently we are at zeroth index the
26:22 - value is 73 currently we don't have any
26:25 - value inside the stack so we are going
26:26 - to add index zero inside the stack okay
26:30 - and now we are at index position number
26:33 - one the value is 74 the very first thing
26:36 - we are going to do is we are going to
26:37 - check that whether the value located at
26:40 - zeroth position which means the value
26:42 - located at temp of zero if that is
26:45 - actually less than the current index
26:48 - positions we are at so if that is less
26:50 - than the temp of one which is correct
26:53 - condition because this one was 73 and
26:55 - this is 74 which means 70 this value can
26:59 - be popped out of the given stack and we
27:02 - can actually Mark the answer for this
27:04 - one by doing the subtraction between the
27:07 - current element minus the index position
27:10 - that we just kicked out from the stack
27:13 - so this is going to be just one where we
27:16 - did a simple equation 1 - 0 okay now we
27:20 - are going to put 74 in the stack but we
27:23 - are going to put the index value so now
27:24 - in the stack we have index position
27:26 - number one now once again we are at
27:28 - index position number two so this value
27:30 - is 75 75 is greater than 74 which means
27:34 - we can do 2 - 1 and the answer is one so
27:36 - we can store that that 74 is one day
27:40 - away from finding a warmer day now we
27:43 - popped out one from the stack now let's
27:45 - add ENT entry number two inside the
27:47 - stack okay now we are at this position
27:50 - 71 So currently 71 is actually smaller
27:55 - than 75 which means we don't for 75 we
27:59 - have not yet found a small a warmer day
28:02 - so we are going to add entry number
28:03 - three inside our stack as well next we
28:06 - are going to be at position number four
28:08 - which is 69 once again 69 is actually uh
28:12 - less than the current Top Value we have
28:15 - inside the index which means we haven't
28:17 - found a warmer day for this top element
28:20 - and we are going to add one more element
28:22 - uh that we haven't found a warmer day
28:24 - for okay now we are at position number
28:26 - 72 so 72 is actually greater than this
28:31 - value the value at index number four so
28:34 - we can actually uh find the answer for
28:37 - index number four so let me just go okay
28:40 - so this is for index number one zero we
28:43 - have one we have for two we don't have
28:45 - for three we don't have but for four we
28:47 - found the value that is 5 - 4 so we can
28:51 - add 1 as the answer for index number
28:53 - four Once Again One the moment we pop
28:56 - out index number four we we should not
28:58 - be pushing index number five yet because
29:01 - we still have to check that whether five
29:03 - is greater than index number three and
29:05 - yes it is once again greater so for
29:08 - index number three we are going to Mark
29:09 - the answer as two and same way for index
29:12 - number two we are also going to Mark the
29:14 - answer as uh so sorry for index number
29:19 - two we are still not able to be able to
29:21 - find the answer because this is 75 and
29:23 - this is 72 so we are going to have index
29:26 - number two still living inside the stack
29:29 - and then we will have index number five
29:30 - now residing in the stack now we are at
29:33 - index number six so this value is 76 76
29:36 - is actually greater than 72 and so in
29:39 - this case we can actually mark down the
29:42 - answer over here as 1 for this index
29:45 - number five and we can get rid of this
29:46 - index number five now once again this
29:48 - index number two is also smaller than
29:52 - index number six so we need to do the
29:54 - difference 6 - 2 so we find answer four
29:56 - and we are going to populate answer four
29:58 - over here and then we have an empty
30:00 - stack which means there are no more
30:02 - values we need to check so we are going
30:04 - to add value number six inside the stack
30:07 - and then in the end U next value is
30:09 - value number seven so 7 is 73 73 is
30:12 - actually smaller than the current stack
30:15 - value we have so we are also going to
30:16 - add value number seven inside the stack
30:18 - and the moment we reach to the end we
30:21 - are going to fill out all the rest of
30:22 - the elements by zero that there are zero
30:25 - days that we have been able to find the
30:27 - answers for and this is what we can
30:29 - return in the answer so you see how
30:32 - using a stack we actually need to
30:35 - Traverse over just once on the given
30:38 - temperature array and then we have been
30:39 - able to find the answer which means this
30:42 - is a much better approach and this is
30:44 - the optimal solution compared to our
30:46 - Brute Force solution so let's try to see
30:47 - the time and space complexity in this
30:49 - case the time complexity is actually
30:50 - going to be big of n because we are
30:52 - simply iterating over the temperature
30:54 - array once now it could be possible that
30:56 - for some values we might have to go back
30:59 - and find the values that are smaller
31:02 - than that that where we are doing
31:04 - multiple operations inside the stack but
31:06 - that that number is going to be limited
31:08 - because we are being told that we can
31:11 - find out that how many values are there
31:13 - and uh we are only iterating over the
31:16 - values for which we haven't find the
31:17 - answer and uh in terms of space
31:19 - complexity once again in the worst case
31:22 - scenario this is going to be big of n
31:24 - because we are using an additional space
31:26 - additional stack to find the answer
31:30 - answer so the coding solution is
31:32 - actually quite straightforward first we
31:34 - initialize a number n in order to mark
31:37 - down the length of the given array then
31:39 - we initialize a new answer array of the
31:41 - size n we also initialize our stack that
31:44 - we are going to use now we simply
31:46 - iterate over the given temperatures
31:47 - array using the for Loop we first have a
31:50 - while loop condition that while the
31:52 - given St stack is not empty and the
31:55 - temperature that we are iterating over
31:57 - current
31:58 - if that is greater than the temperature
32:00 - that is currently present inside the
32:02 - stack then we simply Mark the index
32:05 - value that is currently present at the
32:07 - very first element of the stack that we
32:09 - popped out and then we Mark the answer
32:11 - index by doing the subtraction of I
32:14 - minus the current index position that we
32:16 - have just been able to find by popping
32:18 - the element out of the stack and then uh
32:21 - we simply push down the element inside
32:23 - the stack and in the end our answer
32:25 - array should have all the answers so we
32:27 - can simply return done that now let's
32:28 - try to run this
32:32 - code okay seems like our solution is
32:34 - working as expected let's submit this
32:39 - code and our code runs pretty fast
32:42 - compared to most of the other Solutions
32:43 - it is also decent in terms of space
32:45 - complexity and once again the solution
32:47 - is available on our GitHub repository
32:49 - the link is in the description so you
32:51 - can check it out from
32:52 - [Music]
32:54 - there so the lead code problem we are
32:56 - going to solve is called evaluate
32:58 - reverse polish notation and we can see
33:00 - that this is a lead code medium problem
33:02 - and also an extremely well-like problem
33:04 - on lead code the problem statement is
33:06 - quite straightforward but it actually
33:08 - has bunch of different conditions that
33:09 - we need to understand so we are given an
33:12 - array of strings called tokens now these
33:14 - strings represents an arithmetic
33:17 - expression in the reverse polish
33:19 - notation now we need to evaluate the
33:21 - expression and we need to return the
33:23 - integer that represents the value of the
33:26 - expression now let's try to see some of
33:28 - the conditions that we are given number
33:29 - one the valid operations are plus minus
33:32 - multiply and division so these are the
33:34 - four operations that we can we can
33:35 - imagine to expect in our uh string that
33:38 - is coming in now we are being told that
33:40 - each operand may be an integer or
33:43 - another expression so we will see this
33:46 - in in another example then we are being
33:48 - told that the division between two
33:50 - integers always truncates towards zero
33:53 - which means we are always considering
33:55 - the ceiling value of ceiling value or
33:57 - sorry the floor value of any equation
34:00 - and then we are being told that all the
34:03 - inputs are going to be valid and there
34:04 - are not going to be any issues so let's
34:06 - try to see one example one very simple
34:08 - example so in this case the answer is
34:10 - going to be that the moment we identify
34:12 - an operator we will have to go back and
34:14 - take the previous two elements and if
34:16 - these two are whatever the numbers are
34:18 - we are going to be using that with this
34:20 - operator so we are going to be treating
34:23 - this as a we are going to be treating
34:25 - this as B and since this is a plus
34:27 - operator we are actually going to be
34:28 - doing a plus b so we need to return
34:30 - three as the answer in this case let's
34:32 - try to take some more slightly more
34:34 - complex examples first we are going okay
34:37 - so this is the number we move away move
34:39 - ahead once again a number we move ahead
34:42 - we identify an operator so now we are
34:43 - going to be treating these two values as
34:45 - a and b so we are going to be doing a
34:48 - plus b so 1 + 2 so the P the answer of
34:52 - this portion is actually going to be
34:54 - three our equation looks like three and
34:57 - then three and then plus so once again
34:59 - we are going to be doing 3 + 3 so the
35:01 - answer is 6 so out of this operation we
35:03 - need to return six as the answer so this
35:06 - is the whole logic of what the problem
35:09 - is actually asking us to solve that
35:11 - whenever we are given the values we keep
35:13 - moving forward until we find either one
35:15 - of these three operators like plus minus
35:17 - multiplication or division the moment we
35:20 - identify these four operators we are
35:21 - going to be treating the previous two
35:23 - values as a and b and then apply this
35:25 - operator and then keep on repeating the
35:27 - same process until we run out of all the
35:29 - every single digits inside the given
35:31 - inputs and we are being told that the
35:33 - all the inputs are valid now after this
35:36 - extensive explanation let's try to
35:38 - understand the most simplest Brute Force
35:40 - approach so Brute Force approach is
35:42 - actually quite straightforward uh
35:44 - suppose we are given the values 4 5 plus
35:47 - and then minus and then 7 suppose these
35:49 - are the values we are given so idea is
35:52 - that we are going to keep on iterating
35:54 - one by one the moment we identify an
35:56 - operator then once again we go back to
36:00 - the previous two elements and we use it
36:02 - with that operator and then once again
36:04 - uh we identify okay so now this becomes
36:06 - 9 and then minus and then 7 so once
36:09 - again we keep on repeating the same
36:10 - operation using the operator but thing
36:12 - is many times for let's assume that this
36:15 - if this is a very long string and we
36:17 - identify operator at very late the
36:19 - moment we identify operator once again
36:20 - we are going to be repeating the same
36:22 - process in order to keep find the values
36:24 - A and B so this becomes very tiresome
36:26 - operation so the idea is that we need to
36:29 - make it better and uh find some smarter
36:32 - ways to keep track of all the elements
36:35 - from the point we find the operators in
36:37 - the reverse order and also have an idea
36:39 - on how we can keep on moving forward
36:41 - with the given input array and start
36:44 - parsing the values so these are the two
36:46 - main considerations that we will have to
36:47 - understand so the idea I'm suggesting is
36:50 - that we can actually use stack to solve
36:53 - this problem so suppose this is the long
36:55 - operation that we are given now the idea
36:57 - I'm suggesting in using the stack is
36:59 - that at the very beginning we are
37:01 - actually going to be iterating the same
37:03 - way we are iterating all the values we
37:05 - find we are going to be pushing these
37:07 - values inside the stack the moment we
37:09 - identify the operator we are going to be
37:11 - popping the previous two elements and
37:13 - treating them as uh A and B and then
37:17 - applying that operator with that value
37:19 - and once again whatever the answer we
37:21 - find we are also going to be pushing
37:23 - those answer inside the stack and then
37:25 - we are going to keep on repeating the
37:27 - same process until we identifi the
37:28 - operator and then when we reach to the
37:30 - end we should have our answer ready
37:32 - because we are being told that the given
37:34 - input is actually valid so let's see the
37:36 - solution in action So currently our
37:38 - stack is empty now we are at very first
37:41 - element number two so we are going to be
37:42 - pushing element number two inside the
37:44 - stack now we are element number three
37:46 - and once again element number seven okay
37:48 - now we identified an operator plus so
37:51 - the moment we identified the plus
37:53 - operator we are actually going to be
37:54 - popping these two values out so if we do
37:57 - that we will have value 7 and three that
37:59 - we need to do the sum of so 7 + 3 is
38:02 - going to give us the answer 10 So
38:04 - currently the answer of this portion is
38:05 - going to be 10 so we are going to be
38:07 - pushing this 10 inside the stack and now
38:10 - look at the stack it actually contains
38:12 - the equation for this portion because
38:15 - sum of these three values is 10 that is
38:17 - present over here and then two was
38:19 - already here now we have 10 and two once
38:22 - again we identify multiplication sign so
38:24 - we need to do 2 * 10 so we get the value
38:26 - as 20 so now once again we are going to
38:29 - be pushing the value 20 because we
38:31 - already popped out 2 and 10 okay so now
38:34 - we have value 20 inside our array and
38:36 - now we once again identified value
38:38 - number eight and then once again value
38:40 - number 19 so let's push that okay after
38:43 - doing that now we identified car symbol
38:46 - plus so once again for plus we are going
38:48 - to be doing 8 + 19 so the answer is
38:51 - going to be 27 okay so now we are
38:54 - because we popped out 19 and 8 we push
38:57 - 27 7 down and then we have this minus
38:59 - operator so last operation we are going
39:01 - to be doing is 27 minus 20 so the answer
39:04 - is going to be 7 so 7even is what we
39:07 - need to return in this case to solve the
39:09 - problem and this is the whole solution
39:11 - that I'm proposing using the stack look
39:13 - how beautiful it is look how at any
39:15 - given moment but by the moment we
39:17 - identified the operator we can actually
39:20 - find the previous two elements back and
39:22 - we can actually do the sum uh that needs
39:24 - to be done or some division uh
39:27 - subtraction whatever and this is how we
39:29 - can solve the reverse polish operation
39:30 - very beautifully using stack this is one
39:33 - of the most awesome way to use stack in
39:36 - the real life problem and that's why
39:38 - this is such a popular problem that we
39:40 - have seen in tons of interviews being
39:42 - asked so if we see time complexity in
39:44 - this case the time complexity is
39:46 - actually going to be biger of n because
39:47 - we are going to be iterating over every
39:49 - single character just once nothing more
39:50 - than that in terms of space complexity
39:53 - we are using an additional uh stack so
39:56 - depending on how apart the characters
40:00 - are from any operation the size of Stack
40:03 - can increase or decrease but overall it
40:05 - is going to be big of n so which is good
40:08 - uh and uh acceptable time and space
40:10 - complexity in this regard so now let's
40:12 - see the coding solution for this
40:14 - one so the idea is quite straightforward
40:17 - first of all we are going to be
40:18 - initializing our stack then for every
40:21 - single token we are first of all going
40:23 - to check that if the given token is
40:26 - operator or not the moment we identify
40:28 - that if the given token is operator we
40:31 - are going to be popping two values out
40:32 - so first value we pop out is going to be
40:35 - our B and second value is going to be
40:36 - our a and then we are going to be
40:39 - applying our operator that we have found
40:42 - uh using this method so let's see couple
40:44 - of the helper methods first helper
40:46 - method is the is operator helper method
40:48 - where we are simply checking that if the
40:50 - given token is equal to any of these
40:52 - four values and second one we are
40:55 - applying the operator Where We Are
40:57 - simply going to go over the given input
40:59 - values that is the string and then a
41:01 - value and B value and we are simply
41:04 - returning depending on the operator to
41:07 - whether do the addition subtraction
41:09 - multiplication or Division and if none
41:11 - of this case is there we are simply
41:13 - adding one extra argument but I don't
41:15 - think this is going to uh be called
41:17 - because we are being told that the given
41:18 - input is valid if that is not the case
41:22 - and we did not find that these are the
41:24 - operator by the way uh the moment we
41:26 - identified the operator we also do the
41:28 - calculation and whatever the result we
41:30 - found we once again push it down the
41:32 - stack if that is not the case which
41:34 - means the given token is not an operator
41:36 - so we simply push it down the stack but
41:39 - we first of all convert the value inside
41:41 - the integer because we know that this is
41:43 - going to be the integer value and once
41:45 - this Loop runs we should have been done
41:47 - with our reverse polish notation and
41:49 - whatever the value left inside the given
41:52 - stack would be the answer that we need
41:53 - to return so we can simply pop the very
41:56 - last element so let's try to run this
42:00 - code okay seems like our solution is
42:02 - working as expected let's submit this
42:05 - code and our code runs pretty fast in
42:08 - terms of time complexity which is pretty
42:10 - awesome once again the coding solution
42:12 - for this problem is present inside our
42:14 - GitHub repository so you can find it
42:16 - from
42:16 - [Music]
42:19 - there so the lead code problem we are
42:21 - going to solve is called Min stack and
42:23 - you can see that this is a lead code
42:24 - medium problem and also a very well like
42:27 - problem on lead code the problem
42:28 - statement is very simple that we need to
42:30 - design a stack that can support push pop
42:33 - top and retriving the minimum element
42:36 - inside the given stop these four
42:38 - operations and it needs to run in
42:40 - constant time or B go off one time so we
42:43 - need to implement the Min stack class
42:45 - and these are all the methods that we
42:47 - need to implement now we know that how
42:48 - does a typical stack work stack operates
42:50 - in Leo principle last in first out if we
42:53 - decide to push element number three then
42:55 - we will have an entry three presented
42:57 - inside the stack next we can push
42:59 - another entry called one then once again
43:02 - we will have entry called one then once
43:03 - again we can have Push another entry
43:05 - called five So currently we have three
43:08 - elements now inside the stack if we have
43:10 - to pop this element then the element
43:13 - five would pop out so let's quickly pop
43:15 - one element so then we will get answer
43:17 - number five then if we do pop once again
43:20 - we will have value number one after
43:22 - doing that if we were to add two two
43:25 - more elements or push two more elements
43:27 - let's assume 2 and six so once again we
43:29 - will have elements 2 and six something
43:31 - like this then if we do top operation at
43:34 - this moment it it should return return
43:35 - answer six because that is the top
43:37 - element inside the array and then if we
43:39 - do get min then it should return us the
43:41 - value S2 because this is the current
43:44 - present minimum element inside the given
43:46 - stack so these are all the operations
43:49 - that we need to do we need to solve all
43:51 - of these in big of one time which means
43:54 - we will have to do something different
43:56 - when we are design designing our stack
43:58 - so what are some of the considerations
44:00 - that we can do the thing is this push
44:03 - method pop method and top method all of
44:06 - these three methods can operate in big
44:08 - go of one time no issues with that in
44:11 - either case this get min is little bit
44:13 - tricky because we will we will need to
44:16 - know that what is the minimum element at
44:19 - any given moment now the very first
44:21 - thing that comes to our mind is that
44:22 - when we are designing the stack uh why
44:24 - don't we just have an extra variable
44:26 - called Min to keep track of the minimum
44:28 - value we have encountered So Far So
44:30 - currently this is an empty stack let's
44:32 - assume that we enter value number five
44:34 - so this has been the minimum value so
44:36 - far five next we add value number six so
44:39 - five is still the minimum value next we
44:40 - add value number two so once again we
44:43 - update this and add two over here once
44:45 - again we add value number seven so now
44:48 - currently the minimum value is two but
44:50 - now there is one problem that you did
44:52 - not see and that problem is that let's
44:54 - assume that we decide to pop one element
44:56 - out so now currently seven is no longer
44:58 - here but once again the minimum V
45:00 - variable is still two because that is
45:03 - the minimum variable let's see let's say
45:05 - that if we do pop once again so once
45:06 - again two is now no longer inside the
45:08 - given stack as well so now if we do Min
45:11 - operation we don't know that what is the
45:13 - minimum value inside the array because
45:15 - we just overrode the value so if we have
45:17 - to check for the minimum value we will
45:19 - have to pop all the elements out of the
45:21 - stack and then find the minimum value
45:23 - that is option number one which takes
45:25 - big off end time and if we don't do that
45:27 - we we basically don't have any other way
45:30 - so now to overcome this issue and to
45:32 - keep track of the minimum value at every
45:34 - single variable we can actually do
45:36 - things slightly differently so the
45:39 - moment we are storing the values inside
45:41 - the given array uh we are actually
45:43 - storing different nodes right for every
45:45 - single location now in this design of
45:48 - node we can actually have node have
45:50 - multiple items not only just its value
45:53 - so let's assume that this is our given
45:55 - node and so in the node I'm suggesting
45:57 - to add three values first value is the
45:59 - value of the node itself that whatever
46:01 - the value we wants to enter that is your
46:03 - integer value like 1 2 34 whatever he
46:05 - wants to put next is that what has been
46:08 - the minimum value up to this point
46:11 - inside the existing stack and if we keep
46:13 - on updating this value with every single
46:15 - entry inside the stack this would be
46:17 - pretty easy to maintain and last thing
46:19 - is the reference to the next node
46:22 - because uh in case we will have to
46:24 - remove or get rid of the element we
46:26 - might need to update the minimum value
46:28 - we have entered so far so let's see that
46:31 - how would this approach is going to look
46:33 - like let's say that we wants to add
46:35 - these values inside the stack okay so
46:38 - first we wants to add value number three
46:40 - currently the node is empty so because
46:42 - node is empty we are adding value number
46:44 - three h what has been the minimum value
46:46 - we have added so far that is also going
46:48 - to be value number three and the
46:50 - reference to the next node is going to
46:51 - be null so we are not going to be
46:53 - concerned with that that this is the
46:55 - very last element inside the stack okay
46:57 - now we need to add value number five so
47:00 - we add value number five but what has
47:02 - been the minimum value is is so far so
47:05 - for that we can either check the minimum
47:08 - value of the next pointer using this
47:10 - next pointer so we check that what has
47:13 - been the minimum value of the next
47:15 - pointer at location number five that is
47:17 - value number three and what is the value
47:20 - of this current value we are trying to
47:21 - enter that is value number five so
47:23 - whichever is the smaller number which is
47:25 - three in this case so we will still Mark
47:27 - three as the minimum value we have been
47:29 - able to find and then we simply have a
47:31 - reference to the next node so reference
47:33 - to the next node once again I'm just
47:35 - marking as three but that that is simply
47:37 - going to be this node okay once again we
47:39 - wants to enter value number one so now
47:41 - at one what has been the minimum value
47:44 - up until this point that is this value
47:46 - number three so instead of using three
47:48 - because one is smaller so the smallest
47:50 - value so far is going to be one and the
47:52 - reference to the next node is also going
47:54 - to be this one same way now we wants to
47:56 - add value number seven but what has been
47:58 - the minimum value we have been able to
47:59 - find so far that is value number one and
48:01 - then just the reference to the next node
48:03 - and then in the end the value is zero so
48:06 - now the value is zero we are trying to
48:08 - see that what has been the minimum value
48:10 - up until this point that is one so
48:12 - compared to one Z is smaller so then
48:14 - this is also going to be zero and then
48:16 - we simply have a reference to the next
48:17 - note okay so now this is what our uh
48:21 - stack looks like we are simply updating
48:23 - the node that we are storing uh the
48:25 - values in and now let's let see each of
48:27 - the operation so I just mentioned that
48:29 - push operation can happen in big off one
48:31 - time because we are just simply pushing
48:32 - one node inside the stack uh let's try
48:35 - to do a pop operation so pop operation
48:37 - can also happen in big off one time
48:39 - because we are simply popping one
48:40 - element out so we will get rid of this
48:42 - element okay now once again let's try to
48:45 - do the top operation so top operation we
48:47 - need we can return seven immediately
48:49 - because that has been the latest value
48:50 - we we find and then if we do the get min
48:53 - operation this can also happen in big
48:55 - off one time because we can simply find
48:57 - the minimum value we have been able to
48:58 - identify so far so this is the logic on
49:02 - how we are going to solve this problem
49:04 - basically by simply redefining the way
49:06 - we are storing the values and then
49:08 - keeping track of the minimum value at
49:10 - every single position that is the whole
49:12 - trick and if we see time complexity in
49:14 - this case well time complexity we
49:15 - already know that that is going to be
49:17 - big of one and in terms of space
49:19 - complexity uh well this is debatable but
49:22 - I think it it has to be big off one
49:23 - because anyways we are being asked to
49:25 - create a stack so we cannot create extra
49:27 - space for that so first let's define the
49:29 - node for our given class where we are
49:32 - going to store three values first one is
49:34 - the value of any particular position
49:36 - next is the Min value and third is the
49:38 - reference to the next node and this is
49:40 - just a simple Constructor to store the
49:42 - values okay now coming back to our main
49:45 - class we are going to have a private
49:46 - node head and we are going to initialize
49:48 - our data structure here next we are
49:51 - going to have a main push method so
49:54 - whenever we need to push any single ENT
49:57 - so if the value is very first then we
49:59 - are simply going to provide the value as
50:01 - it is then minimum value is also going
50:03 - to be the same value because there are
50:05 - no other entries inside the stack and
50:07 - then the next element would be simply
50:09 - null if that is not the case we are
50:11 - going to add a new node where we are
50:13 - going to keep the value as it is then
50:16 - for the minimum value we are actually
50:18 - going to compare it with the current
50:19 - value and the minimum value we have been
50:22 - able to find so far and that we can
50:24 - simply find uh using the next node and
50:27 - then as a part of the next node we are
50:28 - simply going to point to the Head node
50:30 - and this is going to be keep on updating
50:32 - with every single entry uh for the pop
50:35 - it's very simple we simply uh take the
50:37 - very first element that is currently
50:39 - present for the top we simply return the
50:41 - very first element and then inside the
50:44 - for the get min method we simply return
50:46 - the minimum value for the head and this
50:48 - is the whole solution let's try to run
50:50 - the
50:52 - code okay seems like our solution is
50:54 - working as expected let's submit this
50:56 - code
50:59 - and our code runs extremely fast
51:01 - compared to lot of other Solutions in
51:03 - terms of time complexity and very
51:05 - efficient in terms of space complexity
51:07 - so once again I will be posting this in
51:09 - our GitHub repository so you can check
51:10 - it out from there
51:13 - thank and today we are going to solve a
51:15 - lead code problem called generate
51:17 - parenthesis now if you see some of the
51:18 - popular companies who have already asked
51:20 - this question there are companies like
51:21 - Amazon Facebook Microsoft Apple
51:23 - Bloomberg Uber Lyft Google by dance
51:26 - Spotify and Nvidia so that's why I'm
51:29 - paying my at most attention I hope you
51:31 - also enjoy the
51:33 - video okay so this is a lead code medium
51:36 - problem and also very well- like problem
51:38 - on lead code basically we are given an
51:40 - input number n and now we need to
51:41 - generate n pairs of parentheses so
51:44 - basically we need to write a function
51:45 - that generates all the possible
51:47 - combinations of well-formed parentheses
51:49 - now these round parenthesis I think they
51:51 - are called wellform parenthesis now we
51:54 - can try to understand these two examples
51:56 - but I'm going to take take it one step
51:58 - further and I'm going to show you four
51:59 - different examples to understand that
52:01 - what this problem is asking us to do
52:03 - okay now in this first example we are
52:05 - basically given n is equal to one pair
52:07 - which means we need to make one possible
52:09 - pair and all the combinations of this
52:11 - well formed parenthesis so obviously the
52:13 - answer is going to be quite simple we
52:15 - simply need to return return like uh
52:17 - just one possible pair that we can make
52:19 - out of this one now suppose n is equal
52:21 - to 2 so now for n is equal to 2 we have
52:23 - the choice to take like two of these and
52:26 - two of of these right we need to take
52:28 - four values uh so basically the number
52:31 - of possibilities we can make is that we
52:33 - can actually make a parenthesis that
52:35 - looks like this and we can also make a
52:37 - parenthesis that looks like this these
52:38 - are the only two possibilities we can
52:40 - have and uh this is what we need to
52:42 - return return as the answer now things
52:44 - becomes a little bit interesting when we
52:46 - reach to n is equal to 3 uh so when we
52:48 - get to the point where n is equal to
52:50 - three the possibilities we can make
52:53 - is so these are the five possible pairs
52:55 - we can make when n is equal to 3 now
52:58 - notice that over here for every single
53:00 - piece we are using like three opening
53:02 - brackets and we are also using three
53:03 - closing brackets but we are just putting
53:05 - them in different pairs so that they
53:08 - generate like the well-formed
53:09 - parenthesis uh same way if we try to do
53:12 - it with n is equal to 4 the answer is
53:14 - going to be pretty huge so let me just
53:15 - uh draw it over
53:19 - here so these are all the possible pairs
53:22 - we can make when n is equal to 4 and
53:23 - basically we are using four opening
53:25 - brackets and four closing brackets and
53:27 - arranging them in different sizes so
53:29 - this is a very interesting problem now
53:31 - let's see that what are going to be the
53:32 - different approaches to solve this
53:35 - problem so now the first approach that
53:38 - comes to our mind is a Brute Force
53:39 - approach in The Brute Force approach
53:40 - what we can do is suppose we are given n
53:42 - is equal to two right if we are given n
53:44 - is equal to 2 there is one thing
53:45 - guaranteed we need to have four
53:47 - characters inside every single block of
53:50 - our answer why four characters because
53:52 - uh we are generating two pairs of
53:54 - parentheses so two pairs of parth Paris
53:56 - is basically going to be four characters
53:58 - at least right so what we can do is now
54:01 - we have two options to choose from
54:02 - either we can choose an opening
54:03 - parenthesis or we can choose a closing
54:05 - parenthesis so what we are going to do
54:06 - is basically we can take every single
54:08 - possible pair that we can make of size
54:11 - four using these two characters and only
54:13 - the valid pairs we put put them in the
54:16 - answer so suppose we are given n is
54:17 - equal to 2 what are the different pairs
54:19 - we can make let me make just a few pairs
54:22 - so these are just some of the few
54:23 - examples that we can make for four
54:25 - characters using like this opening and
54:27 - closing parenthesis for n is equal to 2
54:30 - and over here we only need to find the
54:31 - legitimate pair so okay we can find one
54:33 - legitimate pair and we can find another
54:35 - legitimate pair and I think this is
54:36 - going to be the answer that we need to
54:38 - return so we will put these two in the
54:39 - answer and then just return them but if
54:42 - you see this Pro Force approach is
54:44 - extremely inefficient uh if we see like
54:47 - time complexity the time complexity goes
54:49 - sometimes into like 2 to the power of 2
54:51 - N something multiplied by n just to
54:53 - check that whether the pair is valid or
54:55 - not and that is this dter us so no one
54:58 - is going to accept that so we will have
54:59 - to find a way to do something
55:03 - better so what we are going to do is we
55:06 - are going to do things smartly how we
55:08 - are going to do things smartly first
55:09 - let's define our perspect purpose our
55:11 - purpose is to generate two pairs of
55:13 - opening and two pairs of closing
55:14 - brackets and they has to be well
55:16 - informed or valid now we need like two
55:20 - opening brackets so that is a given fact
55:22 - we need two closing brackets that is
55:24 - also a given fact now there are are some
55:26 - properties that we can use at our
55:28 - advantage taking consideration the
55:31 - definition of being valid now what is
55:33 - the definition of being valid so
55:35 - basically if we are given n is equal to
55:37 - 2 there has to be uh two opening
55:39 - parentheses and two closing parentheses
55:42 - so that is one definition second
55:44 - definition for being valid is that we
55:46 - can only put a closing parenthesis if
55:51 - there exist an opening parenthesis
55:54 - before that again I'm repeating myself
55:56 - we can only put a closing parenthesis if
55:59 - there exists a closing parenthesis
56:01 - before that we cannot start our answer
56:04 - with a closing parenthesis because that
56:06 - wouldn't be valid uh third third thing
56:10 - that we need to consider is that we can
56:12 - only have that many number of open
56:14 - parentheses that is equal to the number
56:17 - of n now you are saying that why am I
56:19 - repeating myself because this is going
56:20 - to be the very important property that
56:22 - we are going to use uh so now once we
56:24 - know all of these things let's try to
56:27 - make some smart decisions on how we can
56:29 - actually generate the answer for valid
56:32 - parenthesis uh basically we are given n
56:34 - is equal to 2 over here right now we
56:36 - have option to choose like two opening
56:38 - parentheses and two closing parenthesis
56:41 - so okay now what we are going to do is
56:43 - uh for our answer generation always we
56:46 - will have to start with us an opening
56:48 - parenthesis right now we we created the
56:51 - opening parenthesis that starts with
56:53 - this one now we are going to keep track
56:55 - of few values first value we are going
56:56 - to keep track of is the number of
56:58 - opening parenthesis right so number of
57:00 - opening parenthesis that we have used so
57:02 - far is one uh and what is the maximum we
57:05 - can use maximum we can use is two
57:07 - because that is the value of n we are
57:09 - also going to keep track of the number
57:11 - of opening parentheses we already know
57:13 - that is one right we are also going to
57:14 - keep track of number of closing
57:16 - parentheses and so far we haven't used
57:18 - any closing parenthesis so that this
57:20 - value is zero and we can only add a
57:23 - closing parenthesis if the number of
57:25 - open parentheses is greater than the
57:28 - number of closing parenthesis because we
57:30 - already proved that over here now using
57:32 - this logic let's see that what is the
57:34 - sequence we can make okay so first we
57:36 - start with this value when we start with
57:38 - this value number of opening parenthesis
57:40 - is one number of closing parenthesis is
57:41 - zero now over here we have two options
57:44 - uh and those two options are we can
57:47 - either add one more opening parenthesis
57:49 - or we can add a closing parenthesis so
57:51 - let's see options in both of both of the
57:53 - cases the number of opening parenthesis
57:55 - is going to be two and we can have this
57:57 - value to be two because we are given n
57:59 - is equal to 2 and in this case the
58:01 - number of closing parentheses is still
58:03 - going to be zero because we have only
58:04 - used two open G parentheses over here
58:06 - now in this case the answer is going to
58:08 - be a little bit different uh because the
58:10 - number of opening parentheses is going
58:11 - to be one and number of closing
58:12 - parentheses is also going to be one and
58:14 - this is also valid why because the
58:16 - number of closing parentheses can be one
58:19 - because we already had one open
58:20 - parenthesis so so far both of the cases
58:23 - are legitimate now again at this
58:25 - position we also have two more choices
58:27 - so over here we have the one choice to
58:30 - open and we have one choice to close now
58:32 - let's see both the options if we try to
58:34 - go one choice to open what we will
58:36 - happen is number of opening bracket is
58:38 - going to be three but that is not valid
58:40 - why because we are given n is equal to
58:42 - two explicitly so in this case we cannot
58:44 - go down this path so if we cannot go
58:47 - down this path we will actually
58:48 - backtrack and come back to this position
58:51 - now from this position we can only go
58:53 - towards the path of closing so if we go
58:55 - towards the path of closing so far the
58:57 - number of Open brackets we had is two
58:59 - and the number of closed bracket we had
59:01 - is one so that is still valid that is
59:03 - still legitimate now again from this
59:05 - position we still have two options we
59:07 - can either open or we can close if we
59:09 - try to open we cannot do that because
59:11 - number of open is going to be three so
59:13 - we are not going to go down this path uh
59:15 - if we go down this path uh basically the
59:18 - number of Open Bracket is going to be
59:19 - two number of Clos bracket is going to
59:21 - be two as well and this is the exact
59:23 - condition we need because we are given n
59:26 - is equal to 2 so which means that there
59:28 - has to be two Open brackets and two
59:29 - closed brackets so we can put two
59:31 - conditions whether we can put like the
59:33 - combination of open Plus close is going
59:35 - to be four that is going to be the
59:36 - double of what is uh n or we can have
59:39 - like uh o is equal to 2 and C is equal
59:42 - to two both of them equal to two so this
59:44 - is also good so now we have reached this
59:47 - condition which means that whatever the
59:49 - path we actually make can make our
59:52 - ourselves into the answer so what is the
59:54 - path we took so first we started with uh
59:57 - taking the opening bracket then again
59:59 - opening bracket then again closing
60:01 - bracket and then again closing bracket
60:03 - so let's put this value in the answer
60:05 - right so we are going to create a new
60:06 - variable answer over here and over here
60:08 - let's put one entry that okay two open
60:11 - two close that is good now let's start
60:14 - following the other path I'm going to
60:15 - clean this up a bit so it does not
60:17 - become any more distraction so now in
60:20 - this case okay currently we have one
60:21 - Open Bracket one closed bracket now
60:23 - again we have two possibilities so first
60:25 - possibility we can open one more bracket
60:27 - or we can close one more bracket now
60:29 - let's uh analyze both the possibilities
60:31 - if we try to open one more bracket
60:33 - basically the number of Open brackets we
60:35 - are going to have is two let me clean
60:37 - this up a bit more and over here uh
60:39 - number of closed bracket we had so far
60:41 - is still one so okay this is valid we
60:44 - can put this one now if we try to put
60:46 - one more closed bracket the number of
60:48 - Open Bracket we have so far is only
60:50 - going to be one but number of closed
60:51 - bracket is going to be two which is no a
60:53 - big no no why because we cannot have
60:55 - more close bracket then the number of
60:57 - brackets we have opened because that
60:59 - would defy the possibility of having a
61:02 - legitimate scenario so we cannot go down
61:04 - this path so we won't and uh now again
61:07 - we have two choices at this position we
61:09 - can open one or we can close one if we
61:11 - open one then the number of open is
61:13 - going to be three that is not valid that
61:15 - is not good so we are not going to do
61:16 - anything with this one and we will not
61:18 - go down this path if we go down this
61:20 - path then over here number of Open
61:22 - brackets we have so far is two and
61:23 - number of closed bracket we have so far
61:25 - is also two which is also the legitimate
61:27 - scenario so which means that this path
61:30 - is also going to be a path that we can
61:32 - add to our answer and uh let's see okay
61:35 - so currently we have okay we have one
61:38 - Open Bracket one Clos bracket we also
61:40 - have one Open Bracket and one closed
61:41 - bracket and that's it now uh initially
61:45 - remember we only started with this one
61:47 - opening bracket and then we had two
61:48 - possibilities and we actually exhausted
61:50 - both the possibilities so we cannot go
61:52 - down further anymore now because we
61:56 - cannot go down further anymore uh we can
61:58 - conclude that whatever the values we
62:00 - find so far this is the complete answer
62:03 - and we can return return this as the
62:04 - answer and basically this is the whole
62:06 - Crux of the finding the optimal solution
62:09 - now you must be asking that hey what we
62:12 - actually did was uh we did something s
62:14 - very important first we identify okay
62:17 - the one value then we had the uh final
62:20 - case so final case was that whenever the
62:22 - number of opening is equal to n and
62:24 - number of closing brackets is also equal
62:26 - to n this is our final case and then at
62:28 - every single position we had two options
62:30 - to either choose an opening bracket and
62:32 - closing bracket and keep on repeating
62:35 - the same process until we reach to the
62:37 - end and we had some parameters in mind
62:40 - so if you see we are actually using
62:42 - dynamic programming at its finest
62:45 - because at any single previously
62:47 - computed value that is being used to
62:49 - calculate that which path we need to
62:51 - take and whether we can take that path
62:53 - or not so we are basically using dynamic
62:55 - DC programming plus backtracking to
62:57 - solve this problem and this is going to
63:00 - be like an amazing way to explain this
63:04 - problem uh logically think that in the
63:07 - Brute Force what a disastrous result we
63:10 - were having and we actually brought it
63:12 - down to such like beautiful answer and
63:14 - then we are just presenting it so this
63:16 - is the whole power of uh using any like
63:19 - computer
63:23 - language so before we start implementing
63:25 - the generate parenthesis method first we
63:27 - are going to create our backtrack method
63:29 - uh that is going to be our helper method
63:31 - that we are going to use recursively now
63:33 - for the backtrack method it is not going
63:35 - to return anything uh but it is going to
63:37 - add all the values towards the answer
63:39 - and inside the method we are actually
63:41 - going to create a list of list that is
63:44 - going to store the answer we are also
63:46 - going to have a string Builder to keep
63:48 - track of the current values we have the
63:50 - number of opening and number of closing
63:51 - brackets and also the maximum number of
63:54 - values we can generate
63:56 - okay so now first let's create the
63:58 - acceptable scenario so if basically the
64:01 - current length is actually going to be
64:03 - maximum * 2 uh which means that we can
64:06 - actually we have reached to our answer
64:08 - and we can add it to our answer so this
64:11 - is the legitimate scenario now let's see
64:14 - say for an example we find out that uh
64:17 - uh the we have not reached the answer
64:19 - then what could be the possibility well
64:20 - first possibility could be the number of
64:22 - Open brackets uh that could be less than
64:24 - the number of maximum brackets that is
64:26 - allowed if that is the case basically
64:28 - for the current uh string Builder we can
64:31 - actually upend an opening bracket so
64:34 - let's do that and uh after adding the
64:37 - opening bracket basically we will have
64:39 - to call the backtrack method again with
64:41 - a reduced value of one Open Bracket so
64:45 - let's do that so in the backtrack method
64:47 - we are going to call the answer and we
64:48 - are also going to call the current uh
64:50 - string Builder list we have but for the
64:52 - open we are actually going to add one
64:54 - value and for the number of closed
64:57 - brackets we are going to keep it as it
64:58 - is the max is also not going to be
65:00 - changed and that is awesome now there is
65:03 - also one more important thing we will
65:05 - have to do every single time we make a
65:07 - backtrack call and that is to delete one
65:10 - character that is located at the current
65:13 - length minus one because it is going to
65:14 - add an extra character so let's do
65:19 - that okay now same way uh say for an
65:23 - example if the number of uh close CL
65:25 - brackets and they are less than the
65:27 - number of Open brackets uh if that is
65:30 - the case basically we can also add one
65:33 - closed bracket to our self as well so
65:36 - let's do that and we are also going to
65:37 - call the backtrack method and uh
65:39 - everything else is going to remain the
65:41 - same and basically this whole logic sums
65:45 - up our backtrack method now all we need
65:47 - to do is from our main method we simply
65:49 - need to create a list of list called
65:51 - answer so let's do that and then we are
65:54 - going to call our backtrack method now
65:57 - inside the backtrack method we are going
65:58 - to provide the value of answer we are
66:00 - also going to provide a new instance of
66:02 - a string Builder Pro going to provide
66:05 - the number of opening brackets that we
66:07 - have used so far is zero number of
66:08 - closing brackets is also zero and the
66:11 - maximum number of opening and closing
66:13 - bracket we can have is going to be the
66:14 - value of N and after getting the answer
66:17 - from the backtrack method we can simply
66:19 - return the answer to be return the
66:22 - answer that we got and uh basically
66:24 - that's it yeah let's try to run the
66:27 - code okay seems like our solution is
66:29 - working as expected let's try to submit
66:31 - the
66:33 - code if we submit the code our solution
66:36 - beats lot of other Solutions it is
66:37 - really good in terms of time complexity
66:39 - and it is also really efficient in terms
66:41 - of space complexity as
66:43 - [Music]
66:45 - well hello friends hope you are having a
66:47 - fantastic day today so once again we are
66:50 - going to do an awesome lead code problem
66:52 - and trust me this is an awesome lead
66:54 - code problem so without any delay let's
66:57 - get started so now we are going to solve
66:59 - the lead code problem called car Fleet
67:01 - now personally this is one of my
67:03 - favorite problems and we can see that
67:05 - this one is a lead code medium problem
67:07 - and also decently well-like problem the
67:10 - thing is this is a very long description
67:13 - for this problem because it covers lot
67:15 - of edge cases and lot of conditions that
67:16 - you have to understand if you want be my
67:19 - guest and read the whole description if
67:21 - not let me just point out few important
67:24 - topics and then we will we will try to
67:26 - understand what the problem is asking us
67:27 - to do through an example that would make
67:29 - things much more simpler so first thing
67:32 - is we are being told that there are n
67:34 - cars going in the same destination along
67:37 - one lane road so it's a single Lane Road
67:40 - and we are told that the cars are not
67:42 - going to be overtaking each other this
67:43 - is not fast and furious this is lead
67:45 - code okay then we are also given a
67:48 - Target miles that we need to reach that
67:50 - is the final destination for our cars
67:54 - now we are given two integer arrays
67:56 - first one is position and second one is
67:58 - called speed so position defines that
68:01 - what is the starting position for any
68:04 - particular given car compared to that
68:07 - Target distance okay and the speed is at
68:10 - what speed that particular car is
68:12 - running on so we are given both the
68:14 - values inside the car now we are being
68:17 - told that cars are not going to overtake
68:20 - each other but if they are close enough
68:22 - we can consider them arriving at the
68:24 - destination at the same time
68:26 - and any car arriving at the destination
68:29 - or set of cars arriving at the
68:31 - destination would be considered as car
68:34 - Fleet and now we need to consider that
68:36 - how many number of different car fleets
68:39 - actually arrive to the destination so I
68:41 - know that this was quite complicated and
68:44 - very extensive description let's try to
68:46 - make it simpler using some example so
68:49 - over here we are given a Target value of
68:52 - 12 that we need to reach and we are
68:54 - given the positions and we are also
68:56 - given the speeds of subsequent cars so
68:59 - here I have actually plotted a graph or
69:03 - a number sequence where this 12 is the
69:06 - Target that every single car is trying
69:08 - to reach now this C1 C2 these represents
69:12 - different cars and we can see that based
69:14 - on their positions inside the subsequent
69:16 - array I have already plotted them on
69:19 - this given line so this defines their
69:21 - starting position and subsequently this
69:25 - ption defines that what is the speed
69:28 - that is given to every single car okay
69:30 - and we are being told that the distance
69:32 - we are trying to cover is 12 mil and the
69:35 - speeds are given in per hour basis so
69:39 - which means this car C2 actually Travers
69:41 - 4 miles in 1 hour okay so now we need to
69:46 - understand that how we Define car fleets
69:49 - so let's try to understand it one by one
69:52 - so we will try to go over that how every
69:55 - single car is actually going to reach to
69:57 - the Final Destination and we know for
69:59 - sure that no car is going to overtake
70:02 - one other so if one car comes closer to
70:05 - the other car we would consider both of
70:08 - them reaching to the destination at the
70:09 - same time and there would be part of one
70:11 - single Fleet so first let's see So
70:15 - currently this car C1 is located at
70:17 - position number 10 and its given speed
70:20 - is 2 mph we know that the C1 has to be
70:24 - the first car to reach to the
70:25 - destination because it is the closest
70:27 - car to the destination so the in the
70:30 - first hour this car is actually going to
70:33 - reach to the destination and it's going
70:35 - to take 1 hour but during this 1 hour
70:37 - period because how do we come up with
70:39 - this 1 hour because we calculated the
70:41 - distance from the current position to
70:43 - the Final Destination we are trying to
70:44 - reach which is 2 miles and its speed is
70:47 - also 2 miles so we can easily easily
70:49 - calculate the time uh that it takes to
70:52 - reach to the destination now for this C2
70:55 - also
70:56 - subsequently the C2 would also reach to
71:00 - the destination in just 1 hour so based
71:03 - on this we can conclude that both of
71:06 - this C1 and C2 are actually going to
71:09 - reach to the destination around the same
71:11 - time around at 1 hour mark which means
71:14 - C1 would be here and C2 would be right
71:16 - very close to it so these two cars are
71:19 - going to reach to the destination in
71:21 - around the same time which means this is
71:24 - going to be one of the Fleet that is
71:26 - going to arrive into the destination so
71:29 - now we already took care of one Fleet so
71:31 - let's just get rid of these okay and
71:33 - also let's try to understand that we
71:35 - have already spent 1 hour so during this
71:37 - 1 hour what would be the position of all
71:40 - of these cars so during 1 hour the C4
71:43 - would have traveled 1 kilm so C4 would
71:46 - be here same way the C5 would have also
71:49 - Kil con completed 3 kilm because its
71:53 - speed is three so after after this 1
71:55 - hour this c5's position should have been
71:58 - at position number six but at position
72:01 - number six we can clearly see that C4 is
72:03 - already present which means after 1 hour
72:06 - the position is going to look something
72:07 - like this where C4 and C5 are going to
72:10 - be right close to each other now
72:12 - remember that the speed of the C4 is 1
72:15 - and speed of the C5 is three but because
72:18 - C4 is ahead compared to C5 even though
72:21 - it has higher speed it is not going to
72:23 - overtake it and it is only going to
72:26 - reach to the destination when the C4
72:29 - arrives but essentially both of these
72:32 - cars are also going to reach to the
72:33 - destination in around the same time and
72:36 - how much time will it take well
72:37 - currently this one is at position number
72:39 - six so it is going to take six more
72:41 - hours and we already spend 1 hours which
72:43 - means the C4 is going to take 7 hours to
72:47 - reach to the destination and because C5
72:50 - is behind that and it is able to catch
72:52 - up to the C4 it is also going to
72:54 - complete and reach to the destination in
72:56 - 7 hours so after 7 hours the second
72:59 - Fleet that would have reached to the
73:01 - destination would be the cars uh that we
73:04 - just saw that is the car C4 and also C5
73:08 - so they both will also reach to the
73:10 - destination in around the same time so
73:12 - this would be our second Fleet that is
73:14 - going to reach to the destination and
73:16 - now we already spend 7 hours which means
73:20 - after 7 hours this C3 would have been uh
73:23 - around here because because its speed is
73:26 - just 1 M hour so it would have covered
73:28 - the distance of 7 mil and then still it
73:31 - would have five more miles to go which
73:33 - means it would still take uh like around
73:36 - 12 hours to reach to their destination
73:38 - and in the end the C3 car would be the
73:41 - very final car that would reach to the
73:43 - destination and still this would also be
73:46 - considered a fleet in its own so over
73:49 - here we can see that actually we are
73:51 - getting 1 two and three fleets reaching
73:54 - to the destination
73:55 - so for this given input we need to three
73:58 - as the answer and this is the whole
74:01 - problem statement now I know
74:03 - understanding this problem statement
74:04 - take took us lot of time because there
74:06 - were a lot of moving paths and moving
74:08 - cars that we had to understand but
74:10 - honestly this is an awesome lead Cod
74:12 - problem because if any interviewer dares
74:14 - to give you this problem this is not
74:16 - very difficult to solve but it's very uh
74:19 - pecular for interviewer to explain also
74:22 - you will have to navigate through lot of
74:23 - different edge cases and then think
74:26 - about coming up with the optimal
74:30 - solution so now I'm not even going to be
74:33 - bothered to show you the Brute Force
74:35 - approach because that would be an ins
74:37 - insult to this beautiful problem so
74:39 - let's talk about the actual complete
74:42 - optimal solution that we can use in
74:45 - order to solve this problem and in order
74:47 - to generate the optimal solution we need
74:50 - to make some assumptions and we we need
74:53 - to do some calculations so what are some
74:55 - of the calculations we need to do number
74:58 - one thing that is most important is that
75:01 - for any particular car we will have to
75:04 - understand that how much time it takes
75:07 - to reach to the end that is number one
75:09 - thing and second thing is cars can only
75:12 - reach to the Target based on the current
75:15 - sequence locations they are present in
75:17 - so even though if we see the car numbers
75:19 - over here this C1 and C2 are based are
75:23 - located at the correct space but the C3
75:26 - is actually going to even though this is
75:28 - the third car this would this has to be
75:30 - the last car to reach to the end so
75:33 - number one thing we are going to do is
75:35 - we will try to find that how much time
75:37 - does it take for any single car to reach
75:39 - to the end we will try to store this
75:41 - information with the cars so we actually
75:43 - have couple of ways to store this we can
75:45 - either store it using a hashmap uh that
75:48 - would only make things more complicated
75:50 - because we don't need like a constant
75:52 - time access to that data and same thing
75:56 - can be achieved using a two-dimensional
75:58 - array as well so we will try to use it
76:00 - store it using two dimensional array
76:02 - okay so in the two-dimensional array we
76:04 - are going to store the information for a
76:07 - subsequent car and how much time does it
76:09 - take to reach to the end that is number
76:11 - one thing number two thing we are going
76:13 - to do is that we will actually sort
76:16 - these cars based on their positions so
76:19 - number one car in that is going to reach
76:21 - to the destination is going to be the
76:23 - car that is closest to the destination
76:26 - position so based on the position size
76:28 - we are also going to sort them and once
76:31 - we have that we would be able to
76:33 - identify the answer quite easily so now
76:35 - first let's try to understand that how
76:36 - do we actually calculate how much time
76:38 - does it take for any single car to reach
76:41 - to the destination and that is a very
76:43 - simple calculation all we need to do is
76:46 - we need to calculate the distance
76:48 - between the current position and the
76:50 - destination position and whatever this
76:53 - distance is we need to divide the speed
76:56 - by that distance and that would give us
76:58 - the time on that it that that particular
77:01 - car would take to reach to the Final
77:03 - Destination okay so now the idea is
77:06 - quite simple so let's just do that so
77:08 - for C1 currently we can see that this is
77:11 - located at position number 10 and it
77:13 - needs to reach to the position position
77:15 - number 12 which means the distance is
77:16 - two and the speed for C1 is also 2 m per
77:20 - hour which means it is going to take 1
77:22 - hour for C to reach to the destination
77:25 - same way for C2 it is also going to take
77:27 - 1 hour to reach to the destination same
77:29 - way for this C4 it is actually going to
77:33 - take 7 hours to reach to the destination
77:35 - because the difference between 5 and 12
77:37 - is 7 and the speed of C4 is 1 M hour
77:41 - same way for the C5 the dist the
77:44 - distance is also going to be 3 U 9 km uh
77:48 - sorry 9 miles and then the speed is
77:50 - three so it is only going to take 3
77:53 - hours to reach to the destination and
77:55 - last one is the C3 car so for C3 it's
77:58 - actually going to take 12 hours to reach
78:00 - to the destination now we have over this
78:03 - list ready now let's try to sort this
78:06 - given list based on the position of the
78:08 - cars which means once again C1 is at the
78:11 - correct position and C2 is also at the
78:13 - correct position both times are 1 hour
78:16 - and 1 hour then we have the car C4 and
78:20 - C5 so for the car C4 it is uh it is
78:24 - going to reach into the 7h hour mark and
78:26 - car C5 should reach in 3our marks if
78:30 - there were no cars ahead of it and the
78:33 - last one is the c0 car or uh I think C3
78:37 - car so C3 car is going to take 12 hours
78:40 - to reach to the destination okay so
78:43 - let's quickly do a re recap what we did
78:46 - we found out how much time does it take
78:48 - to reach to the destination then we
78:50 - sorted all of these cars based on the
78:54 - position
78:55 - where they are compared to the start to
78:58 - the Target location so the higher the
79:00 - position the first it is going to be
79:03 - inside our L list and in order to store
79:06 - this information we are going to be
79:07 - using a 2d array now after having this
79:10 - information it becomes very easy for us
79:13 - to solve this problem because all we
79:15 - need to do is we simply have to check
79:18 - because we know for sure that this has
79:20 - to be the first car to reach to the
79:22 - destination at any given moment moment
79:24 - we realize that the speed of this is
79:29 - actually lesser or equal to the speed of
79:33 - its subsequent car then we can conclude
79:35 - that both of these cars would reach to
79:38 - uh at the same time let me rephrase I
79:42 - use the word speed but the the correct
79:44 - word should have been time so if the
79:46 - time it takes for the C1 car to reach to
79:49 - the destination is 1 hour and we see
79:53 - that for C2 the time it takes is also 1
79:56 - hour which means C1 and C2 both are
79:59 - going to reach to the destination around
80:00 - the same time just in a scenario where
80:03 - C2 is just behind C1 so we can conclude
80:07 - that these two has to be one single
80:09 - Fleet so this becomes our one of The
80:12 - Fleets now in the second scenario we
80:15 - have the time it takes for C4 to reach
80:18 - to the to the destination as 7 hours and
80:21 - the time it takes for C5 to reach at the
80:24 - destination at 3 hours which means C5
80:27 - actually is much faster than C4 So
80:31 - eventually C5 would be close enough or
80:34 - just behind C4 before C4 actually
80:36 - reached to the destination let's try to
80:39 - once again understand using this plot
80:40 - because after the very first hour
80:43 - actually C5 and C4 would both be at the
80:45 - same place and how do we find out
80:49 - because we can see that the time it
80:50 - takes for both of them to reach to the
80:52 - destination so these two also has to be
80:56 - part of a simple Fleet now say this last
81:01 - for the C3 instead of this being 12
81:04 - maybe this also took 3 hours to reach to
81:07 - the destination then C3 would have also
81:10 - been part of this Fleet because C3 would
81:12 - reach to the Destination 3 in 3 hours C5
81:15 - would reach in 3 hours and C C4 is going
81:18 - to block both of them and cause both of
81:21 - these cars to reach at 7h hour mark
81:23 - because C4 is ahead compared to C5 and
81:25 - C3 so this would have been part of this
81:28 - Fleet as well but in this scenario
81:30 - because the time C3 takes to reach to
81:33 - the destination is actually greater than
81:36 - the previous Fleet the largest value in
81:38 - the previous Fleet then we can conclude
81:41 - that this C3 is not going to be able to
81:43 - catch up to this C4 and C5 Fleet so this
81:47 - is going to be our second Fleet and in
81:50 - the end the C3 is going to be our third
81:52 - Fleet so that that's all you need to do
81:56 - to solve this problem once we do have
81:58 - the comp the sorted version of
82:01 - subsequent cars with the time it takes
82:03 - to reach to the destination we can
82:05 - actually very easily compute because for
82:08 - every single Fleet all we need to check
82:10 - is that what is the longest time it
82:13 - takes uh for those Fleet to reach to the
82:17 - destination so in this case for the C4
82:19 - and C5 it's going to take 7 hours to
82:22 - reach to the destination so if this
82:24 - number would have been anything less
82:26 - than seven then it would have been part
82:28 - of this uh C4 Fleet but because it's not
82:32 - less than 7 so this has to be a fleet on
82:34 - its own and uh that's it that's what we
82:37 - need to do and this is the whole
82:39 - solution so now you see how beautiful
82:42 - this problem is and how awesome the
82:43 - solution is like that's why this is
82:45 - really one of my favorite questions
82:48 - because it's a combination of math and
82:50 - data structures and then how do you make
82:52 - things more efficiently and how can you
82:54 - think about uh different scenarios and
82:56 - different mathematical equations and
82:58 - stuff like that okay so now let's try to
83:01 - understand the time complexity it is
83:03 - going to be bigo of n because we are
83:05 - going to be simply iterating over the
83:06 - given input array bunch of times but
83:09 - still it is going to be big off n but
83:11 - you forgot one critical thing that is we
83:14 - will also have to do the Sorting
83:16 - operation and that is actually going to
83:18 - cause our time complexity to be big of n
83:20 - log n and if we see space complexity
83:24 - well for the space complexity is
83:25 - actually going to be big of n Square
83:27 - because we are using a 2d array to store
83:29 - the information of the cars uh to its
83:31 - subsequent time it takes to reach to the
83:33 - destination overall this is also a very
83:36 - good time and space complexity now let
83:38 - me know in the comments if you want also
83:40 - want to see a solution using a monotonic
83:43 - stack because this is pretty popular
83:45 - problem for that so if you want I can
83:48 - also show a solution with that but I
83:50 - think this is a good enough solution for
83:52 - your interview your interviewer is going
83:54 - to be more than happy and now let's just
83:56 - quickly see the coding for this
84:01 - one so the coding solution is quite
84:03 - simple first of all we create an integer
84:06 - n uh to store the length of the given
84:09 - input array and then we initialize our
84:11 - 2D array that we talked about where we
84:14 - are going to store the information about
84:15 - cars and its subsequent time it takes to
84:18 - reach to the end then we are simply
84:20 - going to iterate over the given input
84:22 - array and we are going to pop calate our
84:25 - cars 2D array that we just created where
84:28 - we are going to Mark the positions of
84:30 - the car and also we are going to
84:31 - calculate that how much time does any
84:33 - single car it takes to reach to the
84:35 - destination then we are going to do the
84:37 - most important operation where we are
84:39 - going to sort the given cars based on
84:42 - the current positions of the given cars
84:46 - once we have that now it is very
84:48 - convenient to solve this problem we are
84:50 - going to initialize a counter zero that
84:52 - this is going to calculate the fleet on
84:55 - what time it is going to arrive and then
84:57 - we are going to have another variable
84:58 - where it is going to keep track that
85:00 - what was the previous time for the car
85:02 - to reach to the end then we are simply
85:04 - going to iterate over the given input uh
85:06 - 2D array cars and we are going to check
85:09 - that if the value of any particular
85:12 - given car is actually greater than the
85:15 - previous time which means that is a new
85:18 - Fleet being created so we are simply
85:20 - going to create a new Fleet or add the
85:23 - value to the counter and also we are
85:26 - also going to Mark the previous time of
85:28 - the last car that just came in and
85:31 - that's it in the end we can simply
85:32 - return this counter that we have created
85:34 - that was keeping track of all every
85:36 - single Fleet and now let's try to run
85:38 - this
85:53 - code
85:54 - okay seems like our solution is working
85:56 - as expected let's submit this
86:00 - code and our code runs decently
86:02 - efficiently in terms of time complexity
86:04 - extremely efficiently in terms of space
86:06 - complexity and once again the code is
86:08 - present inside our GitHub repository so
86:10 - you can go and check it out from there
86:12 - thank
86:13 - [Music]
86:16 - you hello friends hope you're having a
86:18 - fantastic day today so now we are going
86:21 - to solve Facebook's most asked question
86:24 - this question has literally been asked
86:27 - 142 times at Facebook so this is a very
86:30 - popular lead code interview question and
86:32 - without any delay let's get started okay
86:35 - so the lead code problem we are solving
86:37 - today is called minimum remove to make
86:39 - valid parenthesis book and we can see
86:41 - that this is a lead code medium problem
86:43 - and also a very well-like problem now
86:46 - the problem statement is quite simple
86:48 - that we are given a string that contains
86:50 - bunch of different opening and closing
86:52 - parentheses and low lowercase English
86:55 - characters now at any given moment if we
86:58 - identify that the parentheses are in
87:00 - correct sequence like the same number of
87:03 - parentheses that are opened are also
87:05 - closed then we call them valid but if we
87:07 - identified some invalid parentheses then
87:10 - we simply have to remove them so let's
87:12 - try to understand this with an example
87:14 - it would make much more sense and we can
87:15 - see that bunch of the parentheses are
87:18 - actually at the wrong position first one
87:21 - we can see over here where we have a
87:22 - closing parenthesis but we don't have
87:24 - any opening parenthesis somewhere here
87:26 - before which means this is an invalid
87:29 - parenthesis sa same way uh this is also
87:32 - an invalid closing parenthesis because
87:35 - though this pair of parentheses are
87:37 - valid this is not valid and same way we
87:40 - have an additional opening parenthesis
87:42 - so in this case we have three
87:44 - parentheses that that are invalid so if
87:47 - we simply get rid of these three
87:49 - parentheses that we just identify then
87:51 - we would have our query that will look
87:54 - like this and now we can see that uh
87:57 - this entire sequence is actually valid
88:00 - where we have uh two pairs of opening
88:03 - and closing parentheses so they are
88:05 - valid and also we have a bunch of
88:06 - different smaller English language
88:08 - characters and they are also valid so we
88:11 - simply have to identify that which are
88:13 - the index positions that we need to
88:15 - remove uh in order to make a valid
88:18 - parenthesis pair or a valid query okay
88:22 - so let's simply see The Brute Force
88:24 - approach very
88:27 - quickly Ro Force approach is very simple
88:30 - uh for any query that we are given we
88:33 - can all we need to do is that we simply
88:36 - go over every single character and the
88:39 - moment we identified either an opening
88:41 - or closing parenthesis so in this case
88:43 - we identify a closing parenthesis so
88:45 - once again we would go back and try to
88:47 - find an opening parenthesis if we cannot
88:50 - find it we identified that this one is
88:51 - invalid and then we move forward so same
88:54 - way the moment we identify an opening
88:56 - parenthesis once again we would move
88:58 - forward to try to find a closing
89:00 - parenthesis that is going to match up
89:02 - with that if we find it that's great if
89:04 - we don't find it then in that case we
89:06 - would deem that parenthesis as invalid
89:09 - and if we keep on moving forward in that
89:11 - direction we would eventually find the
89:13 - answer but thing is there is lot of back
89:15 - and forth we are doing and essentially
89:17 - for every single character in the worst
89:19 - case we might have to do like big of n
89:21 - Square work in order to solve this
89:23 - problem which is lot of work needs to be
89:25 - done just to solve this problem and this
89:28 - is actually a very simple problem to
89:30 - solve so now let's quickly see the
89:32 - optimal solution for this
89:36 - one so now let's try to see that what
89:38 - would be the optimal solution to solve
89:40 - this problem and for that we will have
89:42 - to understand just couple of things that
89:44 - what are the exact checks we are making
89:47 - number one thing we are checking is that
89:48 - at any given moment we identify that any
89:51 - particular opening parenthesis exist
89:54 - this can only be valid if further down
89:57 - the road we identify that there exist
89:59 - some closing parentheses okay and same
90:02 - way if we identify some closing
90:05 - parentheses this can only be valid if
90:08 - there exist a subsequent opening
90:11 - parenthesis presented in counterpart
90:14 - towards this one if there does not exist
90:16 - any which means this is one of the
90:18 - invalid ones so using these two
90:21 - conditions what we need to do is for
90:23 - every single opening parenthesis we need
90:25 - to keep it stored somewhere that there
90:27 - might be a closing parenthesis somewhere
90:29 - down the line and the moment we
90:31 - identified some closing parenthesis we
90:33 - will have to check that whether there
90:35 - exist an opening parenthesis immediately
90:37 - before that that is going to match with
90:39 - it so a very good data structure in this
90:43 - case would be stack to solve this
90:45 - problem why because stack has the
90:47 - property of last in first out that we
90:50 - are going to use at at its maximum to
90:53 - solve this problem and let's quickly
90:55 - understand that what I mean now the
90:57 - thing is through stack we would be we
91:00 - would be able to tell that which uh
91:02 - parenthesis is invalid but the thing is
91:05 - we would still need to recreate this
91:07 - entire string in order to solve this
91:09 - problem so what we can do is the moment
91:12 - through stack we identify that any
91:13 - particular indices is invalid whether
91:16 - opening or closing parenthesis we can
91:19 - just simply create maybe like a hash set
91:21 - or some other data structure where we we
91:23 - are simply going to keep track of all
91:25 - the variables or all the index positions
91:28 - that are invalid this is this will help
91:30 - us to build the rebuild the entire
91:32 - string after we find out all the invalid
91:35 - parenthesis okay and the logic we are
91:38 - going to apply is that for a stack uh if
91:41 - the moment we identify that there exist
91:44 - an opening parenthesis we are going to
91:46 - push the opening parenthesis down the
91:48 - stack the moment we identify a closing
91:50 - parenthesis we are going to check inside
91:53 - the stack that whether there exist an
91:55 - opening parenthesis to counter this
91:58 - closing parenthesis if it does we are
92:00 - simply going to pop that parenthesis out
92:03 - so marking that this entire pair is
92:05 - going to be considered valid now for
92:07 - some PEC case we identify that there
92:10 - exists a closing parenthesis but there
92:12 - is no opening parenthesis then this
92:14 - needs to go to the set because this is
92:16 - an invalid entry and using this logic we
92:19 - would be able to solve this problem
92:20 - quite easily so let's quickly see the
92:22 - solution that I'm proposing okay and
92:24 - also let me quickly Mark the all the
92:28 - index positions and also initialize a
92:30 - hash set where we are going to store all
92:32 - the indices okay so very first element
92:34 - is a lowercase English letter element so
92:37 - we will just move forward now we
92:39 - identified a closing parenthesis so now
92:42 - the moment we identify a closing
92:43 - parenthesis we will need to check inside
92:45 - our stack that does there exist an
92:47 - opening parenthesis currently the stack
92:49 - is empty because the stack is empty this
92:52 - is an invalid position so so we are
92:54 - going to Mark the index position inside
92:56 - our set as one next we will move on
92:59 - towards the next element this one is
93:00 - also a lowercase English character so we
93:02 - move forward this is an opening
93:04 - parenthesis so opening parenthesis has
93:06 - to go into the stack so we are going to
93:08 - Mark its index location inside the stack
93:11 - so we identified value number three over
93:13 - here okay next is also a random
93:15 - character now this one is also a closing
93:18 - parenthesis so closing parenthesis we
93:20 - check that whether in the stack do we
93:22 - have do we have any entry and yes we do
93:24 - so we will actually pop this element out
93:26 - so we pop this element out currently
93:28 - stack is empty now because stack is
93:30 - empty we also identified that there
93:32 - exist an opening parenthesis so or sorry
93:35 - a closing parenthesis and we once again
93:37 - needs to check into the stack but stag
93:38 - is empty which means this is also an
93:40 - invalid character so we are going to
93:42 - mark five over here we get once again we
93:44 - can ignore this one now this one is an
93:46 - opening parenthesis so we enter over
93:48 - here once again opening parenthesis so
93:50 - once again we enter into the stack we
93:52 - can ignore this one now this 10 is also
93:55 - a closing parenthesis so for the closing
93:57 - parenthesis we can pop one value out so
93:59 - we pop eight out uh from our stack but
94:02 - the thing is in our stack we still have
94:04 - value number seven left which means that
94:08 - this value number seven is also an
94:10 - invalid stack because we we just run out
94:12 - of all the characters in inside the
94:14 - string so we have an extra opening
94:16 - opening parenthesis as well that we need
94:18 - to remove so we can mark this value and
94:20 - now if we remove this character one uh
94:24 - five and seven from our existing string
94:27 - we would get our string that looks like
94:29 - this where the values are going to be
94:32 - valid and this is what we need to return
94:34 - return in the answer so basically we can
94:38 - very easily solve this problem using the
94:39 - stack if we see time and space
94:41 - complexity time complexity is going to
94:43 - be bigo of n where n is the number of
94:45 - characters that are present inside the
94:47 - stack and space complexity is simply
94:49 - going to be bigo of n as well because we
94:51 - are using an extra stack and also an
94:54 - extra hash set to store bunch of
94:56 - different values okay so now let's
94:58 - quickly see the coding solution for this
95:02 - one so coding solution for this one is
95:05 - quite straightforward first we
95:06 - initialize our hash set and our stack
95:09 - then we simply iterate over the given
95:12 - string uh and for every single character
95:15 - we first check that if the given
95:16 - character is an opening parenthesis we
95:19 - push it down the stack if it is a
95:21 - closing parenthesis and if the stack is
95:24 - empty which means we identified an
95:26 - unexpected closing parenthesis so we
95:29 - simply remove add that uh character to
95:32 - our remove indices hash set that we have
95:35 - created add its index position uh and if
95:37 - that is not the case we simply pop the
95:40 - element out of the stack because stack
95:42 - already has an opening parenthesis this
95:43 - is what it means now in the end after
95:47 - this uh particular Loop has ended we
95:49 - would have taken care of all the
95:51 - unexpected closing parentheses that were
95:53 - present present but we still have to
95:55 - take care of the opening parenthesis and
95:56 - they would still be present as unmatch
95:59 - opening parenthesis inside the stack so
96:01 - any single element that is present
96:03 - inside the stack we simply uh take them
96:05 - out and work on and add them to our
96:08 - headset as well in the end we simply
96:10 - need to build a string in order to
96:12 - generate the answer so for that we
96:13 - remove all every single character that
96:15 - are present inside our head set uh and
96:18 - then just create and upend the string
96:20 - that is that was already given to us in
96:22 - the input and then we simp return that
96:24 - as the answer so this is the whole
96:25 - solution let's try to run this
96:31 - code and our code works as expected so
96:35 - no issues with that let's submit this
96:39 - code and our solution is pretty fast
96:41 - compared to a lot of other Solutions
96:43 - once again the coding solution is
96:45 - present inside the description of the
96:47 - GitHub link that I have provided below
96:49 - this video so you can go and check it
96:50 - out from there thank
96:52 - you
96:55 - this is a lead code easy problem and
96:56 - also one of the most like problems on
96:58 - lead code uh and that is because this
97:00 - problem actually solves one of the very
97:02 - real life application where a compiler
97:04 - has to check that whether the code has
97:06 - valid parentheses or not and so that's
97:08 - why a lot of companies like to ask this
97:10 - problem as an interview question uh if
97:12 - we understand the problem basically we
97:13 - are given a string s that contains just
97:15 - these three types of parentheses opening
97:17 - parenthesis and closing parenthesis and
97:20 - we need to determine that if the given
97:22 - input is actually a value valid input or
97:24 - not we are also given the definition
97:25 - that what counts as a valid input that
97:27 - if the opening brackets are closed by
97:30 - the same type of closing brackets and
97:32 - also we are told that the opening
97:33 - brackets must be closed in the correct
97:35 - order so let's try to understand this
97:37 - with some examples over here I have
97:38 - drawn a bunch of different uh potential
97:41 - or examples and we will see that if they
97:42 - are valid or not so first of all if we
97:44 - see this example we know that okay we
97:46 - have two closing two opening brackets
97:48 - and we have two closing brackets we can
97:50 - consider this as a valid string so I'm
97:51 - just noting it it as V now again in this
97:54 - case we have two different types of
97:56 - opening brackets and we have two
97:57 - different time types of closing brackets
97:59 - so this is also valid string now in this
98:02 - case uh this is an opening bracket this
98:04 - is an opening bracket we have
98:05 - corresponding closing brackets again we
98:07 - have opening and closing brackets and
98:08 - again we have opening and closing
98:10 - brackets so everything is in order and
98:11 - the same kind of brackets are opened and
98:13 - correct in proper shape and size so we
98:16 - can consider this also as a valid format
98:19 - now if we can come to this example this
98:22 - is an opening bracket this is also an
98:23 - opening bracket but we only have a
98:25 - closing bracket for this original
98:26 - opening bracket so we can consider this
98:28 - as invalid option so we get an idea why
98:31 - it is invalid in this case we have three
98:33 - opening brackets and only one closing
98:34 - bracket so again this is an invalid uh
98:37 - string and in this case actually if we
98:39 - see the number of opening brackets and
98:41 - number of closing brackets they are
98:42 - actually same so we have one opening
98:44 - bracket and one closing bracket again
98:45 - one opening bracket and one type of
98:47 - closing bracket but this is still
98:49 - invalid why it is invalid because this
98:51 - bracket this curly bracket bracket is
98:53 - actually opened before this particular
98:56 - round bracket so that's why it has to be
98:58 - closed before this round bracket closes
99:00 - and in this case this round bracket
99:02 - actually closes first before this curly
99:04 - bracket is being closed so this is very
99:06 - important property that we will have to
99:08 - keep track of and that is why we are
99:09 - told that we need to keep track of the
99:11 - order in which they are opened and
99:14 - closed and then only we can determine
99:16 - that whether they are valid or not so
99:17 - this is also an invalid uh formula so
99:21 - let's see that what would be the
99:22 - potential solution what
99:24 - so let's start from the very simple
99:26 - example and see that what would be the
99:28 - intuition behind building a solution
99:30 - suppose we are given an example that
99:32 - looks like this where we are given all
99:34 - of the brackets that are of the same
99:35 - kind and we are given some opening
99:37 - brackets and some closing brackets well
99:38 - we can clearly see that this is a valid
99:40 - approach and how we can determine is
99:42 - that we can actually create a counter
99:45 - and what this counter does it that any
99:47 - at any given moment we identify an
99:49 - opening bracket we are actually going to
99:50 - increase the value in this counter and
99:52 - at any given moment if we encounter a
99:54 - closing bracket we are actually going to
99:55 - decrease the value in this counter and
99:58 - at the end we have to check that whether
99:59 - the value inside this counter if that is
100:01 - equal to zero which means we can
100:02 - determine that the same number of
100:04 - opening bracket and closing brackets are
100:05 - present and then we can say that the
100:07 - string is actually valid if that is not
100:09 - the case we can say it is invalid so if
100:11 - we see that in action first of all we
100:12 - have three opening brackets so we will
100:14 - increment the value of this counter
100:16 - three times and if we do that we will
100:17 - get the counter value to be at three
100:19 - again now we identify a closing bracket
100:21 - so now this value from three becomes two
100:24 - again we identify two more closing
100:25 - brackets so again it go it gets
100:27 - decreased two more times and then we get
100:29 - the final counter value to be zero and
100:31 - because we get this value as zero we can
100:34 - say that okay this string is actually
100:35 - valid string and the same number of
100:37 - opening and closing brackets are
100:39 - happening so this is one way to identify
100:42 - a solution but in this case the
100:44 - complexity is actually very simple why
100:46 - because we are only using one kind of
100:48 - opening and closing brackets in our
100:50 - original problem we problem we are
100:52 - actually told that there are three
100:54 - different kinds of opening and closing
100:56 - brackets and we will have to keep track
100:58 - of them also we need to keep track that
101:00 - in what order they were opened and
101:02 - closed and that order also has to be
101:04 - maintained so it is not just as simple
101:06 - as keeping track of counter that we
101:08 - create three different counters for all
101:10 - single typ one of them and then we see
101:12 - that at the end whether this value is
101:14 - zero or not we also have to keep track
101:15 - of that what is the order they were
101:17 - opened in and they were closed in now
101:20 - for the optimal solution we know we need
101:21 - to take care of two things first thing
101:23 - is we need to check that whether the
101:25 - opening and closing number of brackets
101:26 - are same for each three different types
101:28 - of parentheses or not second thing we
101:30 - have to take care is that what is the
101:32 - order in which they are opened and
101:34 - closed so first let's tackle the first
101:36 - problem we know that for every single
101:38 - opening bracket there has to be a
101:39 - closing bracket and they are always in
101:41 - pair so now to quickly look them up we
101:43 - are actually going to use a
101:44 - hashmap now inside our hashmap we are
101:47 - actually going to have all of these
101:48 - closing brackets as the keys and their
101:51 - opening brackets as corresponding values
101:53 - so we are going to have three
101:55 - entries now we have to take take care of
101:57 - their order and number of occurrences so
102:00 - the idea is we are actually going to use
102:02 - another data structure called stack and
102:04 - the stack is actually going to be very
102:06 - helpful to us so let's try to understand
102:08 - this with an example that how we are
102:10 - going to use a stack over here suppose
102:12 - we are given an input that looks like
102:14 - this okay so I'm going to show you two
102:15 - examples um on how we are going to solve
102:18 - this problem so first let's take this
102:19 - example and the idea is that at any
102:22 - given moment we identify an Open Bracket
102:24 - we are going to add that value inside
102:26 - our stack and at any moment we are and
102:28 - going to encounter a closing bracket we
102:30 - are going to pop a value on from the
102:32 - stack and then we are going to see that
102:34 - the whatever the value we popped out if
102:36 - that is the same value that is for any
102:39 - given uh hashmap value we have inside
102:42 - the string for this that particular
102:43 - closing bracket so let's see that in the
102:46 - action first of all we identify these
102:47 - three opening brackets so we are going
102:49 - to add all of the entries inside our St
102:51 - so first we will add a curly bracket
102:52 - then we will add uh these two brackets
102:54 - once we are done with this one now we
102:56 - have a closing bracket our hand the
102:58 - moment we identify a closing bracket
102:59 - remember we will have to pop the value
103:00 - out of our stack so we are going to pop
103:02 - the value out of the stack and the value
103:04 - we have popped out is actually this one
103:06 - now for this closing bracket we are
103:08 - going to see that what is the value of
103:10 - that bracket inside our hashmap and the
103:12 - value of that bracket is also like this
103:15 - and we are going to compare these two
103:17 - elements that whatever we took out from
103:18 - the stack and whatever we got from this
103:20 - hashmap and both are same so because
103:22 - both are same we can say that okay we
103:23 - are good so far and now so far we have
103:25 - actually uh taken care of these four
103:27 - elements and now we are on this element
103:29 - again this is also a closing bracket so
103:31 - because this is also closing bracket we
103:33 - will have to pop a value out and we are
103:35 - going if we pop a value out we will get
103:36 - a value that looks like this where that
103:38 - we are arrived from our stack and now we
103:41 - are going to check that for this
103:42 - particular bracket that we were
103:43 - iterating over what is the corresponding
103:45 - value inside the hash map so the key is
103:47 - this one and the corresponding value is
103:49 - this one so the value we found from our
103:51 - hashmap is also this one and they both
103:53 - are same so because they both are same
103:55 - we can say that okay we are good up
103:56 - until this point now we are iterating
103:58 - over this curly bracket so we again pop
104:00 - and also I have forgot to uh delete this
104:03 - value now again we pop out a value from
104:06 - our stack so now we don't have this
104:08 - value over here and we have a bracket
104:09 - that looks like this again for this
104:10 - closing bracket the value inside of our
104:12 - hash map is also an opening curly
104:14 - bracket and both are same so we are good
104:16 - up until this point now we are only up
104:18 - to last two characters so this is also
104:20 - an opening bracket the moment we
104:21 - identify opening bracket we will add an
104:23 - entry to our stack and now this is a
104:25 - closing bracket so again we will pop
104:27 - this entry out after popping this entry
104:29 - out so this is the value we popped out
104:31 - from the stack and then we will compare
104:32 - from our hashmap so the value is this
104:34 - one and both are same so we are now we
104:37 - are at the end of our string and because
104:39 - we are at the end of our string we are
104:40 - going to check that whether inside the
104:41 - stack we have entry any entry or not we
104:43 - don't have any entry so we can return
104:45 - true in this case and we can say that
104:47 - the given string is actually valid and
104:49 - this would be the answer now uh let's
104:52 - take one more example exle where the
104:53 - string is not valid and see that what we
104:55 - are going to encounter in this case
104:57 - suppose we are given a string that looks
104:58 - like this so in this case we have two
105:01 - opening brackets and one closing bracket
105:03 - so first of all we identify that this is
105:05 - the opening bracket uh we are going to
105:07 - add an entry over here again we
105:09 - encounter an opening bracket we are
105:10 - going to add an entry over here now we
105:12 - encounter a closing bracket the moment
105:13 - we encounter a closing bracket we are
105:15 - actually going to pop out the value from
105:17 - our SEC and the value we popped out is
105:19 - actually a curly opening bracket now for
105:21 - this closing bracket
105:23 - we actually have a corresponding value
105:25 - inside our hash map that looks like this
105:27 - one now these two are actually not same
105:29 - so the moment we identify that these two
105:31 - are not same we can immediately return
105:33 - that this string is actually invalid and
105:36 - the parentheses are not in correct order
105:38 - so we we are done with this one time
105:39 - complexity is actually going to be big
105:41 - go of n where the N is the number of
105:44 - entries present inside the string and
105:45 - even in terms of space complexity
105:47 - because we are using a stack and hashmap
105:49 - but we don't care about hashmap because
105:51 - it has finite number of ENT but for the
105:53 - stack the values will be dependent on
105:56 - big of n as well on the number of
105:59 - entries present inside the string now
106:01 - let's move on to
106:05 - coding so first of all we are going to
106:07 - initialize our hashmap and inside the
106:09 - hashmap we are going to store the values
106:11 - for three different brackets that we are
106:15 - given we are done with this one now we
106:17 - are going to initialize our stack and we
106:19 - are going to name it as stack as well
106:22 - and now we are going to run a for Loop
106:23 - across the given
106:25 - string so first of all we are going to
106:27 - initialize a character C and that is to
106:29 - keep track of whatever the character we
106:32 - are looking over inside the given
106:33 - string now we are going to check that if
106:36 - the current bracket is opening bracket
106:37 - or closing bracket which means that if
106:39 - the key value is present inside this
106:41 - mapping bracket then we can Define that
106:43 - it is a closing bracket if not then we
106:45 - can Define it as an opening bracket so
106:48 - if the value is not present inside this
106:50 - ma bracket
106:51 - key
106:54 - which means that we will have to uh push
106:56 - the current value inside the stack if
106:59 - not which means that the value is
107:01 - actually a closing bracket and then
107:03 - first of all we are going to pop the
107:04 - value out of our stack and then we are
107:07 - going to compare it with whatever the
107:09 - value pair inside the map bracket we
107:11 - have and if the stack is empty we can
107:13 - return false
107:15 - immediately so in the lse condition we
107:17 - check that if the stack is empty we can
107:19 - return false immediately if not we are
107:21 - going to pop out of the pop out a value
107:24 - from the stack and we are going to name
107:25 - it as top element and now we are going
107:27 - to check that whether that is the same
107:29 - value that is present for the map
107:31 - bracket value key and if the values are
107:34 - not same we can return return false
107:35 - immediately as well and if that is not
107:38 - the case eventually if we get out of the
107:39 - loop then we will have to check that
107:41 - whether the given stack is empty or not
107:42 - if the stack is empty we can return
107:44 - return true or else we can return
107:46 - false let's try to run this
107:49 - code okay seems like our code is working
107:52 - as expect expected let's submit the
107:55 - code and our solution is actually pretty
107:57 - fast compared to a lot of other
107:58 - Solutions uh so I would be posting this
108:01 - in the comments so you can check it out
108:02 - from there thank
108:02 - [Music]
108:05 - you hello friends hope you're having a
108:07 - fantastic day today so once again we are
108:09 - going to do an awesome lead code problem
108:11 - that is extremely popular at all sorts
108:14 - of it companies so without any delay
108:16 - let's get started so the lead code
108:18 - problem we are going to solve today is
108:20 - called largest rectangle in a histogram
108:22 - this is a lead code hard problem and
108:24 - also an extremely well-like problem now
108:26 - the statement is quite simple and
108:27 - straightforward we are given an array of
108:30 - integer called Heights that represent
108:32 - the histograms bar height and we are
108:34 - also told that the width of every single
108:37 - bar is one now we need to return the
108:40 - area of the largest rectangle that we
108:42 - can make inside this given histogram so
108:46 - this is all we need to return and now
108:47 - let's try to understand this with an
108:49 - example so for this we can make a
108:51 - rectangle that looks like this now the
108:53 - area of this rectangle is going to be
108:55 - two because the width of this portion is
108:58 - 1 and the height of this portion is two
109:00 - so 2 * 1 is going to be two so same way
109:03 - there are multiple different options we
109:04 - can have in order to generate the area
109:06 - but we need to find the maximum area and
109:09 - in this case the answer would be
109:11 - retrived using these values where if we
109:14 - make a rectangle like this using these
109:16 - two bars so now in this case the area is
109:20 - actually going to be 10 why because the
109:22 - height of this portion is five and for
109:25 - this one the width is 2 so 2 * 5 is
109:28 - going to be 10 so this is what we need
109:30 - to find and this is what we need to
109:34 - return so Brute Force approach is
109:36 - actually quite straightforward and very
109:38 - simple now one thing we can do is that
109:41 - we can take this one single rectangle uh
109:44 - starting at position zero and then we
109:46 - can see that what are every single
109:49 - possible areas we can make so one area
109:51 - would be like this second area would be
109:54 - like this the third area would be
109:57 - something like this uh fourth area would
110:00 - be something like this and so on and so
110:02 - forth and eventually we do all every
110:05 - single possible combination uh based on
110:08 - every single position of the given
110:10 - rectangle bar height and then eventually
110:13 - we would find a solution like this that
110:15 - contains the most optimal approach and
110:18 - this solution would work fine we would
110:20 - be able to eventually find the answer
110:22 - but the this is going to work in big of
110:24 - n Square time because at every single
110:26 - time we are doing lot of extra and
110:28 - overhead
110:30 - work so what is the most common thing we
110:33 - can imagine well number one observation
110:36 - we can make is because we can see that
110:38 - the height for this zeroth index is two
110:41 - at the moment but the moment we want to
110:44 - consider this first index as in
110:47 - combination with this two then the
110:49 - maximum height we can imagine is only
110:52 - going to to be able to one which means
110:54 - we are only at the higher height until
110:57 - we encounter a height that is lower than
111:00 - our current height and whenever that
111:02 - happens we will have to start
111:03 - considering the lower height and we need
111:06 - to understand couple of things if we
111:08 - want to calculate the area we need two
111:11 - items first item is the height so we
111:14 - already know that which height are we
111:16 - going to consider based on the lower
111:19 - height compared to all the other
111:20 - possible Heights that is uh number one
111:22 - observation second observation is we
111:24 - need to consider the width so so width
111:27 - we can simply calculate based on the
111:29 - current index position where we have or
111:32 - we can also keep track of that where did
111:35 - that height started existing that in
111:39 - terms of finding the right side boundary
111:41 - of any particular rectangle we can only
111:44 - find it until we find a lower height
111:47 - that reaches so there are actually three
111:50 - examples we can see very easily first
111:53 - example is at this position number two
111:55 - or this uh initial first position where
111:58 - the current height is two and the
112:00 - current height is located position
112:02 - number zero but the moment we try to
112:04 - consider the next element we will have
112:06 - to get rid of this height too because
112:07 - now it is no longer in the existence
112:09 - which means the maximum area we are
112:11 - being able to generate using this bar
112:13 - two is only going to be two okay now
112:16 - next thing another example is we just
112:20 - saw with the value number five that with
112:22 - value number five we can only say that
112:25 - we can use rectangle five or bar five
112:28 - until we reach to this index position
112:30 - number four and then so which means
112:33 - maximum area that this bar five can make
112:35 - is going to be of width two and height
112:38 - five so total is going to be 10 same way
112:41 - for the six six comes into the existence
112:45 - at index number three but since the
112:47 - height at index number four is actually
112:50 - lesser than the index number three which
112:51 - means this six only remains in existence
112:55 - just for one single bar so the maximum
112:57 - area we can make over here is all is
113:00 - only going to be of uh size six and this
113:03 - is the whole logic this is the whole
113:04 - meat of the solution now after
113:07 - understanding this we can actually make
113:09 - a suboptimal solution using the same
113:13 - very simple approach and then we will
113:14 - try to improve upon that solution so the
113:17 - sub suboptimal solution that I'm
113:19 - proposing is that at every single
113:21 - position we identify that what its right
113:24 - side boundary is and what its left side
113:27 - left side boundary is so what is the
113:29 - maximum height and width we can make and
113:32 - based on that we can do all sorts of
113:34 - calculations and then find the solutions
113:36 - very quickly so let's try to see this
113:38 - solution in exist in
113:40 - action the idea is at this position the
113:43 - maximum left side height we can make is
113:45 - to the maximum right side height we can
113:47 - make is also going the maximum width we
113:50 - are able to achieve is one which means
113:51 - the maximum area we can generate is only
113:54 - going to be two for this position number
113:56 - one the maximum width we are able to
113:59 - achieve is going to be six because this
114:01 - one remains in existence throughout this
114:03 - whole process and the maximum height we
114:06 - can achieve is only going to be one so
114:08 - over here maximum area we can make is
114:10 - only going to be six now at this five
114:13 - the maximum left side we can go is only
114:16 - up to 2 because it starts at position
114:19 - two the maximum in terms of right we can
114:21 - go is only up until position four or
114:24 - before position four so up to two and
114:27 - three so width is going to be two so
114:28 - over here we can make the area 10 for
114:31 - this height six we can only make the
114:34 - maximum height as six same way at this
114:36 - position number two the maximum we can
114:39 - make is actually going to be this much
114:41 - where currently the width is going to be
114:44 - uh four and the height is going to be
114:46 - two so maximum area we are able to
114:48 - generate is eight and same way at this
114:51 - three the max maximum we are able to
114:53 - generate is simply going to be uh just
114:57 - just this one because one before that is
115:00 - actually in the Lesser height so we can
115:02 - maximum area we can make using only or
115:05 - or the entire height of this area is
115:07 - going to be three and in the end we can
115:09 - simply return return 10 as the answer so
115:12 - what we did is for every single element
115:14 - we try to see that what is the left
115:16 - limit what is the right limit and what
115:18 - is the total area we are able to
115:19 - generate and then we can very easily
115:21 - store the answer now this solution would
115:24 - just be good if you provide this
115:27 - solution in an interview it might even
115:29 - work but the thing is there exist a
115:31 - better solution where if we just use
115:34 - stack to keep track that what is the
115:37 - current index position and until what
115:40 - previous index positions we are
115:42 - maintaining that height then we can very
115:45 - easily solve this
115:47 - problem why we need to use the stack
115:50 - because think about it for every single
115:52 - position we are only going to have that
115:55 - position in existence until we find
115:58 - another bar with a lower height which
116:00 - means the moment we find another bar
116:02 - with a lower height we can actually go
116:05 - back to the elements that are already
116:07 - present inside the stack with the higher
116:09 - height and calculate the area that's it
116:13 - that is the whole logic so now let's try
116:15 - to see the solution I'm proposing in
116:17 - action so now let's just quickly
116:20 - initiate our stack now inside the stack
116:23 - we know that this is going to operate in
116:25 - the in terms of last in first out
116:29 - principle and one the other thing is we
116:32 - can actually keep track of the bar
116:34 - Heights but then we would also have to
116:36 - find that what was the initial position
116:38 - of that this particular value so rather
116:40 - than a better approach is that we
116:42 - actually store the index values and
116:44 - using the index values we can quickly
116:46 - look up that what has been the bar
116:48 - height at that position in big go of one
116:50 - time because we already know the index
116:51 - position
116:52 - and then we would be able to also
116:54 - calculate the width depending on the
116:56 - current index position and the existing
116:59 - index position inside the stack so let's
117:01 - try to see the solution in action so
117:04 - initially stack is empty okay and we are
117:07 - also going to have an a variable where
117:09 - we are going to store the area so let's
117:11 - just mark this one as Max Max area that
117:13 - we have been able to calculate so far
117:15 - okay so initially stack is empty now we
117:18 - are at this index position number zero
117:20 - so we add index position 0 inside our
117:22 - stack okay and currently we know that
117:25 - this height is two now next thing is we
117:28 - iterate over to the next element and we
117:30 - identify that currently we are at index
117:33 - position one so the height at index
117:35 - position is actually less than the
117:38 - height we currently have on the element
117:40 - that is already present inside the stack
117:42 - which means this position of this
117:46 - element two is no longer relevant
117:48 - because we found out a value that is
117:50 - lesser inside the in in its existence
117:53 - which means this only exist until this
117:55 - portion so we will try to we will pop
117:58 - this element out and we will calculate
118:01 - the possible area that is that this
118:03 - element has been able to generate So
118:05 - currently for this first position this
118:07 - has been the area it is able to generate
118:10 - that area is going to be two that is the
118:12 - height and multiplied by width that is
118:14 - one so the maximum area we have so far
118:16 - is two okay now once again uh we are
118:20 - going to add value number one inside
118:22 - inside our stack saying that currently
118:24 - one so the the height of this one is
118:27 - also one and currently we we will only
118:30 - pop one out when we either reach to the
118:32 - end of the array or so or end of the
118:35 - Heights or we find some place where the
118:38 - height is actually zero and then we have
118:40 - some more elements okay so this is
118:42 - always going to be relevant in this
118:44 - example now we are at index position
118:47 - number two so notice what happened at
118:49 - index position number two the height
118:51 - suddenly increased compared to what the
118:53 - height we already have which means this
118:55 - one is still valid so because it is
118:58 - still valid we are going to keep it
118:59 - inside the stack not popping it out and
119:02 - we will add one more element five or the
119:05 - this index position two on top of the
119:08 - stack because now this is also relevant
119:10 - so far so we are going to put two inside
119:12 - the stack so its subsequent value is bar
119:15 - height five then we are next we identify
119:18 - height six which means this five is
119:20 - still relevant so because is relevant we
119:23 - are once again going to add value number
119:24 - six on top of the stack or soorry not
119:27 - value number six but the index position
119:29 - of six which is value number three so we
119:31 - put value number three inside on top of
119:33 - the stack and the height is six now we
119:36 - suddenly encounter the value uh at index
119:39 - position number four that is height two
119:42 - so any single value that has greater
119:45 - than two height has to be popped out of
119:48 - the stack because now that is no longer
119:50 - relevant which means for first of all
119:52 - this six is now no longer going to be
119:54 - relevant because the height is six and
119:56 - currently this index position is three
119:59 - and notice that the index position for
120:01 - this bar height two is four which means
120:04 - depending on the index position
120:06 - difference we can actually calculate the
120:07 - width for which the six was relevant so
120:11 - six was currently relevant for width one
120:14 - so currently let's pop six out if we pop
120:17 - six out currently this three is no
120:18 - longer present we know that this was
120:20 - relevant for one width which means width
120:22 - was one and the height was six so now
120:25 - the maximum rectangle we have been able
120:27 - to find is of size six which is greater
120:29 - than the previous maximum we had so we
120:31 - are going to update that okay now are we
120:34 - done no because this is two and this
120:36 - value is five which means we would still
120:38 - have to pop one value out if we pop one
120:40 - value out in this case now notice that
120:43 - the height at this position is two and
120:46 - the height at this position is four so
120:49 - because this is a greater position
120:51 - compared two over here so what is the
120:53 - width we found the width is actually two
120:57 - and what is the height we have is five
121:00 - so this is the height and also let's get
121:02 - rid of this two from our existing SE
121:05 - okay and now this area is going to
121:08 - become 10 so let's just add an area 10
121:11 - now once again uh we this we have this
121:14 - element one and currently this element
121:16 - is two so 2 is greater than 1 so because
121:19 - 2 is greater than 1 we are not going to
121:21 - pop one out because this one is still
121:23 - relevant so we are just going to Simply
121:26 - add two on top of one so let's just
121:29 - quickly add this index position number
121:31 - four with the height two okay and now
121:35 - currently next one we found the increase
121:37 - inside the height which means this two
121:39 - is still relevant because this two is
121:41 - relevant we are simply going to add an
121:43 - element five on top so we are going to
121:46 - add element five on top now adding index
121:49 - position number five now we reach to the
121:51 - end of the array which means the moment
121:53 - we reach to the end of the array we will
121:54 - have to start popping every single value
121:57 - out compared to its current position so
122:00 - currently we pop value number five out
122:02 - which means what is the height over here
122:04 - the height is three what would what
122:06 - would be the width width would only be
122:08 - one because it is only relevant for this
122:10 - one portion because currently we are at
122:12 - the end of our Loop so the area we have
122:15 - been able to calculate by popping this
122:17 - uh value number three out is going to be
122:19 - three now currently three is less than
122:23 - uh value 10 which is the maximum area we
122:25 - have so we are not going to update the
122:26 - maximum area okay now we are going to
122:29 - next uh pop out element number four so
122:31 - if we pop element number four out it has
122:33 - been relevant for this much portion of
122:35 - the time which means currently we have 2
122:38 - multiplied 2 so the area is going to be
122:40 - four 4 is also less than 10 which means
122:42 - this area is also not relevant and last
122:45 - one we will have to pop element number
122:47 - one out that has the size one or the
122:50 - height one so for this height is going
122:52 - to be one and this has been relevant
122:54 - since position one until the very last
122:57 - position so this has been relevant for
123:00 - the width five oh sorry for the width
123:02 - six since the very first position it has
123:05 - been relevant so now because this has
123:08 - been relevant since uh position six so
123:11 - the maximum area we have been able to
123:12 - generate is also going to be six but
123:14 - still it is not greater than the maximum
123:16 - area so after the end of this Loop we
123:19 - can simply return the max area to be 10
123:21 - and that's it that's the whole answer
123:23 - now if we see time and space complexity
123:25 - in this case the time complexity is
123:26 - going to be big of N and the space
123:28 - complexity is also going to be big of
123:33 - n so the coding solution is actually
123:35 - quite straightforward first we have a
123:38 - variable called Max area where we are
123:39 - going to be storing the maximum area we
123:41 - have been able to identify so far then
123:43 - we have our stack that we initialize and
123:46 - we also have a variable n the for the to
123:49 - store the length of the given array then
123:51 - we have for Loop to iterate over the
123:53 - given array now first we check for a
123:56 - condition that if the if the given I is
123:58 - equal to n which means we have already
124:01 - crossed every single element then we can
124:04 - mark the current height as zero because
124:07 - this is to take care of the last element
124:09 - if that is not the case we simply take
124:10 - the value of the given subsequent height
124:14 - height from the heights array okay now
124:16 - we have our while loop where we check
124:18 - that while the given stack is not empty
124:21 - and and the current height that we have
124:23 - been able to identify for any given I
124:25 - element is less than the current height
124:29 - that is already present inside the very
124:32 - first element of the stack then we will
124:36 - have to calculate the area for that uh
124:38 - where we simply calculate the height
124:41 - based on by popping the element out of
124:43 - the stack and then we calculate the
124:45 - width by uh subtracting the value of the
124:48 - current I minus the current element that
124:52 - is that was present inside the stack
124:53 - minus one and then we calculate the max
124:56 - area where we compare two elements based
124:59 - on the given Max area that we have been
125:01 - able to identify so far and the given
125:05 - current height and width multiplication
125:07 - or the current area that we have been
125:09 - able to identify whichever is greater we
125:11 - are going to keep it that and in the end
125:13 - after we run out of this V Loop we are
125:15 - still going to push the current element
125:18 - inside our stack and by the time we are
125:20 - done with all the elements we should
125:22 - have our maximum area being populated
125:24 - with the correct value and then we can
125:26 - simply return that so now let's try to
125:28 - run this
125:34 - code okay seems like our solution is
125:36 - working as expected let's submit this
125:40 - code and once again our solution runs
125:42 - beautifully extremely fast in terms of
125:45 - time and space complexity so once again
125:47 - the solution is present in the GitHub
125:48 - repository the link is in the
125:50 - description so you can check it out from
125:51 - from there thank
125:52 - [Music]
125:55 - you hello friends hope you're having a
125:57 - fantastic day today so once again we are
125:59 - going to do an awesome lead code problem
126:01 - that is really popular among tech
126:03 - companies for the interviews so without
126:05 - any delay let's get started so the lead
126:08 - code problem we are going to solve today
126:09 - is called longest valid parenthesis and
126:12 - you can see that this one is a lead code
126:14 - hard problem and also an extremely
126:16 - well-like problem on lead code the
126:18 - problem statement is actually quite
126:19 - simple where we are told that we are
126:21 - given a string that contains just the
126:24 - characters opening uh circular bracket
126:27 - and closing circular bracket and now we
126:29 - need to return return the length of the
126:31 - longest valid parentheses substring
126:35 - suppose we are given a string uh like
126:37 - this now we can see that all of these
126:40 - are actually valid substrings because
126:42 - they are coming in correct order so in
126:44 - this case since all of them are correct
126:46 - we can say that the longest sub
126:49 - substring that is valid is currently of
126:51 - six characters same way let's try to
126:53 - take one more example suppose the string
126:56 - we are currently given is something like
126:57 - this then we only have a valid valid
127:00 - substring that is only valid for just
127:02 - two characters and these two are not
127:04 - part of the valid substring so okay so
127:06 - we need to calculate that what is the
127:08 - consecutive longest valid substring and
127:11 - we need to return
127:14 - that now Brute Force approach logically
127:17 - we are going to do the most simplest
127:19 - things possible where we are simply
127:21 - going to check that uh for every single
127:24 - substring from starting from any
127:26 - particular string we are going to check
127:28 - that what are the longest substring we
127:30 - are able to generate until we encounter
127:32 - some invalid substring so overall this
127:35 - approach is a very simplistic approach
127:37 - that would work fine and generate the
127:39 - result but the issue is this would
127:41 - operate in big of n Square time so we
127:43 - need to find some way to shorten this
127:46 - calculation and in a single go we need
127:49 - to identify that what are the current
127:53 - substring that we have been able to find
127:55 - is it valid or not and if it is valid
127:58 - what is the current length what is the
128:00 - maximum length we have been able to
128:02 - identify and subsequently when will at
128:06 - what point does it stop becoming valid
128:09 - so these are the questions we will have
128:11 - to answer uh and then only we can find
128:13 - the optimal solution so now let's start
128:15 - looking about that what an optimal
128:17 - solution should look
128:20 - like suppose this is the string given to
128:23 - us as an input and now we are trying to
128:25 - find the solution now let's try to make
128:29 - some understanding clear and that would
128:31 - help us build our solution number one
128:33 - thing is the moment we identify at any
128:37 - given moment that there is a closing
128:39 - circular bracket and we haven't found
128:42 - the opening circular bracket which means
128:44 - we can directly ignore this case because
128:46 - this is definitely invalid because it
128:48 - does not have any previous opening curly
128:51 - bracket that is number one observation
128:53 - number two observation is for any single
128:55 - opening curly bracket we will need to
128:58 - keep this information stored somewhere
129:01 - that we have one open bracket for which
129:03 - we are trying to find a subsequent close
129:05 - bracket so it can come over here or
129:08 - maybe here or maybe it cannot be
129:09 - possible but we will need to have that
129:11 - information so these are the two pieces
129:13 - of information we will have to consider
129:16 - third thing is it could be possible that
129:18 - we may find some existing valid uh
129:22 - sequence like this but this may not be
129:26 - the longest valid sequence because
129:28 - longest valid sequence in this case is
129:30 - probably going to be this one so which
129:33 - means we will have to keep track of the
129:35 - current sequence and we will also have
129:37 - to keep track of the valid sequence and
129:40 - also the longest sequence considering
129:42 - all of these things it would make really
129:45 - good sense to use stack data structure
129:47 - for this problem and why are we using
129:49 - stack because if if we have to consider
129:53 - this to be valid then immediately before
129:56 - this there has to be an Open Bracket
129:58 - then only we can see that this is a
129:59 - valid scenario and then this bracket
130:01 - would not be considered which means this
130:03 - still needs to live inside the stack
130:05 - because stack follows an awesome
130:07 - property of last in first out that is
130:09 - going to be greatly helpful to us so now
130:12 - using stack we would be able to solve
130:14 - many different problems and the idea is
130:17 - that for each of this position rather
130:20 - than just storing whether it's an open
130:22 - or curly bracket we can actually store
130:25 - the index values so let me write down
130:27 - the index values and now the thing is
130:29 - inside the stack we will only push
130:32 - values when we encounter some Open
130:34 - Bracket because it could be possible
130:36 - that some time in the future there might
130:38 - be a closing bracket so and whenever we
130:41 - identify a closing bracket we will try
130:43 - to see in the stack that whether there
130:45 - exist any particular uh bracket that we
130:49 - can pop out if it does then then it
130:51 - would be part of the valid sequence if
130:53 - it is not there then we will see all
130:55 - sorts of scenarios okay so I hope that
130:58 - all of these explanation makes sense and
131:00 - now you are able to understand that how
131:01 - we are actually going to use the stack
131:03 - for our solution so let's quickly
131:06 - generate the stack now we are going to
131:08 - keep track of few variables so first one
131:11 - is that what is the current length we
131:14 - have been able to find next what is the
131:16 - maximum length we have been able to
131:18 - achieve now in order to keep track of
131:20 - the current length we will have we will
131:22 - need to know that where does the current
131:24 - valid substring starts so initially
131:27 - because we are actually using this as
131:30 - zero so initially our starter pointer
131:32 - needs to be somewhere over here before
131:34 - zero because we are starting the index
131:36 - from zero because imagine a scenario
131:38 - where we are only given an input like
131:40 - this which means this is 01 So based on
131:43 - the index location we know that this is
131:45 - actually a valid substring of size two
131:47 - but because we are starting the index
131:49 - from zero so we will actually create cre
131:51 - our initial starting pointer from minus1
131:54 - so it would be very convenient for us to
131:56 - calculate these values okay and you will
131:59 - understand the logic once we iterate
132:00 - over the the example so initially our
132:03 - starting pointer is going to be located
132:05 - at minus one position and this is where
132:07 - our starting pointer is okay so now
132:10 - let's quickly start iterating over the
132:13 - solution so logically first here we
132:16 - identify that this is a closing bracket
132:19 - for closing bracket we will have to pop
132:21 - one element out from the stack but the
132:23 - thing is currently stack is empty so
132:25 - because stack is empty this has to be an
132:28 - invalid entry so we can ignore this case
132:32 - and move on to the next element but when
132:34 - we move on to the next element we can
132:35 - say for sure that this is never going to
132:38 - be part of the uh valid substring so we
132:42 - will need to update our start pointer so
132:44 - now we will have our start variable uh
132:47 - being located at position number one so
132:50 - let's just mark start variable at
132:52 - position number one current length is
132:54 - zero and maximum length is also zero we
132:56 - haven't been able to find any values
132:58 - okay so let's just Mark these now we
133:01 - encounter an opening bracket so the
133:03 - moment we encounter the opening bracket
133:04 - we are going to be pushing the values
133:06 - inside the stack so let's mark the index
133:08 - value same way once again we identify an
133:10 - opening bracket so once again we are
133:12 - going to Mark a value inside the bracket
133:15 - and when we are opening the brackets we
133:17 - don't need to update the current length
133:18 - or the maximum length because we haven't
133:20 - find any valid substring so far okay now
133:24 - we identified one closing bracket so the
133:27 - moment we identify a closing bracket we
133:29 - will have to pop element out of the
133:31 - stack so let's try to pop one element
133:34 - out of the stack if we pop this element
133:36 - out of the stack by the way this is this
133:38 - has to be number two okay by the way so
133:40 - number two index we are popping out of
133:43 - the stack which means that currently
133:47 - that what has been the current length we
133:49 - have been able to identify it so far
133:51 - that is currently we are at element
133:53 - number three the element we popped out
133:56 - is located at element number two which
133:58 - means now this is no longer present over
134:00 - here which means currently we still have
134:04 - one element that is left inside the
134:06 - given stack so so far we can do the
134:09 - difference between this current element
134:11 - and the element that is already present
134:13 - inside the stack using the peak function
134:16 - so the difference is 3 minus 1 so so far
134:19 - we have been able to identify a length
134:21 - of two size valid string so let's update
134:25 - the value that the current valid string
134:27 - that we have been able to find is of
134:29 - size two and the maximum length we have
134:31 - been able to identify so far is also of
134:34 - size two now notice that we are not
134:38 - using the start variable right here uh
134:41 - because this is still not taken care
134:44 - inside the existing valid substring so
134:47 - that's why as long as there are some
134:49 - values present inside the stack we
134:51 - cannot conclude that stack is empty and
134:53 - we have taken care of every single
134:55 - substring so that's why start pointer is
134:57 - still going to remain here so now let's
135:00 - move on to the next element now we are
135:01 - at position number four once again we
135:03 - identified the opening bracket so let's
135:06 - try to add one more value inside our
135:08 - existing stack so now the value is four
135:12 - okay now once again we identified a
135:14 - closing bracket so the moment we
135:15 - identify a closing bracket we will have
135:17 - to pop one element out so let's quickly
135:20 - pop this element out now the element
135:23 - that is currently left inside the string
135:25 - is of size one so because this is of
135:27 - size one and the current element we are
135:30 - at is of size five which means the
135:32 - current substring that we have been able
135:34 - to find is 5 minus 1 so this is going to
135:37 - be uh four so current length that we
135:40 - have been able to find the current
135:42 - maximum length is of size four and
135:45 - because this is of size four which means
135:47 - we will also have to update our maximum
135:48 - length as well and that is also going to
135:51 - be of size four okay now currently
135:54 - inside our stack we only have uh one
135:57 - element that was that has been here for
135:59 - quite some time and now let us also try
136:02 - to move to the next element so once
136:04 - again we identified one more opening
136:05 - bracket so we will try to put element
136:07 - number six inside the bracket now once
136:10 - again we identified the opening brackets
136:12 - so we will try to put element number
136:13 - seven inside the bracket and now at
136:15 - element number eight we identified and
136:19 - by the way this current length would be
136:21 - res uh reset every single time we update
136:23 - the value okay so this is always going
136:26 - to be reset because we don't know that
136:27 - what the current length is we only
136:29 - Define the current length based on the
136:31 - value we pop out so now this is a
136:33 - closing bracket which means we will have
136:35 - to pop one element out so now we are
136:37 - located at Value number eight we popped
136:40 - element number seven out which means we
136:42 - still have one more Open Bracket located
136:45 - at element number six that we haven't
136:47 - taken care of so now we will do the
136:49 - difference between 8 - 6 and the value
136:52 - is 2 so current valid length that we
136:55 - have been able to identify is of size 2
136:57 - but that is not greater than the maximum
136:59 - length we have been able to achieve so
137:01 - we are still going to mark this as value
137:02 - number four so this is the logic on how
137:05 - you can actually use stag to solve the
137:07 - problem now let me just show you one
137:09 - more example very quickly uh and then we
137:12 - will uh move to the coding solution
137:14 - basically this is the optimal solution
137:17 - so now let's just quickly start using
137:18 - the logic So currently we identify an
137:20 - opening so we are going to mark value
137:22 - inside the stack we once again identify
137:24 - a closing bracket so once again we are
137:26 - going to pop this element out of the
137:28 - stack the moment we pop this element out
137:31 - of the stack and currently the stack is
137:33 - empty if the stack is empty then we will
137:35 - have to we found a valid string from the
137:38 - starting value so we are going to do the
137:41 - subtraction between the current value
137:43 - minus the starting value which means 1 -
137:45 - -1 so the answer is going to be two so
137:48 - the current length that we have been
137:50 - able to identify is two and the maximum
137:52 - length we we also identified is also two
137:54 - okay now once again so far remember this
137:58 - s is the starting value is still going
138:00 - to remain here but now we identified a
138:03 - closing bracket but for this closing
138:05 - bracket we don't have any value inside
138:07 - our stack so because the stack is empty
138:10 - which means this is an invalid portion
138:12 - so now the starting value has to jump so
138:14 - now we are going to jump our starting
138:16 - value to start at this element number
138:18 - three okay now this at this element
138:21 - number three we identify an Open Bracket
138:22 - so we are going to add value number
138:24 - three over here once again for four we
138:26 - identified a closing bracket so we will
138:28 - pop an element out of the slope So
138:30 - currently the stack is empty if the
138:33 - stack is empty so now we are uh located
138:36 - at this position number four and by the
138:38 - way our starting position should be at
138:40 - this position number two okay so now uh
138:43 - currently we need to because stack is
138:45 - empty we will need to do the difference
138:47 - so the difference between Uh current
138:50 - index and starting index is going to be
138:52 - 4 minus 2 so value is 2 so this is the
138:55 - current length we have been able to
138:57 - identifi and this is for this portion so
139:00 - now maximum length does not need to
139:02 - change once again we identify an Open
139:04 - Bracket so we are going to add value
139:05 - number five over here and once again we
139:07 - identified a closing bracket so now we
139:09 - will have to pop this element number
139:11 - five from the loop as well so currently
139:13 - the string is empty because the string
139:14 - is empty we will have to do the current
139:17 - value minus X so it's going to be 6 - 2
139:20 - so once again and the current length we
139:22 - have been able to identify it is four so
139:24 - the current length needs to be updated
139:26 - this is going to be four and because
139:28 - this is greater than our maximum length
139:30 - so we are also going to update this one
139:32 - and because we reach to the end of this
139:34 - given string so we can return the
139:35 - maximum length as four so this is the
139:37 - whole logic that we can use to solve
139:40 - this problem and by the way if we see
139:42 - time complexity in this case the time
139:43 - complexity is going to be simply big off
139:45 - n because we are simply iterating the
139:47 - given input array just once if we see
139:49 - space complexity because we are using an
139:51 - extra stack we will it will also going
139:53 - to be big of
139:57 - and so the coding solution is actually
139:59 - quite simple first we have a variable to
140:02 - store the maximum length then we
140:03 - initialize our stack and then we
140:06 - initialize the first value inside the
140:08 - stack as minus one this is going to be
140:09 - our starting pointer okay then we have
140:12 - our for Loop to iterate over the given
140:14 - string s uh character by character we
140:16 - check that whether the given string if
140:18 - that is an opening bracket or a closing
140:20 - bracket if it is an opening bracket we
140:22 - simply push that index position into the
140:25 - stack if that is not the case then there
140:27 - can be couple of scenarios so in either
140:30 - scenario first we will have to pop the
140:31 - element out of the stack now after
140:34 - popping element out of the stack if the
140:36 - given stack is empty then we need to
140:39 - push the current index as the base for
140:42 - the next valid substring and uh if that
140:45 - is not the case then we are going to
140:46 - calculate the maximum length so for
140:48 - maximum length we are simply going to to
140:50 - do the max to compare the current
140:52 - maximum length minus I minus the peak
140:56 - that is currently present inside the
140:58 - stack and this is going to be give you
141:00 - give us the current length that we are
141:02 - dealing with and in the end we simply
141:04 - need to return whatever the max length
141:06 - we have been able to identify so let's
141:08 - try to run this
141:13 - code okay seems like our solution is
141:15 - working as expected let's submit this
141:18 - code and our code runs extremely fast
141:21 - and this is a very good time and space
141:23 - complexity so once again I will be
141:25 - posting this solution in the in our
141:26 - GitHub repository so you can check it
141:28 - out from there the link is in the
141:29 - description thank
141:31 - [Music]
141:33 - you hello friends hope you're are having
141:35 - a fantastic day today so now we are
141:38 - going to do an awesome stack problem
141:40 - that is a actually a lead code premium
141:42 - problem so this is going to be really
141:44 - interesting very popular question and
141:46 - very interesting subject so without any
141:48 - delay let's get started Okay so the lead
141:50 - code problem we are going to solve is
141:52 - called Max stack this is actually a lead
141:55 - code hard problem and the thing is
141:57 - because this is a lead code premium
141:58 - problem uh I took this description from
142:01 - another website called Le code. CA so
142:04 - thank you so much to whoever maintaining
142:06 - that that website now we need to design
142:08 - a Max stack class that supports these
142:12 - five functionalities now if we see the
142:14 - functionality the first three are pretty
142:16 - common where we are pushing an element
142:18 - down the stack where we are popping an
142:20 - element out of the stack and where we
142:21 - are uh just checking what is the Top
142:24 - Value inside the given stack these three
142:27 - are the common functionality of any
142:29 - particular stack then we need to add two
142:31 - more methods where first one is a peak
142:34 - Max method uh and second one is the pop
142:36 - Max method so if we do the peak Max
142:39 - method we will need to know that what is
142:41 - the maximum element currently and if we
142:44 - do pop Max then we will have to pop the
142:46 - maximum element that is right now inside
142:48 - the stack outside so let's try to see
142:51 - the solution for this problem so
142:54 - logically uh let's assume that currently
142:57 - we have an empty stack okay so we have
143:00 - the option to use five operations and so
143:02 - let's try to First quickly push some
143:05 - elements inside down the stack so if we
143:07 - let's push value number three and then
143:09 - value number five and then value number
143:11 - one okay so now currently we push a few
143:14 - elements now if we want to pop and let's
143:16 - just add one more now if we want to pop
143:18 - we can pop one element out as well so if
143:20 - we do the pop operation then we will we
143:22 - won't have value number seven now we can
143:24 - also do a peak operation so if we do
143:28 - Peak operation then we can simply check
143:30 - that what is the very first element so
143:32 - answer of this is going to be one then
143:34 - if we do if we want to do Peak Max which
143:37 - means we should see that what is the
143:40 - current maximum element present inside
143:42 - the given array which means the current
143:44 - maximum element present inside the given
143:46 - array is actually value number five even
143:49 - though it is not at the top of the the
143:50 - stack this is the current maximum
143:52 - element so this needs to be value number
143:55 - five and if we have to pop Max then we
143:58 - need to pop the value number five out of
144:01 - the stack not value number one even
144:03 - though one is the very first element so
144:06 - this is how we will have to design this
144:08 - algorithm and design data structure in
144:11 - order to keep these values now we know
144:14 - that completing these uh items is very
144:17 - simple and very similar no issues with
144:19 - this one this is a regular stack
144:21 - functionality and every single language
144:23 - like language like Java python C++ they
144:25 - have they all have their own stack
144:27 - versions that we can simply use the
144:30 - problem comes when we need to do this
144:32 - peak Max and pop Max problem uh
144:35 - operations because the thing is this is
144:37 - actually slightly complicated because of
144:40 - variety of reasons now the very first
144:43 - thing that comes to our mind is to have
144:45 - a variable called Max where we are going
144:47 - to store the maximum value that we have
144:49 - been able to identify inside the given
144:51 - array and this should make our lives
144:53 - easier this is the Primitive logic we
144:55 - can think of where let's assume that we
144:57 - add value number one so we need to
144:59 - update the value of Max to Value number
145:01 - one then once again we add value number
145:04 - six so we once again because 6 is
145:06 - greater than one so so far the maximum
145:08 - element we have been able to identify is
145:10 - six then we have value number three so
145:12 - three is not greater than the current
145:14 - maximum element which means we don't
145:16 - update anything or we don't do anything
145:18 - now after this uh let's say we add value
145:22 - number eight so once again the maximum
145:24 - element needs to be eight so so far you
145:25 - must be thinking that hey this seems
145:27 - pretty convenient why don't we just have
145:29 - one value to keep track of the maximum
145:31 - element and at any given moment I want
145:33 - to see that hey what is the maximum
145:35 - element I can just simply look at this
145:37 - variable and find the answer the problem
145:39 - is when we do the pop operation out of
145:42 - this given stack then there would be an
145:44 - issue because now let's say that I
145:46 - decide to pop this eight so if I do if I
145:49 - pop this element 8 I know that now 8 is
145:53 - no longer the maximum element present
145:55 - inside the stack but I don't know what
145:58 - is the other element that is the maximum
146:01 - element but instead of just having one
146:04 - simple variable Max we actually need to
146:07 - have a variable another stack called Max
146:12 - where for every single entry inside the
146:16 - original stack for that entry we will
146:19 - have to keep track that what what has
146:20 - been the maximum element that we have
146:22 - been able to identifyed so far and keep
146:25 - updating that list depending on the how
146:28 - we uh push out or pop out the elements
146:32 - from the given stack so let's let me try
146:35 - to explain what I mean the idea is let's
146:37 - assume that for the max we have to worry
146:39 - about two operations first one is the uh
146:42 - Peak Max where we are simply watching
146:44 - that what is the max element that is
146:46 - currently present and second one is the
146:48 - pop Max where we are popping the maximum
146:50 - element out at the current position
146:52 - inside the given array so we have
146:55 - created our own Max stack array uh sorry
146:58 - Max stack so this is our Max stack and
147:00 - this is our regular stack okay now let's
147:03 - assume that I wanted to enter value
147:04 - number one so what I'm going to do is
147:07 - I'm going to add value number one
147:08 - currently this Max stack is also empty
147:10 - so so far the maximum element at this
147:13 - position I have been able to find is
147:14 - also one so I'm going to store value
147:16 - number one over here once again I
147:19 - identified Val number six so because
147:21 - value number six is greater than 1 I'm
147:24 - just going to put six as normal value
147:26 - over here but over here because value
147:28 - number six is greater than value number
147:30 - one so I'm going to say that up until
147:33 - this point of the stack the maximum
147:35 - value I have I have been able to
147:37 - identify is six that I have presented
147:40 - over here and some reason if I decide to
147:42 - pop this element out of the stack then I
147:45 - know for sure that this element also
147:47 - needs to be popped out and then the
147:49 - maximum element at this position will be
147:51 - corresponding to the maximum element at
147:53 - this position that is value number one
147:55 - so which is pretty convenient for us now
147:58 - let's try to add one more element let's
148:01 - say three now once again even though we
148:04 - added value number three over here so
148:06 - far the maximum value we have been able
148:07 - to identified up until this point is
148:09 - once again six so we are once again
148:11 - going to mark value number six over here
148:14 - and then once again let's say we add
148:16 - value number eight so once again we are
148:18 - going to add value number eight over
148:20 - here here because that is the maximum
148:21 - value we have been able able to identify
148:24 - so so far let's repeat what we have done
148:26 - we did the push operation in big of one
148:29 - time no issues with that now at this at
148:32 - any given moment we can also do the peak
148:34 - operation uh and the moment we do Peak
148:37 - operation whatever element is located at
148:39 - the top of the stack we should be able
148:41 - to see that so this is also going to
148:42 - happen in big off one time so once again
148:44 - no issues with this one so we already
148:46 - took care of two variables we can also
148:49 - do the pop off operation easily from the
148:51 - stack so pop operation can also be done
148:54 - in big off one time and we can do Peak
148:56 - Max as well in big off one time because
148:59 - this is also being happening or
149:02 - maintaining in constant time so this
149:04 - also happens in constant time so we took
149:07 - care of four operations in big off one
149:09 - time just by simply using these two
149:11 - different Stacks but now the important
149:13 - thing is that how we are going to manage
149:16 - the pop Max operation for that we will
149:19 - also have to do the pop so let's try to
149:21 - First do couple of Pop operations if I
149:23 - pop element number eight out of the
149:25 - given stack which means now stack does
149:27 - not contain eight value anymore and I
149:30 - will also have to update the maximum
149:31 - element up until this point as well okay
149:34 - now at this position let's say I decide
149:36 - to do pop Max so if I do pop Max at this
149:41 - moment I should not be kicking out value
149:44 - number three from the stack because this
149:46 - is not the maximum element so far the
149:49 - value I should be be kicking out is
149:51 - actually going to be the value number
149:53 - six so what I'm going to do is that I'm
149:56 - going to kick value number six out of
149:59 - this given list up until every single
150:02 - point that I have been able to iterate
150:04 - so far and the moment I kick value
150:08 - number six out I'm going to do a peak
150:10 - operation to see that if this given
150:13 - current maximum value if that is greater
150:16 - than the current maximum value I'm left
150:18 - with and if that is the case then I will
150:21 - need to update the given Max element to
150:24 - add in incorporate value number three as
150:26 - well because remember that in the
150:29 - previous state in this state we did not
150:32 - had value number uh six as part of the
150:36 - given uh sorry value number three as
150:38 - part of the maximum value so far but
150:40 - because we did the pop Max we kicked a
150:43 - value number six out and at the same
150:45 - time we will also have to pop these two
150:47 - elements out as well and we would be
150:50 - left with value number three okay so
150:51 - this is the whole thing that we need to
150:54 - do and this is how we can solve this
150:56 - problem using two stacks in order to con
150:59 - convey this message so this is the whole
151:02 - solution and using this we can complete
151:04 - everything in big off one time all five
151:06 - operations so now let's quickly see the
151:08 - coding solution and then things will be
151:10 - make much more sense
151:13 - okay so now since this is a lead code
151:15 - premium problem and we don't have that
151:17 - subscription at the moment I'm just
151:18 - going to explain you the solution in the
151:19 - the notepad but this code would work
151:22 - fine and the code is also present in in
151:24 - our GitHub repository so let's
151:26 - understand the code so first we are
151:27 - going to create couple of inte uh couple
151:30 - of stacks for stack and Max stack now
151:33 - for the push and for the pop and for the
151:35 - top we need to the all of these three
151:38 - are standard operation the thing is pop
151:40 - and top are going to remain the same the
151:42 - only problem is that for the push
151:45 - operation we actually have to push the
151:47 - element in both the places which means
151:50 - in the stack we are just going to push
151:52 - it as a regular push push entry but for
151:55 - the max stack we will first have to
151:57 - check that what has been the maximum
151:59 - element inside the given stack by based
152:02 - on the definition of this x value so far
152:05 - using math. Max function and checking
152:07 - that what has been the current maximum
152:09 - in the max stack versus the current
152:11 - value we are trying to enter so we are
152:13 - always maintaining the maximum element
152:15 - for any given X element inside our Max
152:19 - stack stack okay then for the pop
152:22 - operation we will have to pop the
152:23 - element from both the places Max stack
152:26 - and also from the given regular stack
152:29 - for the top operation we simply have to
152:31 - check that what is the maximum element
152:33 - on our regular St uh stack uh and we can
152:36 - just do a peak operation now for the
152:39 - peak Max operation we will need to do
152:41 - the same operation but now this time in
152:43 - our Max stack stack rather than our
152:45 - regular stack and the last one is the
152:48 - slightly more complicated method that is
152:50 - the pop Max method where first of all we
152:53 - are going to initialize a new stack
152:55 - called buffer because remember uh the
152:58 - the value we are trying to kick out is
153:01 - presented somewhere in the middle in the
153:03 - regular stack so meanwhile we don't find
153:06 - that value we will have to buffer that
153:09 - from our regular stack so that's why we
153:12 - are going to push every single element
153:15 - uh from our normal stack to the buffer
153:17 - stack until we until we find the top
153:19 - element to reach to the Max and then we
153:21 - will simply pop that element out from
153:24 - the regular stack at the same time we
153:27 - are also going to pop that element out
153:29 - from our uh Mac stack as well and then
153:33 - in the end in inside the buffer we are
153:36 - also going to push all of those elements
153:39 - into our regular St stack using the
153:42 - elements that we just stored inside our
153:44 - buffer stab temporarily so that's why
153:47 - this pop Max method is slightly
153:49 - complicated method and uh you can see
153:51 - the coding solution present onside our
153:54 - on our GitHub repository so hopefully
153:57 - this explanation made sense to you and
153:59 - uh yeah thank you so much

Cleaned transcript:

learn all about the stack data structure you'll learn about its implementation operations and practical use cases par teaches this course he'll guide you through when and why to use Stacks enhancing your understanding of this essential data structure then he'll teach you the 10 most popular stack related interview questions to help prepare you for your next technical interview Hello friends hope you're having a fantastic day today so in this course we are going to learn everything that is to know about stack data structure stack is one of the fundamental data structures in computer science it has lot of practical applications and also remains one of the most popular type of interview questions that you can encounter in your technical interviews so my expectation is that by the end of this video you should be able to understand that what stack is when to use it the moment you see any type of interview question you should be able to identify that this is related to stacks and what are the strategies we are going to use to solve this problem so this course is is going to contain lot of important information we are going to start with understanding what stack is how it is implemented what are the benefits what are the limitations what are its characteristics time complexity space complexities and under what type of scenarios you should be using stack afterwards we are going to see 10 most popular stack questions that has been asked in technical interviews we will understand in depth that what those questions are how come stack became the choice of data structure for that particular type of scenario and how do we actually solve it so without any delay let's get started now very quickly let me give you a brief introduction about myself my name is par vas and I'm based in Canada I have been in IT industry for close to 10 years and I have bachelor's and Masters in computer science as part of the education I have worked at companies like Royal Bank of Canada and noia Microsoft and currently I'm working as a Solutions architect for the biggest theater chain in Canada called clex on the side I also run my own YouTube channel called destination Fang and I would really appreciate if you can go ahead and support me on that channel as well in my personal Hobbies I love watching movies playing video games uh going out on Hikes and doing all sorts of fun activities last year I became dad of two beautiful twin daughters and that's why we I have all of these teddy bears hanging around me so now let's get started with our course so stack is one of the fundamental data structures of computer science this is a linear data structure and typically Stacks are implemented using some sort of list function so it can be either array list or link list but the thing is stack is not just typical any single array or link list this is a special kind of list that contains a very specific property and that is called Leo property that is called last in first out so how does a stack typically works is that inside the stack you always have have to work with the values that you are entering is always going to end up at the bottom of the stack and then if you have to enter the next value it will remain at the top of the stack and you can only access the element that was last entered inside the stack so let's try to understand this with an example currently let's say that we have this an empty stack now for this stack if we try to add value number one so one is going to stay at the bottom of the stack and now for this stack then since it only contains one value if we have to see that what is the element inside the stack it will return us the result as one but let's say that we don't do that and we try to add one more element so if we add value number two it is going to come on top of value number one and then we add value number three we can add value number five something something something now the moment uh over here we decide that I want to get one element out from the stack so the moment we try to do that we cannot directly access this element three or two or 1 we will always have to access element number five first and once we kick element number five out or pop element number five out then only we can reach to element number three which means the last value that was entered inside the stack is going to remain at top of the stack and that is the only value we can access in any any given moment inside the stack and this special property of Leo actually comes in very handy for some very specific operations so before learning that let's try to understand that what a typical stack looks like in real world you can think of a stack of books or a stack of plates both of these uh simply un shows us that how does a typical stack works in the real life because if we have bunch of books stack on top of each other then we can only access the book that is currently present at the top of the stack and then we will start going Bottom one by one so same thing applies for the stack of plates as well and this would be the best way to understand that how does the memory is stored inside the stack and this is implemented using some sort of list function so inside the stack there are mainly three operations that we have to worry about first operation is called push operation so push means that you are entering some value inside the stack next operation is called pop operation pop means that some value that is already present inside the stack you you are going to access or fetch that top element outside of the stack and then that element will no longer be present inside the given stack and last operation is called Peak operation in the peak it is very similar to pop but you are not actually fetching the value out you are simply seeing that what is the current value that resides at that location so let's try to understand currently our stack is empty let me push one value so if I try to push value number three then three is going to be populated inside the stack then I can also push value number four then I can also push value number seven and so on and so forth now at this position I decided to do a pop operation so let me just simply do a pop operation the moment I do that the seven is actually going to be kicked out of the given stack and it is going to be return returned as part of the answer so now the seven is no longer present inside the given stack and it is over here that we are able to be fetch uh if I do pop operation one more time then we would have four also be poed as well and then if I try to do a push operation once again and try to add value number five then five is going to be present over here the moment I do Peak operation at this moment then I'm only going to be seeing that there is value number five currently present at the top of the given stack but I would still keep or leave this five untouch inside the stack I only see that what is the value associated with the peak operation and all of these three operation actually operates in big go off one time so there is a special way we actually Implement stack inside the list and that allow us to fetch complete all of these three operations in bigo of one time so now let's just take a quick look at the implementation for any particular given stack so let's start implementing the stack class we are going to use an integer array list to implement our stack class and now let's create a Constructor to to open an instance of the array list now one by one we are going to implement our three push pop and Peak method so let's start with the push method so for the push method we are not returning anything we are taking an item integer item as an input and we are simply adding it to the array list instance that we have created now for the pop method for first we are going to check that if the given items list is not empty then we need to return the very last element that was entered inside the stack or the last element that is currently present inside the item and we need to remove that from the existing array list so here for the pop method we check that if the given list is not empty then we remove the very last element that was entered entered inside our array list if that is not the case and if the given list is actually empty then we simply return the null value and same way let's try to implement the peak method where it is going to be very similar to our pop method the only difference is that instead of removing the element we simply need to get the value of that element and that's it so now we have implemented the three methods for our stack now let us also try to implement the ismt method so for the is empty method we are simply checking that if the given items array list if that is empty or not and that's it this is the complete implementation of the stack class now let us try to implement a main method and also run some operations on the given stack class so now we have implemented our main method where we are initializing a new stack so first of all we are pushing three elements onto the stack the values are 10 20 and 30 next we are going to be pecking that what is the top element inside the given stack so this should return us the answer as 30 because that was the very last element that we entered inside the list then we are going to pop an element once again that should also return the value 30 because that was the last element that was entered and then once again if we do the pop operation it should return value number 20 and in the end we are going to Simply see the peak operation so that should return value number 10 so let's try to run this code we before forgot to change the name let's try to run the code so we can see that for the very first operation the top element is 30 then the PO element is 30 then once again we pop element number 20 and in the end after that when we check for the top operation we can see a value number 10 so this is how stack is actually implemented but lucky for us stack is actually provided as one of the default application and we actually don't have to implement the stack class all the time this was just simply for your information now let's learn that what are some of the popular use cases that we can apply stack at and You by by knowing these use cases we would be able to quickly identify during our interview or any problem we are trying to solve to realize that whether stack would be a good choice or not so number one thing where you can think of using a stack is for any time you have to do an undo type of functionality so what does Undo functionality mean means we know that inside our computer or browser we have the functionality where it keeps track of every single step that we have gone over across any set of websites and then if we click the back side backspace button or if we do the undo button inside the software such as word or any other PowerPoint or something like that it is able to trace our steps back and then put us back to the previous state so how it does it is that it actually uses stack to store that information let's try to understand this with an example suppose we currently have an empty step and I'm trying to open a new browser session inside the Google Chrome so the moment I first uh go inside the Google Chrome I have a new empty stack being created now inside the Google first of all I decide to go to the Facebook website which means stack is going to mark that I visited the Facebook website right now through Facebook I decide to go to the x or Twitter website so next it is going to put the value of x on top of my stack then I decide to go to the Uber website so once again the same information is going to be recorded and so on and so forth now at this position of uber I decide to click on the back button or the undo button where I want to go back to the previous state simply the browser is going to pop the element that I have entered at the very last so this is going to be taken out now I'm no longer at the Uber place and whatever value located over here it is going to do a peak operation and bring me back to the uh Twitter page that I was previously browsing so this is a great use case now you can understand that how this Leo property last in first out property actually help us to solve a real world problem few other important use cases that we can think of for stack is to have it in the backtracking mechanism because how does a typically backtracking works is that let's try to understand this with a small example of trees so inside any given tree if you have to iterate over the tree you will have to understand that what was the previous state that you are iterating over and have you visited all of its children or not so let's assume that I have currently this type of scenario and I'm trying to go in the depth first search fashion now I know that this was supposed to be a course on stack but I'm just explaining you explaining you some simple theorem to understand that how stack can be used with different data structures as well so in the depth for search we actually go in one single Direction and and the moment we try to find some value if the value is found that is great if that is not found then we have to do the backtrack and do the do the same operation for the remaining children or remaining leaves as well so let's try to do that let's say that we are trying to find this particular element and we are doing a simple depth for search so first we are going to we are at we are located at this position so we are going to go to the left child once again to the left child and once again to the left child we did not find the element we were looking for but the thing is there might be some path that we haven't explored so we are going to do the back tracking and through this back tracking now we are going to see that hey are all the childrens of this particular node uh that I have tested no I haven't tested them so I'm going to check one more once again I did not find what I was looking for once again I'm going to do the backt track and through here I okay so now I have tested both of his children which means now I will need to do the backtrack operation once again and through here okay there are still some children that I haven't tested so I will go on the right and once again I will go on the left and I found the value that I was looking for and at every given moment a stack is going to keep track of every single information that we were iterating over so we can quickly backtrack to the previous position that we haven't iterated over let's try to understand this with some example so let's say that these values are a b c d e and this is f and I okay let's say that this is I so initially our stack is going to be empty then uh we are at position number a then we move to the position number B then we move to the position number c then we move to the position number D at D we realize we cannot go any go further anymore so we will pop D out and we will check that have we explored every single possibility at this C no we haven't checked so once again we are going to go to the value number e so we are going to add value number e over here once again we haven't checked all the possibilities uh sorry we check all the possibilities at e once again we come back to the C we check all the possibilities at C so we are going to remove c as well now we are at this position number B so for at B we haven't checked F so we will add F over here from F we haven't checked I and we are going to reach to the I and I was the item that we were looking for so we found our answer so we can simply say say that yeah this element is present inside this tree and we were able to smoothly iterate over the entire tree using backtracking because we had the stack that contained the last in first out property so now you start to understand that how specific or how important stack is let's try to understand one more use case that is that at any given moment you want to identify that whether the given sequence of let's say brackets or parentheses are they valid or are they in the correct order or not and doing this can very easily be done using Stacks how we can simply have a logic that whenever we identify an opening parenthesis we are simply going to add that value to the stack and whenever we identify a closing parenthesis we will remove that value from the stack and see that the value removed does it contains the same type of parenthesis or not so let's try to see the example in action and then you would be able to understand what I'm talking about so first we encountered a square opening bracket so we are going to Mark Square opening brackets then curly opening bracket and then a round round opening bracket okay so now we took care of all of these three elements now we are at this position and we encounter a closing bracket now the thing is in order for this sequence to be valid the closing bracket has to be exactly the same same way that that was for this particular bracket so let's try to do that so let's say that we pop this element out and over here we identify that for this circular closing bracket the value we popped out was also opening bracket which means this is a good sequence so we can move forward so now we no longer have this value next we have a a curly closing bracket so for curly closing bracket we realized that the value we popped out was also curly opening bracket so this is is also a matching pair that is good and in the end we found out that the last element is also a closing bracket that is square closing bracket and the value we popped out was also a square closing bracket so we found this pair which means this pair of parentheses is valid now the question is this is really important whenever you are building idees or compilers so things like intellig eclipse or jet brains or bunch of other compilers they all use this formula or the stacks to keep track of every single opening and closing bracket now imagine in this scenario that this last element say for some some reason this one is a closing circular closing bracket now at this moment we identified a circular closing bracket and we try to pop this element out and we identify that this was actually a square opening bracket which means this was a mismatch so if that is the case we can simply get rid of these uh these things saying that this was an invalid pair and that that is how we can use stack to complete these type of operations and we can do all sorts of like functional logic and all sorts of important fun stuff using stack so that's why they remain so popular in terms of technical interviews and now we are going to go ahead with the 10 questions about Stacks that we talked about completing these 10 questions will give you the full exposure towards stacks these are some of the most popular most like and most cast problems uh in terms of technical interviews all of them are really popular lead code problems and they have been asked in interviews tons of time so without any delay let's get started today we are going to solve daily temperatures lead code problem that is a medium problem and also an extremely wellike lead code problem so the problem statement is quite simple we are given an integer array called temperature that represents the daily temperature over a certain span period now we need to return a new answer from this given temperature array such that any particular item in that particular answers array should Define that how many number of days you have to wait in order to generate a warmer temperature compared to that particular day's temperature so let's try to understand this with an example suppose this is the temperatures array we are given now in the input you can see that bunch of different values for every single day's temperature now if we see on this very first day the temperature is 73 which means means how many number of days we have to wait in order to get a warmer day well a warmer day is right next which means if we just wait one more day we can actually get a warmer day same way for 74 if we just wait one more day we also get a warmer day because next day's temperature is 75 now at the 75 if we have to find a warmer day then we have to find a day that contains higher temperature than 75 which means this temperature 76 is higher which we can see that that is actually 4 days away so over here we will have to actually wait 4 days in order to get a warmer day same way for the 71 we have to wait 2 Days in order to get a warmer day at position 69 we only have to wait one day to get a warmer day at 72 once again we will have to wait just one day because next day is 76 which is warmer at the 76 we do not find any particular warmer day subsequently which means we cannot find a warmer day so we are just going to mark this as zero that no warmer day exist in front of the value 76 and last one is 73 so since this is the very last entry we don't know what the upcoming temperatures looks like so we are also going to return zero and this is the answer array that we need to return uh that defines the temp days you have to wait in order to get a warmer day from any particular day okay so first let's try to understand a Brute Force approach to solve this problem the idea is very simple we simply go to a day and then we keep on iterating the array until we find the next day that has higher temperature the moment we find this one we actually find the difference between the index positions and whatever the difference is we Mark that in the answer so for this first one we can mark first as the answer for the second one once again we are going to repeat the same process we are going to iterate over every single value inside the array till we find a higher value and which we find 2 days later see same way we are going to keep on repeating the same operation and eventually we would have our entire answer array to be populated now this is the most simplest method but we can inherently see some issues with this approach the number one issue is that at any given position we will actually have to Traverse over maybe the entire rest of the array in order to find the optimal solution what if uh let's assume that this instead of being 50 Maybe This Was 80 and we don't have any particular solution in mind we would have still iterated over the entire array and then once again in in order to find the lower temperature for this next element we would still have to iterate over the entire given array maybe this was 82 so in this this case this is an inefficient approach and if we see time complexity for Brute Force approach is going to be biger of n Square in the worst case scenarios so let's try to see if we can improve upon this time and space complexity or not the thing is at this given location at the very first moment we don't know that what is the temperature that is higher than this one because we have only iterated this one element right but what if we are at this element we can at least predict that how many elements actually has lesser temperature than this and based on that we can immediately update their temperature and we can immediately say that for if we are at let's say value number 75 then at 75 we should be able to tell that 74 is only one day away from having its warmer day and same way at 74 we should be able to tell that 73 is actually just one more one day away from having a warmer day same way at 72 we should be able to tell that 69 is only one day away so how can we actually do that for that we will have to find some way to actually iterate the array in One Direction note that what the current temperatures are and based on that we will also have to check that what are the immediate temperatures that are actually smaller than this current temperature or greater than this current temperature so that we can mark their answers in order to do that we will have to use an extra data structure to store the values of all the temperatures for which we have not been able to find the warmer days second thing is for any particular temperature not only we will have to find the warmer day we will also have to find like the immediate warmer day so for this 745 is actually greater than both 74 and 73 but we should not waste our time marking this 73 as having a warmer day as 75 because there is 74 that is more closely associated with 73 which means we have to worry about the immediate before elements so we are traversing in One Direction but the at the very quickly we will have to understand that what was the last item we were at before moving to any particular previous elements so the best data structure in this case is going to be a data structure that contains the property of last and first out and the answer becomes very simple that we are actually going to use a stack to solve this problem now how we are going to use the stack is actually quite interesting let's first understand couple of properties number one thing is we are using the temperature to compare the difference between any two given values which means we are dealing with the value of this given array but in the answer we need to store that how many number of days are apart between any two entities and that we can find using the index values why because at index value 0er we have this value 73 and at index value 1 we have this value 74 which means 7 uh index value zero is only one day away from finding a warmer day because index value 1 minus index value 0 becomes actually value number one so this is how we are going to find the answer which means in the stack it would make more sense to store the index positions rather than storing the actual values but using the index positions we can very quickly look up inside the array find the answer and then subsequently Traverse the answer so after this long explanation let me walk through the solution that I'm proposing So currently we are at zeroth index the value is 73 currently we don't have any value inside the stack so we are going to add index zero inside the stack okay and now we are at index position number one the value is 74 the very first thing we are going to do is we are going to check that whether the value located at zeroth position which means the value located at temp of zero if that is actually less than the current index positions we are at so if that is less than the temp of one which is correct condition because this one was 73 and this is 74 which means 70 this value can be popped out of the given stack and we can actually Mark the answer for this one by doing the subtraction between the current element minus the index position that we just kicked out from the stack so this is going to be just one where we did a simple equation 1 0 okay now we are going to put 74 in the stack but we are going to put the index value so now in the stack we have index position number one now once again we are at index position number two so this value is 75 75 is greater than 74 which means we can do 2 1 and the answer is one so we can store that that 74 is one day away from finding a warmer day now we popped out one from the stack now let's add ENT entry number two inside the stack okay now we are at this position 71 So currently 71 is actually smaller than 75 which means we don't for 75 we have not yet found a small a warmer day so we are going to add entry number three inside our stack as well next we are going to be at position number four which is 69 once again 69 is actually uh less than the current Top Value we have inside the index which means we haven't found a warmer day for this top element and we are going to add one more element uh that we haven't found a warmer day for okay now we are at position number 72 so 72 is actually greater than this value the value at index number four so we can actually uh find the answer for index number four so let me just go okay so this is for index number one zero we have one we have for two we don't have for three we don't have but for four we found the value that is 5 4 so we can add 1 as the answer for index number four Once Again One the moment we pop out index number four we we should not be pushing index number five yet because we still have to check that whether five is greater than index number three and yes it is once again greater so for index number three we are going to Mark the answer as two and same way for index number two we are also going to Mark the answer as uh so sorry for index number two we are still not able to be able to find the answer because this is 75 and this is 72 so we are going to have index number two still living inside the stack and then we will have index number five now residing in the stack now we are at index number six so this value is 76 76 is actually greater than 72 and so in this case we can actually mark down the answer over here as 1 for this index number five and we can get rid of this index number five now once again this index number two is also smaller than index number six so we need to do the difference 6 2 so we find answer four and we are going to populate answer four over here and then we have an empty stack which means there are no more values we need to check so we are going to add value number six inside the stack and then in the end U next value is value number seven so 7 is 73 73 is actually smaller than the current stack value we have so we are also going to add value number seven inside the stack and the moment we reach to the end we are going to fill out all the rest of the elements by zero that there are zero days that we have been able to find the answers for and this is what we can return in the answer so you see how using a stack we actually need to Traverse over just once on the given temperature array and then we have been able to find the answer which means this is a much better approach and this is the optimal solution compared to our Brute Force solution so let's try to see the time and space complexity in this case the time complexity is actually going to be big of n because we are simply iterating over the temperature array once now it could be possible that for some values we might have to go back and find the values that are smaller than that that where we are doing multiple operations inside the stack but that that number is going to be limited because we are being told that we can find out that how many values are there and uh we are only iterating over the values for which we haven't find the answer and uh in terms of space complexity once again in the worst case scenario this is going to be big of n because we are using an additional space additional stack to find the answer answer so the coding solution is actually quite straightforward first we initialize a number n in order to mark down the length of the given array then we initialize a new answer array of the size n we also initialize our stack that we are going to use now we simply iterate over the given temperatures array using the for Loop we first have a while loop condition that while the given St stack is not empty and the temperature that we are iterating over current if that is greater than the temperature that is currently present inside the stack then we simply Mark the index value that is currently present at the very first element of the stack that we popped out and then we Mark the answer index by doing the subtraction of I minus the current index position that we have just been able to find by popping the element out of the stack and then uh we simply push down the element inside the stack and in the end our answer array should have all the answers so we can simply return done that now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to most of the other Solutions it is also decent in terms of space complexity and once again the solution is available on our GitHub repository the link is in the description so you can check it out from there so the lead code problem we are going to solve is called evaluate reverse polish notation and we can see that this is a lead code medium problem and also an extremely welllike problem on lead code the problem statement is quite straightforward but it actually has bunch of different conditions that we need to understand so we are given an array of strings called tokens now these strings represents an arithmetic expression in the reverse polish notation now we need to evaluate the expression and we need to return the integer that represents the value of the expression now let's try to see some of the conditions that we are given number one the valid operations are plus minus multiply and division so these are the four operations that we can we can imagine to expect in our uh string that is coming in now we are being told that each operand may be an integer or another expression so we will see this in in another example then we are being told that the division between two integers always truncates towards zero which means we are always considering the ceiling value of ceiling value or sorry the floor value of any equation and then we are being told that all the inputs are going to be valid and there are not going to be any issues so let's try to see one example one very simple example so in this case the answer is going to be that the moment we identify an operator we will have to go back and take the previous two elements and if these two are whatever the numbers are we are going to be using that with this operator so we are going to be treating this as a we are going to be treating this as B and since this is a plus operator we are actually going to be doing a plus b so we need to return three as the answer in this case let's try to take some more slightly more complex examples first we are going okay so this is the number we move away move ahead once again a number we move ahead we identify an operator so now we are going to be treating these two values as a and b so we are going to be doing a plus b so 1 + 2 so the P the answer of this portion is actually going to be three our equation looks like three and then three and then plus so once again we are going to be doing 3 + 3 so the answer is 6 so out of this operation we need to return six as the answer so this is the whole logic of what the problem is actually asking us to solve that whenever we are given the values we keep moving forward until we find either one of these three operators like plus minus multiplication or division the moment we identify these four operators we are going to be treating the previous two values as a and b and then apply this operator and then keep on repeating the same process until we run out of all the every single digits inside the given inputs and we are being told that the all the inputs are valid now after this extensive explanation let's try to understand the most simplest Brute Force approach so Brute Force approach is actually quite straightforward uh suppose we are given the values 4 5 plus and then minus and then 7 suppose these are the values we are given so idea is that we are going to keep on iterating one by one the moment we identify an operator then once again we go back to the previous two elements and we use it with that operator and then once again uh we identify okay so now this becomes 9 and then minus and then 7 so once again we keep on repeating the same operation using the operator but thing is many times for let's assume that this if this is a very long string and we identify operator at very late the moment we identify operator once again we are going to be repeating the same process in order to keep find the values A and B so this becomes very tiresome operation so the idea is that we need to make it better and uh find some smarter ways to keep track of all the elements from the point we find the operators in the reverse order and also have an idea on how we can keep on moving forward with the given input array and start parsing the values so these are the two main considerations that we will have to understand so the idea I'm suggesting is that we can actually use stack to solve this problem so suppose this is the long operation that we are given now the idea I'm suggesting in using the stack is that at the very beginning we are actually going to be iterating the same way we are iterating all the values we find we are going to be pushing these values inside the stack the moment we identify the operator we are going to be popping the previous two elements and treating them as uh A and B and then applying that operator with that value and once again whatever the answer we find we are also going to be pushing those answer inside the stack and then we are going to keep on repeating the same process until we identifi the operator and then when we reach to the end we should have our answer ready because we are being told that the given input is actually valid so let's see the solution in action So currently our stack is empty now we are at very first element number two so we are going to be pushing element number two inside the stack now we are element number three and once again element number seven okay now we identified an operator plus so the moment we identified the plus operator we are actually going to be popping these two values out so if we do that we will have value 7 and three that we need to do the sum of so 7 + 3 is going to give us the answer 10 So currently the answer of this portion is going to be 10 so we are going to be pushing this 10 inside the stack and now look at the stack it actually contains the equation for this portion because sum of these three values is 10 that is present over here and then two was already here now we have 10 and two once again we identify multiplication sign so we need to do 2 * 10 so we get the value as 20 so now once again we are going to be pushing the value 20 because we already popped out 2 and 10 okay so now we have value 20 inside our array and now we once again identified value number eight and then once again value number 19 so let's push that okay after doing that now we identified car symbol plus so once again for plus we are going to be doing 8 + 19 so the answer is going to be 27 okay so now we are because we popped out 19 and 8 we push 27 7 down and then we have this minus operator so last operation we are going to be doing is 27 minus 20 so the answer is going to be 7 so 7even is what we need to return in this case to solve the problem and this is the whole solution that I'm proposing using the stack look how beautiful it is look how at any given moment but by the moment we identified the operator we can actually find the previous two elements back and we can actually do the sum uh that needs to be done or some division uh subtraction whatever and this is how we can solve the reverse polish operation very beautifully using stack this is one of the most awesome way to use stack in the real life problem and that's why this is such a popular problem that we have seen in tons of interviews being asked so if we see time complexity in this case the time complexity is actually going to be biger of n because we are going to be iterating over every single character just once nothing more than that in terms of space complexity we are using an additional uh stack so depending on how apart the characters are from any operation the size of Stack can increase or decrease but overall it is going to be big of n so which is good uh and uh acceptable time and space complexity in this regard so now let's see the coding solution for this one so the idea is quite straightforward first of all we are going to be initializing our stack then for every single token we are first of all going to check that if the given token is operator or not the moment we identify that if the given token is operator we are going to be popping two values out so first value we pop out is going to be our B and second value is going to be our a and then we are going to be applying our operator that we have found uh using this method so let's see couple of the helper methods first helper method is the is operator helper method where we are simply checking that if the given token is equal to any of these four values and second one we are applying the operator Where We Are simply going to go over the given input values that is the string and then a value and B value and we are simply returning depending on the operator to whether do the addition subtraction multiplication or Division and if none of this case is there we are simply adding one extra argument but I don't think this is going to uh be called because we are being told that the given input is valid if that is not the case and we did not find that these are the operator by the way uh the moment we identified the operator we also do the calculation and whatever the result we found we once again push it down the stack if that is not the case which means the given token is not an operator so we simply push it down the stack but we first of all convert the value inside the integer because we know that this is going to be the integer value and once this Loop runs we should have been done with our reverse polish notation and whatever the value left inside the given stack would be the answer that we need to return so we can simply pop the very last element so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast in terms of time complexity which is pretty awesome once again the coding solution for this problem is present inside our GitHub repository so you can find it from there so the lead code problem we are going to solve is called Min stack and you can see that this is a lead code medium problem and also a very well like problem on lead code the problem statement is very simple that we need to design a stack that can support push pop top and retriving the minimum element inside the given stop these four operations and it needs to run in constant time or B go off one time so we need to implement the Min stack class and these are all the methods that we need to implement now we know that how does a typical stack work stack operates in Leo principle last in first out if we decide to push element number three then we will have an entry three presented inside the stack next we can push another entry called one then once again we will have entry called one then once again we can have Push another entry called five So currently we have three elements now inside the stack if we have to pop this element then the element five would pop out so let's quickly pop one element so then we will get answer number five then if we do pop once again we will have value number one after doing that if we were to add two two more elements or push two more elements let's assume 2 and six so once again we will have elements 2 and six something like this then if we do top operation at this moment it it should return return answer six because that is the top element inside the array and then if we do get min then it should return us the value S2 because this is the current present minimum element inside the given stack so these are all the operations that we need to do we need to solve all of these in big of one time which means we will have to do something different when we are design designing our stack so what are some of the considerations that we can do the thing is this push method pop method and top method all of these three methods can operate in big go of one time no issues with that in either case this get min is little bit tricky because we will we will need to know that what is the minimum element at any given moment now the very first thing that comes to our mind is that when we are designing the stack uh why don't we just have an extra variable called Min to keep track of the minimum value we have encountered So Far So currently this is an empty stack let's assume that we enter value number five so this has been the minimum value so far five next we add value number six so five is still the minimum value next we add value number two so once again we update this and add two over here once again we add value number seven so now currently the minimum value is two but now there is one problem that you did not see and that problem is that let's assume that we decide to pop one element out so now currently seven is no longer here but once again the minimum V variable is still two because that is the minimum variable let's see let's say that if we do pop once again so once again two is now no longer inside the given stack as well so now if we do Min operation we don't know that what is the minimum value inside the array because we just overrode the value so if we have to check for the minimum value we will have to pop all the elements out of the stack and then find the minimum value that is option number one which takes big off end time and if we don't do that we we basically don't have any other way so now to overcome this issue and to keep track of the minimum value at every single variable we can actually do things slightly differently so the moment we are storing the values inside the given array uh we are actually storing different nodes right for every single location now in this design of node we can actually have node have multiple items not only just its value so let's assume that this is our given node and so in the node I'm suggesting to add three values first value is the value of the node itself that whatever the value we wants to enter that is your integer value like 1 2 34 whatever he wants to put next is that what has been the minimum value up to this point inside the existing stack and if we keep on updating this value with every single entry inside the stack this would be pretty easy to maintain and last thing is the reference to the next node because uh in case we will have to remove or get rid of the element we might need to update the minimum value we have entered so far so let's see that how would this approach is going to look like let's say that we wants to add these values inside the stack okay so first we wants to add value number three currently the node is empty so because node is empty we are adding value number three h what has been the minimum value we have added so far that is also going to be value number three and the reference to the next node is going to be null so we are not going to be concerned with that that this is the very last element inside the stack okay now we need to add value number five so we add value number five but what has been the minimum value is is so far so for that we can either check the minimum value of the next pointer using this next pointer so we check that what has been the minimum value of the next pointer at location number five that is value number three and what is the value of this current value we are trying to enter that is value number five so whichever is the smaller number which is three in this case so we will still Mark three as the minimum value we have been able to find and then we simply have a reference to the next node so reference to the next node once again I'm just marking as three but that that is simply going to be this node okay once again we wants to enter value number one so now at one what has been the minimum value up until this point that is this value number three so instead of using three because one is smaller so the smallest value so far is going to be one and the reference to the next node is also going to be this one same way now we wants to add value number seven but what has been the minimum value we have been able to find so far that is value number one and then just the reference to the next node and then in the end the value is zero so now the value is zero we are trying to see that what has been the minimum value up until this point that is one so compared to one Z is smaller so then this is also going to be zero and then we simply have a reference to the next note okay so now this is what our uh stack looks like we are simply updating the node that we are storing uh the values in and now let's let see each of the operation so I just mentioned that push operation can happen in big off one time because we are just simply pushing one node inside the stack uh let's try to do a pop operation so pop operation can also happen in big off one time because we are simply popping one element out so we will get rid of this element okay now once again let's try to do the top operation so top operation we need we can return seven immediately because that has been the latest value we we find and then if we do the get min operation this can also happen in big off one time because we can simply find the minimum value we have been able to identify so far so this is the logic on how we are going to solve this problem basically by simply redefining the way we are storing the values and then keeping track of the minimum value at every single position that is the whole trick and if we see time complexity in this case well time complexity we already know that that is going to be big of one and in terms of space complexity uh well this is debatable but I think it it has to be big off one because anyways we are being asked to create a stack so we cannot create extra space for that so first let's define the node for our given class where we are going to store three values first one is the value of any particular position next is the Min value and third is the reference to the next node and this is just a simple Constructor to store the values okay now coming back to our main class we are going to have a private node head and we are going to initialize our data structure here next we are going to have a main push method so whenever we need to push any single ENT so if the value is very first then we are simply going to provide the value as it is then minimum value is also going to be the same value because there are no other entries inside the stack and then the next element would be simply null if that is not the case we are going to add a new node where we are going to keep the value as it is then for the minimum value we are actually going to compare it with the current value and the minimum value we have been able to find so far and that we can simply find uh using the next node and then as a part of the next node we are simply going to point to the Head node and this is going to be keep on updating with every single entry uh for the pop it's very simple we simply uh take the very first element that is currently present for the top we simply return the very first element and then inside the for the get min method we simply return the minimum value for the head and this is the whole solution let's try to run the code okay seems like our solution is working as expected let's submit this code and our code runs extremely fast compared to lot of other Solutions in terms of time complexity and very efficient in terms of space complexity so once again I will be posting this in our GitHub repository so you can check it out from there thank and today we are going to solve a lead code problem called generate parenthesis now if you see some of the popular companies who have already asked this question there are companies like Amazon Facebook Microsoft Apple Bloomberg Uber Lyft Google by dance Spotify and Nvidia so that's why I'm paying my at most attention I hope you also enjoy the video okay so this is a lead code medium problem and also very well like problem on lead code basically we are given an input number n and now we need to generate n pairs of parentheses so basically we need to write a function that generates all the possible combinations of wellformed parentheses now these round parenthesis I think they are called wellform parenthesis now we can try to understand these two examples but I'm going to take take it one step further and I'm going to show you four different examples to understand that what this problem is asking us to do okay now in this first example we are basically given n is equal to one pair which means we need to make one possible pair and all the combinations of this well formed parenthesis so obviously the answer is going to be quite simple we simply need to return return like uh just one possible pair that we can make out of this one now suppose n is equal to 2 so now for n is equal to 2 we have the choice to take like two of these and two of of these right we need to take four values uh so basically the number of possibilities we can make is that we can actually make a parenthesis that looks like this and we can also make a parenthesis that looks like this these are the only two possibilities we can have and uh this is what we need to return return as the answer now things becomes a little bit interesting when we reach to n is equal to 3 uh so when we get to the point where n is equal to three the possibilities we can make is so these are the five possible pairs we can make when n is equal to 3 now notice that over here for every single piece we are using like three opening brackets and we are also using three closing brackets but we are just putting them in different pairs so that they generate like the wellformed parenthesis uh same way if we try to do it with n is equal to 4 the answer is going to be pretty huge so let me just uh draw it over here so these are all the possible pairs we can make when n is equal to 4 and basically we are using four opening brackets and four closing brackets and arranging them in different sizes so this is a very interesting problem now let's see that what are going to be the different approaches to solve this problem so now the first approach that comes to our mind is a Brute Force approach in The Brute Force approach what we can do is suppose we are given n is equal to two right if we are given n is equal to 2 there is one thing guaranteed we need to have four characters inside every single block of our answer why four characters because uh we are generating two pairs of parentheses so two pairs of parth Paris is basically going to be four characters at least right so what we can do is now we have two options to choose from either we can choose an opening parenthesis or we can choose a closing parenthesis so what we are going to do is basically we can take every single possible pair that we can make of size four using these two characters and only the valid pairs we put put them in the answer so suppose we are given n is equal to 2 what are the different pairs we can make let me make just a few pairs so these are just some of the few examples that we can make for four characters using like this opening and closing parenthesis for n is equal to 2 and over here we only need to find the legitimate pair so okay we can find one legitimate pair and we can find another legitimate pair and I think this is going to be the answer that we need to return so we will put these two in the answer and then just return them but if you see this Pro Force approach is extremely inefficient uh if we see like time complexity the time complexity goes sometimes into like 2 to the power of 2 N something multiplied by n just to check that whether the pair is valid or not and that is this dter us so no one is going to accept that so we will have to find a way to do something better so what we are going to do is we are going to do things smartly how we are going to do things smartly first let's define our perspect purpose our purpose is to generate two pairs of opening and two pairs of closing brackets and they has to be well informed or valid now we need like two opening brackets so that is a given fact we need two closing brackets that is also a given fact now there are are some properties that we can use at our advantage taking consideration the definition of being valid now what is the definition of being valid so basically if we are given n is equal to 2 there has to be uh two opening parentheses and two closing parentheses so that is one definition second definition for being valid is that we can only put a closing parenthesis if there exist an opening parenthesis before that again I'm repeating myself we can only put a closing parenthesis if there exists a closing parenthesis before that we cannot start our answer with a closing parenthesis because that wouldn't be valid uh third third thing that we need to consider is that we can only have that many number of open parentheses that is equal to the number of n now you are saying that why am I repeating myself because this is going to be the very important property that we are going to use uh so now once we know all of these things let's try to make some smart decisions on how we can actually generate the answer for valid parenthesis uh basically we are given n is equal to 2 over here right now we have option to choose like two opening parentheses and two closing parenthesis so okay now what we are going to do is uh for our answer generation always we will have to start with us an opening parenthesis right now we we created the opening parenthesis that starts with this one now we are going to keep track of few values first value we are going to keep track of is the number of opening parenthesis right so number of opening parenthesis that we have used so far is one uh and what is the maximum we can use maximum we can use is two because that is the value of n we are also going to keep track of the number of opening parentheses we already know that is one right we are also going to keep track of number of closing parentheses and so far we haven't used any closing parenthesis so that this value is zero and we can only add a closing parenthesis if the number of open parentheses is greater than the number of closing parenthesis because we already proved that over here now using this logic let's see that what is the sequence we can make okay so first we start with this value when we start with this value number of opening parenthesis is one number of closing parenthesis is zero now over here we have two options uh and those two options are we can either add one more opening parenthesis or we can add a closing parenthesis so let's see options in both of both of the cases the number of opening parenthesis is going to be two and we can have this value to be two because we are given n is equal to 2 and in this case the number of closing parentheses is still going to be zero because we have only used two open G parentheses over here now in this case the answer is going to be a little bit different uh because the number of opening parentheses is going to be one and number of closing parentheses is also going to be one and this is also valid why because the number of closing parentheses can be one because we already had one open parenthesis so so far both of the cases are legitimate now again at this position we also have two more choices so over here we have the one choice to open and we have one choice to close now let's see both the options if we try to go one choice to open what we will happen is number of opening bracket is going to be three but that is not valid why because we are given n is equal to two explicitly so in this case we cannot go down this path so if we cannot go down this path we will actually backtrack and come back to this position now from this position we can only go towards the path of closing so if we go towards the path of closing so far the number of Open brackets we had is two and the number of closed bracket we had is one so that is still valid that is still legitimate now again from this position we still have two options we can either open or we can close if we try to open we cannot do that because number of open is going to be three so we are not going to go down this path uh if we go down this path uh basically the number of Open Bracket is going to be two number of Clos bracket is going to be two as well and this is the exact condition we need because we are given n is equal to 2 so which means that there has to be two Open brackets and two closed brackets so we can put two conditions whether we can put like the combination of open Plus close is going to be four that is going to be the double of what is uh n or we can have like uh o is equal to 2 and C is equal to two both of them equal to two so this is also good so now we have reached this condition which means that whatever the path we actually make can make our ourselves into the answer so what is the path we took so first we started with uh taking the opening bracket then again opening bracket then again closing bracket and then again closing bracket so let's put this value in the answer right so we are going to create a new variable answer over here and over here let's put one entry that okay two open two close that is good now let's start following the other path I'm going to clean this up a bit so it does not become any more distraction so now in this case okay currently we have one Open Bracket one closed bracket now again we have two possibilities so first possibility we can open one more bracket or we can close one more bracket now let's uh analyze both the possibilities if we try to open one more bracket basically the number of Open brackets we are going to have is two let me clean this up a bit more and over here uh number of closed bracket we had so far is still one so okay this is valid we can put this one now if we try to put one more closed bracket the number of Open Bracket we have so far is only going to be one but number of closed bracket is going to be two which is no a big no no why because we cannot have more close bracket then the number of brackets we have opened because that would defy the possibility of having a legitimate scenario so we cannot go down this path so we won't and uh now again we have two choices at this position we can open one or we can close one if we open one then the number of open is going to be three that is not valid that is not good so we are not going to do anything with this one and we will not go down this path if we go down this path then over here number of Open brackets we have so far is two and number of closed bracket we have so far is also two which is also the legitimate scenario so which means that this path is also going to be a path that we can add to our answer and uh let's see okay so currently we have okay we have one Open Bracket one Clos bracket we also have one Open Bracket and one closed bracket and that's it now uh initially remember we only started with this one opening bracket and then we had two possibilities and we actually exhausted both the possibilities so we cannot go down further anymore now because we cannot go down further anymore uh we can conclude that whatever the values we find so far this is the complete answer and we can return return this as the answer and basically this is the whole Crux of the finding the optimal solution now you must be asking that hey what we actually did was uh we did something s very important first we identify okay the one value then we had the uh final case so final case was that whenever the number of opening is equal to n and number of closing brackets is also equal to n this is our final case and then at every single position we had two options to either choose an opening bracket and closing bracket and keep on repeating the same process until we reach to the end and we had some parameters in mind so if you see we are actually using dynamic programming at its finest because at any single previously computed value that is being used to calculate that which path we need to take and whether we can take that path or not so we are basically using dynamic DC programming plus backtracking to solve this problem and this is going to be like an amazing way to explain this problem uh logically think that in the Brute Force what a disastrous result we were having and we actually brought it down to such like beautiful answer and then we are just presenting it so this is the whole power of uh using any like computer language so before we start implementing the generate parenthesis method first we are going to create our backtrack method uh that is going to be our helper method that we are going to use recursively now for the backtrack method it is not going to return anything uh but it is going to add all the values towards the answer and inside the method we are actually going to create a list of list that is going to store the answer we are also going to have a string Builder to keep track of the current values we have the number of opening and number of closing brackets and also the maximum number of values we can generate okay so now first let's create the acceptable scenario so if basically the current length is actually going to be maximum * 2 uh which means that we can actually we have reached to our answer and we can add it to our answer so this is the legitimate scenario now let's see say for an example we find out that uh uh the we have not reached the answer then what could be the possibility well first possibility could be the number of Open brackets uh that could be less than the number of maximum brackets that is allowed if that is the case basically for the current uh string Builder we can actually upend an opening bracket so let's do that and uh after adding the opening bracket basically we will have to call the backtrack method again with a reduced value of one Open Bracket so let's do that so in the backtrack method we are going to call the answer and we are also going to call the current uh string Builder list we have but for the open we are actually going to add one value and for the number of closed brackets we are going to keep it as it is the max is also not going to be changed and that is awesome now there is also one more important thing we will have to do every single time we make a backtrack call and that is to delete one character that is located at the current length minus one because it is going to add an extra character so let's do that okay now same way uh say for an example if the number of uh close CL brackets and they are less than the number of Open brackets uh if that is the case basically we can also add one closed bracket to our self as well so let's do that and we are also going to call the backtrack method and uh everything else is going to remain the same and basically this whole logic sums up our backtrack method now all we need to do is from our main method we simply need to create a list of list called answer so let's do that and then we are going to call our backtrack method now inside the backtrack method we are going to provide the value of answer we are also going to provide a new instance of a string Builder Pro going to provide the number of opening brackets that we have used so far is zero number of closing brackets is also zero and the maximum number of opening and closing bracket we can have is going to be the value of N and after getting the answer from the backtrack method we can simply return the answer to be return the answer that we got and uh basically that's it yeah let's try to run the code okay seems like our solution is working as expected let's try to submit the code if we submit the code our solution beats lot of other Solutions it is really good in terms of time complexity and it is also really efficient in terms of space complexity as well hello friends hope you are having a fantastic day today so once again we are going to do an awesome lead code problem and trust me this is an awesome lead code problem so without any delay let's get started so now we are going to solve the lead code problem called car Fleet now personally this is one of my favorite problems and we can see that this one is a lead code medium problem and also decently welllike problem the thing is this is a very long description for this problem because it covers lot of edge cases and lot of conditions that you have to understand if you want be my guest and read the whole description if not let me just point out few important topics and then we will we will try to understand what the problem is asking us to do through an example that would make things much more simpler so first thing is we are being told that there are n cars going in the same destination along one lane road so it's a single Lane Road and we are told that the cars are not going to be overtaking each other this is not fast and furious this is lead code okay then we are also given a Target miles that we need to reach that is the final destination for our cars now we are given two integer arrays first one is position and second one is called speed so position defines that what is the starting position for any particular given car compared to that Target distance okay and the speed is at what speed that particular car is running on so we are given both the values inside the car now we are being told that cars are not going to overtake each other but if they are close enough we can consider them arriving at the destination at the same time and any car arriving at the destination or set of cars arriving at the destination would be considered as car Fleet and now we need to consider that how many number of different car fleets actually arrive to the destination so I know that this was quite complicated and very extensive description let's try to make it simpler using some example so over here we are given a Target value of 12 that we need to reach and we are given the positions and we are also given the speeds of subsequent cars so here I have actually plotted a graph or a number sequence where this 12 is the Target that every single car is trying to reach now this C1 C2 these represents different cars and we can see that based on their positions inside the subsequent array I have already plotted them on this given line so this defines their starting position and subsequently this ption defines that what is the speed that is given to every single car okay and we are being told that the distance we are trying to cover is 12 mil and the speeds are given in per hour basis so which means this car C2 actually Travers 4 miles in 1 hour okay so now we need to understand that how we Define car fleets so let's try to understand it one by one so we will try to go over that how every single car is actually going to reach to the Final Destination and we know for sure that no car is going to overtake one other so if one car comes closer to the other car we would consider both of them reaching to the destination at the same time and there would be part of one single Fleet so first let's see So currently this car C1 is located at position number 10 and its given speed is 2 mph we know that the C1 has to be the first car to reach to the destination because it is the closest car to the destination so the in the first hour this car is actually going to reach to the destination and it's going to take 1 hour but during this 1 hour period because how do we come up with this 1 hour because we calculated the distance from the current position to the Final Destination we are trying to reach which is 2 miles and its speed is also 2 miles so we can easily easily calculate the time uh that it takes to reach to the destination now for this C2 also subsequently the C2 would also reach to the destination in just 1 hour so based on this we can conclude that both of this C1 and C2 are actually going to reach to the destination around the same time around at 1 hour mark which means C1 would be here and C2 would be right very close to it so these two cars are going to reach to the destination in around the same time which means this is going to be one of the Fleet that is going to arrive into the destination so now we already took care of one Fleet so let's just get rid of these okay and also let's try to understand that we have already spent 1 hour so during this 1 hour what would be the position of all of these cars so during 1 hour the C4 would have traveled 1 kilm so C4 would be here same way the C5 would have also Kil con completed 3 kilm because its speed is three so after after this 1 hour this c5's position should have been at position number six but at position number six we can clearly see that C4 is already present which means after 1 hour the position is going to look something like this where C4 and C5 are going to be right close to each other now remember that the speed of the C4 is 1 and speed of the C5 is three but because C4 is ahead compared to C5 even though it has higher speed it is not going to overtake it and it is only going to reach to the destination when the C4 arrives but essentially both of these cars are also going to reach to the destination in around the same time and how much time will it take well currently this one is at position number six so it is going to take six more hours and we already spend 1 hours which means the C4 is going to take 7 hours to reach to the destination and because C5 is behind that and it is able to catch up to the C4 it is also going to complete and reach to the destination in 7 hours so after 7 hours the second Fleet that would have reached to the destination would be the cars uh that we just saw that is the car C4 and also C5 so they both will also reach to the destination in around the same time so this would be our second Fleet that is going to reach to the destination and now we already spend 7 hours which means after 7 hours this C3 would have been uh around here because because its speed is just 1 M hour so it would have covered the distance of 7 mil and then still it would have five more miles to go which means it would still take uh like around 12 hours to reach to their destination and in the end the C3 car would be the very final car that would reach to the destination and still this would also be considered a fleet in its own so over here we can see that actually we are getting 1 two and three fleets reaching to the destination so for this given input we need to three as the answer and this is the whole problem statement now I know understanding this problem statement take took us lot of time because there were a lot of moving paths and moving cars that we had to understand but honestly this is an awesome lead Cod problem because if any interviewer dares to give you this problem this is not very difficult to solve but it's very uh pecular for interviewer to explain also you will have to navigate through lot of different edge cases and then think about coming up with the optimal solution so now I'm not even going to be bothered to show you the Brute Force approach because that would be an ins insult to this beautiful problem so let's talk about the actual complete optimal solution that we can use in order to solve this problem and in order to generate the optimal solution we need to make some assumptions and we we need to do some calculations so what are some of the calculations we need to do number one thing that is most important is that for any particular car we will have to understand that how much time it takes to reach to the end that is number one thing and second thing is cars can only reach to the Target based on the current sequence locations they are present in so even though if we see the car numbers over here this C1 and C2 are based are located at the correct space but the C3 is actually going to even though this is the third car this would this has to be the last car to reach to the end so number one thing we are going to do is we will try to find that how much time does it take for any single car to reach to the end we will try to store this information with the cars so we actually have couple of ways to store this we can either store it using a hashmap uh that would only make things more complicated because we don't need like a constant time access to that data and same thing can be achieved using a twodimensional array as well so we will try to use it store it using two dimensional array okay so in the twodimensional array we are going to store the information for a subsequent car and how much time does it take to reach to the end that is number one thing number two thing we are going to do is that we will actually sort these cars based on their positions so number one car in that is going to reach to the destination is going to be the car that is closest to the destination position so based on the position size we are also going to sort them and once we have that we would be able to identify the answer quite easily so now first let's try to understand that how do we actually calculate how much time does it take for any single car to reach to the destination and that is a very simple calculation all we need to do is we need to calculate the distance between the current position and the destination position and whatever this distance is we need to divide the speed by that distance and that would give us the time on that it that that particular car would take to reach to the Final Destination okay so now the idea is quite simple so let's just do that so for C1 currently we can see that this is located at position number 10 and it needs to reach to the position position number 12 which means the distance is two and the speed for C1 is also 2 m per hour which means it is going to take 1 hour for C to reach to the destination same way for C2 it is also going to take 1 hour to reach to the destination same way for this C4 it is actually going to take 7 hours to reach to the destination because the difference between 5 and 12 is 7 and the speed of C4 is 1 M hour same way for the C5 the dist the distance is also going to be 3 U 9 km uh sorry 9 miles and then the speed is three so it is only going to take 3 hours to reach to the destination and last one is the C3 car so for C3 it's actually going to take 12 hours to reach to the destination now we have over this list ready now let's try to sort this given list based on the position of the cars which means once again C1 is at the correct position and C2 is also at the correct position both times are 1 hour and 1 hour then we have the car C4 and C5 so for the car C4 it is uh it is going to reach into the 7h hour mark and car C5 should reach in 3our marks if there were no cars ahead of it and the last one is the c0 car or uh I think C3 car so C3 car is going to take 12 hours to reach to the destination okay so let's quickly do a re recap what we did we found out how much time does it take to reach to the destination then we sorted all of these cars based on the position where they are compared to the start to the Target location so the higher the position the first it is going to be inside our L list and in order to store this information we are going to be using a 2d array now after having this information it becomes very easy for us to solve this problem because all we need to do is we simply have to check because we know for sure that this has to be the first car to reach to the destination at any given moment moment we realize that the speed of this is actually lesser or equal to the speed of its subsequent car then we can conclude that both of these cars would reach to uh at the same time let me rephrase I use the word speed but the the correct word should have been time so if the time it takes for the C1 car to reach to the destination is 1 hour and we see that for C2 the time it takes is also 1 hour which means C1 and C2 both are going to reach to the destination around the same time just in a scenario where C2 is just behind C1 so we can conclude that these two has to be one single Fleet so this becomes our one of The Fleets now in the second scenario we have the time it takes for C4 to reach to the to the destination as 7 hours and the time it takes for C5 to reach at the destination at 3 hours which means C5 actually is much faster than C4 So eventually C5 would be close enough or just behind C4 before C4 actually reached to the destination let's try to once again understand using this plot because after the very first hour actually C5 and C4 would both be at the same place and how do we find out because we can see that the time it takes for both of them to reach to the destination so these two also has to be part of a simple Fleet now say this last for the C3 instead of this being 12 maybe this also took 3 hours to reach to the destination then C3 would have also been part of this Fleet because C3 would reach to the Destination 3 in 3 hours C5 would reach in 3 hours and C C4 is going to block both of them and cause both of these cars to reach at 7h hour mark because C4 is ahead compared to C5 and C3 so this would have been part of this Fleet as well but in this scenario because the time C3 takes to reach to the destination is actually greater than the previous Fleet the largest value in the previous Fleet then we can conclude that this C3 is not going to be able to catch up to this C4 and C5 Fleet so this is going to be our second Fleet and in the end the C3 is going to be our third Fleet so that that's all you need to do to solve this problem once we do have the comp the sorted version of subsequent cars with the time it takes to reach to the destination we can actually very easily compute because for every single Fleet all we need to check is that what is the longest time it takes uh for those Fleet to reach to the destination so in this case for the C4 and C5 it's going to take 7 hours to reach to the destination so if this number would have been anything less than seven then it would have been part of this uh C4 Fleet but because it's not less than 7 so this has to be a fleet on its own and uh that's it that's what we need to do and this is the whole solution so now you see how beautiful this problem is and how awesome the solution is like that's why this is really one of my favorite questions because it's a combination of math and data structures and then how do you make things more efficiently and how can you think about uh different scenarios and different mathematical equations and stuff like that okay so now let's try to understand the time complexity it is going to be bigo of n because we are going to be simply iterating over the given input array bunch of times but still it is going to be big off n but you forgot one critical thing that is we will also have to do the Sorting operation and that is actually going to cause our time complexity to be big of n log n and if we see space complexity well for the space complexity is actually going to be big of n Square because we are using a 2d array to store the information of the cars uh to its subsequent time it takes to reach to the destination overall this is also a very good time and space complexity now let me know in the comments if you want also want to see a solution using a monotonic stack because this is pretty popular problem for that so if you want I can also show a solution with that but I think this is a good enough solution for your interview your interviewer is going to be more than happy and now let's just quickly see the coding for this one so the coding solution is quite simple first of all we create an integer n uh to store the length of the given input array and then we initialize our 2D array that we talked about where we are going to store the information about cars and its subsequent time it takes to reach to the end then we are simply going to iterate over the given input array and we are going to pop calate our cars 2D array that we just created where we are going to Mark the positions of the car and also we are going to calculate that how much time does any single car it takes to reach to the destination then we are going to do the most important operation where we are going to sort the given cars based on the current positions of the given cars once we have that now it is very convenient to solve this problem we are going to initialize a counter zero that this is going to calculate the fleet on what time it is going to arrive and then we are going to have another variable where it is going to keep track that what was the previous time for the car to reach to the end then we are simply going to iterate over the given input uh 2D array cars and we are going to check that if the value of any particular given car is actually greater than the previous time which means that is a new Fleet being created so we are simply going to create a new Fleet or add the value to the counter and also we are also going to Mark the previous time of the last car that just came in and that's it in the end we can simply return this counter that we have created that was keeping track of all every single Fleet and now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs decently efficiently in terms of time complexity extremely efficiently in terms of space complexity and once again the code is present inside our GitHub repository so you can go and check it out from there thank you hello friends hope you're having a fantastic day today so now we are going to solve Facebook's most asked question this question has literally been asked 142 times at Facebook so this is a very popular lead code interview question and without any delay let's get started okay so the lead code problem we are solving today is called minimum remove to make valid parenthesis book and we can see that this is a lead code medium problem and also a very welllike problem now the problem statement is quite simple that we are given a string that contains bunch of different opening and closing parentheses and low lowercase English characters now at any given moment if we identify that the parentheses are in correct sequence like the same number of parentheses that are opened are also closed then we call them valid but if we identified some invalid parentheses then we simply have to remove them so let's try to understand this with an example it would make much more sense and we can see that bunch of the parentheses are actually at the wrong position first one we can see over here where we have a closing parenthesis but we don't have any opening parenthesis somewhere here before which means this is an invalid parenthesis sa same way uh this is also an invalid closing parenthesis because though this pair of parentheses are valid this is not valid and same way we have an additional opening parenthesis so in this case we have three parentheses that that are invalid so if we simply get rid of these three parentheses that we just identify then we would have our query that will look like this and now we can see that uh this entire sequence is actually valid where we have uh two pairs of opening and closing parentheses so they are valid and also we have a bunch of different smaller English language characters and they are also valid so we simply have to identify that which are the index positions that we need to remove uh in order to make a valid parenthesis pair or a valid query okay so let's simply see The Brute Force approach very quickly Ro Force approach is very simple uh for any query that we are given we can all we need to do is that we simply go over every single character and the moment we identified either an opening or closing parenthesis so in this case we identify a closing parenthesis so once again we would go back and try to find an opening parenthesis if we cannot find it we identified that this one is invalid and then we move forward so same way the moment we identify an opening parenthesis once again we would move forward to try to find a closing parenthesis that is going to match up with that if we find it that's great if we don't find it then in that case we would deem that parenthesis as invalid and if we keep on moving forward in that direction we would eventually find the answer but thing is there is lot of back and forth we are doing and essentially for every single character in the worst case we might have to do like big of n Square work in order to solve this problem which is lot of work needs to be done just to solve this problem and this is actually a very simple problem to solve so now let's quickly see the optimal solution for this one so now let's try to see that what would be the optimal solution to solve this problem and for that we will have to understand just couple of things that what are the exact checks we are making number one thing we are checking is that at any given moment we identify that any particular opening parenthesis exist this can only be valid if further down the road we identify that there exist some closing parentheses okay and same way if we identify some closing parentheses this can only be valid if there exist a subsequent opening parenthesis presented in counterpart towards this one if there does not exist any which means this is one of the invalid ones so using these two conditions what we need to do is for every single opening parenthesis we need to keep it stored somewhere that there might be a closing parenthesis somewhere down the line and the moment we identified some closing parenthesis we will have to check that whether there exist an opening parenthesis immediately before that that is going to match with it so a very good data structure in this case would be stack to solve this problem why because stack has the property of last in first out that we are going to use at at its maximum to solve this problem and let's quickly understand that what I mean now the thing is through stack we would be we would be able to tell that which uh parenthesis is invalid but the thing is we would still need to recreate this entire string in order to solve this problem so what we can do is the moment through stack we identify that any particular indices is invalid whether opening or closing parenthesis we can just simply create maybe like a hash set or some other data structure where we we are simply going to keep track of all the variables or all the index positions that are invalid this is this will help us to build the rebuild the entire string after we find out all the invalid parenthesis okay and the logic we are going to apply is that for a stack uh if the moment we identify that there exist an opening parenthesis we are going to push the opening parenthesis down the stack the moment we identify a closing parenthesis we are going to check inside the stack that whether there exist an opening parenthesis to counter this closing parenthesis if it does we are simply going to pop that parenthesis out so marking that this entire pair is going to be considered valid now for some PEC case we identify that there exists a closing parenthesis but there is no opening parenthesis then this needs to go to the set because this is an invalid entry and using this logic we would be able to solve this problem quite easily so let's quickly see the solution that I'm proposing okay and also let me quickly Mark the all the index positions and also initialize a hash set where we are going to store all the indices okay so very first element is a lowercase English letter element so we will just move forward now we identified a closing parenthesis so now the moment we identify a closing parenthesis we will need to check inside our stack that does there exist an opening parenthesis currently the stack is empty because the stack is empty this is an invalid position so so we are going to Mark the index position inside our set as one next we will move on towards the next element this one is also a lowercase English character so we move forward this is an opening parenthesis so opening parenthesis has to go into the stack so we are going to Mark its index location inside the stack so we identified value number three over here okay next is also a random character now this one is also a closing parenthesis so closing parenthesis we check that whether in the stack do we have do we have any entry and yes we do so we will actually pop this element out so we pop this element out currently stack is empty now because stack is empty we also identified that there exist an opening parenthesis so or sorry a closing parenthesis and we once again needs to check into the stack but stag is empty which means this is also an invalid character so we are going to mark five over here we get once again we can ignore this one now this one is an opening parenthesis so we enter over here once again opening parenthesis so once again we enter into the stack we can ignore this one now this 10 is also a closing parenthesis so for the closing parenthesis we can pop one value out so we pop eight out uh from our stack but the thing is in our stack we still have value number seven left which means that this value number seven is also an invalid stack because we we just run out of all the characters in inside the string so we have an extra opening opening parenthesis as well that we need to remove so we can mark this value and now if we remove this character one uh five and seven from our existing string we would get our string that looks like this where the values are going to be valid and this is what we need to return return in the answer so basically we can very easily solve this problem using the stack if we see time and space complexity time complexity is going to be bigo of n where n is the number of characters that are present inside the stack and space complexity is simply going to be bigo of n as well because we are using an extra stack and also an extra hash set to store bunch of different values okay so now let's quickly see the coding solution for this one so coding solution for this one is quite straightforward first we initialize our hash set and our stack then we simply iterate over the given string uh and for every single character we first check that if the given character is an opening parenthesis we push it down the stack if it is a closing parenthesis and if the stack is empty which means we identified an unexpected closing parenthesis so we simply remove add that uh character to our remove indices hash set that we have created add its index position uh and if that is not the case we simply pop the element out of the stack because stack already has an opening parenthesis this is what it means now in the end after this uh particular Loop has ended we would have taken care of all the unexpected closing parentheses that were present present but we still have to take care of the opening parenthesis and they would still be present as unmatch opening parenthesis inside the stack so any single element that is present inside the stack we simply uh take them out and work on and add them to our headset as well in the end we simply need to build a string in order to generate the answer so for that we remove all every single character that are present inside our head set uh and then just create and upend the string that is that was already given to us in the input and then we simp return that as the answer so this is the whole solution let's try to run this code and our code works as expected so no issues with that let's submit this code and our solution is pretty fast compared to a lot of other Solutions once again the coding solution is present inside the description of the GitHub link that I have provided below this video so you can go and check it out from there thank you this is a lead code easy problem and also one of the most like problems on lead code uh and that is because this problem actually solves one of the very real life application where a compiler has to check that whether the code has valid parentheses or not and so that's why a lot of companies like to ask this problem as an interview question uh if we understand the problem basically we are given a string s that contains just these three types of parentheses opening parenthesis and closing parenthesis and we need to determine that if the given input is actually a value valid input or not we are also given the definition that what counts as a valid input that if the opening brackets are closed by the same type of closing brackets and also we are told that the opening brackets must be closed in the correct order so let's try to understand this with some examples over here I have drawn a bunch of different uh potential or examples and we will see that if they are valid or not so first of all if we see this example we know that okay we have two closing two opening brackets and we have two closing brackets we can consider this as a valid string so I'm just noting it it as V now again in this case we have two different types of opening brackets and we have two different time types of closing brackets so this is also valid string now in this case uh this is an opening bracket this is an opening bracket we have corresponding closing brackets again we have opening and closing brackets and again we have opening and closing brackets so everything is in order and the same kind of brackets are opened and correct in proper shape and size so we can consider this also as a valid format now if we can come to this example this is an opening bracket this is also an opening bracket but we only have a closing bracket for this original opening bracket so we can consider this as invalid option so we get an idea why it is invalid in this case we have three opening brackets and only one closing bracket so again this is an invalid uh string and in this case actually if we see the number of opening brackets and number of closing brackets they are actually same so we have one opening bracket and one closing bracket again one opening bracket and one type of closing bracket but this is still invalid why it is invalid because this bracket this curly bracket bracket is actually opened before this particular round bracket so that's why it has to be closed before this round bracket closes and in this case this round bracket actually closes first before this curly bracket is being closed so this is very important property that we will have to keep track of and that is why we are told that we need to keep track of the order in which they are opened and closed and then only we can determine that whether they are valid or not so this is also an invalid uh formula so let's see that what would be the potential solution what so let's start from the very simple example and see that what would be the intuition behind building a solution suppose we are given an example that looks like this where we are given all of the brackets that are of the same kind and we are given some opening brackets and some closing brackets well we can clearly see that this is a valid approach and how we can determine is that we can actually create a counter and what this counter does it that any at any given moment we identify an opening bracket we are actually going to increase the value in this counter and at any given moment if we encounter a closing bracket we are actually going to decrease the value in this counter and at the end we have to check that whether the value inside this counter if that is equal to zero which means we can determine that the same number of opening bracket and closing brackets are present and then we can say that the string is actually valid if that is not the case we can say it is invalid so if we see that in action first of all we have three opening brackets so we will increment the value of this counter three times and if we do that we will get the counter value to be at three again now we identify a closing bracket so now this value from three becomes two again we identify two more closing brackets so again it go it gets decreased two more times and then we get the final counter value to be zero and because we get this value as zero we can say that okay this string is actually valid string and the same number of opening and closing brackets are happening so this is one way to identify a solution but in this case the complexity is actually very simple why because we are only using one kind of opening and closing brackets in our original problem we problem we are actually told that there are three different kinds of opening and closing brackets and we will have to keep track of them also we need to keep track that in what order they were opened and closed and that order also has to be maintained so it is not just as simple as keeping track of counter that we create three different counters for all single typ one of them and then we see that at the end whether this value is zero or not we also have to keep track of that what is the order they were opened in and they were closed in now for the optimal solution we know we need to take care of two things first thing is we need to check that whether the opening and closing number of brackets are same for each three different types of parentheses or not second thing we have to take care is that what is the order in which they are opened and closed so first let's tackle the first problem we know that for every single opening bracket there has to be a closing bracket and they are always in pair so now to quickly look them up we are actually going to use a hashmap now inside our hashmap we are actually going to have all of these closing brackets as the keys and their opening brackets as corresponding values so we are going to have three entries now we have to take take care of their order and number of occurrences so the idea is we are actually going to use another data structure called stack and the stack is actually going to be very helpful to us so let's try to understand this with an example that how we are going to use a stack over here suppose we are given an input that looks like this okay so I'm going to show you two examples um on how we are going to solve this problem so first let's take this example and the idea is that at any given moment we identify an Open Bracket we are going to add that value inside our stack and at any moment we are and going to encounter a closing bracket we are going to pop a value on from the stack and then we are going to see that the whatever the value we popped out if that is the same value that is for any given uh hashmap value we have inside the string for this that particular closing bracket so let's see that in the action first of all we identify these three opening brackets so we are going to add all of the entries inside our St so first we will add a curly bracket then we will add uh these two brackets once we are done with this one now we have a closing bracket our hand the moment we identify a closing bracket remember we will have to pop the value out of our stack so we are going to pop the value out of the stack and the value we have popped out is actually this one now for this closing bracket we are going to see that what is the value of that bracket inside our hashmap and the value of that bracket is also like this and we are going to compare these two elements that whatever we took out from the stack and whatever we got from this hashmap and both are same so because both are same we can say that okay we are good so far and now so far we have actually uh taken care of these four elements and now we are on this element again this is also a closing bracket so because this is also closing bracket we will have to pop a value out and we are going if we pop a value out we will get a value that looks like this where that we are arrived from our stack and now we are going to check that for this particular bracket that we were iterating over what is the corresponding value inside the hash map so the key is this one and the corresponding value is this one so the value we found from our hashmap is also this one and they both are same so because they both are same we can say that okay we are good up until this point now we are iterating over this curly bracket so we again pop and also I have forgot to uh delete this value now again we pop out a value from our stack so now we don't have this value over here and we have a bracket that looks like this again for this closing bracket the value inside of our hash map is also an opening curly bracket and both are same so we are good up until this point now we are only up to last two characters so this is also an opening bracket the moment we identify opening bracket we will add an entry to our stack and now this is a closing bracket so again we will pop this entry out after popping this entry out so this is the value we popped out from the stack and then we will compare from our hashmap so the value is this one and both are same so we are now we are at the end of our string and because we are at the end of our string we are going to check that whether inside the stack we have entry any entry or not we don't have any entry so we can return true in this case and we can say that the given string is actually valid and this would be the answer now uh let's take one more example exle where the string is not valid and see that what we are going to encounter in this case suppose we are given a string that looks like this so in this case we have two opening brackets and one closing bracket so first of all we identify that this is the opening bracket uh we are going to add an entry over here again we encounter an opening bracket we are going to add an entry over here now we encounter a closing bracket the moment we encounter a closing bracket we are actually going to pop out the value from our SEC and the value we popped out is actually a curly opening bracket now for this closing bracket we actually have a corresponding value inside our hash map that looks like this one now these two are actually not same so the moment we identify that these two are not same we can immediately return that this string is actually invalid and the parentheses are not in correct order so we we are done with this one time complexity is actually going to be big go of n where the N is the number of entries present inside the string and even in terms of space complexity because we are using a stack and hashmap but we don't care about hashmap because it has finite number of ENT but for the stack the values will be dependent on big of n as well on the number of entries present inside the string now let's move on to coding so first of all we are going to initialize our hashmap and inside the hashmap we are going to store the values for three different brackets that we are given we are done with this one now we are going to initialize our stack and we are going to name it as stack as well and now we are going to run a for Loop across the given string so first of all we are going to initialize a character C and that is to keep track of whatever the character we are looking over inside the given string now we are going to check that if the current bracket is opening bracket or closing bracket which means that if the key value is present inside this mapping bracket then we can Define that it is a closing bracket if not then we can Define it as an opening bracket so if the value is not present inside this ma bracket key which means that we will have to uh push the current value inside the stack if not which means that the value is actually a closing bracket and then first of all we are going to pop the value out of our stack and then we are going to compare it with whatever the value pair inside the map bracket we have and if the stack is empty we can return false immediately so in the lse condition we check that if the stack is empty we can return false immediately if not we are going to pop out of the pop out a value from the stack and we are going to name it as top element and now we are going to check that whether that is the same value that is present for the map bracket value key and if the values are not same we can return return false immediately as well and if that is not the case eventually if we get out of the loop then we will have to check that whether the given stack is empty or not if the stack is empty we can return return true or else we can return false let's try to run this code okay seems like our code is working as expect expected let's submit the code and our solution is actually pretty fast compared to a lot of other Solutions uh so I would be posting this in the comments so you can check it out from there thank you hello friends hope you're having a fantastic day today so once again we are going to do an awesome lead code problem that is extremely popular at all sorts of it companies so without any delay let's get started so the lead code problem we are going to solve today is called largest rectangle in a histogram this is a lead code hard problem and also an extremely welllike problem now the statement is quite simple and straightforward we are given an array of integer called Heights that represent the histograms bar height and we are also told that the width of every single bar is one now we need to return the area of the largest rectangle that we can make inside this given histogram so this is all we need to return and now let's try to understand this with an example so for this we can make a rectangle that looks like this now the area of this rectangle is going to be two because the width of this portion is 1 and the height of this portion is two so 2 * 1 is going to be two so same way there are multiple different options we can have in order to generate the area but we need to find the maximum area and in this case the answer would be retrived using these values where if we make a rectangle like this using these two bars so now in this case the area is actually going to be 10 why because the height of this portion is five and for this one the width is 2 so 2 * 5 is going to be 10 so this is what we need to find and this is what we need to return so Brute Force approach is actually quite straightforward and very simple now one thing we can do is that we can take this one single rectangle uh starting at position zero and then we can see that what are every single possible areas we can make so one area would be like this second area would be like this the third area would be something like this uh fourth area would be something like this and so on and so forth and eventually we do all every single possible combination uh based on every single position of the given rectangle bar height and then eventually we would find a solution like this that contains the most optimal approach and this solution would work fine we would be able to eventually find the answer but the this is going to work in big of n Square time because at every single time we are doing lot of extra and overhead work so what is the most common thing we can imagine well number one observation we can make is because we can see that the height for this zeroth index is two at the moment but the moment we want to consider this first index as in combination with this two then the maximum height we can imagine is only going to to be able to one which means we are only at the higher height until we encounter a height that is lower than our current height and whenever that happens we will have to start considering the lower height and we need to understand couple of things if we want to calculate the area we need two items first item is the height so we already know that which height are we going to consider based on the lower height compared to all the other possible Heights that is uh number one observation second observation is we need to consider the width so so width we can simply calculate based on the current index position where we have or we can also keep track of that where did that height started existing that in terms of finding the right side boundary of any particular rectangle we can only find it until we find a lower height that reaches so there are actually three examples we can see very easily first example is at this position number two or this uh initial first position where the current height is two and the current height is located position number zero but the moment we try to consider the next element we will have to get rid of this height too because now it is no longer in the existence which means the maximum area we are being able to generate using this bar two is only going to be two okay now next thing another example is we just saw with the value number five that with value number five we can only say that we can use rectangle five or bar five until we reach to this index position number four and then so which means maximum area that this bar five can make is going to be of width two and height five so total is going to be 10 same way for the six six comes into the existence at index number three but since the height at index number four is actually lesser than the index number three which means this six only remains in existence just for one single bar so the maximum area we can make over here is all is only going to be of uh size six and this is the whole logic this is the whole meat of the solution now after understanding this we can actually make a suboptimal solution using the same very simple approach and then we will try to improve upon that solution so the sub suboptimal solution that I'm proposing is that at every single position we identify that what its right side boundary is and what its left side left side boundary is so what is the maximum height and width we can make and based on that we can do all sorts of calculations and then find the solutions very quickly so let's try to see this solution in exist in action the idea is at this position the maximum left side height we can make is to the maximum right side height we can make is also going the maximum width we are able to achieve is one which means the maximum area we can generate is only going to be two for this position number one the maximum width we are able to achieve is going to be six because this one remains in existence throughout this whole process and the maximum height we can achieve is only going to be one so over here maximum area we can make is only going to be six now at this five the maximum left side we can go is only up to 2 because it starts at position two the maximum in terms of right we can go is only up until position four or before position four so up to two and three so width is going to be two so over here we can make the area 10 for this height six we can only make the maximum height as six same way at this position number two the maximum we can make is actually going to be this much where currently the width is going to be uh four and the height is going to be two so maximum area we are able to generate is eight and same way at this three the max maximum we are able to generate is simply going to be uh just just this one because one before that is actually in the Lesser height so we can maximum area we can make using only or or the entire height of this area is going to be three and in the end we can simply return return 10 as the answer so what we did is for every single element we try to see that what is the left limit what is the right limit and what is the total area we are able to generate and then we can very easily store the answer now this solution would just be good if you provide this solution in an interview it might even work but the thing is there exist a better solution where if we just use stack to keep track that what is the current index position and until what previous index positions we are maintaining that height then we can very easily solve this problem why we need to use the stack because think about it for every single position we are only going to have that position in existence until we find another bar with a lower height which means the moment we find another bar with a lower height we can actually go back to the elements that are already present inside the stack with the higher height and calculate the area that's it that is the whole logic so now let's try to see the solution I'm proposing in action so now let's just quickly initiate our stack now inside the stack we know that this is going to operate in the in terms of last in first out principle and one the other thing is we can actually keep track of the bar Heights but then we would also have to find that what was the initial position of that this particular value so rather than a better approach is that we actually store the index values and using the index values we can quickly look up that what has been the bar height at that position in big go of one time because we already know the index position and then we would be able to also calculate the width depending on the current index position and the existing index position inside the stack so let's try to see the solution in action so initially stack is empty okay and we are also going to have an a variable where we are going to store the area so let's just mark this one as Max Max area that we have been able to calculate so far okay so initially stack is empty now we are at this index position number zero so we add index position 0 inside our stack okay and currently we know that this height is two now next thing is we iterate over to the next element and we identify that currently we are at index position one so the height at index position is actually less than the height we currently have on the element that is already present inside the stack which means this position of this element two is no longer relevant because we found out a value that is lesser inside the in in its existence which means this only exist until this portion so we will try to we will pop this element out and we will calculate the possible area that is that this element has been able to generate So currently for this first position this has been the area it is able to generate that area is going to be two that is the height and multiplied by width that is one so the maximum area we have so far is two okay now once again uh we are going to add value number one inside inside our stack saying that currently one so the the height of this one is also one and currently we we will only pop one out when we either reach to the end of the array or so or end of the Heights or we find some place where the height is actually zero and then we have some more elements okay so this is always going to be relevant in this example now we are at index position number two so notice what happened at index position number two the height suddenly increased compared to what the height we already have which means this one is still valid so because it is still valid we are going to keep it inside the stack not popping it out and we will add one more element five or the this index position two on top of the stack because now this is also relevant so far so we are going to put two inside the stack so its subsequent value is bar height five then we are next we identify height six which means this five is still relevant so because is relevant we are once again going to add value number six on top of the stack or soorry not value number six but the index position of six which is value number three so we put value number three inside on top of the stack and the height is six now we suddenly encounter the value uh at index position number four that is height two so any single value that has greater than two height has to be popped out of the stack because now that is no longer relevant which means for first of all this six is now no longer going to be relevant because the height is six and currently this index position is three and notice that the index position for this bar height two is four which means depending on the index position difference we can actually calculate the width for which the six was relevant so six was currently relevant for width one so currently let's pop six out if we pop six out currently this three is no longer present we know that this was relevant for one width which means width was one and the height was six so now the maximum rectangle we have been able to find is of size six which is greater than the previous maximum we had so we are going to update that okay now are we done no because this is two and this value is five which means we would still have to pop one value out if we pop one value out in this case now notice that the height at this position is two and the height at this position is four so because this is a greater position compared two over here so what is the width we found the width is actually two and what is the height we have is five so this is the height and also let's get rid of this two from our existing SE okay and now this area is going to become 10 so let's just add an area 10 now once again uh we this we have this element one and currently this element is two so 2 is greater than 1 so because 2 is greater than 1 we are not going to pop one out because this one is still relevant so we are just going to Simply add two on top of one so let's just quickly add this index position number four with the height two okay and now currently next one we found the increase inside the height which means this two is still relevant because this two is relevant we are simply going to add an element five on top so we are going to add element five on top now adding index position number five now we reach to the end of the array which means the moment we reach to the end of the array we will have to start popping every single value out compared to its current position so currently we pop value number five out which means what is the height over here the height is three what would what would be the width width would only be one because it is only relevant for this one portion because currently we are at the end of our Loop so the area we have been able to calculate by popping this uh value number three out is going to be three now currently three is less than uh value 10 which is the maximum area we have so we are not going to update the maximum area okay now we are going to next uh pop out element number four so if we pop element number four out it has been relevant for this much portion of the time which means currently we have 2 multiplied 2 so the area is going to be four 4 is also less than 10 which means this area is also not relevant and last one we will have to pop element number one out that has the size one or the height one so for this height is going to be one and this has been relevant since position one until the very last position so this has been relevant for the width five oh sorry for the width six since the very first position it has been relevant so now because this has been relevant since uh position six so the maximum area we have been able to generate is also going to be six but still it is not greater than the maximum area so after the end of this Loop we can simply return the max area to be 10 and that's it that's the whole answer now if we see time and space complexity in this case the time complexity is going to be big of N and the space complexity is also going to be big of n so the coding solution is actually quite straightforward first we have a variable called Max area where we are going to be storing the maximum area we have been able to identify so far then we have our stack that we initialize and we also have a variable n the for the to store the length of the given array then we have for Loop to iterate over the given array now first we check for a condition that if the if the given I is equal to n which means we have already crossed every single element then we can mark the current height as zero because this is to take care of the last element if that is not the case we simply take the value of the given subsequent height height from the heights array okay now we have our while loop where we check that while the given stack is not empty and and the current height that we have been able to identify for any given I element is less than the current height that is already present inside the very first element of the stack then we will have to calculate the area for that uh where we simply calculate the height based on by popping the element out of the stack and then we calculate the width by uh subtracting the value of the current I minus the current element that is that was present inside the stack minus one and then we calculate the max area where we compare two elements based on the given Max area that we have been able to identify so far and the given current height and width multiplication or the current area that we have been able to identify whichever is greater we are going to keep it that and in the end after we run out of this V Loop we are still going to push the current element inside our stack and by the time we are done with all the elements we should have our maximum area being populated with the correct value and then we can simply return that so now let's try to run this code okay seems like our solution is working as expected let's submit this code and once again our solution runs beautifully extremely fast in terms of time and space complexity so once again the solution is present in the GitHub repository the link is in the description so you can check it out from from there thank you hello friends hope you're having a fantastic day today so once again we are going to do an awesome lead code problem that is really popular among tech companies for the interviews so without any delay let's get started so the lead code problem we are going to solve today is called longest valid parenthesis and you can see that this one is a lead code hard problem and also an extremely welllike problem on lead code the problem statement is actually quite simple where we are told that we are given a string that contains just the characters opening uh circular bracket and closing circular bracket and now we need to return return the length of the longest valid parentheses substring suppose we are given a string uh like this now we can see that all of these are actually valid substrings because they are coming in correct order so in this case since all of them are correct we can say that the longest sub substring that is valid is currently of six characters same way let's try to take one more example suppose the string we are currently given is something like this then we only have a valid valid substring that is only valid for just two characters and these two are not part of the valid substring so okay so we need to calculate that what is the consecutive longest valid substring and we need to return that now Brute Force approach logically we are going to do the most simplest things possible where we are simply going to check that uh for every single substring from starting from any particular string we are going to check that what are the longest substring we are able to generate until we encounter some invalid substring so overall this approach is a very simplistic approach that would work fine and generate the result but the issue is this would operate in big of n Square time so we need to find some way to shorten this calculation and in a single go we need to identify that what are the current substring that we have been able to find is it valid or not and if it is valid what is the current length what is the maximum length we have been able to identify and subsequently when will at what point does it stop becoming valid so these are the questions we will have to answer uh and then only we can find the optimal solution so now let's start looking about that what an optimal solution should look like suppose this is the string given to us as an input and now we are trying to find the solution now let's try to make some understanding clear and that would help us build our solution number one thing is the moment we identify at any given moment that there is a closing circular bracket and we haven't found the opening circular bracket which means we can directly ignore this case because this is definitely invalid because it does not have any previous opening curly bracket that is number one observation number two observation is for any single opening curly bracket we will need to keep this information stored somewhere that we have one open bracket for which we are trying to find a subsequent close bracket so it can come over here or maybe here or maybe it cannot be possible but we will need to have that information so these are the two pieces of information we will have to consider third thing is it could be possible that we may find some existing valid uh sequence like this but this may not be the longest valid sequence because longest valid sequence in this case is probably going to be this one so which means we will have to keep track of the current sequence and we will also have to keep track of the valid sequence and also the longest sequence considering all of these things it would make really good sense to use stack data structure for this problem and why are we using stack because if if we have to consider this to be valid then immediately before this there has to be an Open Bracket then only we can see that this is a valid scenario and then this bracket would not be considered which means this still needs to live inside the stack because stack follows an awesome property of last in first out that is going to be greatly helpful to us so now using stack we would be able to solve many different problems and the idea is that for each of this position rather than just storing whether it's an open or curly bracket we can actually store the index values so let me write down the index values and now the thing is inside the stack we will only push values when we encounter some Open Bracket because it could be possible that some time in the future there might be a closing bracket so and whenever we identify a closing bracket we will try to see in the stack that whether there exist any particular uh bracket that we can pop out if it does then then it would be part of the valid sequence if it is not there then we will see all sorts of scenarios okay so I hope that all of these explanation makes sense and now you are able to understand that how we are actually going to use the stack for our solution so let's quickly generate the stack now we are going to keep track of few variables so first one is that what is the current length we have been able to find next what is the maximum length we have been able to achieve now in order to keep track of the current length we will have we will need to know that where does the current valid substring starts so initially because we are actually using this as zero so initially our starter pointer needs to be somewhere over here before zero because we are starting the index from zero because imagine a scenario where we are only given an input like this which means this is 01 So based on the index location we know that this is actually a valid substring of size two but because we are starting the index from zero so we will actually create cre our initial starting pointer from minus1 so it would be very convenient for us to calculate these values okay and you will understand the logic once we iterate over the the example so initially our starting pointer is going to be located at minus one position and this is where our starting pointer is okay so now let's quickly start iterating over the solution so logically first here we identify that this is a closing bracket for closing bracket we will have to pop one element out from the stack but the thing is currently stack is empty so because stack is empty this has to be an invalid entry so we can ignore this case and move on to the next element but when we move on to the next element we can say for sure that this is never going to be part of the uh valid substring so we will need to update our start pointer so now we will have our start variable uh being located at position number one so let's just mark start variable at position number one current length is zero and maximum length is also zero we haven't been able to find any values okay so let's just Mark these now we encounter an opening bracket so the moment we encounter the opening bracket we are going to be pushing the values inside the stack so let's mark the index value same way once again we identify an opening bracket so once again we are going to Mark a value inside the bracket and when we are opening the brackets we don't need to update the current length or the maximum length because we haven't find any valid substring so far okay now we identified one closing bracket so the moment we identify a closing bracket we will have to pop element out of the stack so let's try to pop one element out of the stack if we pop this element out of the stack by the way this is this has to be number two okay by the way so number two index we are popping out of the stack which means that currently that what has been the current length we have been able to identify it so far that is currently we are at element number three the element we popped out is located at element number two which means now this is no longer present over here which means currently we still have one element that is left inside the given stack so so far we can do the difference between this current element and the element that is already present inside the stack using the peak function so the difference is 3 minus 1 so so far we have been able to identify a length of two size valid string so let's update the value that the current valid string that we have been able to find is of size two and the maximum length we have been able to identify so far is also of size two now notice that we are not using the start variable right here uh because this is still not taken care inside the existing valid substring so that's why as long as there are some values present inside the stack we cannot conclude that stack is empty and we have taken care of every single substring so that's why start pointer is still going to remain here so now let's move on to the next element now we are at position number four once again we identified the opening bracket so let's try to add one more value inside our existing stack so now the value is four okay now once again we identified a closing bracket so the moment we identify a closing bracket we will have to pop one element out so let's quickly pop this element out now the element that is currently left inside the string is of size one so because this is of size one and the current element we are at is of size five which means the current substring that we have been able to find is 5 minus 1 so this is going to be uh four so current length that we have been able to find the current maximum length is of size four and because this is of size four which means we will also have to update our maximum length as well and that is also going to be of size four okay now currently inside our stack we only have uh one element that was that has been here for quite some time and now let us also try to move to the next element so once again we identified one more opening bracket so we will try to put element number six inside the bracket now once again we identified the opening brackets so we will try to put element number seven inside the bracket and now at element number eight we identified and by the way this current length would be res uh reset every single time we update the value okay so this is always going to be reset because we don't know that what the current length is we only Define the current length based on the value we pop out so now this is a closing bracket which means we will have to pop one element out so now we are located at Value number eight we popped element number seven out which means we still have one more Open Bracket located at element number six that we haven't taken care of so now we will do the difference between 8 6 and the value is 2 so current valid length that we have been able to identify is of size 2 but that is not greater than the maximum length we have been able to achieve so we are still going to mark this as value number four so this is the logic on how you can actually use stag to solve the problem now let me just show you one more example very quickly uh and then we will uh move to the coding solution basically this is the optimal solution so now let's just quickly start using the logic So currently we identify an opening so we are going to mark value inside the stack we once again identify a closing bracket so once again we are going to pop this element out of the stack the moment we pop this element out of the stack and currently the stack is empty if the stack is empty then we will have to we found a valid string from the starting value so we are going to do the subtraction between the current value minus the starting value which means 1 1 so the answer is going to be two so the current length that we have been able to identify is two and the maximum length we we also identified is also two okay now once again so far remember this s is the starting value is still going to remain here but now we identified a closing bracket but for this closing bracket we don't have any value inside our stack so because the stack is empty which means this is an invalid portion so now the starting value has to jump so now we are going to jump our starting value to start at this element number three okay now this at this element number three we identify an Open Bracket so we are going to add value number three over here once again for four we identified a closing bracket so we will pop an element out of the slope So currently the stack is empty if the stack is empty so now we are uh located at this position number four and by the way our starting position should be at this position number two okay so now uh currently we need to because stack is empty we will need to do the difference so the difference between Uh current index and starting index is going to be 4 minus 2 so value is 2 so this is the current length we have been able to identifi and this is for this portion so now maximum length does not need to change once again we identify an Open Bracket so we are going to add value number five over here and once again we identified a closing bracket so now we will have to pop this element number five from the loop as well so currently the string is empty because the string is empty we will have to do the current value minus X so it's going to be 6 2 so once again and the current length we have been able to identify it is four so the current length needs to be updated this is going to be four and because this is greater than our maximum length so we are also going to update this one and because we reach to the end of this given string so we can return the maximum length as four so this is the whole logic that we can use to solve this problem and by the way if we see time complexity in this case the time complexity is going to be simply big off n because we are simply iterating the given input array just once if we see space complexity because we are using an extra stack we will it will also going to be big of and so the coding solution is actually quite simple first we have a variable to store the maximum length then we initialize our stack and then we initialize the first value inside the stack as minus one this is going to be our starting pointer okay then we have our for Loop to iterate over the given string s uh character by character we check that whether the given string if that is an opening bracket or a closing bracket if it is an opening bracket we simply push that index position into the stack if that is not the case then there can be couple of scenarios so in either scenario first we will have to pop the element out of the stack now after popping element out of the stack if the given stack is empty then we need to push the current index as the base for the next valid substring and uh if that is not the case then we are going to calculate the maximum length so for maximum length we are simply going to to do the max to compare the current maximum length minus I minus the peak that is currently present inside the stack and this is going to be give you give us the current length that we are dealing with and in the end we simply need to return whatever the max length we have been able to identify so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs extremely fast and this is a very good time and space complexity so once again I will be posting this solution in the in our GitHub repository so you can check it out from there the link is in the description thank you hello friends hope you're are having a fantastic day today so now we are going to do an awesome stack problem that is a actually a lead code premium problem so this is going to be really interesting very popular question and very interesting subject so without any delay let's get started Okay so the lead code problem we are going to solve is called Max stack this is actually a lead code hard problem and the thing is because this is a lead code premium problem uh I took this description from another website called Le code. CA so thank you so much to whoever maintaining that that website now we need to design a Max stack class that supports these five functionalities now if we see the functionality the first three are pretty common where we are pushing an element down the stack where we are popping an element out of the stack and where we are uh just checking what is the Top Value inside the given stack these three are the common functionality of any particular stack then we need to add two more methods where first one is a peak Max method uh and second one is the pop Max method so if we do the peak Max method we will need to know that what is the maximum element currently and if we do pop Max then we will have to pop the maximum element that is right now inside the stack outside so let's try to see the solution for this problem so logically uh let's assume that currently we have an empty stack okay so we have the option to use five operations and so let's try to First quickly push some elements inside down the stack so if we let's push value number three and then value number five and then value number one okay so now currently we push a few elements now if we want to pop and let's just add one more now if we want to pop we can pop one element out as well so if we do the pop operation then we will we won't have value number seven now we can also do a peak operation so if we do Peak operation then we can simply check that what is the very first element so answer of this is going to be one then if we do if we want to do Peak Max which means we should see that what is the current maximum element present inside the given array which means the current maximum element present inside the given array is actually value number five even though it is not at the top of the the stack this is the current maximum element so this needs to be value number five and if we have to pop Max then we need to pop the value number five out of the stack not value number one even though one is the very first element so this is how we will have to design this algorithm and design data structure in order to keep these values now we know that completing these uh items is very simple and very similar no issues with this one this is a regular stack functionality and every single language like language like Java python C++ they have they all have their own stack versions that we can simply use the problem comes when we need to do this peak Max and pop Max problem uh operations because the thing is this is actually slightly complicated because of variety of reasons now the very first thing that comes to our mind is to have a variable called Max where we are going to store the maximum value that we have been able to identify inside the given array and this should make our lives easier this is the Primitive logic we can think of where let's assume that we add value number one so we need to update the value of Max to Value number one then once again we add value number six so we once again because 6 is greater than one so so far the maximum element we have been able to identify is six then we have value number three so three is not greater than the current maximum element which means we don't update anything or we don't do anything now after this uh let's say we add value number eight so once again the maximum element needs to be eight so so far you must be thinking that hey this seems pretty convenient why don't we just have one value to keep track of the maximum element and at any given moment I want to see that hey what is the maximum element I can just simply look at this variable and find the answer the problem is when we do the pop operation out of this given stack then there would be an issue because now let's say that I decide to pop this eight so if I do if I pop this element 8 I know that now 8 is no longer the maximum element present inside the stack but I don't know what is the other element that is the maximum element but instead of just having one simple variable Max we actually need to have a variable another stack called Max where for every single entry inside the original stack for that entry we will have to keep track that what what has been the maximum element that we have been able to identifyed so far and keep updating that list depending on the how we uh push out or pop out the elements from the given stack so let's let me try to explain what I mean the idea is let's assume that for the max we have to worry about two operations first one is the uh Peak Max where we are simply watching that what is the max element that is currently present and second one is the pop Max where we are popping the maximum element out at the current position inside the given array so we have created our own Max stack array uh sorry Max stack so this is our Max stack and this is our regular stack okay now let's assume that I wanted to enter value number one so what I'm going to do is I'm going to add value number one currently this Max stack is also empty so so far the maximum element at this position I have been able to find is also one so I'm going to store value number one over here once again I identified Val number six so because value number six is greater than 1 I'm just going to put six as normal value over here but over here because value number six is greater than value number one so I'm going to say that up until this point of the stack the maximum value I have I have been able to identify is six that I have presented over here and some reason if I decide to pop this element out of the stack then I know for sure that this element also needs to be popped out and then the maximum element at this position will be corresponding to the maximum element at this position that is value number one so which is pretty convenient for us now let's try to add one more element let's say three now once again even though we added value number three over here so far the maximum value we have been able to identified up until this point is once again six so we are once again going to mark value number six over here and then once again let's say we add value number eight so once again we are going to add value number eight over here here because that is the maximum value we have been able able to identify so so far let's repeat what we have done we did the push operation in big of one time no issues with that now at this at any given moment we can also do the peak operation uh and the moment we do Peak operation whatever element is located at the top of the stack we should be able to see that so this is also going to happen in big off one time so once again no issues with this one so we already took care of two variables we can also do the pop off operation easily from the stack so pop operation can also be done in big off one time and we can do Peak Max as well in big off one time because this is also being happening or maintaining in constant time so this also happens in constant time so we took care of four operations in big off one time just by simply using these two different Stacks but now the important thing is that how we are going to manage the pop Max operation for that we will also have to do the pop so let's try to First do couple of Pop operations if I pop element number eight out of the given stack which means now stack does not contain eight value anymore and I will also have to update the maximum element up until this point as well okay now at this position let's say I decide to do pop Max so if I do pop Max at this moment I should not be kicking out value number three from the stack because this is not the maximum element so far the value I should be be kicking out is actually going to be the value number six so what I'm going to do is that I'm going to kick value number six out of this given list up until every single point that I have been able to iterate so far and the moment I kick value number six out I'm going to do a peak operation to see that if this given current maximum value if that is greater than the current maximum value I'm left with and if that is the case then I will need to update the given Max element to add in incorporate value number three as well because remember that in the previous state in this state we did not had value number uh six as part of the given uh sorry value number three as part of the maximum value so far but because we did the pop Max we kicked a value number six out and at the same time we will also have to pop these two elements out as well and we would be left with value number three okay so this is the whole thing that we need to do and this is how we can solve this problem using two stacks in order to con convey this message so this is the whole solution and using this we can complete everything in big off one time all five operations so now let's quickly see the coding solution and then things will be make much more sense okay so now since this is a lead code premium problem and we don't have that subscription at the moment I'm just going to explain you the solution in the the notepad but this code would work fine and the code is also present in in our GitHub repository so let's understand the code so first we are going to create couple of inte uh couple of stacks for stack and Max stack now for the push and for the pop and for the top we need to the all of these three are standard operation the thing is pop and top are going to remain the same the only problem is that for the push operation we actually have to push the element in both the places which means in the stack we are just going to push it as a regular push push entry but for the max stack we will first have to check that what has been the maximum element inside the given stack by based on the definition of this x value so far using math. Max function and checking that what has been the current maximum in the max stack versus the current value we are trying to enter so we are always maintaining the maximum element for any given X element inside our Max stack stack okay then for the pop operation we will have to pop the element from both the places Max stack and also from the given regular stack for the top operation we simply have to check that what is the maximum element on our regular St uh stack uh and we can just do a peak operation now for the peak Max operation we will need to do the same operation but now this time in our Max stack stack rather than our regular stack and the last one is the slightly more complicated method that is the pop Max method where first of all we are going to initialize a new stack called buffer because remember uh the the value we are trying to kick out is presented somewhere in the middle in the regular stack so meanwhile we don't find that value we will have to buffer that from our regular stack so that's why we are going to push every single element uh from our normal stack to the buffer stack until we until we find the top element to reach to the Max and then we will simply pop that element out from the regular stack at the same time we are also going to pop that element out from our uh Mac stack as well and then in the end in inside the buffer we are also going to push all of those elements into our regular St stack using the elements that we just stored inside our buffer stab temporarily so that's why this pop Max method is slightly complicated method and uh you can see the coding solution present onside our on our GitHub repository so hopefully this explanation made sense to you and uh yeah thank you so much
