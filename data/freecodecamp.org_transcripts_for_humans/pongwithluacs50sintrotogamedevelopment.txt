With timestamps:

00:00 - [MUSIC PLAYING]
00:16 - DAVID MALAN: All right.
00:17 - Welcome to Introduction
to Game Development.
00:20 - My name is David Malan,
and this is Colton Ogden.
00:22 - And this is a class that
assumes only a class like CS50,
00:25 - which is the colleges and the extension
schools introduction to computer
00:28 - science but more
generally we just assume
00:30 - that you have prior programming
experience in most any language
00:32 - and therefore have
some comfort with some
00:34 - of the basic constructs of programming.
00:35 - But we assume no background in Lua
or Lab 2D or any of the frameworks
00:38 - that we'll be using in the class.
00:40 - All of that lies ahead.
00:42 - So, if you're like me, you probably
grew up with video games of some sort.
00:46 - And when you maybe started programming,
the programming environments
00:48 - were perhaps very text based, black and
white terminal window, and the like.
00:52 - And maybe you did something graphical
with a language like scratch or Alice
00:55 - or beyond, or if you're
in the world of the web,
00:57 - you've made more graphical applications
of some sort, but still pretty static.
01:01 - The sort of content comes on the screen,
then the content changes, and so forth.
01:04 - And it's a little less obvious if
you're a little newer to programming
01:07 - how you go about creating
some of those games
01:10 - from yesteryear with
which you all grew up,
01:12 - where there's a lot more animation,
there's a lot more asynchronicity,
01:15 - lots of things happening
at the same time.
01:17 - A lot of events happening,
and you all NOT--
01:19 - not only want to capture
this interactivity,
01:21 - but also want to respond
to events that are
01:23 - happening, especially
if you have players
01:25 - elsewhere next to you or online.
01:27 - And so the way the
course will be structured
01:29 - is through a narrative of these
various games, many of which
01:32 - you might have played yourself.
01:33 - But over the course of
the semester, we dive
01:35 - into the context of each
of these games and look
01:37 - at some of the underlying
principles, the constructs via which
01:39 - they were built up, and really
use them as a point of departure
01:42 - for talking about those
various capabilities
01:45 - that you might integrate
into your own games.
01:47 - And then punctuating the
semester, ultimately,
01:49 - will be a number of milestones.
01:51 - Some in the form of smaller assignments
that are meant to reinforce just some
01:54 - of the more recent material and sort of
set you up for success when the course
01:58 - is deeper and more hands on
projects. , Because indeed,
02:01 - the project is where you'll build
or extend some of your own games.
02:04 - And then the class itself will culminate
at the very end of the semester
02:07 - with your very own final project,
an opportunity to propose,
02:09 - to design, and implement a game
that somehow or other draws
02:13 - upon the course's lessons.
02:14 - So that when you walk out of
here in just a few months' time,
02:16 - you've not only played
your fair share of games,
02:19 - but have actually built
several of your own.
02:21 - So without further ado,
allow me to turn things
02:23 - over to Colton for a look and a
stroll through yesteryear's Pong.
02:27 - COLTON OGDEN: Thanks, David.
02:29 - I'm very excited to begin
teaching you guys this course
02:31 - because game development
was actually what got me
02:34 - into programming in the first place.
02:36 - I remember back in 2006 or
2007 buying this book here,
02:40 - 3D Game Programming All In One, which
was a look through 3D game programming.
02:47 - And it was a monolithic text
in the context of a game engine
02:51 - that was popular in the
late 2000s called Torque.
02:54 - It's not as in vogue these days, but
it at the time was pretty popular,
02:58 - and it used a language
called TorqueScript.
03:00 - And I remember reading through
this book and seeing all this code,
03:02 - and I had never seen like
source code at all before,
03:05 - or had ever been
introduced to programming.
03:07 - And, frankly, I found
it quite intimidating,
03:09 - because I was looking at all the
syntax that I didn't understand,
03:13 - and I didn't know anything
about game development.
03:15 - I had always played games growing
up and been fascinated by it,
03:19 - but as I started getting more
comfortable with computers
03:22 - and I started to get
more curious about it
03:23 - and realized that it
was a major profession,
03:25 - I started to dive a little deeper.
03:27 - This was my first foray.
03:29 - And after spending a little
bit of time away from it
03:32 - after looking through the source
code for a TorqueScript, which
03:34 - was rather arcane, a lot of
percent symbols and dollar signs
03:38 - are the weird things that I just
hadn't gotten my mind around.
03:41 - I went back to it, started to really
learn the basics of programming
03:45 - and other languages, like
Python and c and c++,
03:48 - and I grew to really like programming
and computer science a lot.
03:53 - And here's just an image of what
Torque looked like at the time.
03:55 - It was really the sort of
predecessor to Unity nowadays.
03:59 - Although, in my opinion, Unity
does things a lot better.
04:02 - It was more accessible, it uses
languages that are more in vogue
04:05 - and popular and used by other
people already in other domains.
04:10 - And so we'll be covering Unity
at the tail end of the course.
04:13 - So we'll be covering
predominantly 2D game development.
04:15 - But the topics that
we'll be covering today
04:18 - as we get started in the context of
Pong are these bullet points here.
04:23 - Lua, which will be the language
that we're using predominately
04:25 - throughout the course, which is
a dynamic scripting language very
04:28 - similar to Python and JavaScript.
04:29 - We'll be covering LOVE 2D as our
primary game framework, which
04:33 - is a runtime and a framework
which exposes all of its methods
04:39 - for drawing, audio, input, etc.
04:41 - via Lua, so that it's very easy
to write code very quickly,
04:45 - but get very good results.
04:46 - And the documentation for their
framework is superb, in my opinion.
04:50 - Today we'll be talking about
a few just basic principles
04:53 - as we get our feet wet
with game development.
04:54 - Things like drawing
shapes, drawing text,
04:57 - these are both very big
aspects of Pong, which
05:00 - is just a very simple game
based on shapes and text
05:03 - moving around the screen.
05:05 - We'll be talking about Delta Time and
Velocity, which Delta Time is probably
05:09 - arguably one of the
most important variables
05:11 - that we keep track of in any game
framework or engine, which is just
05:14 - the amount of time that's elapsed
since the last frame of execution
05:17 - in our game, measured in LOVE 2D in
terms of seconds, fractions of seconds.
05:22 - We'll be talking about
game state, because you
05:24 - can have a state in your game.
05:25 - You can be at the title screen, you
can be playing, you can be in a menu.
05:29 - This will, obviously, be very important
because you want different update logic
05:32 - and rendering logic depending
on what state you're in.
05:35 - We'll be talking about basic
object oriented programming,
05:37 - for those who might be
unfamiliar coming from C.
05:41 - It's basically a way of encapsulating
our data, any of our game objects,
05:45 - in such a way that the variables
that are relevant to them
05:49 - are put together, along with functions
that will operate on that data.
05:52 - So instead of having like 20
different variables for all
05:55 - these different objects that you
have to keep track of in your code,
05:58 - each individual object can keep
track of all its own information,
06:01 - like its position, or anything
else that's relevant to it.
06:04 - We'll be talking about hit
boxes today, predominantly,
06:07 - in the context of box
collision, because we'll
06:09 - be talking about Pong, which
is just paddles and a ball.
06:11 - Those are all rectangles.
06:13 - And they'll be colliding with
what's called axis aligned bound--
06:16 - axis aligned bounding boxes, which makes
calculating whether two boxes collided
06:21 - very simple, as opposed to
calculating rotated hit boxes,
06:25 - which is a bit more complicated.
06:27 - And then, lastly, we'll
polish off with sound effects,
06:29 - because adding that polished
layer, in my opinion, is important
06:32 - and it ties it all together and makes
it feel like a more cohesive whole.
06:36 - So two important things that we'll
need to do when we're following along
06:40 - with the examples, which I'll show
you a link to the repo in a moment,
06:43 - is getting LOVE 2D installed.
06:44 - It's a very simple process.
06:46 - The first link here is
just a download link.
06:48 - So it's available for all
major operating systems.
06:50 - So Linux, Mac, and Windows.
06:53 - And then the Getting
Started link down here below
06:56 - will give you some tips
as to how to get started,
06:58 - actually running it on your
machine on Mac, iAlias,
07:02 - the actual runtime executable
within the app that it comes with.
07:07 - So in my bash profiles that I
can easily just type love space
07:11 - dot in any directory that
has a main dot Lua file,
07:15 - and I can run it anywhere very simply.
07:16 - And there are similar instructions
located on the page for other operating
07:20 - systems.
07:20 - And this is the repo here,
which has all of the source code
07:23 - that we'll be using today.
07:24 - And I've structured it in a
series of 13 different subrepos
07:28 - so that you can follow along and we can
build upon Pong starting from scratch,
07:32 - going all the way to a
fully implemented game.
07:35 - So the first thing we'll
talk about is what Lua is.
07:37 - We'll be using Lua for
about 75% of the course.
07:40 - It's a very popular
dynamic scripting language.
07:42 - Portuguese for moon, and it
was invented in the early 90s
07:45 - as primarily a config language
and a runtime language
07:48 - for compiled code bases to save time
on adding code to those code bases
07:54 - and recompiling them.
07:55 - A lot faster and a lot easier,
especially in the context
07:58 - of the 90s when computers
were much slower, to expose
08:01 - the core functionality of your
application to Lua so that you can just
08:07 - run it dynamically and then interact
with your compiled code on the fly,
08:11 - rather than having to
recompile and wait minutes,
08:13 - potentially hours, just
to get some new behavior.
08:19 - It's a language that's focused
around the concept of a table.
08:22 - Almost everything in Lua aside
from basic variables, are tables.
08:26 - A table is essentially a dictionary
in Python or an object in JavaScript.
08:30 - Very similar.
08:31 - Intent, for embedded use
in larger applications,
08:33 - and the very nature
of Lua intended to be
08:37 - used in the context of
these large applications
08:39 - meant that it was perfect for
interacting with game engines.
08:42 - Because game engines are a
perfect example of code bases
08:44 - that are traditionally compiled
code for speed purposes.
08:48 - But it can be very cumbersome to
have to add minor functionality,
08:52 - and then recompile it and potentially
have your whole studio take hours.
08:56 - So we'll be using Lua and a
compiled game framework, LOVE 2D,
09:00 - to allow us to rapidly develop.
09:03 - It's similar to JavaScript and Python.
09:06 - A little bit more so to JavaScript.
09:09 - And it's very excellent
because it was initially
09:11 - intended as a config language,
and a-- just sort of a glue layer.
09:15 - It's very good for storing data and
code together, almost one in the same.
09:19 - So LOVE 2D is a fast 2D game develop--
09:24 - development framework.
09:25 - It's compiled in C++ and
it runs very efficiently.
09:28 - Because it's so simple, despite the
fact that we're running it in Lua,
09:33 - and as modules for
basically anything you
09:35 - would need in the context
of 2D game development.
09:37 - Only 2D game development officially,
although some people I know
09:40 - are working on slight little 3D
experiments, but nothing official yet.
09:44 - But it has graphics, keyboard
input, math, basically, anything
09:47 - you could want in the context
of 2D game development.
09:50 - It's completely free.
09:51 - It's portable.
09:51 - You can even run it on
mobile and also the web.
09:54 - And it's excellent for prototyping,
even if you don't necessarily
09:57 - want to publish a game in LOVE 2D,
it's great and easy and fast just
10:01 - to whip something up in
LOVE 2D, and then port
10:03 - that over to whatever
framework or engine
10:05 - you might be using in the real world.
10:08 - So before we get into looking
at some actual concrete code,
10:12 - I think the most fundamental
thing we should take a look at
10:14 - is what a game loop is.
10:16 - So a game, fundamentally, is just an
infinite loop, like a while true or a
10:21 - while one.
10:22 - Only in this case, every iteration of
that loop we're doing a set of steps
10:27 - back to back over and over again.
10:28 - We're processing input so we're
seeing, has the user pressed
10:31 - a key on the keyboard, have
they touched their joystick,
10:34 - have they moved the
mouse, clicked the mouse.
10:36 - If they have, we need to
feed that into our update.
10:39 - We need to keep track of that, and
then change anything in our game state
10:42 - that relies upon that input.
10:43 - So we should move our paddles,
we should detect collision,
10:46 - we should register all of this,
and then whatever has updated,
10:49 - we want to rerender that.
10:51 - We want to render it--
10:52 - render where it's changed
so that we have the--
10:55 - we see on our screen, visually,
that things have actually
10:58 - changed in our game world
and we interact with it,
11:00 - and we get a sense that
we're using something,
11:03 - interacting with something dynamic.
11:07 - And in the context of 2D games, the most
fundamental way of looking at the world
11:12 - is via the 2D coordinate
system, which is just simply
11:14 - as we learned in geometry in
high school, x and y-axis.
11:18 - In this case, it's slightly different
than what we typically learn.
11:21 - In high school, we tend to learn that
the xy origins, sort of bottom left,
11:26 - y positive goes up, negative
goes down, positive x goes right,
11:30 - and negative x goes left.
11:31 - But in this case, we're actually
starting in the top left,
11:34 - and then it goes y positive down,
y negative up, x positive right,
11:38 - x negative left.
11:40 - And everything that we
want to draw in our game
11:42 - needs to have an x and
y-coordinate to draw in order
11:45 - for it to be visually
seen on the screen.
11:48 - So today's goal, we're going
to start a fairly low level
11:51 - and work our way up through examples
today and in future classes.
11:55 - Our first game is arguably
one of the simplest,
11:58 - but also, one of the most
famous games of all time, Pong,
12:00 - which was released in 1972.
12:03 - And the gist of Pong
is you have a paddle
12:05 - on the left side of the screen, a
paddle on the right side of the screen,
12:08 - whoever scores 10 points by getting
the ball past their opponent's paddle
12:11 - onto the edge of the screen, wins.
12:14 - And so today in our lecture, the scope
is we want to, first and foremost,
12:19 - draw shapes to the screen, because
that's how we get our ball and-- ball
12:22 - and paddles rendering.
12:23 - And those are just simply rectangles.
12:25 - We want to control the 2D
position of these paddles,
12:28 - because we want them to move up and
down and want the ball to also move.
12:32 - We want to detect collision
between the paddles and the ball,
12:36 - because that's how we get the
ball to deflect off the paddles,
12:38 - and to deflect off the
ceiling and the floor.
12:40 - And, also, how we detect whether it's
gone beyond the edges of the screen,
12:44 - such that one player scores a point.
12:47 - And then we want to add sound
effects for sort of a feedback
12:51 - and sort of put ourselves into
the game a little bit more.
12:54 - And then scorekeeping, because
ultimately the purpose of the game
12:57 - is to beat your opponent,
so you want a way
12:59 - to see who has scored 10 points first.
13:02 - And so we're going to look through
a set of examples now in the repo.
13:06 - If we look at Pong Zero, I've set this
to be called, The Day Zero Update.
13:11 - It's a trend among many games to
have the games release major content
13:16 - updates as the x update.
13:17 - So just to be cute, I think we'll
call each individual example here,
13:24 - The Something Update.
13:26 - And so I'm going to
go into the Pong Zero
13:29 - Repo of the directory, the GitHub repo.
13:36 - And if we're looking at Pong
Zero here, we can see it
13:40 - says here, The Day Zero Update.
13:41 - I've commented everything
fairly heavily so that we can--
13:44 - if you're reading the code, you can
sort of get a sense of what's going on.
13:48 - At line 23, we're going to
start off by just declaring
13:52 - a window width and a window height.
13:54 - And these are just
constant variables that
13:55 - will be accessible throughout
the rest of our application.
13:58 - So I'm just setting 1280 by
720 as an arbitrary resolution.
14:01 - It doesn't matter too much.
14:03 - An important thing that we need
to look at here is that line 29,
14:07 - we're using a function called
love.load, and I'm actually
14:12 - going to go back to the slides here.
14:14 - We're going to look at
a few functions, and I'm
14:15 - going to go over them
and just sort of tell you
14:18 - what they do before we look at
the code in too much detail.
14:21 - So love.load is just a function
that-- given to us by LOVE, LOVE 2D,
14:26 - and we overwrite it.
14:28 - We give it behavior,
we tell it what to do.
14:31 - And LOVE 2D is going to look
at it in our main.lua file.
14:34 - If we're looking at Pong Zero, you'll
see it just has a main.lua file.
14:37 - LOVE 2D expects just a main.lua
file, and will run the main.lua file,
14:42 - and you can reference any other file
within the directory from that main.lua
14:45 - file.
14:46 - It's our bootstrap, effectively.
14:49 - We're going to override
love.load with whatever
14:52 - we want to execute at the very
beginning of our application.
14:55 - It's just a startup function.
14:57 - We can also define all that behavior
outside of the function above it,
15:01 - but it's good practice to
find it within love.load
15:03 - so that someone reading
your code will know,
15:05 - OK, this is where all the
startup code takes place.
15:08 - Love.update(dt) is a
very important function.
15:12 - This function takes in
a variable called (dt).
15:14 - Love passes it in a function.
15:17 - You're going to overwrite
it with your own behavior,
15:19 - and Love is going to execute this
every frame, passing it in delta time,
15:23 - and you can use delta
time (dt) in that function
15:27 - to change your application based
upon how much time has passed.
15:32 - (dt) will always be a fraction
of a second, potentially more,
15:36 - depending on how slow your computer is.
15:38 - But, typically,
one-sixtieth of a second.
15:41 - And you can scale anything
in your game by that amount
15:43 - to get even behavior
across all frame rates.
15:47 - Love.draw is the other
big function amongst--
15:52 - between update and draw.
15:53 - Two of the two, arguably,
most important functions.
15:55 - Love.draw is the
function that we're going
15:58 - to define that has all of our drawing
behavior, our rendering behavior in it.
16:02 - And that's where we can draw our
paddles, we can draw our ball.
16:05 - And then update is
where we can like change
16:07 - the paddles position and so forth.
16:09 - Two more important functions we'll
take a look at in the first example.
16:13 - Love.graphics.printf is the LOVE 2D
analog of printf and C. The difference
16:19 - being that this printf lets
us actually draw physically
16:22 - onto the screen versus a console.
16:24 - We give it a text as a string, and an
x and a y-coordinate and, optionally,
16:28 - a width and an align, and
it'll will draw the text at xy,
16:32 - but it will also take into
consideration the width,
16:35 - and it'll also take in
consideration the align.
16:37 - The with is how much to align it, and
the align is the mode of alignment.
16:41 - So if we say x is zero width, our window
width, and then we say align center,
16:47 - it's going to go between zero and
our window width and center align it.
16:51 - So that'll have the effect
of center aligning our text.
16:54 - But we can just as easily
say, right, and it will right
16:57 - align it between those
two and have the effect
16:59 - of rendering the screen--
rendering the text
17:01 - along the right edge of the screen.
17:03 - And then lastly, love.window.setmode
takes a width and a height
17:06 - and some optional parameters.
17:08 - Those parameters being things
like V sync and full screen,
17:11 - and will actually set up our window
and get it rendering onto the screen.
17:16 - And so if we go back to our
source code here, it-- at line 29,
17:21 - we're overwriting love.load.
17:23 - We're passing in love.window.setmode,
window width and window
17:27 - height, which recall we defined
up above as 1280 by 720.
17:31 - We're passing in a table.
17:33 - This is the syntax for a
table, these curly brackets.
17:36 - And the way that we define keys and
values is just with an equal sign
17:39 - therein.
17:40 - So full screen gets false, resizeable
gets false, V sync gets true.
17:44 - So it's going to not
be full screen, it's
17:45 - going to be a not resizeable
but it is going to be
17:48 - synced to our monitor's refresh rate.
17:49 - And that's where V sync is,
short for vertical sync.
17:53 - And then on line 40, we're
overwriting love.draw,
17:56 - and this has the love.graphics.printf
function, they're in,
18:00 - and we're saying-- we're passing
in the string, hello, Pong.
18:03 - We're starting it at x
zero, we're setting it
18:06 - at y window height
divided by 2, minus 6.
18:10 - Because the default font size
in LOVE 2D is 12 pixels tall.
18:13 - So we're shifting it up
by six so it's perfectly
18:15 - centered vertically in the screen.
18:18 - And then we're setting the alignment
amount, the width, to window width
18:22 - so that it's going to align it within
the entire width of our window.
18:25 - And now we're setting
it to center alignment.
18:27 - So it's going to be center
aligned within our entire window
18:30 - starting at x zero.
18:31 - And so if we go to Pong zero,
and then we actually run it,
18:36 - it has the effect of doing this.
18:38 - We're just rendering in our
default font, default size,
18:41 - hello, Pong, right in
the middle of the screen.
18:44 - So not a terribly
exciting example, but it
18:47 - is showcasing the most
important functions of LOVE 2D,
18:51 - so that we can get started with
slightly more interesting examples.
18:55 - So, our first content update,
is the Low-Res Update.
18:59 - So we're developing Pong
and Pong is an old game.
19:03 - It doesn't look like the
example that we just looked
19:06 - at where the font is fairly high res.
19:09 - We want something that
looks a little more retro.
19:11 - So what we want to do
is get our resolution
19:14 - looking like it's from
a game released in 1972.
19:18 - So what we're going to do is look at
a few more important functions here.
19:22 - So Pong One has these functions.
19:25 - So love.graphics.setDefaultFilter.
19:28 - This function, the purpose
of that, is every time
19:32 - we have a font or an
image in our application,
19:36 - it's going to be applied
a filter by default.
19:39 - So it's going to by
default a bilinear filter.
19:41 - So what's going to
happen, the effect of that
19:43 - is, basically, whenever we
magnify or downscale a texture,
19:48 - it's going to think that--
it's going to assume
19:51 - that we want it to be slightly blurred
so as to not look too pixilated.
19:55 - Which is good in certain contexts.
19:57 - For higher res 2D game development,
that's good, but as we're going to see,
20:01 - that's not particularly good
in the context of retro games.
20:03 - Retro games have a very 2D,
crisp, pixilated aesthetic,
20:08 - and we want to preserve that.
20:09 - And so this lets us
set a default filter.
20:11 - We'll see that in usage shortly.
20:14 - Another important-- very important
function which is the input phase
20:17 - of our game loop that we saw earlier,
love.keypressed(key) is what's going
20:21 - to allow us to start interacting
with that aspect of our game.
20:24 - So love.keypressed(key) is a callback
function that LOVE expects in main.lua.
20:28 - We're going to overwrite it.
20:29 - It gets passed in a
key, and this function
20:31 - gets called every time by LOVE
2D whenever we press a key.
20:35 - It'll detect a key pressed,
and it will call this function.
20:37 - Whatever we've defined
in here, it will call it,
20:39 - and we can set it to
take in certain keys
20:42 - and perform certain operations on
that input and it will get a string.
20:46 - So if we say-- if we
press the escape key,
20:49 - key is going to be equal to the
string escape in that function,
20:52 - and we have access to that.
20:53 - And another important
function, love.event.quit.
20:56 - This has just a very simple effect
of quitting the application,
20:59 - though we can call it in the code
as opposed to doing it ourselves.
21:03 - And so here's an example of what
texture filtering looks like.
21:07 - Point filtering is the
same as nearest neighbor
21:09 - filtering, which is what
we're going to be using.
21:11 - Bilinear filtering is shown on the
right, where it looks pretty blurry.
21:15 - That's what LOVE 2D applies by
default to both fonts and to textures.
21:21 - And we'll see that in an example.
21:23 - I can actually run it
in two different styles.
21:25 - So if you go to Pong One in
the repo, and then we run it,
21:28 - we see here, hello,
Pong is now blown up.
21:32 - And we'll look at some
more code, actually,
21:34 - to see as to why it's blown up.
21:36 - But if we go back to our
code, let me pull up Pong One.
21:46 - Go to main.lua, and then I'm going
to explain this in just a second,
21:52 - but let me comment this out and
we'll see the difference here.
21:55 - You can see it looks a lot blurrier.
21:58 - And that's the default texture
filtering taking place.
22:00 - It applies, like I said, not only
to textures but also to fonts.
22:04 - And that's not the aesthetic we want.
22:06 - So let's look at Pong One in
detail, starting at the top.
22:11 - On line 28, we're acquiring a library.
22:14 - This is how you get a
library in your LOVE 2D
22:16 - application, or your LOVE application.
22:18 - Just equals require and
the name of the library.
22:21 - Push is what we're going to be
using to take our 1280 by 720 window
22:25 - and turn it into a virtual
resolution window at 432 by 243.
22:31 - We can start to think of our game
in terms of a more low res feel,
22:36 - and think about it in 432 by
243 pixels, but still render it
22:40 - in a window that's arbitrarily sized.
22:42 - In this case, we're preserving the
1280 by 720 window that we saw before.
22:47 - If you go to our love.load function,
we see this being used on line 47.
22:51 - Instead of
love.window.setmode, we're now
22:54 - using push setup screen, the push
libraries setup screen function,
22:59 - where it takes a virtual width, a
virtual height, our regular window
23:02 - width and our window height, and
then the same table as before.
23:05 - And this has the effect of
setting up a window that's
23:09 - got our concrete
dimensions of 1280 by 720,
23:12 - but a virtual resolution of 432 by 243.
23:16 - And so now, when it renders,
as we'll see shortly, as--
23:20 - well, as we already did see,
actually, it's magnified.
23:23 - It has the effect of giving
us a lower resolution.
23:28 - And in line--on line 58, if we look
at the love.keypressed function,
23:32 - we've put in there, if the
key equals the string escape,
23:37 - then love.event.quit.
23:39 - So now we have input handling.
23:41 - We've overridden love.keypressed(key),
which LOVE 2D is going to look
23:45 - for in our application,
and then call as needed.
23:47 - And then we're just looking in there.
23:49 - If the key is escape,
then love.event.quit.
23:52 - And if I run the application, I
can now press escape on my keyboard
23:56 - and just quit it and not
have to command quit or click
23:59 - the X on a Windows application.
24:03 - And we've changed one more thing, also,
in the love.draw function on line 70.
24:08 - We're using the push library now.
24:10 - We need to-- it functions sort
of as a state machine in that we
24:14 - set it to start rendering at
a virtual resolution with push
24:17 - apply start, and then push apply
end, and then anything in between,
24:21 - this is very similar actually
to how Open Go works.
24:23 - We won't go into too much detail.
24:25 - But this is very similar in spirit to
how much of Open Go programming works.
24:30 - Push apply start, push apply end.
24:32 - Between that, whatever we call, is going
to render at this virtual resolution.
24:37 - And so we are calling the same
love.graphics.print(f) function,
24:40 - hello Pong Zero, virtual high
divided by two minus six.
24:43 - Same parameters.
24:44 - And it has the effect of rendering
everything that's still got
24:48 - the old aliasing going on the skin--
24:53 - texture filtering going on as the
effect of giving us our magnified text.
24:58 - So same text, same size, but now our
window of rendering is much smaller.
25:02 - So--
25:04 - Any questions so far on
how any of this works?
25:08 - OK.
25:09 - Awesome.
25:10 - So we've gotten text right into the
screen, but we're nowhere close to Pong
25:14 - yet, so the first big
thing, I think, that's
25:16 - going to get us closer in
that direction is what we're
25:20 - going to call the rectangle update.
25:22 - So some important functions
that we should look at.
25:26 - Love.graphics.newFont.
25:27 - The default font, I believe, is Arial.
25:30 - We don't want Arial in our
application, because we want something
25:33 - that looks a little more retro.
25:35 - We want something that
looks more relevant.
25:38 - Love.graphics.newFont will
basically take a path to a font file
25:43 - that we have in our folder, which
if you're in the Pong 2 folder,
25:49 - you'll see a font.ttf file, and a size.
25:53 - Because every font object
that we instantiate
25:55 - needs to have a size, because
the font objects are immutable.
25:59 - Once constructed, they cannot be changed
so they need to be allocated on a size
26:03 - by size basis.
26:05 - Love.graphics.setFont
will take whatever font
26:08 - object we've acquired from this
function call, and we can set it here
26:13 - and it'll set the active font
in LOVE 2D to be that font.
26:17 - Love is a state machine
in the same sense
26:20 - as before, in that it will have
an active font at any one time,
26:25 - and whatever print functions you call,
will use the currently active font.
26:29 - And that also applies to whatever color
you might want to render to the screen,
26:33 - whatever.
26:34 - If you have a font and you
want to maybe render it in red,
26:37 - you need a set LOVE 2D's
active color to red as well.
26:42 - Love.graphics.clear is a function
that takes an RGBA quadruple,
26:47 - and will flush the screen in that color.
26:49 - It just has a simple effect of
wiping the screen in that color.
26:52 - Useful for drawing just
flat color backgrounds.
26:55 - And then the last function, probably
the most important function,
26:58 - is love.graphics.rectangle.
27:00 - And this is the first
function that we'll
27:02 - see that actually ends up drawing
something beyond text to the screen.
27:05 - It takes it a mode, which can
be fill or line, an x and a y
27:09 - and a width and a height, and it'll
draw a rectangle in that mode.
27:13 - So either filled, so a filled
rectangle, or a line rectangle.
27:16 - It'll take-- it'll draw it at
xy with the width and the height
27:19 - that we pass in.
27:21 - So let's go ahead and
take a look at Pong 2
27:24 - where we can see this
actually implemented.
27:27 - So Pong 2, we have our font.ttf
in there that I've included.
27:31 - And then a main.lua.
27:33 - And by the way, I forgot
to mention last example,
27:35 - push the library that we required
is also just in the same directory.
27:39 - And you can just do require as long as
the file is there within the directory,
27:43 - it will just load it.
27:45 - You don't have to specify .lua.
27:46 - It assumes when you require some string,
that it follows with the .lua suffix.
27:52 - So we're here looking at main.lua
in Pong 2, the rectangle update.
27:56 - So on line 28 to 34,
it's all the same stuff.
27:59 - We're acquiring push.
28:00 - We have our width and height
virtually and physically.
28:04 - In our love.load function,
we are on line 43
28:08 - declaring small font to be
a love.graphics.newFont,
28:13 - giving it the path font.ttf
because it's right there
28:15 - in the same directory at size eight.
28:17 - And this is going to create a font
object, small font, that we can then
28:21 - set as the active font as needed.
28:24 - So if we go down to line
78 in the same directory,
28:29 - we see we're calling
love.graphics.clear,
28:32 - and so we're passing it in a color.
28:33 - I sampled some images
of Pong on Google Images
28:36 - and saw a background gray that I liked,
so 40, 45, 52, RGB, and then 255 just
28:45 - means completely opaque, so no
transparency, the alpha component.
28:49 - And then we're doing
the same print.function
28:51 - as we did before on line 81.
28:53 - Below that on line 89 down
through 95, we're actually
28:56 - calling love.graphics.rectangle.
28:59 - And these are drawing the two
paddles and then the ball.
29:02 - So, note, love.graphics.rectangle
fill mode,
29:05 - because we want the paddles to be
completely filled, as is the ball.
29:09 - We're giving it an xy of 1030
and a width height of 520.
29:14 - And on 992, we're-- and that'll have
the effect of drawing it a little bit
29:19 - shifted from the top left corner,
five pixels wide, 20 pixels tall.
29:23 - On line 92, we're doing the
same thing, except we're
29:26 - going virtual width minus 10.
29:28 - So it's going to go to the right edge
of our screen, virtual width minus 10.
29:32 - So 432 minus 10.
29:33 - So 422.
29:36 - And then virtual height minus 50.
29:38 - So it's going to be slightly--
29:41 - it's going to be slightly up
from the bottom of the screen.
29:43 - So we have our top left paddle
and our bottom right paddle.
29:47 - And then the ball is dead center.
29:48 - So we're sitting-- doing another
graphics-- rectangle call.
29:52 - Virtual width minus two divided by two.
29:54 - So right in the middle,
minus two, because our ball
29:56 - is going to be two pixels
wide by two pixels tall.
29:58 - And same thing with
virtual height, minus two.
30:00 - Our virtual height
divided by two, minus two.
30:03 - So I'm going to go ahead and CD into
the Pong 2 directory and run it.
30:08 - And that has the effect of we have
our new font here in the middle.
30:11 - So it looks nice and retro, much more
so than the Arial font as before.
30:16 - We have a rectangle here, five
pixels wide by 20 pixels tall.
30:19 - A ball in the middle, which
is four pixels wide by four
30:21 - pixels tall, and then a
paddle on the bottom right,
30:23 - which is the same dimensions
as the paddle on the left.
30:27 - So it looks very similar to Pong.
30:29 - It's not interactive at all, but
we sort of getting the feel of what
30:32 - we want our application to look like.
30:33 - We have it mostly sketched out.
30:35 - So any questions so far
as to how this works?
30:41 - OK.
30:41 - Awesome.
30:43 - So Pong 3.
30:44 - So currently we have no
interactivity with our application,
30:48 - and we want to be able to
move the paddles around.
30:50 - We don't want to just be looking
at an-- at an image the whole time.
30:53 - So the paddle update is going
to solve this problem for us.
30:56 - We're going to actually get our first
sort of-- beyond pressing escape
30:59 - to quit the application,
we're going to get a sense
31:01 - of interacting with it dynamically.
31:04 - So the important function that we're
going to look at in this example
31:07 - is love.keyboard.isDownsomekey.
31:11 - And this is true-- this
is a Boolean function.
31:13 - It just returns true or false depending
on whether the key that we pass in
31:16 - as a string is currently
pressed down on this frame.
31:21 - So it just returns true or false.
31:23 - And so let's go ahead and
take a look at the demo.
31:27 - We're going to go ahead
and pull up Pong 3.
31:31 - The main.lua, they're in.
31:35 - Notice that line 37 if you're looking
in Pong 3 we, have a new constant
31:39 - we've defined called paddle
speed, which gets the value 200.
31:43 - And this is just an arbitrary value
that I found was a good speed.
31:46 - But this is how fast our
paddle is going to move.
31:48 - We're going to scale it
by delta time, so we're
31:50 - going to multiply it by how
many seconds have passed.
31:53 - Typically, a fraction of a
second since the last frame.
31:56 - And this is going to, therefore,
move the same distance
31:59 - over time depending on
whether your computer is
32:01 - running at 10 frames per
second or 60 frames per second.
32:05 - So if we go down here to line 63,
I've also set up two new variables.
32:10 - Player one score and player two score.
32:12 - Those are both initialized at zero.
32:14 - We're going to add in this example,
also, some rendering of the score.
32:19 - And notice here on line
49, I've also added
32:22 - a new font, which showcases how you need
to separate fonts based on their size
32:26 - because they're immutable objects.
32:27 - Score font gets love.graphics.newFont.
32:30 - Same exact font file, but it's 32 pixels
large because the font-- or the score
32:35 - when rendered in Pong is pretty
large in the middle of the screen.
32:38 - And so we're creating-- we
have two different fonts now.
32:41 - One for rendering our message,
one for rendering our score.
32:44 - And it's just going to render these two
variables, player one score and player
32:47 - two score.
32:48 - And then we've also
initialized our y values
32:52 - for the rectangles, the paddles
on the left and the right.
32:55 - We need to keep track of their y
position, because paddles in Pong
32:58 - can only move up or down.
33:00 - So player 1Y gets the same
value it did before when
33:02 - we initialized the rectangle,
when we drew it onto the screen.
33:05 - It's going to start at
y 30, so pretty high up.
33:07 - And player 2y is going to start
pretty low, virtual height
33:10 - minus 50, which is 432 minus 50.
33:14 - And so in love.update, which is
our first actual use of the update
33:17 - function on line 75 with the (dt)
parameter that gets passed in.
33:21 - Note, remember that LOVE 2D
will pass that in for us,
33:24 - but we need to give it-- we need to
define the behavior inside of it.
33:27 - We're using love.keyboard.isDown,
and we're passing in the string w
33:31 - and s for this first block.
33:33 - This first block here is
player one's movement.
33:36 - So, traditionally, on
computer WASD is to move--
33:40 - and this example, we're going to
allow ourselves to move both paddles,
33:43 - so we're going to use w
and s for the left paddle,
33:46 - and up or down for the right paddle.
33:48 - So if love.keyboard.isDown
w, which means--
33:51 - or we've currently pressing
the W key, player 1y
33:54 - is going to get itself, plus negative
paddle speed times delta time.
34:00 - So it's going to move up.
34:01 - It's going to take negative paddle
speed, multiply it by delta time,
34:04 - and add that onto our y
value, which will have
34:06 - the effect of shifting our paddle up.
34:08 - And it's the opposite for--
34:10 - on line 82 for-- if
we're pressing the s key.
34:13 - We need to increase the y by positive
paddle speed, because recall,
34:17 - y-axis movement is--
34:19 - up is negative, down is positive.
34:22 - We're doing the exact same thing
with the paddle on the right
34:24 - except we're using up and down as the
strings into love.keyboard.isDown.
34:30 - And then down below here,
we are rendering in addition
34:36 - to what we rendered before,
also, the score now.
34:38 - So on line 125, note that we're calling
love.graphics.setFont, scoreFont,
34:44 - because if we don't call this, it will
use just whatever the last font was,
34:47 - which by default is the eight
pixel font because we set that
34:49 - up top in our program.
34:51 - We want to set it to the
score font, and then we
34:54 - want to call love.graphics.print.
34:55 - In this case, I'm just printing them
in concrete places not, using printf.
34:59 - Virtual width divided by two minus 50.
35:01 - So no matter how we
scale our window, it's
35:03 - always going to be 50 pixels to the
left of the center of the window,
35:08 - and the 30 pixels to the right
of the center of the window
35:12 - if we're rendering the player two score.
35:16 - And so if we go into Pong 3 and we
run it, it looks the same as before.
35:23 - Note, that we do have a score now in
the middle of the screen, zero and zero.
35:26 - But, more importantly, we can
move our paddles up and down.
35:30 - But there's one problem, and that's I
can move beyond the edge of the screen,
35:34 - which is not behavior that
we want in our application.
35:37 - So we have some interactivity,
it's moving along,
35:40 - but we still have a long
way to go, unfortunately.
35:42 - Or fortunately.
35:43 - So let's go ahead and
look at the ball update.
35:47 - So we have paddles, they can move, they
can move beyond the edge of the screen,
35:52 - but we don't have a ball that-- it
just sits in the middle of the screen.
35:57 - And that's not what we're looking for.
35:58 - We want to have a ball that we can
actually bounce between the paddles
36:01 - so we can get an actual game
going beyond just moving paddles.
36:04 - So a few important functions
we're going to look at.
36:06 - We're going to get our
first look here at random.
36:09 - So in games, random number
generation is a very common thing
36:13 - so that we get unpredictability and
variability between different instances
36:17 - of our game.
36:18 - An important function
that just belongs to Lua.
36:20 - It's not a LOVE 2D thing,
it's just a Lua thing.
36:23 - Math.random seed numb.
36:25 - So many of you have
probably heard of like seed,
36:28 - like a random number
generator, seed, and that just
36:30 - means a random number generator.
36:33 - Because it's pseudo
random, it needs some sort
36:35 - of starting value to base all
of its random numbers off of.
36:38 - It takes a starting number, it
performs some mathematical operation
36:42 - on that number to derive new
random values that we can then
36:45 - use in our game engine.
36:46 - But if we give it the same
number every single time,
36:49 - it's just going to give us the same
random numbers every single time,
36:52 - which means it's not
going to be random at all.
36:53 - It's going to be very consistent.
36:55 - So we need a way to seed
our random number generator,
36:58 - give it a different
initial value or seed,
37:01 - and we're going to do that with the
function math.randomseed somenumb.
37:06 - OS.time is an important
function in the context of this,
37:09 - because a very common way of getting
a different number every time
37:13 - you run your application is passing
it in whatever the current time is
37:17 - in seconds, because usually
it's a very large number that
37:20 - is going to be different every single
time you run your game, no matter what.
37:24 - Because it's based upon, in
the context of most engines,
37:27 - in the context of Lua, what's called
Unix Epoch time, which is zero
37:32 - zero UTC January 1st, 1970, which is
some huge number nine or 10 digits long
37:39 - that changes every single second.
37:41 - And then in order to actually
take advantage of all this,
37:44 - we need a function to
get a random number,
37:46 - and so we do that with math.random,
which takes a min and a max,
37:49 - although you don't need
to technically pass a min,
37:51 - it'll just implicitly deuse min
as one if you don't pass it a min.
37:56 - And it'll return a value
inclusively within that range.
37:59 - So if you say math.random
one, 50, it'll give us
38:02 - a random inclusively between 1 and 50.
38:04 - And if we just say math.random
50, it'll do the same exact thing.
38:08 - It'll say-- it'll assume rmin is one
and give us a value between one and 50.
38:12 - And then two important
mathematical functions
38:14 - that are very basic but helpful in the
context of games almost everywhere,
38:18 - it's just math.min, which
returns the lesser of two values,
38:21 - and math.max which turns
the greater of two values.
38:24 - And we'll see this in the context
of clamping values to some range.
38:29 - So let's go ahead and take
a look at a demo here.
38:31 - So I'm going to go ahead
and open up Pong 4.
38:37 - And going to look at
main.lua they're in.
38:42 - So here on line 47, we see we're calling
the math.random seedfunction as before.
38:48 - And note that we're passing in
OS.time, another function call,
38:52 - because OS.time is going to be different
every time we run our application.
38:55 - So we're seeding our
application every time
38:57 - we run it based on whatever the current
second is relative to zero, zero, zero,
39:02 - zero, zero, zero, January 1st, 1970.
39:04 - Which is going to be different
every single time we run.
39:06 - Assuming we don't run it
within the same second.
39:10 - And then if we go down to line 71
and seven-- or, sorry, 67 and 68,
39:16 - we now have--
39:18 - we're giving a starting
value to our ball,
39:21 - because we want to actually
start manipulating our ball.
39:23 - So we give it an X and a Y. So we're
setting it right to the center again
39:27 - but, now, we're defining
a variable for it
39:29 - instead of just rendering it statically
with our love.graphics.rectangle
39:33 - function, because we want
this to change over time.
39:35 - We want to start letting our
ball move around the screen.
39:37 - So these x and y variables are
going to start changing now,
39:40 - and they're going to change
relative to its current velocity.
39:44 - And its velocity is going to be
stored in ball dx and ball dy.
39:48 - dx and dy are common shorthands
for delta x and delta y,
39:53 - which is how you represent velocity.
39:55 - So what we're going to do, effectively,
is take whatever our delta x and delta
39:59 - y are and add them onto
our ball frame by frame,
40:01 - and that's going to have
the effect of updating
40:03 - our ball's position by some value.
40:05 - And separating the
delta x and the delta y
40:07 - will allow us to have different angles,
different trajectories for our ball.
40:12 - And then another thing that we're
also doing in this application,
40:15 - we're starting with the
concept of a game state.
40:18 - Because now we can have a starting
state, and what we're going to have
40:21 - is a play state.
40:23 - And so all we're going to
do here in this example
40:25 - and in this application is
start state as a string.
40:28 - In future examples, we're going to
use what's called a state machine
40:31 - and actually separate out
different states into their own--
40:34 - into their own modules.
40:35 - But in the context of
this game, we're just
40:36 - going to use a simple
string just to illustrate
40:38 - how it works, and we're going to say
our first state, when we start the game,
40:42 - should be the start
string in the start state.
40:46 - And so here on line 86,
what we're going to do
40:49 - is solve a problem that we had
in the last example, which was,
40:52 - the paddles could move beyond the edges
of the screen, which is not behavior
40:55 - that we should permit.
40:56 - So we're going to call math.max
on zero, and the same operation
41:02 - we were doing before, and that will
have the effect of returning whichever
41:06 - of those two values is greater.
41:08 - So if the value is--
41:10 - if we're adding negative
paddle speed to our y value
41:13 - and it goes into the
negative range, which
41:15 - means it's beyond the
top edge of the screen,
41:18 - zero is going to be the
greater of those values
41:20 - and so it will always be zero
in that case. math.max returns
41:23 - the greater of the two values.
41:25 - So it'll have the effect of
clamping it such that it never
41:27 - goes above the top edge.
41:29 - The inverse is true
for line 96, where we
41:32 - call math.min on
virtual height minus 20,
41:35 - and player 1.y plus paddle
speed.delta-- times delta time.
41:39 - And this will have the same
effect, it will return whichever
41:41 - of these two values is lesser.
41:43 - In which case, if we've gone above
virtual height minus 20, which
41:47 - is down at the bottom of the screen
shifted by the size of our paddle,
41:52 - it's going to set it to
virtual height minus 20.
41:55 - So we never go below that point.
41:57 - And we're doing the same thing
for player two, exact same logic.
42:01 - And then if we're in
the play state, we're
42:04 - going to actually update
our ball's position.
42:07 - So we're in the-- if we're in the start
state, ball's not going to move at all.
42:10 - But if we're in the play state, we
want ball x to equal ball x plus ball
42:14 - x times delta time.
42:16 - And note that there
is no shorthand in Lua
42:19 - for adding the value to itself,
which is why we're calling ball
42:23 - x equals ball x, plus
ball x times delta time,
42:26 - instead of just saying ball x plus
equals ball x times delta time.
42:30 - Just a language decision that they made.
42:33 - But if we're in the
play state, this will
42:35 - have the effect of scaling whatever
our current ball's velocity is and--
42:39 - times delta time, so it
stays frame rate independent.
42:43 - And then adding it to ball x
and ball y, which will shift it.
42:45 - And we get this actually
working down here in line 170--
42:53 - 174.
42:54 - We're now-- instead of just
rendering flat numbers to the screen,
42:59 - we're actually using ball
x and ball y to render.
43:01 - And if we're in the play
state, those will get updated.
43:05 - But if we go back up to line 127, now,
we're in the love.keypressed function,
43:13 - so we're starting on line 120.
43:15 - Before we just had the if key
equals escape, then love.event.quit.
43:19 - But now on line 127,
we're going to check
43:22 - to see if the key is
equal to enter or return,
43:25 - and then we're going to use that as
our way of just testing state changes.
43:29 - So we're going to say if the
game state is equal to the start,
43:32 - once you press entered, the game
state should be equal to play.
43:35 - Otherwise, set it back to start.
43:37 - And we set it back to start,
we're going to re-initialize our x
43:41 - and y to be in the center,
virtual width divided by two
43:43 - minus two, virtual height
divided by two minus two,
43:46 - and we're going to give it an initial
random starting velocity again.
43:51 - And note here, this
math.random two equal--
43:54 - is equal to one, and
100, or negative 100.
43:57 - It's just Lua's way of
doing a ternary operation.
43:59 - So in C, you will often have like--
44:03 - you would be something like
math.random two equals one,
44:08 - and you would have a question
mark, 100 colon, negative 100.
44:13 - It's the same exact
thing, but Lua doesn't
44:14 - have that sort of shorthand for a
ternary operation, so we do it with
44:18 - and and or.
44:20 - We use logical operations
instead to do the same thing.
44:24 - And note here we're also showcasing
that math.random can take
44:28 - either one argument or two arguments.
44:30 - In this case, we're
saying math.random two,
44:32 - which means it will give us
a value between one and two.
44:35 - So a 50-50.
44:36 - And then if we do
negative 50-50, that means
44:39 - we'll get a value between
negative 50 and 50.
44:41 - So a range of 100, effectively.
44:44 - And so what that has the effect of
doing, if we run our application,
44:46 - we go into Pong 4.
44:50 - We're in the start state
so now we're rendering--
44:53 - if we're in the start state,
it's set to render that message.
44:57 - If we press Enter, the ball gets
a random veloc-- it's actually
45:01 - applying the velocity frame by frame.
45:03 - It's updating in the update method.
45:05 - If we press Enter again, it gets reset
and we're back in the start state.
45:09 - So we do it again, it's
getting a random value.
45:11 - Do it again, random value.
45:12 - Random value.
45:13 - So every time we're getting a
different random ball value.
45:17 - But what happens if we try to actually
run it, or try to interact with it?
45:24 - Nothing.
45:25 - Goes straight through.
45:26 - So we're missing a key
piece, even though we
45:28 - have the core components of
our game engine implemented,
45:32 - we don't have any concrete game
play, nothing's interacting.
45:35 - And that's a major piece
that we need to look at.
45:38 - And so the next--
45:40 - before we actually start
doing that, though, we're
45:42 - going to take a look at
the class update, Pong 5.
45:46 - And so in order to get
into more of a-- in order
45:52 - to scale our code more
effectively, we need
45:55 - to start looking in terms of classes.
45:58 - And instead of having an x and a y for
our ball, an x and a y for our paddle,
46:01 - a delta x, a delta y for our ball,
all these different variables that
46:04 - are sort of all over the place
starting to bloat our code,
46:07 - before we get too crazy with
it, we should think about
46:10 - how can we put this data altogether
so that we can just think in terms
46:13 - of our paddles or our ball object.
46:15 - And so we use what's called a class.
46:17 - If unfamiliar, a class is simply a
way of taking all these variables that
46:21 - we've been using thus far, but putting
them together in a container such that
46:25 - we can just say, paddle.x or paddle--
46:29 - you know, in this case, car.
46:31 - If we have a function called drive car,
now we can just say, car.drive instead.
46:37 - We don't have to have functions
that are separate from our values,
46:40 - that-- we can put them all together.
46:42 - We can ask what's our car's
current mileage instead
46:45 - of having all these different
variables all over the place.
46:48 - So the classes are
effectively blueprints.
46:51 - Use it-- you define a class.
46:53 - You say, OK, my car
class is going to have
46:55 - a-- it's going to have
a mileage variable,
46:58 - it's going to have a paint variable,
it's going to have a make and a model,
47:02 - it's going to have all these things, and
it's going to maintain its own state.
47:05 - It's going to maintain
all of that for us.
47:09 - as seen here.
47:10 - And, typically, these are
what are called fields.
47:14 - And then we'll have methods as well.
47:16 - Functions that, instead of being like
completely separate from this data,
47:20 - a car now basically
owns its own functions.
47:23 - It has its own method called
drive, or turn, or honk, et cetera,
47:28 - and we don't need to
have a function called,
47:30 - like, turn car, or honk car, et cetera.
47:35 - And then this class is
effectively a blueprint.
47:37 - Well, we'll see shortly
how to define a class,
47:40 - but in order to actually have like one
paddle that has its own set of data,
47:44 - and another paddle that has its own
set of data, we need to define--
47:47 - we need to instantiate, create
objects from this class.
47:51 - Basically, use this class as a
blueprint, but take it to a factory
47:54 - and create concrete
cars from the blueprint.
47:57 - And those are objects.
48:01 - And so as seen here,
our paddles and ball
48:03 - are perfect simple use
cases for doing this.
48:05 - So let's go ahead and
take a look at Pong 5.
48:14 - So in Pong 5, immediately, if you
look at the directory structure,
48:17 - you can see that we've added
a ball.lua and a paddle.lua.
48:21 - And it's tradition in most languages
that have object oriented programming,
48:25 - as it's called, to capitalize class
names just so you can differentiate
48:31 - classes, for example, from concrete
objects or variables or functions.
48:37 - So if you go to our
main.lua, on line 35,
48:43 - we're requiring a library,
called class, which
48:46 - is what's going to allow us to
actually create these classes.
48:50 - Because classes are not native--
48:52 - they are in a sense
a native Lua feature,
48:55 - but Lua's way of doing object oriented
programming is a little bit convoluted.
48:59 - Some folks have kindly put together a
library that makes it a lot simpler,
49:04 - and a lot more closely related to
other languages that do object oriented
49:07 - programming more predominantly,
like Java or C#, or even Python,
49:12 - allow us to use the keyword class in
a way that's very similar to those
49:16 - libraries.
49:17 - On line 39 and 43, we're acquiring
our own code, paddle and ball,
49:22 - and we're going to take a
look at those right now so we
49:25 - can see what a class looks like.
49:27 - So I'm going to go ahead and open up a--
49:33 - the ball file, ball.lua.
49:36 - And we can see here
all we need to do just
49:38 - to create a ball class is, using
our class library, ball gets class,
49:43 - and then curly brackets like that.
49:45 - And so now we have a class
object, a class table,
49:47 - effectively, because
everything in Lua is a table.
49:50 - But we can think about
it in terms of objects.
49:53 - We have a class object
called ball, and then we
49:56 - can start to define functions
that belong to this class.
49:59 - So we're going to define what's called
a constructor, or an init function
50:03 - in this case, an initializer.
50:04 - And it's going to allow us to initialize
our ball with whatever we want.
50:09 - In this case, we want to start
our ball off with an x and a y
50:11 - and a width and a height.
50:13 - And notice within here we
have a word called self.
50:16 - Self and this are common words in
object oriented programming languages
50:20 - that mean whatever object we're creating
with this class is going to be self.
50:25 - So we'll see that--
50:27 - we'll see that shortly.
50:28 - Self.x gets x.
50:29 - So whatever concrete object
we create using this call,
50:31 - this init call, set its x to this x,
set its y to the y, set its width,
50:36 - set its height.
50:37 - That specific object.
50:38 - Self.
50:39 - And then we're doing the same
thing for delta y and delta x,
50:42 - only that we are setting those two
random values just as we did before.
50:46 - Self.dy, self.dx.
50:49 - That belongs to whatever specific object
gets instantiated using this init call
50:54 - as we'll see in the code.
50:57 - We're defining just a reset
function here just to make it easy.
51:01 - Before we had a--
51:02 - several lines of code that set our
ball to the middle of the screen
51:06 - and gave it a random velocity.
51:07 - We're doing that now, and
this is a good way of sort
51:09 - of refactoring out groups of logic.
51:11 - We're creating a function called reset
that just does that all in one function
51:15 - call, and we just call that within our
main function, condensing our code.
51:19 - And then notice we have an
update and a render function now.
51:22 - And we are going to call
these from our own update
51:24 - and our own draw function
such that every object
51:27 - that we want in our game, every
entity, and we'll build upon this game
51:31 - by game in the future.
51:33 - We'll just call update and render
on everything from our main.lua,
51:39 - and defer all of that to each
individual class and objects
51:43 - so we don't have to have a main.lua
that's like 800 lines of code.
51:46 - We just break out all of the updates
that are pertinent to the ball here,
51:50 - and all the render code that's
pertinent to the ball here,
51:53 - call each individual
balls update and render,
51:56 - and save ourselves a lot
of time in refactoring.
51:59 - We're doing the same thing
if we look at paddle.
52:04 - Paddle's a class, as well.
52:06 - It gets the reason the class library.
52:10 - Same exact sort of thing here,
xy with height, and a dy.
52:13 - In this case, we're just initialising
that to zero so that we're not moving.
52:17 - And then we're calling
the update function here.
52:20 - So if our dy is less than zero, we're
using the math.max function as before,
52:25 - with the top edge of the screen, and
then whatever our y plus our current dy
52:29 - is, so delta y.
52:31 - And then here, self.y gets
math.min, virtual height
52:34 - minus self.height, self.y
plus self.dy times delta time.
52:39 - So that's the clamping behavior that we
saw before with the paddles, only now,
52:42 - we took it from main and we
put it in our update function
52:45 - so each paddle calls its
update, and we take some lines
52:48 - of code out of our main file.
52:49 - And then it has its own render
function here, same as the paddle.
52:52 - The render function for the paddle
and the render function for the ball
52:55 - are effectively the same.
52:57 - And so if we go to our main,
we-- we're acquiring the paddle
53:04 - and we're acquiring ball
so that we can use them.
53:07 - So if we go down to line 79, instead
of initializing our ball dx or ball dy,
53:13 - ball x, ball y, paddle
y, player 1y, player 2y,
53:18 - now, we have player one is
simply paddle 10, 35, 20.
53:22 - And player two is a paddle,
virtual width minus 10,
53:25 - virtual height minus 30, 520.
53:28 - Ball is a ball, virtual width
divided by two minus two,
53:30 - virtual height minus two,
minus two, [? five by ?] two
53:33 - minus two, four and four.
53:35 - So those paddles now have control over
their own x and y, their own width
53:39 - and height, and the battle-- or the ball
has its own control over the xy width
53:45 - and height.
53:45 - And the self applies to this object.
53:48 - This is whatever self was in our
constructor that we saw before.
53:53 - So even now we can just
call-- so we can simply
53:55 - say player 1.x player 1.width, player
1.y, and everything is contained.
54:01 - We don't need a million
variables to keep track
54:04 - of all the things going on in our game.
54:05 - And this is going to be especially
important as we scale, and we have--
54:08 - maybe we have 100 things
on the screen at one time.
54:11 - We don't want 100
times x variables where
54:14 - x is, however many properties that
thing has that we need to keep track of.
54:20 - It's all the same logic
except, now, we're
54:23 - calling player one update and player
two update in our update function,
54:28 - instead of having all
that logic therein,
54:30 - where they're moving and
then keeping track of whether
54:33 - or not they're going past the top
and bottom edges of the screen.
54:36 - And then if game state is play,
we're now just calling ball update.
54:39 - And these are all getting
passed in delta time.
54:43 - And then same thing here.
54:45 - Instead of having all that
logic for restating the ball
54:47 - as one block of code, we took
it out, we refactored it,
54:50 - we put it into our ball class,
and now all we have to do
54:52 - is just one line of code, ball or reset.
54:56 - And then here down on line
169 in our draw function,
55:00 - we just have player one render,
player two render, ball render.
55:04 - And later on as we
scale and we make games
55:06 - that have a lot more things on
the screen, a lot more entities,
55:09 - we can just do these renders in a loop.
55:11 - We can just say for each entity
in our screen, just render it.
55:15 - For each entity in our
screen, just update it.
55:18 - We can condense thousands--
hundreds of lines of code
55:21 - into just a few lines of code
by deferring update logic
55:25 - and rendering logic to
each individual entity,
55:27 - thanks to object oriented programming.
55:30 - And so that's how we're going
to refactor using classes.
55:33 - So any questions on how
any of that works so far?
55:40 - Cool.
55:41 - This is a good point, I think,
to take a five minute break.
55:44 - And once we come back, we'll talk
about how to look at frames per second.
55:49 - All right.
55:52 - So we're going to take a minute just
to look at something kind of small,
55:56 - but often it's the case
where in games if we
56:00 - want to make sure that we are performing
like our applications performing well,
56:06 - we want to-- some way to
monitor our frames per second.
56:08 - And so I figured I
would just take a second
56:10 - to illustrate this quickly so that
we can use this in the future.
56:15 - The two functions that are going
to be important for us here--
56:18 - well, the first of these is just
a little small cosmetic addition
56:21 - to the application.
56:22 - It's just love.window.setTitle.
56:25 - Title, so far our application,
I'm not entirely sure what the--
56:31 - it says by default, I think it says--
56:35 - what does it say-- untitled.
56:36 - Yeah.
56:37 - So that's not-- it's a layer of
lack of polish, more or less.
56:41 - And it'd be nice just to
solve that problem quickly.
56:43 - So we're going to call a function called
love.window.setTitle, some string,
56:47 - which will solve that problem quickly.
56:49 - We can make it look as if
we have that detail down.
56:52 - And then the thing that's actually
going to let us determine whether or not
56:57 - we are running well or
we're running very poorly
56:59 - is a function called
love.timer.getframespersecond.getFPS,
57:04 - which is something that LOVE
graciously gives us for free
57:07 - and allows us to very easily
slap it wherever we want.
57:09 - We can print it to the
console, or we can just
57:11 - draw it straight to our application.
57:13 - In this case, we're
going to do the latter.
57:15 - So I'm going to go
ahead and go into LOVE--
57:19 - or Pong 6 in our main.
57:24 - If we go ahead and look at line--
57:32 - where is it-- line 64.
57:34 - love.window.setTitlePong,
just quick and easy.
57:37 - Now, our window header
is set appropriately,
57:39 - and if we go down to line
198, here I've decided
57:49 - to sort of split out this
in a separate function,
57:54 - called display FPS on line 198.
57:57 - And the function is defined on line
207, so a function display FPS,
58:02 - takes no parameters.
58:03 - Its only goal is to just draw
our current FPS to the screen.
58:07 - So we're going to set our
current font to a small font.
58:10 - We're going to set our color-- so this
is what I alluded to before in that we
58:13 - can set LOVE's rendering
color to some RGBA quadruple,
58:19 - and anything that we draw beyond
that point will then be drawn at--
58:24 - it'll be drawn into
whatever that color is.
58:27 - So, in this case, we're giving it red of
zero, 255 on the green, zero blue, 255
58:32 - fully opaque, which has the effect
of setting our color to just
58:35 - completely green.
58:36 - And then love.graphics.print,
our current FPS--
58:40 - string, and then our current FPS
here, which is love.timer.getFPS.
58:45 - But it's going to return that
as a number, and by default,
58:49 - Lua does not allow you to
concatenate strings and numbers,
58:52 - so we're going to concatenate
here with this ..operator,
58:55 - which is the way of doing
string concatenation in Lua.
58:58 - We're going to call the
two string function.
59:00 - So we're going to take
in love.timer.FPS,
59:01 - we're going to make
it a string, and then
59:03 - we're going to concatenate it here.
59:05 - And then we're going to call
love.graphics.print on that value,
59:08 - and then we're going
to put it at 10, 10.
59:10 - So shift it just a little bit from
the top left edge of the screen.
59:14 - So that's going to have the effect
of the go to Pong 6, and we run it.
59:18 - We can see now it starts
at zero and 52 because it
59:20 - has to gather a few
frames of data before it
59:22 - has a number we can actually use.
59:25 - But we see there FPS at 60, and so our
game runs, otherwise, just the same.
59:32 - Completely random.
59:32 - A little bit broken, but
that's OK, we'll fix it up.
59:36 - But currently we have
a problem, and that's
59:39 - that our ball is just going
straight through our paddles.
59:43 - So how can we fix this problem?
59:49 - We need some way of detecting collision.
59:51 - So in 2D games, generally, there's a
concept of aa bb collision detection.
59:59 - And what this is is axis aligned
bounding box collision detection, which
60:04 - means that we have bounding
boxes, just rectangles, quads,
60:09 - which have an x and a y and a width
and a height which are nonrotated.
60:12 - So they're completely
aligned with our axes.
60:14 - They're completely
parallel perpendicular.
60:16 - So the only way that we can get
this easy math, the aa bb collision
60:22 - detection working is if we
have no rotation of our boxes.
60:25 - They have to be completely aligned.
60:27 - But if they are, we have
a very simple algorithm,
60:30 - which is we're just making
sure that no edges of our boxes
60:34 - are outside the opposite edges
of our-- of the other rectangle.
60:39 - So if we have one rectangle-- and I'll
illustrate this on the screen here.
60:45 - We have two rectangles.
60:47 - If this top edge is
below this edge, we know
60:53 - no matter what, they're not going
to inter-- they're not intersecting.
60:56 - There is no way it can
because it's below here.
60:58 - So no matter where it is on the
x and the y, if it's below here,
61:02 - it's not a collision.
61:04 - If this edge is on this
side of this rectangle,
61:08 - we know, as well, there's no
way those two boxes can overlap.
61:11 - And it applies to every edge as
long as it is the opposite edge.
61:15 - So if this edge is below this one,
if this edge is above this one,
61:19 - if this edge is on the right,
and this edge is on the left,
61:22 - it means that no matter what,
those boxes aren't colliding.
61:25 - So we can simply do four conditions.
61:28 - We can say, if rec1.x is not greater
than rec 2.x, plus rec2.width,
61:38 - and rec1.x plus rec1.width
is not less than rec2.x,
61:43 - so if the two edges are not beyond their
opposite edges, same thing with the y,
61:49 - and the y plus rec1.height, we
know that we have a collision.
61:55 - We know that because we haven't
fulfilled any of those criteria.
61:59 - But we know that if
that's not true, if the--
62:05 - one of the edges is not beyond
the opposite edge, then it's--
62:09 - we do have a collision.
62:10 - So it is going to be true.
62:12 - So we'll see that here in our code.
62:14 - The go to Pongs 7, at line
113, we have a function
62:26 - that we're calling called ball collides.
62:29 - Our ball class has a
function called collides.
62:31 - So let's go ahead and take
a look at our ball class.
62:40 - And in this case, we've
defined our function such
62:42 - that it takes in a
paddle parameter, so it's
62:45 - going to compare against
another rectangle that
62:47 - has an xy and a width and a height.
62:50 - And we're saying that if rx is greater
than the paddle x, plus the paddle
62:57 - width, which means if rx is
greater than the right edge.
63:01 - So if our top left is greater than the--
63:04 - or just our left-- is
greater than the right edge,
63:08 - we know that we can't collide.
63:10 - Same thing if it's greater
than the other rectangles,
63:16 - self.x plus self.width.
63:20 - No, sorry.
63:21 - In that case, if the paddle's x is--
63:24 - it basically the same operation
but from the paddle's perspective.
63:26 - If the paddle is greater than
the rectangle on the right side,
63:31 - if it's farther along the
right side past the right edge,
63:33 - we know that there can be no collision.
63:35 - It's just impossible.
63:36 - Same thing with y.
63:38 - If the y-- self.y, so this ball is y--
63:42 - is greater than the paddle's
y, plus the paddle height.
63:45 - So if it's below the edge
of the paddle, because we're
63:47 - taking the height into consideration,
or if the paddle's y is greater
63:51 - than this ball's y plus
self.height, then we
63:57 - know that that also
can't be a collision.
64:00 - But if that's not true,
then we need to return true.
64:06 - And so if we go back to our
main-- no, that's the wrong main.
64:11 - We go back to main.lua here.
64:16 - We're calling ball.collides.
64:19 - So if we're in our game state,
if we're in our-- sorry,
64:22 - if we're in our play state, if
game state is equal to play,
64:25 - if the ball collides with player one,
so player one is the left paddle.
64:29 - So if there's a collision detected,
the ball.dx and dx is our x velocity.
64:36 - So it's whatever direction
it's moving on the x-axis.
64:39 - So it's going to be moving
to the left if it's gone--
64:44 - if we detected a collision.
64:46 - And it doesn't matter whether
it's moving left or right,
64:48 - but we needed-- what we need to do
is set it to its negative value.
64:52 - Because if it's moving
left and we said--
64:54 - let's say it's moving left at its
negative 20 pixels and we set to 20,
64:59 - the dx is now 20, it's going
to start moving to the right.
65:01 - It's going to have the effect
of inverting its x velocity
65:06 - and, therefore, reversing its direction.
65:09 - But what we're also doing
here with times 1.03
65:12 - is we're multiplying a little
bit just to speed up the game.
65:15 - Because we don't want the game to into
perpetuity just have the same velocity.
65:18 - It's not going to ramp
up the excitement.
65:20 - We want to keep things going, we
want to get some momentum going,
65:23 - so what we're going
to do is call ball.dx
65:25 - equals its negative value times a scaler
that we've determined arbitrarily.
65:30 - In this case, I've decided
it should be point--
65:32 - 1.03 so it'll increase
it by 3% every time.
65:37 - And then in the event that we have a--
65:41 - our ball-- because it's getting
added, its x velocity is getting
65:45 - added each frame to
its position, we want
65:48 - to make sure that it's not
like inside of our paddle.
65:52 - Because it is possible that it could
shift a certain number of pixels
65:55 - to the left, or to the right,
because the same operation applies.
65:59 - Such that the two are sort
of like on top of each other.
66:01 - We want to re-- we want to
shift it, we want to reset it.
66:04 - So what we're going to do-- because
it'll detect another collision
66:06 - immediately if that's the case.
66:08 - If it, on the next frame,
it's within that paddle,
66:10 - it's going to say that it's
still colliding with that paddle
66:13 - so it's going to shift
its velocity again.
66:15 - And it's going to have the effect
of it infinitely sort of bouncing
66:18 - back and forth within the paddle.
66:19 - We don't want that to happen.
66:21 - So if we detect a collision,
we want to shift it.
66:23 - We want to make sure it's completely
outside of the paddle's collision box.
66:26 - So we're saying ball.x gets
player one.x, plus five.
66:31 - Plus five because that's
the width of the paddle.
66:34 - So that has the effect of just once
you detect a collision, negative set--
66:38 - x velocity to negative,
and then instantly
66:40 - shift it right on the right
edge of the left paddle.
66:44 - And we're doing the same thing here.
66:47 - If ball collides a play or two, we're
doing the-- we're negating or inverting
66:51 - its x velocity.
66:54 - And then-- this is the
same exact operation,
66:57 - but since it's based on the--
the left top left corner,
67:01 - we can't minus it by five,
that wouldn't make sense.
67:04 - We're going to minus it by four
because that's the width of the ball.
67:07 - So if we minused it by five, we
would have one pixel of space.
67:11 - We plussed it by five on
this example, because we're
67:15 - coming in from the right side.
67:16 - We want to just make sure that it's
right on the right edge of the paddle,
67:19 - so we're setting it to player one.x.
67:22 - And in this case, we're
using the minus four
67:25 - because that's the width of the ball.
67:28 - So we want to shift it to the
left, the width of the ball,
67:30 - and that will have the effect of the
right paddle, if there is a collision,
67:34 - it'll just get shifted over,
and the right-- the ball
67:36 - will be touching the paddle
right on their two edges.
67:40 - Here on line 118, we're solving
the problem we had before of what
67:45 - happens when the--
67:48 - oh, sorry, that's actually
not what I was thinking of.
67:50 - This is the-- if there's a collision,
then we want the ball's y velocity
67:57 - to randomize every time.
67:59 - So this has the effect of
when we're playing the game
68:02 - and we've detected a collision
between the two paddles,
68:05 - we don't want the same angle
back and forth every time
68:08 - because then the game will just
infinitely take place the exact same--
68:11 - the same angle will just keep
happening over and over again.
68:14 - We don't that to happen.
68:15 - We want some variability in terms of
how the ball bounces off the paddle.
68:19 - So what this does is,
still within the condition,
68:22 - if the ball collides
with player one, we're
68:25 - going to, say, if the y velocity
of the ball is negative,
68:31 - then we want to keep it going negative.
68:32 - We still want the ball--
like if the ball's coming
68:34 - at a sort of an upward angle
and it bounces off the paddle,
68:37 - we want the x velocity to shift.
68:39 - We want it to go to opposite direction,
but we want the ball to keep going up.
68:42 - We don't want the ball to
like bounce back down, which
68:45 - wouldn't make any sense.
68:45 - We don't want to negate the y velocity.
68:47 - So we're going to keep
the y velocity negative,
68:49 - we're going to set it to a
negative value between 10 and 150.
68:53 - And it's just arbitrary.
68:54 - You can set that to whatever you want.
68:55 - And then we're going to do the same
thing if the y velocity is positive.
68:58 - We want the ball to--
69:02 - we want the ball to go in the positive
direction if it's already coming down.
69:07 - So we're doing the
exact same thing here.
69:10 - It's the same logic in
the player two instance.
69:13 - And then this was what I thought I
was looking at before for a second,
69:16 - but this is how we fix the issue of the
upper and lower boundary of the screen.
69:20 - Right.
69:21 - Because it's one thing to solve
the fact that we have the paddles
69:24 - now deflecting the ball,
but we don't want the ball
69:27 - to infinitely go above the
top edge of the screen,
69:30 - or the bottom edge of the screen.
69:32 - So this is just a simple if condition.
69:34 - We're just saying if the
ball's less than or equal to
69:37 - zero, which means if the ball's
at the top edge of the screen,
69:40 - just set it to zero,
so make sure it doesn't
69:42 - go above the edge of the screen,
and then negate its wide velocity,
69:46 - so it's instantly going
to start going downwards.
69:48 - Yes.
69:50 - AUDIENCE: This question
is about Pong 7, line 113.
69:53 - Couldn't the shifting
of the balls dx and y
69:57 - be done in the ball collides
function, if there is a collision?
70:01 - COLTON OGDEN: The shifting of the
ball's function if ball collide-- no,
70:06 - collides the ball--
the collides function
70:08 - is a-- it just returns true or false.
70:11 - So it would be--
70:14 - I mean, I think you probably
could refactor it out that way,
70:19 - but the purpose of
collides isn't to have
70:21 - any sort of side effects like that.
70:23 - Its only purpose is just
to return true or false.
70:25 - Because we can do any-- we could
have any sort of behavior we want.
70:28 - In a collides function, we may not
necessarily want to shift the ball
70:31 - or do anything, we might
just want it return true
70:33 - and print something to the console.
70:35 - So, in terms of, I think, in
an engineering perspective,
70:37 - it makes more sense just to have
a simple true or false function,
70:40 - and then determine how you want
that to actually influence your game
70:43 - state inside your main function,
or inside some other function.
70:48 - OK.
70:51 - And so, Yeah, we went down here.
70:53 - The top edge of the screen, and
then bottom edge of the screen.
70:57 - If the ball.y, it's same exact thing,
just the bottom edge of the screen.
71:00 - If the ball.y is greater than or
equal to virtual height minus four,
71:04 - and we're doing virtual
high minus four, why?
71:06 - AUDIENCE: [INAUDIBLE]
71:08 - COLTON OGDEN: Exactly.
71:09 - So we want to make sure that
we write-- as soon as we--
71:12 - the bottom edge of the ball
touches the bottom of the screen,
71:15 - we want to detect a collision,
then we want to say ball.y, the--
71:18 - gets virtual height minus four in
case it overshot the bottom edge
71:22 - based on how much time has elapsed
and how much the velocity is,
71:25 - you want to instantly put it
right up so that it's at the edge
71:28 - so it's a clean bounce.
71:29 - And then we want to negate
the y velocity just the same
71:32 - as we did up above.
71:35 - And so if we run our program
here, Pong 7, looks the same,
71:46 - but now the ball's bouncing.
71:50 - And note that it got a
neg-- it got a random-- it
71:52 - looks like it's going
below the bottom edge
71:54 - because the monitor is currently at
720 and that's the window resolution,
71:57 - but it is bouncing off
the bottom edge as well.
71:59 - And the angle, if you'll note, is
a little bit different every time,
72:03 - because we are giving it
a random y velocity, a y--
72:10 - yeah.
72:10 - And then that's influencing--
oh, I messed up.
72:14 - I wanted to illustrate
the speed increase.
72:17 - It's going to take a little bit of time.
72:19 - But every time it detects a collision,
it is going to be scaling its--
72:25 - the x velocity by 1.03.
72:28 - So it's going to make
it a little bit faster.
72:30 - Now, currently, the y
angle's a bit steep,
72:31 - so it's going to take
forever to illustrate that.
72:33 - But we'll see that in a later example.
72:37 - So we have the basics of our game.
72:42 - But how are we keeping score?
72:43 - What's the determining factor
for how we keep score in Pong?
72:47 - Left or right.
72:48 - As long as it goes past the left
or right edge of the screen.
72:51 - So what do we need to thereby do?
72:53 - AUDIENCE: [INAUDIBLE]
72:55 - COLTON OGDEN: We do
need a counter, and we
72:57 - need to also monitor
whether the ball has
72:59 - collided with the left or the
right boundary of the screen.
73:03 - And then have that
increment that counter.
73:06 - So we're going to go ahead
and take a look at Pong 8
73:08 - to see how this is implemented.
73:13 - We have here on line 88 and 89 some
counter variables, player one score,
73:18 - player two score.
73:19 - We've had those for a long
time, but we haven't used them.
73:21 - We've only used them
to draw to the screen.
73:23 - We're actually going to now increment
them, and show them as scorekeeping
73:27 - variables in our code here.
73:31 - I thought I had
implemented it in Pong 8,
73:33 - but I think I might have left out
the actual incrementing of the score.
73:36 - But this is the logic that's
pertinent to that example.
73:39 - So if ball.x is less
than zero, which just
73:43 - means if we've gone past
the left edge of the screen,
73:48 - ignore serving player for now.
73:49 - The important thing is now we
are doing player two score,
73:52 - gets player twp score, plus one.
73:54 - Just a simple increment.
73:56 - And then we're resetting the ball.
73:57 - Same thing for here.
73:59 - If the ball.x is greater
than virtual width,
74:01 - so pass the right edge of the screen,
and actually it could be ver--
74:08 - if ball x plus four is
greater than virtual width,
74:12 - then and it will have the same effect.
74:14 - But, actually, no, because
we want to make sure
74:16 - that we don't see the ball
at all when they score.
74:19 - So, yeah, this is actually correct.
74:20 - If ball.x is greater than virtual
width, then serving player gets two,
74:23 - player one score is
player one score plus one.
74:25 - And then we're going to reset the ball.
74:27 - Serving player.
74:29 - So now what we need to talk
about is the idea of serving.
74:33 - So when we start up the game--
74:35 - so let's go ahead and take a look at--
74:42 - we're going to go to Pong now so
we're going to go straight to Pong 9,
74:44 - and then we need to take a look
at what a state machine is.
74:47 - So currently in the game, we've
talked about state a little bit.
74:50 - We've had the start state, which
means the game is ready for us
74:53 - to just press Enter and then the ball
will go off in a random direction.
74:56 - And then we have the play state.
74:58 - And the play state is set to our
paddles interacting with the ball,
75:02 - and then keeping track
of score, basically.
75:06 - A state machine is very important.
75:08 - It's a ubiquitous concept
in game development.
75:11 - It just means, how can we
monitor what state we're in
75:14 - and what transitions take place between
those states to bring out new states.
75:19 - And each individual
state has its own logic.
75:22 - And by breaking out the logic
of these states separately,
75:26 - we can scale our code much bigger
and not have monolithic code for--
75:32 - this particular diagram is an example
of what you might have as a state
75:36 - machine for a character like Mario where
you have a ducking state, a release
75:40 - state which takes the down--
the in-- like the input of down.
75:43 - So if we're releasing down,
it'll become standing.
75:45 - So ducking state, the transition
is release the down key,
75:49 - he becomes standing.
75:50 - Standing key, press the down key.
75:52 - He becomes ducking, these
are states and transitions.
75:56 - These individual states are the
overall representation of his behavior
76:01 - at large, basically.
76:03 - And the same logic applies to our game.
76:06 - We have a play state,
we have a serve state.
76:09 - We want to have maybe a game over state.
76:11 - If someone scores 10 points, then
it should say, oh, the winner is x.
76:16 - And you can define any
arbitrary number of states, it--
76:19 - which depends upon your model,
whatever game you want to develop.
76:22 - For example, like Super
Mario has a title screen,
76:24 - maybe your game has
like a high score state.
76:27 - You want to display all the
high scores in your game
76:30 - and we'll actually show
that in a lecture next week.
76:35 - But this is what a state machine is.
76:37 - It's just a-- it can be in any
one particular state at one time,
76:40 - and the transitions are what allow
you to go in between your states.
76:45 - And each state does have transitions
in and out of other states.
76:49 - And we're going to use this in Pong 9.
76:51 - So beyond illustrating
the score, we're going
76:54 - to start keeping track of more than
just the start and the play state.
76:59 - We're actually going to start
modeling the serve state.
77:02 - And so let me go ahead and
illustrate what this looks like.
77:08 - So if we're here, I just pressed Enter.
77:12 - We started at the start state
as normal, but I pressed Enter
77:16 - and now it says player one serve.
77:18 - So we're actually serving.
77:19 - And so if I press Enter
again as it instructs me,
77:22 - player one is on the left, the
ball should move to the right.
77:25 - Which it does.
77:27 - So I'm going to go ahead and
lose on purpose as player two.
77:33 - And now it's player two's serve.
77:34 - So whichever character, whichever
player loses should get to serve again.
77:38 - And so now if I press
Enter, note when we
77:40 - were player one, the
ball moved to the right.
77:42 - So for player two, the
ball moves to the left.
77:46 - So we have now a little
bit more interaction.
77:49 - We have different states.
77:51 - We start off the game, and
then we serve, and we play.
77:53 - So when the ball's live, when
we're actually doing this,
77:57 - we're in the play state.
77:58 - Now we're in the serve state.
77:59 - So what's the transition between the--
78:03 - sort of the play state
and the serve state?
78:07 - What's the transition there?
78:12 - We score a point.
78:13 - So if we are looking at our state
diagram and we're in the play state,
78:17 - the transition to the serve
state is x player scores a point.
78:23 - And then if we're in the
serve state, the transition
78:25 - is someone presses enter.
78:29 - Enter key gets pressed.
78:30 - And so that's how we want
to think about our games
78:33 - if we have a bunch of different
sets of, sort of logic,
78:37 - that we can sort of take out of our
game and think about conceptually,
78:42 - it allows us to break our game up into
a bunch of different modes and states,
78:46 - and not really get overburdened
by all these variables
78:49 - that maybe need to keep track
of-- or what state are we in?
78:51 - Like what are all these variables doing?
78:53 - And we'll see how we can
break this out in a more
78:55 - modular fashion in future weeks.
78:57 - Note that right now,
currently all we're doing is
78:59 - we're setting a state
variable to some string here,
79:04 - and just doing if
conditions on it, which
79:05 - works fantastically for small examples.
79:08 - So if, like, for example, if we're in
the update function and game state--
79:14 - see, over here we're saying if
the game state is set to serve,
79:17 - then we're initializing
all of the variables.
79:24 - And if the game state
is play, then we need
79:27 - to actually perform our logic here.
79:31 - So if the-- if we're in play,
this is going to get called,
79:34 - each frame, and we're going to say,
if ball collides with player one,
79:36 - do all this stuff.
79:37 - And then this allows us to
sort of think of our game.
79:42 - It's almost like having separate update
functions within our update function.
79:46 - And we'll actually see how we
can take these out of one update
79:49 - function in future weeks with
a actual state machine class
79:53 - and implement things a
little bit more abstractly.
79:56 - But suffice to say, now, whenever
we want to like, for example,
80:01 - make a transition, if
someone scores here,
80:04 - like if we're going to the
left side of the screen,
80:06 - it's ball x is less than zero.
80:09 - All we have to do is just
set this state to serve
80:12 - and our update function is then
going to update appropriately.
80:16 - So any questions on how sort
of state machines or the state
80:20 - works here in the context of Pong?
80:23 - Yes.
80:23 - AUDIENCE: So the state machine
is the relationship to the state
80:29 - or is the container of the states?
80:34 - COLTON OGDEN: The state
machine is sort of a--
80:37 - the overall conceptual look
at what your different states
80:40 - are and their transitions, yes.
80:42 - And in future weeks we're not
implementing a state machine
80:45 - object or a class here.
80:47 - But in future weeks, we will
see the state machine class
80:50 - that manages transitions between
different states in a more
80:53 - modular and clean fashion.
80:54 - All we're doing here
is our state machine
80:57 - is just if statements and saying if the
state is equal to this, then do this.
81:01 - And then change the state to some value.
81:03 - AUDIENCE: So the state
machine is a concept?
81:05 - COLTON OGDEN: It is a concept.
81:07 - Yeah.
81:07 - But we will see an implementation of a
state machine as an object next week.
81:13 - Any more questions?
81:17 - OK.
81:17 - Cool.
81:19 - So currently we have scoring.
81:22 - As we saw, the player one score
and player two score are getting
81:26 - incremented now and, therefore,
getting rendered to the screen
81:28 - whenever we go to the
left or the right edge.
81:31 - So we're keeping track of score.
81:33 - But what do we need now in
order for someone to win?
81:38 - AUDIENCE: [INAUDIBLE].
81:39 - COLTON OGDEN: Sorry?
81:40 - AUDIENCE: [INAUDIBLE].
81:42 - COLTON OGDEN: Yes it does.
81:43 - Exactly.
81:44 - So it's actually quite simple.
81:46 - All we need to really do is
just an if statement, right?
81:49 - If someone's score is equal to some
value, 10, then some player has won.
81:54 - So if we look at player-- if you
look at Pong 10, we go to main,
82:00 - and go to here, line
174, and also line 160,
82:14 - we can see that all it
literally is is in our logic
82:19 - from before, where we're just
testing to see whether the ball is
82:21 - gone beyond the left or the right edge.
82:23 - Because this is effectively where
you need to do your check anyway
82:26 - to see whether someone scored a point.
82:28 - So all we're doing is adding
logic to that part of the program
82:31 - and saying after we
increment their score.
82:34 - If it's equal to 10 we're setting
a value called the winning player.
82:38 - We're going to set it to two.
82:39 - So if the ball.x is less than zero,
then that means that player one got
82:44 - scored on because it went pass
the left edge of the screen.
82:46 - Therefore, player two
score should go up.
82:50 - And, therefore, the winning player
should be, too, if the player two or--
82:54 - two score is equal to 10.
82:56 - And in this case, see, we're here,
we're setting a new state done,
83:00 - and then if that's not the case, or
if their score is still less than 10,
83:04 - we should still-- we should set it
back to serve, and then reset the ball.
83:09 - And so if we go to our
update function, here--
83:13 - actually, we're doing
it in our update phase.
83:18 - So, currently, if it's the
done state, the ball gets reset
83:22 - but no update is being applied
to the ball in that case.
83:24 - We still have scores 10.
83:26 - It'll still render the score,
so score whoever's got 10
83:30 - and it'll show the other player's score.
83:32 - And the actual logic that
applies here, whenever
83:35 - we want to break out of that state, is
in our love.keypressed key function.
83:39 - We see you're on line 227.
83:41 - If game state is equal to done,
which we set it to before,
83:46 - and this will only
execute if they've pressed
83:48 - Enter or return, so
it's effectively waiting
83:50 - for them to press Enter or Return.
83:52 - You want to set game save back to serve.
83:54 - We want to reset the ball.
83:56 - We want to initialize
those scores back to zero.
83:58 - So we're setting up a brand
new game, effectively.
84:02 - If the winning player is one, then
we'll give serving player to two
84:06 - so that they have the
advantage on the next game,
84:09 - and then otherwise set it to one.
84:11 - And if we go down to our render
function, so down to line 275,
84:17 - if we're in the done state, then we
should render to the screen player
84:21 - and then winning player,
because, remember,
84:23 - we set winning player to one
or two, depending on whether--
84:26 - depending on who won and
who scored the tenth point.
84:29 - We'll say player one or two wins,
and we'll just render that and then
84:35 - press Enter to restart after that.
84:37 - And that's the logic for that.
84:39 - And we can see this in playoffs.
84:41 - If it's too slow, we might not
have to go through an entire run.
84:45 - But I sped up the--
84:47 - whoops-- I want to
actually get the ball back.
84:50 - I set up the speed so it's--
we're in the serve state,
84:53 - we're in the play state, it's
up-- the ball bounced back.
84:57 - It's going to be a bit tedious, but
suffice to say, it's a big payoff.
85:02 - Don't worry.
85:06 - Should have set the
speed a little faster.
85:08 - Almost there.
85:12 - It's getting tense.
85:14 - And player one wins.
85:15 - So there we-- we're also setting the
font to a larger size, and in the code
85:19 - I create a new font
object that's basically
85:21 - between the small font and the
score font, which is a large font.
85:26 - So 16 size font.
85:28 - And so player one wins, and that's
really all it boils down to.
85:31 - Just keeping track of your counter
and just making sure that when you do
85:35 - hit 10 in your logic for
detecting the screen collisions,
85:39 - that you set the state to done.
85:41 - And if the state is done, then you
just need to monitor keyboard input
85:44 - and see whenever someone presses enter.
85:46 - Someone press Enter in
our love.keypressed,
85:48 - it does the-- it has
the effect of setting
85:50 - player-- it's player two serve because
player one won so that's only fair.
85:53 - We're going to press Enter to serve
and then we begin a brand new game.
85:56 - And that's simple.
85:57 - So now we have an infinitely playable
game with a bunch of simple states.
86:03 - We're missing a very important
detail, though, in my opinion,
86:05 - and that's sound.
86:06 - Currently, our game is just very--
86:08 - it's great, the gameplay all works.
86:10 - Everything is working fine, but
just missing a little polish.
86:13 - And so what we're going
to do is we're going
86:14 - to start adding audio to the
game, which is, in my opinion,
86:17 - one of the more fun things to
add because it also means you're
86:20 - close to the end of your project.
86:21 - Love.audio.newsource is a function
we're going to look at here.
86:25 - All this is going to do is take a
path and then optionally a type.
86:29 - And this path is going
to be to a sound file,
86:31 - and it's going to create an audio
object that you can play back
86:35 - at any point in your application.
86:37 - So what we're going to effectively do
is just whenever a collision happens,
86:41 - depending on what type of collision it
is, we'll just play a particular sound.
86:46 - And a program that I really
like to use for all of this,
86:49 - and I-- what I encourage
you guys to download
86:51 - if you want to start tinkering with
your own sounds for your project,
86:54 - is a program called bfxr.
86:57 - It's free on Windows and Mac.
86:58 - I'm not sure if they have a Linux port.
87:00 - They might have a Linux port of
a similar program called sfxr
87:05 - which is what this is based off of.
87:07 - But what this allows you to do is just
generate a bunch of random sounds.
87:10 - And I can illustrate
that shortly for you.
87:13 - If you would like to grab
it, it's on bfxr.net.
87:16 - It's a super quick download and--
87:19 - here, I'll actually-- I'll demonstrate
it just so we can see how it plays out.
87:26 - So this is the interface.
87:28 - Make sure I have some audio.
87:30 - And then there is a lot
of different presets here.
87:34 - So there's pickup slash
coin, laser slash shoot.
87:37 - It's meant for sort of
like small games like this,
87:39 - like implementing on the fly
prototype audio type stuff.
87:45 - But you can see, it just implements--
87:46 - I'll turn that down, it's a little loud.
87:49 - It-- we have power-ups, for example.
87:50 - So every time I click on this, it's
going to give us a random power-up so.
87:53 - [COMPUTER SOUND EFFECTS]
88:00 - And then randomized, you get
all sorts of weird nasty stuff.
88:05 - And then-- the stuff that
we'll use is blip slash select.
88:08 - Most of the things in our in like
interfaces and games like Pong you
88:13 - just want simple sounds like this.
88:17 - So I've already done the work
of generating a few sounds
88:20 - that I thought fit pretty well.
88:23 - I'll go ahead and show you
the code first in Pong 11.
88:28 - If we go to-- if you'll see-- if
you look at the directory structure,
88:31 - you'll see we have a sounds folder.
88:33 - In the sounds folder, I've created
three sounds, paddle hit, which
88:36 - is anytime the paddle hits the ball.
88:39 - Score, which is when
any-- anytime the ball
88:41 - goes past the left or the
right boundary of the screen.
88:45 - And then wall hit, so
any time the ball touches
88:47 - the top or the bottom of the screen.
88:49 - And so the logic of this
is extremely simple.
88:52 - All we need to do is whenever--
88:54 - we already have it implemented,
so all we need to do is--
89:01 - oh, first thing, I should say, and
this is a good illustration of a table.
89:07 - And we'll start to see this
a lot more in the future.
89:09 - We didn't really use tables
much in this lecture,
89:11 - but the table is Lua's like sort
of be all, end all, data structure.
89:16 - It's the dictionary-- Python
dictionary, JavaScript object.
89:19 - It's an array, it's everything
that you need for anything
89:23 - beyond simple variables in Lua.
89:24 - It's what everything, even like classes
in other libraries are made out of.
89:28 - In this case, we're just initializing
a table here called sounds,
89:32 - and we're passing in three keys so it
takes-- it can take in key value pairs,
89:35 - or you can just give it a list of values
and it will create indices for them
89:40 - implicitly.
89:42 - Here, we're just passing in like you
would do in Python or JavaScript.
89:46 - Paddle hit, and note that it does
need these square brackets in order
89:50 - to initialize key value pairs in a
table like-- in this format here.
89:55 - Paddle hit gets love.audio.newsource.
89:58 - And in this case, it
just takes in a path,
90:00 - so sounds slash paddle head dot wave.
90:02 - And we're giving it the key
word-- or the string static,
90:05 - which is the type of asset it is--
90:08 - it's stored as.
90:09 - So you can have either static
or stream audio assets.
90:12 - So if they're static,
they're loaded in memory
90:14 - and they're kept in memory for
the execution of your program.
90:17 - If they're stream, then they're
loaded on the fly as needed
90:20 - by your game engine.
90:21 - And streamed audio assets
can be helpful if you
90:24 - have a huge game with a ton of sounds
and a long like large audio files.
90:28 - You don't want to keep all
those in memory, necessarily,
90:30 - because that could take up many,
many, many megs or gigs of audio.
90:33 - And if you're sort of
loading assets on the fly,
90:36 - if you have dynamic
loading in your game,
90:38 - then that's another thing you
should take into consideration.
90:41 - In this case, these are
very tiny sound files,
90:43 - because they're like-- like
a fraction of a second long.
90:46 - So we're just setting them all to
static so they get preserved in memory,
90:49 - and we're just loading all
three of them into this table.
90:52 - And if we want to refer to these later
on, all we need to do is sounds--
90:56 - we can either reference
sounds.paddlehit, like that,
91:01 - if we wanted to.
91:02 - Because by default, Lua just gives you a
dot keyword, sort of the way JavaScript
91:08 - does its objects, with the same
name as the key that you passed in,
91:11 - or you can do it the Pythonic way,
which is, without the dot, sorry--
91:18 - with just square brackets and now have
the same of-- those two are equivalent.
91:23 - It won't work, though, if you
decided to put a space in your key,
91:27 - it will, I believe, it will--
91:30 - just won't work at all, but
it may inject an underscore.
91:33 - I'll have to test it out and find out.
91:35 - But, generally, it's not
best practice to use dot
91:40 - when you already have the keys
lined up like this, anyway.
91:43 - And what you can do
with strings that you
91:45 - can't do with dot
using the dot notation,
91:49 - is dynamically generate a
lookup of your table with you--
91:53 - which you can do with
strings, which you-- yeah,
91:56 - because you can't in a four
loop do four something in table,
92:00 - and then table dot something,
that just won't work.
92:02 - But you can do for
everything in your table
92:06 - and then look up the key as that value,
that iterated value in your table.
92:12 - We'll see examples of
that in future lectures.
92:14 - But that's just something
to keep in mind.
92:16 - So we have our table
here, a sounds table.
92:19 - Oh, and-- and we have our sounds
ready, they're loaded in memory.
92:22 - All we need to do now
is wherever we have
92:24 - anything that, like any collision
in our code, we just do this.
92:28 - It's as simple as the table.
92:30 - At the key that we want,
colon, which is Lua's
92:33 - way of calling a function
of a class or a table.
92:38 - Colon play, and the play function
is part of the new source audio
92:43 - object in LOVE that we
created in the table,
92:46 - and that will just have the
effect of just playing it once.
92:48 - You can set it to looping.
92:50 - You can say the sounds paddle
hit, set looping to true,
92:54 - and it will just infinitely
play over and over again,
92:56 - which we wouldn't want
for a sound like this.
92:58 - It would sound obnoxious.
92:59 - But if you have a music
track, for example,
93:01 - in a level, or something
like that, you would
93:03 - want set looping to be true
so that when it finally ends,
93:06 - your user isn't just
playing a game in silence.
93:11 - So we're doing it with paddle hit,
we're doing it with wall hit as well.
93:14 - So I've named them appropriately
so that it's easy to infer where
93:19 - and for what purpose the
sound files are used.
93:21 - So whenever they're at the upper
or lower boundaries, play the wall
93:24 - hit sound, and then
whenever the ball reaches
93:29 - the left or the right
edge of the screen,
93:31 - just play the score sound effect.
93:34 - And so if we play our game, and this
is always one of my more favorite parts
93:39 - is playing the game with
audio because it just makes
93:43 - such a difference, in my opinion.
93:45 - We get sound effects.
93:47 - It's a little thing, and it's very easy,
but it adds-- it adds so much flavor.
93:52 - And then (explosion), and there we go.
93:54 - And then our game is practically
implemented at this point.
93:58 - There's just one more
example that I would
93:59 - like to show you guys, a small
example, because all of the examples
94:02 - thus far have had the resize
equal-- resizable equals false.
94:08 - Sort of key in the push
setup screen initializer,
94:11 - and in case you want to have a game
where you can resize your window,
94:15 - all we need to do is call a
function called love.resize,
94:18 - which takes a width and a height.
94:20 - And what we're going to
end up doing with that,
94:23 - specifically, for our use
case, because we're using push,
94:25 - we're going to go to Pong 12.
94:30 - And then if we go to main.lua
we see here on line 85,
94:40 - I've changed resizable to equal
true now so that it will actually
94:43 - allow us to resize the application.
94:45 - If that's false, you won't
even be able to click and drag
94:47 - the bottom corner of the screen,
it just won't let you do it.
94:50 - And then all you have to do is
call love.resizewidthheight,
94:56 - and then pass in push
resize with height.
94:59 - Because push underneath the hood
takes a texture and renders to it,
95:03 - and then upscaled it
to fill your window,
95:05 - and so it needs to know what your
current window dimensions are so
95:08 - that it can upscale it to
fit the right dimensions.
95:10 - And push also adds
things like letterboxing,
95:12 - which is convenient if you want to
maintain the exact same aspect ratio.
95:16 - And in a game where maybe
you have the UI that's
95:19 - driven by the size of your
application, this function
95:21 - will be important because
then you can resize your--
95:23 - you can resize and reposition
your UI elements appropriately.
95:27 - Because if your game is small,
maybe you want certain parts of UI
95:30 - to be invisible, or in
a different location
95:33 - altogether, just so that you don't
take up a ton of screen space,
95:36 - and just to accommodate all
possible users of your application.
95:39 - But that has the effect now
of-- if we go into Pong 12
95:43 - and then run it, actually, might not
even be able to use the but-- yeah,
95:48 - I can just do this now.
95:51 - I can resize it, and it'll maintain
the virtual width and height
95:56 - that we set it to before, because
that's like first and foremost
96:01 - what push will do and
it'll letterbox no matter
96:03 - what size your application is to make
sure that it maintains that aspect
96:07 - ratio.
96:07 - So if you're beyond that aspect
ratio vertically or horizontally,
96:10 - you'll get the appropriate
letterboxing for it.
96:12 - So it's super convenient.
96:13 - You don't have to worry about your users
getting super distorted aspect ratios,
96:19 - because they are using some
sort of unforeseen resolution.
96:22 - That will always maintain
it even if it's super tiny
96:25 - because their monitor is super thin.
96:27 - It will always maintain
the aspect ratio.
96:29 - But that's pretty much
it for Pong, actually.
96:33 - We have a complete game, start to
finish, and if you have any questions,
96:37 - I'd be happy to answer them.
96:41 - Any questions?
96:43 - Cool.
96:43 - All right.
96:44 - Well, I'm excited to teach the
rest of this course to you guys.
96:46 - We've only scratched the surface.
96:47 - We have a lot more to cover.
96:48 - Next week, we'll actually
be covering Flappy Bird
96:51 - so we'll get some nice
colorful graphics, which
96:54 - is a stark difference to our
black and white aesthetics today.
96:58 - But that's it for Pong.
97:00 - So thanks for coming.

Cleaned transcript:

[MUSIC PLAYING] DAVID MALAN All right. Welcome to Introduction to Game Development. My name is David Malan, and this is Colton Ogden. And this is a class that assumes only a class like CS50, which is the colleges and the extension schools introduction to computer science but more generally we just assume that you have prior programming experience in most any language and therefore have some comfort with some of the basic constructs of programming. But we assume no background in Lua or Lab 2D or any of the frameworks that we'll be using in the class. All of that lies ahead. So, if you're like me, you probably grew up with video games of some sort. And when you maybe started programming, the programming environments were perhaps very text based, black and white terminal window, and the like. And maybe you did something graphical with a language like scratch or Alice or beyond, or if you're in the world of the web, you've made more graphical applications of some sort, but still pretty static. The sort of content comes on the screen, then the content changes, and so forth. And it's a little less obvious if you're a little newer to programming how you go about creating some of those games from yesteryear with which you all grew up, where there's a lot more animation, there's a lot more asynchronicity, lots of things happening at the same time. A lot of events happening, and you all NOT not only want to capture this interactivity, but also want to respond to events that are happening, especially if you have players elsewhere next to you or online. And so the way the course will be structured is through a narrative of these various games, many of which you might have played yourself. But over the course of the semester, we dive into the context of each of these games and look at some of the underlying principles, the constructs via which they were built up, and really use them as a point of departure for talking about those various capabilities that you might integrate into your own games. And then punctuating the semester, ultimately, will be a number of milestones. Some in the form of smaller assignments that are meant to reinforce just some of the more recent material and sort of set you up for success when the course is deeper and more hands on projects. , Because indeed, the project is where you'll build or extend some of your own games. And then the class itself will culminate at the very end of the semester with your very own final project, an opportunity to propose, to design, and implement a game that somehow or other draws upon the course's lessons. So that when you walk out of here in just a few months' time, you've not only played your fair share of games, but have actually built several of your own. So without further ado, allow me to turn things over to Colton for a look and a stroll through yesteryear's Pong. COLTON OGDEN Thanks, David. I'm very excited to begin teaching you guys this course because game development was actually what got me into programming in the first place. I remember back in 2006 or 2007 buying this book here, 3D Game Programming All In One, which was a look through 3D game programming. And it was a monolithic text in the context of a game engine that was popular in the late 2000s called Torque. It's not as in vogue these days, but it at the time was pretty popular, and it used a language called TorqueScript. And I remember reading through this book and seeing all this code, and I had never seen like source code at all before, or had ever been introduced to programming. And, frankly, I found it quite intimidating, because I was looking at all the syntax that I didn't understand, and I didn't know anything about game development. I had always played games growing up and been fascinated by it, but as I started getting more comfortable with computers and I started to get more curious about it and realized that it was a major profession, I started to dive a little deeper. This was my first foray. And after spending a little bit of time away from it after looking through the source code for a TorqueScript, which was rather arcane, a lot of percent symbols and dollar signs are the weird things that I just hadn't gotten my mind around. I went back to it, started to really learn the basics of programming and other languages, like Python and c and c++, and I grew to really like programming and computer science a lot. And here's just an image of what Torque looked like at the time. It was really the sort of predecessor to Unity nowadays. Although, in my opinion, Unity does things a lot better. It was more accessible, it uses languages that are more in vogue and popular and used by other people already in other domains. And so we'll be covering Unity at the tail end of the course. So we'll be covering predominantly 2D game development. But the topics that we'll be covering today as we get started in the context of Pong are these bullet points here. Lua, which will be the language that we're using predominately throughout the course, which is a dynamic scripting language very similar to Python and JavaScript. We'll be covering LOVE 2D as our primary game framework, which is a runtime and a framework which exposes all of its methods for drawing, audio, input, etc. via Lua, so that it's very easy to write code very quickly, but get very good results. And the documentation for their framework is superb, in my opinion. Today we'll be talking about a few just basic principles as we get our feet wet with game development. Things like drawing shapes, drawing text, these are both very big aspects of Pong, which is just a very simple game based on shapes and text moving around the screen. We'll be talking about Delta Time and Velocity, which Delta Time is probably arguably one of the most important variables that we keep track of in any game framework or engine, which is just the amount of time that's elapsed since the last frame of execution in our game, measured in LOVE 2D in terms of seconds, fractions of seconds. We'll be talking about game state, because you can have a state in your game. You can be at the title screen, you can be playing, you can be in a menu. This will, obviously, be very important because you want different update logic and rendering logic depending on what state you're in. We'll be talking about basic object oriented programming, for those who might be unfamiliar coming from C. It's basically a way of encapsulating our data, any of our game objects, in such a way that the variables that are relevant to them are put together, along with functions that will operate on that data. So instead of having like 20 different variables for all these different objects that you have to keep track of in your code, each individual object can keep track of all its own information, like its position, or anything else that's relevant to it. We'll be talking about hit boxes today, predominantly, in the context of box collision, because we'll be talking about Pong, which is just paddles and a ball. Those are all rectangles. And they'll be colliding with what's called axis aligned bound axis aligned bounding boxes, which makes calculating whether two boxes collided very simple, as opposed to calculating rotated hit boxes, which is a bit more complicated. And then, lastly, we'll polish off with sound effects, because adding that polished layer, in my opinion, is important and it ties it all together and makes it feel like a more cohesive whole. So two important things that we'll need to do when we're following along with the examples, which I'll show you a link to the repo in a moment, is getting LOVE 2D installed. It's a very simple process. The first link here is just a download link. So it's available for all major operating systems. So Linux, Mac, and Windows. And then the Getting Started link down here below will give you some tips as to how to get started, actually running it on your machine on Mac, iAlias, the actual runtime executable within the app that it comes with. So in my bash profiles that I can easily just type love space dot in any directory that has a main dot Lua file, and I can run it anywhere very simply. And there are similar instructions located on the page for other operating systems. And this is the repo here, which has all of the source code that we'll be using today. And I've structured it in a series of 13 different subrepos so that you can follow along and we can build upon Pong starting from scratch, going all the way to a fully implemented game. So the first thing we'll talk about is what Lua is. We'll be using Lua for about 75% of the course. It's a very popular dynamic scripting language. Portuguese for moon, and it was invented in the early 90s as primarily a config language and a runtime language for compiled code bases to save time on adding code to those code bases and recompiling them. A lot faster and a lot easier, especially in the context of the 90s when computers were much slower, to expose the core functionality of your application to Lua so that you can just run it dynamically and then interact with your compiled code on the fly, rather than having to recompile and wait minutes, potentially hours, just to get some new behavior. It's a language that's focused around the concept of a table. Almost everything in Lua aside from basic variables, are tables. A table is essentially a dictionary in Python or an object in JavaScript. Very similar. Intent, for embedded use in larger applications, and the very nature of Lua intended to be used in the context of these large applications meant that it was perfect for interacting with game engines. Because game engines are a perfect example of code bases that are traditionally compiled code for speed purposes. But it can be very cumbersome to have to add minor functionality, and then recompile it and potentially have your whole studio take hours. So we'll be using Lua and a compiled game framework, LOVE 2D, to allow us to rapidly develop. It's similar to JavaScript and Python. A little bit more so to JavaScript. And it's very excellent because it was initially intended as a config language, and a just sort of a glue layer. It's very good for storing data and code together, almost one in the same. So LOVE 2D is a fast 2D game develop development framework. It's compiled in C++ and it runs very efficiently. Because it's so simple, despite the fact that we're running it in Lua, and as modules for basically anything you would need in the context of 2D game development. Only 2D game development officially, although some people I know are working on slight little 3D experiments, but nothing official yet. But it has graphics, keyboard input, math, basically, anything you could want in the context of 2D game development. It's completely free. It's portable. You can even run it on mobile and also the web. And it's excellent for prototyping, even if you don't necessarily want to publish a game in LOVE 2D, it's great and easy and fast just to whip something up in LOVE 2D, and then port that over to whatever framework or engine you might be using in the real world. So before we get into looking at some actual concrete code, I think the most fundamental thing we should take a look at is what a game loop is. So a game, fundamentally, is just an infinite loop, like a while true or a while one. Only in this case, every iteration of that loop we're doing a set of steps back to back over and over again. We're processing input so we're seeing, has the user pressed a key on the keyboard, have they touched their joystick, have they moved the mouse, clicked the mouse. If they have, we need to feed that into our update. We need to keep track of that, and then change anything in our game state that relies upon that input. So we should move our paddles, we should detect collision, we should register all of this, and then whatever has updated, we want to rerender that. We want to render it render where it's changed so that we have the we see on our screen, visually, that things have actually changed in our game world and we interact with it, and we get a sense that we're using something, interacting with something dynamic. And in the context of 2D games, the most fundamental way of looking at the world is via the 2D coordinate system, which is just simply as we learned in geometry in high school, x and yaxis. In this case, it's slightly different than what we typically learn. In high school, we tend to learn that the xy origins, sort of bottom left, y positive goes up, negative goes down, positive x goes right, and negative x goes left. But in this case, we're actually starting in the top left, and then it goes y positive down, y negative up, x positive right, x negative left. And everything that we want to draw in our game needs to have an x and ycoordinate to draw in order for it to be visually seen on the screen. So today's goal, we're going to start a fairly low level and work our way up through examples today and in future classes. Our first game is arguably one of the simplest, but also, one of the most famous games of all time, Pong, which was released in 1972. And the gist of Pong is you have a paddle on the left side of the screen, a paddle on the right side of the screen, whoever scores 10 points by getting the ball past their opponent's paddle onto the edge of the screen, wins. And so today in our lecture, the scope is we want to, first and foremost, draw shapes to the screen, because that's how we get our ball and ball and paddles rendering. And those are just simply rectangles. We want to control the 2D position of these paddles, because we want them to move up and down and want the ball to also move. We want to detect collision between the paddles and the ball, because that's how we get the ball to deflect off the paddles, and to deflect off the ceiling and the floor. And, also, how we detect whether it's gone beyond the edges of the screen, such that one player scores a point. And then we want to add sound effects for sort of a feedback and sort of put ourselves into the game a little bit more. And then scorekeeping, because ultimately the purpose of the game is to beat your opponent, so you want a way to see who has scored 10 points first. And so we're going to look through a set of examples now in the repo. If we look at Pong Zero, I've set this to be called, The Day Zero Update. It's a trend among many games to have the games release major content updates as the x update. So just to be cute, I think we'll call each individual example here, The Something Update. And so I'm going to go into the Pong Zero Repo of the directory, the GitHub repo. And if we're looking at Pong Zero here, we can see it says here, The Day Zero Update. I've commented everything fairly heavily so that we can if you're reading the code, you can sort of get a sense of what's going on. At line 23, we're going to start off by just declaring a window width and a window height. And these are just constant variables that will be accessible throughout the rest of our application. So I'm just setting 1280 by 720 as an arbitrary resolution. It doesn't matter too much. An important thing that we need to look at here is that line 29, we're using a function called love.load, and I'm actually going to go back to the slides here. We're going to look at a few functions, and I'm going to go over them and just sort of tell you what they do before we look at the code in too much detail. So love.load is just a function that given to us by LOVE, LOVE 2D, and we overwrite it. We give it behavior, we tell it what to do. And LOVE 2D is going to look at it in our main.lua file. If we're looking at Pong Zero, you'll see it just has a main.lua file. LOVE 2D expects just a main.lua file, and will run the main.lua file, and you can reference any other file within the directory from that main.lua file. It's our bootstrap, effectively. We're going to override love.load with whatever we want to execute at the very beginning of our application. It's just a startup function. We can also define all that behavior outside of the function above it, but it's good practice to find it within love.load so that someone reading your code will know, OK, this is where all the startup code takes place. Love.update(dt) is a very important function. This function takes in a variable called (dt). Love passes it in a function. You're going to overwrite it with your own behavior, and Love is going to execute this every frame, passing it in delta time, and you can use delta time (dt) in that function to change your application based upon how much time has passed. (dt) will always be a fraction of a second, potentially more, depending on how slow your computer is. But, typically, onesixtieth of a second. And you can scale anything in your game by that amount to get even behavior across all frame rates. Love.draw is the other big function amongst between update and draw. Two of the two, arguably, most important functions. Love.draw is the function that we're going to define that has all of our drawing behavior, our rendering behavior in it. And that's where we can draw our paddles, we can draw our ball. And then update is where we can like change the paddles position and so forth. Two more important functions we'll take a look at in the first example. Love.graphics.printf is the LOVE 2D analog of printf and C. The difference being that this printf lets us actually draw physically onto the screen versus a console. We give it a text as a string, and an x and a ycoordinate and, optionally, a width and an align, and it'll will draw the text at xy, but it will also take into consideration the width, and it'll also take in consideration the align. The with is how much to align it, and the align is the mode of alignment. So if we say x is zero width, our window width, and then we say align center, it's going to go between zero and our window width and center align it. So that'll have the effect of center aligning our text. But we can just as easily say, right, and it will right align it between those two and have the effect of rendering the screen rendering the text along the right edge of the screen. And then lastly, love.window.setmode takes a width and a height and some optional parameters. Those parameters being things like V sync and full screen, and will actually set up our window and get it rendering onto the screen. And so if we go back to our source code here, it at line 29, we're overwriting love.load. We're passing in love.window.setmode, window width and window height, which recall we defined up above as 1280 by 720. We're passing in a table. This is the syntax for a table, these curly brackets. And the way that we define keys and values is just with an equal sign therein. So full screen gets false, resizeable gets false, V sync gets true. So it's going to not be full screen, it's going to be a not resizeable but it is going to be synced to our monitor's refresh rate. And that's where V sync is, short for vertical sync. And then on line 40, we're overwriting love.draw, and this has the love.graphics.printf function, they're in, and we're saying we're passing in the string, hello, Pong. We're starting it at x zero, we're setting it at y window height divided by 2, minus 6. Because the default font size in LOVE 2D is 12 pixels tall. So we're shifting it up by six so it's perfectly centered vertically in the screen. And then we're setting the alignment amount, the width, to window width so that it's going to align it within the entire width of our window. And now we're setting it to center alignment. So it's going to be center aligned within our entire window starting at x zero. And so if we go to Pong zero, and then we actually run it, it has the effect of doing this. We're just rendering in our default font, default size, hello, Pong, right in the middle of the screen. So not a terribly exciting example, but it is showcasing the most important functions of LOVE 2D, so that we can get started with slightly more interesting examples. So, our first content update, is the LowRes Update. So we're developing Pong and Pong is an old game. It doesn't look like the example that we just looked at where the font is fairly high res. We want something that looks a little more retro. So what we want to do is get our resolution looking like it's from a game released in 1972. So what we're going to do is look at a few more important functions here. So Pong One has these functions. So love.graphics.setDefaultFilter. This function, the purpose of that, is every time we have a font or an image in our application, it's going to be applied a filter by default. So it's going to by default a bilinear filter. So what's going to happen, the effect of that is, basically, whenever we magnify or downscale a texture, it's going to think that it's going to assume that we want it to be slightly blurred so as to not look too pixilated. Which is good in certain contexts. For higher res 2D game development, that's good, but as we're going to see, that's not particularly good in the context of retro games. Retro games have a very 2D, crisp, pixilated aesthetic, and we want to preserve that. And so this lets us set a default filter. We'll see that in usage shortly. Another important very important function which is the input phase of our game loop that we saw earlier, love.keypressed(key) is what's going to allow us to start interacting with that aspect of our game. So love.keypressed(key) is a callback function that LOVE expects in main.lua. We're going to overwrite it. It gets passed in a key, and this function gets called every time by LOVE 2D whenever we press a key. It'll detect a key pressed, and it will call this function. Whatever we've defined in here, it will call it, and we can set it to take in certain keys and perform certain operations on that input and it will get a string. So if we say if we press the escape key, key is going to be equal to the string escape in that function, and we have access to that. And another important function, love.event.quit. This has just a very simple effect of quitting the application, though we can call it in the code as opposed to doing it ourselves. And so here's an example of what texture filtering looks like. Point filtering is the same as nearest neighbor filtering, which is what we're going to be using. Bilinear filtering is shown on the right, where it looks pretty blurry. That's what LOVE 2D applies by default to both fonts and to textures. And we'll see that in an example. I can actually run it in two different styles. So if you go to Pong One in the repo, and then we run it, we see here, hello, Pong is now blown up. And we'll look at some more code, actually, to see as to why it's blown up. But if we go back to our code, let me pull up Pong One. Go to main.lua, and then I'm going to explain this in just a second, but let me comment this out and we'll see the difference here. You can see it looks a lot blurrier. And that's the default texture filtering taking place. It applies, like I said, not only to textures but also to fonts. And that's not the aesthetic we want. So let's look at Pong One in detail, starting at the top. On line 28, we're acquiring a library. This is how you get a library in your LOVE 2D application, or your LOVE application. Just equals require and the name of the library. Push is what we're going to be using to take our 1280 by 720 window and turn it into a virtual resolution window at 432 by 243. We can start to think of our game in terms of a more low res feel, and think about it in 432 by 243 pixels, but still render it in a window that's arbitrarily sized. In this case, we're preserving the 1280 by 720 window that we saw before. If you go to our love.load function, we see this being used on line 47. Instead of love.window.setmode, we're now using push setup screen, the push libraries setup screen function, where it takes a virtual width, a virtual height, our regular window width and our window height, and then the same table as before. And this has the effect of setting up a window that's got our concrete dimensions of 1280 by 720, but a virtual resolution of 432 by 243. And so now, when it renders, as we'll see shortly, as well, as we already did see, actually, it's magnified. It has the effect of giving us a lower resolution. And in lineon line 58, if we look at the love.keypressed function, we've put in there, if the key equals the string escape, then love.event.quit. So now we have input handling. We've overridden love.keypressed(key), which LOVE 2D is going to look for in our application, and then call as needed. And then we're just looking in there. If the key is escape, then love.event.quit. And if I run the application, I can now press escape on my keyboard and just quit it and not have to command quit or click the X on a Windows application. And we've changed one more thing, also, in the love.draw function on line 70. We're using the push library now. We need to it functions sort of as a state machine in that we set it to start rendering at a virtual resolution with push apply start, and then push apply end, and then anything in between, this is very similar actually to how Open Go works. We won't go into too much detail. But this is very similar in spirit to how much of Open Go programming works. Push apply start, push apply end. Between that, whatever we call, is going to render at this virtual resolution. And so we are calling the same love.graphics.print(f) function, hello Pong Zero, virtual high divided by two minus six. Same parameters. And it has the effect of rendering everything that's still got the old aliasing going on the skin texture filtering going on as the effect of giving us our magnified text. So same text, same size, but now our window of rendering is much smaller. So Any questions so far on how any of this works? OK. Awesome. So we've gotten text right into the screen, but we're nowhere close to Pong yet, so the first big thing, I think, that's going to get us closer in that direction is what we're going to call the rectangle update. So some important functions that we should look at. Love.graphics.newFont. The default font, I believe, is Arial. We don't want Arial in our application, because we want something that looks a little more retro. We want something that looks more relevant. Love.graphics.newFont will basically take a path to a font file that we have in our folder, which if you're in the Pong 2 folder, you'll see a font.ttf file, and a size. Because every font object that we instantiate needs to have a size, because the font objects are immutable. Once constructed, they cannot be changed so they need to be allocated on a size by size basis. Love.graphics.setFont will take whatever font object we've acquired from this function call, and we can set it here and it'll set the active font in LOVE 2D to be that font. Love is a state machine in the same sense as before, in that it will have an active font at any one time, and whatever print functions you call, will use the currently active font. And that also applies to whatever color you might want to render to the screen, whatever. If you have a font and you want to maybe render it in red, you need a set LOVE 2D's active color to red as well. Love.graphics.clear is a function that takes an RGBA quadruple, and will flush the screen in that color. It just has a simple effect of wiping the screen in that color. Useful for drawing just flat color backgrounds. And then the last function, probably the most important function, is love.graphics.rectangle. And this is the first function that we'll see that actually ends up drawing something beyond text to the screen. It takes it a mode, which can be fill or line, an x and a y and a width and a height, and it'll draw a rectangle in that mode. So either filled, so a filled rectangle, or a line rectangle. It'll take it'll draw it at xy with the width and the height that we pass in. So let's go ahead and take a look at Pong 2 where we can see this actually implemented. So Pong 2, we have our font.ttf in there that I've included. And then a main.lua. And by the way, I forgot to mention last example, push the library that we required is also just in the same directory. And you can just do require as long as the file is there within the directory, it will just load it. You don't have to specify .lua. It assumes when you require some string, that it follows with the .lua suffix. So we're here looking at main.lua in Pong 2, the rectangle update. So on line 28 to 34, it's all the same stuff. We're acquiring push. We have our width and height virtually and physically. In our love.load function, we are on line 43 declaring small font to be a love.graphics.newFont, giving it the path font.ttf because it's right there in the same directory at size eight. And this is going to create a font object, small font, that we can then set as the active font as needed. So if we go down to line 78 in the same directory, we see we're calling love.graphics.clear, and so we're passing it in a color. I sampled some images of Pong on Google Images and saw a background gray that I liked, so 40, 45, 52, RGB, and then 255 just means completely opaque, so no transparency, the alpha component. And then we're doing the same print.function as we did before on line 81. Below that on line 89 down through 95, we're actually calling love.graphics.rectangle. And these are drawing the two paddles and then the ball. So, note, love.graphics.rectangle fill mode, because we want the paddles to be completely filled, as is the ball. We're giving it an xy of 1030 and a width height of 520. And on 992, we're and that'll have the effect of drawing it a little bit shifted from the top left corner, five pixels wide, 20 pixels tall. On line 92, we're doing the same thing, except we're going virtual width minus 10. So it's going to go to the right edge of our screen, virtual width minus 10. So 432 minus 10. So 422. And then virtual height minus 50. So it's going to be slightly it's going to be slightly up from the bottom of the screen. So we have our top left paddle and our bottom right paddle. And then the ball is dead center. So we're sitting doing another graphics rectangle call. Virtual width minus two divided by two. So right in the middle, minus two, because our ball is going to be two pixels wide by two pixels tall. And same thing with virtual height, minus two. Our virtual height divided by two, minus two. So I'm going to go ahead and CD into the Pong 2 directory and run it. And that has the effect of we have our new font here in the middle. So it looks nice and retro, much more so than the Arial font as before. We have a rectangle here, five pixels wide by 20 pixels tall. A ball in the middle, which is four pixels wide by four pixels tall, and then a paddle on the bottom right, which is the same dimensions as the paddle on the left. So it looks very similar to Pong. It's not interactive at all, but we sort of getting the feel of what we want our application to look like. We have it mostly sketched out. So any questions so far as to how this works? OK. Awesome. So Pong 3. So currently we have no interactivity with our application, and we want to be able to move the paddles around. We don't want to just be looking at an at an image the whole time. So the paddle update is going to solve this problem for us. We're going to actually get our first sort of beyond pressing escape to quit the application, we're going to get a sense of interacting with it dynamically. So the important function that we're going to look at in this example is love.keyboard.isDownsomekey. And this is true this is a Boolean function. It just returns true or false depending on whether the key that we pass in as a string is currently pressed down on this frame. So it just returns true or false. And so let's go ahead and take a look at the demo. We're going to go ahead and pull up Pong 3. The main.lua, they're in. Notice that line 37 if you're looking in Pong 3 we, have a new constant we've defined called paddle speed, which gets the value 200. And this is just an arbitrary value that I found was a good speed. But this is how fast our paddle is going to move. We're going to scale it by delta time, so we're going to multiply it by how many seconds have passed. Typically, a fraction of a second since the last frame. And this is going to, therefore, move the same distance over time depending on whether your computer is running at 10 frames per second or 60 frames per second. So if we go down here to line 63, I've also set up two new variables. Player one score and player two score. Those are both initialized at zero. We're going to add in this example, also, some rendering of the score. And notice here on line 49, I've also added a new font, which showcases how you need to separate fonts based on their size because they're immutable objects. Score font gets love.graphics.newFont. Same exact font file, but it's 32 pixels large because the font or the score when rendered in Pong is pretty large in the middle of the screen. And so we're creating we have two different fonts now. One for rendering our message, one for rendering our score. And it's just going to render these two variables, player one score and player two score. And then we've also initialized our y values for the rectangles, the paddles on the left and the right. We need to keep track of their y position, because paddles in Pong can only move up or down. So player 1Y gets the same value it did before when we initialized the rectangle, when we drew it onto the screen. It's going to start at y 30, so pretty high up. And player 2y is going to start pretty low, virtual height minus 50, which is 432 minus 50. And so in love.update, which is our first actual use of the update function on line 75 with the (dt) parameter that gets passed in. Note, remember that LOVE 2D will pass that in for us, but we need to give it we need to define the behavior inside of it. We're using love.keyboard.isDown, and we're passing in the string w and s for this first block. This first block here is player one's movement. So, traditionally, on computer WASD is to move and this example, we're going to allow ourselves to move both paddles, so we're going to use w and s for the left paddle, and up or down for the right paddle. So if love.keyboard.isDown w, which means or we've currently pressing the W key, player 1y is going to get itself, plus negative paddle speed times delta time. So it's going to move up. It's going to take negative paddle speed, multiply it by delta time, and add that onto our y value, which will have the effect of shifting our paddle up. And it's the opposite for on line 82 for if we're pressing the s key. We need to increase the y by positive paddle speed, because recall, yaxis movement is up is negative, down is positive. We're doing the exact same thing with the paddle on the right except we're using up and down as the strings into love.keyboard.isDown. And then down below here, we are rendering in addition to what we rendered before, also, the score now. So on line 125, note that we're calling love.graphics.setFont, scoreFont, because if we don't call this, it will use just whatever the last font was, which by default is the eight pixel font because we set that up top in our program. We want to set it to the score font, and then we want to call love.graphics.print. In this case, I'm just printing them in concrete places not, using printf. Virtual width divided by two minus 50. So no matter how we scale our window, it's always going to be 50 pixels to the left of the center of the window, and the 30 pixels to the right of the center of the window if we're rendering the player two score. And so if we go into Pong 3 and we run it, it looks the same as before. Note, that we do have a score now in the middle of the screen, zero and zero. But, more importantly, we can move our paddles up and down. But there's one problem, and that's I can move beyond the edge of the screen, which is not behavior that we want in our application. So we have some interactivity, it's moving along, but we still have a long way to go, unfortunately. Or fortunately. So let's go ahead and look at the ball update. So we have paddles, they can move, they can move beyond the edge of the screen, but we don't have a ball that it just sits in the middle of the screen. And that's not what we're looking for. We want to have a ball that we can actually bounce between the paddles so we can get an actual game going beyond just moving paddles. So a few important functions we're going to look at. We're going to get our first look here at random. So in games, random number generation is a very common thing so that we get unpredictability and variability between different instances of our game. An important function that just belongs to Lua. It's not a LOVE 2D thing, it's just a Lua thing. Math.random seed numb. So many of you have probably heard of like seed, like a random number generator, seed, and that just means a random number generator. Because it's pseudo random, it needs some sort of starting value to base all of its random numbers off of. It takes a starting number, it performs some mathematical operation on that number to derive new random values that we can then use in our game engine. But if we give it the same number every single time, it's just going to give us the same random numbers every single time, which means it's not going to be random at all. It's going to be very consistent. So we need a way to seed our random number generator, give it a different initial value or seed, and we're going to do that with the function math.randomseed somenumb. OS.time is an important function in the context of this, because a very common way of getting a different number every time you run your application is passing it in whatever the current time is in seconds, because usually it's a very large number that is going to be different every single time you run your game, no matter what. Because it's based upon, in the context of most engines, in the context of Lua, what's called Unix Epoch time, which is zero zero UTC January 1st, 1970, which is some huge number nine or 10 digits long that changes every single second. And then in order to actually take advantage of all this, we need a function to get a random number, and so we do that with math.random, which takes a min and a max, although you don't need to technically pass a min, it'll just implicitly deuse min as one if you don't pass it a min. And it'll return a value inclusively within that range. So if you say math.random one, 50, it'll give us a random inclusively between 1 and 50. And if we just say math.random 50, it'll do the same exact thing. It'll say it'll assume rmin is one and give us a value between one and 50. And then two important mathematical functions that are very basic but helpful in the context of games almost everywhere, it's just math.min, which returns the lesser of two values, and math.max which turns the greater of two values. And we'll see this in the context of clamping values to some range. So let's go ahead and take a look at a demo here. So I'm going to go ahead and open up Pong 4. And going to look at main.lua they're in. So here on line 47, we see we're calling the math.random seedfunction as before. And note that we're passing in OS.time, another function call, because OS.time is going to be different every time we run our application. So we're seeding our application every time we run it based on whatever the current second is relative to zero, zero, zero, zero, zero, zero, January 1st, 1970. Which is going to be different every single time we run. Assuming we don't run it within the same second. And then if we go down to line 71 and seven or, sorry, 67 and 68, we now have we're giving a starting value to our ball, because we want to actually start manipulating our ball. So we give it an X and a Y. So we're setting it right to the center again but, now, we're defining a variable for it instead of just rendering it statically with our love.graphics.rectangle function, because we want this to change over time. We want to start letting our ball move around the screen. So these x and y variables are going to start changing now, and they're going to change relative to its current velocity. And its velocity is going to be stored in ball dx and ball dy. dx and dy are common shorthands for delta x and delta y, which is how you represent velocity. So what we're going to do, effectively, is take whatever our delta x and delta y are and add them onto our ball frame by frame, and that's going to have the effect of updating our ball's position by some value. And separating the delta x and the delta y will allow us to have different angles, different trajectories for our ball. And then another thing that we're also doing in this application, we're starting with the concept of a game state. Because now we can have a starting state, and what we're going to have is a play state. And so all we're going to do here in this example and in this application is start state as a string. In future examples, we're going to use what's called a state machine and actually separate out different states into their own into their own modules. But in the context of this game, we're just going to use a simple string just to illustrate how it works, and we're going to say our first state, when we start the game, should be the start string in the start state. And so here on line 86, what we're going to do is solve a problem that we had in the last example, which was, the paddles could move beyond the edges of the screen, which is not behavior that we should permit. So we're going to call math.max on zero, and the same operation we were doing before, and that will have the effect of returning whichever of those two values is greater. So if the value is if we're adding negative paddle speed to our y value and it goes into the negative range, which means it's beyond the top edge of the screen, zero is going to be the greater of those values and so it will always be zero in that case. math.max returns the greater of the two values. So it'll have the effect of clamping it such that it never goes above the top edge. The inverse is true for line 96, where we call math.min on virtual height minus 20, and player 1.y plus paddle speed.delta times delta time. And this will have the same effect, it will return whichever of these two values is lesser. In which case, if we've gone above virtual height minus 20, which is down at the bottom of the screen shifted by the size of our paddle, it's going to set it to virtual height minus 20. So we never go below that point. And we're doing the same thing for player two, exact same logic. And then if we're in the play state, we're going to actually update our ball's position. So we're in the if we're in the start state, ball's not going to move at all. But if we're in the play state, we want ball x to equal ball x plus ball x times delta time. And note that there is no shorthand in Lua for adding the value to itself, which is why we're calling ball x equals ball x, plus ball x times delta time, instead of just saying ball x plus equals ball x times delta time. Just a language decision that they made. But if we're in the play state, this will have the effect of scaling whatever our current ball's velocity is and times delta time, so it stays frame rate independent. And then adding it to ball x and ball y, which will shift it. And we get this actually working down here in line 170 174. We're now instead of just rendering flat numbers to the screen, we're actually using ball x and ball y to render. And if we're in the play state, those will get updated. But if we go back up to line 127, now, we're in the love.keypressed function, so we're starting on line 120. Before we just had the if key equals escape, then love.event.quit. But now on line 127, we're going to check to see if the key is equal to enter or return, and then we're going to use that as our way of just testing state changes. So we're going to say if the game state is equal to the start, once you press entered, the game state should be equal to play. Otherwise, set it back to start. And we set it back to start, we're going to reinitialize our x and y to be in the center, virtual width divided by two minus two, virtual height divided by two minus two, and we're going to give it an initial random starting velocity again. And note here, this math.random two equal is equal to one, and 100, or negative 100. It's just Lua's way of doing a ternary operation. So in C, you will often have like you would be something like math.random two equals one, and you would have a question mark, 100 colon, negative 100. It's the same exact thing, but Lua doesn't have that sort of shorthand for a ternary operation, so we do it with and and or. We use logical operations instead to do the same thing. And note here we're also showcasing that math.random can take either one argument or two arguments. In this case, we're saying math.random two, which means it will give us a value between one and two. So a 5050. And then if we do negative 5050, that means we'll get a value between negative 50 and 50. So a range of 100, effectively. And so what that has the effect of doing, if we run our application, we go into Pong 4. We're in the start state so now we're rendering if we're in the start state, it's set to render that message. If we press Enter, the ball gets a random veloc it's actually applying the velocity frame by frame. It's updating in the update method. If we press Enter again, it gets reset and we're back in the start state. So we do it again, it's getting a random value. Do it again, random value. Random value. So every time we're getting a different random ball value. But what happens if we try to actually run it, or try to interact with it? Nothing. Goes straight through. So we're missing a key piece, even though we have the core components of our game engine implemented, we don't have any concrete game play, nothing's interacting. And that's a major piece that we need to look at. And so the next before we actually start doing that, though, we're going to take a look at the class update, Pong 5. And so in order to get into more of a in order to scale our code more effectively, we need to start looking in terms of classes. And instead of having an x and a y for our ball, an x and a y for our paddle, a delta x, a delta y for our ball, all these different variables that are sort of all over the place starting to bloat our code, before we get too crazy with it, we should think about how can we put this data altogether so that we can just think in terms of our paddles or our ball object. And so we use what's called a class. If unfamiliar, a class is simply a way of taking all these variables that we've been using thus far, but putting them together in a container such that we can just say, paddle.x or paddle you know, in this case, car. If we have a function called drive car, now we can just say, car.drive instead. We don't have to have functions that are separate from our values, that we can put them all together. We can ask what's our car's current mileage instead of having all these different variables all over the place. So the classes are effectively blueprints. Use it you define a class. You say, OK, my car class is going to have a it's going to have a mileage variable, it's going to have a paint variable, it's going to have a make and a model, it's going to have all these things, and it's going to maintain its own state. It's going to maintain all of that for us. as seen here. And, typically, these are what are called fields. And then we'll have methods as well. Functions that, instead of being like completely separate from this data, a car now basically owns its own functions. It has its own method called drive, or turn, or honk, et cetera, and we don't need to have a function called, like, turn car, or honk car, et cetera. And then this class is effectively a blueprint. Well, we'll see shortly how to define a class, but in order to actually have like one paddle that has its own set of data, and another paddle that has its own set of data, we need to define we need to instantiate, create objects from this class. Basically, use this class as a blueprint, but take it to a factory and create concrete cars from the blueprint. And those are objects. And so as seen here, our paddles and ball are perfect simple use cases for doing this. So let's go ahead and take a look at Pong 5. So in Pong 5, immediately, if you look at the directory structure, you can see that we've added a ball.lua and a paddle.lua. And it's tradition in most languages that have object oriented programming, as it's called, to capitalize class names just so you can differentiate classes, for example, from concrete objects or variables or functions. So if you go to our main.lua, on line 35, we're requiring a library, called class, which is what's going to allow us to actually create these classes. Because classes are not native they are in a sense a native Lua feature, but Lua's way of doing object oriented programming is a little bit convoluted. Some folks have kindly put together a library that makes it a lot simpler, and a lot more closely related to other languages that do object oriented programming more predominantly, like Java or C#, or even Python, allow us to use the keyword class in a way that's very similar to those libraries. On line 39 and 43, we're acquiring our own code, paddle and ball, and we're going to take a look at those right now so we can see what a class looks like. So I'm going to go ahead and open up a the ball file, ball.lua. And we can see here all we need to do just to create a ball class is, using our class library, ball gets class, and then curly brackets like that. And so now we have a class object, a class table, effectively, because everything in Lua is a table. But we can think about it in terms of objects. We have a class object called ball, and then we can start to define functions that belong to this class. So we're going to define what's called a constructor, or an init function in this case, an initializer. And it's going to allow us to initialize our ball with whatever we want. In this case, we want to start our ball off with an x and a y and a width and a height. And notice within here we have a word called self. Self and this are common words in object oriented programming languages that mean whatever object we're creating with this class is going to be self. So we'll see that we'll see that shortly. Self.x gets x. So whatever concrete object we create using this call, this init call, set its x to this x, set its y to the y, set its width, set its height. That specific object. Self. And then we're doing the same thing for delta y and delta x, only that we are setting those two random values just as we did before. Self.dy, self.dx. That belongs to whatever specific object gets instantiated using this init call as we'll see in the code. We're defining just a reset function here just to make it easy. Before we had a several lines of code that set our ball to the middle of the screen and gave it a random velocity. We're doing that now, and this is a good way of sort of refactoring out groups of logic. We're creating a function called reset that just does that all in one function call, and we just call that within our main function, condensing our code. And then notice we have an update and a render function now. And we are going to call these from our own update and our own draw function such that every object that we want in our game, every entity, and we'll build upon this game by game in the future. We'll just call update and render on everything from our main.lua, and defer all of that to each individual class and objects so we don't have to have a main.lua that's like 800 lines of code. We just break out all of the updates that are pertinent to the ball here, and all the render code that's pertinent to the ball here, call each individual balls update and render, and save ourselves a lot of time in refactoring. We're doing the same thing if we look at paddle. Paddle's a class, as well. It gets the reason the class library. Same exact sort of thing here, xy with height, and a dy. In this case, we're just initialising that to zero so that we're not moving. And then we're calling the update function here. So if our dy is less than zero, we're using the math.max function as before, with the top edge of the screen, and then whatever our y plus our current dy is, so delta y. And then here, self.y gets math.min, virtual height minus self.height, self.y plus self.dy times delta time. So that's the clamping behavior that we saw before with the paddles, only now, we took it from main and we put it in our update function so each paddle calls its update, and we take some lines of code out of our main file. And then it has its own render function here, same as the paddle. The render function for the paddle and the render function for the ball are effectively the same. And so if we go to our main, we we're acquiring the paddle and we're acquiring ball so that we can use them. So if we go down to line 79, instead of initializing our ball dx or ball dy, ball x, ball y, paddle y, player 1y, player 2y, now, we have player one is simply paddle 10, 35, 20. And player two is a paddle, virtual width minus 10, virtual height minus 30, 520. Ball is a ball, virtual width divided by two minus two, virtual height minus two, minus two, [? five by ?] two minus two, four and four. So those paddles now have control over their own x and y, their own width and height, and the battle or the ball has its own control over the xy width and height. And the self applies to this object. This is whatever self was in our constructor that we saw before. So even now we can just call so we can simply say player 1.x player 1.width, player 1.y, and everything is contained. We don't need a million variables to keep track of all the things going on in our game. And this is going to be especially important as we scale, and we have maybe we have 100 things on the screen at one time. We don't want 100 times x variables where x is, however many properties that thing has that we need to keep track of. It's all the same logic except, now, we're calling player one update and player two update in our update function, instead of having all that logic therein, where they're moving and then keeping track of whether or not they're going past the top and bottom edges of the screen. And then if game state is play, we're now just calling ball update. And these are all getting passed in delta time. And then same thing here. Instead of having all that logic for restating the ball as one block of code, we took it out, we refactored it, we put it into our ball class, and now all we have to do is just one line of code, ball or reset. And then here down on line 169 in our draw function, we just have player one render, player two render, ball render. And later on as we scale and we make games that have a lot more things on the screen, a lot more entities, we can just do these renders in a loop. We can just say for each entity in our screen, just render it. For each entity in our screen, just update it. We can condense thousands hundreds of lines of code into just a few lines of code by deferring update logic and rendering logic to each individual entity, thanks to object oriented programming. And so that's how we're going to refactor using classes. So any questions on how any of that works so far? Cool. This is a good point, I think, to take a five minute break. And once we come back, we'll talk about how to look at frames per second. All right. So we're going to take a minute just to look at something kind of small, but often it's the case where in games if we want to make sure that we are performing like our applications performing well, we want to some way to monitor our frames per second. And so I figured I would just take a second to illustrate this quickly so that we can use this in the future. The two functions that are going to be important for us here well, the first of these is just a little small cosmetic addition to the application. It's just love.window.setTitle. Title, so far our application, I'm not entirely sure what the it says by default, I think it says what does it say untitled. Yeah. So that's not it's a layer of lack of polish, more or less. And it'd be nice just to solve that problem quickly. So we're going to call a function called love.window.setTitle, some string, which will solve that problem quickly. We can make it look as if we have that detail down. And then the thing that's actually going to let us determine whether or not we are running well or we're running very poorly is a function called love.timer.getframespersecond.getFPS, which is something that LOVE graciously gives us for free and allows us to very easily slap it wherever we want. We can print it to the console, or we can just draw it straight to our application. In this case, we're going to do the latter. So I'm going to go ahead and go into LOVE or Pong 6 in our main. If we go ahead and look at line where is it line 64. love.window.setTitlePong, just quick and easy. Now, our window header is set appropriately, and if we go down to line 198, here I've decided to sort of split out this in a separate function, called display FPS on line 198. And the function is defined on line 207, so a function display FPS, takes no parameters. Its only goal is to just draw our current FPS to the screen. So we're going to set our current font to a small font. We're going to set our color so this is what I alluded to before in that we can set LOVE's rendering color to some RGBA quadruple, and anything that we draw beyond that point will then be drawn at it'll be drawn into whatever that color is. So, in this case, we're giving it red of zero, 255 on the green, zero blue, 255 fully opaque, which has the effect of setting our color to just completely green. And then love.graphics.print, our current FPS string, and then our current FPS here, which is love.timer.getFPS. But it's going to return that as a number, and by default, Lua does not allow you to concatenate strings and numbers, so we're going to concatenate here with this ..operator, which is the way of doing string concatenation in Lua. We're going to call the two string function. So we're going to take in love.timer.FPS, we're going to make it a string, and then we're going to concatenate it here. And then we're going to call love.graphics.print on that value, and then we're going to put it at 10, 10. So shift it just a little bit from the top left edge of the screen. So that's going to have the effect of the go to Pong 6, and we run it. We can see now it starts at zero and 52 because it has to gather a few frames of data before it has a number we can actually use. But we see there FPS at 60, and so our game runs, otherwise, just the same. Completely random. A little bit broken, but that's OK, we'll fix it up. But currently we have a problem, and that's that our ball is just going straight through our paddles. So how can we fix this problem? We need some way of detecting collision. So in 2D games, generally, there's a concept of aa bb collision detection. And what this is is axis aligned bounding box collision detection, which means that we have bounding boxes, just rectangles, quads, which have an x and a y and a width and a height which are nonrotated. So they're completely aligned with our axes. They're completely parallel perpendicular. So the only way that we can get this easy math, the aa bb collision detection working is if we have no rotation of our boxes. They have to be completely aligned. But if they are, we have a very simple algorithm, which is we're just making sure that no edges of our boxes are outside the opposite edges of our of the other rectangle. So if we have one rectangle and I'll illustrate this on the screen here. We have two rectangles. If this top edge is below this edge, we know no matter what, they're not going to inter they're not intersecting. There is no way it can because it's below here. So no matter where it is on the x and the y, if it's below here, it's not a collision. If this edge is on this side of this rectangle, we know, as well, there's no way those two boxes can overlap. And it applies to every edge as long as it is the opposite edge. So if this edge is below this one, if this edge is above this one, if this edge is on the right, and this edge is on the left, it means that no matter what, those boxes aren't colliding. So we can simply do four conditions. We can say, if rec1.x is not greater than rec 2.x, plus rec2.width, and rec1.x plus rec1.width is not less than rec2.x, so if the two edges are not beyond their opposite edges, same thing with the y, and the y plus rec1.height, we know that we have a collision. We know that because we haven't fulfilled any of those criteria. But we know that if that's not true, if the one of the edges is not beyond the opposite edge, then it's we do have a collision. So it is going to be true. So we'll see that here in our code. The go to Pongs 7, at line 113, we have a function that we're calling called ball collides. Our ball class has a function called collides. So let's go ahead and take a look at our ball class. And in this case, we've defined our function such that it takes in a paddle parameter, so it's going to compare against another rectangle that has an xy and a width and a height. And we're saying that if rx is greater than the paddle x, plus the paddle width, which means if rx is greater than the right edge. So if our top left is greater than the or just our left is greater than the right edge, we know that we can't collide. Same thing if it's greater than the other rectangles, self.x plus self.width. No, sorry. In that case, if the paddle's x is it basically the same operation but from the paddle's perspective. If the paddle is greater than the rectangle on the right side, if it's farther along the right side past the right edge, we know that there can be no collision. It's just impossible. Same thing with y. If the y self.y, so this ball is y is greater than the paddle's y, plus the paddle height. So if it's below the edge of the paddle, because we're taking the height into consideration, or if the paddle's y is greater than this ball's y plus self.height, then we know that that also can't be a collision. But if that's not true, then we need to return true. And so if we go back to our main no, that's the wrong main. We go back to main.lua here. We're calling ball.collides. So if we're in our game state, if we're in our sorry, if we're in our play state, if game state is equal to play, if the ball collides with player one, so player one is the left paddle. So if there's a collision detected, the ball.dx and dx is our x velocity. So it's whatever direction it's moving on the xaxis. So it's going to be moving to the left if it's gone if we detected a collision. And it doesn't matter whether it's moving left or right, but we needed what we need to do is set it to its negative value. Because if it's moving left and we said let's say it's moving left at its negative 20 pixels and we set to 20, the dx is now 20, it's going to start moving to the right. It's going to have the effect of inverting its x velocity and, therefore, reversing its direction. But what we're also doing here with times 1.03 is we're multiplying a little bit just to speed up the game. Because we don't want the game to into perpetuity just have the same velocity. It's not going to ramp up the excitement. We want to keep things going, we want to get some momentum going, so what we're going to do is call ball.dx equals its negative value times a scaler that we've determined arbitrarily. In this case, I've decided it should be point 1.03 so it'll increase it by 3% every time. And then in the event that we have a our ball because it's getting added, its x velocity is getting added each frame to its position, we want to make sure that it's not like inside of our paddle. Because it is possible that it could shift a certain number of pixels to the left, or to the right, because the same operation applies. Such that the two are sort of like on top of each other. We want to re we want to shift it, we want to reset it. So what we're going to do because it'll detect another collision immediately if that's the case. If it, on the next frame, it's within that paddle, it's going to say that it's still colliding with that paddle so it's going to shift its velocity again. And it's going to have the effect of it infinitely sort of bouncing back and forth within the paddle. We don't want that to happen. So if we detect a collision, we want to shift it. We want to make sure it's completely outside of the paddle's collision box. So we're saying ball.x gets player one.x, plus five. Plus five because that's the width of the paddle. So that has the effect of just once you detect a collision, negative set x velocity to negative, and then instantly shift it right on the right edge of the left paddle. And we're doing the same thing here. If ball collides a play or two, we're doing the we're negating or inverting its x velocity. And then this is the same exact operation, but since it's based on the the left top left corner, we can't minus it by five, that wouldn't make sense. We're going to minus it by four because that's the width of the ball. So if we minused it by five, we would have one pixel of space. We plussed it by five on this example, because we're coming in from the right side. We want to just make sure that it's right on the right edge of the paddle, so we're setting it to player one.x. And in this case, we're using the minus four because that's the width of the ball. So we want to shift it to the left, the width of the ball, and that will have the effect of the right paddle, if there is a collision, it'll just get shifted over, and the right the ball will be touching the paddle right on their two edges. Here on line 118, we're solving the problem we had before of what happens when the oh, sorry, that's actually not what I was thinking of. This is the if there's a collision, then we want the ball's y velocity to randomize every time. So this has the effect of when we're playing the game and we've detected a collision between the two paddles, we don't want the same angle back and forth every time because then the game will just infinitely take place the exact same the same angle will just keep happening over and over again. We don't that to happen. We want some variability in terms of how the ball bounces off the paddle. So what this does is, still within the condition, if the ball collides with player one, we're going to, say, if the y velocity of the ball is negative, then we want to keep it going negative. We still want the ball like if the ball's coming at a sort of an upward angle and it bounces off the paddle, we want the x velocity to shift. We want it to go to opposite direction, but we want the ball to keep going up. We don't want the ball to like bounce back down, which wouldn't make any sense. We don't want to negate the y velocity. So we're going to keep the y velocity negative, we're going to set it to a negative value between 10 and 150. And it's just arbitrary. You can set that to whatever you want. And then we're going to do the same thing if the y velocity is positive. We want the ball to we want the ball to go in the positive direction if it's already coming down. So we're doing the exact same thing here. It's the same logic in the player two instance. And then this was what I thought I was looking at before for a second, but this is how we fix the issue of the upper and lower boundary of the screen. Right. Because it's one thing to solve the fact that we have the paddles now deflecting the ball, but we don't want the ball to infinitely go above the top edge of the screen, or the bottom edge of the screen. So this is just a simple if condition. We're just saying if the ball's less than or equal to zero, which means if the ball's at the top edge of the screen, just set it to zero, so make sure it doesn't go above the edge of the screen, and then negate its wide velocity, so it's instantly going to start going downwards. Yes. AUDIENCE This question is about Pong 7, line 113. Couldn't the shifting of the balls dx and y be done in the ball collides function, if there is a collision? COLTON OGDEN The shifting of the ball's function if ball collide no, collides the ball the collides function is a it just returns true or false. So it would be I mean, I think you probably could refactor it out that way, but the purpose of collides isn't to have any sort of side effects like that. Its only purpose is just to return true or false. Because we can do any we could have any sort of behavior we want. In a collides function, we may not necessarily want to shift the ball or do anything, we might just want it return true and print something to the console. So, in terms of, I think, in an engineering perspective, it makes more sense just to have a simple true or false function, and then determine how you want that to actually influence your game state inside your main function, or inside some other function. OK. And so, Yeah, we went down here. The top edge of the screen, and then bottom edge of the screen. If the ball.y, it's same exact thing, just the bottom edge of the screen. If the ball.y is greater than or equal to virtual height minus four, and we're doing virtual high minus four, why? AUDIENCE [INAUDIBLE] COLTON OGDEN Exactly. So we want to make sure that we write as soon as we the bottom edge of the ball touches the bottom of the screen, we want to detect a collision, then we want to say ball.y, the gets virtual height minus four in case it overshot the bottom edge based on how much time has elapsed and how much the velocity is, you want to instantly put it right up so that it's at the edge so it's a clean bounce. And then we want to negate the y velocity just the same as we did up above. And so if we run our program here, Pong 7, looks the same, but now the ball's bouncing. And note that it got a neg it got a random it looks like it's going below the bottom edge because the monitor is currently at 720 and that's the window resolution, but it is bouncing off the bottom edge as well. And the angle, if you'll note, is a little bit different every time, because we are giving it a random y velocity, a y yeah. And then that's influencing oh, I messed up. I wanted to illustrate the speed increase. It's going to take a little bit of time. But every time it detects a collision, it is going to be scaling its the x velocity by 1.03. So it's going to make it a little bit faster. Now, currently, the y angle's a bit steep, so it's going to take forever to illustrate that. But we'll see that in a later example. So we have the basics of our game. But how are we keeping score? What's the determining factor for how we keep score in Pong? Left or right. As long as it goes past the left or right edge of the screen. So what do we need to thereby do? AUDIENCE [INAUDIBLE] COLTON OGDEN We do need a counter, and we need to also monitor whether the ball has collided with the left or the right boundary of the screen. And then have that increment that counter. So we're going to go ahead and take a look at Pong 8 to see how this is implemented. We have here on line 88 and 89 some counter variables, player one score, player two score. We've had those for a long time, but we haven't used them. We've only used them to draw to the screen. We're actually going to now increment them, and show them as scorekeeping variables in our code here. I thought I had implemented it in Pong 8, but I think I might have left out the actual incrementing of the score. But this is the logic that's pertinent to that example. So if ball.x is less than zero, which just means if we've gone past the left edge of the screen, ignore serving player for now. The important thing is now we are doing player two score, gets player twp score, plus one. Just a simple increment. And then we're resetting the ball. Same thing for here. If the ball.x is greater than virtual width, so pass the right edge of the screen, and actually it could be ver if ball x plus four is greater than virtual width, then and it will have the same effect. But, actually, no, because we want to make sure that we don't see the ball at all when they score. So, yeah, this is actually correct. If ball.x is greater than virtual width, then serving player gets two, player one score is player one score plus one. And then we're going to reset the ball. Serving player. So now what we need to talk about is the idea of serving. So when we start up the game so let's go ahead and take a look at we're going to go to Pong now so we're going to go straight to Pong 9, and then we need to take a look at what a state machine is. So currently in the game, we've talked about state a little bit. We've had the start state, which means the game is ready for us to just press Enter and then the ball will go off in a random direction. And then we have the play state. And the play state is set to our paddles interacting with the ball, and then keeping track of score, basically. A state machine is very important. It's a ubiquitous concept in game development. It just means, how can we monitor what state we're in and what transitions take place between those states to bring out new states. And each individual state has its own logic. And by breaking out the logic of these states separately, we can scale our code much bigger and not have monolithic code for this particular diagram is an example of what you might have as a state machine for a character like Mario where you have a ducking state, a release state which takes the down the in like the input of down. So if we're releasing down, it'll become standing. So ducking state, the transition is release the down key, he becomes standing. Standing key, press the down key. He becomes ducking, these are states and transitions. These individual states are the overall representation of his behavior at large, basically. And the same logic applies to our game. We have a play state, we have a serve state. We want to have maybe a game over state. If someone scores 10 points, then it should say, oh, the winner is x. And you can define any arbitrary number of states, it which depends upon your model, whatever game you want to develop. For example, like Super Mario has a title screen, maybe your game has like a high score state. You want to display all the high scores in your game and we'll actually show that in a lecture next week. But this is what a state machine is. It's just a it can be in any one particular state at one time, and the transitions are what allow you to go in between your states. And each state does have transitions in and out of other states. And we're going to use this in Pong 9. So beyond illustrating the score, we're going to start keeping track of more than just the start and the play state. We're actually going to start modeling the serve state. And so let me go ahead and illustrate what this looks like. So if we're here, I just pressed Enter. We started at the start state as normal, but I pressed Enter and now it says player one serve. So we're actually serving. And so if I press Enter again as it instructs me, player one is on the left, the ball should move to the right. Which it does. So I'm going to go ahead and lose on purpose as player two. And now it's player two's serve. So whichever character, whichever player loses should get to serve again. And so now if I press Enter, note when we were player one, the ball moved to the right. So for player two, the ball moves to the left. So we have now a little bit more interaction. We have different states. We start off the game, and then we serve, and we play. So when the ball's live, when we're actually doing this, we're in the play state. Now we're in the serve state. So what's the transition between the sort of the play state and the serve state? What's the transition there? We score a point. So if we are looking at our state diagram and we're in the play state, the transition to the serve state is x player scores a point. And then if we're in the serve state, the transition is someone presses enter. Enter key gets pressed. And so that's how we want to think about our games if we have a bunch of different sets of, sort of logic, that we can sort of take out of our game and think about conceptually, it allows us to break our game up into a bunch of different modes and states, and not really get overburdened by all these variables that maybe need to keep track of or what state are we in? Like what are all these variables doing? And we'll see how we can break this out in a more modular fashion in future weeks. Note that right now, currently all we're doing is we're setting a state variable to some string here, and just doing if conditions on it, which works fantastically for small examples. So if, like, for example, if we're in the update function and game state see, over here we're saying if the game state is set to serve, then we're initializing all of the variables. And if the game state is play, then we need to actually perform our logic here. So if the if we're in play, this is going to get called, each frame, and we're going to say, if ball collides with player one, do all this stuff. And then this allows us to sort of think of our game. It's almost like having separate update functions within our update function. And we'll actually see how we can take these out of one update function in future weeks with a actual state machine class and implement things a little bit more abstractly. But suffice to say, now, whenever we want to like, for example, make a transition, if someone scores here, like if we're going to the left side of the screen, it's ball x is less than zero. All we have to do is just set this state to serve and our update function is then going to update appropriately. So any questions on how sort of state machines or the state works here in the context of Pong? Yes. AUDIENCE So the state machine is the relationship to the state or is the container of the states? COLTON OGDEN The state machine is sort of a the overall conceptual look at what your different states are and their transitions, yes. And in future weeks we're not implementing a state machine object or a class here. But in future weeks, we will see the state machine class that manages transitions between different states in a more modular and clean fashion. All we're doing here is our state machine is just if statements and saying if the state is equal to this, then do this. And then change the state to some value. AUDIENCE So the state machine is a concept? COLTON OGDEN It is a concept. Yeah. But we will see an implementation of a state machine as an object next week. Any more questions? OK. Cool. So currently we have scoring. As we saw, the player one score and player two score are getting incremented now and, therefore, getting rendered to the screen whenever we go to the left or the right edge. So we're keeping track of score. But what do we need now in order for someone to win? AUDIENCE [INAUDIBLE]. COLTON OGDEN Sorry? AUDIENCE [INAUDIBLE]. COLTON OGDEN Yes it does. Exactly. So it's actually quite simple. All we need to really do is just an if statement, right? If someone's score is equal to some value, 10, then some player has won. So if we look at player if you look at Pong 10, we go to main, and go to here, line 174, and also line 160, we can see that all it literally is is in our logic from before, where we're just testing to see whether the ball is gone beyond the left or the right edge. Because this is effectively where you need to do your check anyway to see whether someone scored a point. So all we're doing is adding logic to that part of the program and saying after we increment their score. If it's equal to 10 we're setting a value called the winning player. We're going to set it to two. So if the ball.x is less than zero, then that means that player one got scored on because it went pass the left edge of the screen. Therefore, player two score should go up. And, therefore, the winning player should be, too, if the player two or two score is equal to 10. And in this case, see, we're here, we're setting a new state done, and then if that's not the case, or if their score is still less than 10, we should still we should set it back to serve, and then reset the ball. And so if we go to our update function, here actually, we're doing it in our update phase. So, currently, if it's the done state, the ball gets reset but no update is being applied to the ball in that case. We still have scores 10. It'll still render the score, so score whoever's got 10 and it'll show the other player's score. And the actual logic that applies here, whenever we want to break out of that state, is in our love.keypressed key function. We see you're on line 227. If game state is equal to done, which we set it to before, and this will only execute if they've pressed Enter or return, so it's effectively waiting for them to press Enter or Return. You want to set game save back to serve. We want to reset the ball. We want to initialize those scores back to zero. So we're setting up a brand new game, effectively. If the winning player is one, then we'll give serving player to two so that they have the advantage on the next game, and then otherwise set it to one. And if we go down to our render function, so down to line 275, if we're in the done state, then we should render to the screen player and then winning player, because, remember, we set winning player to one or two, depending on whether depending on who won and who scored the tenth point. We'll say player one or two wins, and we'll just render that and then press Enter to restart after that. And that's the logic for that. And we can see this in playoffs. If it's too slow, we might not have to go through an entire run. But I sped up the whoops I want to actually get the ball back. I set up the speed so it's we're in the serve state, we're in the play state, it's up the ball bounced back. It's going to be a bit tedious, but suffice to say, it's a big payoff. Don't worry. Should have set the speed a little faster. Almost there. It's getting tense. And player one wins. So there we we're also setting the font to a larger size, and in the code I create a new font object that's basically between the small font and the score font, which is a large font. So 16 size font. And so player one wins, and that's really all it boils down to. Just keeping track of your counter and just making sure that when you do hit 10 in your logic for detecting the screen collisions, that you set the state to done. And if the state is done, then you just need to monitor keyboard input and see whenever someone presses enter. Someone press Enter in our love.keypressed, it does the it has the effect of setting player it's player two serve because player one won so that's only fair. We're going to press Enter to serve and then we begin a brand new game. And that's simple. So now we have an infinitely playable game with a bunch of simple states. We're missing a very important detail, though, in my opinion, and that's sound. Currently, our game is just very it's great, the gameplay all works. Everything is working fine, but just missing a little polish. And so what we're going to do is we're going to start adding audio to the game, which is, in my opinion, one of the more fun things to add because it also means you're close to the end of your project. Love.audio.newsource is a function we're going to look at here. All this is going to do is take a path and then optionally a type. And this path is going to be to a sound file, and it's going to create an audio object that you can play back at any point in your application. So what we're going to effectively do is just whenever a collision happens, depending on what type of collision it is, we'll just play a particular sound. And a program that I really like to use for all of this, and I what I encourage you guys to download if you want to start tinkering with your own sounds for your project, is a program called bfxr. It's free on Windows and Mac. I'm not sure if they have a Linux port. They might have a Linux port of a similar program called sfxr which is what this is based off of. But what this allows you to do is just generate a bunch of random sounds. And I can illustrate that shortly for you. If you would like to grab it, it's on bfxr.net. It's a super quick download and here, I'll actually I'll demonstrate it just so we can see how it plays out. So this is the interface. Make sure I have some audio. And then there is a lot of different presets here. So there's pickup slash coin, laser slash shoot. It's meant for sort of like small games like this, like implementing on the fly prototype audio type stuff. But you can see, it just implements I'll turn that down, it's a little loud. It we have powerups, for example. So every time I click on this, it's going to give us a random powerup so. [COMPUTER SOUND EFFECTS] And then randomized, you get all sorts of weird nasty stuff. And then the stuff that we'll use is blip slash select. Most of the things in our in like interfaces and games like Pong you just want simple sounds like this. So I've already done the work of generating a few sounds that I thought fit pretty well. I'll go ahead and show you the code first in Pong 11. If we go to if you'll see if you look at the directory structure, you'll see we have a sounds folder. In the sounds folder, I've created three sounds, paddle hit, which is anytime the paddle hits the ball. Score, which is when any anytime the ball goes past the left or the right boundary of the screen. And then wall hit, so any time the ball touches the top or the bottom of the screen. And so the logic of this is extremely simple. All we need to do is whenever we already have it implemented, so all we need to do is oh, first thing, I should say, and this is a good illustration of a table. And we'll start to see this a lot more in the future. We didn't really use tables much in this lecture, but the table is Lua's like sort of be all, end all, data structure. It's the dictionary Python dictionary, JavaScript object. It's an array, it's everything that you need for anything beyond simple variables in Lua. It's what everything, even like classes in other libraries are made out of. In this case, we're just initializing a table here called sounds, and we're passing in three keys so it takes it can take in key value pairs, or you can just give it a list of values and it will create indices for them implicitly. Here, we're just passing in like you would do in Python or JavaScript. Paddle hit, and note that it does need these square brackets in order to initialize key value pairs in a table like in this format here. Paddle hit gets love.audio.newsource. And in this case, it just takes in a path, so sounds slash paddle head dot wave. And we're giving it the key word or the string static, which is the type of asset it is it's stored as. So you can have either static or stream audio assets. So if they're static, they're loaded in memory and they're kept in memory for the execution of your program. If they're stream, then they're loaded on the fly as needed by your game engine. And streamed audio assets can be helpful if you have a huge game with a ton of sounds and a long like large audio files. You don't want to keep all those in memory, necessarily, because that could take up many, many, many megs or gigs of audio. And if you're sort of loading assets on the fly, if you have dynamic loading in your game, then that's another thing you should take into consideration. In this case, these are very tiny sound files, because they're like like a fraction of a second long. So we're just setting them all to static so they get preserved in memory, and we're just loading all three of them into this table. And if we want to refer to these later on, all we need to do is sounds we can either reference sounds.paddlehit, like that, if we wanted to. Because by default, Lua just gives you a dot keyword, sort of the way JavaScript does its objects, with the same name as the key that you passed in, or you can do it the Pythonic way, which is, without the dot, sorry with just square brackets and now have the same of those two are equivalent. It won't work, though, if you decided to put a space in your key, it will, I believe, it will just won't work at all, but it may inject an underscore. I'll have to test it out and find out. But, generally, it's not best practice to use dot when you already have the keys lined up like this, anyway. And what you can do with strings that you can't do with dot using the dot notation, is dynamically generate a lookup of your table with you which you can do with strings, which you yeah, because you can't in a four loop do four something in table, and then table dot something, that just won't work. But you can do for everything in your table and then look up the key as that value, that iterated value in your table. We'll see examples of that in future lectures. But that's just something to keep in mind. So we have our table here, a sounds table. Oh, and and we have our sounds ready, they're loaded in memory. All we need to do now is wherever we have anything that, like any collision in our code, we just do this. It's as simple as the table. At the key that we want, colon, which is Lua's way of calling a function of a class or a table. Colon play, and the play function is part of the new source audio object in LOVE that we created in the table, and that will just have the effect of just playing it once. You can set it to looping. You can say the sounds paddle hit, set looping to true, and it will just infinitely play over and over again, which we wouldn't want for a sound like this. It would sound obnoxious. But if you have a music track, for example, in a level, or something like that, you would want set looping to be true so that when it finally ends, your user isn't just playing a game in silence. So we're doing it with paddle hit, we're doing it with wall hit as well. So I've named them appropriately so that it's easy to infer where and for what purpose the sound files are used. So whenever they're at the upper or lower boundaries, play the wall hit sound, and then whenever the ball reaches the left or the right edge of the screen, just play the score sound effect. And so if we play our game, and this is always one of my more favorite parts is playing the game with audio because it just makes such a difference, in my opinion. We get sound effects. It's a little thing, and it's very easy, but it adds it adds so much flavor. And then (explosion), and there we go. And then our game is practically implemented at this point. There's just one more example that I would like to show you guys, a small example, because all of the examples thus far have had the resize equal resizable equals false. Sort of key in the push setup screen initializer, and in case you want to have a game where you can resize your window, all we need to do is call a function called love.resize, which takes a width and a height. And what we're going to end up doing with that, specifically, for our use case, because we're using push, we're going to go to Pong 12. And then if we go to main.lua we see here on line 85, I've changed resizable to equal true now so that it will actually allow us to resize the application. If that's false, you won't even be able to click and drag the bottom corner of the screen, it just won't let you do it. And then all you have to do is call love.resizewidthheight, and then pass in push resize with height. Because push underneath the hood takes a texture and renders to it, and then upscaled it to fill your window, and so it needs to know what your current window dimensions are so that it can upscale it to fit the right dimensions. And push also adds things like letterboxing, which is convenient if you want to maintain the exact same aspect ratio. And in a game where maybe you have the UI that's driven by the size of your application, this function will be important because then you can resize your you can resize and reposition your UI elements appropriately. Because if your game is small, maybe you want certain parts of UI to be invisible, or in a different location altogether, just so that you don't take up a ton of screen space, and just to accommodate all possible users of your application. But that has the effect now of if we go into Pong 12 and then run it, actually, might not even be able to use the but yeah, I can just do this now. I can resize it, and it'll maintain the virtual width and height that we set it to before, because that's like first and foremost what push will do and it'll letterbox no matter what size your application is to make sure that it maintains that aspect ratio. So if you're beyond that aspect ratio vertically or horizontally, you'll get the appropriate letterboxing for it. So it's super convenient. You don't have to worry about your users getting super distorted aspect ratios, because they are using some sort of unforeseen resolution. That will always maintain it even if it's super tiny because their monitor is super thin. It will always maintain the aspect ratio. But that's pretty much it for Pong, actually. We have a complete game, start to finish, and if you have any questions, I'd be happy to answer them. Any questions? Cool. All right. Well, I'm excited to teach the rest of this course to you guys. We've only scratched the surface. We have a lot more to cover. Next week, we'll actually be covering Flappy Bird so we'll get some nice colorful graphics, which is a stark difference to our black and white aesthetics today. But that's it for Pong. So thanks for coming.
