With timestamps:

00:00 - [Music]
00:16 - all right welcome to gd50 lecture five
00:19 - today's topic is the legend of zelda as
00:21 - you can see on the screen there uh very
00:23 - iconic game last week we did super mario
00:26 - brothers which is arguably the most
00:27 - iconic video game of all time legend of
00:29 - zelda is a close contender
00:31 - even now just like with mario they're
00:32 - producing very wonderful games i think
00:34 - last year breath of the wild took all
00:36 - the i forget which
00:39 - ceremony it was or
00:40 - awards sort of show but it took like
00:42 - every award possible this last year the
00:44 - latest zelda breath of the wild
00:46 - so it feels sort of apropos to talk
00:48 - about legend of zelda in that context as
00:50 - well
00:51 - uh here's a screenshot of the original
00:53 - legend of zelda it was an nes title just
00:55 - like super mario brothers a you know
00:57 - just like most games of its time tile
00:58 - based you can sort of see how the
01:00 - surroundings are sort of layered tiles
01:02 - bit by bit
01:04 - the goal of the game overall was to sort
01:06 - of explore this open world which is kind
01:08 - of a first of its kind
01:11 - you controlled link shown at the very
01:12 - bottom there you had a sword you had
01:14 - bombs you had arrows you had uh you went
01:16 - to go find rupees you went through
01:18 - dungeons you slayed monsters and bosses
01:20 - and then ultimately the goal was to
01:22 - obtain the triforce which is shown at
01:24 - the very top left and right of the slide
01:26 - here
01:28 - here's the screenshot another screenshot
01:29 - legend is all the inside and actual
01:30 - dungeon where you can see at the very
01:32 - top there's got like a map layout maps
01:34 - are sort of arranged in a grid and you
01:36 - could go you know room by room
01:38 - whereby each room was the entire width
01:40 - and height of the screen uh looking for
01:43 - you know solving puzzles looking for
01:44 - items that sort of thing uh you can see
01:46 - there's a monster there you have hearts
01:48 - at the very top right so when you take
01:49 - damage hearts sort of decrement we'll
01:51 - see both of these the hearts and the the
01:54 - dungeon aspect of the game today in
01:56 - lecture
01:57 - as well as you know the the width and
01:59 - height of the room being a dungeon tile
02:01 - and controlling an avatar but this is
02:03 - sort of a representative screenshot of
02:04 - what the game looked like back in the
02:06 - day
02:07 - some topics today that we'll be
02:08 - discussing in order to implement sort of
02:10 - the foundation for what a a game engine
02:12 - like this might look like are things
02:13 - like top down perspective so as you can
02:15 - see in this screenshot we're looking at
02:18 - you know link from the very top and a
02:19 - bird's eye view as opposed to how we
02:21 - used to look at mario
02:23 - from the side where it was sort of like
02:25 - a side scroller
02:28 - here we're actually looking at things
02:29 - from the top down so we have a
02:32 - view of the room in sort of a different
02:34 - perspective there's sort of a there's
02:36 - not really a z-axis technically speaking
02:38 - but there sort of is you can implement
02:40 - things like gravity in a game engine
02:42 - like this by jumping over holes and
02:44 - things like that but there's no gravity
02:45 - like there was in super mario where you
02:47 - know you walk left to right you jump
02:48 - over gaps and it's very easy to see in
02:50 - that sort of sense we'll be talking
02:52 - about infinite dungeon generation
02:54 - so in the context of today's example
02:57 - we'll see how we can go about
02:58 - implementing a dungeon that sort of you
03:00 - can go through forever and ever and how
03:02 - to sort of model that and make it look
03:04 - as if you're traveling through a dungeon
03:06 - over and over again and going through
03:07 - different screens in different rooms
03:08 - that are all different but in reality
03:10 - we'll see it's actually just an illusion
03:12 - like we've
03:13 - seen before in prior lectures
03:15 - we'll talk about hitboxes and hurt boxes
03:17 - and what the difference is between the
03:18 - two hitboxes being uh rectangles on the
03:21 - screen that inflict damage upon other
03:23 - entities in your game world and hurt
03:24 - boxes sort of being the rectangle that
03:26 - models where your player or whether
03:29 - where an entity in the game can be hurt
03:31 - by other hitboxes we'll look at events
03:34 - so events are a way of sort of
03:36 - broadcasting some key or some message
03:39 - that tells the game world oh this thing
03:40 - happened and let me register a function
03:43 - to call when that sort of event is
03:45 - processed so on some event you know
03:48 - dispatch an event and then upon that
03:50 - event being received by whatever's
03:52 - listening for it perform this chunk of
03:54 - code it allows you to sort of decouple
03:55 - aspects of your game engine a little bit
03:57 - and makes for a little bit more readable
03:59 - code and allows you to do some
04:00 - interesting things with like
04:01 - achievements for example where you don't
04:02 - necessarily want to pull every single
04:04 - frame oh did i do this sort of arbitrary
04:07 - list of things this frame rather you can
04:09 - just process all of that within the
04:11 - event and have a listener and a function
04:13 - that you know every time you broadcast
04:15 - oh pick up coin maybe i have an
04:17 - achievement that's like oh uh
04:19 - have i picked up 50 coins in this level
04:22 - you know your
04:24 - achievement
04:25 - callback function in your event can can
04:27 - then look for that and in your game loop
04:29 - you don't have to say every frame oh if
04:31 - player has 850 coins and you sort of
04:34 - take out bloat that would exist in your
04:37 - sort of overall game loop that way and
04:38 - we'll see an example of how we use that
04:40 - in today's lecture we'll look at screen
04:42 - scrolling so a very common uh very uh
04:44 - sort of iconic aspect of legend of zelda
04:47 - is when you're going from one screen to
04:48 - another there's a sort of transition
04:50 - period as one screen loads and the other
04:53 - screen goes away
04:54 - in hardware in the nes uh this was sort
04:57 - of the only way um you could actually
05:00 - render a lot of um
05:02 - sort of more than a screen width of
05:04 - tiles you actually had to dynamically
05:05 - load in tiles and sort of overwrite
05:07 - tiles that existed before that in memory
05:09 - but today we'll see how we can sort of
05:11 - create the illusion of doing that by
05:13 - just drawing a room and then having our
05:16 - main room and then just sort of tweening
05:17 - over and then setting everything back to
05:19 - the origin at zero zero and it makes it
05:21 - look as if we're moving you know back
05:23 - and forth between all these rooms when
05:24 - in reality all we're doing is just doing
05:26 - a shift and then putting everything back
05:27 - to zero zero so i'll sort of illustrate
05:30 - that
05:30 - on the screen if i can
05:32 - and one of the last things we'll look at
05:33 - is data driven design in the context of
05:36 - a lot of types of games particularly
05:38 - rpgs and action games it's often very
05:40 - valuable to be able to model all of your
05:42 - items
05:44 - entities sort of abilities anything you
05:46 - really can as data rather than logic in
05:48 - order to make it easier for you to write
05:51 - one and two for you to sort of allocate
05:53 - the design aspect of your game to other
05:55 - people not just programmers and have an
05:58 - engine that's very versatile and
05:59 - moddable and we'll we'll take a look at
06:01 - how we implement sort of a foundation
06:03 - for that later on
06:05 - but first i'd like to illustrate a demo
06:07 - for today's lecture um a sort of
06:10 - implementation of legend of zelda is
06:12 - there anybody that would like to come up
06:13 - and sort of demo this today in class
06:18 - no
06:19 - awesome
06:21 - thank you so much
06:24 - so whenever you're ready just go ahead
06:25 - and press uh the return key there
06:30 - and so we see on the screen legend of 50
06:32 - which is our legend of zelda mock uh you
06:34 - know rip off sort of so if you press
06:36 - enter you go into this is the play state
06:38 - of the game so you control an avatar he
06:40 - can walk around he can interact with
06:42 - switches as we saw here when he presses
06:45 - a switch the doors open
06:46 - and once the doors are open
06:48 - you can walk through them
06:50 - and it does as i alluded to before it
06:52 - transitions the screen uh one entire
06:54 - screen with height or width depending on
06:56 - the direction up above and below we see
06:59 - here now we're pressing space spacebar
07:01 - to actually swing our sword it's
07:03 - destroying the entities in the game
07:04 - space so there's a hitbox triggering
07:08 - when you press the space bar that
07:09 - collides with other entities in the game
07:11 - world if that hitbox hits their hurt box
07:13 - then they are flagged as dead and they
07:15 - disappear from the game world
07:17 - and so this goes on ad infinitum is just
07:19 - an infinite dungeon so we he can go uh
07:22 - in between as many floors as we want to
07:24 - all we're doing is every time we go
07:25 - through a doorway spawn a new room
07:27 - delete the old one and just keep going
07:29 - forever and ever and ever
07:30 - in a game like legend of zelda typically
07:32 - doesn't work like this there's a hard
07:33 - set number of rooms and they all exist
07:36 - in sort of a 2d array and
07:39 - when you generate your dungeon you sort
07:40 - of have to take into consideration
07:41 - things like where do i put the keys
07:43 - where do i put the boss where i put
07:44 - treasure that sort of thing we won't get
07:46 - too in depth as to how we can
07:49 - implement a complex algorithm like that
07:51 - but we'll touch up on it a little bit
07:52 - and talk about maybe some ideas that we
07:54 - have
07:55 - and then lastly if we just if we want to
07:57 - demo
07:58 - as we can see at the top left we have
07:59 - hearts there which is uh iconic sort of
08:02 - zelda and when we do take damage from an
08:04 - enemy notice that we flicker a little
08:05 - bit so there's some rendering behavior
08:07 - triggering and we become invulnerable
08:08 - when we take damage and then lastly when
08:10 - we finally take the last hit we get a
08:12 - little game over screen using the zelda
08:13 - font and that's the game in a nutshell
08:15 - and we press enter and loop back so
08:16 - pretty simple all together but there's a
08:18 - lot of pieces here that we haven't
08:19 - really seen before so thank you very
08:21 - much for coming up to demo the
08:23 - game
08:24 - all right so
08:27 - that was a demo of
08:28 - you know legend of 50 legend of zelda it
08:31 - has a lot of the pieces that zelda has
08:33 - it's not as fully fleshed out of course
08:35 - as a full game like zelda which would be
08:36 - monstrously large um and there's a lot
08:38 - of things we need to factor in but
08:41 - the foundation is there we have the
08:42 - dungeon foundation upon which we can
08:44 - build a an actual generator if we wanted
08:46 - to we have entities we have hitboxes we
08:49 - could easily model because we have
08:50 - switches in the game we could model
08:52 - things like treasure chests that open
08:54 - that have different states just like the
08:55 - switch had different states and have
08:57 - different objects in our game space
08:59 - interact with other objects we have a
09:00 - lot here and we'll talk about all of it
09:03 - today so here's a few screenshots just
09:05 - to show you know what we just looked at
09:07 - our goal mainly is the second screenshot
09:10 - on the top right which is the play state
09:12 - that has all of the little pieces we
09:13 - just saw but just to tie it all together
09:15 - we do have a start state here and a game
09:17 - over state which is relevant in regard
09:19 - to the hearts in the top left
09:22 - so the first thing that i'll talk about
09:23 - um
09:24 - as we sort of get the engine built up is
09:28 - where do we go for getting our assets
09:30 - into the game and just like in
09:32 - prior lectures prior to today we just
09:34 - have a sprite sheet like we did with
09:35 - mario where everything is laid out in a
09:37 - fairly even sequence of
09:39 - tile segments in this case the segments
09:41 - are 16 by 16 pixels
09:43 - here i've overlaid a grid just to show
09:45 - that the picture is indeed perfectly
09:47 - 16x16 and this is something that you
09:49 - should take into consideration and
09:51 - consciously do when you're building your
09:53 - game assets make it easy to chop up into
09:55 - little pieces so you can then index into
09:57 - this sprite via some table of quads
10:01 - and then assign an id to whatever object
10:04 - or tile you want to render to the screen
10:07 - and so we see if you look here things
10:09 - like the doors they're not perfectly
10:11 - modeled by one tile
10:14 - and so when you do have things that are
10:16 - larger than 16x16 it's not quite as easy
10:19 - as oh you know have an entity or an
10:21 - object with this frame id and draw it to
10:24 - the screen you actually need to do a
10:25 - little bit more complicated render logic
10:27 - so uh just offhand if i wanted to draw a
10:29 - door does anybody have any suggestions
10:31 - as to how i would model that and or draw
10:33 - it to the screen
10:39 - so
10:40 - if we have a
10:42 - door that's not perfectly a
10:45 - 16 or a you know a 16 by 16 pixel tile
10:50 - offhand the you know what we need to do
10:52 - is just basically store all four of
10:54 - those tiles in this case or at least you
10:55 - know keep track of however many tiles
10:57 - your
10:58 - um
10:59 - object is and then just draw them based
11:02 - on some offset have the you know an x y
11:04 - that represents the top left of that
11:06 - object place it in the right position
11:08 - and instead of drawing just one tile we
11:09 - draw four tiles and then instead of
11:11 - having just one collision box that's 16
11:14 - by 16 tiles
11:15 - you can do a couple things you can
11:17 - either check collision on all four of
11:19 - these tiles or all at least all two of
11:21 - these door tiles or model your own
11:23 - custom hitbox that then maybe that
11:25 - object that represents a doorway has
11:27 - control of so you can say you know
11:29 - doorway collides player and then the
11:31 - doorway has a
11:32 - height and width of however many
11:35 - pixels it is
11:36 - wide by tall here just this door part
11:38 - and then you know you are able to then
11:40 - build upon not just having one tile that
11:44 - models a an object or entity in your
11:46 - game space but now you have more
11:47 - artistic flexibility you can do things
11:49 - like have doorways that are more than
11:51 - one pixel wide and sort of have a more
11:53 - convincing game world as a result of
11:54 - that
11:55 - and you'll see a lot of things like that
11:56 - in games like rpgs where you have full
11:58 - houses that are obviously not just one
12:01 - tile because that would be i mean some
12:02 - you can model things as one tile if you
12:05 - want to but uh from an artistic
12:07 - perspective and from just a game engine
12:09 - perspective it's a little bit easier to
12:12 - programmatically be able to cut up all
12:14 - your assets into tiles and draw them as
12:16 - such
12:18 - so being able to sort of build upon the
12:20 - just the single sprite and be able to do
12:23 - multiple sprites to represent an object
12:25 - is the key to things like houses things
12:28 - like big trees
12:30 - things that are just more complicated
12:31 - than single tiles as we see here
12:34 - the character sprite sheet is as you can
12:37 - see a little bit more complicated so
12:39 - this is an example of a sprite sheet
12:40 - that has padding
12:41 - sometimes you will get
12:43 - sprite sheets that aren't neatly divided
12:45 - into even segments and for a good reason
12:47 - because sometimes you have tiles that
12:49 - are not perfectly the width and height
12:51 - of whatever your game engine's tiles are
12:53 - in this case the player is actually 20
12:55 - pixels tall and 16 pixels wide and on
12:58 - top of that he's got different frames of
12:59 - animation we can see here at the bottom
13:00 - left he's got a sword swing animation
13:03 - the sword swing animation is actually
13:04 - stored in a 32 by 32 pixel frame because
13:07 - sometimes
13:08 - depending on which angle he's looking at
13:10 - his sprite can get a little larger or
13:11 - smaller so when you have a sprite with
13:14 - padding
13:15 - what's sort of a way that we can draw
13:16 - this to the screen
13:18 - reliably like how do we how do we take
13:20 - this into consideration
13:21 - how would we render a screen a sprite
13:23 - with padding
13:27 - so let's say this right here our
13:30 - character swinging a sword is in a 32 by
13:32 - 32 pixel box
13:34 - right this sort of box around here this
13:36 - white space
13:37 - but he's only still maybe 16 pixels wide
13:39 - by 20 pixels tall or maybe he's some
13:41 - amount similar to that
13:43 - in order to draw him to the screen which
13:45 - you can look at in the code all we
13:47 - really need to do is assign that sprite
13:48 - and offset just say okay this sprite's
13:51 - offset x and offset y are some value
13:54 - that basically lets us draw the sprite
13:57 - to a negative x and a negative y value
14:00 - and that'll shift the sprite up such
14:02 - that it aligns perfectly with wherever
14:04 - his x y are and we can you can take a
14:06 - look at that in the code to see exactly
14:07 - how that works
14:09 - lastly the actual entities for our game
14:11 - world are different creatures and this
14:13 - is a sprite sheet this is a more ideal
14:15 - sprite sheet where everything is 16 by
14:16 - 16 pixels wide and tall and all we
14:19 - really did here was just divide the
14:20 - sprite sheet using the regular
14:22 - utility function generate quads by 16
14:24 - 16.
14:26 - we don't have to worry about separate
14:28 - you know widths and heights for
14:29 - everything and we can create animations
14:31 - very simply because of this
14:33 - um as a side note something that i like
14:35 - to do when i'm you know parsing or when
14:38 - i'm piecing apart a sprite sheet that's
14:40 - got a lot of individual frames
14:42 - particularly from creating animations or
14:44 - i just need to know it for a tile
14:46 - a particular tile to draw to the screen
14:48 - it's kind of a pain to manually look
14:50 - through each and every tile one by one
14:52 - and say okay this is one but okay if i
14:54 - want to find out which one this the
14:56 - slime is i gotta count okay how many
14:58 - pixels wide is this okay and then it's
15:00 - times four so it's twelve and then it's
15:02 - on the fifth row so
15:04 - 12 times four plus one will get me okay
15:06 - so it's that's it's at index 49. so i've
15:09 - spent you know a non-trivial amount of
15:11 - time sort of hand calculating what all
15:13 - these do
15:14 - i wrote a simple python script that will
15:16 - just go over a file and just
15:20 - add a digit to each individual quad to
15:23 - just show you at a glance what each
15:25 - sprite is and this is included in the
15:27 - distro so you can see what it looks like
15:30 - saves a lot of time and i recommend
15:32 - trying when you're you know sort of
15:33 - working with assets and you find
15:35 - yourself doing something that takes a
15:36 - long time and sort of tedious and
15:38 - mechanical maybe try try to find a way
15:40 - to sort of automate that or at least
15:41 - make it easier to do things at a glance
15:43 - in this case just simply imposing a
15:45 - numerical grid solves that problem i
15:47 - don't have to spend a significant amount
15:48 - of time figuring out which
15:50 - frames of animation the ghost facing
15:52 - left is i know instantly it's 67 68 and
15:55 - 69
15:56 - and allows me to just crank things up
15:58 - that much faster
16:00 - so the first thing we'll take a look at
16:01 - is a sort of top-down perspective
16:04 - and we mostly talked about this before
16:07 - earlier but all it really is is a tile
16:09 - map which we've seen before
16:11 - uh the only difference is now instead of
16:14 - looking at things from the side we're
16:16 - just looking at things from up above so
16:18 - what's it what's a probably the most
16:20 - obvious consideration when
16:22 - designing a top-down perspective versus
16:24 - a
16:25 - sort of side-scrolling point of view
16:29 - paying it looking at particularly how
16:30 - the tiles are drawn
16:32 - what stands out
16:36 - so the thing that stands out to me is
16:38 - that we have things like shadows on
16:41 - walls here
16:42 - we have
16:43 - also corners
16:45 - and things altogether are skewed such
16:47 - that they are almost like rotated
16:49 - slightly as if they're simulating an
16:51 - angle of rotation relative to
16:54 - the uh camera facing from up above you
16:56 - can see this in like the player for
16:58 - example he sort of looks sort of looks
16:59 - like you're looking at him from kind of
17:00 - backwards and up when you're modeling
17:02 - your assets that way
17:04 - you this
17:06 - it's more convincing and zelda has
17:07 - always done this to make your assets
17:09 - look as if they are slightly tilted and
17:11 - that you're looking up above so when
17:13 - you're designing a top-down game just
17:14 - for convincing
17:16 - the sake of being more convincing try
17:18 - and emulate that the entities here like
17:21 - the skeleton
17:23 - and such are a little bit more straight
17:24 - on the bats
17:26 - and slimes and whatnot even though they
17:28 - still have a little bit of that
17:29 - appearance like the spider it sort of
17:30 - looks as if it's from the top back but
17:33 - modeling your assets from a top-down
17:35 - perspective really that's mainly mainly
17:37 - the thing pay attention to shadows and
17:38 - highlights which adds a lot in terms of
17:40 - convincing us that we're in this room
17:42 - with lighting and also
17:45 - make sure that
17:47 - you're doing things like corners and
17:48 - stuff and making it look as if things
17:50 - are slightly
17:51 - skewed rotation wise
17:54 - the first thing that we're going to look
17:56 - at in terms of the code in the distro is
17:58 - dungeon generation so uh in legend of
18:01 - zelda
18:02 - dungeons are
18:04 - fixed they're completely set in advance
18:07 - by the designers and in most games this
18:09 - is actually the case
18:10 - in our example and in a couple of other
18:12 - examples a primary example of them being
18:15 - that i can think of that i have in the
18:16 - slides a famous game called the binding
18:18 - of isaac dungeons can also be generated
18:22 - so
18:24 - in what what's the sort of like the main
18:25 - unit of a dungeon at least in the in the
18:27 - context of legend of zelda if you had to
18:29 - distill what comprises a dungeon what's
18:32 - like the most fundamental unit
18:37 - yes a room
18:39 - so
18:40 - we can almost look at this if we picture
18:42 - it in terms of a 2d array right we have
18:46 - assuming that this is like index 1 1 and
18:48 - lua 0 0 and other languages going left
18:50 - to right top to bottom
18:52 - basically we have on or off relative to
18:54 - each of these off on on off off off each
18:59 - of the indexes in this 2d array holds a
19:01 - room
19:03 - and so the room
19:05 - has connections implicitly between the
19:07 - other rooms if you wanted to go let's
19:09 - say from this room here to the room up
19:12 - above it
19:14 - what's the offset in terms of the 2d
19:16 - array how are we going from this room up
19:18 - to this room
19:23 - so we're just going up a y level right
19:25 - so this is x level three why level three
19:27 - if we wanted to go up to the next room
19:30 - we need to load in if we're doing it the
19:32 - zelda way right and we're just going
19:34 - we're we're doing a transition between
19:36 - one room to another
19:37 - what we need to do is load in the room
19:40 - at this room minus one on the y
19:44 - and then perform the transition and then
19:46 - set that to the current room such that
19:47 - now we know we're at
19:49 - y level two x level three that's our
19:51 - dungeon in the context of 2d
19:54 - uh dungeons and the legend of zelda
19:56 - that's as simple as it really is you
19:58 - have a 2d grid of dungeon rooms each
20:01 - room has its own collection of entities
20:03 - and objects and connections to other
20:04 - rooms
20:06 - but really all you all you do to sort of
20:09 - fill a dungeon is fill an array in a
20:11 - smart way such that there's no rooms
20:13 - that are for example left by themselves
20:15 - notice that every room in the dungeon
20:16 - has at least one connection to another
20:18 - room
20:20 - and that when you're maybe doing your
20:23 - algorithm to create a convincing dungeon
20:25 - let's say this room here has a
20:28 - door on the right that has a lock
20:31 - right
20:32 - we want to make sure that the key isn't
20:35 - in that room because if it is we're
20:37 - never going to be able to get to it
20:38 - assuming that we come from another
20:39 - direction so when you're designing
20:41 - dungeons procedurally
20:43 - you want to take these sort of things
20:45 - into consideration and then for example
20:46 - the boss room let's say this is the boss
20:48 - room the boss room should have a maybe a
20:50 - boss key or something like that
20:52 - but the boss key should not be obviously
20:56 - in that room it should be somewhere
20:58 - maybe where there's a a couple of rooms
21:01 - before it that have a lock or a key
21:03 - so that you know there's some sort of
21:05 - challenge involved in your dungeon it's
21:07 - not just
21:08 - random as as random as we've done before
21:11 - there has to be a little bit of sort of
21:12 - conscious design on behalf of your
21:15 - algorithms
21:16 - today we're doing things completely
21:17 - random um for illustration just because
21:20 - a system like this is fairly robust and
21:21 - complex but
21:23 - with some effort you could create a
21:25 - simple dungeon generator just using
21:26 - those mechanics just make sure that you
21:27 - have locked doors the lock doors can
21:29 - only open when you have a key make sure
21:31 - the key exists in a place that's
21:32 - accessible and sort of create a chain of
21:35 - like a sort of like a control flow model
21:38 - maybe via a graph of some kind that uh
21:41 - represents your dungeon and the
21:42 - progression thereof
21:45 - so that's that's
21:47 - what a zelda dungeon looks like that's
21:48 - what a 2d dungeon in this sort of
21:51 - perspective looks like and it looks it
21:53 - will look similar to this in other game
21:54 - engines it doesn't necessarily have to
21:56 - be perfectly modeled as a screen with
21:59 - screen height room going into another
22:01 - screen with screen right room you can
22:02 - have arbitrarily complex rooms that have
22:05 - arbitrarily complex sizes and shapes
22:10 - but you still need to make sure that the
22:11 - connections going out of the rooms like
22:14 - if you you could still model you know
22:16 - left right up down if you want to you
22:18 - could model arbitrary numbers of
22:19 - connections between rooms just make sure
22:21 - that you have puzzles that can be solved
22:24 - that's the main
22:25 - sort of obstacle in generating your
22:27 - dungeons
22:28 - here's a game that i really like that
22:30 - uses the old legend of zelda formula to
22:32 - very good effect now it's called the
22:34 - binding of isaac notice already we can
22:36 - instantly see that it's top-down
22:38 - perspective it's the entire width and
22:40 - height of the room is the dungeon of uh
22:42 - the entire width and height of the
22:43 - screen is the dungeon room
22:46 - uh you have a map up here that sort of
22:48 - shows you oh okay i'm in this room right
22:50 - here i can go up i can go left i can go
22:53 - right i can go down this room up here
22:55 - with the yellow crown that's going to be
22:56 - locked behind some door with a key so we
22:59 - need to have keys that spawn in any of
23:01 - these rooms that are just blindly
23:04 - accessible
23:05 - and isaac does things a little bit
23:06 - differently also in that it generates
23:08 - keys and bombs randomly so that you can
23:10 - actually get you don't necessarily have
23:12 - to plant your keys in very specific
23:14 - locations if your algorithm is
23:16 - sufficiently accommodating and complex
23:18 - enough you can just at the end of every
23:20 - room have a chance to spawn a key
23:22 - randomly and you know if you're lucky or
23:24 - if you're not lucky and assuming that
23:25 - the end of the dungeon doesn't exist
23:27 - behind your locked doors you can
23:29 - you have
23:31 - the opportunity to unlock those doors or
23:33 - not and just go on throughout your
23:34 - dungeon
23:35 - as needed in this case they don't lock
23:38 - the boss doors so you can go through the
23:40 - boss door regardless of whether you have
23:41 - a key so they've accommodated for this
23:43 - purely random approach
23:45 - and that just goes to illustrate how you
23:47 - can still take randomization
23:49 - using very complex principles and
23:51 - produce
23:52 - games that are extremely addicting and
23:55 - fun and
23:56 - don't necessarily need to be super
23:58 - elaborate
24:00 - the first thing okay so hitboxes and
24:02 - hurtbox will be the next topic so i want
24:04 - to touch on in the code how we sort of
24:06 - do dungeon generation in the game engine
24:09 - here so i'm going to open up
24:10 - there's a few files so doorway
24:13 - notice in
24:14 - in the source distro there's a world
24:16 - folder we've sort of categorized all of
24:18 - the files that have to do with world
24:20 - generation within that world folder
24:24 - we have a doorway file we have a dungeon
24:26 - file and we have a room file
24:29 - so the dungeon file models the dungeon
24:33 - it's just
24:33 - all of the rooms that form our dungeon
24:36 - just as a very high level top level data
24:39 - structure it's actually very simple
24:42 - the room is as we saw before the
24:44 - individual unit of the dungeon so a
24:46 - dungeon is effectively like a table of
24:49 - rooms and then it models interact mode
24:52 - it holds the code for how we can
24:53 - transition between them but that's sort
24:55 - of how we can think about it when you
24:56 - have a game level in general in this
24:59 - case dungeon is sort of our game level
25:01 - you can model the different subset
25:03 - aspects of your level via some data
25:05 - structure in this case we've decided to
25:07 - make it room but if you have just a
25:08 - platform or level maybe you have regions
25:10 - or zones or anything just little sub
25:12 - segments of your level that you can
25:14 - transition between
25:15 - it's useful to think in terms of that
25:18 - because from an efficiency and
25:19 - performance standpoint you want to
25:21 - dynamically probably load certain levels
25:23 - one at a time certain aspects certain
25:25 - components sub areas of your level one
25:28 - at a time rather than just the entire
25:30 - level at once because depending on how
25:32 - sufficiently complex and larger level is
25:34 - you could get to uh you know exercising
25:37 - your computer's memory constraints so
25:39 - don't want to do that so in this case
25:41 - our algorithm is we have a dungeon
25:43 - we have rooms we have one active room
25:46 - that's only visible at one time that's
25:48 - loaded in memory and then whenever we
25:49 - transition between rooms we want to have
25:51 - another room that gets temporarily
25:53 - loaded
25:54 - so let's look at the dungeon class here
25:57 - dungeon.lua
25:59 - so 14
26:01 - self.rooms empty table we're going to
26:03 - fill that with rooms just room objects
26:06 - self.current room
26:07 - room and then we're going to pass it in
26:09 - uh the player so that the player has
26:12 - access to all the entities and objects
26:14 - therein and can do things like collision
26:17 - detection
26:18 - which is very important and also
26:22 - so that the entities in the room can
26:25 - look at the player and then
26:28 - decide what they want to do with their
26:29 - ai which you can model arbitrarily
26:31 - complex
26:33 - um the whole init function
26:36 - of room.lua is gonna we're gonna show it
26:38 - here so in room.lua in that same world
26:40 - folder
26:42 - we've instantiated the dungeon at a high
26:44 - level we know the dungeons it's
26:46 - basically a table of rooms so what's a
26:48 - room look like
26:50 - well a room as we saw before what are
26:53 - the what are the pieces that a room
26:54 - needs in order to function what does the
26:56 - room have to to sort of keep control of
27:02 - so doors
27:06 - anything else
27:09 - so doors it has to keep track of right
27:11 - because when we touch a door we should
27:12 - transition to the next room it should
27:14 - keep track of
27:16 - the player so the player can update
27:18 - should keep track of objects in the in
27:20 - the room like switches as we saw in the
27:22 - example such that you know they can
27:24 - update those and see oh has the player
27:26 - stepped on the switch if he has
27:28 - open the doors
27:29 - and then entities right you should keep
27:32 - track of all of the creatures in the in
27:33 - the in the room so that they can update
27:35 - they can interact with each other the
27:37 - player can hit them or they can hit the
27:39 - player um and you can model whatever
27:42 - interactions you want to
27:44 - so we can see here oh and another thing
27:46 - too obviously probably the most one of
27:48 - the more important visual aspects of it
27:50 - we need to also have a set of tiles that
27:52 - model
27:53 - what the room looks like it's a
27:54 - container so we're going to draw
27:57 - you know we have a corner a corner a
27:59 - corner a corner
28:00 - walls on the sides walls on the top and
28:02 - bottom and then a floor and so that's we
28:04 - need to obviously draw the room before
28:06 - we draw all of the other things and
28:07 - update all the other things so
28:08 - tiles doorways entities
28:11 - and
28:12 - objects
28:14 - so
28:15 - we can see here we have tiles self.tiles
28:17 - gets an empty table we have a function
28:19 - called generate walls and floors
28:20 - entities empty table we have a function
28:22 - called generate entities
28:24 - and then objects equals empty table we
28:26 - have a function called generate objects
28:28 - and lastly doorways and then here it's
28:31 - uh because it's not necessarily as
28:33 - complex as we need for a
28:35 - an entire function we just have
28:37 - four doorways and this is static i've
28:40 - chosen in this example to have all the
28:42 - doorways always be in the same place
28:44 - and sort of behave in the same way but
28:46 - you could create a more complex system
28:48 - whereby
28:49 - you especially if you have an algorithm
28:51 - that generates a dungeon dynamically
28:54 - and maybe your rooms aren't necessarily
28:56 - hard set maybe maybe you have a room
28:58 - right if we go back to our
29:00 - slides earlier
29:02 - and let's say we're looking at this room
29:04 - right here in the very center we can see
29:05 - it has a dory on the left a doorway up
29:08 - top and a doorway to the right but
29:09 - there's no doorway on the bottom
29:13 - and that that looks like an arbitrary
29:14 - design decision on behalf of the
29:16 - designers but
29:19 - uh if we look at this room up top here
29:21 - we can see that it sort of behaves in
29:23 - the same way there's a doorway going to
29:25 - this room to the left there's a doorway
29:26 - going to this room down below
29:28 - but it doesn't have a doorway up top and
29:30 - a doorway on the right because there are
29:31 - no rooms going between that room and
29:34 - those directions so when you have a 2d
29:36 - array of
29:37 - dungeon rooms and you want to model your
29:39 - doorways
29:40 - it can be as simple as is there a room
29:44 - in that direction if there is
29:46 - and you'll have your data structure sort
29:48 - of laid out in advance before you
29:49 - generate these doorways if it does if it
29:51 - does not exist
29:53 - don't make a door if it does exist make
29:55 - a door
29:56 - and then make sure
29:58 - that when you transition between the
30:00 - left from let's say from the right to
30:02 - the left or from the bottom to the top
30:04 - that you go to the correct rooms at the
30:07 - correct indices in your 2d sort of room
30:11 - array does that make sense
30:13 - anybody have any questions so far as to
30:14 - like how this works at a high level
30:18 - okay
30:19 - awesome
30:20 - so these doorways here are all because
30:22 - this dungeon's completely random and
30:24 - every time it always has
30:26 - uh
30:27 - doorways going top bottom left and right
30:29 - we're always just going to put four
30:30 - doorways going top bottom left and right
30:32 - note that they take a string denoting
30:34 - which direction they are and this will
30:35 - become important later on in the doorway
30:38 - class which we see here is modeled as a
30:40 - separate class
30:42 - false here just means is the door open
30:44 - so by default we're going to close the
30:46 - door
30:48 - and then self so that we have access to
30:50 - the room
30:50 - from the doorway
30:53 - um
30:54 - the room should have a reference to the
30:56 - player so that it can model uh
30:58 - interactions between the entities and
31:00 - the player as well as the objects on the
31:01 - player
31:04 - that it has a render offset so
31:06 - if we look at the
31:08 - game here
31:09 - [Music]
31:11 - the
31:13 - tiles don't completely match up to the
31:16 - width and height of the screen and
31:18 - that's mainly a function of the virtual
31:20 - height not mapping perfectly to 16 tiles
31:24 - divided evenly by 16 tiles so what i've
31:26 - done is i've made the dungeon a little
31:28 - bit smaller
31:29 - and i've and also the fact that the um
31:33 - doorways take up a couple extra tiles of
31:35 - padding on their on their sides this
31:37 - like sort of blank space up here
31:39 - we've shifted everything inwards a
31:41 - little bit we've made that we've made
31:42 - the dungeon one tile smaller or two
31:44 - tiles smaller width and height wise than
31:46 - the screen and then we've just rendered
31:48 - offset by a certain amount such that
31:50 - it's completely centered we calculate
31:52 - how much padding exists between the
31:55 - fully rendered dungeon and whatever
31:57 - blank space is left and just shift by
31:59 - half of that amount and that's our
32:00 - render offset so that's why that's what
32:02 - why render offset is important in this
32:04 - case
32:05 - when you're trying to center anything
32:06 - you typically do it just by calculating
32:08 - an offset calculate the width and height
32:10 - of whatever you're trying to draw
32:11 - calculate whatever your width and height
32:13 - of your screen is minus that divided by
32:15 - two that's your render offset
32:17 - and then this is this these two fields
32:19 - here are interesting self dot adjacent
32:21 - offset x and self.adjacent offset y does
32:24 - anybody have a guess as to um sort of
32:27 - what this is used for
32:30 - yeah
32:33 - yes exactly so drawing itself when it's
32:36 - the adjacent room so when you load the
32:38 - next room
32:39 - you're going to instantiate a room just
32:40 - like this but by default it's going to
32:43 - draw at zero zero however if we want
32:45 - that room to draw
32:47 - you know not right where we are
32:49 - obviously if we're in the current room
32:50 - we don't want the next room drawing
32:51 - right on top of where we are because
32:52 - then it's just gonna layer right on top
32:55 - of the room we're in we want to draw it
32:56 - if we're going to the right we want to
32:58 - draw a screen width to the right if
32:59 - we're drawing it to the left we want to
33:00 - draw a screen width to the left and same
33:03 - thing on the y axis the screen height
33:05 - above or below it so adjacent offset x
33:07 - or y we just add to when we draw the
33:09 - room and that'll have the effect of
33:12 - rendering it separately from uh
33:15 - from the room that we're currently in i
33:17 - can try and have an illustration here so
33:19 - if we have our room here
33:22 - this is our current room so self
33:26 - dot current room
33:31 - and if we
33:33 - let's say we have a doorway here
33:35 - right that's a doorway object the player
33:37 - is here he collides with that object
33:40 - it's going to trigger a transition to a
33:42 - room up above so what we do is we load
33:44 - in a new room right away
33:46 - we always have a
33:49 - pointer called self dot next room
33:53 - and this is all kept track of in the
33:54 - dungeon.lua file
33:56 - but self.nextroom by default is going to
33:59 - be nil
34:01 - but when we
34:03 - transition from the current room to the
34:04 - next room right we should set that to
34:07 - something so
34:09 - self.current room
34:11 - is going to be the same but when we
34:13 - trigger this when we trigger this
34:15 - collision
34:16 - self.nextroom
34:19 - this is going to be equal to just a new
34:21 - room
34:23 - and then we get which doorway we're in
34:26 - we figure it out we figure out which
34:27 - direction we're moving in technically
34:29 - and then if we're moving up
34:31 - then we just pass in a
34:35 - we set it adjacent offset y in this case
34:38 - to negative screen height
34:41 - if it's below we set it to positive
34:44 - screen height if we set it if we go here
34:47 - it's going to be negative screen width
34:49 - the adjacent x will be negative screen
34:51 - width and then
34:53 - positive screen width on the x if we're
34:55 - moving to the right and so uh this sort
34:59 - of adjacent
35:00 - we could see the uh
35:02 - if we do like x y i think that'll be
35:05 - that's that's basically the adjacent
35:06 - offset and so
35:08 - um we end up when we draw
35:12 - our
35:13 - transition going from bottom to up in
35:15 - this case we just tween
35:17 - the camera to this value
35:20 - so we have a camera
35:23 - right this is our camera and it's going
35:25 - to be
35:25 - looking here
35:27 - by default so camera x and camera y
35:30 - those are values in our code as well
35:33 - when we trigger this
35:35 - collision on the doorway and we have
35:37 - current room here which is at zero zero
35:39 - and then we have this room here which is
35:41 - at
35:42 - zero minus or plus our adjacent offset y
35:46 - which is negative screen height so it
35:48 - has the effect of making it negative
35:50 - screen height on the y
35:53 - our camera x
35:55 - recall love.graphics.translate is our
35:57 - camera so all we do is we just tween
35:59 - that we say okay here's our our cam x is
36:02 - going to be here
36:04 - and chem y it's getting a little bit
36:06 - messy i apologize but our camera x and y
36:09 - are here
36:10 - and then over time we're going to
36:12 - tween that up into the next rooms
36:16 - x and y which is calculated it's just x
36:19 - plus adjacent offset x y plus adjacent
36:22 - offset y
36:23 - and then once once this camera has
36:26 - shifted from here
36:28 - up to here or whichever direction we're
36:29 - going whether it's up down left or right
36:32 - once we've completed that
36:35 - we can normalize everything again
36:37 - back to zero zero by doing uh self dot
36:41 - current room equals
36:43 - what's the what do we need to do if
36:45 - we're
36:46 - if we're gonna put everything back to
36:48 - and let's say let's say i want to make
36:49 - this this room the new current room what
36:51 - do i need to do
36:55 - so we have current room and we have next
36:57 - room
36:58 - if i want the current room to become the
37:00 - next room all i need to do is say self
37:03 - dot current room equals
37:05 - self
37:06 - dot next room right
37:12 - and then once that happens
37:14 - adjacent off what happens to the
37:15 - adjacent offset x and y of the next room
37:22 - they get set to zero right i want to
37:24 - take i want to take this room that we've
37:26 - offset up here and i just want to make
37:28 - it the center of the game world again i
37:29 - want to just put it at zero zero so we
37:31 - can do this exact same calculation
37:34 - by just setting adjacent offset x or y
37:37 - to a negative or positive screen height
37:39 - or screen width relative to zero zero
37:41 - so what i'm going to do is just set
37:44 - uh the adjacent offset of x and y of the
37:47 - next room which is now current room to
37:49 - zero and it's gonna draw it right back
37:51 - at zero zero and then camera x and
37:54 - camera y are also going to be set to
37:56 - zero zero and this is gonna have the
37:58 - effect of looking as if we're going up
38:00 - and staying there but in reality we're
38:02 - just going up and then instantly
38:04 - shifting everything back to zero zero
38:05 - including the player entities and
38:07 - switches of that room so it's purely an
38:10 - illusion but it allows us to simulate
38:12 - this sort of infinite exploring a
38:14 - dungeon effect does that make sense is
38:16 - the overall flow of how this works makes
38:18 - sense
38:20 - okay so it's a little bit messy there
38:21 - hopefully i was able to
38:23 - illustrate the
38:24 - overall algorithm for
38:26 - how the infinite dungeon generator works
38:30 - um where did we leave off on we were in
38:34 - oh yeah we were in the init function of
38:35 - the room
38:37 - so
38:38 - let's take a look at a few of the
38:40 - functions that comprise that so generate
38:42 - walls and floors
38:44 - this is very simple very similar to what
38:47 - we've looked at before with uh like tile
38:49 - maps in mario for example where we just
38:50 - go from y to x and then we just pick a
38:52 - random id or not random id well it is
38:55 - random id for some of it but sometimes
38:57 - we need an explicit id
38:58 - so uh remind me what does the id
39:02 - actually map to
39:04 - uh when we're you know drawing tiles to
39:06 - the screen if we want to give a tile an
39:08 - id what is that what should that map
39:11 - to yeah
39:14 - the frame in the sprite sheet that's
39:16 - correct
39:16 - um it doesn't have to for all game
39:19 - engines for all implementations but it's
39:20 - the easiest thing to do is just to give
39:22 - it your tile and id that you can then
39:25 - just draw you can index into your sprite
39:27 - sheet at that id
39:29 - it's just very very simple lightweight
39:31 - clean approach to modeling and we can
39:32 - see here id gets id
39:36 - after we've sort of figured out what id
39:38 - we want now how do we determine
39:41 - like let's say i want to draw
39:49 - let's say for example like this tile
39:51 - here
39:53 - notice it's a it's a corner tile
39:55 - how would i what do i need to do to
39:58 - basically assign i'm going to die before
39:59 - i even have the chance to uh to show you
40:02 - while i avoid enemies
40:04 - if i wanted to draw that top left corner
40:07 - uh what am i sort of looking for i still
40:09 - taking damage anyway
40:12 - relative to x and y what am i looking
40:14 - for
40:17 - what x and y does that
40:19 - does that tile need assuming everything
40:21 - starts 1 1 on the top left and goes down
40:24 - to height and width of the overall
40:26 - dungeon what does the xy need to be of
40:28 - that top left corner
40:33 - needs to be one right so if that's one
40:35 - one basically the top left corner that
40:38 - id should be equal to
40:40 - the corner sprite the top left corner
40:41 - sprite specifically what about the top
40:43 - right corner sprite
40:47 - what should the x be
40:50 - sorry yes width exactly what's the y
40:55 - still going to be one what about the
40:57 - bottom left
41:00 - width comma height and then the bottom
41:01 - right
41:08 - oh sorry bottom left should be one comma
41:10 - height bottom right should be
41:13 - width comma height
41:16 - and so
41:18 - basically checking the position of each
41:20 - tile is how we can infer its id which is
41:21 - what we're doing um
41:24 - in the source code here if x is one and
41:25 - y is one okay top left corner and notice
41:28 - that we've put these into constants that
41:30 - we've put into constants.lua just for
41:32 - readability so we can instantly see oh
41:34 - okay i should set id to tile top left
41:37 - corner not some arbitrary number that's
41:39 - our index into the tile sheet at like
41:41 - maybe like 40 something or whatever it
41:42 - is
41:43 - bottom left is one and height
41:46 - top right is width and one and then
41:50 - uh bottom right is width and height and
41:53 - we can sort it it's readable we can just
41:54 - sort of see at a glance what we're doing
41:56 - we're sort of conditionally generating
41:58 - all of our tiles
42:00 - um
42:02 - if
42:03 - none of those are true and then x is one
42:07 - what's
42:08 - what's that tile if x is one but it's
42:10 - not a corner
42:19 - it's a left-hand wall
42:20 - and the same thing if it's the width
42:23 - it's a right-hand wall and if y is one
42:25 - it's a top wall
42:27 - if y is height it's a bottom wall and
42:29 - then if it's none of those
42:33 - it's got to be a floor exactly
42:36 - so that's that's basically how we
42:37 - generate the overall it's very it's a
42:39 - very easy simple
42:41 - generation algorithm
42:43 - what i've done is
42:45 - for randomization here
42:48 - we have a actually a table of potential
42:51 - left walls potential right walls
42:52 - potential top and bottom and then we
42:54 - just describe it a random value within
42:57 - there
42:58 - based on however large that is and that
43:00 - gives us variable we can see it it's
43:02 - it's we have random
43:03 - whoops
43:05 - every time i generate it so take note of
43:07 - maybe some of the tiles visually that
43:09 - you can see there on the map
43:13 - notice that they changed notice that the
43:15 - switch is also changed
43:18 - notice that they changed again so
43:20 - everything is variable we have a little
43:21 - bit of visual variety this is what we
43:22 - did essentially with mario we changed
43:24 - the tile set and the topper set only now
43:26 - we're just changing we have only one
43:28 - tile sheet but several variations of the
43:30 - same tile they're in so all we need to
43:31 - do is pick a random variation of
43:33 - whatever tile and that involves us
43:35 - looking at the sprite sheet picking out
43:37 - which individual tiles
43:39 - which separate tiles
43:40 - map to
43:42 - the specific type of tile and then just
43:44 - picking a random value from that table
43:47 - that's how that works
43:49 - so
43:52 - a couple things i think left to show
43:54 - relative to the dungeon generation so
43:56 - um
43:59 - 48 we have generate entities so entities
44:02 - are
44:04 - here we have their names right
44:07 - of the entities we saw skeletons bats
44:10 - slimes ghosts spiders
44:12 - it's a very
44:14 - lightweight
44:15 - function like it's not too it's like 15
44:17 - or 20 lines but we're generating you
44:19 - know a bunch of different kinds of
44:20 - entities because what we've done we take
44:23 - we we basically take a random type from
44:26 - that table
44:27 - we create an entity
44:28 - and then using what we've defined in a
44:32 - global table called entitydefs
44:34 - we take out what sort of matters in
44:37 - terms of generating each individual
44:39 - entity the characteristics thereof and
44:41 - we just put it in simple data form this
44:43 - is sort of like the the segue into data
44:46 - driven design for your game
44:49 - if you look at entity defs here
44:52 - we can just see that all of our entities
44:54 - are a sequence of data so we have up
44:57 - here we have player right on line 10
44:59 - player gets a table we give them walk
45:01 - speed we have a table of animations so
45:04 - he's got a walk left animation a walk
45:06 - right animation a walk down animation
45:08 - all of those have their frames their
45:10 - interval their texture everything's just
45:12 - clean data right
45:14 - there's no logic here really it's just
45:17 - flags or values simple things you could
45:20 - give this you could give anybody
45:23 - who has sort of the basic knowledge of
45:24 - what we're doing this file and what
45:27 - maybe some textures and say hey i want
45:29 - you to design
45:30 - i want you to lay out basically all of
45:32 - that that's involved and what makes a
45:34 - skeleton sort of rendered to the screen
45:36 - like
45:37 - give them like create all the animations
45:39 - for them give them the give us the
45:41 - give those animations their timing give
45:43 - them the exact frames maybe maybe
45:45 - skeleton should have health and maybe
45:47 - health should be equal to 10 on a
45:48 - skeleton or something like that there's
45:50 - not really any like programming going on
45:53 - here but we're describing everything in
45:54 - our game as data and that's important
45:56 - thing in complex games that have you
46:00 - know fairly complex systems but that can
46:02 - be modeled via some attributes
46:04 - you can just describe your entities and
46:06 - data and then let your engine parse this
46:08 - information and then create your
46:09 - entities
46:11 - programmatically
46:12 - you allow you sort of shift the burden
46:14 - from the programmer to the designer a
46:16 - little bit and you afford your design
46:19 - team you and maybe other people who
46:21 - aren't as comfortable with programming
46:23 - the ability to modify the game engine
46:25 - add things to the game
46:27 - without having to go through the bulk of
46:28 - your engine code and do anything too
46:30 - fancy in this case it's simple all we're
46:32 - doing is just we're creating animations
46:34 - and uh assigning a texture
46:37 - to each of these individual things but
46:39 - i alluded to this last week you could
46:41 - have a file that maybe describes
46:43 - something like a goblin we'll see this
46:44 - at the end of the lecture which has
46:46 - maybe like a flag for is it flammable
46:48 - how much health does it have what are
46:49 - its animations
46:51 - um what skills does it have uh what's
46:53 - its attack strength what's a defense
46:55 - where where does it spawn typically
46:57 - um by putting all these attributes
46:59 - together and having your engine sort of
47:01 - parse this you can create depending on
47:02 - how how many fields you have you can
47:05 - create a very complex
47:07 - uh
47:09 - like potential list of things in your
47:12 - game whether they're entities whether
47:13 - they're weapons whether they're items
47:15 - abilities anything you want to whether
47:17 - they're
47:18 - levels even
47:20 - based solely on just data
47:22 - so this is a holy grail of
47:25 - design and development when you get into
47:27 - especially very complex games like rpgs
47:30 - where you can have
47:32 - skills that are you know have particle
47:34 - effects and do different damage to
47:35 - different things and you have entities
47:37 - that are maybe you want them some to set
47:38 - on fire some to be electrocuted maybe
47:40 - some you don't maybe some uh
47:43 - melt when they touch something
47:45 - create a bunch of flags create a
47:47 - function that parses this and generates
47:49 - entities as a result
47:50 - and you just allow yourself an
47:53 - incredible boost in productivity no
47:55 - longer do you need to create a spider
47:57 - class
47:58 - a ghost class
48:00 - a bat class it's all unnecessary all you
48:04 - need to do is define what sort of
48:06 - attributes does a bat have what
48:08 - attributes does a ghost have what
48:09 - attributes does a skeleton have
48:11 - and
48:12 - anybody can therefore mod your game as a
48:15 - result of this all they need to do is
48:17 - know what attributes a potential entity
48:19 - can have and your design team is all the
48:22 - more productive as a result
48:24 - so that's a sort of spiel on why this is
48:27 - relevant we've implemented a very basic
48:29 - version of this just for the sake of
48:31 - modeling animations but we don't need a
48:34 - separate class for all the different
48:35 - entities in our game world we just need
48:38 - basically and in the context of this
48:40 - game what are their animations
48:43 - so that's entity deaths that's how it's
48:45 - working if we're looking at um
48:48 - room.lua at line 48
48:51 - all it's doing is
48:52 - getting animations this is by the way
48:54 - your function that takes in these
48:56 - definitions and creates your entities
48:58 - they should be looking for
49:00 - looking into that they pull that
49:02 - definition and then just parse out each
49:04 - individual uh relevant piece of data and
49:07 - then just construct some relevant
49:09 - information or attach a relevant flag to
49:11 - that entity that your game engine can
49:13 - then later parse
49:15 - the flammable example if you do an
49:17 - attack and that attack is of type fire
49:19 - and it collides with an entity and that
49:22 - entity dot flammable is true that should
49:24 - trigger some behavior but you don't need
49:26 - to do anything terribly complex and you
49:28 - can assign this to any rel any arbitrary
49:30 - entity thereafter
49:33 - so just a simple way of getting very
49:35 - complex behavior for your game objects
49:38 - entities whatever you want
49:40 - modeling them as data rather than
49:42 - thinking about it in terms of classes
49:44 - so
49:45 - that's that
49:46 - does anybody have any questions as to
49:48 - like sort of how that works or how it's
49:50 - why it's viable or why it's useful
49:55 - okay
49:56 - a couple last things we'll look at
49:58 - really fast in room so on line
50:00 - 82
50:02 - generate objects
50:04 - so we did this very very
50:06 - similarly last week where we just had a
50:08 - game object class
50:09 - notice that it takes itself a definition
50:12 - for a switch
50:13 - that definition is in gameobjects.lua
50:17 - switch
50:18 - here's a little bit more sort of data
50:19 - modeling something like a switch it's
50:22 - got its type is switch
50:24 - frame is two by default it's got a width
50:26 - and height of 16. it's not solid player
50:28 - can walk over it its default state is
50:31 - unpressed so when it gets spawned into
50:32 - the game it's unpressed and it's got two
50:35 - potential states unpressed and pressed
50:37 - and each of those states have a frame so
50:40 - all we need to do to render it is say
50:41 - what's its current state render the
50:43 - state dot frame
50:45 - and then now we don't need to do
50:46 - anything that's basically all we need to
50:48 - do in order to render it at the right
50:49 - point your game engine therefore needs
50:52 - to look at your object and look at its
50:54 - state and look at its potential states
50:58 - index into that state and then look at
51:00 - and then pull the frame from that
51:02 - but it affords you sort of infinite
51:04 - flexibility you can now have like
51:06 - uh i don't know glo maybe you have a
51:08 - glowing state and maybe there's a frame
51:09 - in that sprite sheet that
51:11 - allows it to glow and you could just
51:13 - change it to glowing whenever you want
51:14 - and it'll just render appropriately so
51:18 - very flexible approach to modeling data
51:22 - 149 in room so we're almost done with
51:24 - the dungeon here so 149
51:28 - is
51:29 - our update function all it does
51:31 - basically is
51:32 - iterate through everything and update it
51:34 - including i uh
51:36 - basically
51:37 - all the entities so for every entity
51:41 - sort of if it's less than if it's health
51:42 - is less than or equal to zero it's dead
51:45 - if it's dead
51:46 - then don't render it which we see down
51:49 - in render but
51:51 - if it's not dead
51:53 - and
51:54 - self.player collides with it
51:57 - and the player is not invulnerable
52:00 - then we should damage the player go
52:02 - invulnerable and if the player's health
52:04 - is zero change to game over so notice
52:06 - how readable this is
52:08 - when you model your entities
52:10 - like this as well all you really need to
52:12 - do is just check for certain flags or
52:14 - functions and you can do arbitrarily
52:16 - complex tests like this because entities
52:18 - can be dead or not because entities can
52:21 - be invulnerable or not
52:23 - and then because entities are all xy
52:26 - with height based things in our game and
52:28 - collides just expects them to have that
52:32 - all we just do is play a sound
52:34 - damage the player all damage what what
52:36 - does damage do
52:37 - offhand what do we think it does
52:41 - exactly just take a wild guess and say
52:43 - it subtracts from health it does so self
52:45 - uh entity damage just
52:47 - takes in a number and subtracts that
52:48 - from health that's all it does go
52:50 - invulnerable what does that do
52:53 - prevents you from taking damage for that
52:55 - many seconds it does it takes you it
52:57 - prevents you from taking damage for that
52:58 - many seconds all but all that really
53:00 - does is just set a flag which i've
53:03 - alluded to quite a bit already
53:06 - an arbitrary flag that you can model via
53:08 - data or some other means every entity
53:10 - has an invulnerable flag and if it's
53:12 - invulnerable then the engine should look
53:14 - for that and change the rendering and
53:16 - the mechanics of that entity accordingly
53:19 - and then lastly here just simple if the
53:21 - player health is equal to zero which it
53:23 - might be after we take sufficient damage
53:25 - change to game over
53:26 - that's all it does and then for every
53:29 - object just as we do with every entity
53:32 - update the object and if the player
53:33 - collides with it then trigger its on
53:36 - collide function and this can be a
53:38 - function that you arbitrarily create
53:40 - depending on the needs of your object
53:44 - if we look up here for example every
53:47 - time we create a room we generate
53:48 - objects in the room
53:51 - we insert into objects a switch which we
53:53 - saw before in gameobjects.lua
53:56 - and takes an x and a y in this case we
53:58 - just make sure that the x and y is a
53:59 - random number between the top left of
54:01 - the map and the bottom right of the map
54:03 - within the padding that it has
54:06 - we get a reference to that object and
54:09 - then we define our on collide function
54:11 - so what we do is we say if it's
54:13 - unpressed so recall that we have a state
54:16 - in the game object definition if it's
54:19 - unpressed
54:20 - change it to pressed that's all we
54:22 - really need to do
54:23 - and then notice here for k doorway so
54:26 - for every doorway in doorways
54:27 - self.doorways
54:29 - set that doorway
54:31 - open is true
54:33 - and then play a door sound
54:34 - so our on collide function just
54:37 - interacts with other things in the game
54:39 - world and just very simple things but
54:41 - has a a pretty
54:42 - you know
54:44 - interesting sort of mechanic like we
54:46 - have a i took damage off the bat there
54:47 - because my spawning isn't perfect but
54:51 - it changed from notice that it changed
54:53 - its state from unpressed to pressed
54:56 - because it went from the one sprite to
54:58 - i'll go into another room so we can see
54:59 - that i'll take some damage on the way go
55:01 - to another room notice the sprite
55:02 - it sort of looks like it's unpressed
55:05 - right because the game object's default
55:07 - state is unpressed and then on collide
55:09 - triggers
55:10 - when i go on top of it
55:12 - it changes state which has an effect on
55:15 - what gets rendered and it's on collide
55:17 - function just called which opened up
55:19 - every doorway in the room
55:21 - so simple
55:22 - like 15 lines of code
55:25 - but
55:25 - pretty compelling interesting behavior
55:27 - for the sake of our dungeon like it's it
55:29 - adds a lot as simple as that is now we
55:31 - sort of feel like we're interacting with
55:33 - our game world a little bit
55:35 - so that's that's how that um
55:37 - sort of works
55:38 - and then
55:39 - lastly
55:41 - rendering on line 188 just go through
55:43 - all of our tiles render all the tiles
55:45 - we've seen this before
55:47 - render all the doorways render all the
55:48 - objects render all the entities
55:51 - if they're not dead
55:52 - right if they're dead then don't render
55:53 - them
55:55 - and then this bit here we'll take we'll
55:57 - take a look at at the end which is
55:58 - stenciling so
56:01 - notice that when i walk through doors
56:03 - well first of all notice that i can't
56:05 - walk through doors if they're closed
56:06 - which is important so when you collide
56:08 - with your doorway objects
56:10 - if doorway.open is false
56:13 - shouldn't trigger the broom switch right
56:15 - but if i
56:17 - open the doors they're now all set to
56:18 - recall door.open is now equal to true so
56:21 - they've changed their rendering so now
56:22 - they're they're rendering open doorways
56:25 - if i walk through it notice that it
56:26 - looks as if the player walks underneath
56:28 - the tiles
56:29 - but i'm drawing the tiles before the
56:32 - player
56:33 - and
56:35 - one approach that you might think to do
56:38 - when
56:39 - sort of
56:41 - creating this believable appearance of
56:43 - walking through a doorway is say okay
56:45 - i'll just render the player
56:48 - after i render the doorway or before i
56:50 - render the doorways right so render all
56:52 - the doorways last
56:53 - but it doesn't quite work out because
56:55 - the sprite actually starts
56:57 - right
56:58 - here
57:00 - so what what does somebody think is
57:01 - gonna happen if i were to draw the
57:03 - doorway
57:04 - uh
57:05 - after the
57:06 - player would
57:10 - disappear exactly the player would
57:13 - disappear as soon as he gets to this
57:14 - little bit of line right here which is
57:16 - not very convincing and actually i'll uh
57:18 - try right now to
57:20 - take away the stenciling so we can see
57:21 - what that looks like
57:22 - so if i just take away the stenciling
57:24 - here
57:28 - and then i just render
57:32 - whoops
57:33 - i can't type today
57:35 - so i'm going to go ahead
57:38 - do that
57:42 - well first of all the rendering order is
57:44 - such that now
57:46 - the doorways render after the player or
57:48 - before the player so he just walks right
57:49 - over them right so i'm just walking i'm
57:52 - just walking over the walls that's not
57:53 - compelling and if i were to do something
57:56 - as simple as
57:57 - change the rendering order so right now
57:59 - the doorways render first i'll just
58:01 - render the doorways after the player
58:03 - so
58:05 - right
58:06 - here took that out right no
58:10 - so right now they render before the
58:12 - player i want to render them after the
58:13 - player and i'm going to
58:15 - just run it
58:18 - and then going to step on the switch
58:20 - and then
58:22 - yep notice we get some weird behavior
58:24 - too
58:25 - um
58:27 - like sees heads
58:29 - getting cut off
58:31 - like that's and the other entities as
58:33 - well
58:34 - right
58:36 - in that case uh i couldn't really tell
58:39 - but
58:41 - yeah very weird rendering behavior and
58:43 - what we do to fix that is we create
58:45 - what's called a stencil
58:47 - so basically uh try and get a screenshot
58:50 - here i can i can show first let me fix
58:52 - the changes that i just made
58:55 - right
58:57 - and then if i go back into the
58:58 - code here
59:01 - so a stencil is just and we'll see a
59:03 - slide on this in a little bit but a
59:04 - stencil is just a
59:06 - basically any sort of arbitrary shape
59:08 - that you want that you draw onto the
59:11 - screen it's invisible
59:14 - but it determines whatever
59:17 - whatever gets drawn on top of that
59:18 - stencil it determines whether or not
59:20 - that thing gets rendered so i have a
59:22 - stencil going basically from here
59:26 - onwards to the next room so
59:28 - right about where the doorway hits the
59:30 - archway because that's where we want the
59:31 - player's head to look like it disappears
59:33 - stencil going here i have a stencil
59:35 - going right here
59:37 - and right here and on the right side as
59:39 - well and what that does is i've set the
59:41 - stencil to say whatever passes through
59:44 - this stencil during the sort of stencil
59:47 - testing period which is well all we do
59:49 - is we just draw the player during that
59:51 - time but basically if it's on the
59:54 - stencil don't render it and so what that
59:56 - has the effect of is we draw the we
59:57 - still draw the doorways before the
59:59 - player so the player walks in and he's
60:01 - drawn above this part but as soon as
60:03 - this as he hits the stencil he's not
60:05 - drawn it's just all those basically what
60:07 - it does is it draws the character to the
60:10 - stencil and not uh to the to the actual
60:13 - canvas
60:15 - and so we get convincing the sort of if
60:16 - you want sort of convincing layered
60:18 - weird visual effects like that
60:20 - stenciling is a is an approach
60:23 - okay and then that's all this is so this
60:25 - stencil function
60:26 - love.graphics.stencil takes in a
60:28 - function this is what's going to run
60:30 - during the actual stenciling process
60:32 - it's going to draw i draw four
60:33 - rectangles all those rectangles are just
60:36 - the
60:36 - um
60:37 - those arch ways right perfectly layered
60:40 - over them such that it goes into the
60:41 - next room
60:43 - and then
60:46 - we do
60:47 - notice that it says replace and then one
60:49 - so we replace any pixel that gets drawn
60:52 - to that stencil with the stencil value
60:54 - of one and then we only draw
60:58 - things that are less than one during the
61:00 - stencil test which means anything that
61:01 - didn't get ascribed to value of one
61:03 - which means that if the player went over
61:04 - the stencil got a pixel value of one
61:07 - that's going to be false he's not going
61:08 - to be drawn to the screen yeah
61:21 - question was if you have a
61:25 - stencil because you can do it with an
61:26 - arbitrary shape you could create
61:28 - lighting systems
61:29 - where some areas are dark and some areas
61:31 - are light i want to say
61:33 - possibly the thing is i'm not 100 sure
61:35 - whether stenciling allows you to do like
61:38 - whether love2ds stenciling allows you to
61:41 - do
61:42 - like arbitrary numbers of stuff like
61:44 - what i basically am not sure if it's on
61:46 - or off or a gradient typically if i were
61:49 - to do a lighting system like that
61:50 - i would probably draw
61:52 - like a faux lighting system one you can
61:55 - use a lighting kit like box 2d lights
61:58 - which a lot which does really compelling
62:00 - cool lights for you or sort of a cruder
62:02 - way to do it but possibly realistic
62:05 - would be to draw a shape that fits
62:07 - whatever you want to be your darkness
62:10 - um
62:11 - and then render it at an opacity that's
62:14 - less than 100
62:16 - so like uh so you'd have like let's see
62:18 - have a room and let's say maybe like two
62:19 - like the sides of it are like kind of
62:20 - shadowy you draw like black rectangles
62:23 - there right
62:24 - but instead of drawing those black
62:25 - rectangles at 255 alpha you draw them at
62:28 - like
62:29 - 200 or 150 or something like that and so
62:32 - you can still see what's underneath them
62:33 - but it looks as if they are
62:36 - uh
62:37 - you know sort of a shadow and you can
62:38 - use gradient effects do the same thing
62:39 - if you want to like have a shadow that's
62:42 - darker going lighter um i believe you
62:44 - can draw rectangles with a gradient
62:46 - effect in left 2d i'd have to look into
62:48 - a little bit more but you would you
62:49 - would look to do something like that
62:50 - draw a gradient of shadow
62:53 - via some rectangle or some arbitrary
62:54 - shape to simulate lighting in that case
62:56 - and you could accomplish something
62:58 - similar to that and there are a lot of
62:59 - other crazy cool ways i've seen lighting
63:01 - done in 2d but that's probably offhand
63:03 - the simplest way that i could think of
63:04 - doing it
63:06 - cool
63:08 - um
63:09 - so that's stenciling and that's
63:10 - basically that's basically it for the
63:12 - dungeon generation
63:14 - which is arguably the most important
63:16 - part and also we we looked earlier at
63:18 - the sort of transition mechanic and
63:19 - we'll look at the transition mechanic a
63:21 - little bit more um
63:23 - in a little bit but let's take a five
63:24 - minute for right now and then uh come
63:26 - back to that and
63:28 - see some more stuff
63:29 - all right welcome back to lecture five
63:32 - legend of zelda so before the break we
63:33 - talked about a bunch of different things
63:35 - uh dungeon generation being foremost
63:37 - among them now we'll actually start
63:39 - talking about
63:40 - things like hitboxes and hurt boxes as
63:42 - we can see here on the screen so a
63:44 - hitbox is a rectangle basically that's
63:47 - how we've implemented it in the distro
63:50 - but we can see here there's a few
63:52 - different sort of rectangles overlapping
63:53 - we have the green rectangles here these
63:55 - are hurt boxes these are where you can
63:57 - get hurt and then this is a hitbox this
63:59 - is where you can hit something and so
64:02 - games like especially with fighting
64:03 - games and a lot of games of you know
64:05 - fairly complex interactions and complex
64:07 - entities that have weapons or particles
64:09 - things like that that all do damage
64:11 - you'll see a lot of sort of complicated
64:14 - overlapping and adjust or arrangement of
64:16 - these rectangles that sort of bring
64:18 - about how things interact with each
64:19 - other in terms of collision and
64:22 - doing damage and affecting other
64:23 - entities in this case he's doing like a
64:25 - an attack that goes uh from the left to
64:28 - the right it's a low attack only his
64:30 - foot essentially a little bit inwards
64:33 - but essentially his foot does damage
64:34 - whereas the rest of him is vulnerable
64:36 - like if someone were to come up to him
64:37 - from up above and attack him
64:39 - it would uh it would do some damage and
64:41 - there's minecraft and it shows you how
64:43 - the same sort of
64:44 - principle applies to
64:47 - 3d games as well in this case the what
64:49 - you see there are all
64:52 - hurt boxes those are all where things
64:53 - can get hurt even though those are a few
64:56 - of those things are items so that only
64:58 - really affects whether or not the player
64:59 - collides with them and picks them up
65:01 - but that's
65:03 - basically the difference between
65:04 - hitboxes and hurt boxes
65:07 - the distro i think i accidentally called
65:09 - the file hurtbox so when i push it up
65:11 - it's going to be renamed to hitbox
65:13 - because that's what we use it for but
65:15 - the uh what is offhand in the in this
65:18 - game
65:19 - what do we need a hitbox for yeah
65:24 - melee attacks from the sword and the
65:25 - reason that we need a hitbox for that is
65:27 - why
65:30 - yes and why can't we just use the
65:32 - player's
65:33 - position x y width and height because it
65:36 - has direction as well has a direction as
65:38 - well and also it needs that's that's
65:40 - essentially it's hurt box right so
65:42 - that's for those two reasons it has a
65:44 - direction that we need to
65:46 - uh sort of act as its
65:49 - reference point for generating a hitbox
65:51 - to inflict damage on other entities
65:53 - and we need to use the player's main
65:55 - hitbox that hurt box that already has to
65:57 - see if something hit it the player maybe
66:00 - from another side or something like that
66:03 - so let's go ahead and take a look here
66:05 - the main bit of code that deals with the
66:07 - hitbox in this case is one gonna be hurt
66:10 - box should be hitbox but we can see this
66:12 - is literally just a rectangle class x y
66:15 - width and a height self.x self.y
66:17 - self.with self.height equals all of
66:19 - those things that's all you need for for
66:21 - a pit box literally box just all you
66:24 - need are those uh fields and then you
66:26 - can do simply collides
66:28 - just like you do entity entity collides
66:30 - hurt box yes no true or false because
66:33 - recall collides expects x y
66:37 - width or height and it's defined in
66:38 - entity.lua
66:41 - so if we go up to the
66:44 - player states so recall last week we
66:46 - introduced the the idea of having the
66:48 - player maintain its own collection of
66:50 - states in a state machine as opposed to
66:53 - just the game world having a state
66:54 - machine that you know influences whether
66:56 - we're at the start screen the place
66:58 - playstate screen whatever
67:00 - we want to
67:01 - divide our game up into
67:03 - we have
67:04 - entity states as well now one of those
67:07 - is the so we have the idle and the walk
67:09 - state those are
67:10 - very similar to last week's where the
67:13 - with an idle state they're just standing
67:14 - still and walking state they're moving
67:16 - and then their animation changes
67:17 - accordingly
67:18 - the swing sword state is a new state and
67:21 - what this does
67:23 - is the player presses space bar it
67:26 - triggers this swing sword state
67:28 - there's a new animation so we go into
67:30 - the swing sword animation relative to
67:32 - which direction we're in
67:34 - and
67:35 - we get that direction and then we
67:37 - calculate
67:38 - the x y width and height of whatever our
67:41 - hurt box it should be hitbox is going to
67:44 - be
67:44 - for the sword when the sword hits
67:46 - something so that hitbox
67:49 - if it's
67:50 - facing to the left it's going to be 8
67:52 - pixels wide by 16 tall which is roughly
67:54 - the left side of the player and then we
67:57 - just calculate the x and y depending on
67:59 - which position we're in it should be
68:01 - roughly centered based on whatever
68:03 - position the player's direction the
68:05 - player is looking at
68:06 - and so that we then instantiate that
68:09 - hurt box here we call it a self.sword
68:11 - hurt box
68:13 - and then all we really need to do is
68:15 - what
68:16 - in our game loop to check to see if
68:18 - we've hit an entity
68:26 - we just need to loop over
68:29 - the entities in our room the current
68:31 - room right here so every entity in the
68:34 - dungeon's current room
68:35 - dot entities
68:37 - if the entity collides with our sword
68:38 - hurt box sword hitbox then
68:41 - we saw this method before entity damage
68:44 - 1
68:45 - and then hit enemy play that's as simple
68:47 - as it is and recall in room da lua if an
68:50 - entity's health dropped below one drop
68:53 - to zero
68:54 - it would just trigger
68:55 - it to become dead right
68:57 - and so that's all we need effectively
69:00 - and then um we have some additional
69:02 - logic to make sure that the animation
69:03 - only plays one time and then once it has
69:06 - played one time change its state to idle
69:09 - um and then we can press spacebar
69:11 - repeatedly within that same state just
69:13 - to keep swinging if we want to and it'll
69:15 - just restart the animation and restart
69:18 - the hitbox being instantiated and so
69:20 - that's all we really need to do for that
69:23 - now i have some lines of code here at
69:25 - the bottom of the swordswingstate.lua
69:27 - and playerswords swingswordstate and
69:30 - what these do is sometimes it's useful
69:32 - when you're programming to sort of see
69:34 - where your collision boxes are right
69:36 - because you don't necessarily know if
69:37 - everything's lined up perfectly you know
69:39 - when you're detecting collision between
69:40 - different entities you want to just
69:42 - check to see are the rectangles actually
69:44 - overlapping when this triggers
69:46 - so
69:47 - all you need to do in order to visually
69:49 - see this at a glance and you may have
69:50 - seen this before in other games or debug
69:53 - modes of games is just draw line
69:56 - rectangles
69:57 - and then just give them the xy width and
69:58 - height that you want to look at right
70:00 - so here i'm going to go ahead and save
70:02 - this
70:03 - um
70:04 - and then i'm going to run the
70:06 - i've basically uncommented it because by
70:09 - default i don't want it showing i don't
70:10 - want the they're pink rectangles i don't
70:12 - want them displayed on the screen unless
70:13 - i want to do debugging so
70:15 - i'm going to uncomment them down here
70:17 - notice it says the color to 2550-255
70:20 - that's magenta
70:22 - i'm going to run this
70:25 - turn it down a little bit nothing looks
70:27 - particularly different but when i swing
70:29 - my sword
70:30 - notice that there's a little rectangle
70:34 - and the rectangles aren't 100 perfect
70:36 - necessarily there they give the player a
70:37 - little bit of an advantage notice that
70:39 - like up above like his
70:41 - hitbox is barely anything up above in
70:44 - the in the actual animation but in the
70:46 - in the collision i give it quite a wide
70:49 - a wide berth
70:52 - and so that's how you can at a glance
70:53 - sort of see whether your things are
70:55 - interact or interacting appropriately
70:57 - there's lines of code that do the same
70:58 - thing for the other states the entity
71:00 - walking and idle states if you want to
71:02 - sort of look at those and see not only
71:05 - the players swinging the sword but also
71:06 - the other entities and the collision
71:07 - boxes they have and just to check
71:09 - whether or not they're overlapping
71:11 - appropriately or to change them or do
71:12 - whatever you want with them but that's a
71:14 - nice way to sometimes it's hard to debug
71:16 - collision if you can't see exactly
71:17 - what's going on because it's often just
71:19 - in terms of xy width and height and so
71:21 - on and so forth with offsets and such it
71:23 - can be kind of a
71:24 - pain and or
71:26 - sort of difficult to track down certain
71:27 - bugs that way so just draw it to the
71:29 - screen
71:31 - you can apply that same logic to a lot
71:32 - of things in your game world that you
71:34 - can vis that are maybe hidden but you
71:36 - want to see sort of visually just draw
71:38 - shapes or draw different things for them
71:40 - so you can see what's going on
71:42 - so that's how the hitbox and hertbox
71:45 - work for our player and you can easily
71:48 - just spawn more hitboxes for other
71:50 - entities if you want to if you wanted to
71:51 - give them
71:52 - states or maybe you want to create
71:54 - projectiles that are offensive maybe
71:57 - just create projectiles and then shoot
72:00 - projectiles in a specific direction but
72:03 - assign a hitbox to that projectile if
72:06 - you want to or just use the projectiles
72:08 - x y width and height and then you can
72:10 - calculate a collision that way just
72:12 - treat it like a game object or an entity
72:14 - it's up to you
72:15 - or a separate uh a separate class
72:17 - altogether
72:18 - but that's hitboxes and hurt boxes in a
72:20 - nutshell anybody have any questions as
72:21 - to how those sort of work
72:25 - okay cool
72:27 - so let's go on to the next topic so
72:29 - events
72:30 - so i spoke of this earlier events are
72:32 - just a nice way to sort of say when
72:35 - something happens
72:36 - do this block of code
72:38 - um and you can do this anywhere and you
72:40 - can decouple it sort of from like
72:43 - maybe two different objects interact
72:44 - with each other but you don't want them
72:46 - to sort of pass references back and
72:48 - forth between each other and to sort of
72:50 - bloat your code maybe you want the code
72:53 - for that check to happen not inside your
72:55 - main loop you want to sort of abstract
72:56 - it out to some sort of other function
72:58 - like instantiate events and then have
73:00 - your main rendering and update logic be
73:03 - sort of free of all this conditional
73:04 - stuff
73:05 - so you create an event you say on some
73:07 - event so maybe like on player walk
73:12 - and then you just update some maybe a
73:14 - label on the top right of the screen
73:15 - that gives the players x y and you just
73:17 - say that x y is equal to that player's x
73:20 - y i mean aside from the fact that you
73:21 - could just literally draw the players x
73:23 - y but it's the same principle you can
73:25 - update some value somewhere
73:28 - separate from another entity
73:30 - and then just wait for an event
73:32 - arbitrarily defined event um that you
73:34 - then broadcast later so let's say i want
73:37 - to broadcast swing sword i have a swing
73:40 - sword event so whenever the player
73:41 - presses space not only do they do all
73:43 - the code that we saw before but they
73:44 - swing sword and then we say when you
73:47 - swing sword pass in the x y of wherever
73:49 - they swung the sword and so then you can
73:51 - say okay on swing sword look at all the
73:54 - entities and see whether or not the
73:56 - hitbox that xy collides with them and
73:58 - you can sort of take out the logic from
74:00 - where you had it before and put it in
74:01 - some other centralized location if you
74:03 - want to
74:04 - more sort of uh representative i think
74:07 - of this model is the idea of an
74:08 - achievement system where instead of
74:10 - every frame and you can have you know
74:12 - games have like a ridiculous number of
74:14 - achievements some games have like a
74:15 - thousand achievements you don't want to
74:16 - put the test for every one of those 1000
74:19 - achievements necessarily inside of your
74:21 - like update logic right
74:22 - you can instead just broadcast an event
74:25 - for all of the different things that
74:27 - influence whether those achievements are
74:29 - met so whether player needs to get 100
74:31 - kills in a game or 100 coins whether
74:34 - they need to like jump off some ledge
74:36 - you just have events that model all
74:37 - these interactions event on pick up coin
74:40 - do this increment some time some counter
74:43 - that's stored somewhere else and event
74:46 - dot on kill creature right where kill
74:48 - creature triggers every time you
74:51 - literally a creature is set from
74:53 - dead
74:54 - dead
74:54 - as false to death is true
74:58 - maybe whenever the player jumps
75:00 - you
75:01 - do a on jump function and then you can
75:04 - test to see whether or not in that code
75:05 - you can test to see whether they jumped
75:07 - off that ledge and then if that happens
75:10 - you have your achievement system but you
75:11 - don't have all these if statements and
75:12 - all these tests happening inside your
75:16 - your sort of imperative game loop you
75:18 - can just sort of
75:19 - like pseudo asynchronously check for all
75:21 - of them um given a sufficiently detailed
75:24 - event system in your game and so the
75:27 - library that we'll use just to show this
75:29 - a little bit is in the knife library
75:32 - that we saw before with timer
75:35 - timer.ontimer.everytimer.tween in the
75:36 - knife library there's a sub module
75:38 - called event which allows you to
75:42 - call event dot on give it a name and a
75:44 - function so on
75:47 - player jump off player jump you know
75:49 - function if
75:51 - player.position is you know by some
75:54 - cliff or some area that's relevant
75:56 - then call this block of code
75:59 - increment you know or set the
76:00 - achievement to true
76:02 - event.dispatch dispatch an event when
76:05 - something happens so if player jumps so
76:08 - if you press the spacebar event dot
76:10 - dispatch
76:12 - jump and then just whatever values that
76:15 - your callback function needs like let's
76:17 - say you want to check to see whether
76:18 - it's on the cliff well if you want to
76:20 - check to see whether they've jumped off
76:21 - that specific cliff you're gonna need to
76:22 - check their xy position presumably so
76:26 - you can just pass in optional parameters
76:27 - via event.dispatch you can say okay
76:30 - dispatch the event that the player
76:31 - jumped and say that the player jumped at
76:33 - xy
76:34 - and so this function callback is going
76:36 - to have access to that xy it's going to
76:38 - say okay on jump i see i got
76:41 - i'm getting my callback called with
76:42 - player.x player.y and it happens to oh
76:45 - it's not at the cliff so nothing happens
76:47 - or it is the cliff so
76:50 - the achievement
76:51 - jump off cliff unlocked is true and this
76:54 - test now is not happening every single
76:56 - frame which otherwise would potentially
76:58 - and it's not blocking up your
77:00 - update logic for your player jumping
77:03 - right the player
77:04 - the jumping logic inside
77:07 - player the player jump state doesn't
77:09 - need to know doesn't need to ask whether
77:11 - or not we've jumped off a cliff
77:13 - that's something that we should just
77:14 - delegate to our achievement file or
77:17 - whatever you want and that's sort of the
77:18 - flexibility that events afford you so
77:21 - we use event i'll touch on this a little
77:23 - bit briefly here but
77:26 - basically
77:27 - if we go to the
77:29 - player walk state
77:31 - [Music]
77:32 - online
77:36 - uh
77:36 - 21.39 first of all we're
77:39 - checking for input here right we're just
77:41 - saying if if we press left right up or
77:43 - down
77:44 - the direction is that walk left walk
77:46 - right
77:47 - so on and so forth
77:50 - um and then if
77:52 - and then what we do is we call
77:55 - entitywalkstate.update so this base walk
77:58 - state code that exists in entity so that
78:00 - we can let every single entity have this
78:02 - code
78:04 - all it does is just to check to see
78:05 - whether or not the player or entity that
78:07 - it belongs to hit a wall and if it did
78:09 - then set their bumped equals true and
78:12 - that what all that does is just a flag
78:14 - that says okay the player bumped a wall
78:17 - okay why is that relevant because then
78:19 - after we call that we can say okay if we
78:22 - bump the wall and this only happens in
78:24 - the player walk state
78:26 - if we're looking to the left
78:28 - temporarily adjust our position because
78:29 - when you when it bumps you it like
78:31 - knocks you back out
78:33 - back into the world but we're going to
78:35 - re-bump our position in to wherever we
78:37 - collided we're going to look at every
78:40 - doorway
78:41 - and then we're going to say if we
78:42 - collided with that doorway and it's open
78:46 - then uh we're going to shift it to the
78:48 - center of the doorway so that it doesn't
78:49 - look as if the player is walking through
78:51 - the wall we're going to set it to like
78:52 - wherever the wall is or wherever the
78:54 - door is the very center of the doorway
78:57 - and then we're going to call
78:58 - event.dispatch shift and then that
79:00 - direction so shift left shift right
79:04 - shift up and shift down and so all of
79:06 - these these four different cases are
79:08 - going to say okay
79:10 - the player has hit a doorway i have
79:13 - a function
79:14 - somewhere event dot on shift down shift
79:17 - left shift right shift up that's going
79:19 - to trigger what
79:26 - the next room it's going to trigger us
79:29 - moving to the next room and also the
79:30 - next room spawning and the camera sort
79:33 - of shifting position
79:35 - um
79:38 - so the code for this is in dungeon
79:43 - so we're going to go ahead and look at
79:44 - dungeon
79:46 - so right here
79:47 - on line 29-43 event dot on shift left
79:51 - shift right shift up shift down and what
79:54 - that does is we have another function
79:55 - called begin shifting which takes in an
79:57 - x and a y negative virtual width virtual
80:00 - width negative virtual height virtual
80:02 - height does anybody recall why we need
80:03 - to pass those numbers in there
80:06 - if we're shifting
80:08 - left and we're passing a negative
80:10 - virtual width what do you think that
80:11 - number is going to be
80:15 - so recall every room has an adjacent
80:17 - offset x and a y that renders that room
80:21 - with that offset basically added to it
80:23 - it's x and a y so if we begin shifting
80:26 - to the left negative virtual width is
80:28 - going to be the x offset because that
80:29 - room needs to needs to be rendered a
80:32 - screen width to the left right
80:34 - and so on for the right
80:36 - virtual width it adds virtual width to
80:38 - the x offset the adjacent x offset and
80:41 - then virtual height negative and
80:42 - positive for shift up and shift down
80:45 - so begin shifting basically uh it's the
80:50 - gist of this is
80:52 - it's a tween operation so
80:54 - we start
80:56 - here recall timer.tween just takes a
80:58 - value and interpolates it so
81:01 - self we have a camera x and a camera y
81:03 - right going to equal shift x and shift y
81:06 - eventually so shift x and shift y being
81:08 - the adjacent offset that we're going to
81:10 - need to shift the camera by
81:12 - so
81:13 - camera x and camera y are they both
81:15 - start at zero always when the room gets
81:17 - completely finalized
81:20 - so if we if the shift x is virtual width
81:22 - negative virtual width because we're
81:24 - shifting left then it's going to tween
81:26 - the camera going from right to left over
81:28 - the span of a second right
81:30 - and then the player
81:32 - the player x and player y those are
81:35 - basically set up here to
81:37 - the opposite end of the room the next
81:40 - room
81:40 - so if the player is going from the top
81:42 - of the room to the bottom of the next
81:44 - room it needs to get its uh x and y put
81:48 - in that position the bottom part of the
81:50 - next room or the left part
81:54 - the left part of the next room if
81:55 - they're moving from the right right or
81:58 - the right part if they're moving from
81:59 - the left and the bottom part if they're
82:01 - moving up and up part if they're moving
82:02 - down so that's what that does puts them
82:04 - in the right position on the next room
82:06 - tweens both of them the camera and the
82:08 - player because the player needs to keep
82:10 - moving to the next room and the camera
82:11 - needs to shift up
82:14 - um when it's finished we call finish
82:17 - shifting which is just a function that
82:18 - sets basically everything to zero it
82:20 - says the current room
82:21 - to the next room it sets the camera x
82:24 - and all that stuff all to zero and then
82:26 - all the entities and objects there and
82:28 - all get set to zero so we are they're
82:29 - offset to zero so that everything is
82:31 - basically right at zero zero again just
82:34 - like it was at the very beginning
82:36 - um
82:38 - and then last but not least when we get
82:40 - into the new room we start with the
82:41 - doors all open and then when we get into
82:43 - the net and into the room here because
82:45 - this is all done in the finish function
82:46 - recall
82:48 - this will only happen after the tween is
82:49 - completed
82:51 - uh every doorway is going to get set to
82:53 - false open equals false so all the doors
82:55 - will close as soon as we get into the
82:57 - next room after we perform the tween
82:59 - operation and then we'll play a door
83:00 - sound
83:01 - so that's that's the code involved in
83:04 - actually doing the shift operation
83:06 - so we're able to trigger it
83:08 - we don't have to necessarily do that
83:10 - code from the player walk state we just
83:12 - say
83:14 - you know if the players collided with
83:15 - the doorway then dispatch an event that
83:18 - is handled by dungeon because dungeon
83:21 - has access to current room uh next room
83:24 - and all the stuff that it needs to
83:26 - actually perform that transition
83:28 - so we have the two that are sort of
83:29 - decoupled but they work well in tandem
83:31 - with one another so anybody have
83:33 - questions this is sort of how this works
83:38 - okay
83:40 - that's the that's essentially the
83:41 - dungeon scrolling just it's a tween
83:43 - operation it's a camera a temporary room
83:45 - gets rendered we move to the temporary
83:47 - room everything gets set back to zero
83:48 - and then it's just a it's a while loop
83:50 - of that sort of behavior effectively
83:53 - and we use the event library to sort of
83:56 - clean up that whole aspect and sort of
83:58 - uh screen scrolling here just another
84:01 - demonstration we went over it in detail
84:02 - but this is a nice gift i found that
84:04 - sort of encapsulate what that means
84:07 - stenciling is something that we saw
84:09 - earlier and if we look at this as a
84:11 - stencil so
84:12 - uh
84:13 - these
84:14 - we can pretend that these are the circle
84:16 - the heart and that
84:18 - rectangle are a stencil and then we want
84:21 - to draw this
84:23 - gray rectangle on top of those stencils
84:26 - we can use the stencil to mask out
84:28 - specific parts which which would
84:30 - otherwise be pretty tough to do
84:33 - i mean it's hard to necessarily like
84:35 - maybe individually render pixels or
84:38 - create a shape that sort of looks like
84:40 - this much easier for a lot of very
84:42 - interesting visual effects just use a
84:44 - stencil of arbitrary
84:45 - shape and size and you can use images
84:48 - too you can use images as stencils
84:50 - to create some pretty cool effects we
84:51 - went over it before when i talked about
84:53 - the archways so i won't go over in too
84:54 - much more detail
84:56 - but again you can look at that in the
84:58 - where was it exactly it was in the room
85:01 - function room class sorry
85:04 - down here at the bottom so lines 213
85:07 - to 229 recall they're a stencil function
85:11 - the couple functions in in particular
85:13 - that you need to use are
85:15 - love.graphics.stencil which draws the
85:17 - stencils and then love.graphics.set
85:19 - stencil test which compares the stencil
85:22 - values to some value and draws them
85:25 - whether or not that condition is true so
85:27 - we have uh
85:29 - our function here which draws four
85:31 - rectangles those are all the archways
85:33 - it replaces any pixels that get drawn to
85:35 - those rectangles with the value one the
85:37 - stencil value one so stencil value is
85:39 - just like a hidden value that determines
85:41 - whether stencils get whether
85:43 - a image will get drawn if it's being
85:45 - stenciled or not
85:47 - set stencil test means that we're
85:49 - looking for anything
85:50 - less than one
85:52 - and we'll draw that and because the
85:54 - player is going to be one if it's on any
85:56 - of those uh stencil rectangles uh it
86:00 - will not draw the player if it overlaps
86:01 - with those stencil rectangles and so
86:03 - that's just that's in general how it
86:04 - works and you can do there's a lot of
86:06 - different comparisons you can do greater
86:07 - than one
86:09 - you can do iterative stenciling
86:12 - uh so that you can increment a value it
86:14 - could you can have stencil values go
86:16 - between one and zero and 255. there's a
86:18 - lot of interesting effects you can get
86:20 - with that but the general
86:22 - use that we just saw is you know
86:24 - set the values to one and then check to
86:26 - see whether they're less than one if you
86:27 - want to draw them if you want to not
86:28 - draw them does anybody have questions as
86:30 - to like how stenciling works and how
86:32 - these functions work
86:35 - yeah it's like having that stencil cover
86:38 - up the door the top of the doorway so
86:40 - when you drop it there like you want
86:43 - actually drawn
86:45 - yes
86:46 - so the it's like having the uh
86:48 - the stencil rectangles go over the
86:51 - doorway so that the
86:53 - player will not get drawn when it's
86:55 - underneath them the
86:56 - um
86:58 - i'll go back to a slide that has it
87:01 - the stencils are here
87:03 - right right
87:04 - i had to go through and figure out the
87:06 - exact xy that i needed for them
87:08 - and there is a you can what you can do
87:10 - is you can take that stencil function
87:12 - that draws the rectangles and then you
87:13 - can just like take it out of the stencil
87:15 - test and see you'll you'll actually be
87:17 - able to see where the exact rectangles
87:18 - are because then it'll just literally
87:20 - draw the rectangles
87:21 - um but here basically right over right
87:24 - between here and where it would be on
87:26 - the next room so that when we go from
87:27 - here over into the next room it still
87:29 - stencils them
87:31 - right here the player is gonna go over
87:33 - them it's gonna set its stencil value to
87:35 - one it's checking for anything less than
87:37 - less than one um to to render so it's
87:40 - gonna fail the test and it's going to
87:42 - uh
87:43 - not draw that player at that point so
87:46 - effectively just masking out the player
87:48 - because we're assigning it to the right
87:49 - stencil value or doing the right
87:50 - comparison for it
87:52 - but yeah that's effectively it just
87:54 - using it to
87:56 - because we were in a situation where our
87:57 - tiles didn't cleanly lend themselves to
88:00 - drawing over the player which you could
88:02 - do you could draw the shadow part
88:04 - underneath the archway part and then
88:06 - just change the rendering order but the
88:08 - sprite sheet that we had didn't afford
88:10 - us that flexibility so
88:13 - we went through with a little more
88:15 - interesting stenciling approach to
88:17 - getting it done
88:19 - um we looked at this earlier so game
88:21 - design
88:23 - via data rather than
88:25 - you know a bunch of logic
88:26 - so the more you can sort of get towards
88:29 - modeling your
88:31 - anything in your game like data like
88:32 - this the more flexible your engine is
88:34 - the easier it is for people to mod your
88:36 - game which is hugely important and the
88:38 - easier it is for you to let designers
88:40 - take charge of actually creating assets
88:42 - for your game so here we've created an
88:44 - arbitrary collection of data and you
88:45 - could get as complex with this as you
88:47 - want to
88:48 - the only thing that really matters is
88:50 - whether your game engine supports those
88:52 - fields and
88:53 - acts on those fields accordingly but
88:54 - once it does i mean the more things you
88:56 - add the more possibilities you have for
88:58 - adding new things so goblin we have
89:00 - health strength so strength should be
89:03 - accounted for in our game engine and
89:05 - this is we're talking in just the
89:06 - general abstract sense now let's say
89:08 - we're like making an rpg or something or
89:10 - maybe maybe maybe this is part of our
89:12 - zelda game if we got a little bit more
89:13 - detailed with it but
89:15 - goblin is going to be a creature that
89:17 - has 10 health it's got two strengths so
89:19 - these values will get loaded when it's
89:20 - created as an entity and strength is
89:22 - some value that our engine needs to
89:24 - apply to anything that it decides to
89:26 - attack right you can do the same thing
89:28 - with defense you could create arbitrary
89:30 - things it's got a goblin texture so
89:32 - that's the sprite
89:33 - we've defined some animations here which
89:36 - you've already seen how to instantiate
89:37 - those in our game engine
89:39 - maybe it starts off with a
89:40 - club weapon
89:43 - um and you could also
89:45 - reference other
89:47 - sort of uh lua files that have these
89:49 - definitions if you have maybe a
89:51 - weapons defs
89:53 - file you could index it into weapons
89:55 - def's club and then that club item will
89:58 - maybe have a bunch of its own
89:59 - characteristics that
90:01 - when your game engine is loading this
90:03 - goblin death it loads in the club def as
90:07 - well and instantiates a bunch of
90:08 - qualities onto that entity or that item
90:12 - that then have behavior relevant to your
90:14 - game engine um aggressive is true so if
90:18 - something's a dot you know entity dot
90:20 - aggressive then maybe it's a i will seek
90:22 - out the player right and you can set
90:24 - that to false so now you can
90:25 - differentiate between entities that
90:26 - chase the player and entities that are
90:28 - sort of docile and just do their own
90:29 - random thing
90:31 - uh sleeps at night maybe your game has a
90:32 - day night cycle maybe some entities stay
90:34 - awake and some go into a sleep state
90:37 - right so it'll look and say oh okay it's
90:39 - night time does the entity dot sleeps at
90:41 - night if it does okay then
90:44 - entity change state sleep right and then
90:48 - during the day
90:49 - phase when the day happens you'll do the
90:51 - same thing in reverse you'll say if that
90:53 - entity that sleeps at night
90:55 - uh then you'll say entity not awake is
90:57 - true or whatever it is um change state
91:00 - awake or idle or walking
91:02 - and inflammable maybe you have weapons
91:04 - that
91:05 - shoot damage or shoot fire or maybe you
91:07 - have torches that shoot fire or some
91:09 - maybe you're in a level that's like lava
91:12 - and you know if you get touched the one
91:14 - of the tiles it has a flammable effect
91:16 - and if it's flammable maybe your status
91:18 - equals flammable you take damage over
91:20 - time and you change your animation maybe
91:22 - you get tinted red or something like
91:24 - that but thinking about all these
91:26 - different possibilities and like what
91:27 - your engine is capable of you can create
91:29 - pretty much arbitrarily complex data
91:31 - structures and
91:33 - entities and items and whatever you want
91:35 - in your game without having to create a
91:37 - goblin class or a skeleton class or a
91:40 - arbitrarily complex creature class you
91:43 - just compose
91:44 - your creature with attributes and
91:47 - model its behavior that way composition
91:49 - over inheritance which we talked about
91:50 - last week it's very valuable in game
91:52 - design and that's what unity's game
91:54 - engine sort of approaches
91:55 - because entity is a purely entity
91:57 - component system whereby entities are
92:00 - modeled as collections of components
92:03 - that each do something and we can sort
92:05 - of almost think of these as components
92:07 - too
92:08 - albeit a much simpler sort of
92:10 - representation does anybody have
92:12 - questions as to this or like why it's
92:14 - useful or anything like that
92:18 - okay
92:20 - so the last thing i wanted to talk about
92:21 - today um and i saw uh i think one or two
92:24 - students were mentioning how they wish
92:26 - they knew or wish we talked about a
92:27 - little bit more
92:29 - how programming was done back in the day
92:31 - so i'm not an expert necessarily in sort
92:34 - of programming
92:36 - you know 6502 assembly which is what the
92:38 - nes has written in there are a lot of
92:40 - people that are very good at it but
92:41 - there's a few links here so in the
92:43 - slides if you wanted to look at the
92:44 - slides on the website
92:47 - homebrew is actually quite a popular
92:50 - thing amongst certain communities online
92:52 - and what it is is essentially getting
92:54 - compilers that will compile source code
92:57 - for some arbitrary processor or you know
93:00 - development environment from
93:02 - some arbitrary computer system like the
93:04 - nes which was a 8-bit microprocessor
93:07 - based machine with its own set of
93:09 - interesting hardware
93:11 - it allows you to compile the assembly
93:12 - for that and actually run it via a
93:14 - program called an emulator an emulator
93:16 - just allows you to run rom images or you
93:19 - know just arbitrary data that maps to
93:22 - the machine instructions of some
93:26 - system that the emulator has emulated
93:28 - via a virtual machine
93:30 - and so if you wanted to look at
93:32 - look into it a little bit more in detail
93:35 - the there's a couple links here so nes
93:37 - dev wiki's got a bunch of great links um
93:39 - there's a programming guide that kind of
93:41 - goes over the basics of how to do some
93:42 - 6502 assembly as well as with the nes
93:45 - and its particular hardware and then
93:49 - the compiler that most people use for
93:51 - this is called cc65 which is a 6502
93:55 - assembly
93:57 - compiler and so this is
93:59 - an example of some
94:01 - source code it's a little bit tough to
94:03 - read but
94:04 - uh
94:06 - i can't zoom in i don't think but the
94:08 - gist of it is you have a lot of in here
94:11 - i can actually pull it up online uh let
94:13 - me try
94:16 - um super mario disassembly
94:20 - so we go here
94:23 - this is on github so somebody decompiled
94:26 - basically or
94:27 - disassembled rather
94:29 - take took the bytes that represent all
94:32 - the machine code and the rom image of
94:34 - super mario brothers and then just
94:36 - converted it back to assembly language
94:38 - and then added comments to it
94:40 - because uh
94:41 - i won't go into too much detail about
94:43 - what assembly is and how it works but
94:44 - essentially it's just a layer directly
94:47 - above machine code where
94:50 - keywords map to essentially what are
94:52 - bytes in memory that are actually
94:54 - program instructions and that influence
94:56 - the behavior of your cpu such that you
94:58 - get programs and that's what c is
95:01 - layered on top of and then every uh
95:03 - language thereof
95:04 - thereafter
95:06 - so if i zoom in here see if i can
95:10 - just being a little slow but
95:13 - it's letting me
95:15 - so
95:16 - here
95:17 - we can see
95:20 - for some reason i think it's lagging
95:21 - because the file is just so large it's
95:23 - like 14 000 lines of code because this
95:26 - thing about assembly is assembly is very
95:28 - very long because there are so many and
95:31 - you need to have just like really slowly
95:33 - zooming in infinitely
95:36 - there are just uh
95:38 - so many steps you need to do in order to
95:39 - achieve the same thing that you get in a
95:41 - high level language like c or
95:43 - or even languages higher than that
95:47 - taking a lot of things for granted
95:48 - especially things like you know loading
95:50 - registers so every cpu has got a series
95:52 - of registers that can store values and
95:54 - then the cpu has logic that knows that
95:57 - you can basically say okay if the value
95:59 - in register a is greater than or equal
96:01 - to some value then branch to this
96:03 - sequence of the assembly code
96:06 - and you often you'll have to do things
96:08 - like and or operations on byte level uh
96:12 - you know just on bytes like right here
96:13 - we can see we're ending uh the value
96:15 - three on
96:17 - uh whatever is in register a
96:20 - like i said not don't intend to get too
96:22 - much into what assembly is but for those
96:24 - curious as to how games were implemented
96:27 - in the 80s and even the early 90s it was
96:29 - all an assembly language because
96:31 - assembly language is
96:33 - you're literally programming the the cpu
96:35 - of whatever machine you're trying to
96:36 - program and that's how you get as much
96:40 - efficiency as possible if you know your
96:42 - computing environment you know what your
96:43 - cpu is capable of
96:45 - the thing about compiling a language
96:47 - like c
96:48 - or
96:49 - c plus or java which is even higher of
96:52 - an abstraction than those is you're
96:54 - allowing sort of algorithms to do the
96:56 - work for you you're allowing
96:59 - algorithms to take your source code and
97:01 - turn it into this basically well a layer
97:04 - lower than this effectively this is an
97:06 - intermediary level that it does generate
97:08 - but
97:09 - suffice to say in the 80s and 90s c
97:12 - compilers were not as good as humans
97:14 - were in creating games
97:17 - especially to do a lot of the tricky
97:18 - things that they needed to do in order
97:20 - to get them
97:21 - working efficiently on processors that
97:23 - were at the time
97:24 - one to three megahertz in speed which
97:26 - now we have like three gigahertz
97:28 - processors and it's no big deal
97:30 - but that is
97:32 - effectively
97:34 - that's that's sort of a window into what
97:36 - it was like developing games in the 80s
97:39 - and 90s and then in the 90s with like
97:41 - things like the n64 playstation 1 going
97:43 - on to playstation 2 and so forth
97:45 - um
97:47 - it was typically done in a language like
97:49 - c or c plus sometimes with some variants
97:52 - um certain consoles like the ps3 has a
97:54 - notoriously difficult graphics processor
97:56 - to program so a lot of ps3 teams needed
97:59 - to program in assembly even you know at
98:02 - the time which was 2007 2009
98:05 - but that's
98:07 - in a nutshell
98:08 - what it's like programming the 6502 so
98:11 - if you want those things uh those links
98:13 - up above it's a pretty enlightening
98:15 - experience actually digging into that
98:16 - sort of thing and trying to make sense
98:17 - of what the assembly does um it's
98:20 - quite difficult and quite uh
98:22 - it's quite burdensome because of how
98:24 - long these programs are and just how
98:26 - minut each individual instruction is
98:28 - like just checking just loading a value
98:30 - into a register uh just to you know do a
98:33 - loop often will just be iteratively
98:35 - loading a value into a register and then
98:37 - like performing some operation or
98:39 - calculation off of that
98:40 - and then branching to some other loop of
98:42 - code a lot of that can be condensed into
98:44 - like just a couple lines of c
98:46 - or even fewer lines of lua
98:48 - so
98:50 - a lot more of a burden but there is
98:51 - insight definitely some insight into
98:53 - digging a little deeper in sort of
98:55 - looking there so once again those are
98:56 - the links
98:58 - on the nes dev wiki wiki.nesdev.com if
99:00 - you're interested in looking at that
99:02 - in assignment 5
99:04 - you will like you did an assignment 4
99:06 - you can create a game object that's
99:08 - consumable and feel free to use code
99:10 - from assignment 4 to do this
99:12 - when
99:13 - like you define your on consume function
99:16 - uh if you're going to adopt the same
99:17 - model as the last assignment then
99:20 - any ideas is what we need to do
99:26 - probably just
99:27 - add
99:28 - uh you know the opposite of damage the
99:30 - entity right we want to add
99:32 - hearts we want to add hp to it
99:34 - um
99:35 - and you'll see in the distro that health
99:38 - is modeled as uh
99:40 - an even number because every one digit
99:42 - is half a heart yeah
99:46 - you can
99:48 - and it'll uh that'll effectively be the
99:50 - same thing too so
99:52 - uh
99:53 - the second part is including pots so
99:55 - there are pots in the sprite sheet so
99:57 - they should these should be solid so
99:58 - when the player interacts with them he
100:00 - should be bumped out
100:02 - uh of where he was
100:04 - uh allow the player to lift them so
100:06 - there's an animation in the sprite sheet
100:07 - that'll actually allow that shows the
100:09 - player lifting up the pot so you
100:12 - probably need a new state player
100:14 - lift pot state
100:15 - walk with pot state whatever you want to
100:17 - define it as but you'll need uh
100:19 - basically to have those two in order to
100:21 - get this to work
100:22 - what's one thing that we'll need to do
100:24 - in order for the player to lift the pot
100:26 - any ideas
100:29 - besides the rendering aspect of it
100:32 - when the player walks around for example
100:34 - what needs to happen
100:36 - if he's holding the pot
100:40 - you could make him slower yeah that's
100:42 - possible that's not it's not required
100:44 - for the assignment
100:45 - more fundamental than that
100:49 - the pod needs to track the player's
100:50 - location right it needs to be relative
100:52 - to the player's location so keep the pot
100:55 - probably above the player to some by
100:57 - some amount um
100:59 - i won't be too picky as to how you
101:00 - implement that but the pot needs to
101:02 - track the player
101:04 - which is this next point actually and
101:06 - the walking animations like i said
101:07 - should change while they're carrying it
101:09 - allow the player lastly to throw the pot
101:11 - so when you throw the pot
101:12 - basically turn the pot into a projectile
101:14 - if it hits one of the walls break it
101:18 - you can either just despawn it instantly
101:20 - or have some animation it's up to you
101:21 - but just if it hits a wall despawn it
101:25 - trigger it to maybe just trigger it to
101:26 - some value is false render is false
101:29 - whatever you want to do
101:31 - if it hits an enemy
101:33 - it should damage the enemy by one just
101:35 - like we've seen already and if it
101:37 - travels farther than four tiles in
101:39 - addition to also hitting one of the
101:40 - walls then destroy it too
101:43 - so those are the main components for
101:45 - assignment five
101:47 - and the ways that which you achieve most
101:49 - of it's fairly flexible
101:51 - but yeah that's assignment five or uh
101:53 - lecture five legend of zelda so thanks
101:55 - for coming i'll see you next time

Cleaned transcript:

all right welcome to gd50 lecture five today's topic is the legend of zelda as you can see on the screen there uh very iconic game last week we did super mario brothers which is arguably the most iconic video game of all time legend of zelda is a close contender even now just like with mario they're producing very wonderful games i think last year breath of the wild took all the i forget which ceremony it was or awards sort of show but it took like every award possible this last year the latest zelda breath of the wild so it feels sort of apropos to talk about legend of zelda in that context as well uh here's a screenshot of the original legend of zelda it was an nes title just like super mario brothers a you know just like most games of its time tile based you can sort of see how the surroundings are sort of layered tiles bit by bit the goal of the game overall was to sort of explore this open world which is kind of a first of its kind you controlled link shown at the very bottom there you had a sword you had bombs you had arrows you had uh you went to go find rupees you went through dungeons you slayed monsters and bosses and then ultimately the goal was to obtain the triforce which is shown at the very top left and right of the slide here here's the screenshot another screenshot legend is all the inside and actual dungeon where you can see at the very top there's got like a map layout maps are sort of arranged in a grid and you could go you know room by room whereby each room was the entire width and height of the screen uh looking for you know solving puzzles looking for items that sort of thing uh you can see there's a monster there you have hearts at the very top right so when you take damage hearts sort of decrement we'll see both of these the hearts and the the dungeon aspect of the game today in lecture as well as you know the the width and height of the room being a dungeon tile and controlling an avatar but this is sort of a representative screenshot of what the game looked like back in the day some topics today that we'll be discussing in order to implement sort of the foundation for what a a game engine like this might look like are things like top down perspective so as you can see in this screenshot we're looking at you know link from the very top and a bird's eye view as opposed to how we used to look at mario from the side where it was sort of like a side scroller here we're actually looking at things from the top down so we have a view of the room in sort of a different perspective there's sort of a there's not really a zaxis technically speaking but there sort of is you can implement things like gravity in a game engine like this by jumping over holes and things like that but there's no gravity like there was in super mario where you know you walk left to right you jump over gaps and it's very easy to see in that sort of sense we'll be talking about infinite dungeon generation so in the context of today's example we'll see how we can go about implementing a dungeon that sort of you can go through forever and ever and how to sort of model that and make it look as if you're traveling through a dungeon over and over again and going through different screens in different rooms that are all different but in reality we'll see it's actually just an illusion like we've seen before in prior lectures we'll talk about hitboxes and hurt boxes and what the difference is between the two hitboxes being uh rectangles on the screen that inflict damage upon other entities in your game world and hurt boxes sort of being the rectangle that models where your player or whether where an entity in the game can be hurt by other hitboxes we'll look at events so events are a way of sort of broadcasting some key or some message that tells the game world oh this thing happened and let me register a function to call when that sort of event is processed so on some event you know dispatch an event and then upon that event being received by whatever's listening for it perform this chunk of code it allows you to sort of decouple aspects of your game engine a little bit and makes for a little bit more readable code and allows you to do some interesting things with like achievements for example where you don't necessarily want to pull every single frame oh did i do this sort of arbitrary list of things this frame rather you can just process all of that within the event and have a listener and a function that you know every time you broadcast oh pick up coin maybe i have an achievement that's like oh uh have i picked up 50 coins in this level you know your achievement callback function in your event can can then look for that and in your game loop you don't have to say every frame oh if player has 850 coins and you sort of take out bloat that would exist in your sort of overall game loop that way and we'll see an example of how we use that in today's lecture we'll look at screen scrolling so a very common uh very uh sort of iconic aspect of legend of zelda is when you're going from one screen to another there's a sort of transition period as one screen loads and the other screen goes away in hardware in the nes uh this was sort of the only way um you could actually render a lot of um sort of more than a screen width of tiles you actually had to dynamically load in tiles and sort of overwrite tiles that existed before that in memory but today we'll see how we can sort of create the illusion of doing that by just drawing a room and then having our main room and then just sort of tweening over and then setting everything back to the origin at zero zero and it makes it look as if we're moving you know back and forth between all these rooms when in reality all we're doing is just doing a shift and then putting everything back to zero zero so i'll sort of illustrate that on the screen if i can and one of the last things we'll look at is data driven design in the context of a lot of types of games particularly rpgs and action games it's often very valuable to be able to model all of your items entities sort of abilities anything you really can as data rather than logic in order to make it easier for you to write one and two for you to sort of allocate the design aspect of your game to other people not just programmers and have an engine that's very versatile and moddable and we'll we'll take a look at how we implement sort of a foundation for that later on but first i'd like to illustrate a demo for today's lecture um a sort of implementation of legend of zelda is there anybody that would like to come up and sort of demo this today in class no awesome thank you so much so whenever you're ready just go ahead and press uh the return key there and so we see on the screen legend of 50 which is our legend of zelda mock uh you know rip off sort of so if you press enter you go into this is the play state of the game so you control an avatar he can walk around he can interact with switches as we saw here when he presses a switch the doors open and once the doors are open you can walk through them and it does as i alluded to before it transitions the screen uh one entire screen with height or width depending on the direction up above and below we see here now we're pressing space spacebar to actually swing our sword it's destroying the entities in the game space so there's a hitbox triggering when you press the space bar that collides with other entities in the game world if that hitbox hits their hurt box then they are flagged as dead and they disappear from the game world and so this goes on ad infinitum is just an infinite dungeon so we he can go uh in between as many floors as we want to all we're doing is every time we go through a doorway spawn a new room delete the old one and just keep going forever and ever and ever in a game like legend of zelda typically doesn't work like this there's a hard set number of rooms and they all exist in sort of a 2d array and when you generate your dungeon you sort of have to take into consideration things like where do i put the keys where do i put the boss where i put treasure that sort of thing we won't get too in depth as to how we can implement a complex algorithm like that but we'll touch up on it a little bit and talk about maybe some ideas that we have and then lastly if we just if we want to demo as we can see at the top left we have hearts there which is uh iconic sort of zelda and when we do take damage from an enemy notice that we flicker a little bit so there's some rendering behavior triggering and we become invulnerable when we take damage and then lastly when we finally take the last hit we get a little game over screen using the zelda font and that's the game in a nutshell and we press enter and loop back so pretty simple all together but there's a lot of pieces here that we haven't really seen before so thank you very much for coming up to demo the game all right so that was a demo of you know legend of 50 legend of zelda it has a lot of the pieces that zelda has it's not as fully fleshed out of course as a full game like zelda which would be monstrously large um and there's a lot of things we need to factor in but the foundation is there we have the dungeon foundation upon which we can build a an actual generator if we wanted to we have entities we have hitboxes we could easily model because we have switches in the game we could model things like treasure chests that open that have different states just like the switch had different states and have different objects in our game space interact with other objects we have a lot here and we'll talk about all of it today so here's a few screenshots just to show you know what we just looked at our goal mainly is the second screenshot on the top right which is the play state that has all of the little pieces we just saw but just to tie it all together we do have a start state here and a game over state which is relevant in regard to the hearts in the top left so the first thing that i'll talk about um as we sort of get the engine built up is where do we go for getting our assets into the game and just like in prior lectures prior to today we just have a sprite sheet like we did with mario where everything is laid out in a fairly even sequence of tile segments in this case the segments are 16 by 16 pixels here i've overlaid a grid just to show that the picture is indeed perfectly 16x16 and this is something that you should take into consideration and consciously do when you're building your game assets make it easy to chop up into little pieces so you can then index into this sprite via some table of quads and then assign an id to whatever object or tile you want to render to the screen and so we see if you look here things like the doors they're not perfectly modeled by one tile and so when you do have things that are larger than 16x16 it's not quite as easy as oh you know have an entity or an object with this frame id and draw it to the screen you actually need to do a little bit more complicated render logic so uh just offhand if i wanted to draw a door does anybody have any suggestions as to how i would model that and or draw it to the screen so if we have a door that's not perfectly a 16 or a you know a 16 by 16 pixel tile offhand the you know what we need to do is just basically store all four of those tiles in this case or at least you know keep track of however many tiles your um object is and then just draw them based on some offset have the you know an x y that represents the top left of that object place it in the right position and instead of drawing just one tile we draw four tiles and then instead of having just one collision box that's 16 by 16 tiles you can do a couple things you can either check collision on all four of these tiles or all at least all two of these door tiles or model your own custom hitbox that then maybe that object that represents a doorway has control of so you can say you know doorway collides player and then the doorway has a height and width of however many pixels it is wide by tall here just this door part and then you know you are able to then build upon not just having one tile that models a an object or entity in your game space but now you have more artistic flexibility you can do things like have doorways that are more than one pixel wide and sort of have a more convincing game world as a result of that and you'll see a lot of things like that in games like rpgs where you have full houses that are obviously not just one tile because that would be i mean some you can model things as one tile if you want to but uh from an artistic perspective and from just a game engine perspective it's a little bit easier to programmatically be able to cut up all your assets into tiles and draw them as such so being able to sort of build upon the just the single sprite and be able to do multiple sprites to represent an object is the key to things like houses things like big trees things that are just more complicated than single tiles as we see here the character sprite sheet is as you can see a little bit more complicated so this is an example of a sprite sheet that has padding sometimes you will get sprite sheets that aren't neatly divided into even segments and for a good reason because sometimes you have tiles that are not perfectly the width and height of whatever your game engine's tiles are in this case the player is actually 20 pixels tall and 16 pixels wide and on top of that he's got different frames of animation we can see here at the bottom left he's got a sword swing animation the sword swing animation is actually stored in a 32 by 32 pixel frame because sometimes depending on which angle he's looking at his sprite can get a little larger or smaller so when you have a sprite with padding what's sort of a way that we can draw this to the screen reliably like how do we how do we take this into consideration how would we render a screen a sprite with padding so let's say this right here our character swinging a sword is in a 32 by 32 pixel box right this sort of box around here this white space but he's only still maybe 16 pixels wide by 20 pixels tall or maybe he's some amount similar to that in order to draw him to the screen which you can look at in the code all we really need to do is assign that sprite and offset just say okay this sprite's offset x and offset y are some value that basically lets us draw the sprite to a negative x and a negative y value and that'll shift the sprite up such that it aligns perfectly with wherever his x y are and we can you can take a look at that in the code to see exactly how that works lastly the actual entities for our game world are different creatures and this is a sprite sheet this is a more ideal sprite sheet where everything is 16 by 16 pixels wide and tall and all we really did here was just divide the sprite sheet using the regular utility function generate quads by 16 16. we don't have to worry about separate you know widths and heights for everything and we can create animations very simply because of this um as a side note something that i like to do when i'm you know parsing or when i'm piecing apart a sprite sheet that's got a lot of individual frames particularly from creating animations or i just need to know it for a tile a particular tile to draw to the screen it's kind of a pain to manually look through each and every tile one by one and say okay this is one but okay if i want to find out which one this the slime is i gotta count okay how many pixels wide is this okay and then it's times four so it's twelve and then it's on the fifth row so 12 times four plus one will get me okay so it's that's it's at index 49. so i've spent you know a nontrivial amount of time sort of hand calculating what all these do i wrote a simple python script that will just go over a file and just add a digit to each individual quad to just show you at a glance what each sprite is and this is included in the distro so you can see what it looks like saves a lot of time and i recommend trying when you're you know sort of working with assets and you find yourself doing something that takes a long time and sort of tedious and mechanical maybe try try to find a way to sort of automate that or at least make it easier to do things at a glance in this case just simply imposing a numerical grid solves that problem i don't have to spend a significant amount of time figuring out which frames of animation the ghost facing left is i know instantly it's 67 68 and 69 and allows me to just crank things up that much faster so the first thing we'll take a look at is a sort of topdown perspective and we mostly talked about this before earlier but all it really is is a tile map which we've seen before uh the only difference is now instead of looking at things from the side we're just looking at things from up above so what's it what's a probably the most obvious consideration when designing a topdown perspective versus a sort of sidescrolling point of view paying it looking at particularly how the tiles are drawn what stands out so the thing that stands out to me is that we have things like shadows on walls here we have also corners and things altogether are skewed such that they are almost like rotated slightly as if they're simulating an angle of rotation relative to the uh camera facing from up above you can see this in like the player for example he sort of looks sort of looks like you're looking at him from kind of backwards and up when you're modeling your assets that way you this it's more convincing and zelda has always done this to make your assets look as if they are slightly tilted and that you're looking up above so when you're designing a topdown game just for convincing the sake of being more convincing try and emulate that the entities here like the skeleton and such are a little bit more straight on the bats and slimes and whatnot even though they still have a little bit of that appearance like the spider it sort of looks as if it's from the top back but modeling your assets from a topdown perspective really that's mainly mainly the thing pay attention to shadows and highlights which adds a lot in terms of convincing us that we're in this room with lighting and also make sure that you're doing things like corners and stuff and making it look as if things are slightly skewed rotation wise the first thing that we're going to look at in terms of the code in the distro is dungeon generation so uh in legend of zelda dungeons are fixed they're completely set in advance by the designers and in most games this is actually the case in our example and in a couple of other examples a primary example of them being that i can think of that i have in the slides a famous game called the binding of isaac dungeons can also be generated so in what what's the sort of like the main unit of a dungeon at least in the in the context of legend of zelda if you had to distill what comprises a dungeon what's like the most fundamental unit yes a room so we can almost look at this if we picture it in terms of a 2d array right we have assuming that this is like index 1 1 and lua 0 0 and other languages going left to right top to bottom basically we have on or off relative to each of these off on on off off off each of the indexes in this 2d array holds a room and so the room has connections implicitly between the other rooms if you wanted to go let's say from this room here to the room up above it what's the offset in terms of the 2d array how are we going from this room up to this room so we're just going up a y level right so this is x level three why level three if we wanted to go up to the next room we need to load in if we're doing it the zelda way right and we're just going we're we're doing a transition between one room to another what we need to do is load in the room at this room minus one on the y and then perform the transition and then set that to the current room such that now we know we're at y level two x level three that's our dungeon in the context of 2d uh dungeons and the legend of zelda that's as simple as it really is you have a 2d grid of dungeon rooms each room has its own collection of entities and objects and connections to other rooms but really all you all you do to sort of fill a dungeon is fill an array in a smart way such that there's no rooms that are for example left by themselves notice that every room in the dungeon has at least one connection to another room and that when you're maybe doing your algorithm to create a convincing dungeon let's say this room here has a door on the right that has a lock right we want to make sure that the key isn't in that room because if it is we're never going to be able to get to it assuming that we come from another direction so when you're designing dungeons procedurally you want to take these sort of things into consideration and then for example the boss room let's say this is the boss room the boss room should have a maybe a boss key or something like that but the boss key should not be obviously in that room it should be somewhere maybe where there's a a couple of rooms before it that have a lock or a key so that you know there's some sort of challenge involved in your dungeon it's not just random as as random as we've done before there has to be a little bit of sort of conscious design on behalf of your algorithms today we're doing things completely random um for illustration just because a system like this is fairly robust and complex but with some effort you could create a simple dungeon generator just using those mechanics just make sure that you have locked doors the lock doors can only open when you have a key make sure the key exists in a place that's accessible and sort of create a chain of like a sort of like a control flow model maybe via a graph of some kind that uh represents your dungeon and the progression thereof so that's that's what a zelda dungeon looks like that's what a 2d dungeon in this sort of perspective looks like and it looks it will look similar to this in other game engines it doesn't necessarily have to be perfectly modeled as a screen with screen height room going into another screen with screen right room you can have arbitrarily complex rooms that have arbitrarily complex sizes and shapes but you still need to make sure that the connections going out of the rooms like if you you could still model you know left right up down if you want to you could model arbitrary numbers of connections between rooms just make sure that you have puzzles that can be solved that's the main sort of obstacle in generating your dungeons here's a game that i really like that uses the old legend of zelda formula to very good effect now it's called the binding of isaac notice already we can instantly see that it's topdown perspective it's the entire width and height of the room is the dungeon of uh the entire width and height of the screen is the dungeon room uh you have a map up here that sort of shows you oh okay i'm in this room right here i can go up i can go left i can go right i can go down this room up here with the yellow crown that's going to be locked behind some door with a key so we need to have keys that spawn in any of these rooms that are just blindly accessible and isaac does things a little bit differently also in that it generates keys and bombs randomly so that you can actually get you don't necessarily have to plant your keys in very specific locations if your algorithm is sufficiently accommodating and complex enough you can just at the end of every room have a chance to spawn a key randomly and you know if you're lucky or if you're not lucky and assuming that the end of the dungeon doesn't exist behind your locked doors you can you have the opportunity to unlock those doors or not and just go on throughout your dungeon as needed in this case they don't lock the boss doors so you can go through the boss door regardless of whether you have a key so they've accommodated for this purely random approach and that just goes to illustrate how you can still take randomization using very complex principles and produce games that are extremely addicting and fun and don't necessarily need to be super elaborate the first thing okay so hitboxes and hurtbox will be the next topic so i want to touch on in the code how we sort of do dungeon generation in the game engine here so i'm going to open up there's a few files so doorway notice in in the source distro there's a world folder we've sort of categorized all of the files that have to do with world generation within that world folder we have a doorway file we have a dungeon file and we have a room file so the dungeon file models the dungeon it's just all of the rooms that form our dungeon just as a very high level top level data structure it's actually very simple the room is as we saw before the individual unit of the dungeon so a dungeon is effectively like a table of rooms and then it models interact mode it holds the code for how we can transition between them but that's sort of how we can think about it when you have a game level in general in this case dungeon is sort of our game level you can model the different subset aspects of your level via some data structure in this case we've decided to make it room but if you have just a platform or level maybe you have regions or zones or anything just little sub segments of your level that you can transition between it's useful to think in terms of that because from an efficiency and performance standpoint you want to dynamically probably load certain levels one at a time certain aspects certain components sub areas of your level one at a time rather than just the entire level at once because depending on how sufficiently complex and larger level is you could get to uh you know exercising your computer's memory constraints so don't want to do that so in this case our algorithm is we have a dungeon we have rooms we have one active room that's only visible at one time that's loaded in memory and then whenever we transition between rooms we want to have another room that gets temporarily loaded so let's look at the dungeon class here dungeon.lua so 14 self.rooms empty table we're going to fill that with rooms just room objects self.current room room and then we're going to pass it in uh the player so that the player has access to all the entities and objects therein and can do things like collision detection which is very important and also so that the entities in the room can look at the player and then decide what they want to do with their ai which you can model arbitrarily complex um the whole init function of room.lua is gonna we're gonna show it here so in room.lua in that same world folder we've instantiated the dungeon at a high level we know the dungeons it's basically a table of rooms so what's a room look like well a room as we saw before what are the what are the pieces that a room needs in order to function what does the room have to to sort of keep control of so doors anything else so doors it has to keep track of right because when we touch a door we should transition to the next room it should keep track of the player so the player can update should keep track of objects in the in the room like switches as we saw in the example such that you know they can update those and see oh has the player stepped on the switch if he has open the doors and then entities right you should keep track of all of the creatures in the in the in the room so that they can update they can interact with each other the player can hit them or they can hit the player um and you can model whatever interactions you want to so we can see here oh and another thing too obviously probably the most one of the more important visual aspects of it we need to also have a set of tiles that model what the room looks like it's a container so we're going to draw you know we have a corner a corner a corner a corner walls on the sides walls on the top and bottom and then a floor and so that's we need to obviously draw the room before we draw all of the other things and update all the other things so tiles doorways entities and objects so we can see here we have tiles self.tiles gets an empty table we have a function called generate walls and floors entities empty table we have a function called generate entities and then objects equals empty table we have a function called generate objects and lastly doorways and then here it's uh because it's not necessarily as complex as we need for a an entire function we just have four doorways and this is static i've chosen in this example to have all the doorways always be in the same place and sort of behave in the same way but you could create a more complex system whereby you especially if you have an algorithm that generates a dungeon dynamically and maybe your rooms aren't necessarily hard set maybe maybe you have a room right if we go back to our slides earlier and let's say we're looking at this room right here in the very center we can see it has a dory on the left a doorway up top and a doorway to the right but there's no doorway on the bottom and that that looks like an arbitrary design decision on behalf of the designers but uh if we look at this room up top here we can see that it sort of behaves in the same way there's a doorway going to this room to the left there's a doorway going to this room down below but it doesn't have a doorway up top and a doorway on the right because there are no rooms going between that room and those directions so when you have a 2d array of dungeon rooms and you want to model your doorways it can be as simple as is there a room in that direction if there is and you'll have your data structure sort of laid out in advance before you generate these doorways if it does if it does not exist don't make a door if it does exist make a door and then make sure that when you transition between the left from let's say from the right to the left or from the bottom to the top that you go to the correct rooms at the correct indices in your 2d sort of room array does that make sense anybody have any questions so far as to like how this works at a high level okay awesome so these doorways here are all because this dungeon's completely random and every time it always has uh doorways going top bottom left and right we're always just going to put four doorways going top bottom left and right note that they take a string denoting which direction they are and this will become important later on in the doorway class which we see here is modeled as a separate class false here just means is the door open so by default we're going to close the door and then self so that we have access to the room from the doorway um the room should have a reference to the player so that it can model uh interactions between the entities and the player as well as the objects on the player that it has a render offset so if we look at the game here the tiles don't completely match up to the width and height of the screen and that's mainly a function of the virtual height not mapping perfectly to 16 tiles divided evenly by 16 tiles so what i've done is i've made the dungeon a little bit smaller and i've and also the fact that the um doorways take up a couple extra tiles of padding on their on their sides this like sort of blank space up here we've shifted everything inwards a little bit we've made that we've made the dungeon one tile smaller or two tiles smaller width and height wise than the screen and then we've just rendered offset by a certain amount such that it's completely centered we calculate how much padding exists between the fully rendered dungeon and whatever blank space is left and just shift by half of that amount and that's our render offset so that's why that's what why render offset is important in this case when you're trying to center anything you typically do it just by calculating an offset calculate the width and height of whatever you're trying to draw calculate whatever your width and height of your screen is minus that divided by two that's your render offset and then this is this these two fields here are interesting self dot adjacent offset x and self.adjacent offset y does anybody have a guess as to um sort of what this is used for yeah yes exactly so drawing itself when it's the adjacent room so when you load the next room you're going to instantiate a room just like this but by default it's going to draw at zero zero however if we want that room to draw you know not right where we are obviously if we're in the current room we don't want the next room drawing right on top of where we are because then it's just gonna layer right on top of the room we're in we want to draw it if we're going to the right we want to draw a screen width to the right if we're drawing it to the left we want to draw a screen width to the left and same thing on the y axis the screen height above or below it so adjacent offset x or y we just add to when we draw the room and that'll have the effect of rendering it separately from uh from the room that we're currently in i can try and have an illustration here so if we have our room here this is our current room so self dot current room and if we let's say we have a doorway here right that's a doorway object the player is here he collides with that object it's going to trigger a transition to a room up above so what we do is we load in a new room right away we always have a pointer called self dot next room and this is all kept track of in the dungeon.lua file but self.nextroom by default is going to be nil but when we transition from the current room to the next room right we should set that to something so self.current room is going to be the same but when we trigger this when we trigger this collision self.nextroom this is going to be equal to just a new room and then we get which doorway we're in we figure it out we figure out which direction we're moving in technically and then if we're moving up then we just pass in a we set it adjacent offset y in this case to negative screen height if it's below we set it to positive screen height if we set it if we go here it's going to be negative screen width the adjacent x will be negative screen width and then positive screen width on the x if we're moving to the right and so uh this sort of adjacent we could see the uh if we do like x y i think that'll be that's that's basically the adjacent offset and so um we end up when we draw our transition going from bottom to up in this case we just tween the camera to this value so we have a camera right this is our camera and it's going to be looking here by default so camera x and camera y those are values in our code as well when we trigger this collision on the doorway and we have current room here which is at zero zero and then we have this room here which is at zero minus or plus our adjacent offset y which is negative screen height so it has the effect of making it negative screen height on the y our camera x recall love.graphics.translate is our camera so all we do is we just tween that we say okay here's our our cam x is going to be here and chem y it's getting a little bit messy i apologize but our camera x and y are here and then over time we're going to tween that up into the next rooms x and y which is calculated it's just x plus adjacent offset x y plus adjacent offset y and then once once this camera has shifted from here up to here or whichever direction we're going whether it's up down left or right once we've completed that we can normalize everything again back to zero zero by doing uh self dot current room equals what's the what do we need to do if we're if we're gonna put everything back to and let's say let's say i want to make this this room the new current room what do i need to do so we have current room and we have next room if i want the current room to become the next room all i need to do is say self dot current room equals self dot next room right and then once that happens adjacent off what happens to the adjacent offset x and y of the next room they get set to zero right i want to take i want to take this room that we've offset up here and i just want to make it the center of the game world again i want to just put it at zero zero so we can do this exact same calculation by just setting adjacent offset x or y to a negative or positive screen height or screen width relative to zero zero so what i'm going to do is just set uh the adjacent offset of x and y of the next room which is now current room to zero and it's gonna draw it right back at zero zero and then camera x and camera y are also going to be set to zero zero and this is gonna have the effect of looking as if we're going up and staying there but in reality we're just going up and then instantly shifting everything back to zero zero including the player entities and switches of that room so it's purely an illusion but it allows us to simulate this sort of infinite exploring a dungeon effect does that make sense is the overall flow of how this works makes sense okay so it's a little bit messy there hopefully i was able to illustrate the overall algorithm for how the infinite dungeon generator works um where did we leave off on we were in oh yeah we were in the init function of the room so let's take a look at a few of the functions that comprise that so generate walls and floors this is very simple very similar to what we've looked at before with uh like tile maps in mario for example where we just go from y to x and then we just pick a random id or not random id well it is random id for some of it but sometimes we need an explicit id so uh remind me what does the id actually map to uh when we're you know drawing tiles to the screen if we want to give a tile an id what is that what should that map to yeah the frame in the sprite sheet that's correct um it doesn't have to for all game engines for all implementations but it's the easiest thing to do is just to give it your tile and id that you can then just draw you can index into your sprite sheet at that id it's just very very simple lightweight clean approach to modeling and we can see here id gets id after we've sort of figured out what id we want now how do we determine like let's say i want to draw let's say for example like this tile here notice it's a it's a corner tile how would i what do i need to do to basically assign i'm going to die before i even have the chance to uh to show you while i avoid enemies if i wanted to draw that top left corner uh what am i sort of looking for i still taking damage anyway relative to x and y what am i looking for what x and y does that does that tile need assuming everything starts 1 1 on the top left and goes down to height and width of the overall dungeon what does the xy need to be of that top left corner needs to be one right so if that's one one basically the top left corner that id should be equal to the corner sprite the top left corner sprite specifically what about the top right corner sprite what should the x be sorry yes width exactly what's the y still going to be one what about the bottom left width comma height and then the bottom right oh sorry bottom left should be one comma height bottom right should be width comma height and so basically checking the position of each tile is how we can infer its id which is what we're doing um in the source code here if x is one and y is one okay top left corner and notice that we've put these into constants that we've put into constants.lua just for readability so we can instantly see oh okay i should set id to tile top left corner not some arbitrary number that's our index into the tile sheet at like maybe like 40 something or whatever it is bottom left is one and height top right is width and one and then uh bottom right is width and height and we can sort it it's readable we can just sort of see at a glance what we're doing we're sort of conditionally generating all of our tiles um if none of those are true and then x is one what's what's that tile if x is one but it's not a corner it's a lefthand wall and the same thing if it's the width it's a righthand wall and if y is one it's a top wall if y is height it's a bottom wall and then if it's none of those it's got to be a floor exactly so that's that's basically how we generate the overall it's very it's a very easy simple generation algorithm what i've done is for randomization here we have a actually a table of potential left walls potential right walls potential top and bottom and then we just describe it a random value within there based on however large that is and that gives us variable we can see it it's it's we have random whoops every time i generate it so take note of maybe some of the tiles visually that you can see there on the map notice that they changed notice that the switch is also changed notice that they changed again so everything is variable we have a little bit of visual variety this is what we did essentially with mario we changed the tile set and the topper set only now we're just changing we have only one tile sheet but several variations of the same tile they're in so all we need to do is pick a random variation of whatever tile and that involves us looking at the sprite sheet picking out which individual tiles which separate tiles map to the specific type of tile and then just picking a random value from that table that's how that works so a couple things i think left to show relative to the dungeon generation so um 48 we have generate entities so entities are here we have their names right of the entities we saw skeletons bats slimes ghosts spiders it's a very lightweight function like it's not too it's like 15 or 20 lines but we're generating you know a bunch of different kinds of entities because what we've done we take we we basically take a random type from that table we create an entity and then using what we've defined in a global table called entitydefs we take out what sort of matters in terms of generating each individual entity the characteristics thereof and we just put it in simple data form this is sort of like the the segue into data driven design for your game if you look at entity defs here we can just see that all of our entities are a sequence of data so we have up here we have player right on line 10 player gets a table we give them walk speed we have a table of animations so he's got a walk left animation a walk right animation a walk down animation all of those have their frames their interval their texture everything's just clean data right there's no logic here really it's just flags or values simple things you could give this you could give anybody who has sort of the basic knowledge of what we're doing this file and what maybe some textures and say hey i want you to design i want you to lay out basically all of that that's involved and what makes a skeleton sort of rendered to the screen like give them like create all the animations for them give them the give us the give those animations their timing give them the exact frames maybe maybe skeleton should have health and maybe health should be equal to 10 on a skeleton or something like that there's not really any like programming going on here but we're describing everything in our game as data and that's important thing in complex games that have you know fairly complex systems but that can be modeled via some attributes you can just describe your entities and data and then let your engine parse this information and then create your entities programmatically you allow you sort of shift the burden from the programmer to the designer a little bit and you afford your design team you and maybe other people who aren't as comfortable with programming the ability to modify the game engine add things to the game without having to go through the bulk of your engine code and do anything too fancy in this case it's simple all we're doing is just we're creating animations and uh assigning a texture to each of these individual things but i alluded to this last week you could have a file that maybe describes something like a goblin we'll see this at the end of the lecture which has maybe like a flag for is it flammable how much health does it have what are its animations um what skills does it have uh what's its attack strength what's a defense where where does it spawn typically um by putting all these attributes together and having your engine sort of parse this you can create depending on how how many fields you have you can create a very complex uh like potential list of things in your game whether they're entities whether they're weapons whether they're items abilities anything you want to whether they're levels even based solely on just data so this is a holy grail of design and development when you get into especially very complex games like rpgs where you can have skills that are you know have particle effects and do different damage to different things and you have entities that are maybe you want them some to set on fire some to be electrocuted maybe some you don't maybe some uh melt when they touch something create a bunch of flags create a function that parses this and generates entities as a result and you just allow yourself an incredible boost in productivity no longer do you need to create a spider class a ghost class a bat class it's all unnecessary all you need to do is define what sort of attributes does a bat have what attributes does a ghost have what attributes does a skeleton have and anybody can therefore mod your game as a result of this all they need to do is know what attributes a potential entity can have and your design team is all the more productive as a result so that's a sort of spiel on why this is relevant we've implemented a very basic version of this just for the sake of modeling animations but we don't need a separate class for all the different entities in our game world we just need basically and in the context of this game what are their animations so that's entity deaths that's how it's working if we're looking at um room.lua at line 48 all it's doing is getting animations this is by the way your function that takes in these definitions and creates your entities they should be looking for looking into that they pull that definition and then just parse out each individual uh relevant piece of data and then just construct some relevant information or attach a relevant flag to that entity that your game engine can then later parse the flammable example if you do an attack and that attack is of type fire and it collides with an entity and that entity dot flammable is true that should trigger some behavior but you don't need to do anything terribly complex and you can assign this to any rel any arbitrary entity thereafter so just a simple way of getting very complex behavior for your game objects entities whatever you want modeling them as data rather than thinking about it in terms of classes so that's that does anybody have any questions as to like sort of how that works or how it's why it's viable or why it's useful okay a couple last things we'll look at really fast in room so on line 82 generate objects so we did this very very similarly last week where we just had a game object class notice that it takes itself a definition for a switch that definition is in gameobjects.lua switch here's a little bit more sort of data modeling something like a switch it's got its type is switch frame is two by default it's got a width and height of 16. it's not solid player can walk over it its default state is unpressed so when it gets spawned into the game it's unpressed and it's got two potential states unpressed and pressed and each of those states have a frame so all we need to do to render it is say what's its current state render the state dot frame and then now we don't need to do anything that's basically all we need to do in order to render it at the right point your game engine therefore needs to look at your object and look at its state and look at its potential states index into that state and then look at and then pull the frame from that but it affords you sort of infinite flexibility you can now have like uh i don't know glo maybe you have a glowing state and maybe there's a frame in that sprite sheet that allows it to glow and you could just change it to glowing whenever you want and it'll just render appropriately so very flexible approach to modeling data 149 in room so we're almost done with the dungeon here so 149 is our update function all it does basically is iterate through everything and update it including i uh basically all the entities so for every entity sort of if it's less than if it's health is less than or equal to zero it's dead if it's dead then don't render it which we see down in render but if it's not dead and self.player collides with it and the player is not invulnerable then we should damage the player go invulnerable and if the player's health is zero change to game over so notice how readable this is when you model your entities like this as well all you really need to do is just check for certain flags or functions and you can do arbitrarily complex tests like this because entities can be dead or not because entities can be invulnerable or not and then because entities are all xy with height based things in our game and collides just expects them to have that all we just do is play a sound damage the player all damage what what does damage do offhand what do we think it does exactly just take a wild guess and say it subtracts from health it does so self uh entity damage just takes in a number and subtracts that from health that's all it does go invulnerable what does that do prevents you from taking damage for that many seconds it does it takes you it prevents you from taking damage for that many seconds all but all that really does is just set a flag which i've alluded to quite a bit already an arbitrary flag that you can model via data or some other means every entity has an invulnerable flag and if it's invulnerable then the engine should look for that and change the rendering and the mechanics of that entity accordingly and then lastly here just simple if the player health is equal to zero which it might be after we take sufficient damage change to game over that's all it does and then for every object just as we do with every entity update the object and if the player collides with it then trigger its on collide function and this can be a function that you arbitrarily create depending on the needs of your object if we look up here for example every time we create a room we generate objects in the room we insert into objects a switch which we saw before in gameobjects.lua and takes an x and a y in this case we just make sure that the x and y is a random number between the top left of the map and the bottom right of the map within the padding that it has we get a reference to that object and then we define our on collide function so what we do is we say if it's unpressed so recall that we have a state in the game object definition if it's unpressed change it to pressed that's all we really need to do and then notice here for k doorway so for every doorway in doorways self.doorways set that doorway open is true and then play a door sound so our on collide function just interacts with other things in the game world and just very simple things but has a a pretty you know interesting sort of mechanic like we have a i took damage off the bat there because my spawning isn't perfect but it changed from notice that it changed its state from unpressed to pressed because it went from the one sprite to i'll go into another room so we can see that i'll take some damage on the way go to another room notice the sprite it sort of looks like it's unpressed right because the game object's default state is unpressed and then on collide triggers when i go on top of it it changes state which has an effect on what gets rendered and it's on collide function just called which opened up every doorway in the room so simple like 15 lines of code but pretty compelling interesting behavior for the sake of our dungeon like it's it adds a lot as simple as that is now we sort of feel like we're interacting with our game world a little bit so that's that's how that um sort of works and then lastly rendering on line 188 just go through all of our tiles render all the tiles we've seen this before render all the doorways render all the objects render all the entities if they're not dead right if they're dead then don't render them and then this bit here we'll take we'll take a look at at the end which is stenciling so notice that when i walk through doors well first of all notice that i can't walk through doors if they're closed which is important so when you collide with your doorway objects if doorway.open is false shouldn't trigger the broom switch right but if i open the doors they're now all set to recall door.open is now equal to true so they've changed their rendering so now they're they're rendering open doorways if i walk through it notice that it looks as if the player walks underneath the tiles but i'm drawing the tiles before the player and one approach that you might think to do when sort of creating this believable appearance of walking through a doorway is say okay i'll just render the player after i render the doorway or before i render the doorways right so render all the doorways last but it doesn't quite work out because the sprite actually starts right here so what what does somebody think is gonna happen if i were to draw the doorway uh after the player would disappear exactly the player would disappear as soon as he gets to this little bit of line right here which is not very convincing and actually i'll uh try right now to take away the stenciling so we can see what that looks like so if i just take away the stenciling here and then i just render whoops i can't type today so i'm going to go ahead do that well first of all the rendering order is such that now the doorways render after the player or before the player so he just walks right over them right so i'm just walking i'm just walking over the walls that's not compelling and if i were to do something as simple as change the rendering order so right now the doorways render first i'll just render the doorways after the player so right here took that out right no so right now they render before the player i want to render them after the player and i'm going to just run it and then going to step on the switch and then yep notice we get some weird behavior too um like sees heads getting cut off like that's and the other entities as well right in that case uh i couldn't really tell but yeah very weird rendering behavior and what we do to fix that is we create what's called a stencil so basically uh try and get a screenshot here i can i can show first let me fix the changes that i just made right and then if i go back into the code here so a stencil is just and we'll see a slide on this in a little bit but a stencil is just a basically any sort of arbitrary shape that you want that you draw onto the screen it's invisible but it determines whatever whatever gets drawn on top of that stencil it determines whether or not that thing gets rendered so i have a stencil going basically from here onwards to the next room so right about where the doorway hits the archway because that's where we want the player's head to look like it disappears stencil going here i have a stencil going right here and right here and on the right side as well and what that does is i've set the stencil to say whatever passes through this stencil during the sort of stencil testing period which is well all we do is we just draw the player during that time but basically if it's on the stencil don't render it and so what that has the effect of is we draw the we still draw the doorways before the player so the player walks in and he's drawn above this part but as soon as this as he hits the stencil he's not drawn it's just all those basically what it does is it draws the character to the stencil and not uh to the to the actual canvas and so we get convincing the sort of if you want sort of convincing layered weird visual effects like that stenciling is a is an approach okay and then that's all this is so this stencil function love.graphics.stencil takes in a function this is what's going to run during the actual stenciling process it's going to draw i draw four rectangles all those rectangles are just the um those arch ways right perfectly layered over them such that it goes into the next room and then we do notice that it says replace and then one so we replace any pixel that gets drawn to that stencil with the stencil value of one and then we only draw things that are less than one during the stencil test which means anything that didn't get ascribed to value of one which means that if the player went over the stencil got a pixel value of one that's going to be false he's not going to be drawn to the screen yeah question was if you have a stencil because you can do it with an arbitrary shape you could create lighting systems where some areas are dark and some areas are light i want to say possibly the thing is i'm not 100 sure whether stenciling allows you to do like whether love2ds stenciling allows you to do like arbitrary numbers of stuff like what i basically am not sure if it's on or off or a gradient typically if i were to do a lighting system like that i would probably draw like a faux lighting system one you can use a lighting kit like box 2d lights which a lot which does really compelling cool lights for you or sort of a cruder way to do it but possibly realistic would be to draw a shape that fits whatever you want to be your darkness um and then render it at an opacity that's less than 100 so like uh so you'd have like let's see have a room and let's say maybe like two like the sides of it are like kind of shadowy you draw like black rectangles there right but instead of drawing those black rectangles at 255 alpha you draw them at like 200 or 150 or something like that and so you can still see what's underneath them but it looks as if they are uh you know sort of a shadow and you can use gradient effects do the same thing if you want to like have a shadow that's darker going lighter um i believe you can draw rectangles with a gradient effect in left 2d i'd have to look into a little bit more but you would you would look to do something like that draw a gradient of shadow via some rectangle or some arbitrary shape to simulate lighting in that case and you could accomplish something similar to that and there are a lot of other crazy cool ways i've seen lighting done in 2d but that's probably offhand the simplest way that i could think of doing it cool um so that's stenciling and that's basically that's basically it for the dungeon generation which is arguably the most important part and also we we looked earlier at the sort of transition mechanic and we'll look at the transition mechanic a little bit more um in a little bit but let's take a five minute for right now and then uh come back to that and see some more stuff all right welcome back to lecture five legend of zelda so before the break we talked about a bunch of different things uh dungeon generation being foremost among them now we'll actually start talking about things like hitboxes and hurt boxes as we can see here on the screen so a hitbox is a rectangle basically that's how we've implemented it in the distro but we can see here there's a few different sort of rectangles overlapping we have the green rectangles here these are hurt boxes these are where you can get hurt and then this is a hitbox this is where you can hit something and so games like especially with fighting games and a lot of games of you know fairly complex interactions and complex entities that have weapons or particles things like that that all do damage you'll see a lot of sort of complicated overlapping and adjust or arrangement of these rectangles that sort of bring about how things interact with each other in terms of collision and doing damage and affecting other entities in this case he's doing like a an attack that goes uh from the left to the right it's a low attack only his foot essentially a little bit inwards but essentially his foot does damage whereas the rest of him is vulnerable like if someone were to come up to him from up above and attack him it would uh it would do some damage and there's minecraft and it shows you how the same sort of principle applies to 3d games as well in this case the what you see there are all hurt boxes those are all where things can get hurt even though those are a few of those things are items so that only really affects whether or not the player collides with them and picks them up but that's basically the difference between hitboxes and hurt boxes the distro i think i accidentally called the file hurtbox so when i push it up it's going to be renamed to hitbox because that's what we use it for but the uh what is offhand in the in this game what do we need a hitbox for yeah melee attacks from the sword and the reason that we need a hitbox for that is why yes and why can't we just use the player's position x y width and height because it has direction as well has a direction as well and also it needs that's that's essentially it's hurt box right so that's for those two reasons it has a direction that we need to uh sort of act as its reference point for generating a hitbox to inflict damage on other entities and we need to use the player's main hitbox that hurt box that already has to see if something hit it the player maybe from another side or something like that so let's go ahead and take a look here the main bit of code that deals with the hitbox in this case is one gonna be hurt box should be hitbox but we can see this is literally just a rectangle class x y width and a height self.x self.y self.with self.height equals all of those things that's all you need for for a pit box literally box just all you need are those uh fields and then you can do simply collides just like you do entity entity collides hurt box yes no true or false because recall collides expects x y width or height and it's defined in entity.lua so if we go up to the player states so recall last week we introduced the the idea of having the player maintain its own collection of states in a state machine as opposed to just the game world having a state machine that you know influences whether we're at the start screen the place playstate screen whatever we want to divide our game up into we have entity states as well now one of those is the so we have the idle and the walk state those are very similar to last week's where the with an idle state they're just standing still and walking state they're moving and then their animation changes accordingly the swing sword state is a new state and what this does is the player presses space bar it triggers this swing sword state there's a new animation so we go into the swing sword animation relative to which direction we're in and we get that direction and then we calculate the x y width and height of whatever our hurt box it should be hitbox is going to be for the sword when the sword hits something so that hitbox if it's facing to the left it's going to be 8 pixels wide by 16 tall which is roughly the left side of the player and then we just calculate the x and y depending on which position we're in it should be roughly centered based on whatever position the player's direction the player is looking at and so that we then instantiate that hurt box here we call it a self.sword hurt box and then all we really need to do is what in our game loop to check to see if we've hit an entity we just need to loop over the entities in our room the current room right here so every entity in the dungeon's current room dot entities if the entity collides with our sword hurt box sword hitbox then we saw this method before entity damage 1 and then hit enemy play that's as simple as it is and recall in room da lua if an entity's health dropped below one drop to zero it would just trigger it to become dead right and so that's all we need effectively and then um we have some additional logic to make sure that the animation only plays one time and then once it has played one time change its state to idle um and then we can press spacebar repeatedly within that same state just to keep swinging if we want to and it'll just restart the animation and restart the hitbox being instantiated and so that's all we really need to do for that now i have some lines of code here at the bottom of the swordswingstate.lua and playerswords swingswordstate and what these do is sometimes it's useful when you're programming to sort of see where your collision boxes are right because you don't necessarily know if everything's lined up perfectly you know when you're detecting collision between different entities you want to just check to see are the rectangles actually overlapping when this triggers so all you need to do in order to visually see this at a glance and you may have seen this before in other games or debug modes of games is just draw line rectangles and then just give them the xy width and height that you want to look at right so here i'm going to go ahead and save this um and then i'm going to run the i've basically uncommented it because by default i don't want it showing i don't want the they're pink rectangles i don't want them displayed on the screen unless i want to do debugging so i'm going to uncomment them down here notice it says the color to 2550255 that's magenta i'm going to run this turn it down a little bit nothing looks particularly different but when i swing my sword notice that there's a little rectangle and the rectangles aren't 100 perfect necessarily there they give the player a little bit of an advantage notice that like up above like his hitbox is barely anything up above in the in the actual animation but in the in the collision i give it quite a wide a wide berth and so that's how you can at a glance sort of see whether your things are interact or interacting appropriately there's lines of code that do the same thing for the other states the entity walking and idle states if you want to sort of look at those and see not only the players swinging the sword but also the other entities and the collision boxes they have and just to check whether or not they're overlapping appropriately or to change them or do whatever you want with them but that's a nice way to sometimes it's hard to debug collision if you can't see exactly what's going on because it's often just in terms of xy width and height and so on and so forth with offsets and such it can be kind of a pain and or sort of difficult to track down certain bugs that way so just draw it to the screen you can apply that same logic to a lot of things in your game world that you can vis that are maybe hidden but you want to see sort of visually just draw shapes or draw different things for them so you can see what's going on so that's how the hitbox and hertbox work for our player and you can easily just spawn more hitboxes for other entities if you want to if you wanted to give them states or maybe you want to create projectiles that are offensive maybe just create projectiles and then shoot projectiles in a specific direction but assign a hitbox to that projectile if you want to or just use the projectiles x y width and height and then you can calculate a collision that way just treat it like a game object or an entity it's up to you or a separate uh a separate class altogether but that's hitboxes and hurt boxes in a nutshell anybody have any questions as to how those sort of work okay cool so let's go on to the next topic so events so i spoke of this earlier events are just a nice way to sort of say when something happens do this block of code um and you can do this anywhere and you can decouple it sort of from like maybe two different objects interact with each other but you don't want them to sort of pass references back and forth between each other and to sort of bloat your code maybe you want the code for that check to happen not inside your main loop you want to sort of abstract it out to some sort of other function like instantiate events and then have your main rendering and update logic be sort of free of all this conditional stuff so you create an event you say on some event so maybe like on player walk and then you just update some maybe a label on the top right of the screen that gives the players x y and you just say that x y is equal to that player's x y i mean aside from the fact that you could just literally draw the players x y but it's the same principle you can update some value somewhere separate from another entity and then just wait for an event arbitrarily defined event um that you then broadcast later so let's say i want to broadcast swing sword i have a swing sword event so whenever the player presses space not only do they do all the code that we saw before but they swing sword and then we say when you swing sword pass in the x y of wherever they swung the sword and so then you can say okay on swing sword look at all the entities and see whether or not the hitbox that xy collides with them and you can sort of take out the logic from where you had it before and put it in some other centralized location if you want to more sort of uh representative i think of this model is the idea of an achievement system where instead of every frame and you can have you know games have like a ridiculous number of achievements some games have like a thousand achievements you don't want to put the test for every one of those 1000 achievements necessarily inside of your like update logic right you can instead just broadcast an event for all of the different things that influence whether those achievements are met so whether player needs to get 100 kills in a game or 100 coins whether they need to like jump off some ledge you just have events that model all these interactions event on pick up coin do this increment some time some counter that's stored somewhere else and event dot on kill creature right where kill creature triggers every time you literally a creature is set from dead dead as false to death is true maybe whenever the player jumps you do a on jump function and then you can test to see whether or not in that code you can test to see whether they jumped off that ledge and then if that happens you have your achievement system but you don't have all these if statements and all these tests happening inside your your sort of imperative game loop you can just sort of like pseudo asynchronously check for all of them um given a sufficiently detailed event system in your game and so the library that we'll use just to show this a little bit is in the knife library that we saw before with timer timer.ontimer.everytimer.tween in the knife library there's a sub module called event which allows you to call event dot on give it a name and a function so on player jump off player jump you know function if player.position is you know by some cliff or some area that's relevant then call this block of code increment you know or set the achievement to true event.dispatch dispatch an event when something happens so if player jumps so if you press the spacebar event dot dispatch jump and then just whatever values that your callback function needs like let's say you want to check to see whether it's on the cliff well if you want to check to see whether they've jumped off that specific cliff you're gonna need to check their xy position presumably so you can just pass in optional parameters via event.dispatch you can say okay dispatch the event that the player jumped and say that the player jumped at xy and so this function callback is going to have access to that xy it's going to say okay on jump i see i got i'm getting my callback called with player.x player.y and it happens to oh it's not at the cliff so nothing happens or it is the cliff so the achievement jump off cliff unlocked is true and this test now is not happening every single frame which otherwise would potentially and it's not blocking up your update logic for your player jumping right the player the jumping logic inside player the player jump state doesn't need to know doesn't need to ask whether or not we've jumped off a cliff that's something that we should just delegate to our achievement file or whatever you want and that's sort of the flexibility that events afford you so we use event i'll touch on this a little bit briefly here but basically if we go to the player walk state online uh 21.39 first of all we're checking for input here right we're just saying if if we press left right up or down the direction is that walk left walk right so on and so forth um and then if and then what we do is we call entitywalkstate.update so this base walk state code that exists in entity so that we can let every single entity have this code all it does is just to check to see whether or not the player or entity that it belongs to hit a wall and if it did then set their bumped equals true and that what all that does is just a flag that says okay the player bumped a wall okay why is that relevant because then after we call that we can say okay if we bump the wall and this only happens in the player walk state if we're looking to the left temporarily adjust our position because when you when it bumps you it like knocks you back out back into the world but we're going to rebump our position in to wherever we collided we're going to look at every doorway and then we're going to say if we collided with that doorway and it's open then uh we're going to shift it to the center of the doorway so that it doesn't look as if the player is walking through the wall we're going to set it to like wherever the wall is or wherever the door is the very center of the doorway and then we're going to call event.dispatch shift and then that direction so shift left shift right shift up and shift down and so all of these these four different cases are going to say okay the player has hit a doorway i have a function somewhere event dot on shift down shift left shift right shift up that's going to trigger what the next room it's going to trigger us moving to the next room and also the next room spawning and the camera sort of shifting position um so the code for this is in dungeon so we're going to go ahead and look at dungeon so right here on line 2943 event dot on shift left shift right shift up shift down and what that does is we have another function called begin shifting which takes in an x and a y negative virtual width virtual width negative virtual height virtual height does anybody recall why we need to pass those numbers in there if we're shifting left and we're passing a negative virtual width what do you think that number is going to be so recall every room has an adjacent offset x and a y that renders that room with that offset basically added to it it's x and a y so if we begin shifting to the left negative virtual width is going to be the x offset because that room needs to needs to be rendered a screen width to the left right and so on for the right virtual width it adds virtual width to the x offset the adjacent x offset and then virtual height negative and positive for shift up and shift down so begin shifting basically uh it's the gist of this is it's a tween operation so we start here recall timer.tween just takes a value and interpolates it so self we have a camera x and a camera y right going to equal shift x and shift y eventually so shift x and shift y being the adjacent offset that we're going to need to shift the camera by so camera x and camera y are they both start at zero always when the room gets completely finalized so if we if the shift x is virtual width negative virtual width because we're shifting left then it's going to tween the camera going from right to left over the span of a second right and then the player the player x and player y those are basically set up here to the opposite end of the room the next room so if the player is going from the top of the room to the bottom of the next room it needs to get its uh x and y put in that position the bottom part of the next room or the left part the left part of the next room if they're moving from the right right or the right part if they're moving from the left and the bottom part if they're moving up and up part if they're moving down so that's what that does puts them in the right position on the next room tweens both of them the camera and the player because the player needs to keep moving to the next room and the camera needs to shift up um when it's finished we call finish shifting which is just a function that sets basically everything to zero it says the current room to the next room it sets the camera x and all that stuff all to zero and then all the entities and objects there and all get set to zero so we are they're offset to zero so that everything is basically right at zero zero again just like it was at the very beginning um and then last but not least when we get into the new room we start with the doors all open and then when we get into the net and into the room here because this is all done in the finish function recall this will only happen after the tween is completed uh every doorway is going to get set to false open equals false so all the doors will close as soon as we get into the next room after we perform the tween operation and then we'll play a door sound so that's that's the code involved in actually doing the shift operation so we're able to trigger it we don't have to necessarily do that code from the player walk state we just say you know if the players collided with the doorway then dispatch an event that is handled by dungeon because dungeon has access to current room uh next room and all the stuff that it needs to actually perform that transition so we have the two that are sort of decoupled but they work well in tandem with one another so anybody have questions this is sort of how this works okay that's the that's essentially the dungeon scrolling just it's a tween operation it's a camera a temporary room gets rendered we move to the temporary room everything gets set back to zero and then it's just a it's a while loop of that sort of behavior effectively and we use the event library to sort of clean up that whole aspect and sort of uh screen scrolling here just another demonstration we went over it in detail but this is a nice gift i found that sort of encapsulate what that means stenciling is something that we saw earlier and if we look at this as a stencil so uh these we can pretend that these are the circle the heart and that rectangle are a stencil and then we want to draw this gray rectangle on top of those stencils we can use the stencil to mask out specific parts which which would otherwise be pretty tough to do i mean it's hard to necessarily like maybe individually render pixels or create a shape that sort of looks like this much easier for a lot of very interesting visual effects just use a stencil of arbitrary shape and size and you can use images too you can use images as stencils to create some pretty cool effects we went over it before when i talked about the archways so i won't go over in too much more detail but again you can look at that in the where was it exactly it was in the room function room class sorry down here at the bottom so lines 213 to 229 recall they're a stencil function the couple functions in in particular that you need to use are love.graphics.stencil which draws the stencils and then love.graphics.set stencil test which compares the stencil values to some value and draws them whether or not that condition is true so we have uh our function here which draws four rectangles those are all the archways it replaces any pixels that get drawn to those rectangles with the value one the stencil value one so stencil value is just like a hidden value that determines whether stencils get whether a image will get drawn if it's being stenciled or not set stencil test means that we're looking for anything less than one and we'll draw that and because the player is going to be one if it's on any of those uh stencil rectangles uh it will not draw the player if it overlaps with those stencil rectangles and so that's just that's in general how it works and you can do there's a lot of different comparisons you can do greater than one you can do iterative stenciling uh so that you can increment a value it could you can have stencil values go between one and zero and 255. there's a lot of interesting effects you can get with that but the general use that we just saw is you know set the values to one and then check to see whether they're less than one if you want to draw them if you want to not draw them does anybody have questions as to like how stenciling works and how these functions work yeah it's like having that stencil cover up the door the top of the doorway so when you drop it there like you want actually drawn yes so the it's like having the uh the stencil rectangles go over the doorway so that the player will not get drawn when it's underneath them the um i'll go back to a slide that has it the stencils are here right right i had to go through and figure out the exact xy that i needed for them and there is a you can what you can do is you can take that stencil function that draws the rectangles and then you can just like take it out of the stencil test and see you'll you'll actually be able to see where the exact rectangles are because then it'll just literally draw the rectangles um but here basically right over right between here and where it would be on the next room so that when we go from here over into the next room it still stencils them right here the player is gonna go over them it's gonna set its stencil value to one it's checking for anything less than less than one um to to render so it's gonna fail the test and it's going to uh not draw that player at that point so effectively just masking out the player because we're assigning it to the right stencil value or doing the right comparison for it but yeah that's effectively it just using it to because we were in a situation where our tiles didn't cleanly lend themselves to drawing over the player which you could do you could draw the shadow part underneath the archway part and then just change the rendering order but the sprite sheet that we had didn't afford us that flexibility so we went through with a little more interesting stenciling approach to getting it done um we looked at this earlier so game design via data rather than you know a bunch of logic so the more you can sort of get towards modeling your anything in your game like data like this the more flexible your engine is the easier it is for people to mod your game which is hugely important and the easier it is for you to let designers take charge of actually creating assets for your game so here we've created an arbitrary collection of data and you could get as complex with this as you want to the only thing that really matters is whether your game engine supports those fields and acts on those fields accordingly but once it does i mean the more things you add the more possibilities you have for adding new things so goblin we have health strength so strength should be accounted for in our game engine and this is we're talking in just the general abstract sense now let's say we're like making an rpg or something or maybe maybe maybe this is part of our zelda game if we got a little bit more detailed with it but goblin is going to be a creature that has 10 health it's got two strengths so these values will get loaded when it's created as an entity and strength is some value that our engine needs to apply to anything that it decides to attack right you can do the same thing with defense you could create arbitrary things it's got a goblin texture so that's the sprite we've defined some animations here which you've already seen how to instantiate those in our game engine maybe it starts off with a club weapon um and you could also reference other sort of uh lua files that have these definitions if you have maybe a weapons defs file you could index it into weapons def's club and then that club item will maybe have a bunch of its own characteristics that when your game engine is loading this goblin death it loads in the club def as well and instantiates a bunch of qualities onto that entity or that item that then have behavior relevant to your game engine um aggressive is true so if something's a dot you know entity dot aggressive then maybe it's a i will seek out the player right and you can set that to false so now you can differentiate between entities that chase the player and entities that are sort of docile and just do their own random thing uh sleeps at night maybe your game has a day night cycle maybe some entities stay awake and some go into a sleep state right so it'll look and say oh okay it's night time does the entity dot sleeps at night if it does okay then entity change state sleep right and then during the day phase when the day happens you'll do the same thing in reverse you'll say if that entity that sleeps at night uh then you'll say entity not awake is true or whatever it is um change state awake or idle or walking and inflammable maybe you have weapons that shoot damage or shoot fire or maybe you have torches that shoot fire or some maybe you're in a level that's like lava and you know if you get touched the one of the tiles it has a flammable effect and if it's flammable maybe your status equals flammable you take damage over time and you change your animation maybe you get tinted red or something like that but thinking about all these different possibilities and like what your engine is capable of you can create pretty much arbitrarily complex data structures and entities and items and whatever you want in your game without having to create a goblin class or a skeleton class or a arbitrarily complex creature class you just compose your creature with attributes and model its behavior that way composition over inheritance which we talked about last week it's very valuable in game design and that's what unity's game engine sort of approaches because entity is a purely entity component system whereby entities are modeled as collections of components that each do something and we can sort of almost think of these as components too albeit a much simpler sort of representation does anybody have questions as to this or like why it's useful or anything like that okay so the last thing i wanted to talk about today um and i saw uh i think one or two students were mentioning how they wish they knew or wish we talked about a little bit more how programming was done back in the day so i'm not an expert necessarily in sort of programming you know 6502 assembly which is what the nes has written in there are a lot of people that are very good at it but there's a few links here so in the slides if you wanted to look at the slides on the website homebrew is actually quite a popular thing amongst certain communities online and what it is is essentially getting compilers that will compile source code for some arbitrary processor or you know development environment from some arbitrary computer system like the nes which was a 8bit microprocessor based machine with its own set of interesting hardware it allows you to compile the assembly for that and actually run it via a program called an emulator an emulator just allows you to run rom images or you know just arbitrary data that maps to the machine instructions of some system that the emulator has emulated via a virtual machine and so if you wanted to look at look into it a little bit more in detail the there's a couple links here so nes dev wiki's got a bunch of great links um there's a programming guide that kind of goes over the basics of how to do some 6502 assembly as well as with the nes and its particular hardware and then the compiler that most people use for this is called cc65 which is a 6502 assembly compiler and so this is an example of some source code it's a little bit tough to read but uh i can't zoom in i don't think but the gist of it is you have a lot of in here i can actually pull it up online uh let me try um super mario disassembly so we go here this is on github so somebody decompiled basically or disassembled rather take took the bytes that represent all the machine code and the rom image of super mario brothers and then just converted it back to assembly language and then added comments to it because uh i won't go into too much detail about what assembly is and how it works but essentially it's just a layer directly above machine code where keywords map to essentially what are bytes in memory that are actually program instructions and that influence the behavior of your cpu such that you get programs and that's what c is layered on top of and then every uh language thereof thereafter so if i zoom in here see if i can just being a little slow but it's letting me so here we can see for some reason i think it's lagging because the file is just so large it's like 14 000 lines of code because this thing about assembly is assembly is very very long because there are so many and you need to have just like really slowly zooming in infinitely there are just uh so many steps you need to do in order to achieve the same thing that you get in a high level language like c or or even languages higher than that taking a lot of things for granted especially things like you know loading registers so every cpu has got a series of registers that can store values and then the cpu has logic that knows that you can basically say okay if the value in register a is greater than or equal to some value then branch to this sequence of the assembly code and you often you'll have to do things like and or operations on byte level uh you know just on bytes like right here we can see we're ending uh the value three on uh whatever is in register a like i said not don't intend to get too much into what assembly is but for those curious as to how games were implemented in the 80s and even the early 90s it was all an assembly language because assembly language is you're literally programming the the cpu of whatever machine you're trying to program and that's how you get as much efficiency as possible if you know your computing environment you know what your cpu is capable of the thing about compiling a language like c or c plus or java which is even higher of an abstraction than those is you're allowing sort of algorithms to do the work for you you're allowing algorithms to take your source code and turn it into this basically well a layer lower than this effectively this is an intermediary level that it does generate but suffice to say in the 80s and 90s c compilers were not as good as humans were in creating games especially to do a lot of the tricky things that they needed to do in order to get them working efficiently on processors that were at the time one to three megahertz in speed which now we have like three gigahertz processors and it's no big deal but that is effectively that's that's sort of a window into what it was like developing games in the 80s and 90s and then in the 90s with like things like the n64 playstation 1 going on to playstation 2 and so forth um it was typically done in a language like c or c plus sometimes with some variants um certain consoles like the ps3 has a notoriously difficult graphics processor to program so a lot of ps3 teams needed to program in assembly even you know at the time which was 2007 2009 but that's in a nutshell what it's like programming the 6502 so if you want those things uh those links up above it's a pretty enlightening experience actually digging into that sort of thing and trying to make sense of what the assembly does um it's quite difficult and quite uh it's quite burdensome because of how long these programs are and just how minut each individual instruction is like just checking just loading a value into a register uh just to you know do a loop often will just be iteratively loading a value into a register and then like performing some operation or calculation off of that and then branching to some other loop of code a lot of that can be condensed into like just a couple lines of c or even fewer lines of lua so a lot more of a burden but there is insight definitely some insight into digging a little deeper in sort of looking there so once again those are the links on the nes dev wiki wiki.nesdev.com if you're interested in looking at that in assignment 5 you will like you did an assignment 4 you can create a game object that's consumable and feel free to use code from assignment 4 to do this when like you define your on consume function uh if you're going to adopt the same model as the last assignment then any ideas is what we need to do probably just add uh you know the opposite of damage the entity right we want to add hearts we want to add hp to it um and you'll see in the distro that health is modeled as uh an even number because every one digit is half a heart yeah you can and it'll uh that'll effectively be the same thing too so uh the second part is including pots so there are pots in the sprite sheet so they should these should be solid so when the player interacts with them he should be bumped out uh of where he was uh allow the player to lift them so there's an animation in the sprite sheet that'll actually allow that shows the player lifting up the pot so you probably need a new state player lift pot state walk with pot state whatever you want to define it as but you'll need uh basically to have those two in order to get this to work what's one thing that we'll need to do in order for the player to lift the pot any ideas besides the rendering aspect of it when the player walks around for example what needs to happen if he's holding the pot you could make him slower yeah that's possible that's not it's not required for the assignment more fundamental than that the pod needs to track the player's location right it needs to be relative to the player's location so keep the pot probably above the player to some by some amount um i won't be too picky as to how you implement that but the pot needs to track the player which is this next point actually and the walking animations like i said should change while they're carrying it allow the player lastly to throw the pot so when you throw the pot basically turn the pot into a projectile if it hits one of the walls break it you can either just despawn it instantly or have some animation it's up to you but just if it hits a wall despawn it trigger it to maybe just trigger it to some value is false render is false whatever you want to do if it hits an enemy it should damage the enemy by one just like we've seen already and if it travels farther than four tiles in addition to also hitting one of the walls then destroy it too so those are the main components for assignment five and the ways that which you achieve most of it's fairly flexible but yeah that's assignment five or uh lecture five legend of zelda so thanks for coming i'll see you next time
