With timestamps:

00:00 - [Music]
00:16 - all right welcome to
00:18 - gd50 this is lecture 10. today we'll be
00:21 - talking about portal so uh portal's a
00:23 - very iconic game i think most of us have
00:25 - probably seen it before the gist is you
00:27 - have a portal gun a gun that shoots
00:29 - just these elliptical portals
00:32 - if you look through one you can
00:34 - effectively see what's sort of coming
00:35 - out the other one which is pretty cool
00:36 - and vice versa and then if you walk in
00:38 - between the portals you'll actually be
00:40 - teleported to the other side and so they
00:42 - achieve a lot of really interesting
00:43 - effects with some pretty cool um tricks
00:46 - and stuff and actually valve themselves
00:48 - will be coming to
00:49 - give a talk on a lot of the technology
00:51 - that they used um on the second so we
00:53 - can get a glimpse into their version of
00:55 - portal my version of portal is a bit
00:57 - simpler
00:58 - but we'll look at a lot of the same sort
01:00 - of principles and see how i accomplished
01:02 - a lot of the same things
01:03 - so this is also the last lecture of the
01:06 - semester and we've covered a lot of
01:07 - ground i have a few screenshots here to
01:09 - show some of the games that we've talked
01:11 - about you know the very first game was
01:14 - pong and we've come sort of a long way
01:15 - we've gone through um very simple sort
01:18 - of arcadey atari-like games like this
01:20 - and you know have gone and created
01:21 - worlds effectively and you know now
01:23 - we're in 3d we're doing all kinds of
01:25 - awesome stuff but these this is where we
01:26 - started the course um and it's kind of
01:29 - fun to look back and see where we've
01:30 - come so you know here we talked about
01:32 - scoring and just effectively drawing
01:34 - shapes onto the screen then we
01:35 - transitioned to flappy bird or 50 bird
01:37 - and you know we had sprites and
01:39 - characters and we talked about scrolling
01:41 - and infinite level procedural generation
01:44 - type algorithms and that was fun
01:46 - um we took things a step higher than
01:48 - that with breakout where we had the same
01:50 - sort of procedural ideas in the context
01:52 - of a very famous arcade game we talked
01:55 - about particle systems and um some
01:57 - arcade style physics and high scores
01:59 - then we went into puzzle games we talked
02:01 - about match three and how to actually
02:02 - calculate what goes on uh uh to
02:05 - determine whether we've gotten a match
02:06 - and how to clear blocks and how to tween
02:08 - things do operations over time so this
02:11 - asynchronicity
02:13 - um then we went into probably what is my
02:15 - favorite lecture which was super mario
02:16 - brothers and we talked about how to
02:17 - create procedural worlds that all look
02:20 - very different with some very simple
02:21 - algorithms and then we had triggers and
02:24 - um events sort of happening then legend
02:26 - of zelda came and we had this infinite
02:28 - dungeon algorithm and we had enemies
02:30 - walking around that we could use a sword
02:32 - on so it felt more like an actual action
02:34 - game action rpg
02:36 - then we took a look a brief look at
02:38 - physics in the context of box 2d with
02:40 - angry birds and i still remember the
02:42 - like ball pit example was probably my
02:43 - favorite part of that
02:45 - and then um probably the most
02:46 - complicated example of the semester was
02:48 - pokemon where we actually had a full a
02:50 - semi-full turn-based battle system and
02:54 - random encounters and like a little
02:56 - world where there's actually two main
02:58 - stages to our world where there was the
03:00 - field and the battle scene which is a
03:02 - very common thing to have in rpgs
03:05 - following pokemon which was the most
03:07 - complicated code base we went into unity
03:09 - which was our first foray into 3d and
03:11 - even though we were just exploring 2.5 d
03:14 - we still got a chance to look at you
03:15 - know how does the unity engine work and
03:17 - how do we get actual 3d models onto the
03:18 - screen and we put together a very simple
03:21 - flappy bird-esque game so that we can
03:23 - sort of recycle prior ideas
03:25 - last week we looked at dread50 which was
03:27 - sort of a dread halls horror inspired
03:29 - game where we got to look at lighting
03:31 - and how to actually transition between
03:33 - scenes and use some basic ui in unity
03:36 - and today we'll be talking about how to
03:38 - use how to create a game similar to this
03:41 - although much simpler today is mostly
03:43 - just a tech demo more than anything else
03:44 - but this is a screenshot of the actual
03:46 - game portal and as you can see they do a
03:48 - lot of really cool fancy things they
03:50 - have a portal on sort of a slope they
03:52 - have another portal coming out of the
03:53 - front wall or back there different
03:55 - colors so you can differentiate between
03:57 - left and right orange and blue
03:59 - they have
04:00 - sort of this object here on the side and
04:02 - i believe that's to shoot
04:04 - cubes out which this here is a cube
04:06 - which you can then grab with your gun
04:07 - and then shoot it through portals and
04:09 - see it come in and out of portals which
04:10 - is pretty cool
04:12 - and we'll talk today about how to create
04:14 - sort of a simple version of this
04:16 - primarily just the aspect of how do i
04:18 - create a portal that looks out of
04:19 - another scene and see it updating in
04:21 - real time um and how do i teleport and
04:24 - get back back and forth between the
04:25 - portals and carry a weapon and then
04:27 - shoot a ray that'll actually place a
04:29 - portal where i want to in the game world
04:31 - so today some of the topics we'll talk
04:32 - about so one holding a weapon so we've
04:35 - had we've used a first person controller
04:36 - and this is a very easy and simple thing
04:38 - to do but it helps illustrate what
04:40 - parenting is and so we'll talk about
04:41 - that ray casting is the actual shooting
04:43 - out of ray from your object's z
04:45 - direction forward so you have an x and a
04:48 - y which are sort of the angle at which
04:49 - you're moving around but then you have z
04:51 - which is always
04:52 - if you're using vector of using the
04:54 - forward vector from your character it's
04:57 - going to be forward from the in the z
04:58 - axis wherever you're looking effectively
05:00 - and so that allows us to um we can cast
05:03 - a ray in that in that sense which just
05:05 - means you know shoot a straight line an
05:06 - invisible straight line from that point
05:08 - and wherever that point intersects with
05:10 - an object we can get some information
05:11 - about that and then do whatever work we
05:13 - need to do in this case take a portal
05:15 - prefab and just like affix it to the
05:17 - wall basically rotate it from its
05:19 - default position and then just like put
05:20 - it flat up against a wall
05:22 - texture mask masking is uh sort of how
05:26 - we're going to achieve this portal
05:28 - effect right because when we when we
05:30 - create what's called a render texture in
05:32 - unity which here's the third bullet a
05:34 - render texture just means a texture that
05:36 - we are rendering to with a camera so
05:39 - rather than have a texture be an asset
05:40 - in your game in your hierarchy with
05:42 - something that you've made in photoshop
05:44 - you can actually dynamically create it
05:45 - at runtime with a camera
05:47 - what the camera is seeing and unity
05:49 - gives this to you for free very easily
05:50 - with what's called a render texture
05:52 - which is just another asset type
05:54 - and then texture masking is effectively
05:56 - sort of kind of the same thing as
05:57 - stenciling where we can choose certain
06:00 - pixels of an object to delete in this
06:03 - case we create a texture that's white in
06:05 - the center and then black around the
06:07 - edges in a sort of elliptical shape and
06:10 - what that allows us to do is tell it
06:11 - with a simple shader
06:13 - don't render these pixels when you
06:15 - actually render the render texture just
06:17 - render the ones in the middle and so
06:18 - that's how we achieve an ellipse just by
06:20 - effectively discarding the pixels on the
06:22 - outer rim
06:23 - decals uh are is an idea in 3d games
06:27 - where a decal is just something that you
06:28 - have fixed a texture or some object that
06:30 - you fixed to a surface in this case
06:32 - we'll be using decals um to act as our
06:34 - portal so our portals are actually just
06:36 - going to be decals they're just meshes
06:37 - with a render texture affixed to them
06:39 - and then all we need to do is just sort
06:41 - of slap them onto a wall whenever we
06:43 - shoot it and we get a ray that
06:44 - intersects with the wall and that'll
06:46 - have the effect of um actually making it
06:50 - look like we're putting a portal on a
06:51 - wall when in reality we're just taking a
06:52 - mesh and we're just kind of like
06:53 - slapping it onto a wall some other
06:55 - examples of decals that you've probably
06:57 - seen in other games are for example
06:59 - bullet holes which use the same
07:00 - principle
07:02 - teleporting is very easy although the
07:03 - fps controller sort of complicates
07:05 - things a little bit so we'll talk about
07:06 - how i went about sort of solving it sort
07:09 - of solving the problem of teleporting in
07:11 - a way that makes sense
07:13 - it's usually just as simple as a change
07:15 - on the you know setting something's
07:17 - transform's position to another
07:18 - transforms position setting the rotation
07:20 - to the transform's rotation um but the
07:23 - fps controller caches its rotation data
07:26 - so in order to do that teleport cleanly
07:27 - you sort of have to override some
07:28 - default behavior and lastly we'll take a
07:30 - look at some new tools that unity has
07:32 - introduced with 2018.1 pro builder and
07:35 - pro grids which allow you to actually
07:36 - model geometry in the scene and this is
07:39 - what the assignment is going to be
07:40 - focused on um because going forward it's
07:43 - probably i foresee it being a major part
07:45 - of sort of modern unity development and
07:48 - or prototyping
07:49 - the ability to model your scene in unity
07:52 - without needing a third party program
07:54 - heavily optimizes the actual creation
07:56 - process and allows you to do easy what's
07:59 - called gray boxing meaning create a
08:01 - level for like you know to create a
08:03 - level in your game engine and then
08:04 - prototype it test it make sure that it's
08:06 - actually game playable right off the bat
08:08 - that's called grey boxing
08:10 - but first let's get a demo so does
08:11 - anybody want to come up here and play my
08:13 - implementation of portal
08:21 - mr james is landlocked
08:25 - all right james you're not landlocked
08:26 - let's go
08:31 - all right so i'm going to go ahead and
08:33 - set that up
08:37 - and so disclaimer there's actually a bug
08:39 - in this as well so i'm curious to see if
08:40 - you can spot what the bug is
08:43 - go ahead and hit play as soon as you're
08:44 - ready
08:46 - and then the mouse on the right will be
08:48 - your sort of angle of your portal
08:50 - so we see here i have a
08:52 - character with a portal gun created so
08:54 - if james if you shoot a wall with the
08:56 - left mouse that'll create a portal and
08:58 - then they've used the right mouse so
09:01 - that's one other bug
09:04 - so let's go ahead and restart the
09:05 - program actually um
09:09 - so that's one bug
09:12 - and so
09:14 - um if we avoid stepping into a portal
09:16 - that's there and this this could be
09:18 - fixed in a couple of ways
09:21 - so now you have a so okay so now you
09:22 - have two portals basically created
09:25 - do you see what's wrong with the the
09:27 - portal as it is here
09:29 - are both of these portals actually
09:35 - oh actually no i'm sorry these portals
09:36 - are actually completely right but walk
09:38 - through them
09:39 - and i will show you
09:41 - okay so you can see it works it works
09:42 - pretty well right you you can not only
09:44 - see your character rendering completely
09:46 - or moving in real time when the other
09:48 - texture
09:50 - but you can you can jump through them or
09:52 - walk through them you can jump with
09:53 - space bar if you want and that will
09:54 - teleport you out the other end so you
09:56 - see from the perspective of the other
09:57 - portal but if we try shooting one of the
09:59 - other walls for instance like the one of
10:01 - these white walls
10:03 - you can see something weird happens with
10:05 - this particular wall anything strike you
10:08 - as odd about that portal
10:10 - anybody it's upside down
10:12 - and so if you walk through it though
10:16 - it works perfectly fine now the reason
10:18 - that it's upside down um i spent
10:20 - probably like 10 15 hours trying to
10:22 - debug why this is it's in a state of
10:23 - what's called gimbal lock so this prefab
10:27 - right here there's three axes of
10:28 - rotation in 3d space and if you perform
10:31 - a rotation in some odd way
10:34 - um
10:35 - there are these things called euler
10:36 - angles which are your angles of rotation
10:39 - about the x y and z axis and you can
10:41 - sort of think of it think of them as
10:43 - sort of being able to rotate and
10:44 - interdependently but
10:47 - there is a situation in which you can
10:49 - for some reason unity's internal
10:51 - representation of a rotation can get
10:53 - messed up by manipulating these angles
10:55 - and so you can actually lock two axes
10:57 - together such that um
11:00 - rotating like for example in this case
11:01 - it's z and y they both rotate each other
11:04 - and so you're unable to get in this
11:06 - particular case the um portal to rotate
11:09 - about the axis that lets it like
11:12 - look like it's right side up based on
11:13 - the walls surface normal and so
11:16 - um
11:17 - had i maybe another week it probably
11:18 - could have debugged it but i had to
11:19 - leave it in unfortunately i ran out of
11:21 - time but
11:23 - if you don't
11:24 - the interesting thing is if you do shoot
11:26 - that same wall so try and shoot that
11:27 - wall the other wall with the like put
11:30 - both
11:30 - put one portal on the on the buggy wall
11:32 - so the right wall it's only that wall by
11:34 - the way for some reason so um that wall
11:37 - is a bit so notice that now it's right
11:39 - side up so if you shoot both portals on
11:41 - the same wall that buggy wall they do
11:43 - get right side up and i for the life of
11:45 - me couldn't ascertain exactly as to why
11:47 - i know it's gimbal lock
11:49 - unfortunately i was unable to debug it
11:51 - quite in time but every other wall
11:53 - including the ceiling and the floor will
11:54 - work if you shoot a portal up on them so
11:56 - you can create one up there and then you
11:58 - can jump through it see how it's looking
11:59 - down and it'll sort of put you at the
12:02 - top
12:03 - and
12:04 - all together minus the weird single wall
12:07 - that gimbal locks the portal we have a
12:09 - pretty functional implementation of a
12:11 - very basic portal game right we have a
12:14 - this model here is parented to the
12:16 - camera so it's always going to look in
12:18 - the exact same direction as the camera
12:19 - we shoot a ray from
12:21 - the tip of the gun
12:23 - and then whenever that ray intersects
12:25 - with a plane in this case any of these
12:26 - walls we get the information about the
12:28 - intersection and we flip the
12:31 - decal the
12:33 - portal decal such that it's
12:35 - the same angle as the wall rotation
12:38 - and then what happens when we actually
12:40 - collide with one of the portals just in
12:43 - code if we were to think about how to
12:44 - implement like the behavior that goes on
12:46 - here
12:48 - it's transporting the player and it's
12:49 - doing effectively setting the player's
12:52 - transform position to the same transform
12:54 - position as
12:55 - the portal
12:56 - now if we do the same thing on the
12:58 - rotation
12:59 - the player ends up getting a bits the
13:02 - fps controller's rotation gets a bit
13:03 - skewed if you mess with its x and z
13:06 - rotation the default controller
13:09 - so all we do for now is we just
13:11 - we keep those values the x and y
13:13 - rotation but we just change the y
13:14 - rotation y rotation is this position in
13:18 - space like this effectively so that
13:20 - allows us to get when we jump out of the
13:21 - wall we notice that he's you know sort
13:23 - of like flat from it but if we jump
13:25 - through any of the wall portals so if
13:26 - you like create a portal on the wall
13:28 - here and then jump through it
13:31 - you'll notice that you sort of get a you
13:33 - know you're sort of angled at the right
13:34 - um
13:36 - and the reason that it's skewed is
13:37 - because this one's upside down and so it
13:39 - flips it's flipping the camera that's
13:41 - rendering the texture and it's looking a
13:43 - little bit weird but when you jump
13:44 - through
13:45 - um
13:46 - it
13:47 - basically keeps your x and z but rotates
13:49 - your y position such that you come out
13:51 - looking as if you went straight through
13:52 - the portal rather than um by default it
13:55 - has you look like a look back at the
13:57 - portal that you came out of which is a
13:58 - bit weird or whatever direction you were
14:00 - walking through it when you went through
14:01 - the portal
14:03 - um
14:07 - that's just default so it's rendering a
14:09 - it's a render texture so there's a
14:11 - camera actually behind each of these
14:14 - portals so the prefab is a mesh with a
14:16 - render texture and then behind it
14:17 - there's a camera and so the camera is
14:20 - rendering in real time what's in front
14:21 - of the portal basically from behind it
14:23 - and so it's seeing your model
14:26 - from both of these
14:27 - portals both cameras are seeing your
14:29 - model and so it shows up in the render
14:31 - texture on the other on the other um
14:33 - on the other portal so it's effectively
14:35 - like looking at two video cameras
14:38 - instead of a portal
14:39 - it's a sort of a trick and this is a
14:42 - very crude implementation of portal the
14:43 - actual game uses a much more
14:45 - sophisticated algorithm for
14:46 - um and it also uh tracks your position
14:50 - with the camera so that like based on
14:52 - your angle of rotation you'll actually
14:53 - see something different on the on the
14:55 - texture there
14:56 - but it's a lot more complicated to put
14:57 - something like that together i have some
14:59 - resources that i've included um in the
15:01 - lecture and the assignment that'll show
15:02 - you actually how to do that
15:04 - um but
15:05 - it would take many many more hours than
15:08 - i had to uh put this demo together
15:12 - yeah it's fixed so if you actually look
15:13 - at it from the side you'll notice that
15:14 - it's like just a flat texture um there's
15:17 - no perspective ultimately it's
15:18 - perspective and um there's an awesome
15:21 - video that i'm going to show later in
15:22 - the slides by a youtuber named brackies
15:25 - where he actually implements a
15:27 - perspective correct shader that allows
15:30 - you to
15:31 - see and with with camera tracking of the
15:33 - player like both cameras will track the
15:35 - position of the player as well as
15:37 - render a texture and the result of that
15:40 - is because the cameras are changing
15:41 - their position it's sort of like
15:43 - changing the angle at which the scene is
15:45 - being rendered onto the portal mesh
15:48 - but also the way that's being drawn is a
15:50 - little bit different and so he has a
15:51 - really cool shader that does that and
15:52 - then valve when they present they'll
15:54 - actually show how they went about doing
15:55 - it which is even more
15:56 - complex but looks really good and is a
15:58 - lot more you know technically
16:00 - interesting
16:02 - but yeah that's my um sort of
16:04 - implementation bare bones implementation
16:06 - of what makes portal work
16:08 - so and it's somewhat it's somewhat fun
16:10 - to like walk through these um you know
16:12 - walk through these portals and just sort
16:14 - of play around with it now um the reason
16:17 - that if you just walk into a blue portal
16:20 - it doesn't work is because the portals
16:22 - are actually stored off-screen until you
16:24 - use them
16:25 - and so a way in which so i'll open up
16:28 - the scene here oh by the way thanks
16:29 - james for coming up to demo i appreciate
16:31 - it so the portals are over here
16:35 - right both of them are right here
16:37 - and so what allow what that
16:39 - does is when you only shoot one of them
16:41 - the other one is still out here so when
16:43 - you walk through it you end up just
16:44 - teleporting outside the level and in
16:46 - order to not have that happen what you
16:48 - really need to do is have a flag on both
16:50 - of them that just says
16:51 - don't teleport unless they've been shot
16:53 - once right and that'll prevent that'll
16:55 - prevent that sort of behavior from
16:56 - happening simple fix um but an
16:58 - entertaining one to take a look at
17:01 - and that is
17:03 - my crude implementation of portal it's
17:05 - uh far from being anywhere near as
17:07 - polished as the actual game um and there
17:11 - is the slight weird wall that gimbal
17:13 - locks the portal um which i would like
17:15 - to figure out why exactly that is but
17:18 - everything else is sort of in here now
17:21 - it doesn't include something like
17:23 - shooting blocks through it but the same
17:25 - sort of principles would apply because
17:27 - all we're effectively doing on the
17:28 - portal is saying
17:30 - it's it's basically a trigger right it's
17:32 - got a box collider on it and it says if
17:34 - i collide with something in this case
17:36 - the player um i want to teleport that
17:38 - collider to the other portal which means
17:41 - that the portals sort of have to link to
17:42 - each other right one portal has to have
17:44 - a reference to the other portal so that
17:45 - it can say teleport to the linked portal
17:48 - and vice versa the link portal should
17:49 - have a
17:50 - reference to the other portals i can say
17:52 - teleport back if you collide with this
17:54 - and so if we have another object let's
17:56 - say we shoot a cube into the portal it
17:58 - would also get teleported to the other
18:01 - portal right and now the other
18:03 - consideration for that is like if it's a
18:05 - rigid body and it has physics applied to
18:07 - it for example let's say it's it's going
18:09 - like 10 on the x and it teleports to a
18:12 - portal that's like perpendicular to it
18:14 - and it's still going 10 to the x then as
18:16 - soon as it shoots out of the portal it's
18:17 - going to go straight left which isn't
18:19 - the behavior we want we want it to go
18:20 - forward so
18:22 - it's like um
18:24 - linear velocity needs to be calibrated
18:27 - to go in a different direction didn't
18:29 - have enough time to put a full demo of
18:30 - that together but if you're curious in a
18:32 - nutshell that's sort of like what you
18:34 - would need to do in order to implement
18:35 - like some basic physics with uh
18:38 - portal
18:40 - so holding a weapon based on the
18:42 - screenshot can anybody tell me how they
18:43 - think i got i went from just a plain fps
18:45 - controller to an fps controller holding
18:48 - a gun
18:50 - did you stick a gun
18:54 - i don't know what do they call
18:59 - yeah there's not really a notion
19:01 - necessarily of pixels um in 3d space
19:04 - because that changes depending on your
19:05 - resolution but yes unity units so um
19:09 - it's effectively equivalent to a meter
19:12 - and you can change what it represents in
19:14 - unity settings
19:16 - um but yeah i mean it's not it doesn't
19:18 - necessarily have to be one unit it can
19:19 - be an arbitrary amount and what it
19:21 - really was was me going into here with
19:23 - this model by the way got this model on
19:26 - the asset store for free so the asset
19:27 - store is an awesome place if you're
19:28 - looking to just quickly prototype your
19:30 - game they didn't have any like obvious
19:32 - portal guns portable lookalikes that
19:34 - looked really good so i was just like oh
19:35 - this gun's got like the same kind of
19:37 - color i'll just choose this like a
19:38 - sci-fi kind of gun
19:40 - but as you can see
19:42 - there's a hierarchy here now
19:46 - how
19:47 - are we keeping the
19:49 - gun
19:50 - like affixed to where the camera is
19:52 - looking do we know
19:54 - you do the same thing as you do with the
19:56 - first
19:57 - the first person shooter
19:59 - code is you have the camera follow
20:01 - the uh
20:03 - sorry you have the camera
20:07 - yeah the camera followed the gun do we
20:08 - know do you have any guesses as to how
20:09 - we're doing that it's actually a really
20:11 - really simple
20:18 - thing so
20:20 - all we're doing oh stephen
20:23 - you said the cameras like transform like
20:26 - as
20:29 - like you really
20:31 - transform
20:32 - um
20:33 - cut into their guns transform like with
20:35 - an offset in like the same direction but
20:37 - like just some position
20:39 - yeah kind of so set the guns transformed
20:41 - to the cameras transform but just with
20:43 - an offset and that is effectively what
20:45 - we're doing um and in order to
20:46 - accomplish that it's really as simple as
20:49 - just making it a child of that thing
20:52 - so this is the first person character
20:55 - controller it's got a camera attached to
20:56 - it anything that you parent to something
20:58 - or you make a child of something else
21:01 - it's going to have the same transform
21:03 - like changes applied to it including
21:06 - rotation
21:07 - so by making the gun just a child of the
21:09 - first person character which is where
21:11 - the camera is here first person
21:13 - character by the way is just a
21:14 - subcomponent of the fps controller
21:15 - whichever you named the portalgun fps
21:17 - controller here
21:19 - the portal gun anytime this first person
21:21 - character is rotated which is the camera
21:22 - so anytime the camera is rotated it
21:24 - applies that rotation to the portal gun
21:26 - gun here this gun mesh and so that gives
21:29 - you the effect so what you do is you
21:31 - start it off by you know you figure out
21:33 - okay where's the you start off in 3d
21:35 - space like this you're looking at your
21:37 - game scene and you have your character
21:39 - and then you move your gun object around
21:41 - in this case i could go let's go to
21:44 - layouts 2x3
21:45 - so we can see in real time see this is
21:47 - the game view this is what's going to
21:48 - look like on startup
21:49 - i'm going to go over to my game
21:53 - my editor view here
21:55 - and i'm just going to
21:58 - grab the actual gun component here the
22:00 - gun object i should say go and position
22:03 - it and i can just move it right
22:05 - and so this is how you can like change
22:07 - where your gun is relative to the camera
22:10 - and this is going to affect sort of how
22:11 - it feels right like i could put it here
22:13 - and it's kind of a little lower i could
22:14 - put it here it feels a little weird
22:16 - obviously because it doesn't have a hand
22:17 - on it so it's kind of almost looks like
22:18 - a vr game and that's kind of like what
22:20 - vr games do is they take your hand
22:22 - positions and then they like
22:24 - the gun transform is locked to the
22:26 - basically where your hand controllers
22:27 - are
22:28 - um
22:29 - in this case all i did was i just
22:30 - positioned it i said i like how it looks
22:31 - right here so i'm just going to do that
22:33 - and as soon as i make it a child of the
22:35 - first person character which is the
22:36 - camera it's just going to get all the
22:38 - rotations applied to it so anytime we
22:41 - make any rotations
22:43 - to the camera which i'm doing here it
22:45 - stays exactly aligned with the with the
22:48 - camera this applies to any operation
22:51 - that you do in unity when you make any
22:52 - sort of transform position scale changes
22:55 - they
22:56 - all get propagated down the chain all
22:59 - the objects that are children of an
23:00 - object that get transform operations
23:02 - applied to them will have the same
23:04 - transform operations applied to them
23:05 - sort of like this recursive kind of
23:06 - effect yeah so if you import the
23:09 - first-person controller
23:11 - right that automatically has to jump and
23:13 - move left and right
23:14 - and then you just move your asset your
23:16 - gun
23:18 - to be underneath
23:20 - that controller it'll
23:22 - correct so if you have if you just
23:23 - import the vanilla fps controller and
23:25 - then just make the gun specifically the
23:27 - gun needs to be a child of this the
23:29 - first person character bit because that
23:31 - has the camera and recall the camera is
23:33 - what's driving our rotation right
23:34 - because we're moving the camera's
23:36 - rotation with our mouse that is
23:37 - ultimately going to determine how the
23:39 - transform gets applied to the gun but
23:40 - yes
23:42 - and so just whenever you're doing
23:43 - anything in unity and you'll do a lot of
23:45 - things where like one thing's movement
23:47 - or scale or rotation should apply to
23:49 - another thing just remember that it's
23:50 - usually just as easy as making it a
23:52 - child of something else
23:54 - so any other questions as to how we've
23:56 - gone about
23:57 - implementing the weapon
24:00 - all right
24:01 - so ray casting so raycasting is a nice
24:03 - feature that unity gives you for free
24:06 - it's part of the physics sort of
24:08 - namespace in unity part of the scripting
24:10 - api
24:11 - and what it allows you to do is
24:13 - effectively
24:15 - look at from whatever transform you're
24:17 - operating at or whatever opera transform
24:19 - you give it as a the source so whatever
24:21 - point you give it as the source
24:23 - you can tell a direction give it a
24:25 - vector as a direction
24:27 - and in this case what we're doing is
24:28 - we're saying
24:29 - transform.forward and transform.forward
24:32 - just means
24:33 - basically wherever we're looking x and y
24:35 - and then straight in the z direction so
24:37 - if you're doing it on a camera it's
24:38 - always going to be exactly what you're
24:40 - looking at it's always going to be
24:41 - exactly forward on the like
24:43 - transform.forward on a camera is always
24:45 - going to be like center of the screen
24:47 - wherever you're looking at and so if we
24:49 - cast a ray
24:50 - from the point of our character or
24:52 - actually we're doing it from the point
24:53 - of our gun
24:54 - to
24:55 - the transform dot forward like a line
24:57 - going from our player to transform its
24:59 - uh the forward vector of its uh
25:02 - character the
25:04 - forward vector of our camera it's going
25:06 - to have the effect of
25:07 - um
25:08 - we can shoot something
25:10 - right we can we can
25:12 - create a raycast and it's like a fix
25:13 - something wherever that ray intersects
25:16 - and it'll be the exact center of our
25:17 - camera view does that make sense
25:20 - so shoot a line from the z your z axis
25:23 - which is your forward vector and then
25:25 - based on how you've rotated the camera x
25:27 - and y are the x and y part of that and z
25:29 - is always forward that'll let you shoot
25:31 - things or cast rays directly in front of
25:33 - you and you can cast rays between any
25:35 - object and from any source point with
25:37 - any sort of direction you want
25:39 - but it's particularly pertinent in the
25:41 - context of
25:43 - how we've shot it from our gun and so
25:45 - here's a screenshot actually what that
25:46 - looks like and so the nice thing about
25:48 - unity actually is it has a function
25:51 - called debug ray or debug.drawray
25:54 - which i'll show you here
25:58 - i implemented it in a function called
26:00 - the
26:01 - a component rather called debug ray so
26:03 - that you can actually
26:06 - see
26:07 - where array is being cast in your scene
26:10 - and eliminate any ambiguity there so you
26:11 - can see draw array transform.position
26:14 - and then we just say
26:16 - transform.transformdirection
26:18 - vector3.forward
26:20 - and then times a thousand just means a
26:22 - thousand units you know from that point
26:25 - and then color.red
26:28 - and so what that'll do is only in the
26:29 - only in the editor view so this doesn't
26:31 - apply in the in the actual game this is
26:33 - just a debug
26:35 - call
26:36 - debug.drawray and so it'll render in the
26:39 - this scene up here just not down here so
26:42 - if we hit play i actually have all the
26:44 - portals rendering a debug gray from
26:45 - their forward transform and from my gun
26:47 - so you can see it there i'm just doing a
26:49 - debug.drawarray with just
26:51 - transform.forward and
26:54 - um using my transform.position as the
26:56 - source point
26:57 - and forward is always going to be notice
26:59 - that the the z arrow it's always
27:01 - always falling the same direction right
27:03 - x and y are sort of changing you know
27:05 - the back planes or like how that's
27:06 - rotated but z is always forward right
27:11 - and so that's the that's the ray coming
27:13 - from our gun and if we shoot a portal
27:15 - there and there i have those also set to
27:19 - um let me pause it so i can rotate the
27:20 - view a little bit i have those also set
27:22 - to draw array from their forward
27:24 - position so those are also drawing array
27:26 - from what's there vector3 dot or their
27:29 - transform dot forward their directional
27:31 - vector um but yeah raycasting it's
27:35 - pretty it's pretty easy just to get um
27:38 - some pretty simple
27:39 - collision tests this way with guns with
27:42 - um a lot of different things but
27:44 - primarily you'll see this used for like
27:46 - calculating whether something is
27:47 - blocking something else like if a car is
27:49 - moving and it detects maybe if it
27:51 - detects another car like in grand theft
27:53 - auto for example and your car is driving
27:55 - down the center of the road or something
27:56 - and it wants to know whether there's a
27:58 - car
27:59 - two units in front of it or something it
28:00 - just cast a ray and see if there's any
28:02 - geometry there from its forward vector
28:04 - right transform.position card opposition
28:06 - and then get its forward vector which
28:08 - will be its z direction and then um it
28:11 - depends on whether maybe your game's top
28:12 - down maybe it's not your forward vector
28:14 - maybe it's your y vector in that case
28:16 - but that'll effectively give you not
28:19 - only that you've got a collision but
28:20 - also tell you where the collision is too
28:22 - which is nice
28:23 - and we do that in the
28:25 - portal
28:27 - gun script
28:31 - where we call
28:32 - physics.raycast so this this is the
28:34 - function by the way to actually do the
28:35 - raycast
28:36 - the interesting thing about raycasting
28:38 - in unity is that it returns a struct
28:40 - object and so
28:42 - you need to declare this hit object
28:45 - which will tell you all the information
28:46 - about the hit so like where it was
28:48 - whether there was a hit to begin with um
28:50 - and what the like the normal was on the
28:52 - surface that it it collided with so the
28:54 - angle at which that
28:57 - sort of plane was projecting out
29:00 - and then you call physics.raycast with a
29:03 - position and a
29:04 - transform direction
29:06 - and then
29:07 - you pass in out hit
29:09 - so out is interesting
29:11 - because out is sort of c-sharp's way of
29:14 - allowing you to return multiple values
29:16 - to something so out is going to be an
29:18 - object a in this case it's going to be
29:20 - our raycast hit that we declared up here
29:22 - right which is a struct which recall is
29:25 - just a collection of
29:26 - variables like in c or c plus um
29:30 - and out hit just means that normally we
29:33 - pass in these values to the function
29:34 - they don't get manipulated right but we
29:37 - pass in this
29:38 - variable as out
29:40 - which will allow this function to
29:41 - actually change the data inside this
29:44 - this hit variable
29:45 - and so the result of that is hit from
29:48 - this point forward contains all of the
29:49 - information about the raycast
29:51 - that we that we
29:53 - that we just triggered and when we call
29:55 - math f dot infinity that just means um
29:58 - ray cast to infinity which is until you
30:01 - know forever and ever and unity
30:02 - obviously doesn't check infinitely
30:04 - whether something's collided with
30:05 - something
30:05 - it optimizes the right way
30:08 - but you can use that just if you don't
30:10 - want to necessarily specify
30:13 - i want to check two units or five units
30:15 - or a thousand units in front of me i
30:16 - want to just check forever and see if it
30:18 - collides with something in your scene
30:19 - right
30:21 - um and then as you can see here once
30:23 - that once we have detected a collision
30:25 - we play a portal sound we get the right
30:27 - portal and then we set the portal's
30:28 - transform and rotation based upon the
30:31 - hits point and rotation and that's
30:33 - pretty much all that's involved in
30:35 - shooting the gun and you can take a look
30:36 - through here if you want to get a sense
30:39 - of how it works and maybe explore also
30:40 - the raycast the physics.raycast
30:43 - section of the api just to understand
30:45 - what exactly it returns and what you can
30:47 - do with it but in this case this is how
30:49 - we're using it to detect whether we've
30:51 - intersected with the wall so it'll
30:53 - intersect with any sort of mesh and then
30:56 - when it does it'll tell you exactly how
30:58 - it did so
31:00 - that is what ray casting is raycasting
31:02 - has another name for like old school
31:05 - games like wolfenstein the method of
31:07 - rendering was called ray casting where
31:08 - you generate one sort of uh
31:12 - you would generate a ray from every
31:14 - pixel of the screen effectively although
31:16 - it was mostly just every line of the
31:18 - screen and you would just look up and
31:20 - down for everywhere intersected in the
31:22 - scene and then just create draw like a
31:23 - texture there and so that would generate
31:25 - a world that was that looked 3d but you
31:28 - couldn't move up and down because it was
31:30 - always generating all arrays completely
31:32 - forward and so you were locked onto two
31:34 - axes
31:36 - but ray casting is different in unity
31:38 - raycasting is just literally casting a
31:40 - rate in 3d space versus the sort of
31:43 - 2d space that it was casting in games
31:46 - like wolfenstein there's another
31:47 - screenshot of uh
31:51 - normals from our portals casting out
31:54 - rays and i i want to look up and see if
31:56 - i can just find a picture of what
31:58 - wolfenstein look like
32:02 - i'm pretty sure
32:05 - most folks are probably familiar with
32:06 - not the new one
32:08 - yeah wolfenstein 3d so this was this is
32:12 - wolfenstein so old school but this sort
32:16 - of ray casting was different it would go
32:19 - over it would basically shoot rays from
32:21 - every single line of the screen up and
32:23 - down and it would detect based on the
32:25 - level geometry which was very simple
32:27 - level geometry was just basically
32:29 - whether there was a wall there or not
32:30 - true or false kind of like a 2d image
32:33 - and it would draw based on how far away
32:36 - it was that particular point of the
32:37 - geometry it would just draw like pixels
32:40 - from a texture a specific texture
32:42 - at a specific point and they had to
32:44 - interpolate where on the texture it was
32:46 - it was a little more complicated but
32:48 - in case you see wolfenstein or in case
32:49 - you see raycasting used in those two
32:52 - different senses in the case of old
32:53 - school
32:54 - game engines in the case of
32:56 - um
32:58 - uh
32:59 - modern unity sort of raycasting that is
33:03 - what is um
33:05 - involved in that
33:07 - so any questions as to how
33:09 - sort of in a nutshell the raycasting
33:11 - works in the context of our game here
33:18 - so
33:20 - unfortunately no the
33:22 - oculus does not work on mac they do not
33:24 - have mac support and so uh we were
33:27 - unable to get a sort of
33:29 - version of it working we don't have the
33:31 - means to necessarily transport um given
33:33 - how much time we had now getting vr
33:36 - working in unity is actually very easy
33:39 - if i recall correctly i have to just
33:41 - remember the exact
33:42 - menu i had sort of anticipated
33:46 - talking about this before
33:48 - i think it's player xr settings yeah
33:51 - that's how that's what it is so in order
33:53 - to get so it's incredibly easy if you
33:55 - want to do a game in vr in unity and you
33:56 - have a pc out of the box it's very easy
33:59 - just to get it working all you need to
34:00 - go do is go to edit project settings
34:03 - and then go to player and then in the xr
34:07 - settings so unity has like deemed all of
34:09 - its vr ar stuff as xr
34:13 - and you click virtual reality supported
34:15 - here and you have your oculus rift or
34:17 - vive or whatever plugged in it'll just
34:19 - work with the camera like right off the
34:21 - bat right out the gate so it's pretty
34:22 - easy you may have to install drivers on
34:24 - your computer such that your computer
34:26 - knows that you have an oculus plugged in
34:27 - but assuming that's all set up your
34:29 - project will is as easy as just clicking
34:31 - this checkbox
34:36 - hololens
34:37 - um
34:38 - oculus rift and i'm pretty sure the vibe
34:41 - like 90 show the vive
34:43 - i'm not a hundred percent we can we can
34:45 - google it though let's see
34:47 - unity
34:56 - it looks like it does it looks like it
34:58 - definitely does yeah and of course if
35:00 - you already windows pc is very
35:02 - i apologize i thought i totally thought
35:04 - going into the course that unity
35:06 - that oculus worked on a mac um but as of
35:09 - even october they were like it's not
35:11 - going to work on any macbook ever
35:12 - released so only on a pc unfortunately
35:15 - um
35:17 - that said
35:18 - if you do have a pc super easy to get
35:20 - working and it looks like this is
35:21 - actually pretty cool tutorial i haven't
35:22 - looked at this but
35:24 - i tend to like ray i don't know if his
35:26 - name is van der lisch or wenderlich but
35:28 - he makes really good game programming
35:30 - tutorials in general so just you know
35:33 - because we're coincidentally here if you
35:35 - guys are curious i really like this uh
35:38 - website for basic tutorial stuff
35:44 - we have vive um and vive as far as i
35:47 - well vive the thing about vive is you
35:48 - need to install like wall like ceiling
35:50 - mounted cameras in order for it to work
35:52 - so that's kind of out of the equation we
35:54 - have the gear vr but you would need it
35:56 - we would need to export it to mobile and
35:58 - test it and just didn't have i didn't
36:00 - anticipate it not working for mac and so
36:02 - it kind of came up a bit late and so
36:04 - it's on me i apologize but if you are
36:06 - doing a pc game
36:08 - in oculus and you want some assistance
36:09 - i'm happy to like help out it looks like
36:11 - it's very easy just to get working with
36:12 - the default fps controller camera so
36:16 - definitely reach out if you're
36:18 - developing oculus and need some
36:19 - assistance
36:22 - [Music]
36:24 - maybe for the next iteration of our next
36:26 - unity course we can have a
36:28 - a big sort of vr
36:31 - day where we bring in all the guns
36:33 - um
36:35 - but yeah back to sort of raycasting and
36:38 - what we were just talking about um
36:41 - shooting array on your z axis based on
36:44 - your rotation
36:45 - um get information from it
36:47 - and then
36:48 - sort of what we do is we flip the portal
36:50 - based on the hit dot rotation of the
36:53 - surface that we collided with and that's
36:55 - effectively all the raycasting that we
36:58 - need to worry about for
36:59 - portal
37:01 - um but the actual making a portal is
37:03 - probably the most interesting part of
37:05 - this whole project and so let's go ahead
37:07 - and go back into present mode
37:10 - so a render texture is the means is a
37:13 - very is a basic
37:15 - it's not a basic means it is the the
37:17 - fundamental way at which we go about
37:18 - doing it and there are
37:20 - various ways to accomplish doing it some
37:22 - that are more technically challenging
37:24 - and look a lot nicer than others i did a
37:27 - sort of simple version of it
37:29 - just to get a sort of proof of concept
37:31 - out of the gate but unity makes it
37:33 - really easy just to get a simple render
37:34 - texture up and running so a render
37:36 - texture is recall
37:39 - just a texture
37:41 - in unity so it's an asset it's an unity
37:42 - asset that you can create the difference
37:45 - between a render texture and a
37:47 - texture that you might have imported
37:49 - from like photoshop or is that a
37:51 - render texture can be rendered to and
37:53 - typically this is used for things like
37:55 - cameras being rendered to it although
37:58 - from what i understand you can render
37:59 - anything to it so you can create
38:00 - procedural textures this way as well but
38:03 - in this example here we're creating a
38:06 - we're essentially creating a screen into
38:09 - which we're looking at the viewpoint of
38:11 - our other portal right from from its
38:14 - forward direction so we can see what
38:15 - what it will look like once we walk out
38:17 - of the portal and go into the next area
38:20 - and so a render texture so i have some
38:22 - for in the slides if you want to
38:23 - download the slides they're here
38:25 - you can see exactly how to create a
38:27 - render texture so literally just create
38:28 - and then render texture that creates a
38:30 - render texture these are the settings
38:31 - that i used
38:33 - for the actual render texture so
38:36 - what will happen do we think if we use
38:38 - like a low res render texture
38:40 - just logically
38:45 - hey let's see what if my render texture
38:46 - was like 200 pixels by 200 pixels
38:50 - and our resolution of our game is
38:52 - like 1080p
38:59 - it won't be blown up because what we're
39:00 - doing is we're taking a mesh and we're
39:02 - affixing the texture to it so it'll just
39:04 - scale to fill the mesh
39:07 - but what'll it look like when it's
39:09 - rendered
39:11 - because it's rendering a 200 pixel
39:12 - texture
39:16 - it'll pixelate it it'll look really like
39:18 - nasty
39:19 - and so in order to fix that problem
39:21 - typically what you'll do a smart way to
39:23 - do it would be to dynamically figure out
39:25 - at run time what's what's the resolution
39:27 - of your game right if it's going to be
39:28 - rendered in various resolutions
39:30 - up to 4k maybe down to 720p
39:34 - and then create a render texture that is
39:36 - the size of your game
39:38 - and then by doing that it'll ensure that
39:40 - no matter what your resolution is it'll
39:41 - always be one to one pixel ratio even if
39:43 - you're right up close to it right it'll
39:45 - fill up your whole screen
39:47 - in this case we went for a simpler
39:49 - method so we didn't have to do any
39:51 - dynamic instantiation of the render
39:52 - texture which you can absolutely do and
39:54 - it is the more robust way to do it but
39:56 - in this case i just chose 1024 by 1024
39:59 - figuring that that was going to be good
40:01 - enough for demonstration purposes and
40:03 - most of these other settings i believe
40:05 - actually all these other settings are
40:06 - completely default render texture
40:08 - settings the only ones that changed
40:09 - where this is 256 by 256 by default and
40:11 - it just looks really pixelated and nasty
40:14 - especially when you're right up close to
40:15 - it
40:16 - um
40:18 - and then
40:19 - all we need to do so
40:21 - once we've created a render texture
40:22 - right in our in our scene in our assets
40:25 - so here i'm going to go to textures this
40:28 - is where i'm storing all my textures
40:30 - whether they render textures or not i
40:32 - have these two render textures here
40:34 - and so these are by default they're not
40:36 - going to be mapped to anything because
40:37 - they're just there's empty render
40:38 - textures we've effectively allocated
40:39 - them and said something will be
40:41 - rendering to these later but for now
40:43 - they're just empty there's placeholders
40:44 - right they're like blank screens but
40:46 - that tv hasn't been turned on yet
40:49 - in order to actually render to them
40:53 - we go into our first person character
40:56 - sorry not our first person character we
40:57 - go into whatever camera we want to
40:59 - render it to render to the render
41:01 - texture because we're we're effectively
41:03 - taking these render textures and we're
41:05 - rendering a camera view onto them right
41:07 - each of the portals has a camera behind
41:09 - it looking out from it and so we want to
41:11 - take that camera's view
41:13 - and we want to render that onto the
41:14 - other portal's face
41:16 - the other portal's render texture the
41:18 - texture that we're going to put onto it
41:21 - and so
41:22 - all we need to do
41:24 - is say here is my orange portal i have
41:26 - my camera here
41:28 - every camera has a target texture just
41:30 - right out the gate
41:32 - so you can just say okay i'm going to
41:34 - take my orange portal texture my render
41:35 - texture that i've instantiated so it
41:37 - knows that it's going to be able to
41:38 - receive an input source
41:40 - and i'm going to just click and drag it
41:42 - there and it's that simple now whenever
41:43 - you run the game
41:45 - you'll notice that your render texture
41:46 - updates i'm not sure if it updates in
41:48 - real time in the inspector but it
41:50 - renders if you're if you're showing it
41:52 - onto a
41:54 - yeah it doesn't render in the inspector
41:55 - but it will update if you've affixed it
41:58 - to any other surface
41:59 - and so what we're doing is we're fixing
42:01 - it to the meshes that are associated
42:04 - with each portal james did you have a
42:05 - question
42:09 - oh sure the render texture so i just
42:11 - right click and then i go to create and
42:13 - then a render texture right here
42:16 - and that will give you most of the
42:17 - settings that you need to get up and
42:18 - running with it and you can assign it to
42:20 - a camera but the important thing is do
42:22 - consider your resolution for your render
42:24 - texture make sure that it's high enough
42:25 - such that your game won't look pixelated
42:27 - when you're looking at it like pretty
42:29 - close up
42:32 - yep yep and so that'll do is create a
42:36 - link between the two such that anything
42:38 - the camera sees it's no longer going to
42:40 - be rendering to the scene or anything
42:42 - like that it's going to render to the
42:43 - texture and actually i think you can
42:44 - render to the scene and the texture but
42:46 - these aren't rendering um to the scene
42:48 - at all they're the only one rendering to
42:50 - the scene is the first person character
42:52 - because it's the default camera
42:54 - main camera
43:03 - um if it's a high too high of a
43:05 - resolution it's just going to like
43:07 - compress to fit the the mesh whatever
43:09 - it's affixed to and you'll probably run
43:10 - into performance problems but it's not
43:12 - going to break
43:13 - yeah because you're not affixing it to
43:15 - any because your resolution it doesn't
43:17 - really have an effect necessarily on
43:18 - whatever's in your game world and like
43:20 - that doesn't cause any issues um it gets
43:22 - it gets interpolated like unity will
43:24 - just like calculate how to render it to
43:26 - the screen right
43:27 - yeah
43:30 - like game textures
43:32 - generally are very high resolution like
43:35 - four thousand by two 4k textures are
43:37 - often used
43:38 - even if you're running your game in
43:39 - 1080p and now game engine will probably
43:41 - optimize it and like down sample the
43:43 - texture so that it is like actually a
43:45 - 1080p texture and you don't like you're
43:47 - not trying to calculate more draw more
43:49 - than you need to
43:50 - um
43:51 - but
43:52 - unity we'll figure that out for you you
43:53 - don't have to worry about that
43:56 - um
43:57 - but yeah that's that's what a render
43:59 - texture is and that's that's how we are
44:01 - creating this illusion remember
44:03 - everything in the game is an illusion um
44:06 - in this case we're not actually and it's
44:08 - it's obvious in this example because
44:10 - we're not actually because the the
44:12 - textures are flat and there's no
44:13 - perspective correction you can see that
44:15 - it's a texture even if it is slightly
44:17 - convincing from far away like from far
44:19 - away it actually kind of looks
44:21 - i mean i don't know if it necessarily
44:23 - looks real
44:24 - um i mean it kind of does right like you
44:26 - from here it's hard to tell and from
44:27 - here it kind of looks like we're going
44:28 - into another room right i go like that
44:31 - that's the broken wall they go like that
44:33 - right there's a portal there and it kind
44:35 - of looks like it's a real room that
44:37 - we're walking into it's just a
44:38 - resolution but all we're doing is we're
44:39 - just drawing a camera's view onto that
44:41 - texture in real time and
44:44 - if you notice you can see our gun that's
44:45 - kind of hard to see actually
44:47 - um
44:52 - see if i can do it from
44:54 - from there maybe
44:57 - yeah there we i see a little bit better
44:59 - there when we move we can see the gun so
45:01 - we it's we can see that it's rendering
45:02 - in real time and that's the power of a
45:04 - render texture and this allows you to do
45:06 - all kinds of things you can have like
45:08 - you know tv screens in your game that
45:09 - are rendering another part of your scene
45:13 - obviously an example like this where you
45:15 - have a portal looking into another area
45:16 - now if you apply a perspective
45:18 - correction to this whereby your camera
45:20 - actually tracks where your player's
45:21 - position is relative to the portal you
45:22 - can accomplish a much more believable
45:24 - look and you can actually make it seem
45:26 - as if you're looking into another area
45:28 - because the camera is literally moving
45:30 - with your player so the cameras like the
45:32 - the stuff that it's capturing is going
45:34 - to be changing in real time not only
45:35 - just your character's model right the
45:37 - actual angle is going to change and
45:39 - therefore be perspective correct
45:41 - and there's a awesome tutorial that i'm
45:43 - going to link to in the slides that will
45:45 - show you how to go about doing that it's
45:47 - really awesome and so this is what it
45:48 - ends up looking like this is actually
45:49 - before i changed one of the portals had
45:51 - a slightly offset camera angle so you
45:54 - can see here this is like a little bit
45:55 - higher than this one is they even though
45:57 - they should be exactly the same
45:58 - but it's fixed now so
46:01 - so texture masking oh any questions
46:03 - about any of that process before we talk
46:05 - about texture masking
46:09 - okay
46:10 - so texture masking is
46:13 - basically the process so here's a
46:15 - if we just take a plane and we put a
46:17 - render texture onto it that's what it
46:18 - looks like it just looks like it's just
46:20 - a square and this could work fine if you
46:23 - want a sort of a square portal look you
46:26 - don't have to do any extra work but if
46:28 - you want a circle
46:30 - right you can't really create like a
46:32 - circle shaped plane object that doesn't
46:34 - really exist and if and even it did it
46:36 - wouldn't be efficient especially if you
46:37 - want a very smooth
46:40 - plane because everything is triangles
46:42 - and polygons right so if you're if you
46:44 - have a circle it's going to be a bunch
46:45 - of these sort of fanned out polygons
46:47 - especially a very high res circle like
46:49 - one of these that's a very high-res
46:50 - circle making a polygon that looks like
46:53 - that is not
46:55 - it's not an optimal way to go about
46:56 - solving that problem right
46:58 - a much more optimal way to go about
46:59 - solving that problem would be to say to
47:01 - designate certain pixels of the t of
47:04 - some texture as being pixels that we
47:06 - want to read and then certain other
47:08 - pixels being not pixels that we want to
47:10 - read and um and therefore produce a the
47:13 - final image that gets put onto a
47:16 - geometry right
47:19 - um and so what we end up doing is
47:21 - creating an image first so it's this
47:23 - image
47:25 - um which is kind of hard to see
47:27 - but
47:28 - it's just a simple sort of can you see
47:31 - you guys see from the akin so it's just
47:32 - a simple oval right it's the exact shape
47:34 - that we want our portal to look like
47:36 - um and the pixels that are white are the
47:39 - pixels that we're going to render and
47:40 - the pixels that are black are the pixels
47:42 - that we don't want to render we want to
47:43 - consider those as black pure zero alpha
47:45 - effectively
47:48 - and using a awesome shader that you can
47:51 - get for free just easily on the unity
47:53 - webpage this is just a masking shader
47:56 - and i'm not great at writing shaders
47:58 - but what this does is turns lighting off
48:01 - first of all
48:02 - what happens if we have lighting applied
48:03 - to our
48:06 - portals
48:13 - it's going to look a little weird right
48:14 - you're going to get like shadows cast
48:16 - onto your portals and that doesn't make
48:17 - sense right because we're effectively
48:18 - supposed to be looking into another
48:20 - another place another area so we have
48:22 - shadows that are being cast onto our
48:24 - thing we're effectively like almost
48:26 - seeing like a glass door on our portal
48:28 - right
48:29 - it sort of breaks the illusion
48:30 - so
48:31 - lighting should be off
48:33 - a lot of these things i'm not 100 on
48:35 - because i'm not great at writing shaders
48:36 - but it's a very simple easy shader that
48:38 - you can grab off of the
48:40 - unity web page and the
48:42 - i think i
48:44 - clipped the url here at the very bottom
48:48 - but i grabbed that off of the unity web
48:49 - page and all it does is it adds onto
48:52 - your material
48:55 - this second image here and it gets blown
48:57 - up a little bit because unity makes any
48:59 - texture that you apply to
49:04 - basically any texture you put into like
49:05 - an image selector will get made into a
49:07 - square shape and our image is not square
49:09 - shaped but what this does is when you
49:11 - pass in this image which is called a
49:13 - culling mask
49:15 - it will
49:16 - basically combine the two images and
49:18 - then cancel out any of the pixels that
49:20 - are black
49:22 - on the
49:24 - on this it'll effectively add
49:26 - the black and white to the alpha of the
49:30 - of the
49:32 - texture pixels right so you can actually
49:34 - make some of these gray and then it'll
49:35 - have the effect of sort of making it
49:36 - half transparent but in this case i only
49:39 - went with full transparent and full hard
49:42 - 255 alpha so we get sort of a crisp
49:45 - outline for our portals
49:48 - and that's what the that's how you end
49:49 - up putting together a um
49:53 - a
49:54 - basic
49:55 - sort of oval shape on something that is
49:57 - just a flat mesh and you can do this
49:59 - with anything
50:01 - anytime you need to sort of take away
50:03 - detail that would make making a mesh
50:06 - extremely difficult or doing really cool
50:08 - effects
50:09 - it's often just a lot easier to create a
50:11 - mask for it and then create use the
50:13 - right shader that's meant to have that
50:14 - mask and then just
50:17 - manipulate that however you need to
50:19 - um
50:21 - and again the link here for the shader
50:23 - is here and then you can use this for
50:24 - pretty much anything you want
50:27 - and result of that
50:29 - is we go from having a square portal to
50:31 - a elliptical portal so pretty nice
50:36 - i didn't have to use a plane but it
50:39 - doesn't really make sense
50:40 - to use anything else
50:42 - um
50:43 - because using a i mean using a cube
50:46 - it would it would create depth we don't
50:48 - want the portal to have any depth really
50:50 - right it should be a flat surface
50:53 - and then when we go through it it's just
50:54 - teleport us to the other surface to make
50:56 - it look
50:57 - sort of seamless
50:58 - i don't think there's any other
51:00 - i don't think there's another choice of
51:02 - geometry that makes sense for this use
51:04 - case
51:11 - no i probably wouldn't um you'd
51:14 - make a cylinder flat
51:16 - and project it and have no depth on it
51:18 - the
51:20 - you would be able to still see the rings
51:22 - on it
51:23 - and also texturing that
51:26 - is a little bit more complicated because
51:28 - then it's going to it's going to you'd
51:29 - have to uv map your
51:31 - both your
51:33 - sort of
51:34 - mask and your regular texture onto that
51:36 - because by default it's going to wrap it
51:38 - weird just because
51:40 - this is just a plain so whatever you
51:41 - texture map onto it's going to be
51:42 - completely flat but a cylinder is going
51:44 - to wrap it around all sides and it's
51:46 - going to look a little bit it's going to
51:47 - look a little bit funky
51:49 - i suppose in theory you could use a
51:50 - cylinder for it but i think it'd be a
51:51 - tremendous amount of work i don't think
51:53 - it would be
51:54 - anywhere near as easy as getting it to
51:55 - work with just a flat plane or a mesh
51:59 - interesting idea though
52:01 - i guess you could theoretically create a
52:03 - cylinder
52:04 - that has if you wanted to like a bridge
52:06 - between two worlds and have one end be
52:09 - one
52:10 - portal and one envy another portal and
52:11 - then be able to walk between them that's
52:13 - a cool idea maybe you can make that work
52:15 - but i think for this the the plane is
52:17 - the right way to go
52:20 - any more questions as to sort of how
52:23 - that works
52:27 - all right
52:28 - so we'll talk about teleporting now so
52:30 - teleporting is pretty easy
52:32 - all we really need to do right is just
52:35 - create a
52:38 - mesh collider on the portal mesh the
52:40 - orange portal in the blue portal and
52:42 - then when that mesh collider if that
52:43 - mesh collider is a trigger right and it
52:46 - collides it detects a collision with
52:47 - something else it's going to we can just
52:49 - define on trigger enter
52:51 - and then with that
52:53 - we can teleport the
52:55 - collider other
52:57 - to the other portal's location so every
53:00 - portal this is the portal component
53:02 - it has a links portal right because we
53:04 - need to know where to teleport the
53:06 - player to the other portal
53:07 - so we need to get no have a reference to
53:09 - its transform
53:11 - whether it's active right because if we
53:14 - allow ourselves to
53:16 - teleport to another portal
53:19 - and another portal like back and forth
53:20 - just without any restraints what do you
53:22 - think is going to happen
53:26 - infinite loop we just get an infinite
53:27 - sort of weird flickering effect um so
53:30 - you need to effectively have like a
53:31 - toggle switch on both portals and say
53:34 - um as soon as i enter a portal i should
53:37 - not be able to teleport back into it
53:39 - right and as soon as i teleport to
53:41 - another portal i should not be able to
53:42 - teleport into it either but once you
53:44 - exit a portal you should be able to
53:46 - teleport back into it
53:48 - and so what that effectively does is we
53:50 - enter a portal
53:52 - it gets flagged as not teleportable
53:55 - right we get teleported to the other
53:57 - portal as soon as that happens this
53:58 - portal can now be teleported into
54:01 - this portal that we're standing in
54:03 - is now flagged as not teleportable and
54:06 - then we walk out of it and we're allowed
54:08 - to teleport back into that one and the
54:10 - other one so it's effectively an on off
54:12 - operation that you have to balance
54:13 - appropriately
54:15 - the actual portal game is a little more
54:17 - complicated because they allow you to
54:19 - walk in between portals
54:22 - this does not go into that level of
54:23 - detail and it's a more complicated
54:25 - problem to solve
54:26 - this example just assumes that you walk
54:28 - into a portal you get teleported out the
54:30 - other end and there's no sort of
54:31 - in-between state
54:33 - and actually if you're in between two
54:35 - portals there's a replication of
54:36 - geometry which valve will talk about in
54:38 - their talk as well which i think will be
54:40 - very interesting because if you look
54:42 - into another portal while you're in the
54:43 - middle of a portal right you want to be
54:45 - able to see
54:46 - yourself you know in that portal right
54:49 - halfway in and out of that portal so
54:51 - there's a
54:52 - lot of interesting considerations for
54:55 - getting very believable portal systems
54:56 - but ours is a very simple illustration
55:00 - and so this toggle function is all that
55:02 - i have to toggle the function's on and
55:04 - off capability and all it is is just
55:06 - portal active is not portal active and
55:08 - that just flips that flag super easy
55:12 - on trigger enter we
55:15 - effectively cache our position x on the
55:18 - x and z axis so we don't rotate it
55:19 - because when we rotate our x and z on
55:21 - the first person controller by default
55:24 - it causes some really weird buggy
55:26 - behavior based on the way that the fps
55:28 - controller works so all i do is i just
55:30 - cache i cache those positions and then
55:32 - make a rotation on the y-axis and
55:34 - that'll save us that weird um
55:37 - sort of
55:38 - going topsy-turvy effect that you'll get
55:40 - if you use the fps controller by default
55:42 - and you do perform rotations on it
55:44 - you'll notice this so
55:46 - i haven't had the time to dig in depth
55:48 - as to how to fix it um but this is the
55:50 - way that i was able to fix it for this
55:51 - example at least is only only allow
55:54 - yourself to rotate on the y direction
55:56 - which is where you're looking in sort of
55:58 - like the ground relative to the ground
55:59 - plane and that'll allow us to rotate
56:02 - based on where we're exiting the portal
56:04 - um at least on the sort of walls that
56:07 - are going up and down and then have that
56:10 - sort of believable effect it doesn't
56:11 - allow us to like jump down into a portal
56:13 - from up above and see us coming down
56:15 - from the other portal
56:16 - which is a cool effect um unfortunately
56:19 - but it does allow us you know sort of to
56:21 - get most of the way there
56:23 - um
56:24 - and so we set our position to the other
56:26 - portals position and our rotation but
56:28 - only the y we get the y and then we set
56:31 - it here using euler angles on our
56:34 - player's transform
56:36 - and then um there's a function that i
56:38 - called that i created called mouse reset
56:40 - which effectively uh just calls init
56:43 - again on the fps controller's um
56:47 - rotation on the the camera and the
56:49 - player and then um that's sort of like
56:51 - the hack that you need in order to
56:54 - so the reason that a lot of the
56:55 - weirdness exists is because the player
56:57 - controller caches its rotation
56:59 - information and so if you perform a
57:01 - rotation on a on your fps controller by
57:04 - hand as opposed to allowing it to happen
57:06 - with the mouse it will
57:08 - immediately reset it back to its prior
57:10 - position and rotation which has the
57:12 - effect of when we teleport from one
57:14 - portal to another
57:15 - um even though we set our direction of
57:18 - rotation to be like outside going in the
57:20 - direction of where the portal is facing
57:22 - we end up having the same position the
57:24 - rotation that we did entering the portal
57:26 - so we end up coming out of portals often
57:27 - just backwards and so
57:30 - that's some that's just a limitation of
57:32 - the first person controller but you can
57:33 - fix that by calling mouse reset which is
57:35 - a function that essentially just calls
57:37 - init again
57:39 - which init is part of the fps
57:41 - controller's
57:43 - mouse look object i won't go too much
57:45 - into detail about it just because it's a
57:46 - little bit arcane and
57:49 - the the source code's in there if you
57:50 - want to take a look and dabble with it
57:52 - but
57:53 - effectively preventing it from caching
57:55 - its uh rotation information and just
57:57 - hard setting it and then
57:59 - recalling the mouse look init function
58:02 - which does the actual setting of the
58:03 - rotation on the camera and the and the
58:06 - player
58:07 - a little bit a little bit weird but
58:09 - that's
58:10 - unity's fps controller and
58:12 - that's how other people are saying to
58:14 - fix it so you could roll your own you
58:16 - could create your own fps controller and
58:17 - probably
58:18 - prevent this from happening but if you
58:19 - want to use the regular fps controller
58:21 - that's sort of the
58:22 - limitation there but it's mostly working
58:24 - and it looks
58:25 - pretty good
58:28 - some more time on end we could probably
58:29 - make it look even better but
58:32 - for now i think it's good
58:34 - so that's teleporting
58:36 - say your position and then set your y
58:38 - rotation override the fps controller's
58:40 - default rotation caching and um we can
58:43 - walk in this portal and then instantly
58:45 - walk out this portal that's what we see
58:47 - so any questions as to how sort of this
58:50 - works in a nutshell
58:52 - or any of the maybe any of the code here
58:55 - in our
58:56 - portal
59:00 - all right
59:03 - so a much better version of the
59:06 - portal at least from the rendering side
59:08 - is this video here so it's bracky's so
59:11 - uh he's a very good
59:13 - he he explains things very well he's got
59:15 - very
59:16 - high quality to his videos uh he creates
59:19 - a bunch of unity tutorials and in this
59:22 - case he created a portal that used a
59:24 - sort of shader and an interesting shader
59:27 - that will only render everything but
59:29 - geometry and also
59:31 - um onto a plane in which case this plane
59:34 - and um does the camera interpolation of
59:37 - the player that i alluded to before
59:39 - which allows us to
59:40 - actually have two so these are two
59:42 - separate worlds
59:43 - in tandem right now so there's this red
59:45 - world here and then this camera is
59:47 - looking at a completely different green
59:49 - world that's completely like set off
59:50 - onto the in the distance that's the
59:52 - exact same geometry but completely
59:54 - colored green as opposed to red and if
59:57 - you look through here it's just
59:58 - completely seamless and the walkthrough
59:59 - is completely seamless and he goes into
60:01 - detail as to how he accomplished all of
60:02 - this if you're curious and he provides
60:04 - you the shader that you can use for free
60:05 - so definitely check that out if that's
60:07 - of interest there's a link there in the
60:09 - video and here's a link to his youtube
60:10 - series if you want to i put some of
60:12 - these in the slack because somebody
60:14 - requested some ai videos and so he has a
60:17 - bunch of different ai videos and a bunch
60:19 - of other really cool series so you can
60:20 - take a look at that if curious
60:23 - and
60:24 - the
60:25 - best version sort of of portal obviously
60:27 - is the portal itself and dave kersher
60:30 - and tajiev kohli are
60:31 - employees at valve who worked on portal
60:33 - and they'll be here on may 2nd to give a
60:36 - talk as to all of the technical sort of
60:38 - things that went behind the scenes and
60:40 - related to rendering and physics and
60:44 - just getting a believable and good and
60:45 - good feeling experience with portal
60:49 - for the actual polished final game that
60:52 - we're talking about so definitely come
60:54 - to that talk if you're curious we're
60:55 - going to take a break and then as soon
60:56 - as we come back we're going to talk a
60:58 - little bit about some new tools that
60:59 - unity has released called pro builder
61:01 - and pro grids um
61:03 - and we'll talk about the assignment and
61:05 - that'll be it for gd50
61:07 - all right welcome back this is lecture
61:09 - 10. so we talked about portal before the
61:11 - break we talked about ray casting we
61:13 - talked about render textures sort of
61:15 - what those are how easy it is to make
61:17 - those in unity we talked about how to
61:19 - give our first person controller a gun
61:22 - so that we could actually look around
61:23 - and look as if we're holding a weapon
61:25 - we talked about the portals themselves
61:27 - how we're masking out the texture the
61:28 - render texture as applied to a plane and
61:31 - how each of those has a camera behind it
61:32 - so that it can render what is going out
61:35 - from the portal in the direction that
61:36 - it's facing
61:37 - we're going to deviate from portal now
61:40 - and talk about pro builder and pro grids
61:43 - which are two tools that are part of the
61:44 - new unity 2018.1 which will allow us to
61:48 - actually model geometry per the
61:50 - screenshot this is actually a level that
61:52 - i created and that is in the
61:55 - distro it allow us to create geometry in
61:58 - the actual scene view without needing to
62:00 - go into a third party program like
62:02 - blender or maya and have to sort of
62:04 - alternate between the two and import and
62:06 - export you know incessantly
62:09 - not only that but as soon as you model
62:10 - something like this in unity in the
62:12 - scene view you can immediately test it
62:14 - for gameplay and make sure that it
62:15 - actually fits
62:16 - what you want and you don't have to
62:17 - worry about scale issues when you're
62:19 - importing and sort of making it work and
62:21 - figuring out ultimately that oh i don't
62:22 - like the way this mesh this level is let
62:25 - me go and tweak it and redo it
62:27 - it just allows you a ton of ease and
62:29 - flexibility and i made i previously
62:31 - mentioned brackie's before but he's got
62:33 - a couple of awesome tutorials here
62:35 - on pro builder and pro grizz to
62:36 - supplement sort of what we'll talk about
62:38 - today in lecture but if you want sort of
62:40 - more of a showcase of all the features
62:41 - of both then you can look at these
62:43 - videos here and get a sense of how they
62:45 - work so we're going to go ahead and just
62:47 - mess around with pro builder a little
62:49 - bit here in the scene view so that we
62:52 - can see what it looks like i'm going to
62:53 - open up my other scene so i have the
62:55 - portal scene if you're in the distro
62:57 - this is where all the stuff that we've
62:58 - been looking at exists just the portal
63:00 - game
63:01 - there's a pro builder scene as well
63:02 - which i'm going to not save that
63:05 - and so this
63:07 - pro builder scene
63:09 - is the level geometry that i created
63:11 - earlier now it looks pretty horrendous
63:13 - because i didn't spend a terrible amount
63:15 - of time on it and i'm not a particularly
63:17 - talented
63:19 - visual designer by any stretch let me go
63:20 - ahead and make it a little bit larger so
63:22 - we can see it a little better
63:25 - but it showcases some of the interesting
63:27 - features so we see you know we have
63:31 - obviously
63:32 - sort of polygonal square shaped
63:34 - rectangular geometry
63:36 - we can see that some faces are textured
63:38 - and some aren't so we can see this face
63:39 - here for example is just white
63:43 - the default material we can see that all
63:45 - of these sort of have this uh brick
63:47 - texture which i got off a procedural
63:49 - generator sorry website that allows you
63:51 - to choose a template for your texture
63:53 - and then you know specify colors and
63:55 - stuff like that i did the same thing for
63:57 - this texture this is another uh
63:58 - procedural texture which is kind of like
64:00 - a blue marbley type texture
64:04 - the cool thing about it is at least for
64:06 - texturing you can just choose arbitrary
64:07 - faces that you want to texture rather
64:09 - than have to texture the whole thing
64:11 - like you would do if you were to just
64:12 - give a mesh a default material it'll
64:15 - apply it to the whole mesh in this case
64:18 - it's just applying it to whatever faces
64:19 - we select in pro builder
64:21 - another interesting thing which i really
64:23 - like is pro builder gives you a lot of
64:24 - tools for creating
64:27 - special kinds of geometry very quickly
64:28 - and efficiently in this case this is a
64:30 - staircase which all i had to do was with
64:34 - pro builder select build staircase and
64:36 - then you can choose a lot of different
64:37 - parameters we'll take a look at how to
64:38 - do that in a second i did the same thing
64:40 - here so notice this this staircase has
64:42 - kind of a spiral to it and then this
64:44 - staircase is really tall but has no
64:46 - spiral and then we have another
64:48 - staircase here which is kind of shorter
64:49 - and doesn't have a spiral and then it
64:51 - ends up coming up here to this point and
64:53 - then if this were the assignment maybe
64:56 - this spot here would be where you put
64:58 - your collider that says oh this is the
65:01 - finished you know this is the levels
65:02 - conclusion you've beaten the level so
65:04 - the assignment is with pro builder so to
65:06 - make a level you know it doesn't have to
65:08 - be anything terribly fancy like i'm not
65:09 - a great designer but it should have at
65:12 - least one section where you're required
65:13 - to jump so some sort of jump puzzle just
65:16 - so that you can you know think about the
65:17 - design of your level a little bit
65:19 - and it should be you know meaningfully
65:21 - large not like it doesn't have to be
65:22 - gargantuan and it shouldn't be small it
65:25 - shouldn't be like 10 meters or you know
65:27 - not maybe not 10 meters but it shouldn't
65:29 - be like you know 10 5 meters large
65:32 - obviously that's very small it should be
65:34 - something that you would consider you
65:35 - know a somewhat sizable level using
65:38 - something of this size is is a fair
65:41 - affair metric
65:42 - so pro builder if you've installed pro
65:45 - builder so by default pro builder is not
65:47 - installed in your project you have to go
65:49 - to the asset store i don't know it's
65:51 - assessor's been a little bit slow last
65:53 - couple of days we'll see if it works
65:54 - quickly looks like it is
65:56 - so if we go to the asset store open this
65:58 - connecting again again being slow
66:01 - okay so if you search for assets and you
66:04 - look just type pro builder it will pop
66:06 - up here and notice that it says unity
66:08 - technologies anything basically that
66:09 - says unity technologies will be a free
66:12 - sort of supplement to unity that you can
66:14 - easily just import from the asset store
66:16 - now it's a little bit cramped the window
66:18 - here
66:19 - but
66:20 - and because i'm in a 720p monitor but
66:22 - you just have to click download and then
66:23 - import in order to import it into your
66:25 - project
66:27 - the distro for portal for assignment 10
66:29 - already has a pro builder and pro grids
66:31 - installed pro grids would be the exact
66:33 - same process just pro grids right here
66:36 - and when you import both of those into
66:39 - your project you'll immediately have the
66:41 - ability to go up to tools and you'll see
66:44 - pro builder and pro grids here and all
66:46 - you need to do is click on the whoops
66:48 - pro builder and then pro builder window
66:51 - and you can see here this nice little
66:53 - widget filled window pops up and you can
66:54 - also dock it here if you want to i
66:56 - actually did on accident but unity makes
66:58 - it pretty nice so you can dock your
67:01 - stuff wherever you want it to
67:03 - and there's a few different things so
67:04 - you can do new shape and a new poly
67:06 - shape
67:08 - the new shape actually gives you like
67:09 - shape templates so here i've chosen just
67:12 - cube by default and it allows you to do
67:15 - stairs prisms cylinder so i just do a
67:17 - stair for example and then we
67:19 - immediately see this like stair mesh
67:20 - here right i can generate the number of
67:23 - steps that i want just by changing the
67:24 - slider i can change the curvature if i
67:26 - want so that it's a rotating staircase
67:28 - and then i can also change how wide and
67:30 - how tall the stairs are
67:33 - and also this inner radius is like how
67:35 - deep the steps are if that makes sense
67:38 - and then
67:39 - all of these together once you finished
67:41 - you just hit build stair and it's done
67:43 - now you have a stair mesh that you can
67:44 - just put anywhere in your level and it's
67:46 - that easy to make stairs
67:50 - before i get into more of the sort of
67:52 - what makes pro builder work i'm going to
67:53 - go ahead and enable pro grids so pro
67:56 - grids is a cool feature
67:59 - it's a cool sorry add-on which will
68:01 - actually lock everything in your scene
68:03 - to a specific grid which you can
68:05 - designate based on how fine or coarse
68:08 - you want the grid to be and what that'll
68:10 - allow us to do is when i move notice
68:13 - that it's moving on the grid right it's
68:14 - not moving in continuous con like sort
68:17 - of a
68:18 - continuous motion it's actually discrete
68:20 - steps
68:21 - and the advantage of doing things this
68:23 - way is that when you're modeling your
68:25 - level or whatnot you know let's say you
68:28 - have a maybe a
68:29 - can or a
68:31 - sort of a diagram or a drawing that
68:32 - you've created you slap it on a texture
68:35 - then a flat mesh in your scene and then
68:37 - you just sort of draw your level on top
68:38 - of it everything will sort of just like
68:40 - map up nice and cleanly when you're
68:42 - creating all your your geometry and you
68:44 - can snap things together and align all
68:46 - in the same axis and it makes
68:48 - creating levels like this just a lot
68:50 - easier you don't have to worry about
68:51 - things being slightly off and then like
68:53 - missing vertices and everything sort of
68:55 - be
68:56 - looking a little bit unclean this
68:58 - ensures that everything is very clean so
69:01 - again just notice the discrete steps
69:02 - that it's moving these are all locked to
69:05 - the grid here
69:07 - and so you can change
69:09 - all the settings here as to like how
69:11 - large it is
69:12 - uh if i create a
69:15 - cube so i'm going to go ahead and create
69:17 - a new cube i'm gonna build it
69:21 - notice up here
69:23 - these four buttons are sort of like the
69:26 - modes with which we can interact with
69:27 - our cube
69:28 - and this is very similar to what you get
69:30 - in 3d software like blender maya or
69:32 - whatnot you choose vertices with the
69:35 - left mouse and you can hit shift to
69:37 - select multiple and then you can just
69:38 - move it and since i'm using pro grids
69:40 - it's snapping it to the to the grid
69:43 - right
69:44 - so if i turn off pro
69:46 - grids should just be continuous like
69:49 - that and so you can get whatever sort of
69:51 - angles you want
69:53 - um
69:55 - depending on what your your use case is
69:57 - so i'm going to hit command z
69:59 - if i click on the face mode and i click
70:01 - this face and i shift click it'll
70:03 - actually extrude it and make a new face
70:06 - and i can keep doing this uh
70:08 - sort of over and over again about to
70:09 - zoom out a little bit so i can see a
70:11 - little bit better and i extrude that
70:14 - and then i extrude that
70:17 - right starting to build up something
70:19 - right it's not beautiful but
70:22 - it's something i can extrude that again
70:26 - right
70:27 - i believe i can scale as well
70:31 - so you can build it out like that
70:34 - you can and i haven't spent a ton of
70:36 - time mastering how to use the tool and
70:37 - all the ins and outs of it but it is
70:39 - very
70:40 - i think useful
70:42 - if you're looking to get into sort of
70:44 - level design and you want to
70:46 - avoid the overhead of you know dealing
70:49 - with third-party software like blender
70:50 - or maya and having model files that
70:53 - you're sort of importing and exporting
70:55 - it can be kind of a pain
70:56 - however
70:57 - if you want to export models
71:01 - you can definitely do that so there is a
71:03 - method here forget which one it is
71:05 - offhand i think it's this one
71:08 - no it's one of these allows you to save
71:10 - the model i don't remember exactly which
71:12 - one it is
71:13 - is it this one
71:18 - the menu is a little bit cramped here so
71:20 - i'm gonna actually blow it up
71:24 - yeah yeah offhand i can't recall which
71:27 - of these allows you to actually export i
71:28 - don't have the icons memorized yet
71:30 - because it's a fairly new tool but one
71:32 - of these will allow you to actually
71:33 - export the object as fbx or obj whatever
71:37 - your software is that you end up wanting
71:39 - to
71:41 - uh
71:42 - so you can just go also go up here to
71:44 - the export
71:45 - menu which is a lot easier to see
71:47 - everything by name and you can choose
71:49 - how you want to export you can also
71:50 - export assets too for your for your game
71:52 - so you can have objects in your scene
71:54 - that pro builder will generate for you
71:55 - so you can create prefabs that way
71:58 - but then here's like obj so that you can
71:59 - export it to your
72:02 - 3d renderer 3d software of choice
72:05 - this is relevant for situations where
72:07 - for example you want to like rig and
72:09 - model and animate a mesh
72:12 - you can't do any sort of rigging in pro
72:14 - builder but you can do that in through
72:16 - other 3d software so it makes sense to
72:19 - export it that way you can also create
72:21 - the model here export it rig it and then
72:23 - re-import it if you want to
72:25 - and that's relevant
72:28 - this is a usable scene as is right now
72:29 - the lighting gets a little bit messed up
72:31 - notice here when you mess with stuff but
72:33 - that gets fixed
72:34 - there's a little sort of meter here
72:36 - where it does some calculating and by
72:38 - default it'll actually bake lighting on
72:40 - all of your objects but as is this will
72:43 - perfectly collide with with um
72:46 - with any characters that you have so i
72:47 - have a fps character i'm gonna bring
72:49 - this guy up let's go ahead and set the
72:51 - transform
72:52 - up here
72:55 - just put him in the right position
72:57 - and pro grids is like attaching that
72:59 - like sort of making that grid visible
73:01 - next to where i am and you can set the
73:02 - access for that
73:05 - currently i have it actually disabled so
73:07 - if i enable it now
73:09 - this will actually move in increments
73:11 - see
73:12 - and it will snap it to the grid
73:13 - perfectly
73:15 - but
73:16 - now this as soon as i hit play i'm
73:18 - actually going to close this
73:21 - i should just be on this mesh up here
73:24 - yep
73:26 - and so this is just part of the scene
73:27 - now like as if you had made it in
73:29 - blender or maya or whatever i should
73:31 - jump down to my actual level
73:33 - and then explore it a little bit this is
73:35 - all just
73:36 - haphazardly
73:38 - created you know oops stairs and
73:42 - other meshes and stuff
73:45 - and so you know make it all the way to
73:46 - the top oh i fell down
73:49 - i'm also horrible at playing games but
73:51 - this is the you know the beauty of it is
73:54 - you can just play it instantly right
73:56 - um
73:57 - right out the gate
73:58 - now another cool thing uh that i'd like
74:01 - to showcase is
74:02 - we talked about gray boxing earlier um
74:05 - for making interior levels gray boxing
74:07 - is the purpose of making levels and
74:08 - testing for playability um the cool
74:10 - thing about pro builder is that it has a
74:14 - an invert normals feature which i think
74:16 - is just
74:18 - general in like generally accessible in
74:20 - 3d software
74:23 - i don't know off hand which menu it's in
74:27 - actions geometry
74:31 - do you have the right things selected
74:32 - all right i'm going to open up the pro
74:33 - tool pro builder
74:35 - window
74:36 - and then one of these is invert
74:42 - uh
74:43 - invert selection
74:45 - uh sorry wait
74:49 - flip normals there we go
74:51 - and so what this does is now this is an
74:53 - interior level
74:55 - so all we did before was you we made a
74:57 - sort of like
74:59 - polygonal
75:00 - creation
75:01 - of arbitrary
75:03 - you know size and shape if you invert
75:05 - the normal so recall every like 3d
75:07 - polygon 3d surface as a normal and
75:09 - whatever direction that's facing
75:11 - going the opposite way going towards
75:13 - that normal is what gets rendered but
75:15 - behind it if you're going in the
75:16 - opposite direction of the surface normal
75:18 - it's invisible
75:19 - and so the effect of that is if we flip
75:22 - all the normals of something that is
75:23 - convex
75:24 - we get an interior scene and if we're
75:26 - looking at it from the outside it looks
75:28 - a little bit weird right like we can see
75:29 - into it
75:31 - right and this is something that you
75:32 - might see like in minecraft for example
75:34 - when you're looking in part of the
75:35 - geometry that you shouldn't be able to
75:36 - see you can you can clip through the
75:38 - world and see all the other like
75:40 - interior parts of the world
75:42 - um because you've basically gone beyond
75:45 - the surface normal of that polygon and
75:47 - uh you're only seeing the the from that
75:50 - perspective all the the surface normals
75:53 - of polygons that are facing in your
75:54 - direction in that way but often you'll
75:57 - allow you to look straight through all
75:58 - of the other sort of uh cubes that are
76:01 - along the way because you're looking at
76:02 - all the rear of their the inverse of
76:05 - their surface normal you're looking in
76:06 - that direction
76:07 - and so again only one direction can a
76:10 - polygon be lit at once and even if we
76:13 - look at it from the top you can see that
76:14 - as well we're looking at it from the top
76:16 - flip the normals
76:18 - it becomes a sort of concave or a convex
76:22 - 3d object flip them now it's an interior
76:24 - level right so i'm actually going to go
76:28 - into this
76:29 - and i'm going to flip the normals again
76:30 - i'm going to click on this
76:33 - uh oh i would have to click on a lot of
76:35 - these actually because it
76:37 - split up the mesh
76:39 - but it's gonna be easy enough i'm
76:41 - clicking all the top surfaces of this
76:43 - and making sure i didn't get any on the
76:44 - other side on accident i did not
76:46 - i'm going to extrude this
76:50 - and then i'm going to flip all the
76:51 - normals
76:52 - and then i'm going to take my fps
76:54 - controller
76:55 - which is here and actually i think it's
76:57 - already inside which it is i'm going to
76:59 - hit play
77:00 - the lighting i'm not sure if it'll be
77:02 - messed up
77:04 - it is messed up because in the middle of
77:06 - calculating a bunch of stuff but now
77:07 - i've created an interior level right
77:09 - with the weird mesh that i had before
77:11 - and so if you make your if you sort of
77:13 - make the building of your level sort of
77:16 - you know this concave thing
77:18 - and then you flip all the normals you
77:20 - can create an interior scene very easily
77:22 - with ceiling and everything else
77:23 - normally otherwise it would be kind of a
77:25 - pain in the butt but makes it super easy
77:27 - to do with pro builder and there's a lot
77:30 - of other features
77:32 - a material editor for one so with the
77:34 - material editor you can actually
77:36 - designate specific materials so in this
77:38 - case i've created a couple of materials
77:39 - a brick texture here and a marble
77:42 - texture which is just i took some
77:43 - textures created material
77:45 - made the albedo component of those
77:47 - materials that texture
77:49 - and what that allows me to do is i can
77:51 - select an arbitrary face so in this case
77:53 - i'm going to choose these faces
77:55 - and i can just click on this brick
77:57 - texture
77:58 - and now these are textured as that brick
78:01 - right it's not applying it to the entire
78:03 - mesh it's just applying it to whatever
78:04 - specific face that we want to and
78:07 - there's a uv editor which will allow you
78:08 - to actually take the mesh of your model
78:12 - in this case this is this is our entire
78:14 - mesh here just remember as we talked
78:16 - about it last week everything gets cut
78:18 - out and made flat so you can sort of see
78:21 - if you remember the shape of what we're
78:22 - dealing with all the polygons that we
78:24 - were
78:28 - that comprised our sort of weird large
78:31 - object they're all now splayed out for
78:33 - us so we can just very easily
78:36 - take a texture and just like put it
78:38 - wherever we want
78:39 - on here now i don't have a
78:43 - ton of
78:44 - experience using this so i'm not 100
78:47 - confident my ability to uv map something
78:49 - right now in front of you but
78:51 - uh
78:52 - the documentation on the pro builder
78:54 - website goes into detail as to how to
78:56 - use this so if you wanted say
78:58 - a specific texture to be like in part of
79:00 - the mesh and then maybe another texture
79:02 - to be on another part of it in a
79:04 - specific like welded way that's not like
79:06 - just splat onto it
79:08 - the uv editor will help you with that
79:10 - for example a face on a character model
79:12 - or something else
79:15 - but yeah or maybe like a sign on a door
79:17 - somewhere or something like that you can
79:19 - do that all here just click and drag all
79:22 - the faces the faces are actually
79:23 - interdependent like dependent from one
79:25 - another so that you can lay them out in
79:27 - a way that fits the texture that you are
79:29 - trying to map everything to
79:32 - that is um
79:34 - pro builder in a nutshell there's a lot
79:36 - of features um we don't have time to
79:38 - cover
79:39 - all of them and i mean frankly i don't
79:42 - know all of them super well yet um just
79:44 - because the technology is so new but
79:46 - it's
79:47 - i think this is going to be a huge part
79:49 - of like unity's future and like making
79:50 - it accessible for people that would
79:52 - otherwise have maybe been turned off by
79:54 - the idea of modeling their level
79:56 - geometry or their object geometry um i
79:58 - mean certainly for me now this this just
80:00 - makes me want to make a game in unity
80:02 - like right now just because i know i can
80:04 - instantly just like start creating my
80:05 - levels right like it's just nice and
80:07 - easy and convenient and pro grids you
80:09 - should use definitely use pro grids in
80:11 - tandem with pro builders so that you can
80:13 - optimally rearrange things in a way such
80:16 - that they're all like evenly lined up
80:18 - with each other
80:20 - otherwise you're going to end up with
80:22 - issues in like manipulating their
80:24 - position in a very specific way and like
80:26 - coming up here and setting their values
80:27 - manually and that's just kind of a pain
80:29 - so much easier just to snap everything
80:31 - to the grid the pro pro grids
80:33 - and
80:34 - deal with it that way and so the
80:37 - assignment is yeah largely just going to
80:40 - be
80:40 - take the
80:44 - pro take pro builder and pro grades and
80:45 - just like make a level with it and then
80:47 - just like take the principles that we've
80:48 - learned create a controller create a
80:51 - collider and just make a very simple
80:53 - scene
80:53 - um
80:55 - and otherwise probably spend your time
80:57 - focused on your final project
81:00 - so any questions as to pro builder how
81:02 - it works how to get it set up
81:13 - uh no it'll actually it'll it should
81:15 - flip through it um
81:17 - let me
81:19 - go ahead and put this up here it
81:21 - actually actually it might not i think
81:23 - it does still trigger collision but
81:25 - you'll still you'll just be able to walk
81:26 - you'll just be able to see through the
81:28 - um
81:30 - through the
81:32 - yeah just a visual it's just a visual
81:34 - bug it's a lighting bug the physics
81:36 - should still apply i'm going to go ahead
81:37 - and set the
81:39 - model up here
81:44 - okay hit play
81:50 - uh no actually look like it went through
81:52 - it so i think it so it also inverts the
81:56 - collision the collision box yeah
81:59 - i've seen some games where you can
82:02 - clip through something and still collide
82:04 - with it
82:05 - so i think it depends on ultimately the
82:07 - engine or the implementation that you're
82:08 - using but in this case
82:11 - when you flip the surface normals here
82:13 - of this mesh it also flips the box
82:15 - collider the mesh colliders normals yeah
82:27 - precisely yeah if you wanted you could
82:29 - have a you could make a copy of the
82:31 - um interior make it you'd have to make
82:33 - it you make it the same size i suppose
82:36 - um and then flip it's and not flip its
82:38 - normals such that you have a shell and
82:40 - an interior yeah absolutely
82:43 - um yeah generally i don't think you
82:45 - would i mean yeah it depends if a lot of
82:47 - interior levels you'll never ever be
82:49 - outside of their boundaries and so you
82:51 - don't often see that happening but it's
82:54 - very much the case that you could have
82:55 - that happening and if you have like a
82:56 - house model for example then yeah you'll
82:58 - often you'll actually see house models
83:00 - are modeled with walls that are two
83:02 - planes so there's a bit of thickness
83:05 - it's actually a rectangular
83:07 - shape so it allows you to have a
83:10 - collision on one side and another side
83:13 - because both there's two planes of
83:17 - the collider rather than just the single
83:19 - plane which is the direction of the
83:21 - surface normal
83:23 - any further questions on pro builder
83:25 - yeah
83:31 - because the bottom surface normal is
83:32 - pointed upwards so this this right here
83:34 - is pointed upwards but notice that here
83:37 - the surface normal is actually pointed
83:38 - down
83:40 - so you can only collide with the
83:41 - direction of the surface normal that's
83:43 - facing
83:44 - you
83:45 - if that makes sense you can walk you can
83:47 - walk through
83:48 - you can walk towards the direction of
83:50 - the surface normal but not
83:51 - like against the surface normal if that
83:53 - makes sense that's the way that unity
83:55 - calculates its mesh renderer component
84:05 - you could go through from this direction
84:08 - but you could not go through this
84:09 - direction
84:11 - because this direction the surface
84:12 - normal is pointed this way right
84:15 - so if we try to walk against it we'll be
84:16 - walking against the normal and so we
84:18 - won't be able to uh we won't we'll we
84:20 - will trigger a collision but if you're
84:22 - walking through it and such that you're
84:23 - going the same direction as the surface
84:25 - normal so if you're coming from this
84:27 - direction
84:28 - then it won't detect a collision
84:30 - does that make sense yeah
84:32 - yeah
84:33 - what tawny suggested which was to make a
84:35 - shell around it would solve that problem
84:37 - so if we created this this exact mesh
84:39 - duplicated it and then inverted it then
84:42 - we would have two of the same object but
84:44 - with normals going one direction and
84:46 - normal's going the other direction such
84:47 - that the mesh renderers
84:49 - account for both potential movement
84:51 - directions
84:53 - cool
84:54 - all right any further questions on
84:57 - pro builder again not to meant to be a
84:58 - comprehensive tutorial there's videos
85:01 - um
85:02 - and documentation that i've linked to in
85:04 - the slides but more just to illustrate
85:07 - how awesome this tool is really and that
85:09 - this is probably going to save some
85:11 - people doing unity projects sometime if
85:13 - you're doing any unity
85:15 - like if you're doing any asset modeling
85:17 - i should say or level modeling
85:20 - another thing that
85:23 - we didn't i didn't make a slide for but
85:25 - which i talked about in class
85:27 - was shader graph and so what shader
85:29 - graph is is another
85:32 - 2018.1 feature which allows
85:35 - rather than having to write shaders in
85:38 - shader lab which is unity's shader
85:40 - language
85:41 - which can be quite
85:43 - quite an experience quite intimidating
85:46 - you can actually create them now with
85:48 - this node-based programming language not
85:51 - really programming language but this
85:52 - node-based programming environment i
85:54 - should say
85:55 - which will allow you to choose all these
85:57 - preset nodes that influence the shader's
85:59 - behavior
86:01 - and there's a lot of different kinds
86:03 - and have the result of that
86:06 - be you can see your shader every step of
86:08 - the way so the shader is just a series
86:10 - of transformations going from left to
86:12 - right
86:13 - in one direction
86:15 - all of these sort of transformations you
86:17 - can see how they end up accumulating to
86:20 - produce this final effect in which case
86:22 - here
86:23 - if it may be kind of hard
86:24 - hard to discern is a sort of marine guy
86:28 - with these blue holes that are actually
86:30 - like masking his mesh and we talked
86:32 - about masking earlier this shader itself
86:34 - looks like it's applying a mask with
86:36 - this
86:38 - noise that it's generating and it comes
86:40 - with noise generation functions
86:42 - generation nodes which will allow you to
86:44 - feed those into sort of like the mass
86:46 - component of your shader and then
86:47 - produce some very interesting cool
86:48 - effects otherwise this would be
86:51 - kind of uh
86:52 - unless you're like a shader expert which
86:54 - i am not it would be um
86:57 - pretty complicated and non-trivial to
86:58 - implement something like this with just
87:00 - code but this generates code for you
87:02 - such that you don't have to actually
87:06 - write any code at all but you can still
87:07 - see the produced shader that gets
87:08 - created for you from shader lab or
87:10 - shader graph
87:12 - i
87:13 - believe that it's just a
87:15 - asset now i'm not 100 sure i didn't test
87:17 - this going in um
87:25 - hopefully i'm not just missing it
87:28 - supposedly you should be able to just
87:29 - import it
87:30 - i'm not 100 let's see how you actually
87:32 - is it this article maybe uses it
87:36 - via the package manager
87:39 - package manager i think this is a new
87:41 - window package manager so we go to
87:43 - window and then package manager
87:51 - and then
87:52 - all
87:56 - and then shader graph yep so right here
87:58 - so window and then package manager and
88:00 - then shader graph and that will allow
88:02 - you to
88:04 - import
88:05 - the
88:06 - means to which by which to create these
88:09 - sort of graph layouts
88:11 - if you're using 2018.1 which the course
88:13 - is using but if you're at home and
88:15 - you're using 2017.4
88:18 - then
88:20 - update to 2018.1 and you should see this
88:22 - in your package manager
88:24 - and then once you do that you can create
88:25 - a you can actually create a new shader
88:27 - graph object and then you'll see it as a
88:29 - new window that pops up in your scene
88:31 - and then you can start adding nodes
88:33 - i don't have any material prepared for
88:35 - it and i didn't anticipate talking about
88:37 - it necessarily but it's
88:39 - something that seems to be very game
88:41 - changing and something unreal has had
88:43 - for a long time that sort of
88:44 - differentiated it from unity in my
88:45 - opinion
88:46 - and it's i think a very valuable thing
88:49 - that they've added
88:50 - that shows a lot of awesome progress for
88:53 - 2018.
88:55 - so again a link to brackie's if you want
88:58 - details on how to use not only pro
89:01 - builders and pro
89:02 - pro builder and pro grids but a lot of
89:03 - other awesome features of unity and to
89:05 - do a lot of cool stuff he makes some
89:07 - really cool videos
89:08 - um assignment 10
89:10 - so assignment 10 is going to be creating
89:12 - a level with pro builder just to get
89:14 - your hands wet with it um
89:16 - the level should be
89:17 - pretty complex so not like i said
89:19 - earlier not like
89:21 - a finished game level like i'm not
89:24 - expecting you to do awesome amazing
89:26 - incredible things but a level that has
89:28 - maybe you know a few pieces of
89:30 - interesting geometry maybe generate some
89:32 - stairs generate some it has some pipes
89:34 - you can generate and some other things
89:36 - um have a jumping puzzle in there so
89:40 - this this says there should be one
89:41 - jumping puzzle for the player the
89:42 - assignment doesn't officially say it yet
89:44 - but i'm going to make the change to make
89:46 - it say that there should be a jumping
89:47 - puzzle you can interpret this however
89:48 - you want
89:49 - just a couple platforms is fine but
89:52 - honestly whatever whatever you would
89:53 - like
89:55 - um and have two different textures or
89:57 - materials so you can create just an easy
90:00 - pers like just import whatever texture
90:01 - you want or you can go to a website that
90:03 - allows you to procedurally create a
90:05 - texture and
90:07 - you can assign it to a material put it
90:08 - in the material editor of pro builder
90:10 - and then use that to assign it to a face
90:12 - or to the whole object if you want to
90:15 - but it should be at least two not the
90:17 - default so to make it a little
90:18 - interesting use many more if you want to
90:20 - but only two required
90:22 - um
90:23 - so there this should be kind of like a
90:25 - complete scene so
90:27 - uh make a new scene separate from the
90:29 - pro builder scene separate from the
90:30 - portal scene
90:31 - include an fps controller so that we can
90:34 - move around the scene immediately after
90:36 - creating the mesh right
90:39 - but that's it you can just use the
90:40 - default controller you don't need to do
90:41 - anything fancy and then at the very end
90:44 - you should have a trigger on a collider
90:46 - somewhere which should probably it can
90:47 - be invisible it doesn't have to be
90:48 - invisible you can make this whatever you
90:50 - want you can make like an arch or
90:52 - i don't know your imagination is uh
90:55 - you're free to use your imagination as
90:56 - much as you want but there needs to be
90:58 - some collider
90:59 - whether it's invisible or not at the
91:01 - very end and a trigger it needs to be a
91:03 - trigger and then when you collide with
91:05 - it it should say level complete on the
91:07 - screen so just take a text object from
91:09 - unity2d part of the canvas and just drag
91:12 - it if you just add a ui text in the
91:15 - scene it'll automatically add a canvas
91:16 - and an event system for you
91:19 - create the label and then just set it to
91:21 - on or off depending on whether or not
91:23 - you've collided with the trigger there's
91:24 - code for this in the helicopter game in
91:27 - the game over text script you can see
91:30 - exactly how this is done um all it
91:32 - effectively is is setting the color of
91:34 - the text to zero zero zero zero versus
91:36 - zero zero zero one or whatever color you
91:38 - want to effectively just to change on
91:40 - the alpha component of the text color um
91:43 - and then once that's done then you have
91:45 - a complete assignment and then you can
91:46 - spend more energy hopefully this should
91:48 - only take maybe an hour maybe less
91:51 - you can spend more energy on your final
91:53 - project which will be due on the 11th
91:57 - but all together it's been an awesome
91:58 - pleasure teaching this course and i'm i
92:01 - hope that a lot of you were able to
92:02 - learn a lot of interesting things and
92:03 - hopefully we're inspired to create some
92:05 - of your own projects and we'll continue
92:07 - to create some of your own projects in
92:08 - the future um
92:10 - i certainly enjoyed making a lot of the
92:12 - stuff and i especially super mario
92:13 - brothers i think that was my favorite um
92:15 - but this was
92:17 - gd 50. so thank you so much

Cleaned transcript:

all right welcome to gd50 this is lecture 10. today we'll be talking about portal so uh portal's a very iconic game i think most of us have probably seen it before the gist is you have a portal gun a gun that shoots just these elliptical portals if you look through one you can effectively see what's sort of coming out the other one which is pretty cool and vice versa and then if you walk in between the portals you'll actually be teleported to the other side and so they achieve a lot of really interesting effects with some pretty cool um tricks and stuff and actually valve themselves will be coming to give a talk on a lot of the technology that they used um on the second so we can get a glimpse into their version of portal my version of portal is a bit simpler but we'll look at a lot of the same sort of principles and see how i accomplished a lot of the same things so this is also the last lecture of the semester and we've covered a lot of ground i have a few screenshots here to show some of the games that we've talked about you know the very first game was pong and we've come sort of a long way we've gone through um very simple sort of arcadey atarilike games like this and you know have gone and created worlds effectively and you know now we're in 3d we're doing all kinds of awesome stuff but these this is where we started the course um and it's kind of fun to look back and see where we've come so you know here we talked about scoring and just effectively drawing shapes onto the screen then we transitioned to flappy bird or 50 bird and you know we had sprites and characters and we talked about scrolling and infinite level procedural generation type algorithms and that was fun um we took things a step higher than that with breakout where we had the same sort of procedural ideas in the context of a very famous arcade game we talked about particle systems and um some arcade style physics and high scores then we went into puzzle games we talked about match three and how to actually calculate what goes on uh uh to determine whether we've gotten a match and how to clear blocks and how to tween things do operations over time so this asynchronicity um then we went into probably what is my favorite lecture which was super mario brothers and we talked about how to create procedural worlds that all look very different with some very simple algorithms and then we had triggers and um events sort of happening then legend of zelda came and we had this infinite dungeon algorithm and we had enemies walking around that we could use a sword on so it felt more like an actual action game action rpg then we took a look a brief look at physics in the context of box 2d with angry birds and i still remember the like ball pit example was probably my favorite part of that and then um probably the most complicated example of the semester was pokemon where we actually had a full a semifull turnbased battle system and random encounters and like a little world where there's actually two main stages to our world where there was the field and the battle scene which is a very common thing to have in rpgs following pokemon which was the most complicated code base we went into unity which was our first foray into 3d and even though we were just exploring 2.5 d we still got a chance to look at you know how does the unity engine work and how do we get actual 3d models onto the screen and we put together a very simple flappy birdesque game so that we can sort of recycle prior ideas last week we looked at dread50 which was sort of a dread halls horror inspired game where we got to look at lighting and how to actually transition between scenes and use some basic ui in unity and today we'll be talking about how to use how to create a game similar to this although much simpler today is mostly just a tech demo more than anything else but this is a screenshot of the actual game portal and as you can see they do a lot of really cool fancy things they have a portal on sort of a slope they have another portal coming out of the front wall or back there different colors so you can differentiate between left and right orange and blue they have sort of this object here on the side and i believe that's to shoot cubes out which this here is a cube which you can then grab with your gun and then shoot it through portals and see it come in and out of portals which is pretty cool and we'll talk today about how to create sort of a simple version of this primarily just the aspect of how do i create a portal that looks out of another scene and see it updating in real time um and how do i teleport and get back back and forth between the portals and carry a weapon and then shoot a ray that'll actually place a portal where i want to in the game world so today some of the topics we'll talk about so one holding a weapon so we've had we've used a first person controller and this is a very easy and simple thing to do but it helps illustrate what parenting is and so we'll talk about that ray casting is the actual shooting out of ray from your object's z direction forward so you have an x and a y which are sort of the angle at which you're moving around but then you have z which is always if you're using vector of using the forward vector from your character it's going to be forward from the in the z axis wherever you're looking effectively and so that allows us to um we can cast a ray in that in that sense which just means you know shoot a straight line an invisible straight line from that point and wherever that point intersects with an object we can get some information about that and then do whatever work we need to do in this case take a portal prefab and just like affix it to the wall basically rotate it from its default position and then just like put it flat up against a wall texture mask masking is uh sort of how we're going to achieve this portal effect right because when we when we create what's called a render texture in unity which here's the third bullet a render texture just means a texture that we are rendering to with a camera so rather than have a texture be an asset in your game in your hierarchy with something that you've made in photoshop you can actually dynamically create it at runtime with a camera what the camera is seeing and unity gives this to you for free very easily with what's called a render texture which is just another asset type and then texture masking is effectively sort of kind of the same thing as stenciling where we can choose certain pixels of an object to delete in this case we create a texture that's white in the center and then black around the edges in a sort of elliptical shape and what that allows us to do is tell it with a simple shader don't render these pixels when you actually render the render texture just render the ones in the middle and so that's how we achieve an ellipse just by effectively discarding the pixels on the outer rim decals uh are is an idea in 3d games where a decal is just something that you have fixed a texture or some object that you fixed to a surface in this case we'll be using decals um to act as our portal so our portals are actually just going to be decals they're just meshes with a render texture affixed to them and then all we need to do is just sort of slap them onto a wall whenever we shoot it and we get a ray that intersects with the wall and that'll have the effect of um actually making it look like we're putting a portal on a wall when in reality we're just taking a mesh and we're just kind of like slapping it onto a wall some other examples of decals that you've probably seen in other games are for example bullet holes which use the same principle teleporting is very easy although the fps controller sort of complicates things a little bit so we'll talk about how i went about sort of solving it sort of solving the problem of teleporting in a way that makes sense it's usually just as simple as a change on the you know setting something's transform's position to another transforms position setting the rotation to the transform's rotation um but the fps controller caches its rotation data so in order to do that teleport cleanly you sort of have to override some default behavior and lastly we'll take a look at some new tools that unity has introduced with 2018.1 pro builder and pro grids which allow you to actually model geometry in the scene and this is what the assignment is going to be focused on um because going forward it's probably i foresee it being a major part of sort of modern unity development and or prototyping the ability to model your scene in unity without needing a third party program heavily optimizes the actual creation process and allows you to do easy what's called gray boxing meaning create a level for like you know to create a level in your game engine and then prototype it test it make sure that it's actually game playable right off the bat that's called grey boxing but first let's get a demo so does anybody want to come up here and play my implementation of portal mr james is landlocked all right james you're not landlocked let's go all right so i'm going to go ahead and set that up and so disclaimer there's actually a bug in this as well so i'm curious to see if you can spot what the bug is go ahead and hit play as soon as you're ready and then the mouse on the right will be your sort of angle of your portal so we see here i have a character with a portal gun created so if james if you shoot a wall with the left mouse that'll create a portal and then they've used the right mouse so that's one other bug so let's go ahead and restart the program actually um so that's one bug and so um if we avoid stepping into a portal that's there and this this could be fixed in a couple of ways so now you have a so okay so now you have two portals basically created do you see what's wrong with the the portal as it is here are both of these portals actually oh actually no i'm sorry these portals are actually completely right but walk through them and i will show you okay so you can see it works it works pretty well right you you can not only see your character rendering completely or moving in real time when the other texture but you can you can jump through them or walk through them you can jump with space bar if you want and that will teleport you out the other end so you see from the perspective of the other portal but if we try shooting one of the other walls for instance like the one of these white walls you can see something weird happens with this particular wall anything strike you as odd about that portal anybody it's upside down and so if you walk through it though it works perfectly fine now the reason that it's upside down um i spent probably like 10 15 hours trying to debug why this is it's in a state of what's called gimbal lock so this prefab right here there's three axes of rotation in 3d space and if you perform a rotation in some odd way um there are these things called euler angles which are your angles of rotation about the x y and z axis and you can sort of think of it think of them as sort of being able to rotate and interdependently but there is a situation in which you can for some reason unity's internal representation of a rotation can get messed up by manipulating these angles and so you can actually lock two axes together such that um rotating like for example in this case it's z and y they both rotate each other and so you're unable to get in this particular case the um portal to rotate about the axis that lets it like look like it's right side up based on the walls surface normal and so um had i maybe another week it probably could have debugged it but i had to leave it in unfortunately i ran out of time but if you don't the interesting thing is if you do shoot that same wall so try and shoot that wall the other wall with the like put both put one portal on the on the buggy wall so the right wall it's only that wall by the way for some reason so um that wall is a bit so notice that now it's right side up so if you shoot both portals on the same wall that buggy wall they do get right side up and i for the life of me couldn't ascertain exactly as to why i know it's gimbal lock unfortunately i was unable to debug it quite in time but every other wall including the ceiling and the floor will work if you shoot a portal up on them so you can create one up there and then you can jump through it see how it's looking down and it'll sort of put you at the top and all together minus the weird single wall that gimbal locks the portal we have a pretty functional implementation of a very basic portal game right we have a this model here is parented to the camera so it's always going to look in the exact same direction as the camera we shoot a ray from the tip of the gun and then whenever that ray intersects with a plane in this case any of these walls we get the information about the intersection and we flip the decal the portal decal such that it's the same angle as the wall rotation and then what happens when we actually collide with one of the portals just in code if we were to think about how to implement like the behavior that goes on here it's transporting the player and it's doing effectively setting the player's transform position to the same transform position as the portal now if we do the same thing on the rotation the player ends up getting a bits the fps controller's rotation gets a bit skewed if you mess with its x and z rotation the default controller so all we do for now is we just we keep those values the x and y rotation but we just change the y rotation y rotation is this position in space like this effectively so that allows us to get when we jump out of the wall we notice that he's you know sort of like flat from it but if we jump through any of the wall portals so if you like create a portal on the wall here and then jump through it you'll notice that you sort of get a you know you're sort of angled at the right um and the reason that it's skewed is because this one's upside down and so it flips it's flipping the camera that's rendering the texture and it's looking a little bit weird but when you jump through um it basically keeps your x and z but rotates your y position such that you come out looking as if you went straight through the portal rather than um by default it has you look like a look back at the portal that you came out of which is a bit weird or whatever direction you were walking through it when you went through the portal um that's just default so it's rendering a it's a render texture so there's a camera actually behind each of these portals so the prefab is a mesh with a render texture and then behind it there's a camera and so the camera is rendering in real time what's in front of the portal basically from behind it and so it's seeing your model from both of these portals both cameras are seeing your model and so it shows up in the render texture on the other on the other um on the other portal so it's effectively like looking at two video cameras instead of a portal it's a sort of a trick and this is a very crude implementation of portal the actual game uses a much more sophisticated algorithm for um and it also uh tracks your position with the camera so that like based on your angle of rotation you'll actually see something different on the on the texture there but it's a lot more complicated to put something like that together i have some resources that i've included um in the lecture and the assignment that'll show you actually how to do that um but it would take many many more hours than i had to uh put this demo together yeah it's fixed so if you actually look at it from the side you'll notice that it's like just a flat texture um there's no perspective ultimately it's perspective and um there's an awesome video that i'm going to show later in the slides by a youtuber named brackies where he actually implements a perspective correct shader that allows you to see and with with camera tracking of the player like both cameras will track the position of the player as well as render a texture and the result of that is because the cameras are changing their position it's sort of like changing the angle at which the scene is being rendered onto the portal mesh but also the way that's being drawn is a little bit different and so he has a really cool shader that does that and then valve when they present they'll actually show how they went about doing it which is even more complex but looks really good and is a lot more you know technically interesting but yeah that's my um sort of implementation bare bones implementation of what makes portal work so and it's somewhat it's somewhat fun to like walk through these um you know walk through these portals and just sort of play around with it now um the reason that if you just walk into a blue portal it doesn't work is because the portals are actually stored offscreen until you use them and so a way in which so i'll open up the scene here oh by the way thanks james for coming up to demo i appreciate it so the portals are over here right both of them are right here and so what allow what that does is when you only shoot one of them the other one is still out here so when you walk through it you end up just teleporting outside the level and in order to not have that happen what you really need to do is have a flag on both of them that just says don't teleport unless they've been shot once right and that'll prevent that'll prevent that sort of behavior from happening simple fix um but an entertaining one to take a look at and that is my crude implementation of portal it's uh far from being anywhere near as polished as the actual game um and there is the slight weird wall that gimbal locks the portal um which i would like to figure out why exactly that is but everything else is sort of in here now it doesn't include something like shooting blocks through it but the same sort of principles would apply because all we're effectively doing on the portal is saying it's it's basically a trigger right it's got a box collider on it and it says if i collide with something in this case the player um i want to teleport that collider to the other portal which means that the portals sort of have to link to each other right one portal has to have a reference to the other portal so that it can say teleport to the linked portal and vice versa the link portal should have a reference to the other portals i can say teleport back if you collide with this and so if we have another object let's say we shoot a cube into the portal it would also get teleported to the other portal right and now the other consideration for that is like if it's a rigid body and it has physics applied to it for example let's say it's it's going like 10 on the x and it teleports to a portal that's like perpendicular to it and it's still going 10 to the x then as soon as it shoots out of the portal it's going to go straight left which isn't the behavior we want we want it to go forward so it's like um linear velocity needs to be calibrated to go in a different direction didn't have enough time to put a full demo of that together but if you're curious in a nutshell that's sort of like what you would need to do in order to implement like some basic physics with uh portal so holding a weapon based on the screenshot can anybody tell me how they think i got i went from just a plain fps controller to an fps controller holding a gun did you stick a gun i don't know what do they call yeah there's not really a notion necessarily of pixels um in 3d space because that changes depending on your resolution but yes unity units so um it's effectively equivalent to a meter and you can change what it represents in unity settings um but yeah i mean it's not it doesn't necessarily have to be one unit it can be an arbitrary amount and what it really was was me going into here with this model by the way got this model on the asset store for free so the asset store is an awesome place if you're looking to just quickly prototype your game they didn't have any like obvious portal guns portable lookalikes that looked really good so i was just like oh this gun's got like the same kind of color i'll just choose this like a scifi kind of gun but as you can see there's a hierarchy here now how are we keeping the gun like affixed to where the camera is looking do we know you do the same thing as you do with the first the first person shooter code is you have the camera follow the uh sorry you have the camera yeah the camera followed the gun do we know do you have any guesses as to how we're doing that it's actually a really really simple thing so all we're doing oh stephen you said the cameras like transform like as like you really transform um cut into their guns transform like with an offset in like the same direction but like just some position yeah kind of so set the guns transformed to the cameras transform but just with an offset and that is effectively what we're doing um and in order to accomplish that it's really as simple as just making it a child of that thing so this is the first person character controller it's got a camera attached to it anything that you parent to something or you make a child of something else it's going to have the same transform like changes applied to it including rotation so by making the gun just a child of the first person character which is where the camera is here first person character by the way is just a subcomponent of the fps controller whichever you named the portalgun fps controller here the portal gun anytime this first person character is rotated which is the camera so anytime the camera is rotated it applies that rotation to the portal gun gun here this gun mesh and so that gives you the effect so what you do is you start it off by you know you figure out okay where's the you start off in 3d space like this you're looking at your game scene and you have your character and then you move your gun object around in this case i could go let's go to layouts 2x3 so we can see in real time see this is the game view this is what's going to look like on startup i'm going to go over to my game my editor view here and i'm just going to grab the actual gun component here the gun object i should say go and position it and i can just move it right and so this is how you can like change where your gun is relative to the camera and this is going to affect sort of how it feels right like i could put it here and it's kind of a little lower i could put it here it feels a little weird obviously because it doesn't have a hand on it so it's kind of almost looks like a vr game and that's kind of like what vr games do is they take your hand positions and then they like the gun transform is locked to the basically where your hand controllers are um in this case all i did was i just positioned it i said i like how it looks right here so i'm just going to do that and as soon as i make it a child of the first person character which is the camera it's just going to get all the rotations applied to it so anytime we make any rotations to the camera which i'm doing here it stays exactly aligned with the with the camera this applies to any operation that you do in unity when you make any sort of transform position scale changes they all get propagated down the chain all the objects that are children of an object that get transform operations applied to them will have the same transform operations applied to them sort of like this recursive kind of effect yeah so if you import the firstperson controller right that automatically has to jump and move left and right and then you just move your asset your gun to be underneath that controller it'll correct so if you have if you just import the vanilla fps controller and then just make the gun specifically the gun needs to be a child of this the first person character bit because that has the camera and recall the camera is what's driving our rotation right because we're moving the camera's rotation with our mouse that is ultimately going to determine how the transform gets applied to the gun but yes and so just whenever you're doing anything in unity and you'll do a lot of things where like one thing's movement or scale or rotation should apply to another thing just remember that it's usually just as easy as making it a child of something else so any other questions as to how we've gone about implementing the weapon all right so ray casting so raycasting is a nice feature that unity gives you for free it's part of the physics sort of namespace in unity part of the scripting api and what it allows you to do is effectively look at from whatever transform you're operating at or whatever opera transform you give it as a the source so whatever point you give it as the source you can tell a direction give it a vector as a direction and in this case what we're doing is we're saying transform.forward and transform.forward just means basically wherever we're looking x and y and then straight in the z direction so if you're doing it on a camera it's always going to be exactly what you're looking at it's always going to be exactly forward on the like transform.forward on a camera is always going to be like center of the screen wherever you're looking at and so if we cast a ray from the point of our character or actually we're doing it from the point of our gun to the transform dot forward like a line going from our player to transform its uh the forward vector of its uh character the forward vector of our camera it's going to have the effect of um we can shoot something right we can we can create a raycast and it's like a fix something wherever that ray intersects and it'll be the exact center of our camera view does that make sense so shoot a line from the z your z axis which is your forward vector and then based on how you've rotated the camera x and y are the x and y part of that and z is always forward that'll let you shoot things or cast rays directly in front of you and you can cast rays between any object and from any source point with any sort of direction you want but it's particularly pertinent in the context of how we've shot it from our gun and so here's a screenshot actually what that looks like and so the nice thing about unity actually is it has a function called debug ray or debug.drawray which i'll show you here i implemented it in a function called the a component rather called debug ray so that you can actually see where array is being cast in your scene and eliminate any ambiguity there so you can see draw array transform.position and then we just say transform.transformdirection vector3.forward and then times a thousand just means a thousand units you know from that point and then color.red and so what that'll do is only in the only in the editor view so this doesn't apply in the in the actual game this is just a debug call debug.drawray and so it'll render in the this scene up here just not down here so if we hit play i actually have all the portals rendering a debug gray from their forward transform and from my gun so you can see it there i'm just doing a debug.drawarray with just transform.forward and um using my transform.position as the source point and forward is always going to be notice that the the z arrow it's always always falling the same direction right x and y are sort of changing you know the back planes or like how that's rotated but z is always forward right and so that's the that's the ray coming from our gun and if we shoot a portal there and there i have those also set to um let me pause it so i can rotate the view a little bit i have those also set to draw array from their forward position so those are also drawing array from what's there vector3 dot or their transform dot forward their directional vector um but yeah raycasting it's pretty it's pretty easy just to get um some pretty simple collision tests this way with guns with um a lot of different things but primarily you'll see this used for like calculating whether something is blocking something else like if a car is moving and it detects maybe if it detects another car like in grand theft auto for example and your car is driving down the center of the road or something and it wants to know whether there's a car two units in front of it or something it just cast a ray and see if there's any geometry there from its forward vector right transform.position card opposition and then get its forward vector which will be its z direction and then um it depends on whether maybe your game's top down maybe it's not your forward vector maybe it's your y vector in that case but that'll effectively give you not only that you've got a collision but also tell you where the collision is too which is nice and we do that in the portal gun script where we call physics.raycast so this this is the function by the way to actually do the raycast the interesting thing about raycasting in unity is that it returns a struct object and so you need to declare this hit object which will tell you all the information about the hit so like where it was whether there was a hit to begin with um and what the like the normal was on the surface that it it collided with so the angle at which that sort of plane was projecting out and then you call physics.raycast with a position and a transform direction and then you pass in out hit so out is interesting because out is sort of csharp's way of allowing you to return multiple values to something so out is going to be an object a in this case it's going to be our raycast hit that we declared up here right which is a struct which recall is just a collection of variables like in c or c plus um and out hit just means that normally we pass in these values to the function they don't get manipulated right but we pass in this variable as out which will allow this function to actually change the data inside this this hit variable and so the result of that is hit from this point forward contains all of the information about the raycast that we that we that we just triggered and when we call math f dot infinity that just means um ray cast to infinity which is until you know forever and ever and unity obviously doesn't check infinitely whether something's collided with something it optimizes the right way but you can use that just if you don't want to necessarily specify i want to check two units or five units or a thousand units in front of me i want to just check forever and see if it collides with something in your scene right um and then as you can see here once that once we have detected a collision we play a portal sound we get the right portal and then we set the portal's transform and rotation based upon the hits point and rotation and that's pretty much all that's involved in shooting the gun and you can take a look through here if you want to get a sense of how it works and maybe explore also the raycast the physics.raycast section of the api just to understand what exactly it returns and what you can do with it but in this case this is how we're using it to detect whether we've intersected with the wall so it'll intersect with any sort of mesh and then when it does it'll tell you exactly how it did so that is what ray casting is raycasting has another name for like old school games like wolfenstein the method of rendering was called ray casting where you generate one sort of uh you would generate a ray from every pixel of the screen effectively although it was mostly just every line of the screen and you would just look up and down for everywhere intersected in the scene and then just create draw like a texture there and so that would generate a world that was that looked 3d but you couldn't move up and down because it was always generating all arrays completely forward and so you were locked onto two axes but ray casting is different in unity raycasting is just literally casting a rate in 3d space versus the sort of 2d space that it was casting in games like wolfenstein there's another screenshot of uh normals from our portals casting out rays and i i want to look up and see if i can just find a picture of what wolfenstein look like i'm pretty sure most folks are probably familiar with not the new one yeah wolfenstein 3d so this was this is wolfenstein so old school but this sort of ray casting was different it would go over it would basically shoot rays from every single line of the screen up and down and it would detect based on the level geometry which was very simple level geometry was just basically whether there was a wall there or not true or false kind of like a 2d image and it would draw based on how far away it was that particular point of the geometry it would just draw like pixels from a texture a specific texture at a specific point and they had to interpolate where on the texture it was it was a little more complicated but in case you see wolfenstein or in case you see raycasting used in those two different senses in the case of old school game engines in the case of um uh modern unity sort of raycasting that is what is um involved in that so any questions as to how sort of in a nutshell the raycasting works in the context of our game here so unfortunately no the oculus does not work on mac they do not have mac support and so uh we were unable to get a sort of version of it working we don't have the means to necessarily transport um given how much time we had now getting vr working in unity is actually very easy if i recall correctly i have to just remember the exact menu i had sort of anticipated talking about this before i think it's player xr settings yeah that's how that's what it is so in order to get so it's incredibly easy if you want to do a game in vr in unity and you have a pc out of the box it's very easy just to get it working all you need to go do is go to edit project settings and then go to player and then in the xr settings so unity has like deemed all of its vr ar stuff as xr and you click virtual reality supported here and you have your oculus rift or vive or whatever plugged in it'll just work with the camera like right off the bat right out the gate so it's pretty easy you may have to install drivers on your computer such that your computer knows that you have an oculus plugged in but assuming that's all set up your project will is as easy as just clicking this checkbox hololens um oculus rift and i'm pretty sure the vibe like 90 show the vive i'm not a hundred percent we can we can google it though let's see unity it looks like it does it looks like it definitely does yeah and of course if you already windows pc is very i apologize i thought i totally thought going into the course that unity that oculus worked on a mac um but as of even october they were like it's not going to work on any macbook ever released so only on a pc unfortunately um that said if you do have a pc super easy to get working and it looks like this is actually pretty cool tutorial i haven't looked at this but i tend to like ray i don't know if his name is van der lisch or wenderlich but he makes really good game programming tutorials in general so just you know because we're coincidentally here if you guys are curious i really like this uh website for basic tutorial stuff we have vive um and vive as far as i well vive the thing about vive is you need to install like wall like ceiling mounted cameras in order for it to work so that's kind of out of the equation we have the gear vr but you would need it we would need to export it to mobile and test it and just didn't have i didn't anticipate it not working for mac and so it kind of came up a bit late and so it's on me i apologize but if you are doing a pc game in oculus and you want some assistance i'm happy to like help out it looks like it's very easy just to get working with the default fps controller camera so definitely reach out if you're developing oculus and need some assistance maybe for the next iteration of our next unity course we can have a a big sort of vr day where we bring in all the guns um but yeah back to sort of raycasting and what we were just talking about um shooting array on your z axis based on your rotation um get information from it and then sort of what we do is we flip the portal based on the hit dot rotation of the surface that we collided with and that's effectively all the raycasting that we need to worry about for portal um but the actual making a portal is probably the most interesting part of this whole project and so let's go ahead and go back into present mode so a render texture is the means is a very is a basic it's not a basic means it is the the fundamental way at which we go about doing it and there are various ways to accomplish doing it some that are more technically challenging and look a lot nicer than others i did a sort of simple version of it just to get a sort of proof of concept out of the gate but unity makes it really easy just to get a simple render texture up and running so a render texture is recall just a texture in unity so it's an asset it's an unity asset that you can create the difference between a render texture and a texture that you might have imported from like photoshop or is that a render texture can be rendered to and typically this is used for things like cameras being rendered to it although from what i understand you can render anything to it so you can create procedural textures this way as well but in this example here we're creating a we're essentially creating a screen into which we're looking at the viewpoint of our other portal right from from its forward direction so we can see what what it will look like once we walk out of the portal and go into the next area and so a render texture so i have some for in the slides if you want to download the slides they're here you can see exactly how to create a render texture so literally just create and then render texture that creates a render texture these are the settings that i used for the actual render texture so what will happen do we think if we use like a low res render texture just logically hey let's see what if my render texture was like 200 pixels by 200 pixels and our resolution of our game is like 1080p it won't be blown up because what we're doing is we're taking a mesh and we're affixing the texture to it so it'll just scale to fill the mesh but what'll it look like when it's rendered because it's rendering a 200 pixel texture it'll pixelate it it'll look really like nasty and so in order to fix that problem typically what you'll do a smart way to do it would be to dynamically figure out at run time what's what's the resolution of your game right if it's going to be rendered in various resolutions up to 4k maybe down to 720p and then create a render texture that is the size of your game and then by doing that it'll ensure that no matter what your resolution is it'll always be one to one pixel ratio even if you're right up close to it right it'll fill up your whole screen in this case we went for a simpler method so we didn't have to do any dynamic instantiation of the render texture which you can absolutely do and it is the more robust way to do it but in this case i just chose 1024 by 1024 figuring that that was going to be good enough for demonstration purposes and most of these other settings i believe actually all these other settings are completely default render texture settings the only ones that changed where this is 256 by 256 by default and it just looks really pixelated and nasty especially when you're right up close to it um and then all we need to do so once we've created a render texture right in our in our scene in our assets so here i'm going to go to textures this is where i'm storing all my textures whether they render textures or not i have these two render textures here and so these are by default they're not going to be mapped to anything because they're just there's empty render textures we've effectively allocated them and said something will be rendering to these later but for now they're just empty there's placeholders right they're like blank screens but that tv hasn't been turned on yet in order to actually render to them we go into our first person character sorry not our first person character we go into whatever camera we want to render it to render to the render texture because we're we're effectively taking these render textures and we're rendering a camera view onto them right each of the portals has a camera behind it looking out from it and so we want to take that camera's view and we want to render that onto the other portal's face the other portal's render texture the texture that we're going to put onto it and so all we need to do is say here is my orange portal i have my camera here every camera has a target texture just right out the gate so you can just say okay i'm going to take my orange portal texture my render texture that i've instantiated so it knows that it's going to be able to receive an input source and i'm going to just click and drag it there and it's that simple now whenever you run the game you'll notice that your render texture updates i'm not sure if it updates in real time in the inspector but it renders if you're if you're showing it onto a yeah it doesn't render in the inspector but it will update if you've affixed it to any other surface and so what we're doing is we're fixing it to the meshes that are associated with each portal james did you have a question oh sure the render texture so i just right click and then i go to create and then a render texture right here and that will give you most of the settings that you need to get up and running with it and you can assign it to a camera but the important thing is do consider your resolution for your render texture make sure that it's high enough such that your game won't look pixelated when you're looking at it like pretty close up yep yep and so that'll do is create a link between the two such that anything the camera sees it's no longer going to be rendering to the scene or anything like that it's going to render to the texture and actually i think you can render to the scene and the texture but these aren't rendering um to the scene at all they're the only one rendering to the scene is the first person character because it's the default camera main camera um if it's a high too high of a resolution it's just going to like compress to fit the the mesh whatever it's affixed to and you'll probably run into performance problems but it's not going to break yeah because you're not affixing it to any because your resolution it doesn't really have an effect necessarily on whatever's in your game world and like that doesn't cause any issues um it gets it gets interpolated like unity will just like calculate how to render it to the screen right yeah like game textures generally are very high resolution like four thousand by two 4k textures are often used even if you're running your game in 1080p and now game engine will probably optimize it and like down sample the texture so that it is like actually a 1080p texture and you don't like you're not trying to calculate more draw more than you need to um but unity we'll figure that out for you you don't have to worry about that um but yeah that's that's what a render texture is and that's that's how we are creating this illusion remember everything in the game is an illusion um in this case we're not actually and it's it's obvious in this example because we're not actually because the the textures are flat and there's no perspective correction you can see that it's a texture even if it is slightly convincing from far away like from far away it actually kind of looks i mean i don't know if it necessarily looks real um i mean it kind of does right like you from here it's hard to tell and from here it kind of looks like we're going into another room right i go like that that's the broken wall they go like that right there's a portal there and it kind of looks like it's a real room that we're walking into it's just a resolution but all we're doing is we're just drawing a camera's view onto that texture in real time and if you notice you can see our gun that's kind of hard to see actually um see if i can do it from from there maybe yeah there we i see a little bit better there when we move we can see the gun so we it's we can see that it's rendering in real time and that's the power of a render texture and this allows you to do all kinds of things you can have like you know tv screens in your game that are rendering another part of your scene obviously an example like this where you have a portal looking into another area now if you apply a perspective correction to this whereby your camera actually tracks where your player's position is relative to the portal you can accomplish a much more believable look and you can actually make it seem as if you're looking into another area because the camera is literally moving with your player so the cameras like the the stuff that it's capturing is going to be changing in real time not only just your character's model right the actual angle is going to change and therefore be perspective correct and there's a awesome tutorial that i'm going to link to in the slides that will show you how to go about doing that it's really awesome and so this is what it ends up looking like this is actually before i changed one of the portals had a slightly offset camera angle so you can see here this is like a little bit higher than this one is they even though they should be exactly the same but it's fixed now so so texture masking oh any questions about any of that process before we talk about texture masking okay so texture masking is basically the process so here's a if we just take a plane and we put a render texture onto it that's what it looks like it just looks like it's just a square and this could work fine if you want a sort of a square portal look you don't have to do any extra work but if you want a circle right you can't really create like a circle shaped plane object that doesn't really exist and if and even it did it wouldn't be efficient especially if you want a very smooth plane because everything is triangles and polygons right so if you're if you have a circle it's going to be a bunch of these sort of fanned out polygons especially a very high res circle like one of these that's a very highres circle making a polygon that looks like that is not it's not an optimal way to go about solving that problem right a much more optimal way to go about solving that problem would be to say to designate certain pixels of the t of some texture as being pixels that we want to read and then certain other pixels being not pixels that we want to read and um and therefore produce a the final image that gets put onto a geometry right um and so what we end up doing is creating an image first so it's this image um which is kind of hard to see but it's just a simple sort of can you see you guys see from the akin so it's just a simple oval right it's the exact shape that we want our portal to look like um and the pixels that are white are the pixels that we're going to render and the pixels that are black are the pixels that we don't want to render we want to consider those as black pure zero alpha effectively and using a awesome shader that you can get for free just easily on the unity webpage this is just a masking shader and i'm not great at writing shaders but what this does is turns lighting off first of all what happens if we have lighting applied to our portals it's going to look a little weird right you're going to get like shadows cast onto your portals and that doesn't make sense right because we're effectively supposed to be looking into another another place another area so we have shadows that are being cast onto our thing we're effectively like almost seeing like a glass door on our portal right it sort of breaks the illusion so lighting should be off a lot of these things i'm not 100 on because i'm not great at writing shaders but it's a very simple easy shader that you can grab off of the unity web page and the i think i clipped the url here at the very bottom but i grabbed that off of the unity web page and all it does is it adds onto your material this second image here and it gets blown up a little bit because unity makes any texture that you apply to basically any texture you put into like an image selector will get made into a square shape and our image is not square shaped but what this does is when you pass in this image which is called a culling mask it will basically combine the two images and then cancel out any of the pixels that are black on the on this it'll effectively add the black and white to the alpha of the of the texture pixels right so you can actually make some of these gray and then it'll have the effect of sort of making it half transparent but in this case i only went with full transparent and full hard 255 alpha so we get sort of a crisp outline for our portals and that's what the that's how you end up putting together a um a basic sort of oval shape on something that is just a flat mesh and you can do this with anything anytime you need to sort of take away detail that would make making a mesh extremely difficult or doing really cool effects it's often just a lot easier to create a mask for it and then create use the right shader that's meant to have that mask and then just manipulate that however you need to um and again the link here for the shader is here and then you can use this for pretty much anything you want and result of that is we go from having a square portal to a elliptical portal so pretty nice i didn't have to use a plane but it doesn't really make sense to use anything else um because using a i mean using a cube it would it would create depth we don't want the portal to have any depth really right it should be a flat surface and then when we go through it it's just teleport us to the other surface to make it look sort of seamless i don't think there's any other i don't think there's another choice of geometry that makes sense for this use case no i probably wouldn't um you'd make a cylinder flat and project it and have no depth on it the you would be able to still see the rings on it and also texturing that is a little bit more complicated because then it's going to it's going to you'd have to uv map your both your sort of mask and your regular texture onto that because by default it's going to wrap it weird just because this is just a plain so whatever you texture map onto it's going to be completely flat but a cylinder is going to wrap it around all sides and it's going to look a little bit it's going to look a little bit funky i suppose in theory you could use a cylinder for it but i think it'd be a tremendous amount of work i don't think it would be anywhere near as easy as getting it to work with just a flat plane or a mesh interesting idea though i guess you could theoretically create a cylinder that has if you wanted to like a bridge between two worlds and have one end be one portal and one envy another portal and then be able to walk between them that's a cool idea maybe you can make that work but i think for this the the plane is the right way to go any more questions as to sort of how that works all right so we'll talk about teleporting now so teleporting is pretty easy all we really need to do right is just create a mesh collider on the portal mesh the orange portal in the blue portal and then when that mesh collider if that mesh collider is a trigger right and it collides it detects a collision with something else it's going to we can just define on trigger enter and then with that we can teleport the collider other to the other portal's location so every portal this is the portal component it has a links portal right because we need to know where to teleport the player to the other portal so we need to get no have a reference to its transform whether it's active right because if we allow ourselves to teleport to another portal and another portal like back and forth just without any restraints what do you think is going to happen infinite loop we just get an infinite sort of weird flickering effect um so you need to effectively have like a toggle switch on both portals and say um as soon as i enter a portal i should not be able to teleport back into it right and as soon as i teleport to another portal i should not be able to teleport into it either but once you exit a portal you should be able to teleport back into it and so what that effectively does is we enter a portal it gets flagged as not teleportable right we get teleported to the other portal as soon as that happens this portal can now be teleported into this portal that we're standing in is now flagged as not teleportable and then we walk out of it and we're allowed to teleport back into that one and the other one so it's effectively an on off operation that you have to balance appropriately the actual portal game is a little more complicated because they allow you to walk in between portals this does not go into that level of detail and it's a more complicated problem to solve this example just assumes that you walk into a portal you get teleported out the other end and there's no sort of inbetween state and actually if you're in between two portals there's a replication of geometry which valve will talk about in their talk as well which i think will be very interesting because if you look into another portal while you're in the middle of a portal right you want to be able to see yourself you know in that portal right halfway in and out of that portal so there's a lot of interesting considerations for getting very believable portal systems but ours is a very simple illustration and so this toggle function is all that i have to toggle the function's on and off capability and all it is is just portal active is not portal active and that just flips that flag super easy on trigger enter we effectively cache our position x on the x and z axis so we don't rotate it because when we rotate our x and z on the first person controller by default it causes some really weird buggy behavior based on the way that the fps controller works so all i do is i just cache i cache those positions and then make a rotation on the yaxis and that'll save us that weird um sort of going topsyturvy effect that you'll get if you use the fps controller by default and you do perform rotations on it you'll notice this so i haven't had the time to dig in depth as to how to fix it um but this is the way that i was able to fix it for this example at least is only only allow yourself to rotate on the y direction which is where you're looking in sort of like the ground relative to the ground plane and that'll allow us to rotate based on where we're exiting the portal um at least on the sort of walls that are going up and down and then have that sort of believable effect it doesn't allow us to like jump down into a portal from up above and see us coming down from the other portal which is a cool effect um unfortunately but it does allow us you know sort of to get most of the way there um and so we set our position to the other portals position and our rotation but only the y we get the y and then we set it here using euler angles on our player's transform and then um there's a function that i called that i created called mouse reset which effectively uh just calls init again on the fps controller's um rotation on the the camera and the player and then um that's sort of like the hack that you need in order to so the reason that a lot of the weirdness exists is because the player controller caches its rotation information and so if you perform a rotation on a on your fps controller by hand as opposed to allowing it to happen with the mouse it will immediately reset it back to its prior position and rotation which has the effect of when we teleport from one portal to another um even though we set our direction of rotation to be like outside going in the direction of where the portal is facing we end up having the same position the rotation that we did entering the portal so we end up coming out of portals often just backwards and so that's some that's just a limitation of the first person controller but you can fix that by calling mouse reset which is a function that essentially just calls init again which init is part of the fps controller's mouse look object i won't go too much into detail about it just because it's a little bit arcane and the the source code's in there if you want to take a look and dabble with it but effectively preventing it from caching its uh rotation information and just hard setting it and then recalling the mouse look init function which does the actual setting of the rotation on the camera and the and the player a little bit a little bit weird but that's unity's fps controller and that's how other people are saying to fix it so you could roll your own you could create your own fps controller and probably prevent this from happening but if you want to use the regular fps controller that's sort of the limitation there but it's mostly working and it looks pretty good some more time on end we could probably make it look even better but for now i think it's good so that's teleporting say your position and then set your y rotation override the fps controller's default rotation caching and um we can walk in this portal and then instantly walk out this portal that's what we see so any questions as to how sort of this works in a nutshell or any of the maybe any of the code here in our portal all right so a much better version of the portal at least from the rendering side is this video here so it's bracky's so uh he's a very good he he explains things very well he's got very high quality to his videos uh he creates a bunch of unity tutorials and in this case he created a portal that used a sort of shader and an interesting shader that will only render everything but geometry and also um onto a plane in which case this plane and um does the camera interpolation of the player that i alluded to before which allows us to actually have two so these are two separate worlds in tandem right now so there's this red world here and then this camera is looking at a completely different green world that's completely like set off onto the in the distance that's the exact same geometry but completely colored green as opposed to red and if you look through here it's just completely seamless and the walkthrough is completely seamless and he goes into detail as to how he accomplished all of this if you're curious and he provides you the shader that you can use for free so definitely check that out if that's of interest there's a link there in the video and here's a link to his youtube series if you want to i put some of these in the slack because somebody requested some ai videos and so he has a bunch of different ai videos and a bunch of other really cool series so you can take a look at that if curious and the best version sort of of portal obviously is the portal itself and dave kersher and tajiev kohli are employees at valve who worked on portal and they'll be here on may 2nd to give a talk as to all of the technical sort of things that went behind the scenes and related to rendering and physics and just getting a believable and good and good feeling experience with portal for the actual polished final game that we're talking about so definitely come to that talk if you're curious we're going to take a break and then as soon as we come back we're going to talk a little bit about some new tools that unity has released called pro builder and pro grids um and we'll talk about the assignment and that'll be it for gd50 all right welcome back this is lecture 10. so we talked about portal before the break we talked about ray casting we talked about render textures sort of what those are how easy it is to make those in unity we talked about how to give our first person controller a gun so that we could actually look around and look as if we're holding a weapon we talked about the portals themselves how we're masking out the texture the render texture as applied to a plane and how each of those has a camera behind it so that it can render what is going out from the portal in the direction that it's facing we're going to deviate from portal now and talk about pro builder and pro grids which are two tools that are part of the new unity 2018.1 which will allow us to actually model geometry per the screenshot this is actually a level that i created and that is in the distro it allow us to create geometry in the actual scene view without needing to go into a third party program like blender or maya and have to sort of alternate between the two and import and export you know incessantly not only that but as soon as you model something like this in unity in the scene view you can immediately test it for gameplay and make sure that it actually fits what you want and you don't have to worry about scale issues when you're importing and sort of making it work and figuring out ultimately that oh i don't like the way this mesh this level is let me go and tweak it and redo it it just allows you a ton of ease and flexibility and i made i previously mentioned brackie's before but he's got a couple of awesome tutorials here on pro builder and pro grizz to supplement sort of what we'll talk about today in lecture but if you want sort of more of a showcase of all the features of both then you can look at these videos here and get a sense of how they work so we're going to go ahead and just mess around with pro builder a little bit here in the scene view so that we can see what it looks like i'm going to open up my other scene so i have the portal scene if you're in the distro this is where all the stuff that we've been looking at exists just the portal game there's a pro builder scene as well which i'm going to not save that and so this pro builder scene is the level geometry that i created earlier now it looks pretty horrendous because i didn't spend a terrible amount of time on it and i'm not a particularly talented visual designer by any stretch let me go ahead and make it a little bit larger so we can see it a little better but it showcases some of the interesting features so we see you know we have obviously sort of polygonal square shaped rectangular geometry we can see that some faces are textured and some aren't so we can see this face here for example is just white the default material we can see that all of these sort of have this uh brick texture which i got off a procedural generator sorry website that allows you to choose a template for your texture and then you know specify colors and stuff like that i did the same thing for this texture this is another uh procedural texture which is kind of like a blue marbley type texture the cool thing about it is at least for texturing you can just choose arbitrary faces that you want to texture rather than have to texture the whole thing like you would do if you were to just give a mesh a default material it'll apply it to the whole mesh in this case it's just applying it to whatever faces we select in pro builder another interesting thing which i really like is pro builder gives you a lot of tools for creating special kinds of geometry very quickly and efficiently in this case this is a staircase which all i had to do was with pro builder select build staircase and then you can choose a lot of different parameters we'll take a look at how to do that in a second i did the same thing here so notice this this staircase has kind of a spiral to it and then this staircase is really tall but has no spiral and then we have another staircase here which is kind of shorter and doesn't have a spiral and then it ends up coming up here to this point and then if this were the assignment maybe this spot here would be where you put your collider that says oh this is the finished you know this is the levels conclusion you've beaten the level so the assignment is with pro builder so to make a level you know it doesn't have to be anything terribly fancy like i'm not a great designer but it should have at least one section where you're required to jump so some sort of jump puzzle just so that you can you know think about the design of your level a little bit and it should be you know meaningfully large not like it doesn't have to be gargantuan and it shouldn't be small it shouldn't be like 10 meters or you know not maybe not 10 meters but it shouldn't be like you know 10 5 meters large obviously that's very small it should be something that you would consider you know a somewhat sizable level using something of this size is is a fair affair metric so pro builder if you've installed pro builder so by default pro builder is not installed in your project you have to go to the asset store i don't know it's assessor's been a little bit slow last couple of days we'll see if it works quickly looks like it is so if we go to the asset store open this connecting again again being slow okay so if you search for assets and you look just type pro builder it will pop up here and notice that it says unity technologies anything basically that says unity technologies will be a free sort of supplement to unity that you can easily just import from the asset store now it's a little bit cramped the window here but and because i'm in a 720p monitor but you just have to click download and then import in order to import it into your project the distro for portal for assignment 10 already has a pro builder and pro grids installed pro grids would be the exact same process just pro grids right here and when you import both of those into your project you'll immediately have the ability to go up to tools and you'll see pro builder and pro grids here and all you need to do is click on the whoops pro builder and then pro builder window and you can see here this nice little widget filled window pops up and you can also dock it here if you want to i actually did on accident but unity makes it pretty nice so you can dock your stuff wherever you want it to and there's a few different things so you can do new shape and a new poly shape the new shape actually gives you like shape templates so here i've chosen just cube by default and it allows you to do stairs prisms cylinder so i just do a stair for example and then we immediately see this like stair mesh here right i can generate the number of steps that i want just by changing the slider i can change the curvature if i want so that it's a rotating staircase and then i can also change how wide and how tall the stairs are and also this inner radius is like how deep the steps are if that makes sense and then all of these together once you finished you just hit build stair and it's done now you have a stair mesh that you can just put anywhere in your level and it's that easy to make stairs before i get into more of the sort of what makes pro builder work i'm going to go ahead and enable pro grids so pro grids is a cool feature it's a cool sorry addon which will actually lock everything in your scene to a specific grid which you can designate based on how fine or coarse you want the grid to be and what that'll allow us to do is when i move notice that it's moving on the grid right it's not moving in continuous con like sort of a continuous motion it's actually discrete steps and the advantage of doing things this way is that when you're modeling your level or whatnot you know let's say you have a maybe a can or a sort of a diagram or a drawing that you've created you slap it on a texture then a flat mesh in your scene and then you just sort of draw your level on top of it everything will sort of just like map up nice and cleanly when you're creating all your your geometry and you can snap things together and align all in the same axis and it makes creating levels like this just a lot easier you don't have to worry about things being slightly off and then like missing vertices and everything sort of be looking a little bit unclean this ensures that everything is very clean so again just notice the discrete steps that it's moving these are all locked to the grid here and so you can change all the settings here as to like how large it is uh if i create a cube so i'm going to go ahead and create a new cube i'm gonna build it notice up here these four buttons are sort of like the modes with which we can interact with our cube and this is very similar to what you get in 3d software like blender maya or whatnot you choose vertices with the left mouse and you can hit shift to select multiple and then you can just move it and since i'm using pro grids it's snapping it to the to the grid right so if i turn off pro grids should just be continuous like that and so you can get whatever sort of angles you want um depending on what your your use case is so i'm going to hit command z if i click on the face mode and i click this face and i shift click it'll actually extrude it and make a new face and i can keep doing this uh sort of over and over again about to zoom out a little bit so i can see a little bit better and i extrude that and then i extrude that right starting to build up something right it's not beautiful but it's something i can extrude that again right i believe i can scale as well so you can build it out like that you can and i haven't spent a ton of time mastering how to use the tool and all the ins and outs of it but it is very i think useful if you're looking to get into sort of level design and you want to avoid the overhead of you know dealing with thirdparty software like blender or maya and having model files that you're sort of importing and exporting it can be kind of a pain however if you want to export models you can definitely do that so there is a method here forget which one it is offhand i think it's this one no it's one of these allows you to save the model i don't remember exactly which one it is is it this one the menu is a little bit cramped here so i'm gonna actually blow it up yeah yeah offhand i can't recall which of these allows you to actually export i don't have the icons memorized yet because it's a fairly new tool but one of these will allow you to actually export the object as fbx or obj whatever your software is that you end up wanting to uh so you can just go also go up here to the export menu which is a lot easier to see everything by name and you can choose how you want to export you can also export assets too for your for your game so you can have objects in your scene that pro builder will generate for you so you can create prefabs that way but then here's like obj so that you can export it to your 3d renderer 3d software of choice this is relevant for situations where for example you want to like rig and model and animate a mesh you can't do any sort of rigging in pro builder but you can do that in through other 3d software so it makes sense to export it that way you can also create the model here export it rig it and then reimport it if you want to and that's relevant this is a usable scene as is right now the lighting gets a little bit messed up notice here when you mess with stuff but that gets fixed there's a little sort of meter here where it does some calculating and by default it'll actually bake lighting on all of your objects but as is this will perfectly collide with with um with any characters that you have so i have a fps character i'm gonna bring this guy up let's go ahead and set the transform up here just put him in the right position and pro grids is like attaching that like sort of making that grid visible next to where i am and you can set the access for that currently i have it actually disabled so if i enable it now this will actually move in increments see and it will snap it to the grid perfectly but now this as soon as i hit play i'm actually going to close this i should just be on this mesh up here yep and so this is just part of the scene now like as if you had made it in blender or maya or whatever i should jump down to my actual level and then explore it a little bit this is all just haphazardly created you know oops stairs and other meshes and stuff and so you know make it all the way to the top oh i fell down i'm also horrible at playing games but this is the you know the beauty of it is you can just play it instantly right um right out the gate now another cool thing uh that i'd like to showcase is we talked about gray boxing earlier um for making interior levels gray boxing is the purpose of making levels and testing for playability um the cool thing about pro builder is that it has a an invert normals feature which i think is just general in like generally accessible in 3d software i don't know off hand which menu it's in actions geometry do you have the right things selected all right i'm going to open up the pro tool pro builder window and then one of these is invert uh invert selection uh sorry wait flip normals there we go and so what this does is now this is an interior level so all we did before was you we made a sort of like polygonal creation of arbitrary you know size and shape if you invert the normal so recall every like 3d polygon 3d surface as a normal and whatever direction that's facing going the opposite way going towards that normal is what gets rendered but behind it if you're going in the opposite direction of the surface normal it's invisible and so the effect of that is if we flip all the normals of something that is convex we get an interior scene and if we're looking at it from the outside it looks a little bit weird right like we can see into it right and this is something that you might see like in minecraft for example when you're looking in part of the geometry that you shouldn't be able to see you can you can clip through the world and see all the other like interior parts of the world um because you've basically gone beyond the surface normal of that polygon and uh you're only seeing the the from that perspective all the the surface normals of polygons that are facing in your direction in that way but often you'll allow you to look straight through all of the other sort of uh cubes that are along the way because you're looking at all the rear of their the inverse of their surface normal you're looking in that direction and so again only one direction can a polygon be lit at once and even if we look at it from the top you can see that as well we're looking at it from the top flip the normals it becomes a sort of concave or a convex 3d object flip them now it's an interior level right so i'm actually going to go into this and i'm going to flip the normals again i'm going to click on this uh oh i would have to click on a lot of these actually because it split up the mesh but it's gonna be easy enough i'm clicking all the top surfaces of this and making sure i didn't get any on the other side on accident i did not i'm going to extrude this and then i'm going to flip all the normals and then i'm going to take my fps controller which is here and actually i think it's already inside which it is i'm going to hit play the lighting i'm not sure if it'll be messed up it is messed up because in the middle of calculating a bunch of stuff but now i've created an interior level right with the weird mesh that i had before and so if you make your if you sort of make the building of your level sort of you know this concave thing and then you flip all the normals you can create an interior scene very easily with ceiling and everything else normally otherwise it would be kind of a pain in the butt but makes it super easy to do with pro builder and there's a lot of other features a material editor for one so with the material editor you can actually designate specific materials so in this case i've created a couple of materials a brick texture here and a marble texture which is just i took some textures created material made the albedo component of those materials that texture and what that allows me to do is i can select an arbitrary face so in this case i'm going to choose these faces and i can just click on this brick texture and now these are textured as that brick right it's not applying it to the entire mesh it's just applying it to whatever specific face that we want to and there's a uv editor which will allow you to actually take the mesh of your model in this case this is this is our entire mesh here just remember as we talked about it last week everything gets cut out and made flat so you can sort of see if you remember the shape of what we're dealing with all the polygons that we were that comprised our sort of weird large object they're all now splayed out for us so we can just very easily take a texture and just like put it wherever we want on here now i don't have a ton of experience using this so i'm not 100 confident my ability to uv map something right now in front of you but uh the documentation on the pro builder website goes into detail as to how to use this so if you wanted say a specific texture to be like in part of the mesh and then maybe another texture to be on another part of it in a specific like welded way that's not like just splat onto it the uv editor will help you with that for example a face on a character model or something else but yeah or maybe like a sign on a door somewhere or something like that you can do that all here just click and drag all the faces the faces are actually interdependent like dependent from one another so that you can lay them out in a way that fits the texture that you are trying to map everything to that is um pro builder in a nutshell there's a lot of features um we don't have time to cover all of them and i mean frankly i don't know all of them super well yet um just because the technology is so new but it's i think this is going to be a huge part of like unity's future and like making it accessible for people that would otherwise have maybe been turned off by the idea of modeling their level geometry or their object geometry um i mean certainly for me now this this just makes me want to make a game in unity like right now just because i know i can instantly just like start creating my levels right like it's just nice and easy and convenient and pro grids you should use definitely use pro grids in tandem with pro builders so that you can optimally rearrange things in a way such that they're all like evenly lined up with each other otherwise you're going to end up with issues in like manipulating their position in a very specific way and like coming up here and setting their values manually and that's just kind of a pain so much easier just to snap everything to the grid the pro pro grids and deal with it that way and so the assignment is yeah largely just going to be take the pro take pro builder and pro grades and just like make a level with it and then just like take the principles that we've learned create a controller create a collider and just make a very simple scene um and otherwise probably spend your time focused on your final project so any questions as to pro builder how it works how to get it set up uh no it'll actually it'll it should flip through it um let me go ahead and put this up here it actually actually it might not i think it does still trigger collision but you'll still you'll just be able to walk you'll just be able to see through the um through the yeah just a visual it's just a visual bug it's a lighting bug the physics should still apply i'm going to go ahead and set the model up here okay hit play uh no actually look like it went through it so i think it so it also inverts the collision the collision box yeah i've seen some games where you can clip through something and still collide with it so i think it depends on ultimately the engine or the implementation that you're using but in this case when you flip the surface normals here of this mesh it also flips the box collider the mesh colliders normals yeah precisely yeah if you wanted you could have a you could make a copy of the um interior make it you'd have to make it you make it the same size i suppose um and then flip it's and not flip its normals such that you have a shell and an interior yeah absolutely um yeah generally i don't think you would i mean yeah it depends if a lot of interior levels you'll never ever be outside of their boundaries and so you don't often see that happening but it's very much the case that you could have that happening and if you have like a house model for example then yeah you'll often you'll actually see house models are modeled with walls that are two planes so there's a bit of thickness it's actually a rectangular shape so it allows you to have a collision on one side and another side because both there's two planes of the collider rather than just the single plane which is the direction of the surface normal any further questions on pro builder yeah because the bottom surface normal is pointed upwards so this this right here is pointed upwards but notice that here the surface normal is actually pointed down so you can only collide with the direction of the surface normal that's facing you if that makes sense you can walk you can walk through you can walk towards the direction of the surface normal but not like against the surface normal if that makes sense that's the way that unity calculates its mesh renderer component you could go through from this direction but you could not go through this direction because this direction the surface normal is pointed this way right so if we try to walk against it we'll be walking against the normal and so we won't be able to uh we won't we'll we will trigger a collision but if you're walking through it and such that you're going the same direction as the surface normal so if you're coming from this direction then it won't detect a collision does that make sense yeah yeah what tawny suggested which was to make a shell around it would solve that problem so if we created this this exact mesh duplicated it and then inverted it then we would have two of the same object but with normals going one direction and normal's going the other direction such that the mesh renderers account for both potential movement directions cool all right any further questions on pro builder again not to meant to be a comprehensive tutorial there's videos um and documentation that i've linked to in the slides but more just to illustrate how awesome this tool is really and that this is probably going to save some people doing unity projects sometime if you're doing any unity like if you're doing any asset modeling i should say or level modeling another thing that we didn't i didn't make a slide for but which i talked about in class was shader graph and so what shader graph is is another 2018.1 feature which allows rather than having to write shaders in shader lab which is unity's shader language which can be quite quite an experience quite intimidating you can actually create them now with this nodebased programming language not really programming language but this nodebased programming environment i should say which will allow you to choose all these preset nodes that influence the shader's behavior and there's a lot of different kinds and have the result of that be you can see your shader every step of the way so the shader is just a series of transformations going from left to right in one direction all of these sort of transformations you can see how they end up accumulating to produce this final effect in which case here if it may be kind of hard hard to discern is a sort of marine guy with these blue holes that are actually like masking his mesh and we talked about masking earlier this shader itself looks like it's applying a mask with this noise that it's generating and it comes with noise generation functions generation nodes which will allow you to feed those into sort of like the mass component of your shader and then produce some very interesting cool effects otherwise this would be kind of uh unless you're like a shader expert which i am not it would be um pretty complicated and nontrivial to implement something like this with just code but this generates code for you such that you don't have to actually write any code at all but you can still see the produced shader that gets created for you from shader lab or shader graph i believe that it's just a asset now i'm not 100 sure i didn't test this going in um hopefully i'm not just missing it supposedly you should be able to just import it i'm not 100 let's see how you actually is it this article maybe uses it via the package manager package manager i think this is a new window package manager so we go to window and then package manager and then all and then shader graph yep so right here so window and then package manager and then shader graph and that will allow you to import the means to which by which to create these sort of graph layouts if you're using 2018.1 which the course is using but if you're at home and you're using 2017.4 then update to 2018.1 and you should see this in your package manager and then once you do that you can create a you can actually create a new shader graph object and then you'll see it as a new window that pops up in your scene and then you can start adding nodes i don't have any material prepared for it and i didn't anticipate talking about it necessarily but it's something that seems to be very game changing and something unreal has had for a long time that sort of differentiated it from unity in my opinion and it's i think a very valuable thing that they've added that shows a lot of awesome progress for 2018. so again a link to brackie's if you want details on how to use not only pro builders and pro pro builder and pro grids but a lot of other awesome features of unity and to do a lot of cool stuff he makes some really cool videos um assignment 10 so assignment 10 is going to be creating a level with pro builder just to get your hands wet with it um the level should be pretty complex so not like i said earlier not like a finished game level like i'm not expecting you to do awesome amazing incredible things but a level that has maybe you know a few pieces of interesting geometry maybe generate some stairs generate some it has some pipes you can generate and some other things um have a jumping puzzle in there so this this says there should be one jumping puzzle for the player the assignment doesn't officially say it yet but i'm going to make the change to make it say that there should be a jumping puzzle you can interpret this however you want just a couple platforms is fine but honestly whatever whatever you would like um and have two different textures or materials so you can create just an easy pers like just import whatever texture you want or you can go to a website that allows you to procedurally create a texture and you can assign it to a material put it in the material editor of pro builder and then use that to assign it to a face or to the whole object if you want to but it should be at least two not the default so to make it a little interesting use many more if you want to but only two required um so there this should be kind of like a complete scene so uh make a new scene separate from the pro builder scene separate from the portal scene include an fps controller so that we can move around the scene immediately after creating the mesh right but that's it you can just use the default controller you don't need to do anything fancy and then at the very end you should have a trigger on a collider somewhere which should probably it can be invisible it doesn't have to be invisible you can make this whatever you want you can make like an arch or i don't know your imagination is uh you're free to use your imagination as much as you want but there needs to be some collider whether it's invisible or not at the very end and a trigger it needs to be a trigger and then when you collide with it it should say level complete on the screen so just take a text object from unity2d part of the canvas and just drag it if you just add a ui text in the scene it'll automatically add a canvas and an event system for you create the label and then just set it to on or off depending on whether or not you've collided with the trigger there's code for this in the helicopter game in the game over text script you can see exactly how this is done um all it effectively is is setting the color of the text to zero zero zero zero versus zero zero zero one or whatever color you want to effectively just to change on the alpha component of the text color um and then once that's done then you have a complete assignment and then you can spend more energy hopefully this should only take maybe an hour maybe less you can spend more energy on your final project which will be due on the 11th but all together it's been an awesome pleasure teaching this course and i'm i hope that a lot of you were able to learn a lot of interesting things and hopefully we're inspired to create some of your own projects and we'll continue to create some of your own projects in the future um i certainly enjoyed making a lot of the stuff and i especially super mario brothers i think that was my favorite um but this was gd 50. so thank you so much
