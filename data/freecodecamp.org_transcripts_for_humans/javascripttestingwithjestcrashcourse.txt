With timestamps:

00:00 - welcome to this comprehensive video
00:01 - course on JavaScript testing with just a
00:04 - powerful and widely used testing
00:07 - framework this course covers just
00:09 - features and capabilities and will teach
00:12 - you how to write run and organize tests
00:15 - efficiently to enhance your JavaScript
00:17 - projects popular teacher Tommy too
00:19 - created this course hi there and welcome
00:21 - to this course I am Tommy from free code
00:24 - camp in this course you will learn how
00:26 - to use just to test your JavaScript code
00:29 - just is a power testing framework for
00:31 - JavaScript and in this tutorial we will
00:33 - cover everything from the basic concept
00:35 - to mocking and also in synchronous
00:38 - testing by the end of this course you
00:40 - will have the skills to implement just
00:42 - into your project confidently now let's
00:44 - get straight into this course so now the
00:46 - first thing that we're going to do is to
00:47 - create a folder where we're going to be
00:49 - doing all our work so right now I'm just
00:51 - in the root directory of my computer I'm
00:53 - going to go into
00:55 - document and in there I'm going to go
00:57 - into my project
00:58 - folder and I'm going to create a new
01:02 - actually I'm just going to create a new
01:04 - directory named so I'm just going to say
01:06 - mkd i r just
01:10 - course and I'm going to go into just
01:16 - course now if I press LS to see
01:18 - everything in this folder you're going
01:19 - to see that it's blank so what we're
01:21 - just doing is kind of like creating a
01:22 - playground where we can experiment and
01:24 - see just in action so this is just the
01:26 - folder right here and as you can see I
01:28 - named the just C name it whatever you
01:30 - want to name it and yeah so now the next
01:34 - thing that we're going to do is to just
01:36 - like initialize a new mpm project so
01:39 - what I'm going to do is that in here I'm
01:41 - going to say
01:42 - mpm in it so this is the normal command
01:45 - you use to just initialize a new project
01:48 - but I'm going to add i y now the reason
01:50 - why I add i y is like a shortcut to
01:54 - answer yes to all the prompt so once I
01:56 - run mpm in it if there's any prompt
01:58 - that's going to come up once once I put
02:00 - i y right here it's just going to bypass
02:03 - all of that and answer yes so just so we
02:05 - can have like a default setup and also
02:07 - like a quick setup I'm going to hit
02:09 - enter and now that is done if I press LS
02:12 - again you can now see that we have a
02:14 - package.json file right here so what I'm
02:17 - now going to do is to open up this just
02:19 - C folder inside my vs code I'm going to
02:22 - swipe to vs code right here and what I'm
02:25 - just going to do is to save file open
02:28 - folder and then I'm just going to look
02:31 - for my vs code right here so right here
02:36 - in just going to try to find my project
02:40 - test course I'm going to open this up so
02:43 - right here as you can see so right here
02:46 - as you can see we have opened up just
02:48 - course and this is the package. Json
02:50 - that we have right here just a
02:52 - normal mpm project now what we're just
02:56 - going to do the next thing that we're
02:57 - going to do after doing that is to now
02:59 - actually install just into this
03:01 - particular you know this particular
03:03 - project so for us to install just um the
03:07 - next what we're going to do is to run
03:11 - mpm
03:13 - install two I say
03:16 - save dev then just so the reason why we
03:20 - choosing just again is just for it
03:22 - Simplicity and it's Rich pictures so
03:25 - just is like I think the most popular
03:28 - know frame or library that we can use to
03:30 - run JavaScript tests and that's why
03:32 - we're using just for this course so this
03:33 - is the command that you're going to use
03:35 - to actually install just into this
03:37 - project that we just created and now
03:39 - what I'm just going to do is to click on
03:40 - enter and that is going to start
03:42 - installing just into this project now as
03:45 - I said it's going to install just
03:46 - locally into this project and it's going
03:48 - to add it to the dep dependency in our
03:52 - package.json if I come here there's once
03:55 - it's done you're going to see something
03:56 - named Dev dependency and that just means
03:58 - that it is this particular library that
04:01 - we're installing is essential for the
04:03 - development of this our projects but is
04:07 - not essential for running the actual
04:08 - application so you don't really need to
04:10 - know all of those details what you just
04:11 - need to know is that what we are running
04:13 - right now is to install j into this
04:15 - project and now once that installs
04:17 - you're going to see a new folder here is
04:19 - going to be created named node modules
04:21 - as you can see that was created but
04:22 - let's wait for it to properly install
04:24 - now as you can see everything was
04:26 - installed successfully it added just so
04:29 - it says added 292 packages and found Z
04:32 - zero vulnerabilities which is what we
04:34 - want now if I come back in here let's
04:36 - verify that this installation actually
04:38 - worked so now we have a package look.
04:41 - Json and then we have the actual
04:43 - package.json so first if we come in here
04:46 - you can see that we have a node module
04:48 - folder this means that we actually
04:50 - installed a particular library or a
04:52 - module and in this package. Json once I
04:56 - come in here the dep dependencies I was
04:58 - talking about initially
05:00 - this is it right here so once this has
05:02 - been added under here you can see that
05:04 - we have just added to De dependencies
05:07 - now this just confirms that just has
05:09 - been added successfully as you can see
05:12 - so now that just has been added
05:13 - successfully the next thing is to
05:15 - actually configure our npm script to run
05:18 - just when we want to execute tests so
05:21 - what we're going to do is to just open
05:24 - up package of Json and change some stuff
05:26 - so npm scripts are convenient shortcut
05:29 - we can set up to run specific commands
05:31 - so we're going to set one up now for J
05:34 - now I'm going to open up package.json
05:36 - and right here this is package of Json
05:39 - is like our project manifest so let's
05:41 - just modify it to run test using just
05:44 - now on here what we're going to do is
05:47 - where we see I just come here where we
05:49 - see test so under script under the
05:53 - script section so this default tests
05:56 - we're going to change it to just going
05:58 - to say just
06:00 - right and then what this does this means
06:02 - that whenever we run the command mpm
06:04 - test it's going to use just to execute
06:08 - that test now this is what we want to do
06:10 - we're just going to save this this is
06:12 - what we need to do and then now with our
06:14 - setup ready we can dive into just and
06:18 - dive more into how we can actually run
06:20 - tests using this G now let's go into the
06:24 - basic concepts of testing with just so
06:28 - now that we have set up just and we have
06:30 - everything done the next thing that we
06:32 - want to do is to write our first test so
06:36 - this is going to introduce us to the
06:37 - fundamental concepts in just now what
06:40 - we're going to do is that we're going to
06:43 - write a very simple unit test and before
06:45 - we move forward let me explain what unit
06:46 - test is so unit test is the process of
06:50 - checking small pieces of code to deliver
06:52 - information early and often so when we
06:55 - are testing when we are doing or running
06:57 - a unit test it means that we testing
07:00 - small blocks of code so things like
07:03 - basic functions or basic classes that is
07:06 - unit testing now the reason why we do
07:08 - this is so that we can easily identify
07:10 - errors or any box that's going to come
07:12 - up right from the scratch so that
07:15 - instead of testing the whole code when
07:17 - it's done and that is going to be harder
07:19 - because once we get an error it's going
07:20 - to be harder to actually find where the
07:22 - error is coming from but unit test
07:23 - allows us to
07:25 - easily get or capture this error early
07:28 - on while we're still you know doing our
07:29 - basic functions and basic coding blocks
07:33 - now we're going to run a basic unit test
07:36 - using just and let me show you how to do
07:38 - that now the first thing we need to do
07:40 - is I'm just going to close this and
07:42 - right here I'm going to create a new
07:44 - file named sum.
07:46 - JS now this sum. JS is actually a
07:49 - Javascript file where we're going to be
07:51 - writing a function that is just going to
07:53 - add two F add two numbers together and
07:56 - return the addition or the sum of those
07:58 - numbers and I'm going to create another
08:00 - file named sum. test.js now this is a
08:05 - test file so once we write the actual
08:07 - function in here we're going to kind of
08:08 - like export that particular function and
08:11 - we're going to retrieve that function in
08:13 - this test file and then we're going to
08:15 - actually run the unit test so now what
08:17 - we're going to do is to come back in
08:20 - here and right here in sjs I'm just
08:23 - going to write a basic JavaScript
08:25 - function so I'm going to say function
08:27 - I'm going to name it sum
08:30 - just increase this a little bit and I'm
08:33 - going to say it's going to take two
08:36 - inputs A and
08:37 - B and we're just going to open and close
08:40 - that function and that function is going
08:42 - to return the sum of those two numbers
08:45 - so it's going to return a plus b now the
08:48 - next thing we're going to do is to
08:49 - actually export this particular function
08:51 - so that it can be used by other files in
08:54 - this particular directory so what I'm
08:56 - going to do is to say
08:57 - module. export
09:01 - equals to sum and I'm going to add my
09:04 - semicolon very important now that I have
09:06 - all of this done the next thing I can
09:09 - just do is to actually run a test so the
09:13 - first thing I just did is just creating
09:15 - this basic sum function taking two
09:18 - inputs and it's going to add those
09:20 - inputs and return
09:22 - the value or the sum of those inputs now
09:27 - I'm going to make as I said using this
09:28 - mod export equals sum it makes this sum
09:32 - function available to other files like
09:34 - this test file in nodejs right here so
09:38 - now I'm going to access this particular
09:40 - function in this sum. test.js and I'm
09:43 - going to run a unit test right there but
09:46 - now what I'm going to do is to just
09:48 - explain how this works so as I said
09:51 - we're using just and when we say sum do
09:55 - test.js once we add test before adding
09:58 - Js JavaScript automatically knows that
10:00 - we're trying to run a test so it knows
10:03 - that this is a file dedicated to running
10:05 - tests now what we're now going to do is
10:08 - to say const sum so what I'm doing is
10:13 - I'm using require to import this sum
10:16 - function into this test file so I'm
10:18 - going to say equals to
10:22 - require and I'm going to say dot SL sum
10:26 - now this Imports it into this particular
10:29 - folder file and now I can actually run
10:32 - the test so I'm going to say
10:35 - test not this say
10:38 - test and now this is going to be a
10:42 - description so this comes in two so it
10:45 - it has like a pair so once we run test
10:48 - and we have a bracket I'm going to have
10:51 - right here I'm going to write the
10:52 - description so I'm just going to say
10:54 - description and right here after the
10:56 - description I'm going to have like a
10:58 - test function I'm just going to leave it
11:01 - like this and we're going to come right
11:02 - here to now add an actual description so
11:05 - what is the description of this function
11:07 - so what are this test that we're going
11:09 - to run so we're going to say it adds 1 +
11:14 - 2 to equal
11:16 - three so what we're going to do is that
11:18 - we're going to run a test by giving so
11:20 - I'm going to come back in here so we're
11:22 - going to give it this values of one and
11:23 - two and when we add one and two
11:26 - theoretically this function should
11:28 - return three because it's just adding
11:30 - one and two and it's giving us three and
11:32 - that's what we're going to say in here
11:33 - so the description is saying it adds one
11:36 - and two and it should equal three and
11:40 - then after having the description now
11:42 - we're going to have the actual function
11:44 - so to have the actual text function so
11:47 - we're going to come here and do this
11:49 - like this and equals
11:51 - to the greater than sign then we're
11:55 - going to open the function and then
11:57 - we're going to say expect
12:03 - so
12:05 - expect some now we're going to use that
12:07 - function one and going to give it two
12:10 - one and two and we're going to say 2 B
12:14 - so this is like another pair and it's
12:16 - just saying once we run this one and two
12:19 - function the answer should be or the
12:22 - response should be three and then we're
12:25 - going to have our semicolon to close
12:26 - this and we also need to come here and
12:28 - close this now this is all we need and
12:31 - let me just quickly explain this
12:34 - particular code once again so now what
12:36 - we just doing is we are importing this
12:38 - sum function from here so we can run
12:40 - test of about that function and then we
12:44 - are basically introducing this test
12:47 - right here which is a like a a global
12:51 - case for defining a test case right here
12:53 - in this test function and this structure
12:56 - which is the description and then we
12:59 - have the actual function right here and
13:01 - the last thing is that we did is to
13:04 - input the pairs so we have the expect
13:06 - and 2 BP so as I said expect means we
13:10 - expect that once we run this sum
13:11 - function and give it these values the
13:14 - response should B three now what we need
13:17 - to do is to now just run the test so for
13:21 - us to run the test and get the results
13:23 - we have to save these two files make
13:25 - sure they are saved and then we're going
13:26 - to pop up a terminal right here
13:29 - and then all we just need to do is to
13:30 - make sure we're in this folder yes we
13:32 - are so let's just clear that and now
13:34 - we're going to say mpm
13:37 - test so as you can see that test didn't
13:40 - go through it says Echo error no test
13:43 - specified so that means there is a
13:45 - problem when we set up our package.json
13:47 - I'm just going to close this up and
13:49 - close that so right here where we have
13:52 - script just and we say all of this so as
13:55 - you can see it's basically giving us
13:56 - this error message that is what was
13:59 - given to us right here no test specified
14:01 - now this is because we replace the test
14:04 - with just instead of the actual value so
14:07 - this should be test the the key should
14:10 - be test not just and then the value
14:14 - should be
14:16 - just so we just need to rectify that
14:18 - error and once that is rectified we can
14:20 - close this open up that terminal again
14:23 - and now we can say mpm
14:26 - test and let's wait for that to run
14:29 - good as you can see it says one test is
14:31 - passed one total and as you can see one
14:34 - passed one total so it run one test in
14:37 - total and out of that one test one was
14:41 - passed so basically everything that was
14:42 - run was passed and snapshot zero total
14:45 - and this was the time it take to run to
14:47 - run the test and as you can see this is
14:49 - the main message we looking for pass
14:51 - some. test.js it adds 1 + 2 and it
14:55 - equals 3 so as you can see right here we
14:59 - have successfully run our first unit
15:01 - test and this is how we can use J to
15:03 - easily run a test or unit test right
15:05 - here in JavaScript so what we just did
15:07 - was to create a simple function and then
15:10 - we wrote a test for it and run that test
15:13 - now I'm going to emphasize how
15:15 - understanding this foundational concept
15:16 - is crucial for writing more complex test
15:19 - so this seems like a very easy and the
15:21 - most basic test you could write but it's
15:23 - actually crucial and important that you
15:25 - understand how to write basic test like
15:26 - this before you can go ahead and
15:28 - actually run more complex and advanced
15:31 - tests so we're going to be talking about
15:33 - matchers in just and matchers are just
15:36 - used to test different type of data so
15:39 - they basically let us assert values in
15:41 - different ways so right here this is a
15:45 - matcher this to be right here so when we
15:48 - have the function or the test function
15:51 - this is the test desription right here
15:52 - we have the test function so we have the
15:55 - expect and then we have the matcher so
15:58 - these 2B is one type of match there are
16:01 - various type of matchers there is Tob to
16:03 - equal to truy to faly to throw I'm going
16:08 - to talk about every single one of this
16:10 - right now the first one I'm going to
16:12 - talk about is to be and that is what we
16:14 - already I've already shown you in the
16:17 - initial example that we did now as you
16:21 - can see right here what this is is just
16:23 - to be and we saying sum 1 + 2 to be3 so
16:27 - what we're just going to do is to get
16:29 - rid of this and I'm just going to start
16:31 - again and show you how the 2B matcher
16:33 - actually works so what I want to show
16:37 - you is to Tob is basically used to for
16:40 - primitive values so values like numbers
16:43 - strings and booleans that what Tob is
16:45 - for and I'm going to show you what I
16:47 - mean by that so now let's just quickly
16:49 - write a simple test but we don't need to
16:52 - import any function from some. JS we
16:55 - were not really going to be working with
16:57 - this file for now we just going to be
16:58 - doing everything from here cuz I'm just
17:00 - showing you basic examples so
17:02 - description we're going to say 2 + 2 is
17:08 - four and then right here we're going to
17:10 - have to have open and close bracket and
17:14 - then we're going to have to a function
17:16 - now we're going to say
17:20 - expect 2 +
17:24 - 2 to
17:26 - B four
17:29 - now what this 2B is going to do if 2 + 2
17:33 - is four then it's going to tell us the
17:35 - test has been successfully passed but we
17:38 - only use this 2B when as I said when we
17:41 - are dealing with values like numbers
17:43 - strings and Boolean so this is a number
17:46 - if it was a string if it was anything
17:48 - dealing with string or Boolean we're
17:50 - going to use Tob also now if I open up
17:54 - my terminal let me just make sure we
17:55 - save this let's bring back that terminal
17:59 - just going to say mpm test
18:01 - again and this is going to run
18:04 - successfully it says one pass now that
18:06 - is how we use to be right now the next
18:10 - thing that we're going to talk about is
18:12 - to equal so to equal is used when
18:15 - comparing the values of object or arrays
18:18 - right so what I'm going to do is I'm
18:19 - going to create basically a new
18:23 - dictionary in here so let's just say
18:25 - test let's create another one and and
18:28 - let's say something move this and let's
18:31 - say something like
18:33 - object
18:46 - assignment open and close and right here
18:49 - we're going to create a new dictionary
18:51 - we're going to say data
18:55 - equals I we just say
18:57 - one
18:59 - I one right and then right now what I'm
19:03 - just going to do is to say
19:04 - data two just giving it another value
19:08 - equals to
19:10 - two now we expect that the values of
19:14 - this data dictionary now should be 1 col
19:18 - 1 comma 2 colum 2 because we added a new
19:22 - key value pair which is two and then two
19:24 - right so that what we expected but in
19:27 - this case we're not going to say to be
19:29 - so I'm going to say
19:33 - expect
19:35 - data so we expect this data now that we
19:38 - created here we're going to say dot to
19:40 - equal so we expect it to
19:46 - equal now we can just type in what we
19:48 - need 1 col 1 and then
19:53 - 2 2 so this is what we expect it to be
19:58 - going to keep this
20:00 - spacing add the semicolon now come down
20:03 - here and add the semicolon so now I'm
20:04 - not going to say we expect this two be
20:07 - this because we are not like dealing
20:09 - with directly dealing with primitive
20:12 - values like numbers or strings this is
20:14 - an object basically so because we are
20:17 - dealing with object or arrays or
20:19 - anything like that then we have to say
20:20 - to equal now what we're just going to do
20:23 - is to come up here and then we're going
20:26 - to say mpm test again
20:29 - and because everything should be working
20:32 - successfully it says one pass one total
20:35 - now as you can see what this basic
20:36 - JavaScript code does is we're creating
20:38 - this new object name data and then we
20:41 - are now inputting another value in there
20:44 - as 2 col 2 so now the total value of
20:47 - everything that should be in data should
20:49 - be equals to this because it is equals
20:51 - to that that's why that particular test
20:54 - was passed
20:56 - successfully now we've talked about two
20:58 - be and we've talked about to equal now
21:00 - the next match we're going to talk about
21:02 - is the truthy and falsey matchers I'm
21:05 - just going to demonstrate how to test
21:07 - for truthy and F falsey values in just
21:12 - so the first thing we're going to do is
21:13 - to test for truthy values no we're going
21:16 - to test for FAL falsy values the first
21:18 - thing so when we're testing for faly
21:22 - values so the way we test for faly
21:24 - values is just the way we say to equal
21:27 - right here we're going to say to be
21:29 - FY and this doesn't really work in this
21:32 - situation but we're going to change that
21:34 - so I'm just showing you how you're going
21:35 - to test for it so I'm going to write a
21:37 - code now that is going to test that
21:39 - we're going to have to use this to be FY
21:42 - now we just used faly to check if a
21:45 - value is n undefined if it's false if
21:48 - it's zero if it's blank if it's n and or
21:52 - as I said undefined so that is what we
21:55 - use falc for and let me show you an
21:56 - example so let's just start
22:01 - test go
22:04 - back and we're just going to say no is
22:11 - falsy and then like
22:14 - this
22:18 - to and now let's say const nals to no so
22:22 - n is no and then we're going to say
22:26 - expect
22:31 - n do to be faly so because n is no we
22:36 - expect it to be
22:39 - faly so this should be this test should
22:43 - be run successfully as I said to be FAL
22:46 - is is to check if a value is not
22:48 - undefined ver false zero blank or n n
22:53 - now because this n is no this test
22:57 - should be true and it should run
22:59 - successfully so now let's pop up that
23:01 - terminal once again and then let's run
23:03 - mpm test it enter let me expand it you
23:08 - can see it has been passed successfully
23:11 - now this just shows that to be FC worked
23:13 - now on the other hand the next thing
23:16 - that we can check is TR to be truthful
23:20 - to be truthy so before we go there I'm
23:23 - just going to show you one more thing so
23:25 - as I said this is not just only for when
23:28 - is no if n is zero or n is false or n is
23:31 - any of those other values is going to
23:33 - also be true so let me just say let me
23:35 - say 0o is faly so I'm going to give this
23:38 - a value of zero now n is zero so now
23:41 - we're expecting n to be falsy going to
23:44 - save it if I run that again mpm test
23:47 - you're going to see that that run
23:49 - successfully now as I said next thing
23:52 - we're going to do is to check to be
23:54 - truthy so what we're just going to do is
23:58 - I'm going to show you how we used to be
24:00 - truthy to check or to test if a value is
24:03 - like not any of this so basically if a
24:05 - value is not falsy it is truthy so we
24:09 - say this is zero but if I say one
24:12 - because that is not falsy and I say to
24:15 - be
24:17 - truy right here and then what I can just
24:20 - do is to say Z
24:23 - is
24:24 - one
24:26 - trophy now this should run successfully
24:30 - if I come up here and say mpm test one
24:34 - should be truthy and we say one passed
24:38 - now if I change this back to falsey so
24:41 - you just see that it's not every time
24:43 - that actually passes if we make a
24:45 - mistake it's not going to pass now once
24:47 - I run this you're going to see it says
24:48 - one failed one total this is because to
24:51 - be
24:52 - FY should only be true or should only be
24:55 - successful when the value of of n is
25:00 - basically any of those PR any of those
25:03 - values zero you know false you know
25:06 - undefined null any of those stuff like
25:10 - that now the last thing that we're going
25:12 - to be talking about in matchers is error
25:15 - handling with to throw so what we use
25:19 - error handling for is just to determine
25:22 - whether a function throws an error and
25:24 - just the way we have to be FY to to
25:28 - equal and all of that we have to throw
25:31 - for you know checking error matches
25:34 - that's what
25:35 - we for checking errors basically that's
25:37 - what we use that for now I'm just going
25:40 - to show you how to use this practically
25:43 - so for us to basically use this
25:45 - practically what we're going to do is to
25:48 - write our own test again and once we
25:50 - write the test I'm going to show you
25:52 - that once a particular error is thrown
25:56 - or an invalid input is thrown then it
25:58 - should give us that error so the first
26:01 - thing I'm going to do is to make sure
26:02 - that you understand the to throw so the
26:05 - to throw so it's going to say like this
26:08 - to throw that's what this is and as I
26:12 - said is used for error handling so it's
26:14 - arror handling is a very essential
26:16 - aspect of testing in JavaScript in
26:18 - general so particularly when you expect
26:21 - a function to throw an error under
26:23 - certain conditions and it should throw
26:26 - that error that's why we want to test to
26:28 - make sure those errors are being thrown
26:30 - now as we are using just in here it
26:33 - provides us this to throw function so we
26:36 - can use this for this purpose and this
26:39 - basically helps us write test that
26:41 - verify whether a function throws an
26:43 - error when it is called so for the to
26:46 - throw specifically so this match in just
26:50 - is used to test that a particular
26:52 - function throws an error when it is
26:54 - executed just as I said now this is
26:56 - particularly useful when you're testing
26:58 - functions that are designed to validate
27:00 - input and throw errors when the input is
27:03 - invalid so let's do that right now so
27:06 - I'm just going to write a basic syntax
27:08 - of how to use this to throw and we're
27:10 - just going to say
27:12 - test nope and then we're going to say
27:16 - throws on invalid
27:21 - input right
27:24 - here open and close enter now we're
27:28 - going to say
27:31 - expect and then what we're just going to
27:35 - do is after expect we basically want to
27:37 - have something that throws an error so
27:41 - right here well we need to
27:44 - do
27:49 - say put one up in here so we want to do
27:56 - this actually we we don't because we
27:58 - already have so right here in
28:01 - expect we have open and closed we need
28:04 - to make sure the syntax is correct so we
28:06 - open
28:07 - this
28:10 - and I have another one in
28:15 - here
28:17 - this now we can hit enter and then we
28:21 - could just say for now let's say my
28:25 - function inval
28:31 - input and then dot to
28:37 - throw right here so in this example my
28:40 - function is a function that we are
28:42 - testing an inv valid input is some input
28:44 - that is expected to basically cause the
28:47 - function to throw an error so what we
28:50 - need to do is to write an
28:53 - actual function for this my function so
28:58 - what I'm going to do is to say going to
29:00 - save this we could write that function
29:02 - in here or we could you know write it
29:06 - outside and just import it in here so
29:09 - what I'm just going to do is to write a
29:11 - function to write another
29:13 - function and I'm going to name it my
29:16 - function and it's just going to take an
29:21 - input so we're just going to say
29:25 - if input is
29:34 - invalid we're going to take care of how
29:36 - to get if the input is invalid so if the
29:40 - input is invalid what we want to do is
29:43 - to basically do something in here we're
29:46 - going to
29:47 - throw not here right here throw new
29:52 - error we're just going to say invalid
29:56 - input
29:58 - so how do we check if the input is
30:00 - invalid so we'll say
30:04 - if type of input is not equals to A
30:11 - number that means in this case that
30:15 - input should be invalid if the type of
30:17 - the input is not equals to number so
30:20 - what we're just going to do is since
30:22 - this type of input is not equals to
30:24 - number then that should be invalid for
30:26 - us and and we're just going to have to
30:28 - export this particular function to just
30:31 - the way we exported the form the sum
30:34 - function initially just going to export
30:37 - that and then right here going to come
30:41 - back to just and we're just going to
30:45 - say
30:47 - const my function equals to
30:56 - require just slash
30:59 - sum we're going to sa my
31:02 - function so now we can use my function
31:04 - in here because we've already imported
31:07 - it from here so we exported this we
31:10 - don't really need this we could get rid
31:12 - of all of this and we could save this
31:15 - just make sure we're copying this
31:17 - correctly function and my function so
31:20 - now we can basically use all of this and
31:22 - what this does is if the input is
31:25 - invalid then it's not going to work so
31:27 - what we're going to do now is that right
31:31 - here in sjs so this invalid input uh we
31:36 - don't really have any value we giv it so
31:39 - I'm just going to give it like a string
31:41 - and let's save it now let's open this up
31:45 - and then let's say mpm
31:49 - test and let's
31:52 - see and it failed and let's see why it
31:56 - failed
31:58 - it said TR mode not found now this is
32:01 - because right here we're getting the sum
32:03 - file so this is saying do/ some. JS
32:06 - basically and then we could give it my
32:09 - function so now let's run this
32:11 - again the mistake we made was we changed
32:14 - some to my function and when we change
32:17 - some to my function there was no actual
32:20 - there was no any file here named my
32:22 - function so it gave us an error but now
32:25 - we got this my function from right here
32:28 - from do/ suum so that should work so as
32:31 - you can see now it passed it says throws
32:34 - on invalid input now because that input
32:37 - is invalid it throws that error for us
32:40 - because we are expecting a number but
32:42 - now let's say we actually put a number
32:46 - let's save it and then run npm test
32:52 - again so now as you can see it said one
32:54 - failed now why does one fail this is
32:57 - because this is not actually an invalid
32:59 - input this is a very valid input because
33:01 - we the for it to be invalid it needs to
33:04 - be not a number but this is a number so
33:07 - it's not going to throw an error that is
33:09 - why that failed so that is basically a
33:12 - summary of matchers in just and that is
33:15 - why why we use matchers and why matchers
33:17 - is actually very powerful in testing in
33:21 - JavaScript in general so now we are
33:23 - going to be testing a synchronous code
33:26 - in JavaScript
33:27 - so testing a secon code is quite complex
33:30 - and is um it's not as straightforward as
33:33 - testing normal functions that we've been
33:36 - talking about and writing this whole
33:38 - course so I'm going to show you how
33:41 - we're going to be able to test a
33:42 - synchronous code and it's actually quite
33:45 - vital and important that we know how to
33:48 - test a synchronous code because a
33:50 - synchronous code is used the law in
33:51 - JavaScript and it's very important so
33:54 - let me just show you how just makes this
33:56 - straightforward but before we do that
33:58 - let me just quickly explain the concept
34:00 - of a synchronous code so a synchronous
34:02 - code in JavaScript allows for executing
34:04 - some operations in the background and
34:07 - not blocking the main execution thread
34:09 - so this is crucial in JavaScript
34:11 - especially in web environments because
34:13 - it keeps the user interface responsive
34:15 - while handling tasks like networks
34:17 - request file operations or timers so
34:21 - there are different ways that we're
34:23 - going to different free method in
34:25 - testing a code ingest which are
34:28 - callbacks promises and async/await so
34:32 - I'm going to first start with telling
34:34 - you or showing you how to test callbacks
34:38 - so the first thing that we're going to
34:39 - do is to actually create a basic
34:41 - callback function in here and let's get
34:44 - started so right here in sjs I'm just
34:47 - going to get rid of all of this and then
34:49 - what I'm going to do is to just write a
34:51 - very basic function so this function is
34:53 - just going to as I said be a call back
34:55 - function and then I'm going going to
34:57 - show you what we're going to do to test
34:58 - it I'm just going to say
35:02 - function let's call it fetch
35:09 - data and the call
35:12 - back going to open and close that
35:14 - function and let's set time out I'm
35:17 - going to explain everything that this
35:18 - code does in a
35:20 - bit
35:25 - so
35:27 - then we're just going to open
35:30 - up that and now we're going to call
35:34 - back like a result so for this result
35:37 - let's just say something like peanut
35:41 - buttter let me colon and down here going
35:45 - to set it to like let's say
35:48 - 1,000 and now we can just add our
35:50 - semicolon right here now let me explain
35:53 - what this code does real quick so this
35:55 - is uh basic basic as I said a basic
35:58 - function and the name of the function is
35:59 - fetch data so what all of this does is
36:02 - that it kind of simulates a delayed
36:04 - operation so like an API call using set
36:07 - timeout and then it calls a call back
36:10 - with a result so once the API call has
36:13 - been done or whatever operation we are
36:14 - doing has been done then it calls a call
36:17 - back with your result in this case the
36:20 - result is pin Not Butter so that's what
36:22 - this basic code does and I'm just going
36:24 - to show you how to test that this code
36:26 - Works using just right here now before
36:29 - we go straight into testing this the
36:32 - first thing we need to do is to make
36:33 - sure that we're actually exporting this
36:35 - PCH data function so that it can be
36:37 - available in here in the test file so to
36:41 - do this we're just going to say
36:43 - module
36:45 - export equals to fetch data so now we
36:48 - are exporting fetch data and when we
36:51 - require it here this is going to allow
36:54 - us to just use that particular function
36:56 - let's get rid of all of this and now
36:58 - let's just write a basic test file basic
37:02 - test code that we can use to test this
37:04 - so let's say
37:05 - test and let's say Okay nope this is not
37:08 - what we want let's say the data
37:11 - something like the
37:14 - data is p
37:17 - not and then we can
37:20 - say done this done is very important
37:23 - again I'm going to explain what this
37:24 - code
37:25 - does then going to open that now we're
37:28 - going to write a
37:30 - function we're going to say call back
37:34 - going to take the
37:35 - data and right now we're just going to
37:38 - open this function and close it and
37:40 - we're going to have a try accept can say
37:44 - try open and close that I'm going to say
37:51 - accept
37:52 - data do
37:55 - 2b
37:59 - peut data PE
38:07 - but now we have to call it done so we
38:10 - have to call this done so just knows
38:12 - that we are done with what we're doing
38:14 - and then down here say catch so this is
38:18 - a try catch
38:21 - syntax error to catch any error then
38:24 - open and close that and say done
38:29 - error that easy close this and then
38:33 - right
38:35 - here fetch data is the function that we
38:39 - created right here fetch data and then
38:42 - we're going to say call
38:46 - back and then we're just going to add a
38:48 - semicolon right here like
38:51 - this now once again this is just a basic
38:54 - code that is testing for this and and
38:56 - I'm just going to explain what this does
38:58 - so first of all we require this
39:01 - particular fetch data right here from
39:04 - here by just importing
39:06 - this/ sum which is sum. GS and then
39:10 - we're just giving it a description of
39:11 - what this test is so we're saying that
39:14 - once this test is run the data that is
39:16 - being outputed should be pin data to
39:19 - write whatever you want to write here
39:20 - this is just the basic description so
39:23 - yes and now what we're just doing is to
39:25 - specify
39:27 - and once we have this call back function
39:29 - right here once we say we're trying and
39:31 - remember the matches to be and accept so
39:34 - accepting the data and we're saying it
39:36 - should be P not butter and once we are
39:39 - done with that we need to add the Dum
39:41 - parameter which we did right here so we
39:44 - need to add that D parameter because it
39:46 - is used for callbacks that's what we did
39:48 - here but now we also need to specify it
39:50 - here it's important in calling that done
39:53 - function to signal to just that the test
39:55 - is complete so that's what we did right
39:57 - here and that's also what we did right
39:59 - here so now we're just going to go ahead
40:01 - and actually test this particular or run
40:03 - this particular test bring up my
40:06 - terminal and what I'm just going to do
40:07 - is to say mpm test going to hit enter
40:11 - and now let's
40:12 - see so it says one test failed and let's
40:16 - see why the test is failed this is
40:20 - because it says reference except is not
40:24 - defined so let's go back can see why
40:27 - this is
40:29 - expect not accept now let's run that
40:35 - again and now everything should be
40:37 - working fine good as you can see it says
40:40 - pass right here which is what we need
40:42 - and it says the data is pin not data
40:44 - which is good say one pass one total so
40:47 - the amount of test we run was one and
40:50 - out of that one one was passed this is
40:52 - the time it used to run that test so
40:55 - everything is working successfully now
40:57 - in testing for callbacks now we are
41:00 - going to be testing for promise based
41:02 - functions so without wasting anytime
41:04 - let's just get into it so let's close
41:06 - down this terminal and we're going to
41:08 - come back into some. JS we could change
41:11 - this name to whatever we want but just
41:13 - let's just leave it at su. JS and what
41:15 - we're going to do now is to as I said
41:18 - test for promise based functions the
41:20 - first thing we need to do is to First
41:21 - write U we're going to introduce a
41:24 - function that returns a promise which
41:26 - resolves after a delay so let's do that
41:29 - right now so once again get rid of all
41:32 - of this right here and then I'm just
41:34 - going to say
41:36 - function let's just name it fetch
41:41 - promise and then we're going to open and
41:44 - close that function and we're going to
41:46 - say return
41:50 - new promise so once again
41:53 - um should have a basic knowledge of
41:55 - JavaScript to be be able to follow along
41:57 - with this tutorial cuz this is for
41:58 - people that already know JavaScript and
42:00 - want to learn how to test their
42:01 - JavaScript code so we're going to say
42:05 - resolve
42:09 - reject and so this resolve and reject
42:13 - just shows that it can be resolved and
42:14 - also rejected and I'm going to show you
42:16 - how we test for both if is resolved or
42:19 - rejected now what we're going to do is
42:23 - and close that we're just going to set
42:25 - time out
42:31 - this then we're going to
42:34 - resolve let's just give you the same
42:36 - thing we gave the last code we're going
42:38 - to say p
42:39 - Not
42:43 - Butter say
42:46 - th000 that all right here we're going to
42:49 - have the semicolon also now this is the
42:51 - basic code as I said this is just a
42:53 - basic you know from promise a basic
42:56 - function that returns a promise and as I
42:59 - said it resolved after a delay so now
43:01 - what we're just going to do is to make
43:03 - sure that we export this out so that it
43:05 - can be used in our test file so
43:10 - module.
43:11 - export equals to fetch promise semicolon
43:16 - now we're going to come and test this
43:19 - for us to test it once again the first
43:21 - thing we need to do is get rid of all of
43:23 - this and let's just say con going to say
43:25 - f
43:26 - promise equals to
43:34 - require so don't allow we're just going
43:37 - to say do slash
43:41 - sum and now we're going to write the
43:43 - test so we're going to say test this is
43:45 - actually quite
43:47 - straightforward
43:48 - test the
43:50 - data is peut
43:54 - butter and right here we're going to
43:56 - open and
43:58 - close to the same here and now we're
44:01 - going to return so we're going to say
44:06 - ex fetch
44:09 - promise so we're expecting a fetch
44:11 - promise the resolves so if everything
44:14 - works
44:16 - fine 2B why ising the 2B matcher and we
44:20 - expect it to be what it is right here P
44:25 - bottom
44:30 - so peanut
44:32 - butter and we're going to add a
44:34 - semicolon now let's save this and what
44:36 - we're just going to do is let's make
44:38 - sure we have our semicolon right here
44:40 - this is basically what we need and let
44:42 - me just pop this up and run mpm test now
44:46 - let's see what happens it should be
44:48 - passed as you can see it says pass this
44:51 - is because everything works successfully
44:53 - once if this is resolved right here it
44:56 - gives us pin up butter that happens but
44:59 - now let's just assume that fetch promise
45:02 - can also reject because of course it can
45:04 - resolve or reject now let's add a test
45:07 - for if it rejects so say
45:10 - test the
45:12 - fetch fails with an
45:16 - error something like that and then we'll
45:19 - just going to do same
45:22 - syntax and we're just going to say
45:24 - return expect
45:28 - fetch
45:30 - promise going to say do
45:35 - reject now we're going to say that to
45:37 - throw remember when we talked about the
45:38 - to throw matcher for if there is an
45:41 - error now we're using that right here
45:44 - and then we're just going to say
45:47 - error right
45:49 - here so right here is the way we can
45:52 - write test for if the data so let's just
45:55 - spell this
45:57 - correctly the data is successfully
46:01 - resolved or if the data is rejected so
46:04 - this is the basic way we can just you
46:06 - know as I said write test for for
46:09 - promises for functions that uses
46:12 - promises so it helps handling in
46:14 - handling resolved and rejected promises
46:16 - respectively now I'm going to show you
46:18 - how to test with async await now we
46:21 - don't even need to write any new
46:23 - function right here we already have an
46:25 - asynchronous function right here so we
46:27 - don't really need to write any new
46:28 - function I'm just going to show you how
46:30 - to use a sing await to test this promise
46:32 - function that we have right here so what
46:34 - I'm just going to do is to come back in
46:36 - here clear all of this I'm going to
46:37 - leave this out so we don't need to
46:39 - rewrite that and I'm just going to write
46:41 - every the code out and then I'm going to
46:43 - explain it to you in detail because this
46:45 - is very crucial for you to understand so
46:47 - the first thing I'm just going to do is
46:48 - to write a new test just as we've been
46:50 - doing we're just going to say not this
46:53 - test say the data
46:56 - peanut
46:58 - butter and now we're going to say a
47:01 - sync so a sync just basically signifies
47:05 - make sure we're writing that well it
47:07 - basically signifies that this is an
47:08 - asynchronous function that's what async
47:10 - does and now we're just going to open
47:13 - that up and we're going to say
47:16 - con data equals to await so AWA is is
47:20 - using tandem is using constru con is
47:24 - used alongside as sync So when you say a
47:27 - sync you should write await right here
47:29 - this just means that we are waiting for
47:31 - the promise to resolve before making any
47:34 - assertions so what we're just going to
47:35 - do is to say
47:37 - fetch
47:42 - promise and
47:47 - expect data and then we're going to use
47:50 - the
47:51 - 2B
47:54 - matcher
47:56 - peanut
47:59 - butter right here and then we do this so
48:02 - this is just what we need to basically
48:04 - test this out and what I'm going to do
48:06 - is to explain as I said in detail what
48:09 - this does so first I'm going to talk
48:11 - about this async right here so as I said
48:14 - it signifies once we have this async
48:17 - function ASN keyword before the actual
48:20 - function it signifies that this function
48:23 - is going to be asynchronous so it's like
48:25 - signal to JavaScript that the function
48:27 - can pause and resume at some point and
48:30 - especially to wait for as syn fonus
48:32 - operations to complete that's what that
48:34 - does and in testing this is very useful
48:38 - for handling promises returned by the
48:40 - code that you're testing so as you can
48:42 - see we use that to handle this fetch
48:44 - promise function now let's talk about
48:46 - this await now this await is a keyword
48:49 - that that is used alongside a sync so
48:51 - when you use await before a function or
48:54 - a promise what you are just saying is
48:56 - that you're telling JavaScript to wait
48:57 - till that promise settles and returns
49:00 - its result now what we need to do is
49:04 - to understand why what this await does
49:07 - so is used as I said to pause the test
49:10 - until the asynchronous function resultes
49:13 - so when we say this await is going to
49:17 - pause the test the test is not going to
49:18 - go on until we get a result or this
49:22 - promised function is being resolved so
49:25 - that is what that helps us to do and
49:28 - this I think a way it basically just
49:30 - leads to more readable and cleaner test
49:32 - code and that is why we use this most of
49:34 - the time and I'm just going to run this
49:36 - and show you that it works so I'm just
49:38 - going to say mpm
49:41 - test and right here you should see it
49:44 - says fast but that works successfully
49:47 - and that is how to use a sync await in
49:50 - testing now let's talk about mock
49:52 - functions and spice in testing so in
49:54 - unit testing I isolating the component
49:56 - being tested is very crucial and this is
49:59 - where mocking and spying comes in so
50:01 - mocks are fake implementations of real
50:03 - functions and spies are tools that are
50:06 - used to track the behaviors of those
50:08 - functions so they track behaviors such
50:11 - as whether the function has been called
50:13 - or how many times it has been called or
50:15 - with what arguments the function was
50:17 - called
50:18 - with now as I said mocking is used to
50:21 - isolate the unit of code being tested so
50:24 - it basically allows you to replace a
50:25 - complex or slow or unavailable
50:28 - dependency with simpler
50:30 - versions and this isolation prevents
50:32 - tests from being affected by external
50:35 - factors and makes them more reliable and
50:37 - faster to execute so let me give you an
50:39 - example of why and when we can use this
50:42 - so I'm going to give you an example of
50:43 - like a database call so pain this
50:46 - scenario imagine you have a function
50:48 - that calls a database now testing this
50:50 - function could be problematic because it
50:52 - involves Network calls database setup
50:55 - and stuff like that but by mocking the
50:57 - database call we can simulate Its
50:59 - Behavior and focus solely on testing the
51:02 - functions logic now this is why testing
51:05 - using mocking and spice is very
51:07 - important now let's create and Implement
51:09 - mock functions using just so the first
51:12 - thing I'm going to show you how to do is
51:14 - to use just. FN so just. FN is a way of
51:19 - creating a mock function and it can be
51:23 - implemented to return a specific value
51:25 - of perform a specific action let me just
51:27 - show you what I'm talking about so right
51:30 - here in sum. test.js I'm going to remove
51:32 - all of this and I'm just going to write
51:34 - const let me just say something like
51:36 - Mark call
51:39 - back equals to just FN now we're
51:42 - creating a mock function by saying just
51:45 - FN and let's just say x equal
51:50 - 42 plus X so as you can see this is a
51:54 - basic function and let's say I call this
51:57 - by saying mock call back and I give it
51:59 - zero now you if you understand
52:01 - JavaScript you know that this is just
52:03 - going to say 0 is equal to X so that
52:06 - means 42 + 0 is = to X so the new value
52:10 - of x will be 42 if I do the same and say
52:13 - call back
52:15 - one now this is just going to be 42 + 1
52:18 - which is 43 now this is just a basic way
52:22 - that we just created a mock function but
52:24 - now I'm going to show you how to test
52:26 - for a mock function by using just so
52:29 - just going to get rid of all of this
52:30 - real quick and I'm actually going to
52:32 - write a real test now I'm going to say
52:35 - let's remove that and let's give it a
52:38 - description and the description will be
52:40 - something like
52:41 - mock
52:46 - implementation so this is just like a
52:48 - mock implementation let's say of a basic
52:53 - function and now that
52:55 - function just write this out that
53:00 - function open and close and now we're
53:03 - just going to create that same 42 plus X
53:06 - that we created initially and I'm just
53:08 - going to say const so as you can see
53:10 - right here we're not actually doing
53:11 - anything with the sum. JS because we
53:13 - don't really need to do anything here
53:14 - I'm just showing you how to implement a
53:17 - mock function right here so we're just
53:20 - going to say mock equals to just now
53:24 - we're going to use just
53:26 - FN and now we're going to say
53:29 - x is
53:31 - 42 +
53:34 - x as I said this is a very basic
53:36 - function we're just going to do is going
53:38 - to return 42 plus whatever value that we
53:41 - give it is basically what we want so now
53:45 - the next thing that we just need to do
53:47 - is to
53:51 - say
53:53 - expect more Mark and we call one we
53:58 - expect it to
54:01 - be do to
54:05 - be 43 so what this is just saying is
54:09 - that if we call this mock right here and
54:11 - give it a value of one or argument of
54:13 - one the what should be returned the
54:16 - value that we should get should be 43
54:18 - and that is because once we give it one
54:19 - it adds that one to 42 and it should be
54:22 - 43 so let's make sure this is 43
54:27 - give the semicolon and for now let's
54:30 - just save this and I'm just going to
54:33 - pull this up and right here what we just
54:36 - need to do is to say mpm
54:39 - test now when we say mpm test just as
54:43 - you can see it says one Past One total
54:46 - right now this is just a very basic way
54:48 - of using mock functions but we're going
54:50 - to do one more thing I'm going to
54:52 - introduce to you to have been C with so
54:55 - is it's kind of like another match up we
54:57 - haven't talked about this match up
54:59 - before I'm going to show you what this
55:01 - does right here so it's going to let's
55:04 - just say right here I'm going to say
55:08 - expect
55:10 - Mark do to I've been called
55:22 - with the H one
55:27 - now let's also add this semicolon here
55:30 - now this statement what it just does is
55:32 - that it checks that the mock function
55:34 - was called with the correct argument so
55:36 - if this assertion failed then just to
55:39 - provide an error message indicating what
55:41 - went wrong so what we're just doing is
55:43 - to make sure that we call this with one
55:46 - because we did call it with one right
55:47 - here we said mock one so this is just
55:49 - saying we're checking that mock should
55:52 - have been C with one we're just going to
55:54 - do the same thing that we did run mpm
55:56 - test and everything should also work
55:59 - successfully nothing went wrong so this
56:01 - is just a very basic way of using mock
56:04 - function for testing right here in just
56:06 - it's very easy it's very straightforward
56:09 - now I'm going to show you how to use
56:10 - just do spy on ingest so we're going to
56:13 - use it to spy as I explained earlier in
56:16 - this tutorial now what we're just going
56:18 - to do is right here in some. test.js I'm
56:22 - just going to go straight to writing
56:23 - this test I'm going to say
56:26 - test not
56:29 - this going to say spying on a method of
56:34 - an
56:35 - object we're going to create that right
56:37 - now and we're just going to say equals
56:40 - this and we're going to create this and
56:43 - we're going to say const video equals to
56:47 - I'm going to open that up and say
56:50 - play now we're going to open this play
56:52 - function up too just say return
56:57 - true right here and now we're just going
57:00 - to comma and right here we're going to
57:03 - add our
57:04 - semicolon now we're going to add just
57:07 - the spy on and why we're adding just the
57:10 - spy on is basically like tracking this
57:13 - particular video right here so we want
57:15 - to track and see if this play has been
57:20 - called in this video so what we're just
57:23 - going to do right here is to say con
57:27 - spy was just do spy
57:32 - on we say video and we're going to spy
57:35 - on
57:37 - play write that and we're going to say
57:40 - video do
57:42 - play open and close and add the
57:45 - semicolon and now we're going to say
57:52 - expect spy
57:55 - do two have been
58:02 - called and what we're just going to say
58:04 - spy. mock
58:09 - restore now this is just a basic test
58:12 - that we writing to track so let's get
58:15 - rid of this we're writing to track and
58:17 - make sure that this and track if this
58:20 - play has been displ function has been
58:22 - called right here and that's what we're
58:25 - just doing is we're saying cons spy
58:27 - we're saying just dop so this just dop
58:30 - is just a method to track CS to video.
58:34 - play so we're tracking when this video.
58:36 - play has been called and just the spy on
58:39 - this spy on right here it does not
58:40 - replace the functions implementation
58:43 - unlike just. FN that we talked about
58:45 - earlier so this allows us to observe the
58:48 - functions real Behavior now what we're
58:51 - just going to do is to just go ahead and
58:53 - run this and
58:55 - just going to save this and then going
58:58 - to pop up the
59:00 - terminal all right you are just going to
59:02 - say mpm
59:04 - test just going to hit
59:07 - enter so let's go back to terminal and
59:11 - hit
59:13 - enter as you can see it says one passed
59:16 - so that means it has been done
59:18 - successfully so as you can see
59:20 - everything works and let me just quickly
59:22 - explain this cuz we didn't talk about
59:24 - this so so expect spy. to have been
59:26 - called with so this line will check if
59:29 - the play method was called so this
59:31 - basically validates the spies
59:33 - functionality that we created so that's
59:36 - what these two have been called with
59:38 - does and the last thing we're going to
59:40 - talk about is this spy mock restore
59:43 - function so this spy Mo restore function
59:46 - in just is used to restore the original
59:49 - implementation of that function so the
59:52 - function that has been spied on using
59:54 - just do spy on this that is what is
59:58 - being used to restore the original
59:59 - implementation of that function now when
60:02 - we create a spy on a function just
60:04 - basically replaces the Spy function with
60:06 - a mock function now this allows you to
60:09 - like track calls argument and return
60:12 - values of that function but in some
60:14 - cases you might want to revert the
60:16 - function back to its original
60:18 - implementation that is why we use spym
60:21 - restore and that is what we did right
60:22 - here so that is the end of this tutorial
60:25 - and I hope you understood everything we
60:26 - did in this tutorial if you did please
60:29 - don't forget to click on the like button
60:31 - and subscribe and I'll see you in the
60:33 - next one

Cleaned transcript:

welcome to this comprehensive video course on JavaScript testing with just a powerful and widely used testing framework this course covers just features and capabilities and will teach you how to write run and organize tests efficiently to enhance your JavaScript projects popular teacher Tommy too created this course hi there and welcome to this course I am Tommy from free code camp in this course you will learn how to use just to test your JavaScript code just is a power testing framework for JavaScript and in this tutorial we will cover everything from the basic concept to mocking and also in synchronous testing by the end of this course you will have the skills to implement just into your project confidently now let's get straight into this course so now the first thing that we're going to do is to create a folder where we're going to be doing all our work so right now I'm just in the root directory of my computer I'm going to go into document and in there I'm going to go into my project folder and I'm going to create a new actually I'm just going to create a new directory named so I'm just going to say mkd i r just course and I'm going to go into just course now if I press LS to see everything in this folder you're going to see that it's blank so what we're just doing is kind of like creating a playground where we can experiment and see just in action so this is just the folder right here and as you can see I named the just C name it whatever you want to name it and yeah so now the next thing that we're going to do is to just like initialize a new mpm project so what I'm going to do is that in here I'm going to say mpm in it so this is the normal command you use to just initialize a new project but I'm going to add i y now the reason why I add i y is like a shortcut to answer yes to all the prompt so once I run mpm in it if there's any prompt that's going to come up once once I put i y right here it's just going to bypass all of that and answer yes so just so we can have like a default setup and also like a quick setup I'm going to hit enter and now that is done if I press LS again you can now see that we have a package.json file right here so what I'm now going to do is to open up this just C folder inside my vs code I'm going to swipe to vs code right here and what I'm just going to do is to save file open folder and then I'm just going to look for my vs code right here so right here in just going to try to find my project test course I'm going to open this up so right here as you can see so right here as you can see we have opened up just course and this is the package. Json that we have right here just a normal mpm project now what we're just going to do the next thing that we're going to do after doing that is to now actually install just into this particular you know this particular project so for us to install just um the next what we're going to do is to run mpm install two I say save dev then just so the reason why we choosing just again is just for it Simplicity and it's Rich pictures so just is like I think the most popular know frame or library that we can use to run JavaScript tests and that's why we're using just for this course so this is the command that you're going to use to actually install just into this project that we just created and now what I'm just going to do is to click on enter and that is going to start installing just into this project now as I said it's going to install just locally into this project and it's going to add it to the dep dependency in our package.json if I come here there's once it's done you're going to see something named Dev dependency and that just means that it is this particular library that we're installing is essential for the development of this our projects but is not essential for running the actual application so you don't really need to know all of those details what you just need to know is that what we are running right now is to install j into this project and now once that installs you're going to see a new folder here is going to be created named node modules as you can see that was created but let's wait for it to properly install now as you can see everything was installed successfully it added just so it says added 292 packages and found Z zero vulnerabilities which is what we want now if I come back in here let's verify that this installation actually worked so now we have a package look. Json and then we have the actual package.json so first if we come in here you can see that we have a node module folder this means that we actually installed a particular library or a module and in this package. Json once I come in here the dep dependencies I was talking about initially this is it right here so once this has been added under here you can see that we have just added to De dependencies now this just confirms that just has been added successfully as you can see so now that just has been added successfully the next thing is to actually configure our npm script to run just when we want to execute tests so what we're going to do is to just open up package of Json and change some stuff so npm scripts are convenient shortcut we can set up to run specific commands so we're going to set one up now for J now I'm going to open up package.json and right here this is package of Json is like our project manifest so let's just modify it to run test using just now on here what we're going to do is where we see I just come here where we see test so under script under the script section so this default tests we're going to change it to just going to say just right and then what this does this means that whenever we run the command mpm test it's going to use just to execute that test now this is what we want to do we're just going to save this this is what we need to do and then now with our setup ready we can dive into just and dive more into how we can actually run tests using this G now let's go into the basic concepts of testing with just so now that we have set up just and we have everything done the next thing that we want to do is to write our first test so this is going to introduce us to the fundamental concepts in just now what we're going to do is that we're going to write a very simple unit test and before we move forward let me explain what unit test is so unit test is the process of checking small pieces of code to deliver information early and often so when we are testing when we are doing or running a unit test it means that we testing small blocks of code so things like basic functions or basic classes that is unit testing now the reason why we do this is so that we can easily identify errors or any box that's going to come up right from the scratch so that instead of testing the whole code when it's done and that is going to be harder because once we get an error it's going to be harder to actually find where the error is coming from but unit test allows us to easily get or capture this error early on while we're still you know doing our basic functions and basic coding blocks now we're going to run a basic unit test using just and let me show you how to do that now the first thing we need to do is I'm just going to close this and right here I'm going to create a new file named sum. JS now this sum. JS is actually a Javascript file where we're going to be writing a function that is just going to add two F add two numbers together and return the addition or the sum of those numbers and I'm going to create another file named sum. test.js now this is a test file so once we write the actual function in here we're going to kind of like export that particular function and we're going to retrieve that function in this test file and then we're going to actually run the unit test so now what we're going to do is to come back in here and right here in sjs I'm just going to write a basic JavaScript function so I'm going to say function I'm going to name it sum just increase this a little bit and I'm going to say it's going to take two inputs A and B and we're just going to open and close that function and that function is going to return the sum of those two numbers so it's going to return a plus b now the next thing we're going to do is to actually export this particular function so that it can be used by other files in this particular directory so what I'm going to do is to say module. export equals to sum and I'm going to add my semicolon very important now that I have all of this done the next thing I can just do is to actually run a test so the first thing I just did is just creating this basic sum function taking two inputs and it's going to add those inputs and return the value or the sum of those inputs now I'm going to make as I said using this mod export equals sum it makes this sum function available to other files like this test file in nodejs right here so now I'm going to access this particular function in this sum. test.js and I'm going to run a unit test right there but now what I'm going to do is to just explain how this works so as I said we're using just and when we say sum do test.js once we add test before adding Js JavaScript automatically knows that we're trying to run a test so it knows that this is a file dedicated to running tests now what we're now going to do is to say const sum so what I'm doing is I'm using require to import this sum function into this test file so I'm going to say equals to require and I'm going to say dot SL sum now this Imports it into this particular folder file and now I can actually run the test so I'm going to say test not this say test and now this is going to be a description so this comes in two so it it has like a pair so once we run test and we have a bracket I'm going to have right here I'm going to write the description so I'm just going to say description and right here after the description I'm going to have like a test function I'm just going to leave it like this and we're going to come right here to now add an actual description so what is the description of this function so what are this test that we're going to run so we're going to say it adds 1 + 2 to equal three so what we're going to do is that we're going to run a test by giving so I'm going to come back in here so we're going to give it this values of one and two and when we add one and two theoretically this function should return three because it's just adding one and two and it's giving us three and that's what we're going to say in here so the description is saying it adds one and two and it should equal three and then after having the description now we're going to have the actual function so to have the actual text function so we're going to come here and do this like this and equals to the greater than sign then we're going to open the function and then we're going to say expect so expect some now we're going to use that function one and going to give it two one and two and we're going to say 2 B so this is like another pair and it's just saying once we run this one and two function the answer should be or the response should be three and then we're going to have our semicolon to close this and we also need to come here and close this now this is all we need and let me just quickly explain this particular code once again so now what we just doing is we are importing this sum function from here so we can run test of about that function and then we are basically introducing this test right here which is a like a a global case for defining a test case right here in this test function and this structure which is the description and then we have the actual function right here and the last thing is that we did is to input the pairs so we have the expect and 2 BP so as I said expect means we expect that once we run this sum function and give it these values the response should B three now what we need to do is to now just run the test so for us to run the test and get the results we have to save these two files make sure they are saved and then we're going to pop up a terminal right here and then all we just need to do is to make sure we're in this folder yes we are so let's just clear that and now we're going to say mpm test so as you can see that test didn't go through it says Echo error no test specified so that means there is a problem when we set up our package.json I'm just going to close this up and close that so right here where we have script just and we say all of this so as you can see it's basically giving us this error message that is what was given to us right here no test specified now this is because we replace the test with just instead of the actual value so this should be test the the key should be test not just and then the value should be just so we just need to rectify that error and once that is rectified we can close this open up that terminal again and now we can say mpm test and let's wait for that to run good as you can see it says one test is passed one total and as you can see one passed one total so it run one test in total and out of that one test one was passed so basically everything that was run was passed and snapshot zero total and this was the time it take to run to run the test and as you can see this is the main message we looking for pass some. test.js it adds 1 + 2 and it equals 3 so as you can see right here we have successfully run our first unit test and this is how we can use J to easily run a test or unit test right here in JavaScript so what we just did was to create a simple function and then we wrote a test for it and run that test now I'm going to emphasize how understanding this foundational concept is crucial for writing more complex test so this seems like a very easy and the most basic test you could write but it's actually crucial and important that you understand how to write basic test like this before you can go ahead and actually run more complex and advanced tests so we're going to be talking about matchers in just and matchers are just used to test different type of data so they basically let us assert values in different ways so right here this is a matcher this to be right here so when we have the function or the test function this is the test desription right here we have the test function so we have the expect and then we have the matcher so these 2B is one type of match there are various type of matchers there is Tob to equal to truy to faly to throw I'm going to talk about every single one of this right now the first one I'm going to talk about is to be and that is what we already I've already shown you in the initial example that we did now as you can see right here what this is is just to be and we saying sum 1 + 2 to be3 so what we're just going to do is to get rid of this and I'm just going to start again and show you how the 2B matcher actually works so what I want to show you is to Tob is basically used to for primitive values so values like numbers strings and booleans that what Tob is for and I'm going to show you what I mean by that so now let's just quickly write a simple test but we don't need to import any function from some. JS we were not really going to be working with this file for now we just going to be doing everything from here cuz I'm just showing you basic examples so description we're going to say 2 + 2 is four and then right here we're going to have to have open and close bracket and then we're going to have to a function now we're going to say expect 2 + 2 to B four now what this 2B is going to do if 2 + 2 is four then it's going to tell us the test has been successfully passed but we only use this 2B when as I said when we are dealing with values like numbers strings and Boolean so this is a number if it was a string if it was anything dealing with string or Boolean we're going to use Tob also now if I open up my terminal let me just make sure we save this let's bring back that terminal just going to say mpm test again and this is going to run successfully it says one pass now that is how we use to be right now the next thing that we're going to talk about is to equal so to equal is used when comparing the values of object or arrays right so what I'm going to do is I'm going to create basically a new dictionary in here so let's just say test let's create another one and and let's say something move this and let's say something like object assignment open and close and right here we're going to create a new dictionary we're going to say data equals I we just say one I one right and then right now what I'm just going to do is to say data two just giving it another value equals to two now we expect that the values of this data dictionary now should be 1 col 1 comma 2 colum 2 because we added a new key value pair which is two and then two right so that what we expected but in this case we're not going to say to be so I'm going to say expect data so we expect this data now that we created here we're going to say dot to equal so we expect it to equal now we can just type in what we need 1 col 1 and then 2 2 so this is what we expect it to be going to keep this spacing add the semicolon now come down here and add the semicolon so now I'm not going to say we expect this two be this because we are not like dealing with directly dealing with primitive values like numbers or strings this is an object basically so because we are dealing with object or arrays or anything like that then we have to say to equal now what we're just going to do is to come up here and then we're going to say mpm test again and because everything should be working successfully it says one pass one total now as you can see what this basic JavaScript code does is we're creating this new object name data and then we are now inputting another value in there as 2 col 2 so now the total value of everything that should be in data should be equals to this because it is equals to that that's why that particular test was passed successfully now we've talked about two be and we've talked about to equal now the next match we're going to talk about is the truthy and falsey matchers I'm just going to demonstrate how to test for truthy and F falsey values in just so the first thing we're going to do is to test for truthy values no we're going to test for FAL falsy values the first thing so when we're testing for faly values so the way we test for faly values is just the way we say to equal right here we're going to say to be FY and this doesn't really work in this situation but we're going to change that so I'm just showing you how you're going to test for it so I'm going to write a code now that is going to test that we're going to have to use this to be FY now we just used faly to check if a value is n undefined if it's false if it's zero if it's blank if it's n and or as I said undefined so that is what we use falc for and let me show you an example so let's just start test go back and we're just going to say no is falsy and then like this to and now let's say const nals to no so n is no and then we're going to say expect n do to be faly so because n is no we expect it to be faly so this should be this test should be run successfully as I said to be FAL is is to check if a value is not undefined ver false zero blank or n n now because this n is no this test should be true and it should run successfully so now let's pop up that terminal once again and then let's run mpm test it enter let me expand it you can see it has been passed successfully now this just shows that to be FC worked now on the other hand the next thing that we can check is TR to be truthful to be truthy so before we go there I'm just going to show you one more thing so as I said this is not just only for when is no if n is zero or n is false or n is any of those other values is going to also be true so let me just say let me say 0o is faly so I'm going to give this a value of zero now n is zero so now we're expecting n to be falsy going to save it if I run that again mpm test you're going to see that that run successfully now as I said next thing we're going to do is to check to be truthy so what we're just going to do is I'm going to show you how we used to be truthy to check or to test if a value is like not any of this so basically if a value is not falsy it is truthy so we say this is zero but if I say one because that is not falsy and I say to be truy right here and then what I can just do is to say Z is one trophy now this should run successfully if I come up here and say mpm test one should be truthy and we say one passed now if I change this back to falsey so you just see that it's not every time that actually passes if we make a mistake it's not going to pass now once I run this you're going to see it says one failed one total this is because to be FY should only be true or should only be successful when the value of of n is basically any of those PR any of those values zero you know false you know undefined null any of those stuff like that now the last thing that we're going to be talking about in matchers is error handling with to throw so what we use error handling for is just to determine whether a function throws an error and just the way we have to be FY to to equal and all of that we have to throw for you know checking error matches that's what we for checking errors basically that's what we use that for now I'm just going to show you how to use this practically so for us to basically use this practically what we're going to do is to write our own test again and once we write the test I'm going to show you that once a particular error is thrown or an invalid input is thrown then it should give us that error so the first thing I'm going to do is to make sure that you understand the to throw so the to throw so it's going to say like this to throw that's what this is and as I said is used for error handling so it's arror handling is a very essential aspect of testing in JavaScript in general so particularly when you expect a function to throw an error under certain conditions and it should throw that error that's why we want to test to make sure those errors are being thrown now as we are using just in here it provides us this to throw function so we can use this for this purpose and this basically helps us write test that verify whether a function throws an error when it is called so for the to throw specifically so this match in just is used to test that a particular function throws an error when it is executed just as I said now this is particularly useful when you're testing functions that are designed to validate input and throw errors when the input is invalid so let's do that right now so I'm just going to write a basic syntax of how to use this to throw and we're just going to say test nope and then we're going to say throws on invalid input right here open and close enter now we're going to say expect and then what we're just going to do is after expect we basically want to have something that throws an error so right here well we need to do say put one up in here so we want to do this actually we we don't because we already have so right here in expect we have open and closed we need to make sure the syntax is correct so we open this and I have another one in here this now we can hit enter and then we could just say for now let's say my function inval input and then dot to throw right here so in this example my function is a function that we are testing an inv valid input is some input that is expected to basically cause the function to throw an error so what we need to do is to write an actual function for this my function so what I'm going to do is to say going to save this we could write that function in here or we could you know write it outside and just import it in here so what I'm just going to do is to write a function to write another function and I'm going to name it my function and it's just going to take an input so we're just going to say if input is invalid we're going to take care of how to get if the input is invalid so if the input is invalid what we want to do is to basically do something in here we're going to throw not here right here throw new error we're just going to say invalid input so how do we check if the input is invalid so we'll say if type of input is not equals to A number that means in this case that input should be invalid if the type of the input is not equals to number so what we're just going to do is since this type of input is not equals to number then that should be invalid for us and and we're just going to have to export this particular function to just the way we exported the form the sum function initially just going to export that and then right here going to come back to just and we're just going to say const my function equals to require just slash sum we're going to sa my function so now we can use my function in here because we've already imported it from here so we exported this we don't really need this we could get rid of all of this and we could save this just make sure we're copying this correctly function and my function so now we can basically use all of this and what this does is if the input is invalid then it's not going to work so what we're going to do now is that right here in sjs so this invalid input uh we don't really have any value we giv it so I'm just going to give it like a string and let's save it now let's open this up and then let's say mpm test and let's see and it failed and let's see why it failed it said TR mode not found now this is because right here we're getting the sum file so this is saying do/ some. JS basically and then we could give it my function so now let's run this again the mistake we made was we changed some to my function and when we change some to my function there was no actual there was no any file here named my function so it gave us an error but now we got this my function from right here from do/ suum so that should work so as you can see now it passed it says throws on invalid input now because that input is invalid it throws that error for us because we are expecting a number but now let's say we actually put a number let's save it and then run npm test again so now as you can see it said one failed now why does one fail this is because this is not actually an invalid input this is a very valid input because we the for it to be invalid it needs to be not a number but this is a number so it's not going to throw an error that is why that failed so that is basically a summary of matchers in just and that is why why we use matchers and why matchers is actually very powerful in testing in JavaScript in general so now we are going to be testing a synchronous code in JavaScript so testing a secon code is quite complex and is um it's not as straightforward as testing normal functions that we've been talking about and writing this whole course so I'm going to show you how we're going to be able to test a synchronous code and it's actually quite vital and important that we know how to test a synchronous code because a synchronous code is used the law in JavaScript and it's very important so let me just show you how just makes this straightforward but before we do that let me just quickly explain the concept of a synchronous code so a synchronous code in JavaScript allows for executing some operations in the background and not blocking the main execution thread so this is crucial in JavaScript especially in web environments because it keeps the user interface responsive while handling tasks like networks request file operations or timers so there are different ways that we're going to different free method in testing a code ingest which are callbacks promises and async/await so I'm going to first start with telling you or showing you how to test callbacks so the first thing that we're going to do is to actually create a basic callback function in here and let's get started so right here in sjs I'm just going to get rid of all of this and then what I'm going to do is to just write a very basic function so this function is just going to as I said be a call back function and then I'm going going to show you what we're going to do to test it I'm just going to say function let's call it fetch data and the call back going to open and close that function and let's set time out I'm going to explain everything that this code does in a bit so then we're just going to open up that and now we're going to call back like a result so for this result let's just say something like peanut buttter let me colon and down here going to set it to like let's say 1,000 and now we can just add our semicolon right here now let me explain what this code does real quick so this is uh basic basic as I said a basic function and the name of the function is fetch data so what all of this does is that it kind of simulates a delayed operation so like an API call using set timeout and then it calls a call back with a result so once the API call has been done or whatever operation we are doing has been done then it calls a call back with your result in this case the result is pin Not Butter so that's what this basic code does and I'm just going to show you how to test that this code Works using just right here now before we go straight into testing this the first thing we need to do is to make sure that we're actually exporting this PCH data function so that it can be available in here in the test file so to do this we're just going to say module export equals to fetch data so now we are exporting fetch data and when we require it here this is going to allow us to just use that particular function let's get rid of all of this and now let's just write a basic test file basic test code that we can use to test this so let's say test and let's say Okay nope this is not what we want let's say the data something like the data is p not and then we can say done this done is very important again I'm going to explain what this code does then going to open that now we're going to write a function we're going to say call back going to take the data and right now we're just going to open this function and close it and we're going to have a try accept can say try open and close that I'm going to say accept data do 2b peut data PE but now we have to call it done so we have to call this done so just knows that we are done with what we're doing and then down here say catch so this is a try catch syntax error to catch any error then open and close that and say done error that easy close this and then right here fetch data is the function that we created right here fetch data and then we're going to say call back and then we're just going to add a semicolon right here like this now once again this is just a basic code that is testing for this and and I'm just going to explain what this does so first of all we require this particular fetch data right here from here by just importing this/ sum which is sum. GS and then we're just giving it a description of what this test is so we're saying that once this test is run the data that is being outputed should be pin data to write whatever you want to write here this is just the basic description so yes and now what we're just doing is to specify and once we have this call back function right here once we say we're trying and remember the matches to be and accept so accepting the data and we're saying it should be P not butter and once we are done with that we need to add the Dum parameter which we did right here so we need to add that D parameter because it is used for callbacks that's what we did here but now we also need to specify it here it's important in calling that done function to signal to just that the test is complete so that's what we did right here and that's also what we did right here so now we're just going to go ahead and actually test this particular or run this particular test bring up my terminal and what I'm just going to do is to say mpm test going to hit enter and now let's see so it says one test failed and let's see why the test is failed this is because it says reference except is not defined so let's go back can see why this is expect not accept now let's run that again and now everything should be working fine good as you can see it says pass right here which is what we need and it says the data is pin not data which is good say one pass one total so the amount of test we run was one and out of that one one was passed this is the time it used to run that test so everything is working successfully now in testing for callbacks now we are going to be testing for promise based functions so without wasting anytime let's just get into it so let's close down this terminal and we're going to come back into some. JS we could change this name to whatever we want but just let's just leave it at su. JS and what we're going to do now is to as I said test for promise based functions the first thing we need to do is to First write U we're going to introduce a function that returns a promise which resolves after a delay so let's do that right now so once again get rid of all of this right here and then I'm just going to say function let's just name it fetch promise and then we're going to open and close that function and we're going to say return new promise so once again um should have a basic knowledge of JavaScript to be be able to follow along with this tutorial cuz this is for people that already know JavaScript and want to learn how to test their JavaScript code so we're going to say resolve reject and so this resolve and reject just shows that it can be resolved and also rejected and I'm going to show you how we test for both if is resolved or rejected now what we're going to do is and close that we're just going to set time out this then we're going to resolve let's just give you the same thing we gave the last code we're going to say p Not Butter say th000 that all right here we're going to have the semicolon also now this is the basic code as I said this is just a basic you know from promise a basic function that returns a promise and as I said it resolved after a delay so now what we're just going to do is to make sure that we export this out so that it can be used in our test file so module. export equals to fetch promise semicolon now we're going to come and test this for us to test it once again the first thing we need to do is get rid of all of this and let's just say con going to say f promise equals to require so don't allow we're just going to say do slash sum and now we're going to write the test so we're going to say test this is actually quite straightforward test the data is peut butter and right here we're going to open and close to the same here and now we're going to return so we're going to say ex fetch promise so we're expecting a fetch promise the resolves so if everything works fine 2B why ising the 2B matcher and we expect it to be what it is right here P bottom so peanut butter and we're going to add a semicolon now let's save this and what we're just going to do is let's make sure we have our semicolon right here this is basically what we need and let me just pop this up and run mpm test now let's see what happens it should be passed as you can see it says pass this is because everything works successfully once if this is resolved right here it gives us pin up butter that happens but now let's just assume that fetch promise can also reject because of course it can resolve or reject now let's add a test for if it rejects so say test the fetch fails with an error something like that and then we'll just going to do same syntax and we're just going to say return expect fetch promise going to say do reject now we're going to say that to throw remember when we talked about the to throw matcher for if there is an error now we're using that right here and then we're just going to say error right here so right here is the way we can write test for if the data so let's just spell this correctly the data is successfully resolved or if the data is rejected so this is the basic way we can just you know as I said write test for for promises for functions that uses promises so it helps handling in handling resolved and rejected promises respectively now I'm going to show you how to test with async await now we don't even need to write any new function right here we already have an asynchronous function right here so we don't really need to write any new function I'm just going to show you how to use a sing await to test this promise function that we have right here so what I'm just going to do is to come back in here clear all of this I'm going to leave this out so we don't need to rewrite that and I'm just going to write every the code out and then I'm going to explain it to you in detail because this is very crucial for you to understand so the first thing I'm just going to do is to write a new test just as we've been doing we're just going to say not this test say the data peanut butter and now we're going to say a sync so a sync just basically signifies make sure we're writing that well it basically signifies that this is an asynchronous function that's what async does and now we're just going to open that up and we're going to say con data equals to await so AWA is is using tandem is using constru con is used alongside as sync So when you say a sync you should write await right here this just means that we are waiting for the promise to resolve before making any assertions so what we're just going to do is to say fetch promise and expect data and then we're going to use the 2B matcher peanut butter right here and then we do this so this is just what we need to basically test this out and what I'm going to do is to explain as I said in detail what this does so first I'm going to talk about this async right here so as I said it signifies once we have this async function ASN keyword before the actual function it signifies that this function is going to be asynchronous so it's like signal to JavaScript that the function can pause and resume at some point and especially to wait for as syn fonus operations to complete that's what that does and in testing this is very useful for handling promises returned by the code that you're testing so as you can see we use that to handle this fetch promise function now let's talk about this await now this await is a keyword that that is used alongside a sync so when you use await before a function or a promise what you are just saying is that you're telling JavaScript to wait till that promise settles and returns its result now what we need to do is to understand why what this await does so is used as I said to pause the test until the asynchronous function resultes so when we say this await is going to pause the test the test is not going to go on until we get a result or this promised function is being resolved so that is what that helps us to do and this I think a way it basically just leads to more readable and cleaner test code and that is why we use this most of the time and I'm just going to run this and show you that it works so I'm just going to say mpm test and right here you should see it says fast but that works successfully and that is how to use a sync await in testing now let's talk about mock functions and spice in testing so in unit testing I isolating the component being tested is very crucial and this is where mocking and spying comes in so mocks are fake implementations of real functions and spies are tools that are used to track the behaviors of those functions so they track behaviors such as whether the function has been called or how many times it has been called or with what arguments the function was called with now as I said mocking is used to isolate the unit of code being tested so it basically allows you to replace a complex or slow or unavailable dependency with simpler versions and this isolation prevents tests from being affected by external factors and makes them more reliable and faster to execute so let me give you an example of why and when we can use this so I'm going to give you an example of like a database call so pain this scenario imagine you have a function that calls a database now testing this function could be problematic because it involves Network calls database setup and stuff like that but by mocking the database call we can simulate Its Behavior and focus solely on testing the functions logic now this is why testing using mocking and spice is very important now let's create and Implement mock functions using just so the first thing I'm going to show you how to do is to use just. FN so just. FN is a way of creating a mock function and it can be implemented to return a specific value of perform a specific action let me just show you what I'm talking about so right here in sum. test.js I'm going to remove all of this and I'm just going to write const let me just say something like Mark call back equals to just FN now we're creating a mock function by saying just FN and let's just say x equal 42 plus X so as you can see this is a basic function and let's say I call this by saying mock call back and I give it zero now you if you understand JavaScript you know that this is just going to say 0 is equal to X so that means 42 + 0 is = to X so the new value of x will be 42 if I do the same and say call back one now this is just going to be 42 + 1 which is 43 now this is just a basic way that we just created a mock function but now I'm going to show you how to test for a mock function by using just so just going to get rid of all of this real quick and I'm actually going to write a real test now I'm going to say let's remove that and let's give it a description and the description will be something like mock implementation so this is just like a mock implementation let's say of a basic function and now that function just write this out that function open and close and now we're just going to create that same 42 plus X that we created initially and I'm just going to say const so as you can see right here we're not actually doing anything with the sum. JS because we don't really need to do anything here I'm just showing you how to implement a mock function right here so we're just going to say mock equals to just now we're going to use just FN and now we're going to say x is 42 + x as I said this is a very basic function we're just going to do is going to return 42 plus whatever value that we give it is basically what we want so now the next thing that we just need to do is to say expect more Mark and we call one we expect it to be do to be 43 so what this is just saying is that if we call this mock right here and give it a value of one or argument of one the what should be returned the value that we should get should be 43 and that is because once we give it one it adds that one to 42 and it should be 43 so let's make sure this is 43 give the semicolon and for now let's just save this and I'm just going to pull this up and right here what we just need to do is to say mpm test now when we say mpm test just as you can see it says one Past One total right now this is just a very basic way of using mock functions but we're going to do one more thing I'm going to introduce to you to have been C with so is it's kind of like another match up we haven't talked about this match up before I'm going to show you what this does right here so it's going to let's just say right here I'm going to say expect Mark do to I've been called with the H one now let's also add this semicolon here now this statement what it just does is that it checks that the mock function was called with the correct argument so if this assertion failed then just to provide an error message indicating what went wrong so what we're just doing is to make sure that we call this with one because we did call it with one right here we said mock one so this is just saying we're checking that mock should have been C with one we're just going to do the same thing that we did run mpm test and everything should also work successfully nothing went wrong so this is just a very basic way of using mock function for testing right here in just it's very easy it's very straightforward now I'm going to show you how to use just do spy on ingest so we're going to use it to spy as I explained earlier in this tutorial now what we're just going to do is right here in some. test.js I'm just going to go straight to writing this test I'm going to say test not this going to say spying on a method of an object we're going to create that right now and we're just going to say equals this and we're going to create this and we're going to say const video equals to I'm going to open that up and say play now we're going to open this play function up too just say return true right here and now we're just going to comma and right here we're going to add our semicolon now we're going to add just the spy on and why we're adding just the spy on is basically like tracking this particular video right here so we want to track and see if this play has been called in this video so what we're just going to do right here is to say con spy was just do spy on we say video and we're going to spy on play write that and we're going to say video do play open and close and add the semicolon and now we're going to say expect spy do two have been called and what we're just going to say spy. mock restore now this is just a basic test that we writing to track so let's get rid of this we're writing to track and make sure that this and track if this play has been displ function has been called right here and that's what we're just doing is we're saying cons spy we're saying just dop so this just dop is just a method to track CS to video. play so we're tracking when this video. play has been called and just the spy on this spy on right here it does not replace the functions implementation unlike just. FN that we talked about earlier so this allows us to observe the functions real Behavior now what we're just going to do is to just go ahead and run this and just going to save this and then going to pop up the terminal all right you are just going to say mpm test just going to hit enter so let's go back to terminal and hit enter as you can see it says one passed so that means it has been done successfully so as you can see everything works and let me just quickly explain this cuz we didn't talk about this so so expect spy. to have been called with so this line will check if the play method was called so this basically validates the spies functionality that we created so that's what these two have been called with does and the last thing we're going to talk about is this spy mock restore function so this spy Mo restore function in just is used to restore the original implementation of that function so the function that has been spied on using just do spy on this that is what is being used to restore the original implementation of that function now when we create a spy on a function just basically replaces the Spy function with a mock function now this allows you to like track calls argument and return values of that function but in some cases you might want to revert the function back to its original implementation that is why we use spym restore and that is what we did right here so that is the end of this tutorial and I hope you understood everything we did in this tutorial if you did please don't forget to click on the like button and subscribe and I'll see you in the next one
