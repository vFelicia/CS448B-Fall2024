With timestamps:

00:00 - Branches are one of the most important concepts. 
In this course, Tobias will give you a thorough  
00:05 - understanding on how branches work in Git. And 
don't forget to hit that subscribe button so you  
00:10 - don't miss any of our great courses. Hello Free 
Code Camp friends. My name is Tobias and I'm going  
00:16 - to explain how to work with branches in Git. One 
of the core and most important topics in Git and  
00:23 - version control is how you can productively 
work with your branches and what you can do  
00:29 - to start off. But before we go, let me have a 
huge shout out to the people at Free Code Camp  
00:36 - for teaching people how to code for 
free on the internet. Thank you so much  
00:40 - for being on that mission. And thank you 
for letting me help a little bit with that  
00:44 - contribution. A couple of words about my 
background, I'm part of the team behind tower  
00:50 - tower is a graphical user interface for Git on Mac 
and Windows. And we've been around for more than  
00:56 - 10 years now. And in those 10 years, we've 
helped around 100,000 people in companies  
01:02 - big and small freelancers, every developer 
in every part of the world, work more easily  
01:08 - with the good version control system, take the 
headache out of good and make it more more easy.  
01:14 - This workshop today will not be about tower, don't 
worry, you don't have to have tower installed,  
01:19 - we will do everything on the command line. So you 
can follow along, no matter what you're using.  
01:25 - So before we start, what's this going to be about? 
branches are one of the core concepts in Git. And  
01:31 - there's really an endless amount of things you 
can do with them, you can create and delete them,  
01:36 - you can compare, you can merge and rebase them you 
can publish and track them. So we're talking about  
01:43 - all of those things that you can do with your 
branches. Before we dive into the specifics,  
01:50 - let me just briefly talk about two core 
concepts that are mentioned again and again.  
01:55 - So one is the head branch. If you don't know 
that term, that's pretty important. It is the  
02:00 - currently active or the checked out branch, 
you can have many branches in your repository,  
02:05 - but you can have only one. And that is active at 
a single time. So if you hit get status on your  
02:12 - command line or are in a graphical user interface, 
you will see you are on a certain branch in this  
02:19 - example here on branch master. So master is 
currently the head branch, the active branch.  
02:25 - And the other core concept is the distinction 
between local and remote branches.  
02:29 - So when we're working with branches, we are in 99% 
of the time or 95% of the time, we're working with  
02:38 - branches in our local Git repository, right? 
The remote branches in your GitHub, git lab,  
02:45 - Bitbucket, as your DevOps, whatever you have, that 
they're more for synchronizing, right, the bulk of  
02:53 - the actual work happens in your local branches on 
your local machine in your local Git repository.  
03:01 - Alright, let's start by creating new branches. 
Right. So before you can work with branches, you  
03:09 - will first need to have some in your repository. 
And to create a new branch, you can just use the  
03:16 - git branch, command and provide the name of 
your branch. So my new branch is the name of  
03:23 - that new branch. And when I do it like that, when 
providing just a name to the git branch command,  
03:30 - git will assume that I want to start my new branch 
based on the currently checked out revision. So  
03:36 - I'm going to create a new branch on the situation 
that I was to this point. So if I'd like to create  
03:44 - a new branch at a specific other revision, 
let's say, let's see what revisions we have  
03:50 - in this repository. By the way, so this is this 
tower, the graphical user interface that we make.  
03:57 - So here is my new branch, I just created that. 
So that worked good news. If I want to create my  
04:04 - branch on a different revision, let's say 
I want to start here, I can just copy the  
04:12 - revision hash of that commit here. And then 
on the command line, I can type git branch,  
04:19 - other branch, that's the name and I wanted 
to start on that revision here. Alright,  
04:26 - let's see what that did. Alright, and new 
branch. So that worked. And it started  
04:32 - on that revision here, right? So you're pretty 
flexible with how you want to start your branches.  
04:40 - And again, as I mentioned briefly, in that 
core concept area just a few seconds ago,  
04:45 - you can only create new branches 
in your local repository, right?  
04:49 - Creating branches in a remote repository, happens 
by publishing an existing local branch so I can, I  
04:57 - can upload these here, but I can't Create a branch 
on a remote, we'll talk about that later on.  
05:06 - Or write git branch, either without 
mentioning a specific revision, then it's  
05:13 - going to be your current revision, or mentioning 
a specific one to started on a specific revision.  
05:21 - Alright, switching branches, of course, another 
very important action you're going to use all of  
05:28 - the time. So the current branch, the checked out 
branch, so to say, the head branch, defines the  
05:37 - context your work is in at the moment. And the 
current head branches where new commits will be  
05:43 - created, they will be created in that context. And 
to change the branch you're currently working in.  
05:52 - This means to check out another branch or to 
switch a branch. And let's see how we can do that.  
06:00 - All right, so at the moment, if I hit git 
status, I can see I am on branch main. So main is  
06:06 - currently checked out, this is my head branch. 
And if I want this to be a different branch,  
06:10 - I can type git checkout. And while we 
have so many beautiful new branches,  
06:16 - get new branch. And while I switched to 
branch, my new branch, so the git checkout  
06:25 - command is pretty versatile. It's it's used 
for so many things. In recent years, there  
06:31 - has been a new command added to the Git command 
palette, and I would suggest you use Git switch  
06:40 - in the future. Because Git switch is only for this 
purpose. It's only for switching branches. So if  
06:47 - we want to switch to we created other branch, I 
can type Git switch, other branch and get switch,  
06:55 - as I said, is a little bit more unambiguous. 
Because it only has this purpose. git checkout  
07:01 - is a command with lots and lots of meanings. 
So I'm more comfortable using Git switch,  
07:09 - git checkout and get switch again. So you can see 
in a graphical user interface, this is where the  
07:17 - head pointer now points to. So other branches, 
currently the checked out the active branch.  
07:26 - Okay, number three renaming branches, it's 
pretty easy to miss type A branches name or to  
07:33 - change your mind after the fact. So don't 
worry, you can rename branches, of course,  
07:39 - and get makes it pretty easy to rename your 
local head branch. So let's do that. So  
07:45 - we are currently on. Again, let's type git status 
to make sure we are on branch other branch.  
07:52 - And if I'm not happy with that naming, I can 
just change it using git branch with the dash  
07:59 - m parameter, and then provide a new name. 
So better branch, let's call it like that.  
08:05 - And take a look. Okay, I'm now on branch, 
better branch. And that was pretty easy.  
08:14 - So in case you want to rename a different branch, 
not the head branch, not the currently checked out  
08:21 - branch, then we have to provide the name of the 
old branch to to make this an ambiguous so at the  
08:28 - moment, we have, let's see what branches we have. 
We're using git branch without any parameters. All  
08:34 - right, so better branch main and my new branch. 
So let's say I want to rename a non head branch,  
08:41 - a branch that is not currently checked out. 
Let's say I want to rename my new branch here. So  
08:48 - let's make some room. Alright, so let's rename 
git branch, dash m, my new branch and call it  
08:59 - my better branch. Let's see if that work. git 
branch without any parameters shows you what  
09:06 - branches you currently have. And voila, we just 
changed the name of a non head branch like this.  
09:15 - So these commands are used to work for changing 
local branch names. If you'd like to rename a  
09:22 - remote branch, things are a little bit more 
complicated because Git doesn't allow you  
09:28 - to rename rogue remote branches really. 
So in practice, renaming a remote branch  
09:32 - can be done by deleting the old one and then 
pushing up publishing the new one from your  
09:39 - local repository. So let's take another look 
at what we have. So if I'm not happy with  
09:48 - origin, staging that naming here, I can delete 
that and then re upload it and I'll show you  
09:56 - how to publish upload your brand For the first 
time in a second, so we can see how that works.  
10:06 - All right, renaming branches with the git 
branch dash M. Command. And if you have  
10:12 - a non head branch that you want to rename, 
provide the old name, and then the new name.  
10:19 - This is for renaming remote branches. And we'll do 
that in a while we are creating a new branch and  
10:25 - pushing that for the first time. So we can do two 
things in one. All right publishing branches. As I  
10:33 - already said, it's not really possible to create a 
new branch on a remote repository. What we can do,  
10:39 - however, is republish an existing local branch on 
a remote repository. So we can upload what we have  
10:47 - locally to the remote server and thereby share it 
with our team, right. So let's see what we have  
10:56 - and what we can publish. Okay, so at the moment, 
we have this beautiful feature uploader branch  
11:04 - here, and it's not present on the remote. So let's 
say I want to publish that for the first time,  
11:09 - I want to upload it to the remote server named 
origin. And let's let's do that on the command  
11:15 - line. So I can just use git push dash u, I'll 
explain what the new flag is in a second.  
11:23 - On the Origin remote, and it's the feature, loader 
branch. Right, looking good. All right, here we  
11:35 - go. So we've just uploaded that to that branch 
here, that local branch to the remote repository.  
11:43 - Now, we'll be talking about this dash you 
flag here in great detail in a second. But  
11:50 - to give you the the the nutshell, right now, it 
tells Git to establish a tracking connection.  
11:57 - And this means pushing and pulling later on will 
be much, much, much, much more easy in the future.  
12:06 - So let's talk about that in detail. Because 
the whole topic of tracking branches is really  
12:13 - important to understand. By default, local and 
remote branches have nothing to do with each  
12:19 - other, they're stored and managed as independent 
objects in Git. But in real life, of course,  
12:25 - local and remote branches often do have a 
relationship with each other. For example,  
12:30 - a remote branch is often something like a 
counterpart of a local one, right? Such a  
12:36 - relationship can be established in Git. So one 
branch typically a remote one, or a local ones,  
12:42 - sorry, contrac. Another one, typically a remote 
one. So in this little diagram, here, you can  
12:50 - see we have a local branch, it's called develop, 
and we have a remote branch on the origin remote,  
12:56 - that's also called develop, and of course, I 
want them to have a relationship with each other,  
13:01 - they're the counterparts of each other. And 
with that tracking relationship establish,  
13:09 - when I later pull, or push, when I push from 
my local branch or pull from my remote branch,  
13:15 - I can simply use the vanilla Git commands, I can 
use git push and get pulled without any further  
13:24 - flags or parameters, because the tracking 
connection already knows in the can fill in  
13:30 - the blank. So which branch on which remote do I 
want to push to or pull from, for example, all of  
13:38 - that is already saved in the tracking connection. 
And we've already used such one way to establish  
13:46 - that so tracking connection when we use git push 
with the you option to publish that local branch.  
13:52 - And after that, as I said, we can guess just use 
git push without mentioning the remote or the  
13:57 - target branch or the source branch, this all works 
out. And this also works the other way around. So  
14:05 - what we did was publish a local branch to a 
remote repository. But we can also go ahead and  
14:14 - track or download a remote branch and bring 
it to the local repository right the other  
14:20 - way around is also possible. And we can also 
establish a tracking connection like that.  
14:25 - So let's see what we have. This would 
be number five. And we currently have,  
14:41 - right, a feature login branch on the remote 
that is not present here in my local branches.  
14:48 - So let's say somebody else worked on that feature, 
log in branch and I want to join that work and  
14:56 - work with that branch. So let's get 
that branch to my local branches.  
15:00 - And the way to do that is either to 
use git branch with the dash dash track  
15:06 - option. And this will be feature login. 
And it's coming from origin feature, login.  
15:16 - So by that I created a local branch called feature 
login, that is based on origin feature login.  
15:24 - And they know about each other, right? I 
established that tracking connection, and voila,  
15:30 - here we go, we now have that locally. And in 
a graphical user interface like tower, I can  
15:36 - see that yes, there is a tracking connection, 
right, this local branch tracks the remote one.  
15:43 - Another way to do that, well, 
let's create another branch  
15:50 - feature, downloader, so we have another local 
branch that is not present on the, on the  
16:02 - remote. And we'll publish that really quickly. And 
then remove it from here from my local branches.  
16:17 - Right, so again, we have that situation, I 
want to have that feature downloader branch  
16:23 - on my local branches. And currently, it's only 
present on the remote. So another way to do that,  
16:30 - instead of git branch dash dash track is 
to use the git checkout command. And again,  
16:38 - with the track option, so that's the same. And 
I'm basing that on origin feature, downloader.  
16:46 - And by not naming a local branch and just 
specifying the base, remote branch, get uses that  
16:58 - branch name for the local branches name, so I now 
have feature downloader here again, same thing  
17:05 - as before, so it doesn't really matter if you're 
using git branch dash dash track or git checkout  
17:10 - distressed track, it's just another way of doing 
that. Okay, tracking branches, very important,  
17:18 - either with git branch, distressed track, 
or with git checkout, dash dash track,  
17:25 - pulling and pushing branches. So once you have 
your tracking connection set up properly, pulling  
17:31 - and pushing is really simple and almost boring, 
actually. So that's why I strongly suggest to  
17:37 - work with the commands I showed you before either. 
When publishing a local branch with git push dash,  
17:44 - you are when tracking a remote branch from the 
other side with git checkout dash track command,  
17:52 - because again, once this tracking connection 
is set up, all you need to do is use Git pull,  
17:58 - and git push to sync your branches, right 
get pulled to download new commits from  
18:02 - the remote probably from your colleagues, and 
get push for uploading or publishing your own  
18:08 - new work to the remote server. You don't need with 
the striking connection setup, you didn't need any  
18:13 - additional parameters, you don't need to specify 
the remote like origin and the base branch or  
18:19 - the target branch and the source branch. Just get 
pulled and get push is enough. So that's the real  
18:26 - advantage of using those tracking connections. 
Let's take another look at what we have here.  
18:38 - and see what's happening. Okay, so currently we 
are on the feature login branch. And the Another  
18:47 - advantage of having those tracking connections 
set up is that Git tells me if my local branch  
18:54 - and the tract remote branch diverge. And that 
means that let's take another look at tower  
18:59 - and what what this looks like. So this feature 
login branch here has little numbers here. And  
19:06 - this means one commit hasn't been pushed 
yet. So the remote version of that branch  
19:13 - doesn't have one commit that I produced locally. 
And the other way around. Two commits are present  
19:20 - on the remote end to probably a co worker or 
a teammate made some commits. And I haven't  
19:25 - pulled those down. I haven't downloaded those. So 
this is really interesting to stay on track and  
19:32 - understand how local and remote branches 
diverged if there's something that I forgot  
19:37 - to push or haven't pushed yet. Or if there's 
something that I need to pull I need to update.  
19:44 - And with the command line with the git branch,  
19:49 - dash v command, I can get the same information. 
So I see feature logging is ahead one  
19:56 - behind two ahead means I have Local commit 
that is not pushed yet behind means I am  
20:04 - behind the remote. So there are new commits on the 
remote that I haven't pulled. Pretty interesting  
20:10 - information to understand where you are, how 
you act, how current your data is, you could say  
20:19 - how right deleting branches soap, most 
branches are not meant to live forever.  
20:27 - And I encourage you to do a little bit of 
housecleaning now and then. And here's how  
20:32 - to delete a local branch. That's pretty easy. So 
let's move to number seven. And see what we have.  
20:42 - Okay, feature uploader and main are there. The 
first thing you know to know is you cannot delete  
20:49 - the current head branch. So if I were to 
type git branch, dash D and feature uploader,  
20:59 - I would get an error message because I as I said, 
I can delete the branches currently active that  
21:05 - is currently head. So first, I would have to 
step away from that get switch main make main or  
21:11 - another branch active. And then I could use git 
branch dash D, and feature uploader to do that  
21:22 - loader and deleted branch 
feature uploader. So this is now  
21:28 - gone, right, I deleted that. In some cases, 
you will again, get an error message. Because  
21:37 - let's say you have worked on a local feature 
branch for some time produced some commits,  
21:42 - and then understand, okay, this, this doesn't 
lead anywhere I need to delete that you've  
21:47 - produced new commits that are present nowhere 
else. And if you try to delete that branch,  
21:52 - git will say, well, be careful, you are 
about to delete data that is present  
21:57 - nowhere else these commits haven't 
been integrated into other branches.  
22:00 - So are you really sure and that's when you need to 
use the dash f option force to force the deletion.  
22:11 - Needless to say, I guess that this is quite a 
destructive action with dash F for force. So  
22:18 - be careful you have a hard time getting 
those commits back. You can Don't worry, but  
22:26 - it's it has its reasons why good warns you Well,  
22:29 - these commits are present, nowhere else are 
you sure you want to delete that branch.  
22:34 - Another thing you might want to do is delete a 
remote branch. And as you already know, working  
22:41 - with branches on the local end is different than 
working on the remote. So it's a different command  
22:49 - git branch. Let's see what we have first. So 
let's say we want to delete that origin feature  
22:56 - downloader branch here on the remote. And we can 
do that using Git. clear up a little bit git push  
23:07 - again, and I want to remove something from origin. 
Delete flag is used here for feature down loader.  
23:21 - And let's see, all right, boom, there it is gone. 
So maybe another important thing to remember is  
23:32 - when deleting a branch doesn't matter if it's 
a remote one of our local one, keep in mind to  
23:37 - check if you should delete its counterpart branch 
to write the tracking branch. So for example,  
23:42 - if you've deleted a remote feature branch, it 
might make sense to also delete its local tracking  
23:48 - branch. That way you make sure you aren't left 
with lots of obsolete branches and a messy Git  
23:54 - repository, of course. So always keep in mind when 
I delete one branch, is there a counterpart branch  
24:00 - on the other end, either local or remote? 
And should I delete that too? Maybe. Okay,  
24:10 - deleting on the remote with git push, and 
dash, dash, delete. Merging branches are  
24:17 - pretty interesting topic. Merging is probably 
the most common way to integrate changes. So  
24:24 - essentially, you're bringing new commits from 
another branch into your current head branch.  
24:29 - That's always the direction, right? You're, you're 
integrating into your current local head branch  
24:35 - from another branch. And merging in most cases 
is very easy in in in Git and very simple,  
24:43 - different to other version control systems. 
So that's one reason why it's so popular.  
24:48 - And essentially, it just requires two 
steps. So first, you need to make active,  
24:53 - the branch that you want to have the changes come 
into that should receive the changes then execute,  
25:01 - execute the merge command with the name of the 
branch that has the desire changes on let's see  
25:10 - what we have here in our example scenario.  
25:16 - Okay, so at the moment Maine has a new commit that 
is this one here, title of error page corrected.  
25:24 - And uploader has also a different commit clarify 
CSS background rule. So they diverged. And let's  
25:32 - say I want to integrate this commit here or 
these changes the new commits on feature upload  
25:40 - into main, right, I want to bring the new 
changes into the main branch, then I can just  
25:48 - switch to main, make main active, and then just 
type Git merge feature, what was it uploader?  
25:58 - And voila, I'm getting an editor with a why 
is that, because merging most often not always  
26:05 - produces a merge commit, right? Think of that 
like a knot that combines or that connects two  
26:13 - branches. And this is a new commit. So I 
can provide a new commit message. And I'm  
26:18 - going with what Git provides here as a standard 
merge branch feature uploader. Just close that.  
26:25 - And let's see what happened. on Main wall, 
I just combined these two branches and,  
26:32 - and I have all of the changes 
here from both branches.  
26:40 - So this is what the end result looks like. As 
I said, there is this merge commit here that  
26:46 - combines the changes from both branches. And 
there is another way of integrating changes,  
26:55 - and that is rebasing, so this is just an 
alternative way to integrate commits from  
26:59 - one branch into another. And it's very important 
to stress that this is not better or worse,  
27:06 - this is not the the pro version and merges 
the beginner version, it's simply different.  
27:11 - If and when you're using rebase, mainly 
comes down to your personal preferences  
27:16 - and conventions in your team and the situation. 
So some teams love rebase, some prefer merge,  
27:22 - and some do in some cases and not in other 
cases. So it's not a matter of better or worse,  
27:28 - that's important to understand. So let's compare 
merge and rebase. So you understand what's  
27:34 - the difference. So this is the the starting 
situation, we have two branches, we have branch a  
27:39 - and branch B, and both have diverting changes 
are different changes. So we've couple commits  
27:45 - here and one commit here. And they they 
were branched off on this point here.  
27:51 - Now with merge, you've already seen that we would 
receive this merge commit in the end this melting  
27:59 - point or this not that combines these two commits, 
using rebase. On the other hand, the end result  
28:06 - will look quite different. So especially because 
there is no separate merge commit that will be  
28:12 - created this big difference. Using rebase. It 
appears as if development history had happened in  
28:18 - a straight line. There's not this, this branching 
out anymore, it happens, or it looks like it was a  
28:25 - straight line. And this has its pros and its cons. 
So but that's the result and the big difference.  
28:33 - And then starting the actual process is 
pretty simple. But let's do that in practice.  
28:40 - This is case number nine. And let's see what we 
have. Alright, so pretty similar situation like  
28:48 - before, on feature uploader, I have two commits 
these here that are present nowhere else. And on  
28:55 - Main I have this year that is present 
nowhere else. And let's say I would  
29:00 - like to integrate the changes from Maine 
into my feature uploader branch, right.  
29:07 - So the first step would be to switch to feature 
uploader to make that the head branch because,  
29:13 - as with merge, I am always integrating into my 
head branch. Right, the head branch is the one  
29:19 - that's being manipulated. I am already on 
feature uploader. So nothing to do here.  
29:29 - But the second step is Git rebase. And I want to 
rebase on Main. And that was already it. Let's see  
29:38 - what happened. Now you can see this title of error 
page corrected commit that used to be on Main  
29:44 - is now also present here on uploader. And as you 
can see, there's not this branching out this,  
29:51 - this melting, not no merge commit. This looks like 
a straight line. And that's the big difference  
29:57 - between merge and rebase. Again, if you're 
using a graphical user interface like tower,  
30:03 - you can just drag and drop to merge or if you 
keep the Alt key pressed it becomes rebase.  
30:09 - So these actions are pretty straightforward 
in a graphical user interface.  
30:15 - Alright, and so this is rebasing 
again, and final case or final action,  
30:23 - comparing branches, sometimes it's pretty helpful 
to compare two branches. So for example, before  
30:29 - you decide to integrate or delete a branch, you 
want to see how it differs from another branch.  
30:35 - Does it contain any new commits? Or not? Do I 
still need those? What's the difference? So let's  
30:42 - do this in practice. And see what we have. 
So similar situation should just before  
30:54 - feature uploader and main they diverged, they have 
different commits. And let's compare that and see  
31:01 - what is actually different between them. So I can 
type git log main double dot feature uploader. And  
31:17 - this shows me which commits are in our feature 
uploaded branch, but not in our main branch.  
31:24 - And thereby I can see, okay, these two commits are 
here, but not here. And this would also of course,  
31:31 - mean, if I integrated into main these two 
commits, would make it into the integration.  
31:39 - So I can understand the 
difference between those two.  
31:44 - If I want to see what's the difference between 
a local and a remote branch, I can also do that  
31:51 - same thing, actually. So let's compare my local 
Maine with the origin Maine. And the process is  
31:58 - pretty similar. git log, Maine. Let's start with 
origin Maine, and Maine. And I can see okay,  
32:07 - I have one commit currently in my local main that 
is not present in my remote branch origin main.  
32:16 - So I know. Okay, if I pushed now, I would upload 
this commit here because it isn't present there.  
32:24 - All right. I think this is it for today. To help 
you remember what you learned, I prepared a little  
32:34 - cheat sheet about this topics about all of 
the different commands that you can use in  
32:40 - regard to working with branches. Just hop on Bitly 
and get branch's cheat sheet and download that  
32:46 - for free. This comes in handy in your daily 
work, I'm sure of it. And you can download  
32:51 - the cheat sheet for free as you like. I hope 
there's a little bit of new information for you  
32:58 - here in this workshop and in the cheat sheet. 
Have fun creating deleting renaming, tracking,  
33:04 - pushing, pulling, comparing branches and work 
with Git. Thanks for your attention. Take care.

Cleaned transcript:

Branches are one of the most important concepts. In this course, Tobias will give you a thorough understanding on how branches work in Git. And don't forget to hit that subscribe button so you don't miss any of our great courses. Hello Free Code Camp friends. My name is Tobias and I'm going to explain how to work with branches in Git. One of the core and most important topics in Git and version control is how you can productively work with your branches and what you can do to start off. But before we go, let me have a huge shout out to the people at Free Code Camp for teaching people how to code for free on the internet. Thank you so much for being on that mission. And thank you for letting me help a little bit with that contribution. A couple of words about my background, I'm part of the team behind tower tower is a graphical user interface for Git on Mac and Windows. And we've been around for more than 10 years now. And in those 10 years, we've helped around 100,000 people in companies big and small freelancers, every developer in every part of the world, work more easily with the good version control system, take the headache out of good and make it more more easy. This workshop today will not be about tower, don't worry, you don't have to have tower installed, we will do everything on the command line. So you can follow along, no matter what you're using. So before we start, what's this going to be about? branches are one of the core concepts in Git. And there's really an endless amount of things you can do with them, you can create and delete them, you can compare, you can merge and rebase them you can publish and track them. So we're talking about all of those things that you can do with your branches. Before we dive into the specifics, let me just briefly talk about two core concepts that are mentioned again and again. So one is the head branch. If you don't know that term, that's pretty important. It is the currently active or the checked out branch, you can have many branches in your repository, but you can have only one. And that is active at a single time. So if you hit get status on your command line or are in a graphical user interface, you will see you are on a certain branch in this example here on branch master. So master is currently the head branch, the active branch. And the other core concept is the distinction between local and remote branches. So when we're working with branches, we are in 99% of the time or 95% of the time, we're working with branches in our local Git repository, right? The remote branches in your GitHub, git lab, Bitbucket, as your DevOps, whatever you have, that they're more for synchronizing, right, the bulk of the actual work happens in your local branches on your local machine in your local Git repository. Alright, let's start by creating new branches. Right. So before you can work with branches, you will first need to have some in your repository. And to create a new branch, you can just use the git branch, command and provide the name of your branch. So my new branch is the name of that new branch. And when I do it like that, when providing just a name to the git branch command, git will assume that I want to start my new branch based on the currently checked out revision. So I'm going to create a new branch on the situation that I was to this point. So if I'd like to create a new branch at a specific other revision, let's say, let's see what revisions we have in this repository. By the way, so this is this tower, the graphical user interface that we make. So here is my new branch, I just created that. So that worked good news. If I want to create my branch on a different revision, let's say I want to start here, I can just copy the revision hash of that commit here. And then on the command line, I can type git branch, other branch, that's the name and I wanted to start on that revision here. Alright, let's see what that did. Alright, and new branch. So that worked. And it started on that revision here, right? So you're pretty flexible with how you want to start your branches. And again, as I mentioned briefly, in that core concept area just a few seconds ago, you can only create new branches in your local repository, right? Creating branches in a remote repository, happens by publishing an existing local branch so I can, I can upload these here, but I can't Create a branch on a remote, we'll talk about that later on. Or write git branch, either without mentioning a specific revision, then it's going to be your current revision, or mentioning a specific one to started on a specific revision. Alright, switching branches, of course, another very important action you're going to use all of the time. So the current branch, the checked out branch, so to say, the head branch, defines the context your work is in at the moment. And the current head branches where new commits will be created, they will be created in that context. And to change the branch you're currently working in. This means to check out another branch or to switch a branch. And let's see how we can do that. All right, so at the moment, if I hit git status, I can see I am on branch main. So main is currently checked out, this is my head branch. And if I want this to be a different branch, I can type git checkout. And while we have so many beautiful new branches, get new branch. And while I switched to branch, my new branch, so the git checkout command is pretty versatile. It's it's used for so many things. In recent years, there has been a new command added to the Git command palette, and I would suggest you use Git switch in the future. Because Git switch is only for this purpose. It's only for switching branches. So if we want to switch to we created other branch, I can type Git switch, other branch and get switch, as I said, is a little bit more unambiguous. Because it only has this purpose. git checkout is a command with lots and lots of meanings. So I'm more comfortable using Git switch, git checkout and get switch again. So you can see in a graphical user interface, this is where the head pointer now points to. So other branches, currently the checked out the active branch. Okay, number three renaming branches, it's pretty easy to miss type A branches name or to change your mind after the fact. So don't worry, you can rename branches, of course, and get makes it pretty easy to rename your local head branch. So let's do that. So we are currently on. Again, let's type git status to make sure we are on branch other branch. And if I'm not happy with that naming, I can just change it using git branch with the dash m parameter, and then provide a new name. So better branch, let's call it like that. And take a look. Okay, I'm now on branch, better branch. And that was pretty easy. So in case you want to rename a different branch, not the head branch, not the currently checked out branch, then we have to provide the name of the old branch to to make this an ambiguous so at the moment, we have, let's see what branches we have. We're using git branch without any parameters. All right, so better branch main and my new branch. So let's say I want to rename a non head branch, a branch that is not currently checked out. Let's say I want to rename my new branch here. So let's make some room. Alright, so let's rename git branch, dash m, my new branch and call it my better branch. Let's see if that work. git branch without any parameters shows you what branches you currently have. And voila, we just changed the name of a non head branch like this. So these commands are used to work for changing local branch names. If you'd like to rename a remote branch, things are a little bit more complicated because Git doesn't allow you to rename rogue remote branches really. So in practice, renaming a remote branch can be done by deleting the old one and then pushing up publishing the new one from your local repository. So let's take another look at what we have. So if I'm not happy with origin, staging that naming here, I can delete that and then re upload it and I'll show you how to publish upload your brand For the first time in a second, so we can see how that works. All right, renaming branches with the git branch dash M. Command. And if you have a non head branch that you want to rename, provide the old name, and then the new name. This is for renaming remote branches. And we'll do that in a while we are creating a new branch and pushing that for the first time. So we can do two things in one. All right publishing branches. As I already said, it's not really possible to create a new branch on a remote repository. What we can do, however, is republish an existing local branch on a remote repository. So we can upload what we have locally to the remote server and thereby share it with our team, right. So let's see what we have and what we can publish. Okay, so at the moment, we have this beautiful feature uploader branch here, and it's not present on the remote. So let's say I want to publish that for the first time, I want to upload it to the remote server named origin. And let's let's do that on the command line. So I can just use git push dash u, I'll explain what the new flag is in a second. On the Origin remote, and it's the feature, loader branch. Right, looking good. All right, here we go. So we've just uploaded that to that branch here, that local branch to the remote repository. Now, we'll be talking about this dash you flag here in great detail in a second. But to give you the the the nutshell, right now, it tells Git to establish a tracking connection. And this means pushing and pulling later on will be much, much, much, much more easy in the future. So let's talk about that in detail. Because the whole topic of tracking branches is really important to understand. By default, local and remote branches have nothing to do with each other, they're stored and managed as independent objects in Git. But in real life, of course, local and remote branches often do have a relationship with each other. For example, a remote branch is often something like a counterpart of a local one, right? Such a relationship can be established in Git. So one branch typically a remote one, or a local ones, sorry, contrac. Another one, typically a remote one. So in this little diagram, here, you can see we have a local branch, it's called develop, and we have a remote branch on the origin remote, that's also called develop, and of course, I want them to have a relationship with each other, they're the counterparts of each other. And with that tracking relationship establish, when I later pull, or push, when I push from my local branch or pull from my remote branch, I can simply use the vanilla Git commands, I can use git push and get pulled without any further flags or parameters, because the tracking connection already knows in the can fill in the blank. So which branch on which remote do I want to push to or pull from, for example, all of that is already saved in the tracking connection. And we've already used such one way to establish that so tracking connection when we use git push with the you option to publish that local branch. And after that, as I said, we can guess just use git push without mentioning the remote or the target branch or the source branch, this all works out. And this also works the other way around. So what we did was publish a local branch to a remote repository. But we can also go ahead and track or download a remote branch and bring it to the local repository right the other way around is also possible. And we can also establish a tracking connection like that. So let's see what we have. This would be number five. And we currently have, right, a feature login branch on the remote that is not present here in my local branches. So let's say somebody else worked on that feature, log in branch and I want to join that work and work with that branch. So let's get that branch to my local branches. And the way to do that is either to use git branch with the dash dash track option. And this will be feature login. And it's coming from origin feature, login. So by that I created a local branch called feature login, that is based on origin feature login. And they know about each other, right? I established that tracking connection, and voila, here we go, we now have that locally. And in a graphical user interface like tower, I can see that yes, there is a tracking connection, right, this local branch tracks the remote one. Another way to do that, well, let's create another branch feature, downloader, so we have another local branch that is not present on the, on the remote. And we'll publish that really quickly. And then remove it from here from my local branches. Right, so again, we have that situation, I want to have that feature downloader branch on my local branches. And currently, it's only present on the remote. So another way to do that, instead of git branch dash dash track is to use the git checkout command. And again, with the track option, so that's the same. And I'm basing that on origin feature, downloader. And by not naming a local branch and just specifying the base, remote branch, get uses that branch name for the local branches name, so I now have feature downloader here again, same thing as before, so it doesn't really matter if you're using git branch dash dash track or git checkout distressed track, it's just another way of doing that. Okay, tracking branches, very important, either with git branch, distressed track, or with git checkout, dash dash track, pulling and pushing branches. So once you have your tracking connection set up properly, pulling and pushing is really simple and almost boring, actually. So that's why I strongly suggest to work with the commands I showed you before either. When publishing a local branch with git push dash, you are when tracking a remote branch from the other side with git checkout dash track command, because again, once this tracking connection is set up, all you need to do is use Git pull, and git push to sync your branches, right get pulled to download new commits from the remote probably from your colleagues, and get push for uploading or publishing your own new work to the remote server. You don't need with the striking connection setup, you didn't need any additional parameters, you don't need to specify the remote like origin and the base branch or the target branch and the source branch. Just get pulled and get push is enough. So that's the real advantage of using those tracking connections. Let's take another look at what we have here. and see what's happening. Okay, so currently we are on the feature login branch. And the Another advantage of having those tracking connections set up is that Git tells me if my local branch and the tract remote branch diverge. And that means that let's take another look at tower and what what this looks like. So this feature login branch here has little numbers here. And this means one commit hasn't been pushed yet. So the remote version of that branch doesn't have one commit that I produced locally. And the other way around. Two commits are present on the remote end to probably a co worker or a teammate made some commits. And I haven't pulled those down. I haven't downloaded those. So this is really interesting to stay on track and understand how local and remote branches diverged if there's something that I forgot to push or haven't pushed yet. Or if there's something that I need to pull I need to update. And with the command line with the git branch, dash v command, I can get the same information. So I see feature logging is ahead one behind two ahead means I have Local commit that is not pushed yet behind means I am behind the remote. So there are new commits on the remote that I haven't pulled. Pretty interesting information to understand where you are, how you act, how current your data is, you could say how right deleting branches soap, most branches are not meant to live forever. And I encourage you to do a little bit of housecleaning now and then. And here's how to delete a local branch. That's pretty easy. So let's move to number seven. And see what we have. Okay, feature uploader and main are there. The first thing you know to know is you cannot delete the current head branch. So if I were to type git branch, dash D and feature uploader, I would get an error message because I as I said, I can delete the branches currently active that is currently head. So first, I would have to step away from that get switch main make main or another branch active. And then I could use git branch dash D, and feature uploader to do that loader and deleted branch feature uploader. So this is now gone, right, I deleted that. In some cases, you will again, get an error message. Because let's say you have worked on a local feature branch for some time produced some commits, and then understand, okay, this, this doesn't lead anywhere I need to delete that you've produced new commits that are present nowhere else. And if you try to delete that branch, git will say, well, be careful, you are about to delete data that is present nowhere else these commits haven't been integrated into other branches. So are you really sure and that's when you need to use the dash f option force to force the deletion. Needless to say, I guess that this is quite a destructive action with dash F for force. So be careful you have a hard time getting those commits back. You can Don't worry, but it's it has its reasons why good warns you Well, these commits are present, nowhere else are you sure you want to delete that branch. Another thing you might want to do is delete a remote branch. And as you already know, working with branches on the local end is different than working on the remote. So it's a different command git branch. Let's see what we have first. So let's say we want to delete that origin feature downloader branch here on the remote. And we can do that using Git. clear up a little bit git push again, and I want to remove something from origin. Delete flag is used here for feature down loader. And let's see, all right, boom, there it is gone. So maybe another important thing to remember is when deleting a branch doesn't matter if it's a remote one of our local one, keep in mind to check if you should delete its counterpart branch to write the tracking branch. So for example, if you've deleted a remote feature branch, it might make sense to also delete its local tracking branch. That way you make sure you aren't left with lots of obsolete branches and a messy Git repository, of course. So always keep in mind when I delete one branch, is there a counterpart branch on the other end, either local or remote? And should I delete that too? Maybe. Okay, deleting on the remote with git push, and dash, dash, delete. Merging branches are pretty interesting topic. Merging is probably the most common way to integrate changes. So essentially, you're bringing new commits from another branch into your current head branch. That's always the direction, right? You're, you're integrating into your current local head branch from another branch. And merging in most cases is very easy in in in Git and very simple, different to other version control systems. So that's one reason why it's so popular. And essentially, it just requires two steps. So first, you need to make active, the branch that you want to have the changes come into that should receive the changes then execute, execute the merge command with the name of the branch that has the desire changes on let's see what we have here in our example scenario. Okay, so at the moment Maine has a new commit that is this one here, title of error page corrected. And uploader has also a different commit clarify CSS background rule. So they diverged. And let's say I want to integrate this commit here or these changes the new commits on feature upload into main, right, I want to bring the new changes into the main branch, then I can just switch to main, make main active, and then just type Git merge feature, what was it uploader? And voila, I'm getting an editor with a why is that, because merging most often not always produces a merge commit, right? Think of that like a knot that combines or that connects two branches. And this is a new commit. So I can provide a new commit message. And I'm going with what Git provides here as a standard merge branch feature uploader. Just close that. And let's see what happened. on Main wall, I just combined these two branches and, and I have all of the changes here from both branches. So this is what the end result looks like. As I said, there is this merge commit here that combines the changes from both branches. And there is another way of integrating changes, and that is rebasing, so this is just an alternative way to integrate commits from one branch into another. And it's very important to stress that this is not better or worse, this is not the the pro version and merges the beginner version, it's simply different. If and when you're using rebase, mainly comes down to your personal preferences and conventions in your team and the situation. So some teams love rebase, some prefer merge, and some do in some cases and not in other cases. So it's not a matter of better or worse, that's important to understand. So let's compare merge and rebase. So you understand what's the difference. So this is the the starting situation, we have two branches, we have branch a and branch B, and both have diverting changes are different changes. So we've couple commits here and one commit here. And they they were branched off on this point here. Now with merge, you've already seen that we would receive this merge commit in the end this melting point or this not that combines these two commits, using rebase. On the other hand, the end result will look quite different. So especially because there is no separate merge commit that will be created this big difference. Using rebase. It appears as if development history had happened in a straight line. There's not this, this branching out anymore, it happens, or it looks like it was a straight line. And this has its pros and its cons. So but that's the result and the big difference. And then starting the actual process is pretty simple. But let's do that in practice. This is case number nine. And let's see what we have. Alright, so pretty similar situation like before, on feature uploader, I have two commits these here that are present nowhere else. And on Main I have this year that is present nowhere else. And let's say I would like to integrate the changes from Maine into my feature uploader branch, right. So the first step would be to switch to feature uploader to make that the head branch because, as with merge, I am always integrating into my head branch. Right, the head branch is the one that's being manipulated. I am already on feature uploader. So nothing to do here. But the second step is Git rebase. And I want to rebase on Main. And that was already it. Let's see what happened. Now you can see this title of error page corrected commit that used to be on Main is now also present here on uploader. And as you can see, there's not this branching out this, this melting, not no merge commit. This looks like a straight line. And that's the big difference between merge and rebase. Again, if you're using a graphical user interface like tower, you can just drag and drop to merge or if you keep the Alt key pressed it becomes rebase. So these actions are pretty straightforward in a graphical user interface. Alright, and so this is rebasing again, and final case or final action, comparing branches, sometimes it's pretty helpful to compare two branches. So for example, before you decide to integrate or delete a branch, you want to see how it differs from another branch. Does it contain any new commits? Or not? Do I still need those? What's the difference? So let's do this in practice. And see what we have. So similar situation should just before feature uploader and main they diverged, they have different commits. And let's compare that and see what is actually different between them. So I can type git log main double dot feature uploader. And this shows me which commits are in our feature uploaded branch, but not in our main branch. And thereby I can see, okay, these two commits are here, but not here. And this would also of course, mean, if I integrated into main these two commits, would make it into the integration. So I can understand the difference between those two. If I want to see what's the difference between a local and a remote branch, I can also do that same thing, actually. So let's compare my local Maine with the origin Maine. And the process is pretty similar. git log, Maine. Let's start with origin Maine, and Maine. And I can see okay, I have one commit currently in my local main that is not present in my remote branch origin main. So I know. Okay, if I pushed now, I would upload this commit here because it isn't present there. All right. I think this is it for today. To help you remember what you learned, I prepared a little cheat sheet about this topics about all of the different commands that you can use in regard to working with branches. Just hop on Bitly and get branch's cheat sheet and download that for free. This comes in handy in your daily work, I'm sure of it. And you can download the cheat sheet for free as you like. I hope there's a little bit of new information for you here in this workshop and in the cheat sheet. Have fun creating deleting renaming, tracking, pushing, pulling, comparing branches and work with Git. Thanks for your attention. Take care.
