With timestamps:

00:00 - apis have become the backbone of
00:02 - software development making API testing
00:04 - an essential skill for developers and
00:06 - testers in this course Valentine despo
00:08 - will teach you how to use Postman to
00:10 - write and automate API tests from the
00:13 - fundamentals of API testing to the
00:15 - intricacies of automating these tests
00:18 - using Postman this course covers it all
00:21 - you will learn about variables scripts
00:23 - debugging JavaScript Basics Json format
00:26 - assertions regular expressions and more
00:29 - plus the course provides valuable
00:31 - insights into integrating Postman tests
00:34 - in CI CD and the fundamentals of
00:36 - collaboration within a postman workspace
00:39 - so let's start learning
00:42 - hello African campers and welcome to
00:44 - this course introducing you to API
00:46 - testing and automation with Postman my
00:49 - name is Valentine I'm a software
00:50 - developer with a passion for sharing my
00:53 - love for technology in a fun and easily
00:56 - digestible way in this course we will
00:59 - dive into why automated API tests are so
01:02 - important and how Postman can help with
01:04 - that my goal is to help those already
01:07 - familiar with creating requests in
01:09 - Postman explore the thrilling world of
01:12 - test automation with an emphasis on
01:14 - writing tests and automating test
01:17 - executions while this course is for
01:20 - beginners it is not for absolute
01:22 - beginners in terms of apis you will get
01:24 - most value out of this course if you
01:27 - already know what an API is and know how
01:29 - to use Postman to create requests if you
01:32 - are a total API rookie fear not free
01:35 - code Camp has at least two other courses
01:37 - to help you get your feet wet now let's
01:40 - turn our attention back to this video
01:43 - which wouldn't have been possible
01:44 - without the support of Postman the
01:47 - sponsor of this course for which I am
01:49 - very thankful
01:50 - throughout the course we will work with
01:53 - an existing Postman collection write
01:55 - tests and automate their execution with
01:58 - various tools by scheduling runs
02:01 - directly from Postman or by employing a
02:04 - third-party CI CD tool such as GitHub
02:06 - actions in other words we'll be focusing
02:09 - on test automation
02:11 - if you Ace all the assignments from this
02:13 - course you will be able to claim a
02:15 - postman badge that certifies you have
02:18 - completed this course and are a true Pro
02:20 - in test automation want more details
02:23 - check the video description for a link
02:25 - to the course notes there you will find
02:28 - essential resources and troubleshooting
02:30 - tips for when things go Haywire I will
02:33 - also be posting any updates or
02:35 - Corrections there after all this is a
02:38 - fast-paced industry where change is the
02:40 - only constant so if something is not
02:42 - working make sure to check the course
02:44 - notes first this action-packed course
02:47 - will surely keep you busy for a few days
02:50 - at least as always on free code Camp
02:53 - please help us create awesome content by
02:56 - liking and subscribing and hey if you're
02:59 - enjoying this course do me a solid and
03:01 - drop a comment below I'll do my best to
03:03 - answer if you learned something from
03:05 - this course I invite you to check out
03:07 - and subscribe to my YouTube channel Link
03:10 - in the video description below which is
03:12 - packed with content about Postman devops
03:15 - software development and testing also
03:18 - don't be shy connect with me on social
03:19 - media I would love to hear from you
03:22 - don't forget the sponsor of this course
03:23 - Osman their channel is chock full of
03:27 - valuable videos definitely worth a
03:29 - subscription so be sure to show them
03:31 - some love as well
03:33 - lastly a huge thank you in advance to
03:36 - those who will support free code Camp by
03:38 - clicking that thanks button and making a
03:40 - small donation I hope you're excited to
03:43 - learn more about automated API testing
03:45 - in Postman and with that being said
03:47 - let's get started
03:52 - welcome to the world of API test
03:55 - automation where we're about to embark
03:58 - on an Epic Quest full of surprises
04:00 - challenges and most importantly fun
04:04 - I want you to think about this course as
04:06 - a multi-level game where we'll conquer
04:08 - each stage together and level up our
04:12 - Postman testing skills to be a pro at
04:15 - this you need to go through four levels
04:17 - which will take us from manual testing
04:20 - all the way to automation
04:23 - we are at level 1 where we will use our
04:26 - trusty Postman collection for some
04:28 - manual testing
04:30 - we will also need to get up to speed
04:32 - with some JavaScript Concepts but don't
04:34 - worry I'll try to make this as easy as
04:37 - possible
04:39 - the first thing I need you to do is to
04:41 - open Postman for this I'm going to use
04:43 - postman on the web so it's essentially
04:46 - Postman in your browser if you go to
04:48 - postman.com and log in you should see
04:51 - something similar to this one
04:54 - so in this case I'm logged in inside my
04:56 - Postman account and I can manage here
04:58 - workspaces and Collections and you can
05:01 - see here that I'm logged in because I'm
05:02 - getting this nice icon here
05:05 - the first thing that I like to do when
05:07 - using Postman is to change to a darker
05:09 - theme so from settings
05:11 - I'm gonna select here themes
05:15 - and I'm going to select the Dark theme
05:17 - okay this is just a personal preference
05:19 - you don't have to do it but I'm going to
05:21 - use this throughout the course
05:24 - now once you have Postman open and you
05:26 - have logged in into your account we can
05:28 - now jump straight into the API
05:31 - open the course notes from the video
05:33 - description so in the video description
05:35 - you will find their link click on that
05:37 - link and you will be taken to a page
05:39 - that looks like this one
05:41 - located notes for this lecture
05:44 - and then you will find a link that takes
05:48 - you to a workspace
05:51 - this is the workspace that we will use
05:53 - throughout the course so it's important
05:55 - that you know where to locate this link
05:58 - to the workspace inside the course nodes
06:01 - what we have inside this workspace is
06:04 - the collection or an API
06:06 - as well as various assignments that you
06:09 - will need to do throughout the course
06:12 - this is the postman collection for an
06:14 - API named Valentino Artisan coffee house
06:17 - I love coffee so why not create an API
06:20 - for a fictitious coffee place
06:23 - this API helps browse a list of products
06:25 - view details and place an order for
06:28 - coffee
06:30 - of course in order to work with this API
06:32 - all we have to do is expand this
06:34 - collection here and we'll see here
06:37 - various endpoints that we can use for
06:40 - example we could use this request to get
06:42 - a status of the API
06:44 - as you can notice here everything is
06:47 - grayed out and we cannot make any
06:49 - changes to this
06:50 - to make changes to any of the
06:52 - collections in this workspace we need to
06:55 - make a copy in Postman we call this a
06:58 - form
06:59 - so essentially in order to work with
07:01 - this collection we need to Fork it
07:04 - now before we Fork this collection it is
07:07 - best to create a separate workspace that
07:10 - we will use throughout this course
07:12 - so from the workspaces here
07:15 - you will have here the possibility of
07:17 - creating a new workspace
07:20 - I'm going to name my workspace free code
07:22 - camp
07:23 - API test automation with Postman
07:28 - and I'm going to go ahead and make this
07:31 - a public workspace
07:33 - let's go ahead and hit that create
07:35 - workspace button
07:37 - so we need to switch back to the
07:39 - workspace and to do so we're gonna need
07:41 - to access that link that we have used
07:43 - previously
07:45 - so we need the link that we have used
07:47 - previously so that we go to this
07:49 - original workspace with all these
07:52 - Postman collections
07:54 - next what we'll do we'll go to this
07:56 - collection which holds the API
07:59 - and from the Ellipsis I'm going to click
08:01 - on it and we're gonna get here this menu
08:04 - and the option that we're gonna select
08:06 - is create a fork
08:09 - and when we select creative work there
08:12 - are still a few steps that we need to
08:13 - take
08:15 - first of all we're gonna be asked how we
08:17 - want to label this work and by default
08:19 - Postman will give us a suggestion and we
08:22 - can just go with that suggestion it does
08:24 - not matter so much at this point the
08:26 - next thing which is maybe a bit more
08:28 - important is where we are going to
08:31 - create this copy this work of the
08:34 - collection and we have previously
08:36 - created a new workspace so we're gonna
08:37 - select that workspace so instead of my
08:40 - workspace I'm going to click on it and
08:42 - I'm going to select here free code Camp
08:44 - API test automation with Postman
08:47 - next you will be asked if you wish to
08:50 - watch this collection
08:51 - watching a collection means getting
08:54 - notifications each time A change is made
08:57 - in the parent collection
08:59 - so if you don't want to be bothered with
09:01 - emails every time I change something
09:03 - about this collection it is best to
09:05 - uncheck this
09:07 - let's go ahead and click for collection
09:09 - now we have our own copy of this
09:12 - collection so for example if we expand
09:14 - it here and go here inside the status
09:17 - folder
09:18 - we can click on get API status and we'll
09:21 - be able to see here that
09:23 - send is enabled this is essentially a
09:26 - regular postmap collection where we can
09:28 - start making changes as we need it is
09:30 - totally independent of the previous
09:32 - workspace we have seen it's just a copy
09:35 - of the collection we made from that
09:36 - workspace so let's go ahead and simply
09:39 - click on the send button to see if this
09:41 - API is working
09:43 - so what you will see here is the message
09:46 - Api is up and running
09:49 - if you don't see this message if you see
09:51 - at this point some errors no need to
09:54 - freak out just refer back to the course
09:56 - notes and follow some of the
09:59 - troubleshooting ideas that I will list
10:01 - there
10:02 - but if you're seeing this message and
10:04 - we're also getting here a status 200
10:06 - okay you are on the right track
10:09 - a postman workspace is essentially a
10:12 - central point where collaboration occurs
10:15 - within a team
10:16 - we will use Postman workspaces to see
10:19 - Run results write comments and generally
10:22 - collaborate when working on apis
10:30 - before we continue exploring Postman
10:33 - let's first understand what API testing
10:36 - is
10:37 - API testing is a type of software
10:40 - testing that checks the functionality
10:43 - reliability performance and security of
10:47 - an API
10:48 - in simple terms we test API to make sure
10:52 - it works as it should API testing is
10:56 - like quality control in a car factory a
10:59 - car must go through various inspections
11:01 - and tests before it is considered ready
11:04 - for the road we really don't want to
11:07 - release a car that has no brakes
11:10 - ouch
11:11 - API testing focuses on examining the API
11:15 - from the Viewpoint of an external user
11:19 - the consumer of the API to ensure it
11:23 - behaves as expected
11:25 - the main goal of API testing is to find
11:29 - issues and defects in the API ideally
11:32 - before it is released and made available
11:35 - to user
11:37 - in this course we will focus on
11:40 - functional testing in functional testing
11:43 - we will examine if the API works as it
11:46 - should from a functional perspective and
11:49 - we're gonna look at individual API
11:51 - endpoints and ensure that they respond
11:54 - correctly to various HTTP requests other
11:58 - types of testing such as performance
12:00 - tests and security tests are outside the
12:04 - scope of this course
12:09 - before we can automate the testing of
12:12 - the API we first need to do a manual
12:14 - test we cannot automate something if we
12:18 - don't know how to do it manually
12:20 - in this lecture we'll go through all the
12:22 - endpoints of this API and check if they
12:25 - work as expected the idea of this API is
12:28 - pretty simple we have essentially a list
12:31 - of products that the coffee shop has
12:33 - available and we can submit an order for
12:37 - one or more products
12:39 - we're gonna begin here with a status
12:41 - endpoint because the status endpoint
12:42 - tells us if the API is available tells
12:46 - us if the API is up and running
12:49 - so if this endpoint isn't working
12:50 - properly testing the rest of the
12:52 - endpoints doesn't make a lot of sense
12:54 - and when we're doing this test what we
12:56 - want to do is first of all send a
12:58 - request see if something comes back in
13:00 - the first place and then when something
13:02 - comes back we're gonna take a look here
13:04 - at the status we typically expect status
13:06 - 200 okay
13:08 - and second of all we also want to take a
13:10 - look in the response body to see what's
13:13 - inside there so obviously this is coming
13:16 - from the API it's telling the API is up
13:18 - and running so this is already a good
13:20 - sign it tells us we have reached the API
13:22 - and this is a response from the API
13:24 - itself
13:25 - the next step is to take a look at the
13:28 - products that are available
13:30 - so I'm going to explain here the
13:31 - products folder I'm going to click on
13:33 - get all products you can also go ahead
13:35 - and close this previous tab as we don't
13:37 - need it anymore
13:38 - I'm going to click here on send
13:41 - so what we're gonna get here is
13:43 - something a bit more complex in terms of
13:45 - the response we're gonna still see
13:47 - status 200 okay
13:49 - and we're gonna get this relatively
13:51 - large response body that you see here so
13:54 - we can scroll through it and we're gonna
13:56 - see here a lot of products coffees and
14:00 - so on now there are a few things I want
14:02 - you to notice first of all we are
14:04 - getting here 33 results in total so this
14:07 - is some information about all the
14:09 - products are available
14:10 - and these results are paginated meaning
14:14 - they are not displayed all at once which
14:17 - means that if we want to go through all
14:19 - the products like the pages in the book
14:21 - we need to turn the pages
14:23 - so in order to facilitate that we also
14:26 - have some information we know what is
14:29 - the current page
14:30 - and we know how many pages are in total
14:33 - so for example if we want to go to the
14:35 - second page
14:37 - we need to use a query param so we'll
14:40 - see here the parents are already
14:42 - available the parents tab is already
14:44 - selected
14:45 - and one of the query patterns that we
14:47 - need to set is the page so if we enable
14:50 - this query param
14:52 - you can tell us the page that we want to
14:54 - fetch
14:55 - the default initially is one but we
14:57 - already have page one so let's go ahead
14:58 - and change this to 2.
15:01 - so now we're going to check if we have
15:03 - page two so we are now getting other
15:05 - products in the list and we can go on so
15:08 - on and so forth through all the pages
15:11 - apart from this what I want you to
15:13 - notice is that each product also has a
15:17 - category so there are a few categories
15:18 - for example let's say we are only
15:21 - interested in pastry so what we can do
15:24 - is copy the value pastry from here
15:27 - gonna disable the page initially
15:29 - but this time enable the param category
15:33 - I'm gonna paste here pastry
15:35 - and what we're gonna get back are only
15:38 - the products that are from the pastry
15:40 - category
15:42 - we're gonna see here the information has
15:43 - updated there are several results
15:45 - there's only one page in total and we're
15:48 - getting this page
15:50 - so if we go and scroll through this
15:52 - we're gonna see that all the products
15:54 - that appear here are from pastry
15:57 - right so this is how we can get a list
16:00 - of products but let's say for example we
16:02 - want some additional details about this
16:05 - croissant
16:06 - so in that case we have a separate
16:08 - endpoint and that is the get single
16:10 - product endpoint
16:12 - and what happens with this list is that
16:14 - a product can have a lot of information
16:16 - and we don't really want to display all
16:18 - that information at once
16:19 - for that we're gonna use the get single
16:22 - product so that we get information about
16:24 - a single product
16:26 - now I want you to notice a few things
16:28 - here so we have the base URL and then we
16:30 - have forward slash products and then
16:33 - we're using this annotation which
16:35 - denotes a path variable
16:37 - it's essentially something that's part
16:39 - of the path is the address where we can
16:42 - reach that particular product
16:44 - so let's say for example we have here
16:46 - this croissant and we want to get some
16:48 - additional information so I'm going to
16:50 - go ahead and copy the ID of this product
16:53 - I'm gonna go to get single product
16:56 - and paste this ID here
16:58 - let's go ahead and click on send
17:00 - and of course what we expect here is
17:03 - yeah the name is the same the ID is the
17:07 - same we're still in the category pastry
17:09 - but addition we're gonna get information
17:11 - like a product description which wasn't
17:13 - available before or in this additional
17:16 - text it's going to tell us it contains
17:19 - gluten and milk all right so now we have
17:23 - tested these two endpoints we have
17:25 - tested that we can get all the products
17:27 - and this endpoint also has some
17:30 - parameters that we can toggle on and off
17:33 - and play with them it seems everything
17:34 - to be working fine so we can just leave
17:37 - it as it is
17:38 - and then we can move forward
17:42 - now in order to move forward and place
17:44 - an order there are a few things that we
17:46 - need
17:47 - but let's go ahead and open the orders
17:50 - and this time to create an order we're
17:53 - gonna use a post request now what's
17:56 - important to know about a post request
17:58 - is that the post request typically has a
18:00 - request body something that we didn't
18:02 - have before so far we were like give me
18:05 - information about all the products give
18:07 - you information about a single product
18:08 - so it's like get get get get me that
18:11 - information but now I'm saying no no I
18:13 - want to place an order so for that we're
18:15 - using a post record and essentially in
18:18 - the body we're saying what we want to
18:20 - order so let's take a look at the body
18:22 - that is already here
18:24 - you'll notice that there's some
18:25 - information that's already entered here
18:27 - now what's interesting here is that we
18:30 - need a customer name so for example you
18:32 - know when you're ordering coffee
18:33 - somewhere you're gonna ask what's your
18:35 - name so that I know to call you when
18:37 - your coffee is ready so we need some
18:38 - customer name
18:40 - and what we have here is a random
18:43 - Postman variable
18:45 - a random Postman variable will generate
18:48 - in this case a full name with every
18:51 - request and it's not something
18:53 - hard-coded like for example if we're
18:54 - right here Jamie doe that would be a
18:57 - value that is hard-coded this is
18:59 - something that changes with every
19:00 - request and we're gonna take a look at
19:01 - that a bit later but just in case you're
19:03 - wondering this is the Syntax for one of
19:06 - this Postman random variables and apart
19:09 - from this what we have here are the
19:10 - products that we want to order so when
19:12 - we want to place an order we need to
19:14 - specify the products and we need to say
19:16 - which is the idea of the product and
19:18 - what is the desired quantity all right
19:21 - so let's go ahead and submit this order
19:23 - and see how it works come and click here
19:26 - on send
19:27 - and what we're gonna get back here is
19:30 - 403 Forbidden
19:33 - and apart from this we're gonna get also
19:36 - this error invalid API key
19:39 - now this is a bit interesting because
19:41 - this is not necessarily what we have
19:43 - expected
19:45 - we wanted to place an order but it does
19:48 - not look like this order has been
19:50 - successfully received on the other side
19:53 - and similar to this we also have other
19:55 - endpoints for example if you want to
19:56 - check what are all our orders that we
19:58 - have again 403 Forbidden invalid API key
20:03 - now the question is
20:05 - how does the API know who we are
20:08 - and how can an API then show us all the
20:11 - orders that we have
20:13 - we need a way to authenticate ourselves
20:15 - and this is a bit the topic of the
20:18 - upcoming lecture
20:19 - but in conclusion we went through some
20:22 - of the requests in this collection
20:25 - we have inspected the status code to
20:27 - determine if the call was successful and
20:30 - we also looked inside the response body
20:32 - to see the data that is there to see if
20:34 - that data actually makes sense
20:36 - this is a very basic form of testing we
20:39 - have manually tested if the API Works
20:41 - which as I said earlier is a very
20:44 - important step towards automation
20:50 - so how can we get this request work we
20:53 - need an API key which we don't have and
20:56 - without it we cannot send an order well
20:58 - in order to get that API key we need to
21:01 - register ourselves with the API now in
21:04 - order to do that we're going to go here
21:06 - to the clients folder and we're going to
21:08 - register a new client
21:10 - now in the context of apis when we're
21:12 - talking about clients or API clients
21:15 - we're referred to entities that are
21:20 - using the API a client in this context
21:23 - is not the same as a customer so for
21:25 - example for this coffee place API we
21:29 - wouldn't have the customers actually
21:31 - register themselves with the API we only
21:33 - need their name in order to process an
21:35 - order
21:36 - but what we would like to register as a
21:39 - client is for example a terminal where
21:41 - an employee types in this information
21:44 - in a more General context your Postman
21:46 - tool and your usage against this API is
21:49 - also a client when you are using Postman
21:51 - to connect to this API Postman is a
21:54 - client it's an API client that connects
21:56 - to it so we now we need to register
21:58 - ourselves with this API
22:01 - now again this is a post request because
22:04 - we're creating some data whenever you're
22:06 - creating some data we're also sending
22:08 - this data typically here in the body
22:10 - what we have here for the registration
22:13 - is an email we only need an email to
22:16 - register also
22:17 - now again here to test various scenarios
22:21 - we have a random email that's being
22:24 - inserted here so this is absolutely the
22:26 - same as writing something like jamie.do
22:29 - at example.com but Postman changes this
22:32 - all the time with a different value
22:35 - not so relevant at this point because we
22:37 - just want to register our status with
22:38 - this API
22:40 - so let's go ahead and click the send
22:42 - button
22:43 - and what we're getting back this time is
22:45 - 200 okay
22:47 - and what we'll see here is a token now
22:51 - token is sort of like a temporary
22:53 - password that's being used by apis
22:56 - and if you're working with apis we're
22:57 - going to come across tokens a lot
22:59 - but what's important about these tokens
23:01 - is that this is a secret this is
23:04 - something that only we should know and
23:07 - we want to make sure that we handle this
23:09 - Secret in a very careful way
23:12 - in Postman what we don't want to do is
23:15 - we don't want to put the secret inside
23:18 - the request
23:19 - we want to store it somewhere else where
23:21 - it is a bit more safer a bit more
23:24 - protected remember we have created here
23:26 - a public workspace
23:28 - if we put here a secret somewhere in our
23:31 - request
23:32 - well somebody else can just simply grab
23:35 - that secret and impersonate us this is
23:38 - something that we don't really want to
23:39 - do
23:40 - now let's go ahead and copy this value
23:44 - and what we're gonna do with it is we're
23:46 - gonna store it inside our collection as
23:50 - a postman collection variable
23:52 - I'm gonna hover here over the collection
23:54 - until this Ellipsis shows up I'm going
23:57 - to click on it
23:58 - and select here edit
24:01 - and this will open up information about
24:03 - the collection itself
24:05 - now what we can do next is to go here to
24:08 - the variables tab
24:10 - and what we'll see here is origin entry
24:13 - API key
24:15 - well apparently we need to enter here an
24:18 - API key and this API key will be used by
24:21 - the collection so obviously enter a
24:23 - valid API key is not an expected value
24:26 - so what we're gonna do is we're gonna go
24:29 - here under current value
24:31 - we're gonna paste the value that we have
24:34 - received when we have registered
24:36 - ourselves with the API
24:39 - and next I'm gonna click here
24:42 - it is super important that you
24:43 - understand the difference between the
24:46 - initial value and the current value
24:49 - because our workspace is public
24:52 - somebody else can see this information
24:54 - but from the outside the only
24:57 - information that is visible is here the
24:59 - initial value
25:00 - in the initial value our secret API key
25:04 - is not being exposed however when we are
25:07 - running a request with Postman only the
25:10 - current value is being used not the
25:13 - initial value so this token that we have
25:15 - here can be stored even in a public
25:18 - collection and can be used by US when
25:21 - working with Postman and sending
25:22 - requests at others from the outside
25:24 - cannot see this information
25:27 - so in a nutshell it is always a good
25:30 - practice to store any secrets that you
25:33 - have in Postman variables and to make
25:36 - them part as the current value unless
25:39 - you want to share them with others
25:41 - so now we have store this value so let's
25:44 - take a look at create a new order why
25:47 - didn't this request work
25:49 - well actually it has a bit of
25:52 - authentication here and the token that
25:55 - we have provided previously is not valid
25:57 - so let's try this request once again to
25:59 - see if it works now
26:01 - so now what we have here is actually
26:03 - status 201 created indicates this order
26:07 - has been created we're saying okay great
26:09 - let's take a look at the response by
26:11 - this to see what we have inside there
26:13 - and we'll have here the order ID
26:16 - this is our client ID so this is some
26:19 - internal idea that the API has assigned
26:21 - to us
26:22 - we know when this order has been created
26:24 - and we also know the customer name
26:27 - and you're probably wondering well where
26:29 - this Amy came from well this is the
26:32 - random full name that at the time of the
26:37 - execution postman has simply generated
26:40 - this random name we submit this request
26:42 - once again we're going to get a
26:43 - different
26:44 - and then in the lower part we also have
26:47 - the products that we have ordered
26:49 - still you're probably a bit confused
26:51 - where does this come from how does this
26:53 - work
26:54 - well typically authentication is being
26:56 - sent either as a query param so if you
26:59 - look here at the params you're gonna see
27:01 - no there are no query parents okay so if
27:03 - it's not a query param typically it is
27:06 - something in a header we can take a look
27:08 - here at the headers
27:09 - and again we're going to be uh no I
27:12 - don't see anything oh well let's take a
27:13 - look again you see here we have 10
27:15 - hidden headers right so let's click on
27:17 - this to expose this hidden headers that
27:20 - we have here
27:21 - let's take a look if there's anything
27:23 - that we oh yeah look at this
27:26 - x dash API Dash key so this looks maybe
27:30 - like our API keyer that year so how did
27:33 - our PostNet variable transform in this
27:36 - header here that's a bit weird right and
27:38 - you know how can we change this you know
27:40 - if you're trying to make some changes so
27:43 - it doesn't work okay so this is a bit of
27:45 - the magic of Postman trying to make
27:48 - things a bit easier for you to manage
27:51 - but you know if you're encountering this
27:53 - for the first time it can be totally
27:54 - confusing actually this has been
27:57 - configured using an off helper the name
27:59 - implies it's something that's designed
28:01 - to help you a bit and this is typically
28:03 - configured under authorization if you go
28:06 - here under authorization what we're
28:07 - gonna see here is well the type is
28:10 - inherited off from P it's actually says
28:13 - parent so it's just a bit smaller on my
28:15 - screen so it means do whatever the
28:18 - parent does in terms of authorization
28:20 - it's like oh which parent do you mean
28:22 - well as you can see this request is
28:25 - inside a folder which is called orders
28:28 - so we need to look inside the orders
28:30 - because that's the parent
28:32 - all right so we're now inside orders and
28:35 - what you see here have authorization
28:38 - this is the tab where we're active and
28:40 - what we have here in the list is API key
28:43 - because yes we have an API key and in
28:46 - this case the API key has a key name
28:50 - which we saw in the headers also has a
28:52 - value which this is how we reference the
28:55 - postman variables with curly braces and
28:58 - then this is added as a header and we
29:01 - actually saw the header
29:03 - the advantage of configuring this on a
29:05 - folder level is that all the other
29:07 - requests that we have can use this
29:09 - without us having to manually go through
29:12 - every request so let me show you for
29:14 - example if we go here to get all orders
29:17 - we expect here to see the order that we
29:19 - have just submitted
29:21 - so what do we see that is 200 okay looks
29:24 - good and here is our Amy ordering
29:28 - something from the API ordering
29:31 - something from the coffee place
29:33 - perfect
29:34 - so as you have seen nothing has changed
29:36 - just by placing a postman variable in
29:39 - the right spot and correctly configuring
29:42 - this request in terms of authorization
29:45 - can get things to work again
29:48 - now we still have one endpoint and that
29:50 - is get order by ID
29:52 - so you can simply go ahead and we
29:54 - already have here an ID let's go ahead
29:56 - and see if this works no we're getting
29:58 - back 404 not found well typically first
30:01 - founder font can mean two things either
30:03 - this order really doesn't exist or
30:05 - actually not our order
30:08 - so if you're looking here in the list of
30:10 - the orders that we have
30:11 - well we have a different order ID so how
30:14 - about we use that one
30:16 - and replace the value here
30:19 - let's click Send again and yes we're
30:21 - gonna see here the entire order that we
30:23 - have submitted
30:25 - including the products that were ordered
30:28 - which were previously not visible
30:30 - so in a nutshell this is how we wanna
30:33 - handle secrets in postman by using
30:36 - variables and also using this auth
30:38 - helpers which make our life a bit easier
30:41 - and also reduce the chances that we make
30:43 - any mistakes
30:48 - we need to be able to write scripts in
30:50 - Postman to automate the testing of this
30:53 - API
30:54 - API tests are written using Scripts and
30:59 - automated testing is a way to check if
31:01 - the API works correctly by letting
31:04 - Postman run some tests instead of
31:07 - running all these requests by hand and
31:09 - checking the status code and checking
31:10 - the body and so on
31:12 - this approach has many benefits most
31:15 - importantly it is faster and more
31:18 - accurate because a computer can run the
31:21 - same tests over and over without making
31:23 - mistakes
31:24 - computers are great at this humans tend
31:28 - to get bored and start making mistakes
31:31 - writing tests also helps document how
31:33 - the API should behave or how it used to
31:37 - behave in the past at least
31:39 - now leaving all the benefits behind
31:41 - let's actually start writing some
31:43 - scripts but where can we do that
31:46 - well let's expand here the status folder
31:48 - and get into the API status request
31:52 - in Postman there are two places where we
31:55 - can write scripts the first one is the
31:58 - prequest script and the second one is
32:01 - inside the test
32:03 - now what does pre-request script mean
32:06 - okay it is a script well prerequest
32:09 - means that this script is executed
32:12 - before the request is being sent and
32:15 - we're gonna get a bit into that why this
32:18 - is important and which are the use case
32:19 - but just keep this in mind you can write
32:22 - them before the request is executed and
32:25 - inside the test
32:27 - you can write some scripts that are
32:30 - executed after the request has been sent
32:32 - and a response has been retrieved
32:36 - so how does this look like well if we
32:38 - click inside the prequest script we're
32:40 - gonna have here this editor where you
32:42 - can start writing some code the same
32:45 - goes here for the tests pretty much the
32:48 - same editor so this is where we can
32:50 - write these tests inside this editor
32:52 - here
32:53 - in order to write the test here we need
32:56 - to use a programming language called
32:58 - JavaScript
33:00 - Postman only supports JavaScript and it
33:03 - is not possible to use any other
33:05 - programming language to write this
33:07 - Scripts
33:08 - however JavaScript is relatively easy to
33:11 - learn and also in the upcoming lectures
33:13 - we're gonna go a bit into JavaScript so
33:15 - if you've never written JavaScript
33:16 - before it's absolutely fine I'm gonna
33:19 - take you through this step by step no
33:21 - worries
33:22 - some people confuse JavaScript with Java
33:26 - another programming language but trust
33:29 - me they are super different and they
33:31 - don't have anything in common apart from
33:33 - this let's say unfortunate naming
33:36 - similarity but anyway just keep in mind
33:38 - JavaScript and Java definitely do
33:41 - different things all right so how do we
33:45 - write some code well let's go ahead for
33:47 - example and start with what we're doing
33:49 - a lot of programming language we start
33:51 - writing like a hello world thing so how
33:54 - do we do that well we can start typing
33:56 - here something like console.log
33:59 - you'll notice as I start typing you're
34:02 - gonna get this suggestion so if you hit
34:04 - enter
34:05 - it's gonna auto complete with the first
34:07 - option that you see in the list that is
34:09 - console
34:10 - I'm gonna write here Dot and there
34:12 - another suggestion pops up and I can
34:15 - even go and select what do I want to use
34:17 - here so if you start typing log you're
34:19 - gonna get only one suggestion and if I
34:22 - hit enter once again
34:23 - this suggestion will be completed this
34:26 - is just a quicker way on how you can
34:28 - type this and make sure that you're
34:29 - making fewer mistakes alright so console
34:31 - log is something that allows us to print
34:34 - a message so I'm gonna go ahead here and
34:37 - between parentheses and single or double
34:40 - quotes I'm going to write something like
34:42 - hello from the test
34:44 - okay so this is the message that we want
34:46 - to send out and at the end we're gonna
34:49 - terminate this instruction with a
34:50 - semicolon
34:52 - in order to actually execute this code
34:55 - we need to click on the send button so
34:58 - that we run the request this code is
35:00 - always associated with the requested
35:02 - sound
35:03 - so either we decide to run this code
35:05 - after we have executed the request or in
35:08 - the freequest script before we have
35:10 - executed the request in this case it is
35:13 - in the test so it's gonna be after the
35:15 - request has been sent and the response
35:17 - has been retrieved let's go ahead send
35:19 - this
35:20 - and we're not going to see anything
35:22 - however what's important here is that we
35:25 - are not noticing any errors if there
35:28 - were any errors we'd see them here in
35:30 - test results so for example let's
35:32 - replace log with a capital l o g
35:37 - just to make fun of this
35:39 - so console.log I'm gonna send this and
35:43 - we're gonna get here an error now this
35:45 - can be super scary when you when you
35:47 - encountering this so in JavaScript It's
35:49 - always important how you write things
35:51 - though things are always case sensitive
35:54 - with apis with programming you want to
35:56 - make sure that you write things exactly
35:58 - as they are so in this case we're going
36:00 - to get an error but
36:01 - if we write the everything correctly
36:03 - we're not going to see anything and this
36:05 - is because things are going to be
36:07 - printed to the postman console which is
36:09 - the topic of the upcoming lesson
36:15 - if you are writing script in Postman
36:17 - there is a postman tool you absolutely
36:20 - need to know and use and that is the
36:23 - postman console let me show you how to
36:26 - use the postman console to debug your
36:28 - scripts understand your requests and
36:31 - many many other things
36:33 - so in order to open the postman console
36:35 - we'll have to go here on the lower left
36:39 - corner
36:40 - and you'll see here console
36:43 - so if you click here on console
36:46 - this additional window will open up you
36:48 - already see here a lot of requests now
36:51 - first of all we don't need everything
36:53 - that is already here so we're gonna go
36:55 - ahead and click on this clear button
36:57 - now let's go ahead and submit this
37:00 - request once again
37:01 - where we have this console log script
37:05 - so what we'll see here in the postman
37:07 - console are two things
37:10 - first of all we'll have here the request
37:13 - where we're requesting some information
37:15 - and we can expand this
37:17 - and we're gonna see here request headers
37:21 - and other information from the response
37:23 - the response body so there's a lot of
37:25 - information about the request that has
37:27 - been sent
37:28 - what's important to know is that
37:30 - everything that appears in a console is
37:32 - in a chronological order so it appears
37:35 - as it happens
37:37 - now we have this script console log and
37:40 - because we have written the script we
37:42 - are getting this message in the console
37:44 - hello from the test
37:46 - because this is inside a test we are
37:49 - getting this message after this request
37:52 - has been sent
37:54 - let's say for example that we want to
37:56 - display a message before the request is
37:58 - being sent so I'm going to copy
38:00 - console.log I'm gonna go here to the
38:02 - prequest script
38:04 - and I'm going to paste the exact same
38:05 - code
38:06 - but this time I'm gonna write here hello
38:08 - from the prequest script
38:12 - hit again the send button
38:16 - and what we'll see here is that append
38:18 - it to what we already had in a console
38:21 - we now have Hello from the prequest
38:23 - script because this is being executed
38:26 - before the request
38:28 - then the request is being sent and only
38:31 - then hello from tests appears here in
38:35 - the logs
38:36 - let me show you a neat thing about this
38:38 - the thing is when we're working with the
38:40 - postman console and we're sending a few
38:42 - requests this entire log here will get
38:44 - really crowded with a lot of messages so
38:47 - instead of manually clicking on this
38:49 - clear button over and over again we can
38:51 - do a different thing so here in the
38:53 - pre-request I'm gonna write here console
38:57 - dot clear
38:59 - and I'm also make sure that I'm going to
39:01 - add here the parenthesis
39:02 - so what this will do is we'll clear the
39:05 - console with every request so let me
39:08 - show you what I mean I'm going to click
39:09 - here again on send
39:11 - you're gonna see here
39:13 - console was cleared
39:16 - the request is being sent and then the
39:18 - code that is in the test will be
39:20 - executed and we'll see this here
39:23 - we're gonna work with the post Bank
39:25 - console a lot so it's important to get
39:27 - familiar with it write this code
39:30 - understand where it appears understand
39:32 - in which order this code is being
39:34 - executed
39:35 - if you're no longer be in the console
39:37 - you can simply close it from here
39:39 - and if you need it again simply click on
39:42 - it again and it will appear here
39:48 - in this lecture we're gonna write our
39:51 - first API test in Postman and actually
39:54 - we're going to get a bit of help from
39:55 - Postman but just want to get to the
39:58 - taste of what is an API test so that we
40:00 - don't talk so much about API testing and
40:02 - actually start writing some
40:04 - so I'm here inside the get API status
40:08 - request I've opened up the test Tab and
40:11 - we already have here this console log
40:13 - message and we can continue writing here
40:15 - code but what kind of code are we going
40:18 - to write here well let's say that we
40:19 - want to assert we want to check we want
40:22 - to test
40:23 - if for this request we're getting a
40:25 - status 200 okay meaning the API is
40:29 - answering back and saying hey the status
40:31 - is okay everything is good you can use
40:33 - this API
40:34 - and we don't want to do this manually we
40:37 - don't want to look at the status code we
40:39 - want to forget that there's a status quo
40:40 - we don't know anything about it when I
40:42 - write a script and want to let postmen
40:44 - do this for us how can we do that
40:46 - well in that case what we can do here in
40:49 - Postman is that we can open here a panel
40:52 - so it's a bit hidden here on the right
40:55 - hand side it's not already expanded
40:57 - you'll have to click on this
40:59 - you will get here a list of Snippets
41:02 - these are useful scripts that you can
41:04 - use
41:04 - if you don't see the Snippets don't
41:07 - worry about it I will also include the
41:09 - exact same code that I'm using in the
41:11 - course notes for this lecture
41:13 - now if you can see the Snippets all you
41:16 - have to do is scroll a bit through the
41:19 - Snippets until you find here something
41:21 - that says status code code is 200. okay
41:24 - now before you click on that I want you
41:27 - to go here in the code editor
41:29 - hit enter to time so that we are here on
41:31 - line 3 now
41:33 - now you can simply go over status code
41:36 - code is 200 and click on it
41:38 - and by Magic this code will be generated
41:42 - okay now this code is written in
41:44 - JavaScript but it also contains like a
41:47 - language that is easy to understand so
41:49 - we have a test name which says status
41:51 - code is 200. that's pretty easy to
41:53 - understand
41:54 - and then we have here something that
41:55 - says pm.response to have status 200.
42:00 - this is essentially the assertion that
42:02 - we're making we're checking if the
42:04 - status is 200.
42:06 - so let's run this code again by
42:08 - submitting the request and see the
42:10 - difference
42:11 - now because we now have this test
42:14 - we are seeing here on the lower part of
42:16 - Postman test results
42:19 - we can click on this
42:21 - and what you will see here we're gonna
42:23 - see that we have different tabs for all
42:26 - passed skipped and filled essentially is
42:28 - going to tell us all the tests that we
42:30 - have here for this request and we have
42:32 - only one test status is 200 it says here
42:34 - pass right it's even integrated here in
42:37 - green one from one test half passed
42:41 - so this is the difference the difference
42:43 - between us manually checking if a status
42:46 - is 200 or writing some code and then
42:49 - checking here at the end has everything
42:51 - back we only have one test so obviously
42:54 - the difference is not so major right you
42:55 - can easily tell if it's 200 or not
42:57 - but let's say for example what if we had
43:00 - here five tests or six tests right
43:02 - Postman can do this in an instant and
43:05 - tell us if all the tasks that we have
43:07 - written pass or not
43:09 - now again what we have here is
43:11 - Javascript and now in the beginning uh
43:14 - it may look a bit weird right
43:16 - so the thing is we will look into better
43:20 - understanding JavaScript so that we can
43:22 - rewrite this kind of tests on our own
43:26 - but I just want to show you how easy it
43:28 - is to write your first test
43:31 - there's one important thing that I want
43:33 - you to take from this
43:34 - even if we have used Postman to quickly
43:37 - generate this code and we don't exactly
43:39 - understand what it's doing it's
43:40 - important that we ensure that this code
43:43 - is working so how do you ensure that
43:44 - this code is working well by generating
43:47 - a status code that's not 200. so in this
43:51 - case what we can do here is we can write
43:55 - here status 2 for example which is an
43:58 - endpoint that doesn't exist so when I'm
44:01 - sending this request once again against
44:03 - status 2 gonna get back here 404 not
44:06 - found
44:07 - and if I'm looking here at the test
44:09 - status I'm going to see Zero from one
44:11 - fail
44:13 - so this indicates that postman has
44:16 - executed this code which has a test it
44:20 - has checked is the status 200 no it's
44:23 - not 100 then bam alert it's not 200 it's
44:26 - reporting this information here so that
44:29 - we can easily see it
44:31 - we are starting to automate this and
44:34 - you're gonna get a taste of it real soon
44:41 - so we have created this code here by
44:43 - simply clicking one button
44:46 - I already don't fully understand what
44:48 - exactly is going on here how does this
44:50 - code work and how we can write maybe
44:52 - more advanced tests so to be able to
44:55 - understand this code which is written in
44:57 - JavaScript
44:58 - and even write more advanced code we
45:01 - need to learn a few JavaScript basics
45:04 - in the upcoming lessons we will cover
45:07 - some of the most important Concepts in
45:09 - JavaScript that are relevant for writing
45:12 - API tests in Postman we will cover
45:14 - JavaScript variables and their scope
45:16 - data types including object and arrays
45:20 - functions and many other things you
45:22 - should know now keep in mind that this
45:25 - is not a full JavaScript course and
45:27 - always check the course notes for
45:30 - additional resources and learning
45:32 - however with what you will learn in the
45:34 - upcoming lessons you should have just
45:37 - enough information to get started
45:39 - writing code in Postman and
45:41 - understanding such code if you see some
45:47 - one of the fundamental building blocks
45:50 - of any programming language including
45:52 - JavaScript is the concept of variables
45:55 - in this lecture we will learn about the
45:57 - JavaScript variables their declaration
45:59 - types and how to use them in our code
46:03 - variables are like containers that store
46:06 - data for us so that we can use them to
46:09 - store and manipulate information in our
46:11 - script
46:13 - you can think of a variable like a jar
46:15 - in a jar you can put something and then
46:18 - put a label on it so that you know
46:20 - what's inside so for example if you want
46:22 - to store a name like Jamie that's the
46:25 - data all we have to do is put JB in a
46:27 - jar and put a label on that jar
46:30 - which is like first name or simply name
46:34 - so let's do exactly that in Postman
46:37 - first of all I'm here inside the test
46:39 - script so I'm going to go ahead and
46:41 - remove everything that is inside here
46:43 - and in the prequest script I'm going to
46:45 - keep here console clear because that's
46:47 - going to be useful
46:48 - apart from this because we're gonna be
46:50 - focusing on scripts I'm going to change
46:52 - a bit to the interface of Postman first
46:55 - of all I'm going to collapse this panel
46:56 - here so there's an option here right at
46:58 - the bottom hide sidebar
47:00 - this will give us a bit more space
47:03 - and additionally there's a different way
47:05 - on how we can organize everything in
47:07 - Postman and one of this is this side by
47:10 - side pane so we have this two pane view
47:13 - which we can click on it it will move
47:16 - here a few things to the side so we'll
47:18 - see here
47:19 - the test results and everything but this
47:22 - is something that we actually don't need
47:23 - so we're gonna move this all together
47:25 - and we can also collapse this script so
47:29 - this gives us a bit more space to write
47:31 - this code and in addition to this you
47:33 - can open up here the console
47:36 - so that we have here the editor and the
47:39 - console in Clear View
47:41 - perfect so let's go ahead by actually
47:45 - defining a variable which is called
47:47 - Jamie so I'm going to use the keyword
47:49 - let which is used to define a new
47:52 - variable so you're gonna write here let
47:54 - and then we have to provide the variable
47:57 - name which is like on the jar the label
47:59 - so we can see here name
48:01 - and then I'm going to use the equal sign
48:03 - and between quotes I'm going to put here
48:06 - the name Jamie
48:08 - when we're working with strings like
48:10 - names or any text or something like that
48:13 - it is always important to put this
48:15 - between codes
48:16 - that this is when we have a string you
48:19 - can use single quotes or double quotes
48:21 - as you prefer now if we simply run this
48:24 - code
48:25 - nothing will happen
48:27 - so it's important to remember
48:29 - that if you want to check what's inside
48:31 - the name variable then we'll have to use
48:34 - here console log
48:37 - and what we're gonna do here we're gonna
48:39 - pass name
48:41 - between the parentheses we're gonna
48:42 - write name
48:44 - in this case it is important that you
48:46 - don't put quotes
48:49 - so let me show you we're gonna click
48:50 - here on send
48:52 - and what we're going to get back is
48:54 - Jamie so what is happening here is by
48:58 - not using name between quotes we are
49:01 - actually referencing the variable name
49:04 - and then by referencing the variable
49:06 - name we're essentially we're trying to
49:08 - log this variable well what's the value
49:10 - of this variable well it's Jamie okay
49:12 - let's write that so this is why Jamie
49:15 - appears here in the console
49:17 - it's important to remember that this
49:20 - code that we are executing here in
49:21 - Postman
49:22 - doesn't store anything anywhere this jar
49:27 - with a label name will be destroyed
49:30 - after the execution of the code so it's
49:31 - available while we run this code here
49:34 - but once the execution has stopped this
49:37 - variable no longer exists so for example
49:39 - here I'm gonna simply comment this code
49:42 - out so I'm gonna write here forward
49:44 - slash forward slash it essentially
49:46 - ensures that this code is not being
49:48 - executed it's commented out
49:51 - and if I run this request once again
49:53 - we're gonna get back here reference
49:56 - error which is a JavaScript error
49:58 - telling us
49:59 - name is not defined
50:01 - you are trying to log here a variable
50:04 - called name but name hasn't been defined
50:07 - anywhere so this is why this code is
50:09 - failing this is just a demonstrate that
50:12 - this variable only exists during the
50:14 - execution of the code all right
50:17 - so now these are the absolute basics in
50:19 - terms of defining a variable and using a
50:22 - variable
50:23 - so how about we next Define two numbers
50:27 - so let's say I want to define a number
50:29 - which is called a
50:32 - I'm gonna write here a
50:34 - equals 20. and I'm going to find another
50:38 - number called B which equals 30.
50:41 - as you can tell
50:43 - 20 and 30 are not between quotes
50:46 - but if we're trying to put here in
50:49 - console log a
50:51 - you're going to get 20. there are no
50:53 - errors this is because 20 is a number we
50:56 - can even
50:57 - by comma separating A and B we can even
51:00 - log A and B together
51:02 - we're going to get here 20 30. we can
51:05 - see two values at the same time
51:07 - sometimes we want to create variables
51:09 - that are the result of some operation
51:12 - for example we may want to Define here a
51:15 - variable which is called sum
51:17 - and wanted to hold the result of adding
51:20 - A and B so we can write here A plus b
51:24 - so what we're going to do here we are
51:25 - going to initialize a new variable which
51:27 - is called sum but here we're gonna have
51:30 - this mathematical operation which adds A
51:33 - and B so let's take a look here at the
51:36 - value of sum
51:38 - we can add that to the list as well
51:41 - you're going to see here that if we're
51:43 - adding 20 and 30 the sum will be 50. the
51:47 - advantage of using these variables is
51:49 - that we can change one of the variables
51:51 - we don't need to change anything about
51:53 - that code
51:54 - and then the sum variable will be
51:56 - updated accordingly so we have here A
51:59 - and B and some referenced in multiple
52:01 - places but we only need to update them
52:03 - once
52:04 - sometimes we also need to join strings
52:07 - together
52:08 - say for example we have here a variable
52:10 - which is called first name
52:13 - and just as well we have another
52:15 - variable which is called last name
52:18 - so these are two strings now let's say
52:20 - that for this person we actually need
52:23 - the full name so we're going to Define
52:24 - here a new variable which gonna call
52:26 - full name
52:28 - and in this case full name will be
52:31 - pretty similar to the way we have added
52:34 - two numbers and you may be surprised by
52:35 - this but we can use here first name plus
52:38 - last name
52:41 - so let's see what's happening there
52:44 - I'm Gonna Change here the console log so
52:46 - that we can log this variable
52:48 - we're going to see here in the console
52:51 - Jamie Doe
52:53 - now of course this is less than ideal
52:54 - because there's no space between Jamie
52:56 - and dough
52:58 - but just as well as we have added here
53:01 - first name and last name we can also
53:04 - directly write a string here so we can
53:06 - write here after the plus sign in
53:08 - between quotes we have here quotes
53:11 - and then we're gonna add another plus
53:14 - sign so we are combining first name with
53:17 - an empty string and with a last name now
53:20 - in this empty string all I have to do is
53:22 - press the space bar
53:25 - and we're going to create a white space
53:27 - so if we're running this code again
53:30 - what JavaScript will do is you cannot
53:32 - take the first name variable
53:34 - take its value
53:35 - then combine it with white space you'll
53:38 - notice here between Jamie and though
53:40 - there's a white space now
53:43 - and then add do
53:45 - so now we have defined a new variable
53:47 - with a combination of two variables and
53:50 - also something that we added in between
53:53 - how we write these variables in
53:55 - JavaScript is super important for
53:58 - example you notice here that first is
54:01 - written in lowercase but
54:03 - n here in name is with a capital N
54:09 - if we replace this
54:11 - and have everything in lowercase and try
54:13 - running this once again
54:15 - we're going to get an error and
54:17 - sometimes this can be so confusing for
54:19 - beginners it's like what do you mean
54:20 - first name is not defined I've just
54:22 - defined it here it's right here I can't
54:25 - even find it right so if something like
54:27 - that happens always need to trace back
54:30 - to what you have written and quite often
54:32 - you're looking at the screen and looking
54:34 - at what I'm doing and it's like no it's
54:36 - the exact same code as you and mine is
54:38 - not working
54:39 - now the reality is that if the code
54:42 - would have been the same it should have
54:45 - worked the same but even just one letter
54:47 - A Difference can cause the code to have
54:51 - such an error right so when you're in
54:53 - the beginning it's always a good idea to
54:55 - Simply copy paste things instead of
54:58 - writing them on your own because some
55:00 - mistakes are a bit hard to spot and
55:02 - especially if you're not working with
55:03 - these errors and you don't understand
55:04 - exactly what they mean can be a bit hard
55:07 - so always if something isn't working
55:09 - make sure that you really have
55:11 - everything as you see here on the screen
55:14 - no first name in lowercase and first
55:17 - name with the first letter of each World
55:19 - capitalized except for the first word is
55:23 - called camel case camel case is a widely
55:26 - used naming convention in JavaScript for
55:29 - naming things
55:31 - as it makes things easier to read it
55:34 - enhances readability
55:37 - so now we are getting pretty comfortable
55:39 - with this variables and as the name
55:42 - implies
55:44 - a variable can change its value and
55:47 - using a variable is super useful because
55:49 - we can change the value as needed we can
55:52 - change its values during the execution
55:53 - of the script or you can change it later
55:55 - on we can reference a value in multiple
55:59 - places without asking it to hard code it
56:02 - right so instead of having here full
56:04 - name once again written like Jamie space
56:07 - though you can simply reference over
56:09 - this all these variables now the
56:11 - opposite of a variable is a constant and
56:15 - once we Define a constant we cannot
56:17 - change its value so just so that you
56:20 - understand what I mean by changing a
56:22 - value so for example we have here first
56:24 - name and for some reason we decide yeah
56:27 - first name doesn't have the right value
56:29 - that we wanted to have so we want to
56:31 - make a correction to it so I'm going to
56:33 - write here John instead of Jamie right
56:35 - this is possible you notice here I'm not
56:38 - using the let keyword anymore I'm
56:40 - writing this code once again
56:42 - and then I'm gonna see here we have John
56:44 - Doe right so we can change this value
56:46 - when we Define it once but because we
56:48 - have used let we can change this now
56:51 - let's take a look at the following
56:53 - example
56:54 - I'm going to replace here for example
56:56 - first name
56:58 - and instead of let I'm gonna use cons
57:00 - I'm gonna say you cannot change this
57:03 - first name right and initially the code
57:06 - Works absolutely the same no different
57:08 - but when we're trying to enable this
57:11 - line of code which changes the first
57:13 - name
57:14 - this time
57:15 - we're going to get an error here it's
57:17 - like whoa
57:18 - whoa what are you doing it's like you
57:20 - have defined first name as a constant
57:23 - you cannot change a constant
57:25 - and this thing failed
57:28 - so this is just JavaScript telling you
57:31 - you told me to take care of this
57:33 - variable and to keep it sealed there in
57:36 - the jar and not allow any changes to it
57:38 - and now you want to change it no no no
57:40 - no this is not possible okay so this is
57:42 - why we have this constant now sometimes
57:45 - it does make sense to use a constant or
57:47 - other times you don't need a constant so
57:49 - in this case you know it really depends
57:52 - maybe it's not the greatest example but
57:54 - let's say how about you if you have here
57:56 - something like year of birth right so
57:58 - let's say I have here const we're going
58:00 - to Define here here
58:02 - of birth
58:04 - and we're gonna say here is 1995 or 94
58:08 - whatever
58:09 - well it kind of makes sense if we're
58:11 - storing information about the person
58:14 - the ear of birth is Something That We're
58:16 - Not Gonna Change right so maybe we're
58:19 - gonna change the last name for some
58:21 - reason
58:22 - maybe we can change other information
58:23 - like an email or address phone number
58:27 - but year of birth you know that that is
58:30 - a constant but it doesn't change right
58:33 - the same we can store like how many
58:35 - seconds are in an hour right this is
58:36 - also something like a constant doesn't
58:38 - change so whenever we have data where
58:40 - from a logical perspective it doesn't
58:43 - make sense to Define this as a variable
58:47 - then we should use a constant
58:53 - when we are working with variables in
58:55 - JavaScript there's an important thing
58:57 - you need to know about and that is the
58:59 - variable scope scope is just a fancy
59:01 - name for like where is a variable
59:04 - available
59:05 - for example we already know that this
59:07 - variable name that I've defined here is
59:09 - only available during the execution of
59:11 - this script
59:13 - the same goes for the prequest script if
59:15 - we Define here a variable this is going
59:17 - to be available only in the prequest
59:18 - script we cannot reference it in the
59:21 - test script or something like that and
59:22 - also if we run this request and Define a
59:25 - variable and we run the request again
59:26 - and try to reference the same variable
59:29 - that's not going to work because that
59:30 - variable will be gone by that but still
59:33 - within the same script so inside the
59:36 - test here we can still have a scope
59:39 - so in JavaScript we can Define another
59:42 - scope so like essentially another area
59:45 - where we can Define variables and this
59:48 - is inside a code block so right now I
59:51 - have defined this variable name Jamie
59:53 - and I'm using here console log on name
59:56 - and I'm seeing here the variable being
59:59 - displayed in the console perfect
60:01 - now what we can do here is put this
60:05 - inside a code block so I'm going to
60:07 - start here code block with a curly
60:08 - bracket
60:09 - and I'm going to end it with a curly
60:11 - bracket as well so this is a code Block
60:14 - in JavaScript
60:15 - it is not very useful in this concept
60:17 - but I just wanted to illustrate what it
60:20 - means for code to be defined inside a
60:23 - code block
60:24 - so if we try here for example adding
60:27 - another console log statement we're just
60:29 - gonna get here Jamie Jamie perfect
60:33 - but let's see what will happen if we
60:36 - Define the name
60:38 - Jamie here well we're gonna get the
60:41 - Jamie Jamie
60:42 - but what if we change Jaime to Jake
60:46 - let's try it once again
60:48 - and we're gonna get here
60:51 - Jake and Jamie so what exactly is going
60:55 - on here and why can we redefine this
60:58 - variable if we already defined it right
61:00 - we know this here we have the let
61:02 - keyword two times what's going on
61:05 - well these are a bit the rules of this
61:08 - code block so what this code block
61:11 - allows us to do
61:12 - is to Define our own variables in the
61:16 - code block so in this case we have here
61:18 - what is called the global scope we have
61:21 - a variable name
61:22 - and we are here in the global scope then
61:25 - we have a code block and then we're back
61:26 - in the global scope so console log
61:30 - will not be able to see what's happening
61:33 - here inside this code block
61:36 - and we'll essentially say okay you're
61:38 - trying to log a variable name I know
61:40 - here variable name I'm going to try and
61:42 - print this out so the name will be Jamie
61:44 - it appears here and here inside the code
61:46 - block we have declared a new variable
61:50 - which is called name it is just a
61:52 - coincidence that it has the exact same
61:54 - label exact same name as the previous
61:57 - variable
61:58 - but we can just use it here inside the
62:00 - scope we can make changes to it and so
62:02 - on so this is why we can see here a
62:05 - variable called jig and we're going to
62:07 - be able to access it here now let's take
62:10 - a look at what happens if we remove the
62:13 - first Declaration of the variable so we
62:15 - only have the code block
62:16 - now if this is the case all we're going
62:19 - to get here is a reference error gonna
62:22 - see here name is not defined
62:26 - and this is because we are trying here
62:28 - to access name from the global scope
62:31 - and in the global scope this variable
62:33 - hasn't been defined
62:35 - now there are a few things that we can
62:36 - do let's say for example well we only
62:39 - want to Define it in the global scope
62:40 - perfect in that case what we could do
62:42 - here is we're gonna write here latiname
62:45 - and if we remove here the lat
62:49 - what will actually happen is that when
62:52 - we're initializing here name we check
62:54 - we're not defining a new variable but
62:57 - we're using one from the global scope so
62:59 - let's see if this works
63:01 - we're going to get here Jake Jake so
63:03 - what has happened here we've defined
63:04 - here variable but we haven't set the
63:06 - value
63:07 - then inside the code block
63:09 - we have set a value to Jake we have
63:12 - printed it and then because this
63:14 - variable is defined in the global space
63:16 - we can also access this here
63:19 - now I can totally understand that this
63:22 - can be a bit confusing but you can think
63:24 - about this code blocks like a one-way
63:27 - mirror in an interrogation room you see
63:30 - in the movies
63:31 - the cops in the room can see outside
63:35 - but the suspect cannot see in the room
63:38 - so this is a bit hard to understand but
63:41 - if there is one takeaway I want you to
63:44 - get from this lecture is that whenever
63:47 - you're noticing here a code block
63:50 - pay close attention to variables and
63:53 - understand where they have been defined
63:55 - and I'm going to point this out also
63:58 - later in the course but this is
64:00 - something that tricks a lot of people
64:02 - and they don't understand where exactly
64:04 - is a variable defined why do I get a
64:07 - variable undefined error and similar
64:10 - things like that
64:11 - so we're gonna start working with this
64:13 - but in this lesson I just wanted to
64:15 - introduce you to this concept so that
64:17 - you can start getting familiar with it
64:19 - and notice when this is the case
64:22 - so in a nutshell
64:24 - in a scope we can Define some variables
64:26 - and nobody from outside will be able to
64:30 - see what's going on inside that code
64:31 - block Gonna Keep it like private like
64:34 - what's happening in the code block is
64:36 - only what is behind the one-way mirror
64:39 - but what is happening here in the global
64:41 - spaces is something that is public
64:43 - knowledge for everyone so we can read it
64:46 - in the global space but if we need
64:47 - access from the code block we can also
64:49 - see what's going on there
64:56 - in JavaScript there are a variety of
64:58 - data types that are needed to represent
65:00 - information
65:02 - this lesson aims to provide a basic
65:04 - understanding of the JavaScript data
65:06 - types you are most likely to encounter
65:09 - when writing scripts in Postman these
65:12 - are strings numbers booleans objects and
65:17 - arrays
65:18 - by understanding the usage of these data
65:21 - types you will be better equipped to use
65:24 - them when writing script
65:26 - so far we have interacted with two data
65:29 - types we have worked here with strings
65:32 - for example in this case we're
65:34 - initializing a variable called name with
65:37 - the string Jake and also number and
65:42 - you'll notice here that numbers are not
65:44 - between quotes
65:46 - if you're not sure about the data type
65:48 - of a particular value
65:51 - JavaScript is there to help you so let
65:53 - me show you for example we can use
65:55 - console.log
65:57 - an inside console.log we can use the
66:00 - keyword type of written together
66:03 - and this will give us the type of
66:06 - whatever we provide after this so for
66:09 - example if you're trying to get the type
66:10 - of name let's go ahead and see that
66:14 - we're gonna see here we're getting
66:16 - string
66:18 - just as well instead of referencing a
66:20 - variable we couldn't simply write here
66:22 - something like
66:24 - Jamie and we're gonna get back a string
66:28 - we can write here 29
66:31 - and we're gonna get back also a string
66:34 - well the thing is 29 is between quotes
66:37 - so anything that is between quotes even
66:39 - if it is a number
66:40 - it would still be a string from a
66:43 - JavaScript perspective so not to make it
66:45 - a string to make it a number we'll have
66:47 - to remove the quotes
66:48 - run this once again and we're gonna see
66:51 - this is a number okay perfect so we are
66:55 - kind of like understanding a bit how
66:57 - things work
66:58 - if a number has decimals we can write
67:01 - them after the dot so for example we can
67:03 - have here
67:05 - 29.65 and this will still be a valid
67:09 - number
67:11 - sometimes we need to represent the state
67:13 - of something like on or off like a
67:17 - switch that can only be on or off well
67:20 - we could theoretically use a string for
67:22 - that and say on off
67:24 - but JavaScript has a data type called
67:27 - Boolean
67:28 - a Boolean value can only be true or
67:32 - false so let me show you for example
67:34 - let's say here that we are going to
67:37 - create a new variable and let's
67:39 - initialize it with is adult
67:42 - and we're gonna set the value of true
67:46 - if you want to check the data type of is
67:49 - addled
67:50 - all we have to do is use our console log
67:53 - statement here
67:54 - and run this
67:56 - and what you're gonna get back here is
67:59 - Boolean
68:00 - super important true and false to be a
68:04 - Boolean doesn't need any codes just like
68:07 - with a number if we put anything between
68:09 - quotes it will become a string
68:12 - another data type that is maybe a bit
68:15 - hidden and sometimes confusing is
68:17 - undefined so this is something that can
68:20 - confuse a lot of people so let's do for
68:22 - example the following we're going to
68:23 - Define here a variable is active
68:26 - and we're not going to initialize it
68:28 - with any value
68:30 - so what value does it have
68:32 - let's try it out gonna go here inside
68:36 - this statement and change type of
68:38 - angle reference here is active
68:41 - and what we're getting back here is
68:44 - undefined so undefined is its own data
68:48 - type
68:49 - and simply represents something that
68:51 - isn't defined we don't know it is not a
68:54 - string it's not a number it's not
68:56 - anything else it's simply undefined we
68:58 - have created a new jar but we haven't
69:01 - put anything inside there
69:03 - so this is the representation of
69:05 - undefined but it's important to
69:07 - understand this concept of undefined
69:09 - because we're going to encounter it a
69:10 - lot as you later see
69:12 - now in this case we have a lot of
69:15 - properties here that kind of belonged to
69:17 - the same person right so we have a
69:19 - variable name we have a variable age we
69:22 - also have a variable is adult but it's
69:24 - obvious that this data actually belongs
69:27 - to a person
69:28 - now in this case if we want to make
69:30 - things more clear that hey all these
69:32 - variables grouped together actually
69:34 - belong to a person we can use another
69:37 - data type which is called an object
69:41 - so let me show you how that works
69:43 - and it's quite easy so what we're going
69:45 - to do here is we're going to define a
69:47 - new variable to hold this object I'm
69:48 - going to call the variable person
69:51 - and in order to Define an object all we
69:53 - have to do here is use this braces don't
69:57 - have one brace in the beginning and one
70:00 - brace at the end I'm here between the
70:02 - braces I'm gonna hit one time enter and
70:05 - add a semicolon at the end all right
70:08 - so now we have here an object but this
70:10 - object doesn't have any properties so
70:12 - what we're gonna do here is going to
70:14 - move these variables that we have here
70:16 - I'm going to put them inside here now
70:18 - you'll notice as soon as we do this
70:21 - everything will turn in right because
70:23 - this is not valid code
70:25 - now what we're gonna do first of all is
70:27 - remove all the let definitions in the
70:29 - beginning we don't need that anymore
70:31 - now after this what we're going to do is
70:34 - we're going to replace the equal sign
70:36 - with a semicolon and we're going to also
70:39 - remove the space before the equal sign
70:42 - and last but not least we're gonna
70:44 - replace this semicolon with a comma
70:48 - except for the last semicolon
70:50 - which will simply remove
70:53 - this looks very similar to Json but it
70:57 - is not Json it's super important to
71:00 - understand the distinction between a
71:02 - JavaScript object and a representation
71:04 - of a JavaScript object in Json while
71:07 - there are some similarities this is not
71:10 - Json it is simply a JavaScript object
71:13 - you don't have to trust me that this is
71:15 - a JavaScript object let's go ahead and
71:17 - take a look at the type of this thing to
71:19 - see what it is
71:22 - I'm gonna get back here object
71:25 - all right so what can we do with this
71:27 - object well for example we can simply
71:29 - use here console log and we can log the
71:33 - contents of this object so that we know
71:34 - what's inside this object maybe we don't
71:36 - know
71:37 - so we'll be able to see here that we
71:40 - expand this that we have here multiple
71:42 - properties name age is adult and so on
71:46 - now quite often
71:48 - we don't need the entire object at once
71:50 - maybe we only need the name for whatever
71:53 - reason we're going to print a message
71:55 - like hello then the person name right
71:58 - so in that case to only access one
72:01 - property we're gonna use what is known
72:03 - as a DOT notation so after person we're
72:06 - going to write here Dot
72:08 - and you'll see here already there is a
72:10 - bit of autocompletion that kicks in this
72:12 - is because this object has been defined
72:14 - here right inside the window
72:16 - so let's select from the list name
72:19 - and if we run this code once again
72:21 - we're going to see here that the name is
72:23 - Jake
72:24 - perfect so this is how we can access a
72:26 - property
72:28 - now let's say for example for some
72:30 - reason when we have created this object
72:32 - we didn't have some information we want
72:34 - to add some information later on how can
72:36 - we do that well we can simply use here
72:39 - person
72:40 - and we can specify a new property let's
72:43 - say for example we want to add a
72:44 - property which is called email
72:46 - so you can write person.email
72:48 - and we're gonna initialize here this
72:51 - property with a new value
72:53 - so I'm going to write here something
72:54 - like check at example.com
72:57 - so if we log the entire object with
73:00 - console log
73:01 - what we're gonna see here in the list of
73:03 - all the properties is also the property
73:06 - email
73:07 - and just as well if we need to access it
73:09 - we can use the dot notation
73:11 - let's say for example that we want to
73:15 - have here email with the dash between E
73:18 - and M
73:19 - the written like this
73:21 - now as soon as we write something like
73:23 - this you'll notice here something turns
73:25 - into red
73:26 - and here at the end there's also this
73:30 - indication that
73:32 - there's something wrong with the code so
73:33 - what's wrong with this code well
73:34 - essentially when we use here and minus
73:37 - sign JavaScript will think that we're
73:41 - trying to access here
73:43 - person.e minus a variable which is
73:47 - called mail
73:48 - and we're gonna try to initialize this
73:50 - to a variable doesn't make a lot of
73:53 - sense right
73:54 - now in this case if we're trying to do
73:57 - something like this we need to use a
73:59 - separate notation there is a special
74:00 - notation whenever we have some
74:02 - characters that let's say are a bit
74:04 - special and break our syntax that we
74:07 - have here in JavaScript and for that
74:08 - we're going to remove this Dot and
74:10 - between square brackets I'm going to put
74:13 - here email
74:15 - so the idea here is that in order to
74:17 - make this a string we also need to put
74:20 - it between codes because otherwise
74:21 - JavaScript will still think that e is a
74:24 - variable and male is another variable
74:26 - and it's going to try to subtract them
74:27 - so even if the code now
74:30 - looks valid you know if we're trying to
74:32 - run this but we're going to get back
74:34 - here is that e is not defined right so
74:36 - that's also not good so let's put
74:38 - everything between quotes
74:40 - and now
74:41 - what do we see we have here this
74:44 - property email exactly as we wanted it
74:47 - and it has right now the value that we
74:49 - need
74:51 - the same thing goes when we're trying to
74:54 - access this property so if you want to
74:55 - go here and write person Dot you'll
74:58 - notice here in the list email doesn't
75:00 - appear
75:01 - so if you're gonna write here email like
75:04 - this
75:05 - well this is not going to give an error
75:07 - itself
75:08 - but again this is going to be like a
75:11 - math operation where JavaScript will
75:13 - think we're gonna get a property E from
75:16 - person and subtract mail
75:18 - so we're gonna get this time the error
75:21 - that mail is not defined
75:24 - you're probably wondering why is person
75:26 - that he defined well that's not defined
75:30 - but that's not gonna throw an error so
75:32 - let me show you whenever we're writing a
75:34 - property on an object that doesn't exist
75:36 - like person.e it's a property that
75:39 - doesn't exist this object does not have
75:41 - this property what we're gonna get back
75:43 - is our old friend undefined for
75:46 - JavaScript not gonna say oh my God this
75:48 - is an error you cannot continue just
75:50 - gonna say this is a property that is not
75:52 - defined
75:53 - maybe you forgot to Define it or
75:55 - something but it is undefined doesn't
75:58 - show an error this is sometimes a bit
76:00 - confusing because you maybe you are
76:02 - writing here a property like is adult
76:04 - let's say is adult
76:07 - and you forgot to put a capital A there
76:10 - you're looking at this and say oh it's
76:12 - why doesn't this property work it's
76:14 - right here in the object it should work
76:16 - I've written it exactly the same oh well
76:19 - almost exactly the same well that's a
76:21 - problem if you're not writing things
76:22 - exactly as they are inside the object
76:24 - you're gonna get this undefined okay
76:27 - we're jumping into too many things at
76:29 - once but let's go back to how do we get
76:32 - to this property so we know that this
76:33 - notation with that doesn't work so we'll
76:35 - have to use this other notation with
76:38 - square brackets again when we're setting
76:40 - a property or when we're trying to
76:42 - retrieve a property that has some
76:44 - special characters that break our code
76:45 - then we have to use this square bracket
76:48 - notation we're not going to use it a lot
76:50 - but you'll have to remember it because
76:52 - from time to time we're gonna need it so
76:55 - this is essentially
76:56 - more or less what we need to know about
76:58 - objects here let's move this property
77:01 - to the object itself so in this case
77:04 - we're still going to use this notation
77:05 - so we have to put this between quotes
77:08 - single or double doesn't matter
77:10 - and we can put the value here
77:13 - then we have everything in one place
77:16 - so this is our person it looks much
77:18 - better
77:19 - at other times we may need a collection
77:22 - or a list of things things that are you
77:25 - know kind of like similar to one another
77:28 - and for that we can use an array
77:30 - an array is a data structure that can
77:33 - store a collection of elements each
77:36 - identified by an index okay sounds a bit
77:39 - confusing let me share an example
77:41 - so let's say for example we want to
77:43 - store here a list of hobbies currently
77:46 - find here a new variable which is called
77:47 - hobbies and this time to initialize this
77:50 - array
77:51 - we're going to open up a square bracket
77:53 - and we're going to close one
77:55 - now at this point we have here an empty
77:58 - array so let me use here the postman
78:00 - console
78:02 - and we're going to write here Hobbies so
78:04 - we can take a look at this thing
78:06 - so we're gonna see here this is an empty
78:09 - array some people think that this is
78:10 - some error or something like that no it
78:12 - begins and ends and there's nothing
78:14 - inside okay so let's add something
78:16 - inside so that we can make this a bit
78:19 - useful so let's say what do we have for
78:21 - hobbies num
78:22 - not a lot of people do it nowadays but
78:24 - let's say reading that would be one
78:27 - hobby right so if we run this once again
78:30 - we'll see here one so we have one
78:32 - element here and this is a reading
78:34 - perfect and what else we have maybe
78:36 - traveling
78:38 - and gardening
78:40 - and cooking
78:42 - now you can understand how these are
78:44 - related to one another right so they're
78:45 - all Hobbies so it kind of like makes
78:47 - sense to put them in a list otherwise
78:49 - would have something like hobby one
78:50 - hobby two hobby three and so on and we
78:54 - don't know in advance like how many
78:55 - hobbies we have maybe you have none
78:56 - maybe we have 10 maybe we have only two
78:59 - so this array structure allows us to be
79:02 - a bit flexible with how we store this
79:04 - information
79:06 - let's take a look again what we have
79:07 - here we're gonna see here okay we have
79:09 - four Hobbies perfect let's say for
79:12 - example we only interested in the second
79:14 - hobby how can we do that well in order
79:17 - to access only one element of the array
79:19 - we'll use again this square bracket
79:22 - notation and this time we're going to
79:24 - specify the index
79:26 - so it means the number of the element in
79:30 - the array so each item is identified by
79:33 - an index so we're gonna write here this
79:35 - is the first element this is the second
79:36 - element so we're gonna write here two
79:39 - and let's see what we're getting back
79:41 - and we're getting back gardening this is
79:44 - kind of confusing right so let's remove
79:46 - this and go back to square one to
79:49 - understand what's going on here now
79:52 - indeed we have four elements here in the
79:55 - array but if we expand this array
79:58 - what we're gonna see here is the index
80:01 - actually
80:02 - now remember that in computer science we
80:05 - always count from zero a race in
80:07 - JavaScript are zero indexed meaning that
80:11 - the first element is at index 0. the
80:15 - second element is at index one and so on
80:18 - so if you want to get the second element
80:21 - we actually have to write there one
80:23 - because you'll see here
80:25 - traveling has index 1. no problem a
80:28 - small hiccup so we're trying to get a
80:30 - second element we're providing index one
80:33 - and we're gonna get to this array
80:36 - now again we have the situation that we
80:38 - have a person which is an object and we
80:41 - have this array separately
80:43 - which is again a bit confusing
80:45 - but we also have the possibility of
80:47 - actually putting Hobbies inside object
80:50 - so all we need to do is Define here
80:53 - property
80:54 - so
80:55 - I'm gonna add here a comma so that we
80:58 - can add something new to this object
81:01 - column
81:03 - and now we're gonna simply paste here
81:04 - the array
81:06 - so let's take a look again at the person
81:09 - and now we have here a more complex data
81:12 - structure we have an object that also
81:13 - contains an array
81:15 - so let's take a look at this one we have
81:17 - here we have name age adult and we have
81:19 - hobbies we can still explore these
81:21 - hobbies and take a look at them
81:23 - now how can we get to let's say the
81:27 - third hobby right so we cannot write
81:29 - here Hobbies anymore because Hobbies is
81:32 - no longer a variable we have to go
81:33 - through person we have person dot
81:36 - Hobbies
81:38 - and if we're trying to get the third
81:41 - hobby then we'll have to specify index
81:43 - two so this is how we can still access
81:45 - this information from the array but
81:47 - using the object which contains now this
81:50 - array now there's one last thing about
81:52 - the race
81:54 - so if you're trying to do here like type
81:55 - off
81:57 - person.hobbies we should get back array
82:00 - right
82:01 - when we're getting object
82:03 - that's again confusing right why are we
82:06 - getting objects is it because this array
82:08 - is now inside an object no it has
82:10 - absolutely nothing to do with it
82:12 - actually this is because arrays are
82:16 - objects they are more specialized form
82:18 - of object however we kind of like tend
82:22 - to work with them separately and
82:24 - consider them like separate things from
82:26 - objects because they have like this
82:28 - particularities that we need to learn
82:30 - about and when we're interacting with
82:32 - them they're super important but at a
82:34 - technical level in JavaScript there are
82:36 - also objects this is why when we're
82:38 - trying to get the type of an array we're
82:40 - gonna get back object
82:46 - in this lesson we'll be exploring
82:48 - JavaScript functions which is a
82:51 - fundamental Concept in programming
82:53 - a function is essentially a block of
82:55 - code designed to perform a specific task
82:58 - which can be called whenever needed this
83:02 - allows us to organize and reuse our code
83:05 - efficiently
83:06 - so let's go ahead and Define a simple
83:08 - function to define a function we need to
83:11 - write the function keyword
83:14 - followed by the name of the function
83:17 - for example let's say we want to create
83:19 - a function that greets us right so we're
83:21 - going to give the name grid to this
83:23 - function and then to make it a function
83:25 - we're going to add here this parenthesis
83:28 - and after this we're gonna start here
83:30 - actually a code block which we have
83:33 - learned about a bit previously and we're
83:35 - gonna get to it a bit later
83:37 - so this is the code block
83:39 - this is where we can write some code and
83:42 - this will be encapsulated so essentially
83:44 - these are like gates to ensure that
83:47 - whatever happens in this function is
83:48 - isolated from the rest of the things so
83:50 - for example we can write here something
83:52 - like console log
83:53 - and display a message like hello from
83:56 - Postman okay so let's put this back here
83:59 - where it belongs near the function I
84:01 - just want to point out that this is
84:02 - actually a code block perfect so now we
84:05 - have this inside function our function
84:08 - name is grid
84:09 - or let's run this again
84:11 - and if we're taking a look at the
84:12 - console nothing like nothing where is
84:15 - this console log statement what has
84:17 - happened with it
84:18 - well here's the thing just because we
84:20 - have defined a function
84:22 - doesn't mean that that function is being
84:25 - executed immediately right so initially
84:28 - nothing happens if we decide that we
84:31 - want to call a function and reuse some
84:33 - functionality that we have in that
84:34 - function we need to invoke it or call it
84:39 - so I wanted to call that function what
84:40 - we need to do is to specify the name of
84:42 - the function which in our case is grid
84:45 - and not only that we also need the
84:49 - parentheses at the end
84:51 - this is what actually calls the function
84:54 - and we can also add a semicolon there
84:56 - so let's go ahead and run this code
84:59 - and then we will see here hello from
85:02 - Postman
85:03 - so with this code here we are
85:05 - referencing this function here named
85:07 - grid
85:08 - and with a parenthesis we are executing
85:12 - that function without a parenthesis this
85:15 - would still be valid JavaScript code but
85:18 - we wouldn't be calling the function so
85:20 - we'll see here there's no output that's
85:22 - being generated
85:24 - now our function is kind of like silly
85:26 - it doesn't really do a lot let's make it
85:28 - useful let's make it greet us how can we
85:31 - provide some information from the
85:33 - outside and make this useful
85:36 - well in order to do that
85:39 - a function can also think inputs in the
85:41 - form of arguments which are values
85:44 - passed to the function when it is called
85:46 - so essentially when recalling this
85:48 - function we can say something like we
85:50 - want to provide our name so let's say I
85:52 - want to provide here Val
85:54 - and I want to say here something like
85:56 - hello from Postman well do I want this
85:59 - name to be printed there in the console
86:02 - now in order to do that we also need to
86:05 - change something about our function
86:07 - so here in the definition between this
86:10 - parenthesis
86:11 - we're going to Define here a parameter
86:13 - so we're going to call this parameter
86:14 - name
86:17 - and then in the console log we can also
86:20 - reference that so we can say here hello
86:22 - from Postman
86:24 - comma space and then with the plus sign
86:27 - we can use your name
86:29 - so let's go ahead and run this once
86:32 - again
86:33 - and we're gonna see here
86:35 - hello from Postman file just as well we
86:38 - can greet multiple people for example we
86:40 - can greet Jake
86:41 - we can greet Jamie
86:44 - and anyone else would like to greet so
86:47 - let's go ahead and run this so we have
86:49 - reused the same function
86:51 - but by providing a different argument
86:55 - we have also changed a bit what the
86:57 - function does of course this is a super
87:00 - simple example but you kind of
87:01 - understand the idea
87:03 - now I wanted to talk a bit about name
87:06 - here like what's name
87:09 - like what's name is it a variable is it
87:12 - where has this been defined or how does
87:14 - it work if you try for example inside
87:17 - here to get something like console.log
87:19 - name
87:21 - it's not gonna work
87:23 - you're gonna get an error name is not
87:25 - defined but if you're trying it inside
87:27 - here obviously this is gonna work
87:31 - name here is like a variable
87:36 - and this is why it's important to
87:38 - remember the discussion that we had
87:39 - about code blocks this is a code block
87:43 - and this function what it does is
87:46 - essentially saying here this is a
87:48 - variable called name and we're going to
87:50 - initialize it with whatever value is
87:52 - being provided here I'm gonna say here
87:54 - like name equals
87:57 - Val right now of course this is not
87:59 - actually happening in terms of the
88:01 - syntax that was being used but it's
88:03 - almost the same thing so for every time
88:05 - we are passing a different argument here
88:07 - this value will change
88:09 - but it almost works the same as when
88:13 - defining a variable but this is the work
88:16 - that JavaScript does for us by using
88:18 - this syntax by the way we have defined
88:21 - this function so it happens
88:22 - automatically but the idea is name here
88:25 - is only available inside a function it's
88:27 - not available anywhere else
88:29 - okay so now we have this useful function
88:32 - that's cool but sometimes you know we
88:35 - have let's say for example we have
88:37 - developed a super secret algorithm that
88:39 - adds two numbers right so let's put that
88:41 - in a function I'm going to give it a
88:44 - name add and this amazing function will
88:47 - add to numbers like like
88:49 - let's call them A and B right this will
88:51 - be parameters that we will have here in
88:53 - the function because you know to add to
88:54 - numbers we need to know those two
88:56 - numbers
88:57 - so this is how we can take input
88:59 - essentially when we're starting this
89:00 - function
89:01 - so what are we doing with these two
89:03 - numbers let's define a new variable I'm
89:05 - going to call it sum
89:06 - and we can add a plus b
89:10 - all right so then we can use
89:12 - console.log
89:14 - and we can print out some and you
89:17 - already know the drill in order to call
89:19 - this we'll have to provide here two
89:21 - numbers let's add one and two
89:24 - and I'm gonna write and what I'm gonna
89:27 - see here is three in the console
89:30 - perfect okay this kind of works but
89:34 - let's see if there's anything else we
89:36 - could do here
89:37 - so for example let's define two
89:38 - variables let's call them number one and
89:44 - gonna provide here one number
89:47 - don't need a space here actually
89:50 - this will be number two with a different
89:53 - value
89:54 - so let's say we want to display here a
89:56 - nice message like
89:57 - using console log
90:00 - the result of adding
90:03 - and we're gonna specify here
90:05 - number one
90:07 - with gonna add the next number number
90:10 - two
90:12 - is and let's say we want to call
90:15 - this function at here so that we can
90:17 - display everything in the message I'm
90:19 - going to use here
90:21 - the plus sign again we can reference
90:23 - variables as well
90:25 - so what we're gonna do we're gonna add
90:26 - number one
90:28 - and number two
90:30 - perfect we still have here syntax error
90:32 - so we need to make sure that when we're
90:34 - combining Different Strings that we are
90:37 - using the plus sign so the result of
90:39 - adding number one with number two is
90:42 - we're gonna call this function so we can
90:44 - call the function
90:45 - even from within console log
90:49 - so let's run this once again
90:52 - and what we're going to get here is
90:54 - something interesting right
90:55 - so we have here
90:57 - 58 and this is coming from here we have
91:00 - console log so the function works it
91:04 - adds these two numbers and displays them
91:06 - but then when we're trying to use it
91:08 - here it says the result of adding 24
91:11 - with 34 is undefined again this annoying
91:15 - undefined thing
91:17 - which is driving us crazy why is this
91:19 - happening why is the function adding the
91:21 - numbers but when we're trying to use it
91:23 - it disappears here's the thing
91:27 - just because we use console log in a
91:30 - function
91:30 - it does not mean that the function
91:32 - returns a value
91:34 - console log is just useful for debugging
91:38 - your code we're understanding what the
91:39 - code is doing
91:41 - but in this situation we actually want
91:44 - this function to give us back sum
91:47 - just because we have used console log it
91:49 - doesn't give us some because we can use
91:51 - 10 console log statements right so it
91:53 - wouldn't make sense to just randomly
91:55 - pick one of them or just take the last
91:56 - one and send that over
91:59 - what we need to do is to add a return
92:01 - statement so a return statement is used
92:04 - to specify the value that the function
92:07 - should return
92:08 - after it is done whatever the function
92:11 - is supposed to do
92:12 - in this case because we haven't
92:15 - specified a return value
92:18 - well you guessed it by default
92:20 - a function will return undefined because
92:23 - we haven't redefined what we want to
92:25 - return so if you haven't defined what
92:27 - one return we're gonna get back
92:29 - undefined so in order to not return
92:32 - undefined we're going to use here the
92:34 - return keyword
92:36 - I'm gonna say
92:38 - but what do you want to return how about
92:40 - returning some
92:41 - so when we're running this once again
92:44 - we are keeping here our console log
92:46 - statement which is useful for debugging
92:48 - and understand what the function is
92:50 - doing
92:51 - but then
92:52 - we also get here the value
92:55 - which is being displayed through the
92:58 - console log statement
93:00 - so this is why it is important to have
93:02 - this return statement in functions just
93:06 - because you have added cancel log does
93:08 - that mean that the function actually
93:10 - Returns what you see in the console
93:17 - we can also Define a function inside an
93:19 - object so let me show you how this works
93:22 - we have here an object with some
93:24 - properties and let's say we want to add
93:27 - this function to the object so that we
93:30 - do something in relation to the object
93:32 - so in order to do that things are
93:34 - relatively simple we're going to copy
93:35 - the code that I have here
93:38 - I'm going to go here inside the object
93:41 - and I'm going to Simply paste the code
93:44 - obviously this syntax is not correct but
93:47 - we are actually not so far off
93:49 - there are a few things we need to change
93:51 - now you can notice here that object
93:52 - always has something like a property
93:55 - and then a value
93:58 - now we need to keep the same structures
94:01 - we're going to start here with a
94:02 - property which is grid the name of the
94:05 - function and add it here and then with
94:08 - column this is definitely going to
94:10 - replace here any any equal sign or
94:12 - something like that
94:13 - we're going to say okay we have here
94:14 - grid and grid is a function
94:17 - that takes name as an argument
94:20 - and does something with it
94:22 - so if we're trying to access this
94:26 - function all we have to do is right here
94:28 - person dot greet
94:31 - and in order to call it we need to use
94:33 - parenthesis and grid also takes an
94:36 - argument so we're going to write here
94:37 - Jamie now let's see how this works I'm
94:40 - gonna see here hello from Postman Jamie
94:43 - let's add here another space so that it
94:44 - looks well
94:46 - and we're gonna get this to work when a
94:49 - function is defined inside an object we
94:52 - call it a method
94:54 - while they look similar they're not
94:57 - really the same functions can be defined
95:00 - and called independently without being
95:03 - associated with any particular object
95:06 - on the other hand a method is a function
95:10 - that belongs to an object and is
95:12 - designed to perform specific tasks that
95:15 - is related to that object so for example
95:18 - let's say we wanna also display the
95:21 - first name
95:22 - right so we are getting some argument
95:24 - from the outside but how about accessing
95:26 - some information that is inside here we
95:29 - can write here maybe a special message
95:31 - like my name is and then we're going to
95:34 - take the first name
95:35 - so hello from Postman
95:38 - Jamie and then we're gonna continue the
95:40 - message
95:41 - dot we're ending the first sentence my
95:44 - name is
95:46 - space and then with the plus sign
95:48 - we'll wait to use here first name
95:52 - let's paste it inside here
95:54 - I'm gonna get this to run and we're
95:56 - gonna get here an error first name is
95:59 - not defined
96:00 - okay
96:01 - that's a bit of a problem we could use
96:03 - here
96:04 - person.verse name because obviously
96:06 - first name is a variable it doesn't
96:08 - exist so in order to get this to work
96:10 - then we're gonna use here person DOT
96:13 - first name
96:14 - but let's run it once again and we're
96:16 - gonna see here my name is Jake
96:18 - now this has a minor disadvantage if we
96:21 - for some reason decide to rename this in
96:24 - person too from the outside we know that
96:26 - hey this is person two so we're gonna
96:28 - use person to that grid but here on the
96:30 - inside maybe we forget to change that
96:33 - so again we're going to get an error
96:35 - here person is undefined
96:37 - that's a bit unfortunate and exactly for
96:40 - this reason if we're trying to reference
96:43 - an internal property of the object we
96:46 - can use a special keyword and this
96:49 - keyword is this we can replace person or
96:53 - person two or any other person with this
96:57 - so if we run this once again we're going
96:58 - to see here my name is Jake if we're
97:01 - changing this back to person
97:03 - it's still gonna work so it is an ideal
97:06 - situation to use this if we're trying to
97:09 - access some internal data in a method
97:11 - that we have defined here
97:13 - now methods and functions they indeed
97:15 - look similar and they kind of like work
97:17 - similarly but it's important to
97:19 - understand what is a method and what is
97:21 - a function even if they are kind of
97:24 - similar for example when we're using
97:26 - here console
97:28 - doesn't log right oh well console is an
97:32 - object we can write here something like
97:33 - type of console let's see what's cancel
97:37 - console is an object
97:39 - which means that console.log
97:43 - is then a function
97:45 - and we're going to see here
97:47 - it's a function but because it is like
97:50 - technically in JavaScript it is a
97:52 - function but because it belongs to an
97:54 - object
97:55 - we're still going to call it a method
97:57 - right so we don't have this data type
97:59 - which is called method and function but
98:01 - we refer to an object that has a
98:03 - function we're going to call that a
98:04 - method and when that function is
98:07 - Standalone we're going to call it a
98:09 - function
98:10 - anyway
98:11 - console.log when recalling log here this
98:14 - is actually the method log on the object
98:18 - console so now you understand exactly
98:20 - what console log is this is something
98:22 - that's provided by Postman and it has
98:25 - been defined somewhere else we can just
98:27 - simply use it so this is an ideal
98:29 - example for what it means to reuse
98:31 - something we don't really know or care
98:34 - exactly how this information is being
98:36 - displayed here why everything is on a
98:38 - new line why everything is nicely
98:40 - formatted this is something that
98:43 - it's a concern of this method it's being
98:46 - put together in this method so that we
98:48 - can conveniently use it whenever we need
98:50 - it
98:55 - callback functions are an essential
98:57 - Concept in JavaScript programming
98:59 - allowing us to write more efficient and
99:02 - flexible code
99:04 - Postman uses callback functions and it
99:07 - is important to understand what they are
99:10 - so let's begin with a few basics
99:13 - the first concept I want you to get
99:15 - familiar with is that we can store a
99:18 - function in a variable
99:20 - so what we're gonna do here is I'm gonna
99:22 - Define here a variable let's call it say
99:25 - hello
99:26 - and I'm going to initialize it with a
99:29 - function so we can simply write here
99:30 - function
99:32 - and what is our function
99:34 - this will be our function code and we
99:37 - can have here a simple console.log
99:39 - statement which says hello
99:42 - super simple so which means in this case
99:45 - that
99:46 - where what's the name of this function
99:48 - this function doesn't have a name
99:50 - anymore it's just stored in a variable
99:52 - this is called in JavaScript an
99:55 - anonymous function when a function
99:57 - doesn't have a name it is anonymous it
100:00 - doesn't have a name so in this case if
100:02 - you want to actually run this function
100:04 - if you want to run the code that's in
100:05 - this function the only way to do that is
100:08 - by using the variable where this is
100:10 - stored so we're gonna use here say hello
100:13 - this is the variable and remember in
100:16 - order to invoke the function we need to
100:18 - use parenthesis we're going to add here
100:21 - this parenthesis and this is what makes
100:23 - the call to the function
100:25 - so let's run this
100:27 - and we're gonna get here back hello okay
100:29 - so we can store functions in a variable
100:33 - good big deal why do we need this well
100:36 - we're starting to get there
100:38 - the next concept I want you to get
100:39 - familiar with is that functions can also
100:43 - be passed as arguments to another
100:46 - function
100:47 - okay so how does that work
100:51 - let's say we have this regular function
100:53 - which is called and do something right
100:56 - so this is a regular function
100:58 - and as you know a function can take here
101:01 - some argument so we can provide some
101:03 - inputs that we want to give to the
101:04 - function now we in the past we have
101:06 - provided like two numbers A and B which
101:08 - we have added or we have provided a name
101:11 - so that we can say hello Jamie but we
101:14 - can also provide here a function we're
101:16 - going to write here thumb function
101:18 - because we don't know which function
101:20 - this will be and here inside the code we
101:23 - now have this function and we can decide
101:25 - to run it
101:27 - so let's write here a statement like
101:29 - console log before running the function
101:33 - and we're gonna have another console log
101:35 - statement after running the function and
101:39 - here in between we have here thumb
101:40 - function which is a reference to some
101:43 - function that we're going to get and we
101:46 - want to call that function so in order
101:48 - to call that function we're going to use
101:49 - here you guessed it parenthesis
101:52 - so now we are calling a function that we
101:54 - are retrieving here as a parameter so
101:58 - how can we do this well the next step
102:01 - would be to call do something right
102:03 - because at this point do something isn't
102:05 - being called anywhere
102:07 - and we can reference
102:09 - say hello
102:11 - so we are passing say hello
102:13 - as an argument to this function which is
102:16 - called do something
102:18 - do something we retrieve it here will
102:20 - run console log then it will invoke some
102:25 - function
102:26 - and it doesn't matter if the name is not
102:28 - to say hello this is being passed here
102:31 - as a value
102:33 - it will call here this function that we
102:36 - have here so let's run it and see if it
102:39 - works as intended
102:41 - so what we see here is that we have
102:43 - before running the function this is the
102:44 - first statement then we have hello which
102:47 - is coming from here and then we are
102:49 - after running the function
102:51 - okay you're probably thinking oh Jesus
102:54 - that's a really complicated way of
102:56 - calling this function I mean why in the
102:58 - world would you need something like this
103:01 - and again we're getting there and I do
103:03 - appreciate your patience with this it's
103:05 - super important that you get this so
103:07 - let's take it step by step
103:09 - so to recap we can put a function in a
103:13 - variable
103:13 - we can pass a function to another
103:17 - function and invoke that function here
103:19 - maybe there's some condition here on
103:21 - upon which we decide to invoke that
103:23 - function it doesn't really matter
103:25 - but these are like the first ideas that
103:27 - we need to get familiar with now
103:29 - what if we don't want to Define this
103:32 - variable say hello
103:34 - right in the past when we use something
103:36 - like saying hello we have just written
103:39 - there as a string for example Jamie
103:43 - why can we not write the function
103:46 - directly here inside this function call
103:48 - well actually instead of using here say
103:51 - hello we can simply copy the contents of
103:55 - this variable
103:57 - I'm going to remove this all together
103:59 - and I'm going to paste it here
104:02 - looks a bit crazy but let's see if it
104:04 - still works
104:05 - so it works absolutely the same before
104:07 - running the function then we are running
104:09 - the function and then after running the
104:11 - function so now again we have this
104:13 - Anonymous function
104:15 - which we only need maybe one time and we
104:18 - have passed it here when calling this do
104:21 - something function
104:22 - and what I want you to get is that this
104:26 - function this code is not being called
104:28 - here this console log statement is not
104:31 - called here at line 8. it's actually
104:34 - being called here
104:37 - if we for some reason decide to
104:40 - comment this and we're trying it once
104:43 - again I'm gonna see here the hello
104:44 - statement has disappeared so this is
104:46 - what is running our function
104:49 - this syntax is a bit confusing in the
104:52 - beginning this is why I try to take you
104:54 - step by step so that you understand the
104:56 - syntax the way we write these things in
104:59 - the end if we write here a function if
105:02 - you write here a string jig if we
105:04 - provide one number or even multiple
105:05 - numbers it's the same idea we are
105:08 - calling a function which is called do
105:10 - something
105:11 - and we are providing one argument so the
105:14 - argument starts here and ends here and
105:17 - then we're closing the function call
105:19 - well the function call is this one let
105:22 - me remove it once this is how we're
105:23 - calling the function and here between
105:25 - this parenthesis we are passing one
105:27 - argument just as well we could be
105:29 - passing two arguments or multiple
105:31 - arguments same idea again you're
105:33 - wondering why is this useful when I'm
105:37 - gonna need something like this and it's
105:39 - obviously not easier to read than before
105:41 - well let me explain a bit why we went
105:45 - through this effort of trying to
105:46 - understand this callback function the
105:48 - reason is that Postman uses them
105:50 - so here in Postman if we're trying to
105:52 - write a test
105:54 - and I'm going to expand here the
105:55 - Snippets once again
105:57 - I'm gonna go here to the status 200 test
105:59 - and add it here again now what you're
106:03 - noticing here is maybe maybe something
106:05 - familiar right so what do we have here
106:08 - well we have PM DOT test well PM this
106:13 - looks like an object
106:15 - and test looks like a method right it's
106:18 - starting to accept some arguments so
106:22 - what are the arguments that this is
106:24 - accepting well let me make it easier for
106:26 - you to understand
106:27 - so we're going to Define here a variable
106:29 - which we're gonna call name of the test
106:33 - and the name of this test will be this
106:35 - one so this is the name of the test
106:38 - and let's define another variable which
106:41 - we're gonna call Maybe assertions
106:44 - and this will be a function
106:46 - and we can reference it here
106:49 - this is what a postman test consists of
106:53 - it uses the PM object
106:56 - and then the test method which has two
106:59 - arguments
107:00 - it takes the name of the test
107:03 - and a callback function containing
107:06 - assertions
107:08 - so assertions in this case is a function
107:12 - what is sometimes difficult for
107:13 - beginners to understand is this syntax
107:16 - because it's not clear well where does
107:18 - the method call start and where does it
107:20 - end right so this is why I try to break
107:23 - this down into smaller steps so that you
107:25 - can understand where is the name of the
107:27 - function this is the name of the
107:28 - function right so I'm gonna put it back
107:30 - together again so name of the test this
107:32 - is the name of the test we're providing
107:34 - it directly without using a variable
107:36 - much easier and much faster to write
107:39 - and then as a callback function we're
107:42 - going to provide here the assertions
107:43 - that we're going to use
107:45 - and we're doing it like this
107:47 - this is how we end up with this
107:48 - particular syntax when we are writing
107:51 - Postman tests
107:52 - now I hope that learning about this
107:54 - callback functions hasn't been a waste
107:56 - of your time because now you understand
107:58 - what is a postman test and how it is
108:02 - composed and which are the arguments
108:04 - that we need to pass in order to
108:06 - construct the test of course we'll go
108:08 - further into this test but this is why
108:11 - we have learned about this
108:17 - if you're not familiar with Json this
108:19 - lesson will provide a quick introduction
108:21 - to it if you already know what Json is
108:24 - feel free to skip ahead
108:26 - so what is Json and why do we need it
108:29 - when working with most apis to send and
108:33 - retrieve data we need to use the Json
108:36 - format so essentially we use Json to
108:39 - send requests from one machine to the
108:42 - other
108:42 - in this case
108:44 - Postman is running on our machine and we
108:47 - need to send a message to the API server
108:49 - for example to order a cappuccino right
108:53 - and then in order to essentially place
108:56 - this order for example we cannot simply
108:58 - say like we would say to a human yes I
109:02 - would like a cup of cappuccino or
109:03 - something like that
109:04 - we need to format our message in a way
109:08 - that the computer can understand it
109:11 - let's take a look at an example so that
109:13 - you can better understand what Json is
109:16 - so the Json format is pretty
109:18 - straightforward Json has a simple key
109:21 - value format it is like saying first
109:24 - name equals Jamie so we are assigning to
109:28 - first name the value Jamie
109:31 - but instead of using an equal sign we
109:34 - actually use a column
109:35 - and we put both the key and the value
109:38 - between double quotes
109:40 - and then we're still not ready but we're
109:42 - going to surround everything with curly
109:44 - braces this essentially creates an
109:47 - object with one property
109:50 - if we need to add an additional property
109:52 - then all we need to do is create a new
109:55 - line and separate those two lines with a
109:58 - comma
109:59 - you can notice that in this case 22 is
110:02 - not between quotes
110:04 - 22 is a number and it doesn't require
110:07 - any quotes otherwise it will become a
110:10 - string the same goes for booleans
110:13 - booleans true or false also don't need
110:16 - quotes
110:18 - the beauty of Json is that it is both
110:21 - readable by humans as well as by
110:23 - computers
110:24 - you can read Json without essentially
110:27 - knowing a lot about the Json format
110:29 - itself
110:30 - a confusing part about Json is when you
110:33 - encounter square brackets
110:36 - square brackets allow you to specify a
110:39 - list in this case we have a list of
110:42 - hobbies and you will notice that there
110:44 - are multiple values between those square
110:46 - brackets
110:47 - inside the square brackets we Define a
110:49 - list of things
110:51 - can be any type of values like a string
110:53 - a number a Boolean or anything else even
110:57 - object
110:58 - so let's do a quick recap first of all
111:02 - we can see that we have keys and values
111:06 - first name age is married and hobbies
111:09 - are all keys
111:11 - Jamie 22 Falls and then the list of
111:15 - hobbies like Netflix and mountain biking
111:18 - they are values
111:20 - Jaime is a string because it is between
111:23 - double quotes
111:24 - when we want to add another property to
111:27 - this object we must add that comma
111:30 - otherwise our Json will become invalid
111:32 - and the other party will not be able to
111:34 - understand this message
111:36 - so commas at the end of the line
111:39 - except for the last line are super
111:41 - important
111:42 - 22 in this case is a number
111:45 - false is a Boolean and Netflix and
111:48 - mountain biking are an array notice the
111:51 - square brackets and individual values
111:53 - separated by a comma
111:55 - finally you will see that the object is
111:57 - enclosed by curly braces one at the
112:00 - beginning and one at the end
112:03 - so in a nutshell this is the Json format
112:10 - in this lesson we will dive into the
112:12 - world of Json and understand how to
112:15 - parse Json in Postman and how to use
112:18 - console log to read a specific value
112:21 - from the API response
112:23 - we are done now with learning the
112:26 - JavaScript Basics so let's transform our
112:29 - Postman interface back to original state
112:33 - so first of all we can enable this
112:35 - single pane view by clicking here on the
112:38 - bottom single pane View
112:40 - this will put again the response here in
112:43 - the lower part
112:45 - and initially we can simply go ahead and
112:47 - close the console
112:49 - apart from this we can also enable
112:52 - the list of collections that we have by
112:55 - enabling here the sidebar
112:58 - and we should be back where we started
113:00 - let's go ahead and close the get API
113:03 - status request and expand the products
113:06 - folder and go to the get single product
113:10 - what we have inside here is a product ID
113:13 - so if we go ahead and try to retrieve
113:16 - this we're gonna get a single product
113:19 - perfect now let's say we want to work
113:22 - with some information that we're getting
113:24 - back from the API how can we do this
113:26 - well what we see here is Json this is
113:31 - the representation of a JavaScript
113:33 - object Json stands for JavaScript object
113:37 - notation
113:38 - it looks pretty similar to how we have
113:41 - defined an object in JavaScript but
113:44 - there's still a few differences
113:45 - now the thing is we cannot work with
113:48 - what we have here if this is like a
113:51 - pretty view that Postman offers us but
113:53 - actually the data that we're getting
113:55 - back is this one this here what you see
113:58 - here is simply a string
114:01 - and we cannot do anything with it we
114:04 - cannot read a property we cannot access
114:07 - any information or something like that
114:09 - so for that reason we need to transform
114:12 - this string that we see here into an
114:15 - object that we can use now this
114:18 - transformation from a string into a
114:22 - JavaScript object is called parsing and
114:25 - we need to do this promo Postman script
114:28 - now the question is where can we parse
114:31 - this should we use the request script or
114:34 - should we use the test well the thing is
114:37 - this information is only available after
114:39 - we have sent the request and after we
114:42 - have retrieved a response from the API
114:44 - this is the response from the API and
114:46 - this information is only available here
114:48 - in the test in the prequest script
114:50 - that's a bit too early so we need to go
114:52 - here inside the test and do something
114:54 - with this now I'm going to enable here
114:57 - the pretty view again so that we can get
114:59 - this a nice view of the information that
115:01 - we're trying to work with
115:02 - now in Postman in order to interact with
115:05 - this there are already some predefined
115:07 - methods that we can use so we're going
115:09 - to use the PM object
115:12 - and on the PM object we have here
115:14 - actually another object which is called
115:16 - the response so you see it's available
115:18 - here on the list I'm going to select
115:20 - here response
115:21 - and there is a method which is called
115:23 - Json
115:25 - so when we are calling this method Json
115:29 - it actually gets the response body and
115:32 - transforms it in a JavaScript object
115:34 - so this is what this method is supposed
115:36 - to do
115:38 - this method will return a value it's not
115:40 - going to print to the console or
115:41 - something like that so if you want to
115:43 - use this for later on what we actually
115:46 - need to do is to store it in a postman
115:48 - variable so I'm going to go ahead and
115:50 - Define a postman variable which we can
115:52 - call response or response body as you
115:55 - prefer I'm gonna go ahead and write here
115:57 - const response
115:59 - but this is actually storing the
116:01 - response body just keep that in mind
116:03 - all right so now we have the response so
116:06 - we can go ahead and use console.log
116:09 - and take a look at this response to see
116:10 - what we have here
116:12 - let's open the postman console run this
116:15 - request once again
116:16 - and what we're gonna get here is this
116:19 - object which has different properties
116:22 - so for example if we're trying to maybe
116:25 - get the property ID
116:27 - all I have to write is response.id
116:30 - now what you need to pay attention here
116:32 - is that we no longer have this Auto
116:34 - completion
116:35 - in this case Postman doesn't have the
116:37 - information what kind of an object we
116:40 - have parsed here what kind of a data
116:42 - structure we have whatever properties
116:44 - are available and so on so for this when
116:46 - you're typing the code you're not going
116:48 - to get the auto completion for this
116:50 - reason it's always super important that
116:53 - you pay attention to what you're typing
116:54 - so number right here response.id
116:57 - I'm going to get here the ID
116:59 - but if I'm writing your idea with a
117:03 - capital i
117:04 - I'm gonna get back undefined so for that
117:08 - reason what I always recommend
117:09 - especially when you're getting started
117:11 - simply copy paste the information if
117:14 - you're trying to get here the property
117:16 - is available just write response that is
117:18 - available and copy that from the body
117:21 - so you see here true though is available
117:24 - is true and it's the exact same value
117:26 - from here
117:27 - if you are trying to get for example the
117:29 - product description you need to remember
117:31 - that this is a bit trickier right so
117:34 - right here something like response dot
117:36 - product minus description
117:39 - this again will fail I'm gonna get
117:42 - essentially an error saying that
117:43 - description is not defined the response
117:46 - that project will be undefined and the
117:49 - description variable is also not defined
117:51 - so in order to do that we'll have to use
117:53 - the other notation that we have learned
117:56 - about it in the past and put this as a
117:59 - string
118:00 - between these quotes
118:02 - and then use this square bracket
118:04 - notation so this will help us get the
118:06 - information that we are looking for so
118:08 - in a nutshell this is how we can parse
118:11 - Json into a JavaScript object
118:15 - and when we have a JavaScript object
118:17 - everything that we know about JavaScript
118:19 - objects still applies the way we work
118:21 - with this object the way we read
118:23 - properties the way we change things and
118:26 - so on
118:31 - previously we have seen how convenient
118:33 - it is to set a postman variable and then
118:36 - have a bunch of requests magically work
118:39 - just because we have set the right value
118:42 - this is the power of using Postman
118:44 - variables
118:46 - as you have seen where we have tested
118:48 - our collection
118:49 - there are a few things that we still
118:51 - need to copy around so for example we
118:53 - went here as all products and we have
118:56 - found a product
118:57 - and then what we need to do is copy a
119:00 - value and then set it in the upcoming
119:02 - request well while there's still a bit
119:05 - of work to do this we can use Postman
119:09 - variables and later on we're gonna even
119:11 - improve this process so let me show you
119:14 - what I mean by that so in this case we
119:16 - have here this value product ID so let's
119:19 - say we want to order this product but
119:21 - first we want to check if this product
119:23 - exists
119:24 - so we're going to send this request and
119:26 - checked oh okay this is the product that
119:27 - exists and it's actually a product that
119:30 - is available great and then we need to
119:32 - copy the same value
119:34 - and go into the orders create a new
119:37 - order
119:38 - and then put that value here for example
119:42 - now let's say for some reason we decide
119:44 - we no longer want to order this product
119:46 - we want to order a different product
119:48 - then again would have to search for a
119:51 - product check that a product exists and
119:54 - that is this may be the right product
119:56 - that we want to order and also update to
119:58 - create a new order request
120:00 - we can slightly optimize this process by
120:03 - using Postman variables so what I'm
120:06 - gonna do here in the get single product
120:09 - request I'm going to replace this
120:11 - hard-coded value here
120:13 - and I'm gonna set a postman variable so
120:16 - you can see here if I select this text
120:19 - I'm gonna get this context menu here set
120:21 - as variable now if you don't see this
120:24 - that's absolutely fine you can simply go
120:27 - ahead and manually create that variable
120:28 - I'm going to show you in a second how to
120:30 - do that as well but if you see this
120:32 - simply click on set as variable
120:35 - and what we're going to do here we're
120:37 - gonna set as a new variable
120:40 - and all we have to do is provide a
120:42 - variable name and I are going to be very
120:45 - creative here I'm gonna just write
120:46 - product ID
120:48 - and in terms of the scope I'm gonna
120:50 - select the collection scope so
120:52 - essentially we're gonna save this as a
120:55 - collection variable so let's go ahead
120:56 - click here set variable
120:59 - and now this is a variable of V hover
121:01 - over this we're going to see its value
121:04 - if you didn't see this context menu
121:06 - which allows you to add a variable from
121:07 - here no problem we can hover over the
121:10 - collection name until this Ellipsis
121:12 - shows up click on edit
121:14 - and from the variables tab you will be
121:18 - able here to Simply go ahead and add a
121:21 - variable manually from here
121:23 - of course later on if you want to change
121:25 - this variable that we have created
121:27 - earlier you can simply change its value
121:29 - from here remember if you want this
121:31 - value to take effect in Postman you
121:34 - always need to change the current value
121:36 - because this is the one that's being
121:37 - used by Postman
121:39 - all right so we have it now in a single
121:42 - place here so what to do next well we
121:45 - wanted to reference it here when we're
121:47 - creating a new order
121:48 - so all we have to do is remove this
121:50 - value
121:51 - and then I'm going to write here two
121:53 - braces
121:55 - and all I have to do is start typing
121:57 - product ID
121:58 - you're going to see here appearing in
122:01 - the list of suggestions
122:03 - and let's go ahead and submit this
122:05 - request
122:07 - so what we're getting back here are the
122:10 - products that we have ordered and you'll
122:12 - see here this is the product that we
122:15 - have then referenced through this
122:18 - Postman collection variable
122:20 - so this saves us a bit of time in terms
122:23 - of ensuring that a product that we have
122:25 - retrieved earlier is also available and
122:28 - we can manage all this through a postman
122:30 - variable so let's take a look at an
122:32 - example where we're going to change this
122:34 - to something else
122:35 - let's copy this other ID that we have
122:38 - here
122:39 - and I'm gonna go inside the collection
122:42 - and simply change the variable here
122:45 - so this time when we're getting a single
122:46 - product
122:48 - we're not going to make any changes to
122:50 - the request just submit it you will see
122:52 - here this ID has changed
122:54 - and just as well in the create new order
122:58 - we're going to submit this again and
123:00 - we're gonna see here this ID has changed
123:02 - as well
123:03 - we can do also something similar here
123:05 - with get all orders so from the list of
123:09 - all the orders available we can simply
123:11 - take a look and getting an existing
123:13 - order ID in this case we're gonna have
123:16 - to hard code one of these values so
123:19 - let's copy one of these
123:21 - I'm gonna go back in the collection and
123:23 - I'm going to Define here another
123:24 - variable which I'm going to call order
123:26 - ID
123:27 - and I'm going to Simply paste the value
123:29 - here make sure to save the collection
123:31 - otherwise the variable will not be saved
123:34 - and then when I'm trying to get an order
123:36 - by ID instead of having this hard-coded
123:39 - value
123:40 - can I simply go ahead
123:42 - and select here from the list of
123:44 - variables that are available order ID by
123:47 - hover over it I'm gonna see what is the
123:49 - current value that will be used for this
123:51 - request
123:51 - we can go ahead and submit this request
123:53 - and then we're gonna see we're getting
123:56 - back status 200 okay we're gonna get
123:58 - information about this to order
124:01 - maybe it doesn't seem so useful at this
124:03 - point but understanding that you can use
124:06 - post my variables to store this kind of
124:08 - data that are coming from one request
124:10 - and use it in other requests as well is
124:13 - super important and we're going to work
124:15 - towards eliminating this manual process
124:18 - of copy pasting data
124:24 - in this lesson we're gonna take a look
124:26 - at how we can set Postman variables
124:28 - directly from a script
124:30 - just as a recap we have learned about
124:33 - Postman variables and we have learned
124:35 - about JavaScript variables JavaScript
124:38 - variables are not the same as postband
124:41 - variables while essentially a variable
124:43 - is a way to store something they work a
124:46 - bit differently JavaScript variables are
124:49 - scoped only to the script where they are
124:51 - defined and no variables are persisted
124:54 - meaning we set a variable in a script
124:56 - and then if we remove it we're not going
124:58 - to be able to retrieve it once again
125:00 - well this is why we also have Postman
125:03 - variables Postman variables allow us to
125:06 - store some information between requests
125:08 - and even later on if we need so so for
125:12 - example we can store settings and
125:14 - persisting data on the long term such as
125:16 - the base URL or the API key that we have
125:19 - previously generated or any other
125:20 - details that we need so we have this
125:22 - information as Postman collection
125:24 - variables but both my variables are also
125:27 - useful for passing data between requests
125:30 - so sometimes we retrieve some
125:32 - information in one request but we also
125:34 - need it in another request for example
125:36 - here with the orders we're creating a
125:38 - new order but maybe you also want to get
125:41 - the same order later on and check if
125:44 - that order has been properly created
125:47 - that order ID is something that changes
125:49 - all the time so yes we can use a postman
125:52 - variable but we'll have to constantly
125:54 - change this so let's take a look at a
125:57 - way on how we can improve this process
125:59 - the concept I want you to get familiar
126:01 - with is that we can set Postman
126:05 - variables from scripts so I'm gonna go
126:07 - ahead and run this request once again
126:11 - so let's say we have this value here
126:13 - which is the ID of the order we have
126:17 - just created
126:18 - so we can go here inside the test
126:21 - and here inside the test we can write
126:23 - something like PM Dot
126:26 - collection variables dot set
126:29 - and we can either update or create a
126:32 - variable if it doesn't exist
126:34 - in our case if we're looking here at the
126:37 - get an order by ID request we're gonna
126:40 - see here we already have here this
126:41 - variable order ID so let's try and
126:44 - update that
126:45 - I'm going to use here the name of the
126:48 - variable which is order ID
126:50 - and then we can also set here a value so
126:53 - we're going to take this value that we
126:54 - have here in the body
126:56 - let's run this
126:58 - you will see here this is something with
127:01 - fb8t and so on
127:03 - we open this other request
127:06 - and we are hovering over order ID
127:09 - we'll see here that the current value
127:10 - has been updated
127:12 - so we have updated this variable from a
127:16 - script
127:17 - now okay the problem with this approach
127:19 - is that we now have another ID here so
127:22 - if you're always trying to get the
127:24 - latest ID and then get an order by that
127:27 - ID
127:28 - this approach is still not super useful
127:30 - now in that case there's still something
127:32 - else we can do we are gonna go ahead and
127:35 - actually read this information from here
127:38 - because we now know how to write some
127:40 - scripts and we can level up our
127:42 - automation game essentially by employing
127:45 - this nice trick so what we'll do next is
127:48 - we're going to Define a variable which
127:50 - we're going to call
127:51 - response and we're going to store inside
127:54 - the result of parsing the response body
127:56 - so for that we're going to use
127:58 - pm.response dot Json we're going to call
128:01 - it as a method so now response holds
128:05 - this information
128:07 - and whenever we're trying to do
128:08 - something it's always a good idea just
128:10 - use console.log
128:12 - and what we're trying to do we have here
128:14 - response
128:16 - let's open the postman console
128:18 - and we can see here okay we have access
128:21 - to the response so it looks good what
128:22 - are we trying to get we're trying to get
128:24 - this ID so let's right here response.id
128:28 - can we see this information here in the
128:30 - postman console
128:32 - yes we can here it is this is the latest
128:34 - ID and you can see it's the same as we
128:37 - see in the response body
128:39 - all right perfect we're making amazing
128:41 - progress
128:42 - how can we update the postman variable
128:45 - with this information that is in the
128:47 - body
128:48 - well all we have to do is remove this
128:51 - hard-coded value that we have here
128:54 - and use response.id
128:57 - so let's see again
128:58 - we are parsing the response body we're
129:01 - updating a postman variable called order
129:03 - ID
129:04 - let's run this
129:06 - so now we have this value I'm going to
129:09 - copy it just to cross reference it
129:12 - and now let's run this request you can
129:14 - see that the postman variable has been
129:16 - updated
129:17 - let's click on send
129:19 - and we can search here the body I'm
129:22 - going to click on this one paste the
129:23 - value that we have copied we're able to
129:25 - see that is the exact same ID
129:28 - so what has happened here is that we no
129:31 - longer need to copy paste data from the
129:33 - create and order request to the get an
129:35 - order by ID if we're trying to retrieve
129:37 - the latest order
129:39 - so we can just run this once
129:41 - go to the next request and write as well
129:45 - this is the power of being able to know
129:48 - how to write a script and know how to
129:50 - use Postman variables to store
129:52 - information between the request
129:59 - we will conclude this unit with an easy
130:01 - assignment
130:02 - if you have been following along you
130:04 - already did most of the work
130:07 - now all you need to do is to go back to
130:10 - the original workspace from where you
130:12 - have forked the collection
130:14 - inside here you'll see this list of
130:17 - assignments that you need to complete by
130:19 - the end of the course
130:21 - completing all these assignments is
130:23 - necessary for you to get the postman
130:25 - badge that certifies you have taken this
130:28 - course and have done the work
130:30 - let's begin with the first assignment in
130:34 - order to complete the first assignment
130:35 - what you need to do is work this
130:38 - collection so all you have to do is
130:39 - hover over this until this Ellipsis
130:42 - shows up
130:43 - and from the menu select create a fork
130:47 - make sure to Fork this collection in the
130:49 - same workspace where you have also
130:51 - forked The Collection containing the API
130:55 - each assignment contains instruction so
130:58 - if you're not sure all you have to do is
131:00 - click on the collection
131:02 - and what you will see here is the
131:04 - documentation
131:05 - just in case the documentation doesn't
131:07 - show up you can also access it from here
131:11 - since this is your first assignment I
131:13 - will guide you through the steps you
131:15 - need to take
131:17 - so we already did a first step and that
131:19 - is to Fork The Collection now the next
131:21 - step is to actually read the
131:23 - instructions that we have here so there
131:26 - are multiple tasks that you need to
131:27 - complete and these are things that we
131:29 - already did in this unit
131:31 - in a nutshell you need to put here
131:34 - inside the API request folder some of
131:38 - the requests that we have worked on on
131:40 - the original collection
131:42 - so what you need to do for example for
131:44 - the first task is to take the get API
131:48 - status request
131:50 - to duplicate it here
131:52 - and then to Simply drag it into the API
131:54 - request folder
131:56 - inside here we want to make sure that we
131:58 - remove copy
132:01 - so in the end the name of the request
132:03 - should be exactly the same as here
132:08 - now you will do the same with all the
132:10 - requests as instructed by the
132:12 - documentation so there are three
132:14 - requests that you need to add to get API
132:16 - status the get single product and also
132:19 - get all orders
132:21 - once you have done so
132:23 - you can jump to the next folder and this
132:26 - is where you can check your solution
132:28 - this folder contains a request as well
132:31 - as instructions on how you can verify
132:33 - your work
132:34 - essentially it is a way for you to check
132:36 - that you did everything accordingly
132:38 - this request also contains documentation
132:40 - which are essentially step-by-step
132:43 - instructions on what you need to do
132:45 - but let me give you a hand
132:48 - essentially this request here will try
132:51 - to fetch your collection
132:54 - and we'll do some tests on it to make
132:56 - sure that you have written the code and
132:58 - did all the tasks that were required
133:01 - so let's go ahead and run this request
133:04 - and see what is happening
133:06 - now in this case we're going to get an
133:08 - authentication error because we actually
133:11 - need an API key to be able to use this
133:14 - API
133:15 - just as well we also need here the
133:17 - collection ID this is an internal ID
133:20 - that the collection has so let's start
133:22 - with that one how can we get the
133:24 - internal collection ID
133:25 - well all we have to do here is click on
133:28 - the assignment
133:30 - and what you will see here is this I
133:33 - button here
133:34 - if you click on it
133:36 - you will get additional information
133:38 - about this collection including the
133:41 - collection ID
133:43 - so all you have to do is copy this
133:46 - collection ID
133:47 - edit the collection
133:49 - and go to the variables
133:52 - you will see here that there are already
133:54 - two variables that have no value
133:58 - so for the collection ID I'll have to
134:00 - paste here the current value
134:03 - the next thing that we need is still the
134:05 - API key so if we try this request once
134:08 - again it will still not work
134:11 - so what you will need to do is click
134:12 - here on our profile picture
134:15 - and select settings
134:20 - and this will take us to our Postman
134:22 - account
134:24 - next from the menu we're going to select
134:25 - API keys
134:29 - and we're going to generate a new API
134:31 - key
134:33 - let's name this API key Postman
134:37 - I'll go ahead and copy this API key
134:40 - and go back to the workspace and the
134:43 - collection
134:45 - select the collection assignment 1
134:48 - go to the variables
134:51 - and in the current value
134:53 - paste this API key and save it
134:57 - let's expand the assignment once again
135:00 - and go to the verify your work request
135:04 - kind of go ahead and send this
135:07 - so what we're getting back now is a
135:09 - status 200 okay
135:11 - and if you take a look here at the test
135:13 - results
135:14 - you will also see that some of the tests
135:18 - you will see here an indication if the
135:20 - tasks that you've done are complete or
135:22 - not
135:24 - now ideally you will start with this
135:26 - once you're getting a status 200 okay
135:28 - because this indicates this request is
135:31 - working in the sense that it can fetch
135:33 - your Postman collection
135:34 - It's always important that when you're
135:36 - making changes that you're saving them
135:37 - otherwise the test that you see here
135:40 - will continue to fail
135:42 - so this is just a quick introduction on
135:44 - how you can approach this assignment and
135:47 - this is also valid for the upcoming
135:49 - assignments as well your job is to
135:51 - ensure that everything here will get a
135:54 - pass sign and you do that by closely
135:57 - following the instructions given here in
135:59 - the tasks
136:00 - always check that you are naming the
136:02 - request exactly as indicated and that
136:05 - you follow all the instructions I wish
136:07 - you good luck with this one and if
136:09 - you're encountering any issues please
136:11 - use the postman Community forum for
136:13 - posting about the problem you're
136:14 - encountering and add there as many
136:17 - details as possible so that we can help
136:20 - you out
136:25 - welcome to the second level in our API
136:28 - test automation Quest where we Flex our
136:31 - brain muscles and craft some tests that
136:34 - will put our API to the ultimate
136:36 - challenge
136:37 - aren't you tired of clicking through
136:40 - your Postman collection and squinting at
136:43 - each response to see if everything is
136:44 - working as expected
136:46 - so far we have inspected the status code
136:49 - and response body to determine if our
136:53 - API calls were successful
136:56 - a very basic form of testing we have
136:59 - manually tested if the API Works doing
137:02 - it once is fun but doing it multiple
137:05 - times not so much well my friends buckle
137:09 - up because in this unit we're going to
137:11 - automate all this tedious work we'll be
137:14 - diving into writing API tests using
137:17 - Postman with Postman we can write a tiny
137:20 - bit of code that automatically checks if
137:23 - all the criteria with deem relevant have
137:26 - been fulfilled will be checking status
137:29 - codes
137:30 - response headers and response bodies
137:33 - we'll even dive into Json schemas
137:37 - we're doing all this work now so that
137:40 - later we can kick back and relax while
137:43 - Postman does the heavy lifting for us so
137:46 - no more manual checks or copy pasting
137:49 - data between requests it is time to
137:52 - level up your API game and embrace the
137:55 - power of automation
137:57 - so without further Ado let's jump in and
138:00 - start writing some tests
138:04 - in this lecture we will discuss the
138:06 - structure of a test in Postman so what
138:09 - do I mean by the structure of a test
138:11 - let's open up the status endpoint
138:14 - and start writing here test
138:17 - now a test in Postman needs to start
138:21 - with pm.test
138:23 - and this method has two arguments we
138:25 - need to specify the name of the test
138:27 - we're gonna call it like example for a
138:30 - moment
138:31 - and we also need to specify a callback
138:34 - function
138:35 - so we can write here function
138:38 - and this will be our callback function
138:40 - I'm gonna hit here the enter key so that
138:42 - we have a bit more space
138:44 - and this is the basic structure of this
138:46 - test now at this point this test doesn't
138:49 - do anything this is like an empty shell
138:51 - so we can go ahead and click on send
138:55 - this test will show up here in the test
138:57 - results you will see here the name
138:59 - example but it doesn't do anything in
139:02 - order to make this a test that will fail
139:04 - if needed we need to write assertions
139:07 - and we're gonna write these assertions
139:10 - exactly here in this callback function
139:13 - this is why we need this entire
139:14 - structure
139:15 - so how do we write assertions well
139:18 - insertion is essentially something that
139:21 - we expect so with an assertion we are
139:24 - gonna assert something so for example
139:27 - let's write PM dot expect
139:30 - and we're gonna expect for example one
139:36 - to eql which comes from equal
139:41 - 1.
139:42 - so in this case we're practically saying
139:45 - we expect 1 to equal one
139:48 - of course this is a very simple
139:50 - expectation and all the data that we
139:53 - have is our coded but let's take a look
139:55 - and understand how this works
139:58 - so in this case the test passes because
140:00 - 1 does equal one
140:03 - however just as well we could have here
140:06 - the expectation that
140:08 - 2 equals 1.
140:11 - or three
140:14 - now in this case this test will fail
140:17 - so the first test with the status code
140:19 - will pass
140:21 - but then our second test that we have
140:23 - will fail we're gonna get you this
140:25 - assertion error it's going to tell us
140:27 - hey look 3 doesn't equal one and it's
140:32 - gonna fail
140:33 - a test in Postman can contain one or
140:37 - multiple assertions
140:39 - as soon as one of these assertion fields
140:42 - the entire test is considered fail
140:46 - once Postman detects a failure it will
140:49 - stop the test and not execute the
140:52 - upcoming exertions if there are multiple
140:54 - of them
140:55 - in this assertion we also have a bit of
140:58 - a structure
140:59 - what we expect here
141:01 - this is what you will typically get from
141:03 - the response so this is something that
141:05 - we don't know this is why we need to
141:07 - make an expectation about it and on the
141:11 - second part here to equal this is the
141:13 - part that we know for example maybe we
141:16 - expect a product to be available and
141:19 - then would say something in regards to
141:22 - the product
141:23 - to be true because available will be a
141:27 - Boolean
141:28 - the point of this initial lesson is to
141:30 - get you familiar with the structure of
141:32 - having a test and having assertions
141:35 - inside that test
141:37 - there's also something that you need to
141:39 - pay attention
141:40 - for example if you write something like
141:42 - PM that expect
141:44 - one
141:45 - to equal one with a triple equal sign
141:49 - this test will appear as it passes
141:52 - however
141:53 - if you write here 1 equals three
141:58 - this test will also pass
142:00 - what you see here is actually an
142:03 - incomplete and incorrect way of writing
142:06 - an assertion
142:07 - so to write an assertion in Postman you
142:10 - have to use PM that expect and you're
142:13 - specifying here something then you need
142:16 - to specify the expectation the value
142:18 - that you think this initial part will
142:21 - equal
142:22 - just writing something like this is
142:24 - totally incomplete and will give the
142:27 - impression that everything is working
142:29 - fine when actually it isn't
142:32 - so pay attention to how you're writing
142:34 - this test and make sure that you are
142:36 - following the structure that I've
142:38 - mentioned earlier and this is using
142:41 - pm.expect
142:43 - having something here then to equal
142:46 - something else
142:52 - let's turn our attention back to this
142:55 - test and in particular to this assertion
142:58 - as you can notice this assertion is not
143:01 - using PM that expect it's using
143:04 - something else well in Postman there are
143:07 - a few expectations that we can write a
143:09 - bit differently but probably most of the
143:12 - time like 95 of the time we're gonna use
143:15 - PM that expect
143:17 - still I wanted to show you a different
143:18 - way on how we can write the exact same
143:20 - expectation but using PM that expect
143:24 - now in order to use PM that expect
143:27 - which looks like this PM not expect we
143:29 - need here somehow the status code we
143:31 - don't know from where we can get at
143:33 - and then we need to write something like
143:35 - to equal
143:36 - when we expect it to equal 200 right so
143:39 - this would be in a nutshell the
143:40 - expectation
143:42 - the missing part is this one here
143:45 - now what we could do here is use
143:47 - console.log and use pm.response because
143:51 - this is where the response is being
143:53 - stored in Postman
143:55 - so let's take a look at what is
143:57 - happening here
143:59 - but our test will fail because we have
144:02 - written here essentially undefined to
144:04 - equal 200 and this will not work
144:08 - but we have also logged here PM that
144:10 - response so let's see what this thing is
144:13 - well as you can see here in essence
144:17 - pm.response is an object that has some
144:20 - properties so we have here a property
144:22 - status and we have here a property code
144:25 - well we could use property code so let's
144:28 - write here PM that response dot code
144:31 - run this once again
144:33 - and we're going to see here the value
144:34 - 200.
144:36 - so what we want to do next is we want to
144:40 - make a assertion with this one we're
144:42 - gonna copy pm.response.code this is what
144:45 - is coming from the response this is
144:47 - essentially what we don't know
144:49 - and then we're saying well we're
144:51 - expecting the code to equal to 100.
144:53 - let's go ahead and run it it's working
144:55 - perfectly if you're writing here status
144:58 - 2 so we're changing the URL to something
145:00 - that doesn't exist
145:02 - this assertion will still fail
145:05 - so this is just an alternative way of
145:07 - writing the same assertion but this time
145:09 - using PM that expect
145:16 - welcome to the second assignment of this
145:18 - course your job is to write a status
145:21 - code test for Every request that we have
145:25 - in this collection
145:27 - having at least a status code test is
145:30 - the most basic thing that we can do when
145:33 - we're doing API testing so whenever
145:36 - we're testing an endpoint the status
145:38 - code test is the first test that we're
145:41 - gonna write so this is why when we're
145:43 - starting API testing we should ensure
145:46 - that every request has documented status
145:49 - code test which indicates what is the
145:51 - expected status code for that particular
145:53 - endpoint
145:55 - from the original workspace I have
145:57 - Linked In the course notes you need to
145:59 - Fork The Collection named assignment 2
146:02 - and follow the instructions from there
146:09 - before we start doing something with the
146:11 - response body it is best not to assume
146:14 - we get Json Bank
146:16 - sometimes the API might misbehave and
146:20 - return something unexpected like HTML
146:23 - let me show you
146:25 - I'm gonna go ahead and expand the
146:28 - products folder
146:29 - and take a look at the get single
146:31 - product where we already inside the test
146:33 - have some code where we're parsing the
146:35 - response body and then we're trying to
146:37 - log property
146:39 - now typically if we're getting back Json
146:41 - this works without any issues
146:43 - however let's make a change to this
146:47 - instead of products here I'm going to
146:49 - write here products too
146:51 - and I'm going to go ahead and submit
146:53 - this request
146:55 - now what we're getting back here
146:57 - is a status 404 not found
147:01 - and apart from this we're getting back
147:04 - here HTML
147:06 - this is essentially what's being used to
147:08 - display web pages and this API is not
147:11 - perfect and in some situations does
147:13 - return back HTML without knowing that
147:15 - we're not really interested in HTML
147:18 - still we need to be prepared for such
147:20 - situations
147:22 - apart from this what I want you to
147:24 - notice is that here the test results
147:25 - appear in red now even though we haven't
147:28 - written any tests
147:30 - we're gonna get this nasty error here
147:33 - telling us there was an error evaluating
147:35 - the test script and there's some
147:37 - problems here when we're writing code in
147:40 - Postman it is best to encapsulate this
147:44 - in a test
147:45 - if an error occurs in a test it's not
147:49 - going to propagate outside of the test
147:51 - though essentially that callback
147:52 - function provides some protection around
147:55 - the code that we're writing
147:57 - let me show you what I mean so we're
147:59 - gonna write here a test
148:00 - where we want to assert that the
148:03 - response body is Json so I'm going to
148:05 - write pm.test
148:07 - and then right here response body is
148:09 - Json
148:11 - so this is the first argument
148:13 - then I'm gonna write the Callback
148:15 - function
148:16 - and inside the Callback function let's
148:18 - move our test
148:21 - so I know that currently this code is
148:23 - not properly working
148:25 - now let's send this once again
148:28 - and this time what we're gonna get back
148:30 - is a test result and we're gonna get the
148:33 - information that this test here which
148:36 - doesn't contain any assertions but the
148:38 - code that is inside this test has
148:41 - actually failed and we're getting here a
148:43 - Json error and it is practically the
148:45 - same error but what's important here to
148:47 - notice is that this code doesn't prevent
148:50 - other code that we have inside our test
148:53 - from running
148:54 - so any errors that appear will be
148:57 - limited to this callback function
148:59 - still this is not a way of actually
149:02 - testing if the response body is Json so
149:05 - in order to test if the response body is
149:07 - Json we actually need to write an
149:09 - assertion and this is again one of these
149:11 - special assertions that don't use PM
149:14 - that expect in this case we're going to
149:16 - write pm.response
149:18 - to B
149:20 - Json super easy to read and also super
149:24 - easy to write
149:25 - let's run this once again and see what
149:27 - is happening
149:28 - and in this case now the test is still
149:31 - failing this is expected but we're gonna
149:33 - get here this assertion error it's gonna
149:36 - tell us expected response body to be a
149:38 - valid Json but God error unexpected
149:41 - token at something okay and if this
149:45 - assertion here fails this code here is
149:48 - no longer being executed
149:50 - so when we're working with Json and we
149:52 - expect to get back Json from an API
149:55 - it is not a bad idea to start with a
149:58 - test where we are checking that the
150:01 - response body is Json the resource
150:03 - button is not Json you shouldn't worry
150:05 - with further assertions because we're
150:07 - gonna get some unexpected errors
150:14 - just testing if the status is 200 or
150:18 - checking that we're getting back Json is
150:21 - not enough to really verify that an
150:23 - endpoint is working as expected
150:26 - sometimes we want to wish if a property
150:29 - from the response has an expected value
150:32 - so how can we do that
150:34 - let's take a look at the response once
150:36 - again
150:37 - and in this case I'm just grabbing a
150:39 - product here it doesn't really matter
150:41 - which product it is but I'm having here
150:43 - Bagel so I would like to check that this
150:47 - property name
150:48 - is actually bagel let's go ahead and
150:52 - write a test pm.test and the name of the
150:55 - test will be productivism
150:58 - and I'm gonna also add here the Callback
151:00 - function
151:01 - perfect so in order to write these
151:03 - assertions first of all we need access
151:05 - to the response body
151:08 - and as you have seen here we already
151:10 - passed the response once so
151:12 - theoretically we would be able to use it
151:14 - here as well we can use pm.expect I'm
151:17 - gonna write here response
151:20 - and from the response what are we trying
151:22 - to get we're trying to get here the
151:24 - property name
151:25 - I'm gonna write here 2 equal
151:28 - and we're going to hard code the value
151:30 - bail
151:31 - if you're using a different product make
151:33 - sure to specify a different value
151:36 - let's go ahead and run this and
151:38 - surprisingly this test is failing and
151:40 - we're getting here this reference error
151:42 - response is not defined but response is
151:45 - defined how come it doesn't work here
151:48 - well this is where understanding the
151:50 - JavaScript Basics are super important
151:52 - remember those code blocks well when we
151:56 - are here inside the function we are
151:59 - essentially inside the code block so
152:00 - whatever we Define here is not going to
152:03 - be available somewhere else still if we
152:07 - put this outside that's going to cause
152:10 - other problems because we're gonna try
152:11 - to parse the response without knowing if
152:14 - it is actually a valid Json
152:17 - so what we could do in this case
152:20 - is simply Define here
152:23 - response outside we're gonna remove here
152:26 - const
152:27 - and this time I'm going to use let
152:30 - response because we're changing its
152:32 - value we cannot Define it with const
152:34 - so we have here let outside in the
152:37 - global scope
152:38 - which means we have access in our
152:40 - callback functions to this so then we
152:43 - can use response.name let's give it
152:45 - another try
152:46 - and we're going to see here response
152:48 - body is Json
152:49 - product is beagle this is passing
152:52 - without any issues
152:54 - just as well we can take a look at
152:56 - another property for example let's say
152:58 - we want to check the price so we're just
153:00 - going to go ahead and simply copy paste
153:02 - the same expectation that we had before
153:04 - and you notice me I'm using here copy
153:07 - paste
153:08 - always use copy paste when you're
153:10 - working with properties from the
153:12 - response body because this ensures
153:13 - you're not making any mistakes
153:15 - so response at price
153:18 - well what is the price it's going to be
153:19 - 195.
153:22 - so let's put that price here
153:24 - and run this once again
153:26 - and again this test is failing why is it
153:28 - failing
153:29 - because 195 does not deeply equal 195
153:34 - and this can be a bit of a confusing
153:35 - error how do you mean well 195 in the
153:39 - body doesn't have any quotes which means
153:42 - is a number
153:43 - here 195 is between quotes which means
153:46 - it is a string when we're comparing
153:48 - things in JavaScript a string will never
153:52 - equal a number
153:53 - even if the value is the same so in
153:57 - order to get this to work all we have to
153:59 - do is remove this quote
154:01 - and then our restoration will work
154:04 - just as well okay continue also with
154:06 - other assertions for example we could
154:08 - check if this is available so you'll
154:10 - notice here I'm grouping multiple
154:12 - assertions under the same test so maybe
154:15 - later on we can decide to change the
154:17 - name of the test but we're just trying
154:19 - to understand how these assertions are
154:22 - actually working so let's go ahead and
154:24 - start here that this property is
154:27 - available
154:28 - is actually true so again true is a
154:31 - Boolean so we don't need any quotes we
154:33 - can put it like this
154:35 - so the test will continue to pass
154:37 - or an alternative way to write this is
154:40 - to still use PM that expect instead of
154:43 - writing to equal we can write to B
154:47 - true
154:49 - different syntax Works absolutely the
154:51 - same
154:52 - if you would think that this is for some
154:54 - reason false we can write this false but
154:57 - of course in this case the test is
154:59 - failing it's a good idea to test our
155:01 - assertions to make sure that they're
155:03 - actually work the way we expect them to
155:05 - work
155:05 - now there's still one thing that I would
155:08 - like to test here and that is we have
155:11 - here this Postman collection variable
155:13 - with the product ID and we manage this
155:16 - somewhere so we can change this later on
155:19 - so how can we ensure that the product
155:20 - that we have requested by specifying
155:22 - this product ID is also the one that
155:25 - we're getting here in the body now of
155:28 - course we can check all these properties
155:29 - name and so on but maybe testing out the
155:33 - ID would be a good idea as well so let's
155:35 - write here pm.expect
155:37 - what are respecting we're expecting
155:39 - response dot ID to equal
155:43 - and
155:44 - what is the name of the variable let's
155:46 - go ahead and copy paste this
155:49 - and put it inside here
155:52 - okay maybe we need some quotes no
155:54 - problem
155:55 - let's put this between quotes
155:58 - no errors I'm gonna give it a try
156:01 - and the test is failing
156:03 - what is happening in this case
156:06 - why is this working here when we're
156:09 - sending the request
156:11 - but when we're putting this inside our
156:13 - test is not working anymore
156:15 - well what's important to remember is
156:18 - that this syntax
156:19 - only works in the request Builder
156:22 - essentially you can use this Syntax for
156:24 - variables when we're working with params
156:27 - with path variables with authorization
156:29 - headers in the body
156:31 - anywhere else apart from the script we
156:34 - cannot use this syntax in the script
156:36 - it's simply a string Postman is not
156:39 - going to replace it
156:40 - so if we're trying to get the product ID
156:44 - in a programmatic way essentially from a
156:46 - script
156:47 - we need to use something similar to The
156:49 - Way We have set a variable from the
156:52 - script we can use
156:53 - pm.colection variables because this is a
156:55 - collection variable and this time we're
156:57 - going to use get
156:59 - we're going to specify okay what are we
157:01 - trying to get trying to get a product ID
157:05 - let's give it a chance
157:07 - now there's something even more
157:09 - interesting you can see now we're
157:10 - getting the value right
157:13 - but we're getting this problem that
157:16 - we've seen before when we're comparing a
157:18 - number with a string
157:20 - if you're looking here inside a
157:22 - collection at the variables
157:25 - you'll notice that you know there are no
157:27 - quotes here
157:28 - and the question is why doesn't this
157:30 - work
157:31 - well the thing where we're manually
157:33 - managing information here most of the
157:36 - time behind the scenes Postman will save
157:39 - this as a string
157:41 - and then when we are making comparisons
157:43 - here then we're gonna get a string and
157:46 - we're gonna compare string with a number
157:47 - and that's not gonna work
157:50 - if we want to rescue the situation and
157:52 - we are pretty sure that we have a string
157:54 - there we can use a function which is
157:57 - called parse int so with parse end it's
158:00 - gonna try to transform that string into
158:04 - a number into an integer
158:06 - then we can run this and our assertion
158:09 - is working because now we're comparing a
158:11 - number with another number
158:18 - now let's go ahead and change this
158:20 - product to some other product
158:22 - you will see here we are using the
158:24 - product ID so what we need to do is to
158:27 - figure out another valid product ID say
158:30 - for example let's disable the category
158:32 - that we have enabled
158:34 - and let's simply go with the cappuccino
158:38 - so we have here this ID for a cappuccino
158:40 - I'm gonna go inside the collection and
158:43 - edit the variables I'm Gonna Change here
158:45 - the product ID to a different value I'm
158:48 - going to go ahead and save it and let's
158:50 - get a single product so now we expect to
158:53 - get back cappuccino if we're taking a
158:55 - look at the body
158:57 - yes we have a cappuccino
158:59 - and yeah the response body looks
159:02 - absolutely fine
159:03 - now if you're taking a look at the test
159:05 - results they are not so fine well okay
159:09 - it says here product is a bagel and we
159:12 - have here some tests that verify
159:15 - some parameters well the thing is the
159:19 - response itself is still fine it still
159:21 - looks like a valid response
159:23 - it just isn't a bagel now we can debate
159:26 - if this is a good test or a bad test but
159:29 - this for our situation here this test is
159:33 - overly specific if there's any change in
159:36 - the data for example maybe the price is
159:38 - changing or the product name is slightly
159:40 - changing then our test will fail
159:43 - so the only Dynamic part that we have
159:45 - here inside our test are the product ID
159:49 - and of course it's always a good idea to
159:51 - assume that a product that we're trying
159:52 - to work with is available but the name
159:55 - and the price they are problematic there
159:58 - are situations like this one where it
160:00 - makes little sense to hard code values
160:03 - in tests
160:05 - do we really care if the product is
160:08 - called a bagel or a cappuccino or how
160:10 - much it costs
160:12 - and in most cases reality is we don't
160:15 - we just want to check if the product
160:17 - that we have received is a valid product
160:21 - so instead of asserting if a property
160:23 - has a specific value
160:26 - we can change our assertion to check the
160:29 - data type of that property so let me
160:31 - give an example
160:32 - we know that the response body has a
160:35 - property called name
160:37 - so let's check if there is a property
160:39 - code name there instead of just checking
160:42 - it has a specific value
160:44 - so to do that we can write here another
160:46 - expectation so I'm gonna remove here
160:49 - bagel
160:50 - and the expectation that I'm gonna write
160:52 - is PM that expect
160:54 - and the expectation goes against the
160:57 - response because this is the object that
160:59 - contains the product
161:00 - and we can write here to have property
161:04 - and the property is name and for a
161:07 - second I'm also then remove this price
161:08 - from here
161:10 - so now we are just checking if the
161:12 - response has a property called name
161:15 - and the test is passing we can check
161:18 - also if it has property called Product
161:21 - name
161:22 - and if we run this the test will fail
161:25 - because there is no property product
161:27 - name in the response body we can check
161:29 - that easily
161:31 - so there's only a property called name
161:34 - now we don't only care that we have a
161:36 - property called name but we also care if
161:39 - this name property is actually a string
161:43 - so we can write another expectation but
161:45 - this time on the property we can see PM
161:47 - not expect
161:48 - and we have response dot name
161:51 - and we can say here 2B oh
161:54 - and then as a string we're going to
161:57 - write here strings we're going to have
161:58 - here string between quotes
162:01 - so we're checking if the response body
162:03 - has a property called name and we're
162:05 - checking that this property is a string
162:08 - and it is a string we can also check if
162:11 - it is a number
162:12 - and this is not a number it is actually
162:15 - a string
162:16 - so we're gonna get this assertion error
162:18 - so let's switch it back to string
162:20 - in a similar fashion we can also go
162:23 - about the price
162:24 - so instead of checking a specific price
162:27 - we can simply go ahead and D here if the
162:31 - responsive price
162:33 - to be a number
162:35 - and the price indeed is a number so the
162:39 - test is passing and now from a logical
162:41 - sense we typically expect our price to
162:45 - be higher than zero right so no price
162:49 - can be zero or we can't have any
162:52 - negative prices this is just the
162:54 - business logic that we have we are
162:56 - trying to make a profit so we're not
162:57 - going to sell something where we have to
163:00 - give mine to the customer right so it's
163:02 - a valid expectation to say whatever
163:04 - price we have it must be at least one
163:07 - cent so it needs to be greater than zero
163:10 - so we can write here another expectation
163:12 - with PM that expect against the response
163:16 - price
163:17 - 2 B and we have here greater than
163:21 - always follow the auto completion to be
163:23 - faster and more accurate
163:25 - I'm gonna write here the price to be
163:27 - greater than zero
163:29 - the test is passing now this product
163:31 - costs three dollars so let's change it
163:35 - for example to let's say four here to be
163:39 - greater than four and it's not going to
163:41 - be greater than 4 because 3 is not above
163:44 - 4.
163:45 - so we have also tested that the
163:47 - assertion that we have written makes
163:49 - sense from this perspective
163:50 - now of course we have grouped here a lot
163:53 - of assertions around this test but we
163:55 - can just also split them for example we
163:58 - can write a test that only deals with
164:01 - price to ensure that it has a valid
164:02 - price we can write a test that just
164:05 - ensures that a property is as expected
164:08 - and so on so we're not going too much
164:10 - into how we organize this test and how
164:13 - we name things but we're just trying to
164:14 - understand how we can write these
164:16 - assertions better
164:18 - and now the advantage of this approach
164:20 - is that we can change the product and
164:22 - the test will still work only if
164:25 - something changes about the structure of
164:27 - the data will we have issues
164:30 - now you notice here that this syntax is
164:33 - relatively easy to read right so maybe
164:36 - you don't know exactly how to write
164:38 - everything but once something is written
164:40 - you can just look at it and say oh
164:42 - response to have property name that's
164:44 - understandable response that name to be
164:47 - a string that's also understandable well
164:49 - what makes these assertions work so well
164:53 - and be so easily readable is a
164:57 - third-party library that is being used
165:00 - by Postman so this easy to read syntax
165:03 - is made possible by a JavaScript
165:05 - assertion Library named chai JS and you
165:09 - can find out more about chijs at
165:11 - chijs.com and I also linked this
165:15 - documentation in the course notes so
165:17 - what you will find here are many many
165:20 - other options that you can use now
165:22 - you'll notice here that the
165:23 - documentation uses expect to equal so
165:27 - the only thing that you need to get
165:28 - something like this working in post is
165:31 - to Simply add here PM don't expect and
165:34 - it will work in Postman so let me show
165:35 - you an example here just to understand
165:38 - we can copy this assertion here take it
165:41 - inside Postman if you paste it as it is
165:43 - we're gonna get an error telling us that
165:46 - expect is not defined so all you have to
165:48 - do is add pm.expect
165:51 - getting familiar with the chai assertion
165:53 - library is a very powerful way of
165:56 - writing more sophisticated Postman tests
165:59 - and this is a very powerful assertion
166:02 - Library so do spend some time and go
166:05 - over the examples that are being listed
166:07 - here I'm sure you will find something
166:09 - useful
166:14 - let's take a look for a second at the
166:17 - create an order request
166:19 - inside this request we have a few
166:22 - interesting things when one of these
166:24 - things is here this variable which is a
166:29 - postman generated random variable it's
166:32 - not a variable that we are setting
166:35 - however how can we guarantee that the
166:38 - data that we're sending has actually
166:40 - been received by the API exactly as we
166:43 - intended
166:45 - well let's go ahead and see how we can
166:47 - write a test for this particular use
166:49 - case
166:51 - we're going to begin with a few Basics
166:53 - and we're gonna borrow from one of the
166:55 - previous requests that we have and this
166:57 - comes from the products endpoint
167:00 - for what we already have here is this
167:02 - part with response body is Json so this
167:05 - is something that's super useful we want
167:08 - to make sure that the response body is
167:09 - Json so we're parsing the response body
167:11 - and storing this in a variable and of
167:14 - course once the response body is Json
167:16 - maybe we also want to set this Postman
167:19 - variable here but that's not the scope
167:21 - of it let's go ahead and write a new
167:24 - test that verifies the customer name
167:26 - so let's name the test simply customer
167:28 - name
167:29 - and we're going to have here our
167:30 - callback function
167:32 - and we can start writing some assertions
167:35 - so how do we write an assertion well we
167:38 - can go ahead and use pm.expect
167:40 - and what do we have here well we have
167:43 - the response
167:45 - and on the response we have the property
167:47 - customer name that we can use perfect so
167:50 - far so good and then we write 2 equal
167:53 - and then
167:55 - what do we put inside here well we could
167:57 - try something like this right so we
167:59 - could go ahead and put this as a string
168:03 - inside here and see what is happening
168:06 - and what is happening is that we're
168:09 - gonna get a test that is failing
168:12 - so this syntax doesn't work inside here
168:15 - it works inside the body but doesn't
168:18 - work inside here
168:19 - still there is a way to resolve Postman
168:23 - variables like this one inside Scripts
168:26 - the syntax is a bit tricky but I'm going
168:29 - to show you anyway
168:30 - so what we need to use is
168:33 - pm.variables dot replace in it's a bit
168:38 - tricky but hang on for a second so we're
168:41 - going to replace in
168:43 - and here we can essentially specify a
168:46 - string pretty similar to what we have
168:48 - here so if you're unsure about the
168:51 - outcome of this we can simply wrap
168:53 - everything in a console.log statement
168:56 - and take a look in the postman console
168:59 - to see what is happening
169:01 - let's clear everything here and run this
169:05 - so what you will see here being logged
169:08 - is the result of us writing this line of
169:11 - code so this is a way how we can still
169:14 - use this syntax with braces without
169:17 - using pm.collection variables.get or
169:19 - something and when we're working with
169:21 - this random Postman variables there is
169:24 - any way no other alternative to reaching
169:27 - one of these values
169:28 - all right so you can see here that we
169:32 - are now getting this random Postman
169:34 - variable and it changes all the time so
169:37 - we can simply go ahead and use this in
169:39 - our code
169:40 - so we're gonna stay here pm.variables
169:43 - replace in
169:44 - and we have our expectation
169:47 - right about here
169:48 - let's run it once again
169:50 - and our test is still failing and the
169:54 - reason for that is whenever Postman
169:57 - invokes this call when we say we want to
170:00 - use here random full name or random
170:02 - something else a new value is generated
170:05 - with every call so Postman generates one
170:09 - value here in the body
170:10 - and in the test it's going to generate a
170:13 - different value so this is why our test
170:15 - is still failing
170:17 - we haven't made a lot of progress have
170:19 - we well not so fast I have a different
170:22 - idea I'm going to go ahead and copy this
170:24 - from here
170:25 - and
170:27 - I'm gonna go here in the prequest script
170:29 - so here in the prequest script what we
170:32 - could do
170:33 - is to set another Postman collection
170:36 - variable we can use here pm.collection
170:39 - variables.set
170:41 - and we could call this customer name and
170:44 - the value would be you know whatever
170:46 - comes back from here and then in the
170:49 - body
170:51 - we can replace this random variable here
170:54 - with a collection variable which
170:57 - currently doesn't exist but it will
170:58 - exist in a second
171:00 - and also in the test we can use BMW
171:02 - collection variables dot get
171:06 - and we're getting the customer name
171:08 - so we're letting Postman generate this
171:11 - once
171:12 - set it in a postman collection variable
171:14 - by using it in the body and we're using
171:16 - it in assertion let's give it a try to
171:19 - see if it works
171:21 - and what do you see this is how we can
171:24 - take advantage of random Postman
171:27 - variables and Postman collection
171:29 - variables to pass data between the
171:32 - prequest to request the tests and so on
171:40 - let's continue thinking about what kind
171:42 - of tests we could write against this
171:44 - particular endpoint so we know that we
171:46 - have the right customer name and of
171:48 - course there's also other details that
171:50 - we could check
171:51 - but one interesting one would be this ID
171:55 - this ID is the order ID and it does
171:59 - follow some rules for example this order
172:02 - ID can only be composed of uppercase
172:05 - letters and numbers and it has a fixed
172:09 - size of nine characters
172:12 - so how can we write a test for something
172:14 - like this
172:15 - well let's go ahead and copy the
172:18 - skeleton for a test and we can write
172:20 - here something like order
172:22 - ID
172:23 - format
172:25 - so we're testing the format of the order
172:27 - ID
172:28 - how can we do that well we can again use
172:31 - PM that expect a response
172:33 - dot ID
172:35 - and then what we could do here is to
172:38 - write a regular expression
172:41 - now regular expression is a way how you
172:44 - can Define in a programmatic way the
172:47 - kind of structure that you expect from
172:49 - data in this case we can write a regular
172:52 - expression that says this ID can only
172:56 - contain numbers and letters and those
173:00 - letters need to be in uppercase and the
173:02 - size of this thing needs to be nine
173:04 - characters
173:06 - we're not going to go into how we can
173:08 - write regular Expressions because that's
173:10 - a topic on its own but we're going to
173:12 - take a look at a simple example at how
173:14 - to do this in Postman so what we're
173:16 - going to use here is to match so to
173:19 - match allows us to write a regular
173:22 - expression
173:23 - and we're gonna write it here and I want
173:25 - you to pay attention this is not a
173:27 - string here what we're writing inside
173:28 - match
173:29 - so a regular expression goes more or
173:32 - less like this
173:33 - we are starting it here then we're
173:36 - adding here this carrot sign
173:38 - and then what we'll have here between
173:40 - brackets we're gonna say something like
173:42 - this must contain letters from A to Z
173:47 - and from n numbers from 0 to 9.
173:51 - and we expect to see this exactly nine
173:55 - times
173:56 - and this is the end of the regular
173:59 - expression you'll see here I have no
174:01 - errors if you're having trouble finding
174:03 - any of these characters on your keyboard
174:05 - don't worry I've added this expression
174:08 - to the course notes as well so that you
174:10 - can easily copy paste it if needed
174:12 - so let's take a look and see if this is
174:14 - working as expected
174:16 - I'm gonna go ahead and click on send
174:19 - and you'll see the test is passing
174:21 - now the thing is I know that this API
174:24 - has a bug and from time to time in the
174:28 - ID it will include a character that is
174:31 - not a letter from A to Z or a number
174:34 - from 0 to 9. so it's just a matter of
174:37 - time until you're running this test
174:40 - and you're noticing all of the sudden
174:42 - this test failing because you will find
174:46 - there a character that shouldn't be
174:47 - there oh there it is look have you
174:50 - spotted it
174:51 - you'll see initially the test has passed
174:54 - but after a while we are getting this
174:56 - Dash here and this is not something that
174:59 - we expect according to how this ID
175:01 - should work
175:02 - so this is why it's a good thing to have
175:05 - a test here that will fail and warn us
175:07 - if all of the sudden something changes
175:10 - about the behavior of this API
175:17 - it is now time for the third assignment
175:19 - and for you to get some Hands-On
175:21 - practice we have gone through various
175:24 - ways of testing the API endpoints and
175:27 - writing various tests and assertions
175:30 - now I want you to go inside the orders
175:33 - endpoint
175:35 - and take a look at this get an order by
175:38 - ID request
175:40 - in this case you're getting here back
175:42 - information about this order and I want
175:45 - you to use everything that you have
175:47 - learned so far to write some tests
175:51 - make sure that you go to the original
175:52 - workspace and work the collection named
175:56 - assignment 3.
176:02 - let's continue exploring ways on how we
176:05 - can test this endpoint so I'm here at
176:07 - the create a new order endpoint and we
176:10 - are checking out the response buddies
176:11 - Json we are checking the customer name
176:13 - and we're also checking that the order
176:16 - ID has the right format but there's
176:19 - still also other information here
176:22 - how can we do that
176:23 - well in order to test the response
176:26 - structure we could again go property by
176:29 - property
176:30 - check if the property exists check if
176:32 - the property has a particular type
176:34 - check maybe other things about those
176:36 - properties
176:38 - with relatively simple responses that is
176:41 - relatively okay
176:43 - but once our responses get a bit longer
176:46 - or are a bit more complex
176:48 - this approach is no longer so valid a
176:52 - solution to this is to use a Json schema
176:56 - and to validate the response that we're
176:58 - getting against the schema okay let's
177:01 - back it up for a second what is adjacent
177:04 - schema adjacent schema is essentially a
177:07 - way to describe the structures and rules
177:10 - of our responses
177:13 - when our responses are in Json we can
177:16 - use a Json schema
177:17 - adjacent schema is also written in Json
177:20 - and essentially helps us understand if
177:24 - the Json that we're having here actually
177:27 - follows the expected format and it is a
177:30 - bit easier to catch errors in that way
177:33 - so let me show you what I mean by that
177:36 - we're going to start with a very very
177:38 - simple test so I'm gonna use here the
177:41 - test skeleton that we already have
177:44 - and just one line below I'm gonna write
177:47 - here schema is valid
177:49 - and what you will need here is a Json
177:52 - schema so we're gonna Define here a new
177:55 - constant call it schema
177:57 - and what we have here is the assertions
177:59 - or resolution will be pm.response
178:03 - and this is going to be one of those
178:05 - special assertions so we're going to
178:07 - stay here PM that response to have
178:11 - Json schema
178:13 - and we're going to reference here the
178:15 - schema
178:16 - so we can simply run it and see
178:19 - if we're getting anything back
178:21 - okay
178:22 - we're getting again the test field the
178:25 - failed test because of the ID which is
178:27 - sometimes inconsistent but we're gonna
178:29 - get here schema is valid okay
178:31 - so we haven't done a lot in terms of
178:33 - this schema it's just an empty schema
178:34 - but just by default it kind of like
178:37 - passes the test okay fair enough let's
178:40 - go ahead and actually talk about the
178:43 - body that we have here about the
178:44 - structure that we have inside here so
178:47 - first of all we're gonna say look we
178:49 - have here an object this is an object
178:51 - which has properties so we're gonna
178:53 - write here type
178:54 - and the type is gonna be object okay
178:57 - fair enough
178:59 - then
179:00 - we can again check is it still working
179:02 - perfect no problem let's say if we say
179:05 - type is array
179:07 - does it fail
179:08 - okay it fails it says here expecting
179:12 - data to satisfy schema but found
179:13 - following errors data should be an array
179:16 - our data is not an array it's an object
179:19 - okay so this is a simple way to make
179:22 - sure that we are on track let's continue
179:24 - with properties so inside properties
179:27 - which is again an object we can start
179:30 - defining the kind of properties we have
179:32 - in our body so for example ID client ID
179:35 - created and so on they're all properties
179:38 - and we can stay for these properties for
179:41 - example ID is a string client ID is a
179:44 - string any other information is also a
179:47 - string
179:48 - so this should be pretty straightforward
179:50 - but I'm gonna go ahead and right here we
179:52 - have the property ID
179:54 - and again as an object we're gonna write
179:56 - here type
179:58 - and the type will be string
180:01 - okay so we're gonna repeat this a couple
180:04 - of times so I'm just gonna copy this
180:06 - code block here make sure to add a comma
180:10 - and
180:11 - do this for maybe three or four times
180:15 - let me make it a bit larger so that you
180:18 - can see it so we have here ID
180:20 - the next one on the list is client ID
180:24 - after this we have created
180:27 - after created we have customer name
180:30 - and actually we need another one
180:33 - but this one is no longer
180:35 - an ID this is actually an array so we'll
180:39 - see here products so we can write here
180:41 - products
180:42 - column and also as an object type will
180:46 - be array
180:48 - very well let's go ahead and run this
180:52 - and it seems to be working fine
180:55 - now how do we know if this schema that
180:58 - we have written here is any good well we
181:01 - could essentially go ahead and maybe
181:03 - again play around with stuff and see
181:06 - string let's change this to a number see
181:09 - if it fails
181:11 - and it does fail okay
181:13 - fair enough seems to be working
181:16 - but this is a very rudimentary way of
181:19 - testing if our schema works we need to
181:22 - find a better way
181:28 - when we are writing tests in Postman it
181:31 - is our duty to ensure that this test
181:33 - will actually fail if needed
181:36 - if we have tests that never fail when
181:40 - they should
181:41 - then we got a problem because then our
181:44 - tests will not be so useful and we have
181:47 - wasted a lot of time writing tests that
181:49 - never fail
181:50 - now when we're working with Json schema
181:53 - The Experience shows that writing a
181:56 - schema that doesn't do what we expect to
181:59 - do is much much higher than any other
182:03 - assertions we have written before
182:05 - so when you're writing a Json schema or
182:07 - when we're working with Json schema we
182:09 - need to be extra careful that what our
182:13 - tests do is actually what we think that
182:16 - the test should do now testing if the
182:19 - Json schema works as expected
182:22 - actually requires us to make some
182:24 - changes to the response body
182:26 - well this is easier said than done
182:29 - because this is the response that is
182:31 - coming from the API we cannot easily
182:33 - make changes to it
182:36 - well luckily we have a built-in Postman
182:40 - tool that we can use to our advantage
182:43 - and this is a postman mock servers now
182:46 - Postman Max servers allows us to create
182:49 - fake API endpoints so in this context
182:53 - the word Mark simply means to imitate or
182:56 - simulate something
182:58 - it refers to creating a fake version of
183:01 - the actual API let me put this in plain
183:04 - terms a mock server will pretend to be
183:07 - the real API
183:09 - provide us with some responses to our
183:12 - requests
183:13 - but it will not actually process
183:16 - anything so for example if were to
183:18 - create a mock endpoint for this create
183:21 - an order endpoint that mock endpoint
183:23 - will not save the order will not do any
183:26 - validation or things like that no the
183:29 - advantage of using a mock server is that
183:31 - it allows us to actually test our test
183:34 - and to ensure that they work as expected
183:36 - without actually changing the real API
183:39 - which in most situations we cannot do
183:42 - anyway so we are going to use this
183:45 - particular use case for mock servers to
183:48 - modify the response body so that we can
183:50 - test our schema now in order to create
183:53 - our mock the first thing that we need to
183:55 - do is go to the create a new order
183:57 - request and click here on save as
184:00 - example and what this will do is it's
184:03 - going to save this response body as an
184:06 - example and this example will be used by
184:09 - the mock this is the first step that we
184:11 - need to do and then the second step is
184:13 - by going over the collection
184:15 - and hovering over it until this Ellipsis
184:18 - shows up and from the context menu we're
184:21 - gonna select Mark collection
184:24 - what we need to specify here is the mock
184:27 - server name so for example we can call
184:29 - it Valentinos
184:32 - coffee
184:34 - API mock We're Gonna Save the mock URL
184:38 - as a new environment variable
184:40 - and all you need to do next is to click
184:42 - on create mock server
184:45 - so the mock server has been created
184:48 - we can close this tab here
184:50 - and if we go here over the environment
184:52 - we'll see here that we have a new
184:54 - environment this is Valentino's coffee
184:56 - API mock this is the environment that
185:00 - stores information about this mock
185:03 - server and we have there the address we
185:05 - can go over these environment
185:07 - and we'll have here this variable URL
185:10 - we're going to change this to base URL
185:12 - so that it is the same variable we're
185:15 - using in our request we'll notice here
185:17 - we have base URL
185:19 - and here it should be also base URL when
185:23 - we don't have an environment selected
185:25 - we're gonna use the URL that is
185:27 - configured inside the collection however
185:30 - when we select an environment
185:32 - this base URL variable will be
185:35 - overridden and now we are actually
185:37 - calling using the exact same request
185:40 - without making any changes to the
185:42 - request itself we're now calling the
185:44 - mock API
185:47 - so you can notice here I'm running this
185:49 - once
185:51 - twice
185:52 - three times and getting the exact same
185:54 - information back nothing changes about
185:56 - it
185:57 - now if we're looking at the test results
185:59 - we're gonna see that a few things fail
186:02 - obviously our mock API doesn't behave
186:04 - like a real API so for example where we
186:06 - checking the customer name if it is a
186:08 - specific name that test is going to fail
186:11 - we also have this problem with the order
186:13 - ID so this is something that we can
186:15 - change here from the response itself so
186:19 - if we're going over this example EG here
186:22 - this is an example this is what's being
186:23 - used by the mock server
186:25 - see here we remove this
186:28 - and click on Save
186:30 - we can check if our test isn't passing
186:33 - no it's not passing because it's not
186:35 - long enough so let's add here a new
186:37 - character
186:39 - and this schema seems to be valid so the
186:42 - only problem is the customer name so
186:43 - let's go back
186:45 - how can we make sure that this schema is
186:48 - actually a good schema that it is
186:50 - working as we expect
186:53 - what could go wrong with this response
186:56 - for example
186:57 - what if we don't have the property
187:00 - client ID anymore
187:01 - how can we
187:03 - stimulate this we go back to this
187:06 - where we have this essentially
187:09 - temporary response which you wouldn't
187:10 - modify
187:12 - and I'm going to remove here the client
187:13 - ID all together from the response let's
187:16 - say some developer has removed it from
187:18 - the response and we no longer have it
187:21 - will any test say anything about this
187:25 - and we can run this again
187:28 - and if we're looking here at the schema
187:31 - the schema is valid
187:33 - that's weird
187:34 - How about if a developer would add here
187:38 - a new property for example new property
187:41 - new prop
187:43 - I'm gonna call it hello
187:45 - just for fun adding a new property to
187:48 - the response body
187:49 - this should definitely raise the alarm
187:53 - nope doesn't schema is still valid
187:57 - so now by using mock servers we can play
188:01 - around with the response that the server
188:05 - sends us or doesn't send us and we can
188:08 - then figure out what can we change about
188:11 - this to see if the schema will fail if
188:13 - needed if one of the situations should
188:16 - occur if we then have a valid test for
188:18 - that case
188:19 - well it seems that we don't have a valid
188:22 - test for that case and the problem with
188:25 - this is that our schema is valid is a
188:29 - good schema but it does have some
188:31 - problem and one of these problems is
188:33 - that it doesn't say that these
188:36 - properties are required so yes we have
188:39 - defined them in the schema if they are
188:41 - there they're going to be checked to be
188:43 - a string or an array or anything else
188:45 - but if they're missing that's not a
188:48 - problem
188:48 - if we add new properties that are not
188:51 - mentioned here that's not a problem so
188:53 - for this use case this is a problem and
188:56 - this is something that we can easily
188:59 - Overlook by looking at this schema and
189:01 - thinking yeah seems to be working fine
189:03 - when actually it is not
189:06 - so what we need to do next here is to
189:09 - specify another property
189:11 - and this property will be the required
189:13 - property so the required property allows
189:16 - us to specify essentially an array of
189:19 - values that are required so for example
189:22 - ID is required
189:25 - or do we have else client ID it's also
189:27 - required
189:28 - created is required everything that we
189:31 - have here in the response body is
189:33 - actually required we need to specify
189:35 - this here
189:37 - so that when we're doing the schema
189:39 - validation we're also checking that none
189:41 - of these properties are missing so we
189:44 - now saving this let's take a look here
189:46 - in the response we are still missing
189:49 - this particular property client ID
189:52 - so let's see if now
189:55 - something is failing and yes
189:58 - now we're getting an error and it's
190:00 - telling us data should have required
190:02 - property client ID
190:05 - but it doesn't
190:06 - so now we have tested that this
190:08 - particular feature is working as
190:11 - expected okay so let's re-enable here
190:13 - the client ID let's save this
190:16 - I'm gonna check here again that
190:17 - everything is working fine schema is
190:19 - valid perfect
190:21 - let's add here at the end another
190:24 - property
190:25 - I'm gonna call it new
190:29 - again an additional property that
190:31 - appeared all of the sudden in our
190:32 - responses
190:34 - and we don't know about it
190:36 - keema is valid how can we change this
190:39 - Behavior well by default any additional
190:42 - properties inside the Json data that are
190:45 - not specified in the schema are allowed
190:48 - and will not cause the validation to
190:51 - fail
190:52 - while this is useful in some situations
190:55 - in our particular use case it's not what
190:58 - we want ideally when new data is added
191:02 - to an API New Field something changes
191:04 - you want to be alerted about this
191:06 - because we might want to check that we
191:09 - may want to write a test about it
191:11 - and we don't want to be surprised that
191:13 - something new appeared all of the sudden
191:16 - so if we don't want any surprises then
191:19 - we need to specify this explicitly in
191:22 - our Json schema that we don't allow
191:24 - additional properties
191:26 - again this is another setting that we're
191:28 - gonna add here
191:29 - so just on the steam level as type
191:32 - properties required we're gonna write
191:34 - here additional properties and we're
191:37 - going to set additional properties to
191:39 - false we don't allow additional
191:41 - properties
191:42 - and now luckily our Json schema is
191:46 - failing and is telling us data should
191:49 - not have additional properties
191:51 - it does have additional properties here
191:54 - so let's go ahead and remove this from
191:56 - our mock server
191:57 - and now our schema is again valid if we
192:01 - need to check back in with the real API
192:03 - all we have to do here is disable the
192:06 - environment
192:07 - and then we're gonna start interacting
192:10 - again with the API
192:11 - but using mock servers is a very
192:13 - powerful way of working with a schema
192:16 - defining it and making sure that it
192:20 - works as expected
192:25 - writing Json schemas is no easy task and
192:29 - so far we have just scratched the
192:31 - surface however I want it to go a bit
192:34 - deeper and show you a more advanced
192:36 - example of how we can really ensure that
192:39 - this response body looks pretty much the
192:41 - way we expect it to look like
192:43 - there's still a few flaws here for
192:45 - example we haven't done anything about
192:47 - these properties ID and client identity
192:50 - they can be anything
192:52 - in terms of created we haven't checked
192:54 - for a specific format
192:55 - and also in terms of the products we
192:57 - just said there must be an array but we
193:00 - haven't really looked into like the data
193:02 - structure that these products need to
193:04 - have here so there's still a bit of work
193:06 - to be done
193:07 - now there are a few things that I wanted
193:09 - to point out first of all we can have
193:11 - here a string but just as well we can
193:14 - add here another property which is
193:16 - called pattern
193:17 - and this pattern allows us to write here
193:20 - a regular expression now this time we're
193:22 - going to write it here between quotes
193:25 - and in this case we already have Here
193:27 - regular expression that we can employ so
193:29 - we're gonna simply go ahead and copy it
193:31 - from here
193:33 - and put it here inside a pattern
193:36 - now apart from this because it is
193:39 - already between quotes you can go ahead
193:41 - and remove this
193:43 - at the beginning and at the end the
193:45 - forward slashes
193:46 - and we can go ahead and save this
193:49 - but not before we remove this other test
193:51 - which we no longer need
193:54 - so let's see if this is working properly
193:56 - seems not to be working properly
193:59 - let's see why oh actually is a good
194:02 - example because now we have a character
194:04 - that we shouldn't have so we already
194:06 - made the test with this one let's run it
194:08 - once again
194:10 - and now the schema is working so
194:12 - obviously just better luck the first
194:15 - request went into one of these edge
194:17 - cases where the ID is not what it should
194:20 - be
194:21 - perfect so we have done this here with a
194:23 - pattern in a pretty similar way we can
194:25 - do it also for the client ID
194:28 - but I want you to take a look here at
194:30 - created so created here is a date so
194:33 - what we could do here is write for
194:36 - example a format
194:38 - and we can say the format needs to be
194:40 - date time
194:42 - so this is a date time format let's go
194:45 - ahead and run it seems to be working
194:47 - fine
194:48 - let's switch back to the mock endpoint
194:51 - just to make sure that in case we're
194:53 - having here something else that it does
194:57 - so I'm just going to remove the last
194:58 - part of this daytime format and make it
195:01 - a bit shorter let's see if this causes
195:03 - any issues
195:05 - and it is going to cause an issue
195:07 - because it's gonna stay here does not
195:09 - match the format date time so luckily
195:12 - again using mock servers can help us
195:16 - identify if there are any issues at this
195:18 - point let's switch back to the real API
195:20 - and take a look at another thing and
195:23 - these are the products we mentioned
195:25 - earlier that we have here an array but
195:29 - we want to go a bit deeper
195:31 - so we have here an array but this is an
195:34 - array of objects and we can actually go
195:36 - a level deeper and say look this is an
195:39 - array of objects and every object in
195:42 - this array must have the property ID and
195:45 - must have the property quantity
195:47 - so let's see how we can do this as well
195:49 - essentially when we're having an array
195:51 - we can then specify items
195:54 - and items will be then an object where
195:57 - we can write additional things now the
196:00 - thing about this is that we're going
196:01 - back to how we Define an object so this
196:04 - is super interesting because you can
196:05 - write here type
196:07 - and the type will be object
196:09 - and we can write properties
196:11 - and we can start writing the kind of
196:13 - properties that we have
196:15 - so for example we have here an ID
196:17 - property
196:18 - and this is type integer
196:21 - and just as well we have here a quantity
196:24 - property
196:26 - go ahead and copy it from here
196:29 - and
196:30 - this is of type
196:33 - also integer
196:35 - let's go ahead and see if this works
196:37 - we're getting here an error Let's Take a
196:40 - Look Ah probably again the problem with
196:43 - the ID
196:44 - no worries we're gonna write once again
196:46 - so
196:48 - the schema seems to be working fine
196:50 - however you need to remember this is an
196:52 - object so we also need to add here
196:56 - required
196:58 - and we're gonna see here that ID is
197:01 - required and
197:03 - quantity is required
197:05 - so if any of these are missing you want
197:08 - to get notified
197:10 - if you also want to allow or disallow
197:12 - additional properties that's a different
197:14 - discussion but let's give it a try with
197:16 - this one
197:18 - schema is valid gonna switch back here
197:21 - to the mark endpoint
197:23 - and let's change a few things so I'm
197:25 - gonna make here ID all in uppercase
197:29 - just to give it a try Gonna Save this
197:32 - gonna select the mock environment
197:35 - and let's try this again to see if this
197:38 - error is being picked up
197:40 - and it is being picked up
197:42 - and it says here should have required
197:44 - property ID
197:46 - now we just briefly went over this to
197:49 - exemplify how we can reduce some of the
197:52 - tests that we have written previously
197:53 - and integrate everything in a schema and
197:56 - still get a pretty decent level of
197:58 - testing instead of having to write all
198:01 - these manual tests where we go property
198:03 - by property and so on
198:09 - now as we have seen by writing this Json
198:12 - schema is not really straightforward so
198:15 - I must warn you that the Json schemas
198:16 - are a topic on their own and we are just
198:20 - scratching the surface here
198:21 - learning to write Json schemas is not
198:24 - easy
198:25 - there are two pitfalls I must warn you
198:28 - about
198:29 - first of all and I see this all the time
198:31 - don't use websites which generator
198:34 - schema for you from a given response
198:38 - most of the time the schema that you're
198:40 - getting is simply not good
198:42 - second of all you're not gonna
198:44 - understand that schema so it's going to
198:46 - be very hard for you to determine what
198:48 - is inside that schema what is actually
198:50 - being tested and so on and so forth
198:54 - whatever approach you're taking
198:56 - always test if the schema will fail if
198:59 - needed
199:00 - I've seen so many times complex schemas
199:03 - being written that simply don't do what
199:07 - they're supposed to do and we get this
199:09 - false sense of security because we have
199:12 - this complex schema which is having all
199:15 - this regular expressions and is checking
199:17 - arrays and objects and everything and
199:19 - then when something changes about the
199:21 - response the schema says no okay
199:23 - everything is fine don't worry about it
199:25 - now if your project is programmatically
199:28 - generating a Json schema based on its
199:32 - code and given annotation that is fine
199:34 - you don't need to write that schema from
199:37 - scratch you can use it
199:39 - however this is not a real placement for
199:42 - understanding what the schema contains
199:44 - and how to test it
199:47 - so my advice is if you're just getting
199:50 - started with Json schemas is to learn
199:53 - about Json schemas step by step and to
199:56 - write them on your own
199:58 - a good resource for learning about Json
200:01 - schemas is Json Dash
200:04 - schema.org a link in the course notes
200:07 - the website is a bit hard to navigate
200:10 - but if you spend a bit of time and take
200:13 - a look at the documentation that is
200:14 - available
200:15 - you will soon get the hang of it and you
200:18 - will see how powerful Json schemas are
200:25 - alright so you have learned so much
200:27 - about Json schemas
200:29 - and now it's time for an assessment you
200:32 - want to really check how you would apply
200:34 - and create a Json schema for the get
200:37 - single product endpoint we currently
200:40 - have all these things here but I want
200:43 - you to write a Json schema based on what
200:46 - you have learned from the previous
200:48 - lectures go ahead to the original
200:50 - workspace and Fork the assignment number
200:53 - four inside your workspace and follow
200:56 - the instructions there
201:02 - apart from the status code in the
201:04 - response body a response also has
201:07 - headers
201:09 - and we already know how to test the
201:11 - status code and we know how to work with
201:13 - response body and make assertions there
201:15 - but what if there is a header that we
201:18 - would like to test
201:20 - while headers tend to be very technical
201:22 - you may find yourself in a situation
201:25 - that you want to make an assertion
201:26 - against a header to make sure that it
201:29 - has an expected value
201:31 - for example what if we want to check
201:33 - here if this x powered by header has the
201:37 - value expressed
201:39 - so let's write the test for the headers
201:41 - I'm just gonna copy here the structure
201:43 - of the test that we don't have to write
201:45 - it from scratch
201:46 - and I'm just gonna write here headers
201:49 - now before we actually make an assertion
201:52 - let's make sure that we can actually get
201:54 - to these headers and for that we're
201:57 - going to use
201:58 - pm.response because the headers are in
202:00 - the response dot headers we'll see here
202:04 - we have the auto completion four headers
202:07 - and in order to get a specific header
202:09 - we're gonna use dot get
202:12 - and as a string we need to pass the name
202:15 - of the header so it is best if we go
202:17 - here in the headers select the name of
202:20 - the header we want to use
202:21 - and paste it here this will ensure that
202:24 - we don't make any mistakes
202:26 - apart from this let's wrap this up in a
202:28 - postman console to make sure that we are
202:30 - getting the right value
202:32 - right so we're going to open up the
202:34 - console
202:35 - clear it
202:36 - and let's send this request
202:39 - so what you will see here in a console
202:41 - is the value Express and this is the
202:44 - value that we need
202:46 - okay so it seems that we have everything
202:48 - that we need so we can go ahead and
202:50 - write our expectation which would be a
202:53 - typical expectation that we're going to
202:54 - write with PM that expect
202:56 - so what are we expecting well we're
202:58 - expecting that this value that we're
203:01 - grabbing from this header to equal
203:05 - Express
203:08 - let's go ahead and see if it works and
203:10 - we have here a new test headers seems to
203:13 - be passing without any issues and this
203:15 - is anyway a test structure that we have
203:17 - used in the past so we know that it is
203:19 - working
203:20 - so this is how easy it is to test the
203:23 - header in Postman
203:29 - can you imagine testing 100 endpoints in
203:33 - just a few seconds with Postman you can
203:35 - do exactly that and I'm here to show you
203:38 - how you can unlock this super power
203:40 - welcome to the third level of our API
203:44 - automation testing challenge we now have
203:47 - a postman collection with some requests
203:50 - and each request has the associated test
203:53 - so we can go through the collection
203:55 - request by request and all we need to do
203:59 - is check if the test passed
204:01 - still this is a manual process and it is
204:04 - really Time to Say Goodbye to clicking
204:06 - around in this unit we'll explore
204:09 - postman's powerful automation tools that
204:12 - will turn you into an API testing
204:14 - Rockstar we are entering the most
204:17 - exciting part of this course where all
204:19 - the effort we have been putting into
204:21 - writing this test pays off so let's Dive
204:24 - In
204:27 - before we jump into automating things we
204:30 - need to make sure that the request as it
204:32 - is right now is working without any
204:34 - issues so what we need to do is to go
204:36 - through every request
204:38 - standard request
204:40 - and check here the test results
204:44 - so we need to do this for every request
204:46 - in this collection because if we have
204:49 - some issues at this point then it
204:51 - doesn't make sense to automate it so we
204:53 - need to check that all the test results
204:55 - are passing
204:58 - now once we have done that this is when
205:00 - we can talk about the Automation and the
205:02 - first tool I wanted to show you is the
205:04 - postman collection Runner so the postman
205:07 - collection Runner is a tool that allows
205:10 - us to run this entire collection with
205:12 - just a single click of a button so just
205:15 - remember all the work that you did for
205:17 - this just a few requests here if you
205:20 - have maybe 20 30 100 requests that you
205:24 - need to send that's a lot of work so we
205:25 - can replace all that with just the click
205:27 - of a button so let me show you how it
205:29 - works and it's super super easy all you
205:31 - have to do is go over our collection
205:33 - until this Ellipsis shows up and from
205:36 - the menu we're gonna select run
205:39 - collection this will open up a new tab
205:42 - and this is the postman collection run
205:44 - so let me briefly explain what we're
205:46 - seeing here
205:48 - on the left hand side here we see a list
205:50 - of all our requests now the way requests
205:54 - are executed in Postman is by the order
205:57 - that we have in the collection so
205:59 - essentially post model will go folder by
206:02 - folder and grab all the requests that
206:04 - are inside there and we'll display them
206:06 - here
206:07 - of course sometimes maybe this is not
206:10 - the way we want to have this but that's
206:12 - not the problem we can easily drag and
206:14 - drop requests anywhere else
206:16 - so we can move requests around if we're
206:19 - not happy with a particular execution
206:20 - order
206:22 - apart from this there can be situations
206:24 - where we say for example register a new
206:27 - client we have already executed that
206:29 - request manually so we don't really want
206:32 - to automate that we can disable that
206:35 - all right so this is the order in which
206:38 - this request will be executed the
206:40 - postman collection Runner will execute
206:42 - this request from top to bottom so it
206:45 - will start with get API status get all
206:47 - products and so on and so forth in this
206:50 - order
206:52 - now on the right hand side we need to
206:54 - choose how we want to run our collection
206:56 - and the first option that is already
206:58 - selected is run manually this is what we
207:00 - want to do
207:02 - apart from this there are also some
207:03 - other settings but they are not relevant
207:05 - at this point so all you need to do is
207:08 - click on this big orange run button and
207:11 - start automating this collection run
207:13 - with just a single click
207:16 - now look at this magic as Postman goes
207:19 - through all this requests that we have
207:22 - and in a matter of essentially second
207:26 - the entire collection has been executed
207:28 - and now we have the results we know what
207:31 - has happened so what has happened we
207:32 - have here all the tests and we see here
207:34 - past 11. so 11 tests have passed none
207:39 - have failed
207:41 - now of course we can find ourselves in a
207:43 - situation where maybe one of the tests
207:45 - is failing
207:47 - of course we know that this API has an
207:49 - issue and if we run this a couple of
207:52 - times one of these schema validations
207:55 - will fail because the idea of the order
207:57 - doesn't match the given pattern
208:00 - if that is the case what we will see
208:02 - here is we have how many have passed and
208:05 - we'll see here failed now generally
208:07 - we're not interested in how many have
208:09 - passed but we're interested in why
208:11 - something has failed so we'll get you
208:13 - information about okay create a new
208:15 - order has failed and we're getting here
208:18 - the reason why this has failed
208:20 - now if you're trying to debug this a bit
208:23 - deeper
208:24 - we'll notice here that the response is
208:27 - not available it says your response body
208:29 - is not available and this is a bit of a
208:30 - bummer because
208:31 - without the response body we can't
208:33 - really understand what has happened but
208:35 - we're also given here information that
208:37 - hey you can change this in the Run
208:39 - configuration right so let's go back to
208:42 - the Run configuration and what has
208:44 - happened this time is that postman has
208:46 - set this flag for us
208:49 - persist responses in a session so by
208:52 - default for performance reasons Postman
208:54 - doesn't save the response body doesn't
208:56 - allow you to take a look at it and see
208:58 - what has happened
208:59 - but if we enable this one it is very
209:02 - powerful because it will allow us to
209:05 - take a look at the response and
209:06 - understand what has happened
209:08 - now there's another setting that I want
209:10 - to show you
209:11 - and this one is the iteration
209:14 - this bug that we're experiencing only
209:16 - occurs from time to time
209:18 - so either we can manually click maybe
209:22 - three four five six times through that
209:25 - run button until the error occurs or we
209:28 - can see from the beginning look just run
209:30 - this 10 times for example and I will
209:32 - take a look and see which of these times
209:35 - didn't work and I can investigate that
209:37 - in particular
209:38 - so let's go ahead and click that run
209:40 - button once again
209:43 - and you can see here Postman is doing
209:45 - the heavy lifting for us everything is
209:47 - in place
209:48 - imagine just the work that would have to
209:51 - do to run this request so many times and
209:54 - inspect all the tests and see if
209:56 - everything is working well
209:58 - okay so in this situation we have
210:01 - executed this so many times nothing has
210:03 - failed so let's try it again
210:06 - and what you will see here is that some
210:08 - of our runs have failed so this is
210:11 - another opportunity to go ahead and
210:12 - investigate what has happened and we're
210:15 - gonna see it is the create new order
210:17 - request that is constantly failing so
210:19 - that's a good thing that there's nothing
210:20 - else that is failing
210:21 - but let's this time take a look and see
210:24 - what is wrong with this now we'll
210:26 - actually have access to the response and
210:28 - we'll see oh look at this character this
210:31 - is not what we expect according to the
210:33 - schema this is why this test is failing
210:36 - so in a nutshell this is how we can use
210:38 - the postman collection Runner to run our
210:42 - collection with a click of a button and
210:44 - then if something fails we can dive into
210:46 - the results and understand what is the
210:49 - reason for the failure
210:54 - using the postman collection Runner is
210:57 - the first step that we need to take just
210:59 - to verify that we can actually automate
211:01 - our collection run so this is going to
211:03 - be probably the first thing that we want
211:05 - to do just to manually run the
211:06 - collection a couple of times to make
211:08 - sure that everything is working fine
211:11 - but this is still a semi-automatic step
211:13 - because we need to open a collection we
211:15 - need to go inside it we need to open the
211:17 - postman collection Runner we need to
211:18 - click that button we need to inspect the
211:20 - results and everything
211:22 - now there is also the possibility in
211:24 - Postman of scheduling a run so
211:27 - essentially when scheduling a run we are
211:30 - no longer executing the postman
211:32 - collection on our personal computer
211:33 - we're not using Postman at all
211:37 - instead the execution takes place on the
211:39 - postman cloud
211:41 - so there's no need to keep a postman
211:43 - open or even our computer can be turned
211:45 - off during this process so this is
211:48 - essentially a fully automated collection
211:50 - run
211:51 - in order to schedule a run all you have
211:53 - to do is hover over the collection click
211:56 - on the Ellipsis and from the context
211:58 - menu we're gonna select run collection
212:01 - by default we have here run manually but
212:04 - just as well we can select the option
212:06 - schedule runs
212:09 - so when we are scheduling a run we are
212:11 - taking our collection and running it in
212:14 - the postman cloud
212:16 - in this case we can also decide which is
212:19 - the order in which we want to execute
212:20 - this request or if there are any
212:22 - requests that we would like to disable
212:24 - like registering a new client
212:27 - apart from this on the lower part there
212:30 - are also a few things that we need to
212:31 - configure we should give this schedule a
212:34 - name for example if you wanna run this
212:37 - once per week or once per day we can
212:40 - decide this here just going to give it a
212:42 - name weekly API test
212:45 - and then we can select the Run frequency
212:47 - and this can be like every hour every
212:50 - week every day and so on
212:53 - in this case
212:54 - we are on the week timer
212:56 - so we can decide we want to run it every
212:59 - day or we want to run it every weekday
213:01 - because if it fails on a Sunday and
213:04 - nobody is going to be in the office to
213:05 - take a look at the results or maybe we
213:08 - can decide just to run this once per
213:10 - week let's say that we want to run it
213:13 - every weekday and we're gonna decide
213:15 - when do we want to run it probably early
213:17 - in the morning would be a good choice
213:19 - apart from this we can also get email
213:22 - notifications and you can also add other
213:24 - people there
213:25 - is also some advanced settings that you
213:28 - may want to look into but they're not
213:30 - relevant for what we're trying to do
213:31 - right now
213:33 - let's go ahead and click on schedule run
213:36 - so in this case we're going to get
213:37 - information about when is this run
213:41 - scheduled
213:42 - scheduling is a good way to keep an eye
213:46 - on an already deployed API to see if it
213:49 - is still working as expected in other
213:51 - words we are monitoring the API if there
213:55 - are any issues this will be reported and
213:58 - will get a notification
213:59 - running this at regular intervals also
214:03 - allows us to understand the time frame
214:05 - when a problem occurred if one occurs
214:08 - now of course we have the option of
214:10 - waiting until this collection will be
214:14 - automatically executed
214:16 - just to make sure that you know
214:17 - everything is working fine in theory
214:19 - before we wait for the first run we can
214:22 - manually click on run now but if we
214:25 - don't do this
214:26 - Postman will do this for us from the
214:28 - cloud so when we're clicking here on a
214:30 - run now this is not the same as manually
214:32 - running the collection on our own
214:34 - computer now we are using the postman
214:36 - Cloud to run this collection
214:39 - now instantly we're gonna get some
214:41 - information here we're gonna get
214:42 - information that this is unhealthy so
214:45 - there's some problems with this API
214:48 - and apart from this we're gonna see here
214:50 - how many tests have failed and what is
214:53 - going on and why these tests have failed
214:56 - now we can notice here a few things for
214:58 - example get API status seems to be
215:01 - working fine getting all products get
215:03 - single products everything works well
215:05 - until we start working with requests
215:07 - that have authentication we're gonna get
215:10 - here the status 403 Forbidden
215:13 - now this can be a bit confusing because
215:16 - we have executed this collection locally
215:19 - and it worked without any issues so why
215:21 - is this failing now well the thing is
215:24 - the following you need to remember that
215:26 - inside our collection we have stored a
215:29 - secret so if we go inside the collection
215:31 - and edit it
215:33 - and jump to the variables we're gonna
215:36 - see here that we have some secrets we
215:38 - have this API key
215:41 - now the current value this is what we
215:44 - have here on our computer
215:47 - however when we're sharing this
215:49 - collection and in this case we're also
215:51 - sharing our collection with the postman
215:53 - cloud
215:55 - Postman
215:56 - from the cloud only has access to this
215:58 - information
215:59 - and as you can notice here we don't have
216:02 - a valid API key
216:04 - now we can change our workflow in a way
216:06 - that this information is available so
216:09 - that we generate an API key when we're
216:11 - running this flow or what's a bit
216:14 - quicker in our situation we can simply
216:16 - go ahead and take this from the current
216:19 - value
216:20 - and put it here in the initial value
216:23 - now you need to be very careful with
216:25 - this because remember this workspace is
216:28 - public
216:29 - anything that is in the initial value is
216:31 - public
216:32 - for this particular collection this API
216:35 - key is Not So problematic but you may
216:39 - find yourself in a different setting and
216:42 - in that case exposing this API key as an
216:45 - initial value may not be such a good
216:47 - idea
216:48 - but typically when you're trying to run
216:50 - a collection
216:52 - and you're having authentication issues
216:54 - when using a schedule run
216:56 - but the exact same run is working
216:58 - without any problems when you're using
217:00 - the manual run install Postman
217:02 - probably 99 of the cases this is related
217:05 - to postman variables
217:08 - so remember the postman cloud is only
217:11 - using this initial value doesn't have
217:14 - access to the current value
217:15 - so this is just a small hack to ensure
217:18 - that this is not working properly
217:21 - so let's go ahead over the collection
217:25 - and we can open here the tab runs
217:29 - and we can see here that we have
217:31 - scheduled runs
217:33 - so this is our schedule here
217:36 - and we can click on view to go back to
217:38 - the previous View that we had
217:41 - so all we have to do now is Click again
217:43 - on run
217:46 - wait a few seconds
217:50 - and we'll see now that our API is
217:53 - healthy meaning everything that we have
217:56 - inside our collection is working as
217:57 - expected well the requests are working
217:59 - as expected all the tests are working as
218:02 - expected there are no script errors or
218:04 - anything like that
218:06 - of course we can also go into the
218:08 - details and see the test results and see
218:10 - which tests have been executed and the
218:13 - fact that they have passed but this is
218:14 - less relevant also have access to the
218:17 - console log and see if there's any
218:19 - details here that might interest us
218:22 - but apart from this there's nothing else
218:24 - that we need to do here so typically we
218:27 - are going here when something doesn't
218:28 - work anymore when we get an alert that
218:30 - our API has issues now this tool can be
218:34 - very valuable for verifying that your
218:37 - public API operates as intended
218:40 - particularly in relation to
218:41 - configuration updates or recent
218:43 - deployments so it's just a good idea if
218:45 - you're having a public API to schedule
218:48 - one of these runs and let it run at a
218:50 - regular interval so that you get
218:52 - information about this if something goes
218:54 - wrong you will be notified
218:57 - now pre-production environments are
218:59 - usually not publicly accessible which
219:02 - somehow restricts the usage of this
219:04 - feature professional and Enterprise
219:07 - plans provide access to a static IP
219:10 - address that can be configured as a
219:12 - firewall exception but that's a separate
219:15 - conversation on its own
219:17 - now once you have understood how this
219:19 - scheduled runs work it is also best once
219:23 - you don't need them anymore to simply
219:25 - delete them so all you have to do is
219:27 - again go here inside the collection go
219:30 - to the runs tab
219:32 - and then all you have to do is hover
219:34 - over the scheduled run that you have
219:37 - click on the Ellipsis and either pause
219:39 - it or delete it all together
219:42 - so in a nutshell scheduling a run
219:44 - essentially creates a monitor which runs
219:47 - at a predefined interval and keeps an
219:50 - eye on your API and ensure that it's
219:52 - still working properly
219:59 - in this lecture I will introduce you to
220:01 - the postman CLI a tool that runs a
220:03 - postman collection using the command
220:05 - line we'll learn its Basics setup and
220:09 - how to use it for a more efficient API
220:11 - testing process
220:13 - in order to get started with a postman
220:14 - CLI again we're gonna hover over the
220:17 - collection until this Ellipsis shows up
220:19 - and select run collection
220:22 - from the options available here this
220:24 - time we're gonna select here automate
220:26 - runs via CLI
220:29 - once we do this we're gonna get
220:31 - instructions on how to use Postman CLI
220:33 - to run this collection but first of all
220:36 - we need to install
220:37 - so let's go ahead and download Postman
220:40 - CLI
220:42 - to install Postman CLI we need to follow
220:44 - a few steps
220:46 - I'm going to demonstrate this process in
220:48 - Windows because most of you are using
220:50 - Windows but it works in a similar way
220:52 - for Mac OS and Linux
220:56 - first of all you need to open a terminal
220:58 - window if you never did this before
221:00 - that's absolutely fine
221:02 - simply search for a program called
221:04 - Powershell
221:06 - if you are on a Mac you need to search
221:08 - for a program called terminal
221:11 - and if you're on a Linux you're probably
221:13 - done with installing this by now anyway
221:15 - let's go back to Windows you will see
221:18 - this window where you can type in
221:20 - commands
221:21 - let me make this a bit bigger for you
221:24 - now if we're going back to the
221:25 - documentation
221:26 - we'll see here that we have installation
221:29 - instructions for Windows Mac
221:32 - and Linux
221:34 - so for every operating system there is a
221:36 - different command so for Windows all you
221:39 - have to do is copy this command
221:42 - if you have a newer Mac you probably
221:45 - have the newer CPU for Mac so you may
221:47 - want to use this first command if your
221:50 - Mac is a bit older you use this one
221:53 - and for Linux you have this command at
221:55 - the end so I'm going to copy this one
221:57 - for Windows
221:59 - and we'll have to paste it in the
222:00 - terminal window that we have open
222:03 - you can use your keyboard shortcuts or
222:06 - simply click on the window bar and use
222:08 - the context menu to paste
222:10 - after this the command will show up and
222:13 - you need to press the enter key to
222:15 - execute the command
222:16 - the installation should only take a few
222:19 - minutes
222:20 - to ensure that the installation has been
222:22 - successful we need to type in the
222:25 - following command
222:26 - Postman
222:28 - space
222:29 - minus V
222:31 - and this will print out the current
222:33 - Postman version
222:35 - now when you're seeing this process and
222:37 - all these weird commands you're probably
222:40 - like are you sure is this a good idea I
222:43 - mean why do we need this can we go back
222:45 - to this nice Postman interface that we
222:47 - had before
222:48 - and I can totally understand
222:50 - a command line interface tool CLI tool
222:54 - is invaluable for streamlining the
222:57 - testing process as it allows for
222:59 - automation easy integration with
223:01 - continuous integration and continuous
223:03 - deployment pipelines and overall a
223:06 - faster execution
223:07 - apart from this we can also run a
223:09 - postman collection on our own
223:11 - infrastructure without using the posting
223:14 - cloud
223:15 - let me put this plainly if we want to
223:17 - let the computer run our Postman
223:19 - collection without our human
223:21 - intervention we need to use a CLI tool
223:24 - if we wish to run Postman tests in a CI
223:27 - CD server like Jenkins GitHub actions or
223:30 - gitlab we need to use a CLI tool we
223:33 - cannot use the graphical interface from
223:35 - Postman
223:41 - so let's jump back into Postman and try
223:44 - to run our collection using the postman
223:46 - CLI
223:47 - now if we're looking here on the lower
223:49 - part we're gonna get here instructions
223:51 - about some commands we need to run and
223:54 - they're essentially to command one of
223:55 - them is Postman login
223:57 - and the other one is a command that will
224:00 - actually run the collection
224:02 - now let's just copy the last command
224:04 - that you see here
224:06 - jumping into the terminal I'm gonna
224:08 - paste it
224:09 - and what we're gonna get here is an
224:12 - error it's going to tell us that no
224:15 - authorization data was found and that we
224:18 - need to use the postman login command
224:20 - now whenever you're getting errors when
224:22 - using these tli tools
224:24 - it's important not to just panic because
224:26 - there is an error but just take a bit
224:28 - the time to read line by line understand
224:31 - what has happened you have executed a
224:34 - command and then the tool is telling you
224:36 - no authorization data was found and
224:38 - sometimes these tools teacher to be
224:40 - helpful in telling you hey you need to
224:41 - use Postman login
224:43 - so obviously we have missed something
224:44 - here we first need to run the First
224:46 - Command which is Postman login okay how
224:49 - do we run this let's copy this command
224:51 - here
224:52 - and we're going to paste it again and
224:55 - again we're gonna get an error now when
224:57 - we're trying to log in with an API key
224:59 - in this case we actually need to provide
225:02 - that API key
225:03 - and the graphical interface here is
225:06 - trying to help us you like you don't
225:07 - have an API key let's how about you add
225:09 - one here so we're going to click here on
225:11 - ADD API key
225:12 - and we can either use an existing key
225:14 - that we have or we can simply click here
225:16 - on generate key
225:18 - we can call this key Postman CLI so that
225:21 - we know what we have created it
225:23 - and click on generate
225:26 - okay no spaces are allowed let's put
225:28 - this together
225:30 - and now we have a key and we can click
225:33 - here on insert key
225:35 - so this key then will be part of this
225:37 - command here so all we need to do then
225:39 - is to copy this entire command
225:42 - go back here and paste it
225:44 - so the First Command will log us in
225:47 - and the second command will execute the
225:49 - postman collection so let's see how this
225:51 - will go
225:54 - so we're gonna see here a few issues
225:58 - but first of all we have been logged in
226:00 - successfully and then we can actually
226:02 - see our API here but then we're getting
226:05 - some errors here now the first error is
226:08 - a type error and we're going to take a
226:10 - look at the logs to understand what is
226:12 - going on and the second one is coming
226:14 - here from the orders and this is
226:16 - probably the schema that has failed in
226:17 - the past so that's nothing to worry
226:19 - about so the first error is actually
226:21 - complaining that in the get API status
226:23 - request we have this console clear
226:25 - function so it's telling us this is not
226:27 - a function so obviously Postman CLI
226:30 - doesn't know about console.clear or
226:32 - doesn't make sense to have a console got
226:34 - clear in this context so we need to
226:36 - figure out a way around that
226:38 - and the second assertion error is that
226:40 - schema is valid but apart from this this
226:44 - is how we can run a collection using
226:46 - Postman CLI and we can take a look here
226:49 - and see all the requests that have been
226:51 - executed we'll have here essentially a
226:53 - report at the end so we know how many
226:55 - requests have failed how many requests
226:57 - are still working and so on
226:59 - let's jump back into Postman and try to
227:01 - fix this console.clearprom
227:04 - so what we can do here in the status
227:06 - request get API status
227:09 - and in a prequest script you see here we
227:12 - have console.clear
227:14 - so what we could do here is we could add
227:16 - an if statement so if console.clear
227:19 - without actually calling it
227:22 - and we're going to move the statement
227:23 - inside here
227:25 - we can quickly verify if the console is
227:27 - still being cleared let's send this
227:29 - request
227:30 - so we see console was cleared we have
227:33 - saved this request
227:35 - and then if we need to run this once
227:37 - again all we need is the second command
227:40 - because postman has logged us in
227:44 - so when we're trying to run any other
227:46 - commands here we don't need to log in
227:48 - once again because we are already logged
227:50 - in
227:50 - so all we need to do is use this command
227:53 - Postman collection run and this thing
227:55 - that we see here this is actually the
227:57 - internal ID of the collection this is
228:00 - how Postman identifies our collection
228:04 - and now we have apparently got rid of
228:07 - that issue with console.clear and we
228:10 - still have this problem with the schema
228:12 - is valid
228:13 - now apart from this we're also getting
228:15 - information that this execution has been
228:18 - uploaded to the postman cloud
228:21 - so what does that mean well it means
228:23 - that we can see this detail inside
228:24 - Postman let me show you
228:27 - go back to postman
228:29 - and click on our collection
228:32 - we're gonna see here the Run step
228:35 - and what we'll be able to see here are
228:37 - test runs and we have here the source so
228:41 - we have here the source being Postman
228:43 - CLI or Runner which means the manual run
228:45 - that we have used and we can also dig
228:48 - here into the results and see what is
228:50 - going on
228:51 - for example we're gonna click here on
228:54 - this icon to view the report
228:56 - and we can take a look and see what
228:58 - exactly has failed and hopefully what is
229:02 - the reason for this and of course if you
229:04 - need to troubleshoot this we can go back
229:06 - to either running the request manually
229:08 - in Postman or using the manual
229:11 - collection Runner to run this collection
229:14 - from the beginning to see if whatever
229:15 - error we have encountered is still
229:17 - occurring now as you can see the
229:19 - response body is also not available so
229:21 - this is something that we need to change
229:22 - in the Run configuration but for Postman
229:26 - cli's this is not something that we can
229:29 - do at this moment so this is why we need
229:33 - to run this manually to see if we can
229:34 - replicate that specific issue
229:41 - when you're using the postman CLI to run
229:43 - a postman collection that actually a lot
229:46 - of things that you can configure that
229:48 - are not visible here directly in post
229:51 - now to understand how you can use
229:53 - Postman CLI like like a pro it is
229:56 - important to spend a bit of time and go
229:58 - over the postman CLI documentation and
230:01 - its command options essentially whenever
230:04 - we're running a command like Postman
230:06 - collection run
230:08 - we can also specify some additional
230:10 - options that change the behavior of this
230:12 - command
230:13 - now there are a lot of options here and
230:16 - I highly recommend going over them and
230:18 - seeing if you may want to use them
230:21 - sometime in the future at least to note
230:23 - that they are available and that this is
230:25 - possible
230:26 - however there is something that I wanted
230:27 - to show you just to give you an idea on
230:29 - how we can use this
230:31 - let's say that in our collection run
230:34 - we only want to run a specific folder
230:37 - and for this we can use this option
230:40 - minus I and specify the folder name
230:44 - let me show you how it works
230:47 - all I have to do is go back to postman
230:49 - and let's just copy again only the
230:52 - command that runs the entire collection
230:56 - in Postman CLI I'm going to go ahead and
230:58 - paste this
230:59 - and after this I'm going to add here
231:01 - space then minus I
231:04 - and then between quotes
231:06 - I'm going to put here a name of the
231:08 - folder that I want to execute
231:10 - for the sake of this let's just say I
231:12 - want to execute status so only the
231:15 - requests that are inside status I want
231:16 - to execute them
231:18 - I'm going to write inside here status
231:21 - let's go ahead and run this
231:24 - and what you will see this time is that
231:26 - only one request has been executed
231:29 - because now with this additional option
231:32 - we have configured the way this
231:34 - collection run functions so only one
231:37 - request has been executed and this is
231:39 - sometimes very powerful because we can
231:41 - decide to run only a couple of folders
231:43 - so for example if you need to run only
231:45 - three folders from a collection then you
231:47 - can just use minus I the name of a
231:50 - folder and then after this also the
231:52 - other folders Let me Give an example
231:54 - let's say one run status and then
231:57 - there's another folder that way we want
231:59 - to use products
232:01 - I'm gonna write here product as well
232:04 - and you will see here that only status
232:07 - and products as folders have been
232:09 - executed
232:11 - again it's super important that you go
232:13 - over the documentation and understand
232:15 - what these options do and how you can
232:18 - use them
232:24 - welcome to the last level of our API
232:26 - automation testing game in this unit
232:29 - we'll be tackling the integration of
232:31 - Postman tests in cicd in the upcoming
232:34 - lessons my goal is to help you
232:36 - understand why this is important and how
232:39 - to do it integrating Postman API tests
232:42 - in a cicd pipeline is essential because
232:44 - it automates the testing process
232:46 - ensuring that apis are continuously
232:49 - validated and function as expected
232:52 - during development and deployment let me
232:56 - put this in simpler terms where
232:58 - basically firing ourselves from the
233:01 - testing department and letting computers
233:03 - take over while we still keep a watchful
233:07 - eye to make sure nothing goes Haywire we
233:10 - will kick things off by discussing the
233:12 - fundamentals of cicd and the importance
233:15 - it holds in our testing process next
233:18 - we'll embark on a step-by-step journey
233:21 - to run Postman tests using GitHub action
233:24 - one of the leading cicd tools out there
233:27 - if you are using a different CI CD
233:29 - Solution that's also fine I will provide
233:32 - you with some guidance on how to get
233:34 - started with other tools as well apart
233:36 - from this we will talk about Postman
233:38 - workspaces reports and effective
233:42 - collaboration techniques within your
233:44 - team if you have been following Along on
233:46 - this Grand Adventure give yourself a
233:49 - hearty pad on the back this is the fun
233:51 - part so grab your gear and let's Dive In
233:56 - let's talk about cicd for a second
233:59 - the ICD stands for continuous
234:02 - integration and continuous deployment
234:06 - it is a practice used in software
234:08 - development to make the process faster
234:11 - and more reliable
234:14 - with continuous integration every time a
234:17 - developer changes the software those
234:20 - changes are tested automatically this
234:23 - helps catch any problems early in the
234:25 - process
234:27 - once the CI pipeline is done we start
234:30 - the CD pipeline where we typically
234:32 - deploy the software to a test
234:34 - environment which allows us to do
234:36 - further tests
234:38 - if all tests pass the changes are
234:41 - automatically deployed to the production
234:43 - environment and go live
234:46 - this practice allows for improvements
234:49 - that can be made quickly without having
234:51 - to wait for a big update
234:54 - this process helps teams work together
234:56 - more efficiently
234:58 - and it makes easier to keep the software
235:00 - running smoothly
235:02 - now what does this have to do with
235:04 - Postman tests and automation well the
235:08 - thing is if we're working on an API
235:11 - using CI CD it makes absolute sense
235:15 - and we also want to integrate our
235:17 - Postman API test in the CI CD pipeline
235:22 - there are at least two steps in the
235:24 - process where it makes sense to run
235:26 - Postman tests
235:27 - after deploying the API to a
235:30 - pre-production environment such as a
235:32 - test environment and after deploying to
235:34 - the production environment
235:36 - using the postman CLI allows us to run a
235:39 - postman collection and the associated
235:42 - tests in our continuous deployment
235:43 - pipeline without us manually triggering
235:47 - a run
235:52 - let's talk for a second about the ICD
235:55 - providers using a CI CD tool allows us
235:58 - to automate the process of integrating
236:00 - code changes testing and deploying
236:03 - applications making our lives easier now
236:06 - it is important to understand that there
236:08 - isn't a single best tool for CI CD the
236:11 - best tool for you will depend on your
236:13 - specific needs your team's familiarity
236:16 - with the tool and the specific
236:18 - requirements of your project your
236:20 - organization may already use a tool so
236:23 - you could be forced to use whatever
236:25 - option is available anyway
236:27 - some popular solutions for cicd include
236:30 - Jenkins gitlab
236:32 - Circle CI and GitHub actions among
236:36 - others in the upcoming lesson I'm going
236:39 - to show you how to use Postman CLI to
236:41 - run a collection in GitHub actions
236:44 - now I want to make it clear that this
236:46 - isn't intended as an introduction to
236:49 - GitHub action we're focusing here on how
236:52 - to use Postman CLI within the context of
236:55 - GitHub actions if you are not familiar
236:57 - with GitHub actions that is absolutely
236:59 - fine I will take you through the process
237:02 - step by step
237:03 - now you might be using a different CI CD
237:06 - tool and that's perfectly fine the
237:09 - beauty of Postman CLI is that once you
237:12 - understand how to use it integrating it
237:15 - in any cicd server is relatively
237:18 - straightforward the principles we'll
237:21 - cover here can be applied to other cicd
237:24 - tools as well
237:26 - before we start you will need to sign up
237:28 - for a free GitHub account if you don't
237:31 - already have one GitHub actions is a
237:34 - feature of GitHub so you need to have an
237:37 - account to be able to use it signing up
237:40 - is relatively easy and quick and it will
237:43 - give you access to a wide range of tools
237:45 - and resources Beyond just GitHub actions
237:53 - so let's go ahead and run bothman API
237:56 - test with GitHub actions for that we're
237:58 - gonna need a GitHub repository so let's
238:01 - go ahead and create a new repository I'm
238:03 - gonna name the repository my API project
238:06 - and also want to make sure that this
238:08 - repository is public
238:11 - let's go ahead and click on create
238:13 - Repository
238:15 - in order to configure a pipeline with
238:17 - GitHub actions we need to go here from
238:20 - the project page to actions
238:23 - and we're going to set up a workflow
238:25 - ourselves essentially a workflow is
238:27 - something that we want to execute with
238:29 - the help of GitHub action
238:31 - I'm going to call this workflow Postman
238:35 - and here we will have to put in the
238:37 - configuration that is needed to run our
238:40 - Postman collection using Postman CLI now
238:43 - luckily we don't have to write
238:45 - everything from scratch but we have
238:47 - postpon on our site to help us with this
238:49 - process
238:51 - so what I'm going to do next is I'm
238:53 - going to jump here inside Postman
238:56 - hover over the collection and select a
238:59 - run collection from the option
239:02 - then gonna go to automate runs via CLI
239:06 - and what you will notice here on the
239:08 - lower part of the screen is run in CI CD
239:12 - a little bit hidden and I wouldn't be
239:14 - surprised if you missed this before so
239:16 - let's go ahead and click on configure
239:18 - command
239:19 - because with this tool here we'll be
239:21 - able to configure our pipeline in just a
239:24 - few seconds
239:25 - so first of all we want to make sure
239:26 - that we have the right collection here
239:28 - and then from the list of cicd providers
239:31 - we're gonna select GitHub action
239:35 - and what we'll see here is the command
239:37 - that we need to execute
239:39 - so let's go ahead and copy this command
239:41 - I'm gonna jump back to GitHub actions
239:44 - and here in this window
239:46 - I'm gonna paste this
239:48 - now this is a git repository so we need
239:50 - to commit these changes
239:52 - and we can just go with the defaults
239:54 - here and click on Commit
239:56 - so now our project contains
239:59 - a folder which is dot GitHub forward
240:01 - slash workflows
240:03 - and inside here we have our
240:05 - configuration file and this should run
240:07 - our Postman collection
240:10 - if you want to see what exactly is
240:11 - happening we can click here on view runs
240:14 - or you can simply go here to actions
240:17 - now if we take a look at one of these
240:19 - workflow runs here
240:21 - we're able to see if they were
240:22 - successful or not
240:24 - so in essence we have here
240:26 - a job which is called automated API test
240:29 - we can go on it and we'll see it is red
240:31 - so it's already not looking good
240:33 - but when something doesn't work it is
240:35 - important to understand what has
240:37 - happened
240:38 - so you'll see here there are various
240:39 - steps that are happening I don't know
240:41 - setting up the job running something and
240:43 - then this is the part that is
240:44 - interesting for us it is installing
240:46 - Postman CLI because it is not installed
240:48 - so you'll see here okay Postman CLI has
240:51 - been installed this work without any
240:53 - issues
240:54 - and it is trying to log into Postman CLI
240:57 - and it's going to tell us hey there's
240:59 - some argument missing here
241:01 - so again we haven't specified the API
241:04 - key and what we definitely don't want to
241:06 - do is to put that API key inside our
241:10 - code so we're not going to put any keys
241:12 - in our configuration
241:14 - so how can we handle this well if we're
241:16 - looking back at the configuration we're
241:18 - going to see here that there is
241:21 - something that is referencing an API key
241:24 - so let's open up here postman.yamu
241:27 - and what you're going to see here is
241:28 - something with secrets that Postman
241:30 - underscore API underscore key
241:34 - every CI CD system out there will allow
241:37 - you to store some secrets so let's go
241:40 - ahead and do exactly that I'm going to
241:41 - copy here Postman underscore API
241:44 - underscore key and go to settings for
241:46 - this project
241:48 - and then under security here
241:50 - you should see secrets and variables
241:55 - we're gonna select from the list actions
241:58 - and this allows us to define a new
242:00 - repository Secret
242:02 - so let's go ahead and click on new
242:03 - repository stick wrap we're gonna give
242:06 - it this name that we have just copied
242:08 - from the pipeline
242:10 - then from Postman we need a secret key
242:15 - so from here from Postman we can see
242:17 - here again the option of generating an
242:19 - API key
242:21 - and this time we're gonna write here
242:22 - GitHub action
242:24 - and this is very helpful because then we
242:26 - know that this API key is associated
242:28 - with GitHub actions so you can simply go
242:31 - ahead and copy this entire thing
242:34 - and paste it here and then click on ADD
242:37 - Secret
242:38 - now I'm showing this openly because I'm
242:41 - going to revoke these secrets later on
242:42 - just in case you're wondering but I want
242:45 - you to understand exactly how this
242:47 - process works and how these secrets look
242:49 - like it's also important that you name
242:51 - them exactly as you see and that you
242:53 - don't add any spaces or any other
242:55 - characters new line and things like that
242:57 - to them otherwise they tend not work so
242:59 - well
243:00 - let's go back to actions here
243:03 - and we can take a look at one of these
243:06 - runs that has failed here and we can
243:08 - simply click on this button rerun jobs
243:11 - this will essentially restart this job
243:16 - so now the job has started
243:19 - and we can even click on it to see what
243:21 - is it doing
243:23 - and we can see the installation part is
243:25 - done
243:26 - it has logged in into the postman CLI
243:29 - so we have that information there
243:31 - and then now we're running some API
243:33 - tests
243:35 - and we can see here what is going on
243:36 - with API tests
243:38 - and we have the exact same report that
243:41 - we see when we're running Postman CLI
243:43 - locally but this time it is running in
243:46 - the cloud
243:47 - now whenever something goes wrong with
243:49 - this you need to determine is this
243:52 - because there was an issue executing the
243:54 - postman collection so essentially a
243:56 - postman test has failed or is it a
243:59 - problem with a script that we have
244:01 - written
244:02 - in any case it is important to have the
244:05 - patience to go over the logs and
244:07 - understand what has happened if there
244:09 - are some errors it's important to
244:10 - understand if there are any hints or any
244:12 - information here in this log so don't
244:14 - get scared that you see some failures
244:15 - here that's absolutely normal actually
244:17 - you want to make sure that whatever
244:18 - we're doing here actually fails if they
244:21 - need to fail
244:23 - just as running Postman CLI locally when
244:26 - we're running Postman CLI with the help
244:28 - of a cicd provider like GitHub actions
244:30 - the results of this execution will be
244:33 - published to postman so you can go back
244:35 - inside Postman
244:37 - and if we close the steps and click on
244:39 - the collection name itself we'll see
244:40 - here runs
244:42 - and this time we're going to see again
244:44 - information about the one that just
244:46 - happened there are also additional
244:48 - information here so you can see here
244:50 - this is the second build this is being
244:52 - linked actually to GitHub action so we
244:54 - can click on it and see more details
244:57 - about this what has happened why
244:58 - something has failed
245:00 - but just as well we can also visualize
245:04 - the results that we have from within
245:06 - Postman
245:11 - I hope you have managed to follow along
245:13 - because now it's time for another
245:15 - assignment
245:17 - it is super important that you
245:18 - understand how to use Postman CLI and if
245:21 - you manage to run the API test with the
245:23 - help of GitHub actions then essentially
245:25 - your job is done if you haven't done
245:28 - that please go to the previous lecture
245:30 - and tried it once again because for this
245:32 - assignment you will need your GitHub
245:34 - repository and you need to submit your
245:36 - guitar repository in order to be able to
245:39 - complete this final assignment anyway go
245:42 - to the original Postman workspace work
245:45 - the assignment number five and follow
245:47 - all the details that you will find
245:49 - inside there
245:54 - if you are not using GitHub actions that
245:57 - is also absolutely fine
245:59 - you can run Postman CLI in virtually any
246:02 - CI CD system out there however for the
246:05 - most popular ones Postman makes your
246:07 - life a bit easier so when you're going
246:10 - here over your collection and selecting
246:12 - a run collection
246:13 - then automating via CLI and then under
246:17 - run on cicd you click on configure
246:19 - command
246:20 - what you will see here are different
246:22 - cicd providers that you can use so you
246:25 - have bit pocket pipelines Circle CI
246:27 - gitlab Jenkins Azure pipelines Travis CI
246:32 - and probably many others in the near
246:33 - future
246:35 - apart from this you can also go and
246:37 - select the operating system where this
246:40 - provider is running so if there are any
246:42 - particularities if you know that this is
246:44 - running for example on Windows then you
246:46 - can also select the operating system
246:48 - there and what you will be given here is
246:50 - the configuration that you can use to
246:53 - get started with this and this of course
246:55 - changes depending on the provider but
246:58 - for most situations this is just enough
247:00 - to get started just enough to see that
247:02 - these tests are executing in your cicd
247:04 - pipeline and then you can make
247:06 - improvements based upon this but in a
247:09 - nutshell what you need to do is you need
247:11 - to ensure that Postman CLI is installed
247:13 - you need to make sure that you are all
247:16 - dedicated and that you don't expose your
247:18 - API credentials anywhere in the pipeline
247:21 - configuration
247:22 - and then you need to run the postman
247:24 - collection run command specifying the ID
247:27 - of your collection
247:28 - and after this the results of this
247:31 - execution will be displayed in your CI
247:33 - CD system and will also be ingested into
247:35 - Postman so that you can see the reports
247:37 - from the collection itself
247:43 - Postman is all about collaboration most
247:46 - of the time when you're using Postman
247:48 - you want to collaborate with other
247:49 - people in your team
247:51 - for that you need a team and you need to
247:54 - use team workspace
247:56 - so not to create a team workspace all
247:58 - you have to do is go here to workspaces
248:00 - and click on create workspace
248:03 - next if it's not already selected you
248:05 - need to select your team
248:07 - let's call this workspace my
248:10 - API
248:12 - my account doesn't have a team so a team
248:15 - will be created as well
248:18 - so let's go ahead and go directly to the
248:21 - workspace
248:23 - and let's see what we can do here
248:26 - team workspaces allow you to collaborate
248:29 - on a collection
248:30 - you can create Forks
248:33 - essentially which are a copy of a
248:35 - collection
248:37 - when you're working on a collection and
248:40 - making changes of course you can also
248:41 - collaborate with others and comment and
248:44 - have conversations with others within
248:46 - your team to understand why some changes
248:48 - are made or why maybe something isn't
248:50 - working as expected
248:52 - and you're also able to track everything
248:54 - that is going on within your collection
248:56 - knowing exactly who has made which
248:58 - changes and most importantly why
249:02 - when you're working with many many apis
249:04 - it's also super helpful to be able to
249:06 - search around and to find what you're
249:08 - looking for
249:10 - okay so let's go ahead and see exactly
249:12 - how we can benefit from this team
249:15 - workspaces and especially how we can
249:17 - benefit from working Collections and
249:19 - merging changes into them so let's go
249:22 - ahead and switch back to our Dark theme
249:27 - and I'm going to make this a bit bigger
249:28 - for you so that you can properly see
249:29 - we're gonna go ahead and create a new
249:32 - collection and I'm going to call this
249:33 - collection Postman Echo
249:36 - but let's imagine that we want to
249:37 - collaborate on this collection but we
249:40 - don't want to make changes directly to
249:42 - the collection in that case what we can
249:45 - do is hover over the collection until
249:47 - this menu pops up
249:48 - and then we can select create Fork so
249:52 - then we're creating a fork of this
249:54 - particular collection but receiving it
249:57 - in the same workspace so this will be my
250:00 - Fork we can give it any other label for
250:02 - example we can call it new request
250:05 - because let's say we want to work on a
250:07 - new request we're gonna Fork this
250:09 - collection we're gonna have an exact
250:10 - copy of this collection
250:12 - and in this new collection we can go
250:15 - ahead and add a request
250:16 - and let's say for example we want to add
250:18 - a request to the following endpoints so
250:21 - we're going to use Postman Dash
250:24 - echo.com forward slash get this will be
250:28 - a very simple request against this API
250:31 - which is provided by Postman and we're
250:33 - gonna get here some information back not
250:35 - so relevant just gonna go ahead and save
250:37 - this and close this so our original
250:40 - collection doesn't have any request now
250:43 - we have added a request here just want
250:46 - to test it a bit to make sure it works
250:47 - then we'll say okay now we want to
250:49 - integrate these changes back into the
250:51 - previous collection because we know that
250:53 - everything will be done here adding The
250:55 - Collection maybe writing some tests and
250:56 - other script everything works as
250:58 - expected what we can do is we're gonna
251:01 - go over our fork and from the context
251:03 - menu
251:04 - we can do two things we can create a
251:07 - pull request which essentially is a
251:10 - request for merging these changes back
251:12 - into original collection or simply
251:15 - merging the changes
251:17 - now of course this depends on the
251:18 - permissions that you have sometimes you
251:20 - can merge changes but sometimes you can
251:22 - only create a pull request so let's go
251:24 - ahead and do that
251:25 - so it's a pull request we have to
251:27 - provide here some information like why
251:30 - are we making these changes to the
251:32 - collection so for example you can say
251:33 - that a title is added request and we can
251:36 - provide here a description like we have
251:37 - added another request which is necessary
251:40 - for whatever project we're working on we
251:42 - can also add here reviewers from our
251:45 - team and then we can go ahead and create
251:47 - that pull request
251:49 - so we can see here a few things so we'll
251:52 - be able to see exactly what has been
251:54 - added
251:55 - so we'll see it's a new request it is
251:57 - with the method get and this is the URL
252:00 - where this request is going so here you
252:02 - will be given an overview of everything
252:04 - that has changed in that collection
252:07 - and it's important to notice here that
252:09 - we are having this particular source
252:11 - with a label that we have specified and
252:14 - we want to integrate these changes in
252:16 - the original collection so this is the
252:18 - original collection this is the one that
252:20 - we have for
252:22 - now depending on how things are
252:24 - configured we may or may not have the
252:28 - permission to merge
252:29 - in this case we do have the permission
252:31 - to merge so this merge pattern appears
252:33 - here so we're gonna go ahead and click
252:35 - on it and here there are various options
252:37 - that we can consider essentially once we
252:41 - merge these changes we don't need the
252:43 - copy that we have made the one with the
252:45 - label so in this case I'm going to
252:47 - select the merge changes and delete
252:49 - Source but you can just go ahead and
252:52 - click on merge changes and manually
252:53 - delete it later on if you feel more
252:55 - comfortable so let's go ahead and click
252:57 - on merge
252:58 - so the pull request has been merged
253:01 - so the changes that we have proposed are
253:03 - now inside this collection
253:07 - in a nutshell this is a very simple
253:08 - workflow that you and your team can use
253:10 - when working on a postman collection in
253:13 - a collaborative way and you want to keep
253:16 - track of which changes are being made
253:17 - and most importantly why
253:24 - we are coming towards the end of the
253:26 - course and it is time for you to claim
253:28 - your Postman badge for completing this
253:30 - course and doing all those assignments
253:34 - now go to the original workspace and
253:36 - Fork The Collection named claim your
253:38 - badge
253:39 - inside there you'll find detailed
253:41 - instructions on what you need to do in
253:43 - order to claim that badge I hope you
253:46 - have been able to follow along and do
253:48 - all the assignments if you need any help
253:50 - or you got stuck please refer to the
253:52 - course notes for every individual
253:54 - assignment
254:00 - congratulations you reached the grand
254:02 - finale of this API test automation
254:04 - course with Postman give yourself a pat
254:07 - on the back or even a round of applause
254:10 - yes because you have earned it my friend
254:13 - I hope you had as much fun learning as I
254:16 - did teaching sure it was a bit of work
254:19 - but who says we can't enjoy a little
254:21 - brain workout right
254:23 - API testing and automation with Postman
254:26 - can be a bit of a maze but I aimed to
254:29 - guide you through this as smooth as
254:32 - possible of course some things just
254:34 - couldn't fit into the course but don't
254:37 - worry the course notes for this lesson
254:39 - have got you covered with both free and
254:42 - paid resources to help you continue your
254:45 - Postman Journey just like you Postman
254:48 - and apis are constantly growing and
254:51 - evolving so make sure to keep up to date
254:54 - in this ever-changing world of API
254:56 - testing it was a pleasure having you
254:59 - throughout this course and I can't wait
255:02 - to see many of you proudly wearing that
255:05 - Postman badge on social media and when
255:08 - you do so don't forget to tag me it will
255:10 - make my day if you enjoyed this course
255:12 - I'll be thrilled if you could check out
255:15 - my YouTube channel for more amazing
255:17 - content and smash that subscribe button
255:20 - your support will keep me fired up to
255:23 - create more content like this one and
255:25 - while you're at it please show some love
255:27 - to the sponsor of this course Postman
255:30 - with that I just want to say a massive
255:33 - thank you for joining me in this
255:35 - adventure and I hope to see you again in
255:37 - the next one until then Happy testing
255:39 - with Postman

Cleaned transcript:

apis have become the backbone of software development making API testing an essential skill for developers and testers in this course Valentine despo will teach you how to use Postman to write and automate API tests from the fundamentals of API testing to the intricacies of automating these tests using Postman this course covers it all you will learn about variables scripts debugging JavaScript Basics Json format assertions regular expressions and more plus the course provides valuable insights into integrating Postman tests in CI CD and the fundamentals of collaboration within a postman workspace so let's start learning hello African campers and welcome to this course introducing you to API testing and automation with Postman my name is Valentine I'm a software developer with a passion for sharing my love for technology in a fun and easily digestible way in this course we will dive into why automated API tests are so important and how Postman can help with that my goal is to help those already familiar with creating requests in Postman explore the thrilling world of test automation with an emphasis on writing tests and automating test executions while this course is for beginners it is not for absolute beginners in terms of apis you will get most value out of this course if you already know what an API is and know how to use Postman to create requests if you are a total API rookie fear not free code Camp has at least two other courses to help you get your feet wet now let's turn our attention back to this video which wouldn't have been possible without the support of Postman the sponsor of this course for which I am very thankful throughout the course we will work with an existing Postman collection write tests and automate their execution with various tools by scheduling runs directly from Postman or by employing a thirdparty CI CD tool such as GitHub actions in other words we'll be focusing on test automation if you Ace all the assignments from this course you will be able to claim a postman badge that certifies you have completed this course and are a true Pro in test automation want more details check the video description for a link to the course notes there you will find essential resources and troubleshooting tips for when things go Haywire I will also be posting any updates or Corrections there after all this is a fastpaced industry where change is the only constant so if something is not working make sure to check the course notes first this actionpacked course will surely keep you busy for a few days at least as always on free code Camp please help us create awesome content by liking and subscribing and hey if you're enjoying this course do me a solid and drop a comment below I'll do my best to answer if you learned something from this course I invite you to check out and subscribe to my YouTube channel Link in the video description below which is packed with content about Postman devops software development and testing also don't be shy connect with me on social media I would love to hear from you don't forget the sponsor of this course Osman their channel is chock full of valuable videos definitely worth a subscription so be sure to show them some love as well lastly a huge thank you in advance to those who will support free code Camp by clicking that thanks button and making a small donation I hope you're excited to learn more about automated API testing in Postman and with that being said let's get started welcome to the world of API test automation where we're about to embark on an Epic Quest full of surprises challenges and most importantly fun I want you to think about this course as a multilevel game where we'll conquer each stage together and level up our Postman testing skills to be a pro at this you need to go through four levels which will take us from manual testing all the way to automation we are at level 1 where we will use our trusty Postman collection for some manual testing we will also need to get up to speed with some JavaScript Concepts but don't worry I'll try to make this as easy as possible the first thing I need you to do is to open Postman for this I'm going to use postman on the web so it's essentially Postman in your browser if you go to postman.com and log in you should see something similar to this one so in this case I'm logged in inside my Postman account and I can manage here workspaces and Collections and you can see here that I'm logged in because I'm getting this nice icon here the first thing that I like to do when using Postman is to change to a darker theme so from settings I'm gonna select here themes and I'm going to select the Dark theme okay this is just a personal preference you don't have to do it but I'm going to use this throughout the course now once you have Postman open and you have logged in into your account we can now jump straight into the API open the course notes from the video description so in the video description you will find their link click on that link and you will be taken to a page that looks like this one located notes for this lecture and then you will find a link that takes you to a workspace this is the workspace that we will use throughout the course so it's important that you know where to locate this link to the workspace inside the course nodes what we have inside this workspace is the collection or an API as well as various assignments that you will need to do throughout the course this is the postman collection for an API named Valentino Artisan coffee house I love coffee so why not create an API for a fictitious coffee place this API helps browse a list of products view details and place an order for coffee of course in order to work with this API all we have to do is expand this collection here and we'll see here various endpoints that we can use for example we could use this request to get a status of the API as you can notice here everything is grayed out and we cannot make any changes to this to make changes to any of the collections in this workspace we need to make a copy in Postman we call this a form so essentially in order to work with this collection we need to Fork it now before we Fork this collection it is best to create a separate workspace that we will use throughout this course so from the workspaces here you will have here the possibility of creating a new workspace I'm going to name my workspace free code camp API test automation with Postman and I'm going to go ahead and make this a public workspace let's go ahead and hit that create workspace button so we need to switch back to the workspace and to do so we're gonna need to access that link that we have used previously so we need the link that we have used previously so that we go to this original workspace with all these Postman collections next what we'll do we'll go to this collection which holds the API and from the Ellipsis I'm going to click on it and we're gonna get here this menu and the option that we're gonna select is create a fork and when we select creative work there are still a few steps that we need to take first of all we're gonna be asked how we want to label this work and by default Postman will give us a suggestion and we can just go with that suggestion it does not matter so much at this point the next thing which is maybe a bit more important is where we are going to create this copy this work of the collection and we have previously created a new workspace so we're gonna select that workspace so instead of my workspace I'm going to click on it and I'm going to select here free code Camp API test automation with Postman next you will be asked if you wish to watch this collection watching a collection means getting notifications each time A change is made in the parent collection so if you don't want to be bothered with emails every time I change something about this collection it is best to uncheck this let's go ahead and click for collection now we have our own copy of this collection so for example if we expand it here and go here inside the status folder we can click on get API status and we'll be able to see here that send is enabled this is essentially a regular postmap collection where we can start making changes as we need it is totally independent of the previous workspace we have seen it's just a copy of the collection we made from that workspace so let's go ahead and simply click on the send button to see if this API is working so what you will see here is the message Api is up and running if you don't see this message if you see at this point some errors no need to freak out just refer back to the course notes and follow some of the troubleshooting ideas that I will list there but if you're seeing this message and we're also getting here a status 200 okay you are on the right track a postman workspace is essentially a central point where collaboration occurs within a team we will use Postman workspaces to see Run results write comments and generally collaborate when working on apis before we continue exploring Postman let's first understand what API testing is API testing is a type of software testing that checks the functionality reliability performance and security of an API in simple terms we test API to make sure it works as it should API testing is like quality control in a car factory a car must go through various inspections and tests before it is considered ready for the road we really don't want to release a car that has no brakes ouch API testing focuses on examining the API from the Viewpoint of an external user the consumer of the API to ensure it behaves as expected the main goal of API testing is to find issues and defects in the API ideally before it is released and made available to user in this course we will focus on functional testing in functional testing we will examine if the API works as it should from a functional perspective and we're gonna look at individual API endpoints and ensure that they respond correctly to various HTTP requests other types of testing such as performance tests and security tests are outside the scope of this course before we can automate the testing of the API we first need to do a manual test we cannot automate something if we don't know how to do it manually in this lecture we'll go through all the endpoints of this API and check if they work as expected the idea of this API is pretty simple we have essentially a list of products that the coffee shop has available and we can submit an order for one or more products we're gonna begin here with a status endpoint because the status endpoint tells us if the API is available tells us if the API is up and running so if this endpoint isn't working properly testing the rest of the endpoints doesn't make a lot of sense and when we're doing this test what we want to do is first of all send a request see if something comes back in the first place and then when something comes back we're gonna take a look here at the status we typically expect status 200 okay and second of all we also want to take a look in the response body to see what's inside there so obviously this is coming from the API it's telling the API is up and running so this is already a good sign it tells us we have reached the API and this is a response from the API itself the next step is to take a look at the products that are available so I'm going to explain here the products folder I'm going to click on get all products you can also go ahead and close this previous tab as we don't need it anymore I'm going to click here on send so what we're gonna get here is something a bit more complex in terms of the response we're gonna still see status 200 okay and we're gonna get this relatively large response body that you see here so we can scroll through it and we're gonna see here a lot of products coffees and so on now there are a few things I want you to notice first of all we are getting here 33 results in total so this is some information about all the products are available and these results are paginated meaning they are not displayed all at once which means that if we want to go through all the products like the pages in the book we need to turn the pages so in order to facilitate that we also have some information we know what is the current page and we know how many pages are in total so for example if we want to go to the second page we need to use a query param so we'll see here the parents are already available the parents tab is already selected and one of the query patterns that we need to set is the page so if we enable this query param you can tell us the page that we want to fetch the default initially is one but we already have page one so let's go ahead and change this to 2. so now we're going to check if we have page two so we are now getting other products in the list and we can go on so on and so forth through all the pages apart from this what I want you to notice is that each product also has a category so there are a few categories for example let's say we are only interested in pastry so what we can do is copy the value pastry from here gonna disable the page initially but this time enable the param category I'm gonna paste here pastry and what we're gonna get back are only the products that are from the pastry category we're gonna see here the information has updated there are several results there's only one page in total and we're getting this page so if we go and scroll through this we're gonna see that all the products that appear here are from pastry right so this is how we can get a list of products but let's say for example we want some additional details about this croissant so in that case we have a separate endpoint and that is the get single product endpoint and what happens with this list is that a product can have a lot of information and we don't really want to display all that information at once for that we're gonna use the get single product so that we get information about a single product now I want you to notice a few things here so we have the base URL and then we have forward slash products and then we're using this annotation which denotes a path variable it's essentially something that's part of the path is the address where we can reach that particular product so let's say for example we have here this croissant and we want to get some additional information so I'm going to go ahead and copy the ID of this product I'm gonna go to get single product and paste this ID here let's go ahead and click on send and of course what we expect here is yeah the name is the same the ID is the same we're still in the category pastry but addition we're gonna get information like a product description which wasn't available before or in this additional text it's going to tell us it contains gluten and milk all right so now we have tested these two endpoints we have tested that we can get all the products and this endpoint also has some parameters that we can toggle on and off and play with them it seems everything to be working fine so we can just leave it as it is and then we can move forward now in order to move forward and place an order there are a few things that we need but let's go ahead and open the orders and this time to create an order we're gonna use a post request now what's important to know about a post request is that the post request typically has a request body something that we didn't have before so far we were like give me information about all the products give you information about a single product so it's like get get get get me that information but now I'm saying no no I want to place an order so for that we're using a post record and essentially in the body we're saying what we want to order so let's take a look at the body that is already here you'll notice that there's some information that's already entered here now what's interesting here is that we need a customer name so for example you know when you're ordering coffee somewhere you're gonna ask what's your name so that I know to call you when your coffee is ready so we need some customer name and what we have here is a random Postman variable a random Postman variable will generate in this case a full name with every request and it's not something hardcoded like for example if we're right here Jamie doe that would be a value that is hardcoded this is something that changes with every request and we're gonna take a look at that a bit later but just in case you're wondering this is the Syntax for one of this Postman random variables and apart from this what we have here are the products that we want to order so when we want to place an order we need to specify the products and we need to say which is the idea of the product and what is the desired quantity all right so let's go ahead and submit this order and see how it works come and click here on send and what we're gonna get back here is 403 Forbidden and apart from this we're gonna get also this error invalid API key now this is a bit interesting because this is not necessarily what we have expected we wanted to place an order but it does not look like this order has been successfully received on the other side and similar to this we also have other endpoints for example if you want to check what are all our orders that we have again 403 Forbidden invalid API key now the question is how does the API know who we are and how can an API then show us all the orders that we have we need a way to authenticate ourselves and this is a bit the topic of the upcoming lecture but in conclusion we went through some of the requests in this collection we have inspected the status code to determine if the call was successful and we also looked inside the response body to see the data that is there to see if that data actually makes sense this is a very basic form of testing we have manually tested if the API Works which as I said earlier is a very important step towards automation so how can we get this request work we need an API key which we don't have and without it we cannot send an order well in order to get that API key we need to register ourselves with the API now in order to do that we're going to go here to the clients folder and we're going to register a new client now in the context of apis when we're talking about clients or API clients we're referred to entities that are using the API a client in this context is not the same as a customer so for example for this coffee place API we wouldn't have the customers actually register themselves with the API we only need their name in order to process an order but what we would like to register as a client is for example a terminal where an employee types in this information in a more General context your Postman tool and your usage against this API is also a client when you are using Postman to connect to this API Postman is a client it's an API client that connects to it so we now we need to register ourselves with this API now again this is a post request because we're creating some data whenever you're creating some data we're also sending this data typically here in the body what we have here for the registration is an email we only need an email to register also now again here to test various scenarios we have a random email that's being inserted here so this is absolutely the same as writing something like jamie.do at example.com but Postman changes this all the time with a different value not so relevant at this point because we just want to register our status with this API so let's go ahead and click the send button and what we're getting back this time is 200 okay and what we'll see here is a token now token is sort of like a temporary password that's being used by apis and if you're working with apis we're going to come across tokens a lot but what's important about these tokens is that this is a secret this is something that only we should know and we want to make sure that we handle this Secret in a very careful way in Postman what we don't want to do is we don't want to put the secret inside the request we want to store it somewhere else where it is a bit more safer a bit more protected remember we have created here a public workspace if we put here a secret somewhere in our request well somebody else can just simply grab that secret and impersonate us this is something that we don't really want to do now let's go ahead and copy this value and what we're gonna do with it is we're gonna store it inside our collection as a postman collection variable I'm gonna hover here over the collection until this Ellipsis shows up I'm going to click on it and select here edit and this will open up information about the collection itself now what we can do next is to go here to the variables tab and what we'll see here is origin entry API key well apparently we need to enter here an API key and this API key will be used by the collection so obviously enter a valid API key is not an expected value so what we're gonna do is we're gonna go here under current value we're gonna paste the value that we have received when we have registered ourselves with the API and next I'm gonna click here it is super important that you understand the difference between the initial value and the current value because our workspace is public somebody else can see this information but from the outside the only information that is visible is here the initial value in the initial value our secret API key is not being exposed however when we are running a request with Postman only the current value is being used not the initial value so this token that we have here can be stored even in a public collection and can be used by US when working with Postman and sending requests at others from the outside cannot see this information so in a nutshell it is always a good practice to store any secrets that you have in Postman variables and to make them part as the current value unless you want to share them with others so now we have store this value so let's take a look at create a new order why didn't this request work well actually it has a bit of authentication here and the token that we have provided previously is not valid so let's try this request once again to see if it works now so now what we have here is actually status 201 created indicates this order has been created we're saying okay great let's take a look at the response by this to see what we have inside there and we'll have here the order ID this is our client ID so this is some internal idea that the API has assigned to us we know when this order has been created and we also know the customer name and you're probably wondering well where this Amy came from well this is the random full name that at the time of the execution postman has simply generated this random name we submit this request once again we're going to get a different and then in the lower part we also have the products that we have ordered still you're probably a bit confused where does this come from how does this work well typically authentication is being sent either as a query param so if you look here at the params you're gonna see no there are no query parents okay so if it's not a query param typically it is something in a header we can take a look here at the headers and again we're going to be uh no I don't see anything oh well let's take a look again you see here we have 10 hidden headers right so let's click on this to expose this hidden headers that we have here let's take a look if there's anything that we oh yeah look at this x dash API Dash key so this looks maybe like our API keyer that year so how did our PostNet variable transform in this header here that's a bit weird right and you know how can we change this you know if you're trying to make some changes so it doesn't work okay so this is a bit of the magic of Postman trying to make things a bit easier for you to manage but you know if you're encountering this for the first time it can be totally confusing actually this has been configured using an off helper the name implies it's something that's designed to help you a bit and this is typically configured under authorization if you go here under authorization what we're gonna see here is well the type is inherited off from P it's actually says parent so it's just a bit smaller on my screen so it means do whatever the parent does in terms of authorization it's like oh which parent do you mean well as you can see this request is inside a folder which is called orders so we need to look inside the orders because that's the parent all right so we're now inside orders and what you see here have authorization this is the tab where we're active and what we have here in the list is API key because yes we have an API key and in this case the API key has a key name which we saw in the headers also has a value which this is how we reference the postman variables with curly braces and then this is added as a header and we actually saw the header the advantage of configuring this on a folder level is that all the other requests that we have can use this without us having to manually go through every request so let me show you for example if we go here to get all orders we expect here to see the order that we have just submitted so what do we see that is 200 okay looks good and here is our Amy ordering something from the API ordering something from the coffee place perfect so as you have seen nothing has changed just by placing a postman variable in the right spot and correctly configuring this request in terms of authorization can get things to work again now we still have one endpoint and that is get order by ID so you can simply go ahead and we already have here an ID let's go ahead and see if this works no we're getting back 404 not found well typically first founder font can mean two things either this order really doesn't exist or actually not our order so if you're looking here in the list of the orders that we have well we have a different order ID so how about we use that one and replace the value here let's click Send again and yes we're gonna see here the entire order that we have submitted including the products that were ordered which were previously not visible so in a nutshell this is how we wanna handle secrets in postman by using variables and also using this auth helpers which make our life a bit easier and also reduce the chances that we make any mistakes we need to be able to write scripts in Postman to automate the testing of this API API tests are written using Scripts and automated testing is a way to check if the API works correctly by letting Postman run some tests instead of running all these requests by hand and checking the status code and checking the body and so on this approach has many benefits most importantly it is faster and more accurate because a computer can run the same tests over and over without making mistakes computers are great at this humans tend to get bored and start making mistakes writing tests also helps document how the API should behave or how it used to behave in the past at least now leaving all the benefits behind let's actually start writing some scripts but where can we do that well let's expand here the status folder and get into the API status request in Postman there are two places where we can write scripts the first one is the prequest script and the second one is inside the test now what does prerequest script mean okay it is a script well prerequest means that this script is executed before the request is being sent and we're gonna get a bit into that why this is important and which are the use case but just keep this in mind you can write them before the request is executed and inside the test you can write some scripts that are executed after the request has been sent and a response has been retrieved so how does this look like well if we click inside the prequest script we're gonna have here this editor where you can start writing some code the same goes here for the tests pretty much the same editor so this is where we can write these tests inside this editor here in order to write the test here we need to use a programming language called JavaScript Postman only supports JavaScript and it is not possible to use any other programming language to write this Scripts however JavaScript is relatively easy to learn and also in the upcoming lectures we're gonna go a bit into JavaScript so if you've never written JavaScript before it's absolutely fine I'm gonna take you through this step by step no worries some people confuse JavaScript with Java another programming language but trust me they are super different and they don't have anything in common apart from this let's say unfortunate naming similarity but anyway just keep in mind JavaScript and Java definitely do different things all right so how do we write some code well let's go ahead for example and start with what we're doing a lot of programming language we start writing like a hello world thing so how do we do that well we can start typing here something like console.log you'll notice as I start typing you're gonna get this suggestion so if you hit enter it's gonna auto complete with the first option that you see in the list that is console I'm gonna write here Dot and there another suggestion pops up and I can even go and select what do I want to use here so if you start typing log you're gonna get only one suggestion and if I hit enter once again this suggestion will be completed this is just a quicker way on how you can type this and make sure that you're making fewer mistakes alright so console log is something that allows us to print a message so I'm gonna go ahead here and between parentheses and single or double quotes I'm going to write something like hello from the test okay so this is the message that we want to send out and at the end we're gonna terminate this instruction with a semicolon in order to actually execute this code we need to click on the send button so that we run the request this code is always associated with the requested sound so either we decide to run this code after we have executed the request or in the freequest script before we have executed the request in this case it is in the test so it's gonna be after the request has been sent and the response has been retrieved let's go ahead send this and we're not going to see anything however what's important here is that we are not noticing any errors if there were any errors we'd see them here in test results so for example let's replace log with a capital l o g just to make fun of this so console.log I'm gonna send this and we're gonna get here an error now this can be super scary when you when you encountering this so in JavaScript It's always important how you write things though things are always case sensitive with apis with programming you want to make sure that you write things exactly as they are so in this case we're going to get an error but if we write the everything correctly we're not going to see anything and this is because things are going to be printed to the postman console which is the topic of the upcoming lesson if you are writing script in Postman there is a postman tool you absolutely need to know and use and that is the postman console let me show you how to use the postman console to debug your scripts understand your requests and many many other things so in order to open the postman console we'll have to go here on the lower left corner and you'll see here console so if you click here on console this additional window will open up you already see here a lot of requests now first of all we don't need everything that is already here so we're gonna go ahead and click on this clear button now let's go ahead and submit this request once again where we have this console log script so what we'll see here in the postman console are two things first of all we'll have here the request where we're requesting some information and we can expand this and we're gonna see here request headers and other information from the response the response body so there's a lot of information about the request that has been sent what's important to know is that everything that appears in a console is in a chronological order so it appears as it happens now we have this script console log and because we have written the script we are getting this message in the console hello from the test because this is inside a test we are getting this message after this request has been sent let's say for example that we want to display a message before the request is being sent so I'm going to copy console.log I'm gonna go here to the prequest script and I'm going to paste the exact same code but this time I'm gonna write here hello from the prequest script hit again the send button and what we'll see here is that append it to what we already had in a console we now have Hello from the prequest script because this is being executed before the request then the request is being sent and only then hello from tests appears here in the logs let me show you a neat thing about this the thing is when we're working with the postman console and we're sending a few requests this entire log here will get really crowded with a lot of messages so instead of manually clicking on this clear button over and over again we can do a different thing so here in the prerequest I'm gonna write here console dot clear and I'm also make sure that I'm going to add here the parenthesis so what this will do is we'll clear the console with every request so let me show you what I mean I'm going to click here again on send you're gonna see here console was cleared the request is being sent and then the code that is in the test will be executed and we'll see this here we're gonna work with the post Bank console a lot so it's important to get familiar with it write this code understand where it appears understand in which order this code is being executed if you're no longer be in the console you can simply close it from here and if you need it again simply click on it again and it will appear here in this lecture we're gonna write our first API test in Postman and actually we're going to get a bit of help from Postman but just want to get to the taste of what is an API test so that we don't talk so much about API testing and actually start writing some so I'm here inside the get API status request I've opened up the test Tab and we already have here this console log message and we can continue writing here code but what kind of code are we going to write here well let's say that we want to assert we want to check we want to test if for this request we're getting a status 200 okay meaning the API is answering back and saying hey the status is okay everything is good you can use this API and we don't want to do this manually we don't want to look at the status code we want to forget that there's a status quo we don't know anything about it when I write a script and want to let postmen do this for us how can we do that well in that case what we can do here in Postman is that we can open here a panel so it's a bit hidden here on the right hand side it's not already expanded you'll have to click on this you will get here a list of Snippets these are useful scripts that you can use if you don't see the Snippets don't worry about it I will also include the exact same code that I'm using in the course notes for this lecture now if you can see the Snippets all you have to do is scroll a bit through the Snippets until you find here something that says status code code is 200. okay now before you click on that I want you to go here in the code editor hit enter to time so that we are here on line 3 now now you can simply go over status code code is 200 and click on it and by Magic this code will be generated okay now this code is written in JavaScript but it also contains like a language that is easy to understand so we have a test name which says status code is 200. that's pretty easy to understand and then we have here something that says pm.response to have status 200. this is essentially the assertion that we're making we're checking if the status is 200. so let's run this code again by submitting the request and see the difference now because we now have this test we are seeing here on the lower part of Postman test results we can click on this and what you will see here we're gonna see that we have different tabs for all passed skipped and filled essentially is going to tell us all the tests that we have here for this request and we have only one test status is 200 it says here pass right it's even integrated here in green one from one test half passed so this is the difference the difference between us manually checking if a status is 200 or writing some code and then checking here at the end has everything back we only have one test so obviously the difference is not so major right you can easily tell if it's 200 or not but let's say for example what if we had here five tests or six tests right Postman can do this in an instant and tell us if all the tasks that we have written pass or not now again what we have here is Javascript and now in the beginning uh it may look a bit weird right so the thing is we will look into better understanding JavaScript so that we can rewrite this kind of tests on our own but I just want to show you how easy it is to write your first test there's one important thing that I want you to take from this even if we have used Postman to quickly generate this code and we don't exactly understand what it's doing it's important that we ensure that this code is working so how do you ensure that this code is working well by generating a status code that's not 200. so in this case what we can do here is we can write here status 2 for example which is an endpoint that doesn't exist so when I'm sending this request once again against status 2 gonna get back here 404 not found and if I'm looking here at the test status I'm going to see Zero from one fail so this indicates that postman has executed this code which has a test it has checked is the status 200 no it's not 100 then bam alert it's not 200 it's reporting this information here so that we can easily see it we are starting to automate this and you're gonna get a taste of it real soon so we have created this code here by simply clicking one button I already don't fully understand what exactly is going on here how does this code work and how we can write maybe more advanced tests so to be able to understand this code which is written in JavaScript and even write more advanced code we need to learn a few JavaScript basics in the upcoming lessons we will cover some of the most important Concepts in JavaScript that are relevant for writing API tests in Postman we will cover JavaScript variables and their scope data types including object and arrays functions and many other things you should know now keep in mind that this is not a full JavaScript course and always check the course notes for additional resources and learning however with what you will learn in the upcoming lessons you should have just enough information to get started writing code in Postman and understanding such code if you see some one of the fundamental building blocks of any programming language including JavaScript is the concept of variables in this lecture we will learn about the JavaScript variables their declaration types and how to use them in our code variables are like containers that store data for us so that we can use them to store and manipulate information in our script you can think of a variable like a jar in a jar you can put something and then put a label on it so that you know what's inside so for example if you want to store a name like Jamie that's the data all we have to do is put JB in a jar and put a label on that jar which is like first name or simply name so let's do exactly that in Postman first of all I'm here inside the test script so I'm going to go ahead and remove everything that is inside here and in the prequest script I'm going to keep here console clear because that's going to be useful apart from this because we're gonna be focusing on scripts I'm going to change a bit to the interface of Postman first of all I'm going to collapse this panel here so there's an option here right at the bottom hide sidebar this will give us a bit more space and additionally there's a different way on how we can organize everything in Postman and one of this is this side by side pane so we have this two pane view which we can click on it it will move here a few things to the side so we'll see here the test results and everything but this is something that we actually don't need so we're gonna move this all together and we can also collapse this script so this gives us a bit more space to write this code and in addition to this you can open up here the console so that we have here the editor and the console in Clear View perfect so let's go ahead by actually defining a variable which is called Jamie so I'm going to use the keyword let which is used to define a new variable so you're gonna write here let and then we have to provide the variable name which is like on the jar the label so we can see here name and then I'm going to use the equal sign and between quotes I'm going to put here the name Jamie when we're working with strings like names or any text or something like that it is always important to put this between codes that this is when we have a string you can use single quotes or double quotes as you prefer now if we simply run this code nothing will happen so it's important to remember that if you want to check what's inside the name variable then we'll have to use here console log and what we're gonna do here we're gonna pass name between the parentheses we're gonna write name in this case it is important that you don't put quotes so let me show you we're gonna click here on send and what we're going to get back is Jamie so what is happening here is by not using name between quotes we are actually referencing the variable name and then by referencing the variable name we're essentially we're trying to log this variable well what's the value of this variable well it's Jamie okay let's write that so this is why Jamie appears here in the console it's important to remember that this code that we are executing here in Postman doesn't store anything anywhere this jar with a label name will be destroyed after the execution of the code so it's available while we run this code here but once the execution has stopped this variable no longer exists so for example here I'm gonna simply comment this code out so I'm gonna write here forward slash forward slash it essentially ensures that this code is not being executed it's commented out and if I run this request once again we're gonna get back here reference error which is a JavaScript error telling us name is not defined you are trying to log here a variable called name but name hasn't been defined anywhere so this is why this code is failing this is just a demonstrate that this variable only exists during the execution of the code all right so now these are the absolute basics in terms of defining a variable and using a variable so how about we next Define two numbers so let's say I want to define a number which is called a I'm gonna write here a equals 20. and I'm going to find another number called B which equals 30. as you can tell 20 and 30 are not between quotes but if we're trying to put here in console log a you're going to get 20. there are no errors this is because 20 is a number we can even by comma separating A and B we can even log A and B together we're going to get here 20 30. we can see two values at the same time sometimes we want to create variables that are the result of some operation for example we may want to Define here a variable which is called sum and wanted to hold the result of adding A and B so we can write here A plus b so what we're going to do here we are going to initialize a new variable which is called sum but here we're gonna have this mathematical operation which adds A and B so let's take a look here at the value of sum we can add that to the list as well you're going to see here that if we're adding 20 and 30 the sum will be 50. the advantage of using these variables is that we can change one of the variables we don't need to change anything about that code and then the sum variable will be updated accordingly so we have here A and B and some referenced in multiple places but we only need to update them once sometimes we also need to join strings together say for example we have here a variable which is called first name and just as well we have another variable which is called last name so these are two strings now let's say that for this person we actually need the full name so we're going to Define here a new variable which gonna call full name and in this case full name will be pretty similar to the way we have added two numbers and you may be surprised by this but we can use here first name plus last name so let's see what's happening there I'm Gonna Change here the console log so that we can log this variable we're going to see here in the console Jamie Doe now of course this is less than ideal because there's no space between Jamie and dough but just as well as we have added here first name and last name we can also directly write a string here so we can write here after the plus sign in between quotes we have here quotes and then we're gonna add another plus sign so we are combining first name with an empty string and with a last name now in this empty string all I have to do is press the space bar and we're going to create a white space so if we're running this code again what JavaScript will do is you cannot take the first name variable take its value then combine it with white space you'll notice here between Jamie and though there's a white space now and then add do so now we have defined a new variable with a combination of two variables and also something that we added in between how we write these variables in JavaScript is super important for example you notice here that first is written in lowercase but n here in name is with a capital N if we replace this and have everything in lowercase and try running this once again we're going to get an error and sometimes this can be so confusing for beginners it's like what do you mean first name is not defined I've just defined it here it's right here I can't even find it right so if something like that happens always need to trace back to what you have written and quite often you're looking at the screen and looking at what I'm doing and it's like no it's the exact same code as you and mine is not working now the reality is that if the code would have been the same it should have worked the same but even just one letter A Difference can cause the code to have such an error right so when you're in the beginning it's always a good idea to Simply copy paste things instead of writing them on your own because some mistakes are a bit hard to spot and especially if you're not working with these errors and you don't understand exactly what they mean can be a bit hard so always if something isn't working make sure that you really have everything as you see here on the screen no first name in lowercase and first name with the first letter of each World capitalized except for the first word is called camel case camel case is a widely used naming convention in JavaScript for naming things as it makes things easier to read it enhances readability so now we are getting pretty comfortable with this variables and as the name implies a variable can change its value and using a variable is super useful because we can change the value as needed we can change its values during the execution of the script or you can change it later on we can reference a value in multiple places without asking it to hard code it right so instead of having here full name once again written like Jamie space though you can simply reference over this all these variables now the opposite of a variable is a constant and once we Define a constant we cannot change its value so just so that you understand what I mean by changing a value so for example we have here first name and for some reason we decide yeah first name doesn't have the right value that we wanted to have so we want to make a correction to it so I'm going to write here John instead of Jamie right this is possible you notice here I'm not using the let keyword anymore I'm writing this code once again and then I'm gonna see here we have John Doe right so we can change this value when we Define it once but because we have used let we can change this now let's take a look at the following example I'm going to replace here for example first name and instead of let I'm gonna use cons I'm gonna say you cannot change this first name right and initially the code Works absolutely the same no different but when we're trying to enable this line of code which changes the first name this time we're going to get an error here it's like whoa whoa what are you doing it's like you have defined first name as a constant you cannot change a constant and this thing failed so this is just JavaScript telling you you told me to take care of this variable and to keep it sealed there in the jar and not allow any changes to it and now you want to change it no no no no this is not possible okay so this is why we have this constant now sometimes it does make sense to use a constant or other times you don't need a constant so in this case you know it really depends maybe it's not the greatest example but let's say how about you if you have here something like year of birth right so let's say I have here const we're going to Define here here of birth and we're gonna say here is 1995 or 94 whatever well it kind of makes sense if we're storing information about the person the ear of birth is Something That We're Not Gonna Change right so maybe we're gonna change the last name for some reason maybe we can change other information like an email or address phone number but year of birth you know that that is a constant but it doesn't change right the same we can store like how many seconds are in an hour right this is also something like a constant doesn't change so whenever we have data where from a logical perspective it doesn't make sense to Define this as a variable then we should use a constant when we are working with variables in JavaScript there's an important thing you need to know about and that is the variable scope scope is just a fancy name for like where is a variable available for example we already know that this variable name that I've defined here is only available during the execution of this script the same goes for the prequest script if we Define here a variable this is going to be available only in the prequest script we cannot reference it in the test script or something like that and also if we run this request and Define a variable and we run the request again and try to reference the same variable that's not going to work because that variable will be gone by that but still within the same script so inside the test here we can still have a scope so in JavaScript we can Define another scope so like essentially another area where we can Define variables and this is inside a code block so right now I have defined this variable name Jamie and I'm using here console log on name and I'm seeing here the variable being displayed in the console perfect now what we can do here is put this inside a code block so I'm going to start here code block with a curly bracket and I'm going to end it with a curly bracket as well so this is a code Block in JavaScript it is not very useful in this concept but I just wanted to illustrate what it means for code to be defined inside a code block so if we try here for example adding another console log statement we're just gonna get here Jamie Jamie perfect but let's see what will happen if we Define the name Jamie here well we're gonna get the Jamie Jamie but what if we change Jaime to Jake let's try it once again and we're gonna get here Jake and Jamie so what exactly is going on here and why can we redefine this variable if we already defined it right we know this here we have the let keyword two times what's going on well these are a bit the rules of this code block so what this code block allows us to do is to Define our own variables in the code block so in this case we have here what is called the global scope we have a variable name and we are here in the global scope then we have a code block and then we're back in the global scope so console log will not be able to see what's happening here inside this code block and we'll essentially say okay you're trying to log a variable name I know here variable name I'm going to try and print this out so the name will be Jamie it appears here and here inside the code block we have declared a new variable which is called name it is just a coincidence that it has the exact same label exact same name as the previous variable but we can just use it here inside the scope we can make changes to it and so on so this is why we can see here a variable called jig and we're going to be able to access it here now let's take a look at what happens if we remove the first Declaration of the variable so we only have the code block now if this is the case all we're going to get here is a reference error gonna see here name is not defined and this is because we are trying here to access name from the global scope and in the global scope this variable hasn't been defined now there are a few things that we can do let's say for example well we only want to Define it in the global scope perfect in that case what we could do here is we're gonna write here latiname and if we remove here the lat what will actually happen is that when we're initializing here name we check we're not defining a new variable but we're using one from the global scope so let's see if this works we're going to get here Jake Jake so what has happened here we've defined here variable but we haven't set the value then inside the code block we have set a value to Jake we have printed it and then because this variable is defined in the global space we can also access this here now I can totally understand that this can be a bit confusing but you can think about this code blocks like a oneway mirror in an interrogation room you see in the movies the cops in the room can see outside but the suspect cannot see in the room so this is a bit hard to understand but if there is one takeaway I want you to get from this lecture is that whenever you're noticing here a code block pay close attention to variables and understand where they have been defined and I'm going to point this out also later in the course but this is something that tricks a lot of people and they don't understand where exactly is a variable defined why do I get a variable undefined error and similar things like that so we're gonna start working with this but in this lesson I just wanted to introduce you to this concept so that you can start getting familiar with it and notice when this is the case so in a nutshell in a scope we can Define some variables and nobody from outside will be able to see what's going on inside that code block Gonna Keep it like private like what's happening in the code block is only what is behind the oneway mirror but what is happening here in the global spaces is something that is public knowledge for everyone so we can read it in the global space but if we need access from the code block we can also see what's going on there in JavaScript there are a variety of data types that are needed to represent information this lesson aims to provide a basic understanding of the JavaScript data types you are most likely to encounter when writing scripts in Postman these are strings numbers booleans objects and arrays by understanding the usage of these data types you will be better equipped to use them when writing script so far we have interacted with two data types we have worked here with strings for example in this case we're initializing a variable called name with the string Jake and also number and you'll notice here that numbers are not between quotes if you're not sure about the data type of a particular value JavaScript is there to help you so let me show you for example we can use console.log an inside console.log we can use the keyword type of written together and this will give us the type of whatever we provide after this so for example if you're trying to get the type of name let's go ahead and see that we're gonna see here we're getting string just as well instead of referencing a variable we couldn't simply write here something like Jamie and we're gonna get back a string we can write here 29 and we're gonna get back also a string well the thing is 29 is between quotes so anything that is between quotes even if it is a number it would still be a string from a JavaScript perspective so not to make it a string to make it a number we'll have to remove the quotes run this once again and we're gonna see this is a number okay perfect so we are kind of like understanding a bit how things work if a number has decimals we can write them after the dot so for example we can have here 29.65 and this will still be a valid number sometimes we need to represent the state of something like on or off like a switch that can only be on or off well we could theoretically use a string for that and say on off but JavaScript has a data type called Boolean a Boolean value can only be true or false so let me show you for example let's say here that we are going to create a new variable and let's initialize it with is adult and we're gonna set the value of true if you want to check the data type of is addled all we have to do is use our console log statement here and run this and what you're gonna get back here is Boolean super important true and false to be a Boolean doesn't need any codes just like with a number if we put anything between quotes it will become a string another data type that is maybe a bit hidden and sometimes confusing is undefined so this is something that can confuse a lot of people so let's do for example the following we're going to Define here a variable is active and we're not going to initialize it with any value so what value does it have let's try it out gonna go here inside this statement and change type of angle reference here is active and what we're getting back here is undefined so undefined is its own data type and simply represents something that isn't defined we don't know it is not a string it's not a number it's not anything else it's simply undefined we have created a new jar but we haven't put anything inside there so this is the representation of undefined but it's important to understand this concept of undefined because we're going to encounter it a lot as you later see now in this case we have a lot of properties here that kind of belonged to the same person right so we have a variable name we have a variable age we also have a variable is adult but it's obvious that this data actually belongs to a person now in this case if we want to make things more clear that hey all these variables grouped together actually belong to a person we can use another data type which is called an object so let me show you how that works and it's quite easy so what we're going to do here is we're going to define a new variable to hold this object I'm going to call the variable person and in order to Define an object all we have to do here is use this braces don't have one brace in the beginning and one brace at the end I'm here between the braces I'm gonna hit one time enter and add a semicolon at the end all right so now we have here an object but this object doesn't have any properties so what we're gonna do here is going to move these variables that we have here I'm going to put them inside here now you'll notice as soon as we do this everything will turn in right because this is not valid code now what we're gonna do first of all is remove all the let definitions in the beginning we don't need that anymore now after this what we're going to do is we're going to replace the equal sign with a semicolon and we're going to also remove the space before the equal sign and last but not least we're gonna replace this semicolon with a comma except for the last semicolon which will simply remove this looks very similar to Json but it is not Json it's super important to understand the distinction between a JavaScript object and a representation of a JavaScript object in Json while there are some similarities this is not Json it is simply a JavaScript object you don't have to trust me that this is a JavaScript object let's go ahead and take a look at the type of this thing to see what it is I'm gonna get back here object all right so what can we do with this object well for example we can simply use here console log and we can log the contents of this object so that we know what's inside this object maybe we don't know so we'll be able to see here that we expand this that we have here multiple properties name age is adult and so on now quite often we don't need the entire object at once maybe we only need the name for whatever reason we're going to print a message like hello then the person name right so in that case to only access one property we're gonna use what is known as a DOT notation so after person we're going to write here Dot and you'll see here already there is a bit of autocompletion that kicks in this is because this object has been defined here right inside the window so let's select from the list name and if we run this code once again we're going to see here that the name is Jake perfect so this is how we can access a property now let's say for example for some reason when we have created this object we didn't have some information we want to add some information later on how can we do that well we can simply use here person and we can specify a new property let's say for example we want to add a property which is called email so you can write person.email and we're gonna initialize here this property with a new value so I'm going to write here something like check at example.com so if we log the entire object with console log what we're gonna see here in the list of all the properties is also the property email and just as well if we need to access it we can use the dot notation let's say for example that we want to have here email with the dash between E and M the written like this now as soon as we write something like this you'll notice here something turns into red and here at the end there's also this indication that there's something wrong with the code so what's wrong with this code well essentially when we use here and minus sign JavaScript will think that we're trying to access here person.e minus a variable which is called mail and we're gonna try to initialize this to a variable doesn't make a lot of sense right now in this case if we're trying to do something like this we need to use a separate notation there is a special notation whenever we have some characters that let's say are a bit special and break our syntax that we have here in JavaScript and for that we're going to remove this Dot and between square brackets I'm going to put here email so the idea here is that in order to make this a string we also need to put it between codes because otherwise JavaScript will still think that e is a variable and male is another variable and it's going to try to subtract them so even if the code now looks valid you know if we're trying to run this but we're going to get back here is that e is not defined right so that's also not good so let's put everything between quotes and now what do we see we have here this property email exactly as we wanted it and it has right now the value that we need the same thing goes when we're trying to access this property so if you want to go here and write person Dot you'll notice here in the list email doesn't appear so if you're gonna write here email like this well this is not going to give an error itself but again this is going to be like a math operation where JavaScript will think we're gonna get a property E from person and subtract mail so we're gonna get this time the error that mail is not defined you're probably wondering why is person that he defined well that's not defined but that's not gonna throw an error so let me show you whenever we're writing a property on an object that doesn't exist like person.e it's a property that doesn't exist this object does not have this property what we're gonna get back is our old friend undefined for JavaScript not gonna say oh my God this is an error you cannot continue just gonna say this is a property that is not defined maybe you forgot to Define it or something but it is undefined doesn't show an error this is sometimes a bit confusing because you maybe you are writing here a property like is adult let's say is adult and you forgot to put a capital A there you're looking at this and say oh it's why doesn't this property work it's right here in the object it should work I've written it exactly the same oh well almost exactly the same well that's a problem if you're not writing things exactly as they are inside the object you're gonna get this undefined okay we're jumping into too many things at once but let's go back to how do we get to this property so we know that this notation with that doesn't work so we'll have to use this other notation with square brackets again when we're setting a property or when we're trying to retrieve a property that has some special characters that break our code then we have to use this square bracket notation we're not going to use it a lot but you'll have to remember it because from time to time we're gonna need it so this is essentially more or less what we need to know about objects here let's move this property to the object itself so in this case we're still going to use this notation so we have to put this between quotes single or double doesn't matter and we can put the value here then we have everything in one place so this is our person it looks much better at other times we may need a collection or a list of things things that are you know kind of like similar to one another and for that we can use an array an array is a data structure that can store a collection of elements each identified by an index okay sounds a bit confusing let me share an example so let's say for example we want to store here a list of hobbies currently find here a new variable which is called hobbies and this time to initialize this array we're going to open up a square bracket and we're going to close one now at this point we have here an empty array so let me use here the postman console and we're going to write here Hobbies so we can take a look at this thing so we're gonna see here this is an empty array some people think that this is some error or something like that no it begins and ends and there's nothing inside okay so let's add something inside so that we can make this a bit useful so let's say what do we have for hobbies num not a lot of people do it nowadays but let's say reading that would be one hobby right so if we run this once again we'll see here one so we have one element here and this is a reading perfect and what else we have maybe traveling and gardening and cooking now you can understand how these are related to one another right so they're all Hobbies so it kind of like makes sense to put them in a list otherwise would have something like hobby one hobby two hobby three and so on and we don't know in advance like how many hobbies we have maybe you have none maybe we have 10 maybe we have only two so this array structure allows us to be a bit flexible with how we store this information let's take a look again what we have here we're gonna see here okay we have four Hobbies perfect let's say for example we only interested in the second hobby how can we do that well in order to access only one element of the array we'll use again this square bracket notation and this time we're going to specify the index so it means the number of the element in the array so each item is identified by an index so we're gonna write here this is the first element this is the second element so we're gonna write here two and let's see what we're getting back and we're getting back gardening this is kind of confusing right so let's remove this and go back to square one to understand what's going on here now indeed we have four elements here in the array but if we expand this array what we're gonna see here is the index actually now remember that in computer science we always count from zero a race in JavaScript are zero indexed meaning that the first element is at index 0. the second element is at index one and so on so if you want to get the second element we actually have to write there one because you'll see here traveling has index 1. no problem a small hiccup so we're trying to get a second element we're providing index one and we're gonna get to this array now again we have the situation that we have a person which is an object and we have this array separately which is again a bit confusing but we also have the possibility of actually putting Hobbies inside object so all we need to do is Define here property so I'm gonna add here a comma so that we can add something new to this object column and now we're gonna simply paste here the array so let's take a look again at the person and now we have here a more complex data structure we have an object that also contains an array so let's take a look at this one we have here we have name age adult and we have hobbies we can still explore these hobbies and take a look at them now how can we get to let's say the third hobby right so we cannot write here Hobbies anymore because Hobbies is no longer a variable we have to go through person we have person dot Hobbies and if we're trying to get the third hobby then we'll have to specify index two so this is how we can still access this information from the array but using the object which contains now this array now there's one last thing about the race so if you're trying to do here like type off person.hobbies we should get back array right when we're getting object that's again confusing right why are we getting objects is it because this array is now inside an object no it has absolutely nothing to do with it actually this is because arrays are objects they are more specialized form of object however we kind of like tend to work with them separately and consider them like separate things from objects because they have like this particularities that we need to learn about and when we're interacting with them they're super important but at a technical level in JavaScript there are also objects this is why when we're trying to get the type of an array we're gonna get back object in this lesson we'll be exploring JavaScript functions which is a fundamental Concept in programming a function is essentially a block of code designed to perform a specific task which can be called whenever needed this allows us to organize and reuse our code efficiently so let's go ahead and Define a simple function to define a function we need to write the function keyword followed by the name of the function for example let's say we want to create a function that greets us right so we're going to give the name grid to this function and then to make it a function we're going to add here this parenthesis and after this we're gonna start here actually a code block which we have learned about a bit previously and we're gonna get to it a bit later so this is the code block this is where we can write some code and this will be encapsulated so essentially these are like gates to ensure that whatever happens in this function is isolated from the rest of the things so for example we can write here something like console log and display a message like hello from Postman okay so let's put this back here where it belongs near the function I just want to point out that this is actually a code block perfect so now we have this inside function our function name is grid or let's run this again and if we're taking a look at the console nothing like nothing where is this console log statement what has happened with it well here's the thing just because we have defined a function doesn't mean that that function is being executed immediately right so initially nothing happens if we decide that we want to call a function and reuse some functionality that we have in that function we need to invoke it or call it so I wanted to call that function what we need to do is to specify the name of the function which in our case is grid and not only that we also need the parentheses at the end this is what actually calls the function and we can also add a semicolon there so let's go ahead and run this code and then we will see here hello from Postman so with this code here we are referencing this function here named grid and with a parenthesis we are executing that function without a parenthesis this would still be valid JavaScript code but we wouldn't be calling the function so we'll see here there's no output that's being generated now our function is kind of like silly it doesn't really do a lot let's make it useful let's make it greet us how can we provide some information from the outside and make this useful well in order to do that a function can also think inputs in the form of arguments which are values passed to the function when it is called so essentially when recalling this function we can say something like we want to provide our name so let's say I want to provide here Val and I want to say here something like hello from Postman well do I want this name to be printed there in the console now in order to do that we also need to change something about our function so here in the definition between this parenthesis we're going to Define here a parameter so we're going to call this parameter name and then in the console log we can also reference that so we can say here hello from Postman comma space and then with the plus sign we can use your name so let's go ahead and run this once again and we're gonna see here hello from Postman file just as well we can greet multiple people for example we can greet Jake we can greet Jamie and anyone else would like to greet so let's go ahead and run this so we have reused the same function but by providing a different argument we have also changed a bit what the function does of course this is a super simple example but you kind of understand the idea now I wanted to talk a bit about name here like what's name like what's name is it a variable is it where has this been defined or how does it work if you try for example inside here to get something like console.log name it's not gonna work you're gonna get an error name is not defined but if you're trying it inside here obviously this is gonna work name here is like a variable and this is why it's important to remember the discussion that we had about code blocks this is a code block and this function what it does is essentially saying here this is a variable called name and we're going to initialize it with whatever value is being provided here I'm gonna say here like name equals Val right now of course this is not actually happening in terms of the syntax that was being used but it's almost the same thing so for every time we are passing a different argument here this value will change but it almost works the same as when defining a variable but this is the work that JavaScript does for us by using this syntax by the way we have defined this function so it happens automatically but the idea is name here is only available inside a function it's not available anywhere else okay so now we have this useful function that's cool but sometimes you know we have let's say for example we have developed a super secret algorithm that adds two numbers right so let's put that in a function I'm going to give it a name add and this amazing function will add to numbers like like let's call them A and B right this will be parameters that we will have here in the function because you know to add to numbers we need to know those two numbers so this is how we can take input essentially when we're starting this function so what are we doing with these two numbers let's define a new variable I'm going to call it sum and we can add a plus b all right so then we can use console.log and we can print out some and you already know the drill in order to call this we'll have to provide here two numbers let's add one and two and I'm gonna write and what I'm gonna see here is three in the console perfect okay this kind of works but let's see if there's anything else we could do here so for example let's define two variables let's call them number one and gonna provide here one number don't need a space here actually this will be number two with a different value so let's say we want to display here a nice message like using console log the result of adding and we're gonna specify here number one with gonna add the next number number two is and let's say we want to call this function at here so that we can display everything in the message I'm going to use here the plus sign again we can reference variables as well so what we're gonna do we're gonna add number one and number two perfect we still have here syntax error so we need to make sure that when we're combining Different Strings that we are using the plus sign so the result of adding number one with number two is we're gonna call this function so we can call the function even from within console log so let's run this once again and what we're going to get here is something interesting right so we have here 58 and this is coming from here we have console log so the function works it adds these two numbers and displays them but then when we're trying to use it here it says the result of adding 24 with 34 is undefined again this annoying undefined thing which is driving us crazy why is this happening why is the function adding the numbers but when we're trying to use it it disappears here's the thing just because we use console log in a function it does not mean that the function returns a value console log is just useful for debugging your code we're understanding what the code is doing but in this situation we actually want this function to give us back sum just because we have used console log it doesn't give us some because we can use 10 console log statements right so it wouldn't make sense to just randomly pick one of them or just take the last one and send that over what we need to do is to add a return statement so a return statement is used to specify the value that the function should return after it is done whatever the function is supposed to do in this case because we haven't specified a return value well you guessed it by default a function will return undefined because we haven't redefined what we want to return so if you haven't defined what one return we're gonna get back undefined so in order to not return undefined we're going to use here the return keyword I'm gonna say but what do you want to return how about returning some so when we're running this once again we are keeping here our console log statement which is useful for debugging and understand what the function is doing but then we also get here the value which is being displayed through the console log statement so this is why it is important to have this return statement in functions just because you have added cancel log does that mean that the function actually Returns what you see in the console we can also Define a function inside an object so let me show you how this works we have here an object with some properties and let's say we want to add this function to the object so that we do something in relation to the object so in order to do that things are relatively simple we're going to copy the code that I have here I'm going to go here inside the object and I'm going to Simply paste the code obviously this syntax is not correct but we are actually not so far off there are a few things we need to change now you can notice here that object always has something like a property and then a value now we need to keep the same structures we're going to start here with a property which is grid the name of the function and add it here and then with column this is definitely going to replace here any any equal sign or something like that we're going to say okay we have here grid and grid is a function that takes name as an argument and does something with it so if we're trying to access this function all we have to do is right here person dot greet and in order to call it we need to use parenthesis and grid also takes an argument so we're going to write here Jamie now let's see how this works I'm gonna see here hello from Postman Jamie let's add here another space so that it looks well and we're gonna get this to work when a function is defined inside an object we call it a method while they look similar they're not really the same functions can be defined and called independently without being associated with any particular object on the other hand a method is a function that belongs to an object and is designed to perform specific tasks that is related to that object so for example let's say we wanna also display the first name right so we are getting some argument from the outside but how about accessing some information that is inside here we can write here maybe a special message like my name is and then we're going to take the first name so hello from Postman Jamie and then we're gonna continue the message dot we're ending the first sentence my name is space and then with the plus sign we'll wait to use here first name let's paste it inside here I'm gonna get this to run and we're gonna get here an error first name is not defined okay that's a bit of a problem we could use here person.verse name because obviously first name is a variable it doesn't exist so in order to get this to work then we're gonna use here person DOT first name but let's run it once again and we're gonna see here my name is Jake now this has a minor disadvantage if we for some reason decide to rename this in person too from the outside we know that hey this is person two so we're gonna use person to that grid but here on the inside maybe we forget to change that so again we're going to get an error here person is undefined that's a bit unfortunate and exactly for this reason if we're trying to reference an internal property of the object we can use a special keyword and this keyword is this we can replace person or person two or any other person with this so if we run this once again we're going to see here my name is Jake if we're changing this back to person it's still gonna work so it is an ideal situation to use this if we're trying to access some internal data in a method that we have defined here now methods and functions they indeed look similar and they kind of like work similarly but it's important to understand what is a method and what is a function even if they are kind of similar for example when we're using here console doesn't log right oh well console is an object we can write here something like type of console let's see what's cancel console is an object which means that console.log is then a function and we're going to see here it's a function but because it is like technically in JavaScript it is a function but because it belongs to an object we're still going to call it a method right so we don't have this data type which is called method and function but we refer to an object that has a function we're going to call that a method and when that function is Standalone we're going to call it a function anyway console.log when recalling log here this is actually the method log on the object console so now you understand exactly what console log is this is something that's provided by Postman and it has been defined somewhere else we can just simply use it so this is an ideal example for what it means to reuse something we don't really know or care exactly how this information is being displayed here why everything is on a new line why everything is nicely formatted this is something that it's a concern of this method it's being put together in this method so that we can conveniently use it whenever we need it callback functions are an essential Concept in JavaScript programming allowing us to write more efficient and flexible code Postman uses callback functions and it is important to understand what they are so let's begin with a few basics the first concept I want you to get familiar with is that we can store a function in a variable so what we're gonna do here is I'm gonna Define here a variable let's call it say hello and I'm going to initialize it with a function so we can simply write here function and what is our function this will be our function code and we can have here a simple console.log statement which says hello super simple so which means in this case that where what's the name of this function this function doesn't have a name anymore it's just stored in a variable this is called in JavaScript an anonymous function when a function doesn't have a name it is anonymous it doesn't have a name so in this case if you want to actually run this function if you want to run the code that's in this function the only way to do that is by using the variable where this is stored so we're gonna use here say hello this is the variable and remember in order to invoke the function we need to use parenthesis we're going to add here this parenthesis and this is what makes the call to the function so let's run this and we're gonna get here back hello okay so we can store functions in a variable good big deal why do we need this well we're starting to get there the next concept I want you to get familiar with is that functions can also be passed as arguments to another function okay so how does that work let's say we have this regular function which is called and do something right so this is a regular function and as you know a function can take here some argument so we can provide some inputs that we want to give to the function now we in the past we have provided like two numbers A and B which we have added or we have provided a name so that we can say hello Jamie but we can also provide here a function we're going to write here thumb function because we don't know which function this will be and here inside the code we now have this function and we can decide to run it so let's write here a statement like console log before running the function and we're gonna have another console log statement after running the function and here in between we have here thumb function which is a reference to some function that we're going to get and we want to call that function so in order to call that function we're going to use here you guessed it parenthesis so now we are calling a function that we are retrieving here as a parameter so how can we do this well the next step would be to call do something right because at this point do something isn't being called anywhere and we can reference say hello so we are passing say hello as an argument to this function which is called do something do something we retrieve it here will run console log then it will invoke some function and it doesn't matter if the name is not to say hello this is being passed here as a value it will call here this function that we have here so let's run it and see if it works as intended so what we see here is that we have before running the function this is the first statement then we have hello which is coming from here and then we are after running the function okay you're probably thinking oh Jesus that's a really complicated way of calling this function I mean why in the world would you need something like this and again we're getting there and I do appreciate your patience with this it's super important that you get this so let's take it step by step so to recap we can put a function in a variable we can pass a function to another function and invoke that function here maybe there's some condition here on upon which we decide to invoke that function it doesn't really matter but these are like the first ideas that we need to get familiar with now what if we don't want to Define this variable say hello right in the past when we use something like saying hello we have just written there as a string for example Jamie why can we not write the function directly here inside this function call well actually instead of using here say hello we can simply copy the contents of this variable I'm going to remove this all together and I'm going to paste it here looks a bit crazy but let's see if it still works so it works absolutely the same before running the function then we are running the function and then after running the function so now again we have this Anonymous function which we only need maybe one time and we have passed it here when calling this do something function and what I want you to get is that this function this code is not being called here this console log statement is not called here at line 8. it's actually being called here if we for some reason decide to comment this and we're trying it once again I'm gonna see here the hello statement has disappeared so this is what is running our function this syntax is a bit confusing in the beginning this is why I try to take you step by step so that you understand the syntax the way we write these things in the end if we write here a function if you write here a string jig if we provide one number or even multiple numbers it's the same idea we are calling a function which is called do something and we are providing one argument so the argument starts here and ends here and then we're closing the function call well the function call is this one let me remove it once this is how we're calling the function and here between this parenthesis we are passing one argument just as well we could be passing two arguments or multiple arguments same idea again you're wondering why is this useful when I'm gonna need something like this and it's obviously not easier to read than before well let me explain a bit why we went through this effort of trying to understand this callback function the reason is that Postman uses them so here in Postman if we're trying to write a test and I'm going to expand here the Snippets once again I'm gonna go here to the status 200 test and add it here again now what you're noticing here is maybe maybe something familiar right so what do we have here well we have PM DOT test well PM this looks like an object and test looks like a method right it's starting to accept some arguments so what are the arguments that this is accepting well let me make it easier for you to understand so we're going to Define here a variable which we're gonna call name of the test and the name of this test will be this one so this is the name of the test and let's define another variable which we're gonna call Maybe assertions and this will be a function and we can reference it here this is what a postman test consists of it uses the PM object and then the test method which has two arguments it takes the name of the test and a callback function containing assertions so assertions in this case is a function what is sometimes difficult for beginners to understand is this syntax because it's not clear well where does the method call start and where does it end right so this is why I try to break this down into smaller steps so that you can understand where is the name of the function this is the name of the function right so I'm gonna put it back together again so name of the test this is the name of the test we're providing it directly without using a variable much easier and much faster to write and then as a callback function we're going to provide here the assertions that we're going to use and we're doing it like this this is how we end up with this particular syntax when we are writing Postman tests now I hope that learning about this callback functions hasn't been a waste of your time because now you understand what is a postman test and how it is composed and which are the arguments that we need to pass in order to construct the test of course we'll go further into this test but this is why we have learned about this if you're not familiar with Json this lesson will provide a quick introduction to it if you already know what Json is feel free to skip ahead so what is Json and why do we need it when working with most apis to send and retrieve data we need to use the Json format so essentially we use Json to send requests from one machine to the other in this case Postman is running on our machine and we need to send a message to the API server for example to order a cappuccino right and then in order to essentially place this order for example we cannot simply say like we would say to a human yes I would like a cup of cappuccino or something like that we need to format our message in a way that the computer can understand it let's take a look at an example so that you can better understand what Json is so the Json format is pretty straightforward Json has a simple key value format it is like saying first name equals Jamie so we are assigning to first name the value Jamie but instead of using an equal sign we actually use a column and we put both the key and the value between double quotes and then we're still not ready but we're going to surround everything with curly braces this essentially creates an object with one property if we need to add an additional property then all we need to do is create a new line and separate those two lines with a comma you can notice that in this case 22 is not between quotes 22 is a number and it doesn't require any quotes otherwise it will become a string the same goes for booleans booleans true or false also don't need quotes the beauty of Json is that it is both readable by humans as well as by computers you can read Json without essentially knowing a lot about the Json format itself a confusing part about Json is when you encounter square brackets square brackets allow you to specify a list in this case we have a list of hobbies and you will notice that there are multiple values between those square brackets inside the square brackets we Define a list of things can be any type of values like a string a number a Boolean or anything else even object so let's do a quick recap first of all we can see that we have keys and values first name age is married and hobbies are all keys Jamie 22 Falls and then the list of hobbies like Netflix and mountain biking they are values Jaime is a string because it is between double quotes when we want to add another property to this object we must add that comma otherwise our Json will become invalid and the other party will not be able to understand this message so commas at the end of the line except for the last line are super important 22 in this case is a number false is a Boolean and Netflix and mountain biking are an array notice the square brackets and individual values separated by a comma finally you will see that the object is enclosed by curly braces one at the beginning and one at the end so in a nutshell this is the Json format in this lesson we will dive into the world of Json and understand how to parse Json in Postman and how to use console log to read a specific value from the API response we are done now with learning the JavaScript Basics so let's transform our Postman interface back to original state so first of all we can enable this single pane view by clicking here on the bottom single pane View this will put again the response here in the lower part and initially we can simply go ahead and close the console apart from this we can also enable the list of collections that we have by enabling here the sidebar and we should be back where we started let's go ahead and close the get API status request and expand the products folder and go to the get single product what we have inside here is a product ID so if we go ahead and try to retrieve this we're gonna get a single product perfect now let's say we want to work with some information that we're getting back from the API how can we do this well what we see here is Json this is the representation of a JavaScript object Json stands for JavaScript object notation it looks pretty similar to how we have defined an object in JavaScript but there's still a few differences now the thing is we cannot work with what we have here if this is like a pretty view that Postman offers us but actually the data that we're getting back is this one this here what you see here is simply a string and we cannot do anything with it we cannot read a property we cannot access any information or something like that so for that reason we need to transform this string that we see here into an object that we can use now this transformation from a string into a JavaScript object is called parsing and we need to do this promo Postman script now the question is where can we parse this should we use the request script or should we use the test well the thing is this information is only available after we have sent the request and after we have retrieved a response from the API this is the response from the API and this information is only available here in the test in the prequest script that's a bit too early so we need to go here inside the test and do something with this now I'm going to enable here the pretty view again so that we can get this a nice view of the information that we're trying to work with now in Postman in order to interact with this there are already some predefined methods that we can use so we're going to use the PM object and on the PM object we have here actually another object which is called the response so you see it's available here on the list I'm going to select here response and there is a method which is called Json so when we are calling this method Json it actually gets the response body and transforms it in a JavaScript object so this is what this method is supposed to do this method will return a value it's not going to print to the console or something like that so if you want to use this for later on what we actually need to do is to store it in a postman variable so I'm going to go ahead and Define a postman variable which we can call response or response body as you prefer I'm gonna go ahead and write here const response but this is actually storing the response body just keep that in mind all right so now we have the response so we can go ahead and use console.log and take a look at this response to see what we have here let's open the postman console run this request once again and what we're gonna get here is this object which has different properties so for example if we're trying to maybe get the property ID all I have to write is response.id now what you need to pay attention here is that we no longer have this Auto completion in this case Postman doesn't have the information what kind of an object we have parsed here what kind of a data structure we have whatever properties are available and so on so for this when you're typing the code you're not going to get the auto completion for this reason it's always super important that you pay attention to what you're typing so number right here response.id I'm going to get here the ID but if I'm writing your idea with a capital i I'm gonna get back undefined so for that reason what I always recommend especially when you're getting started simply copy paste the information if you're trying to get here the property is available just write response that is available and copy that from the body so you see here true though is available is true and it's the exact same value from here if you are trying to get for example the product description you need to remember that this is a bit trickier right so right here something like response dot product minus description this again will fail I'm gonna get essentially an error saying that description is not defined the response that project will be undefined and the description variable is also not defined so in order to do that we'll have to use the other notation that we have learned about it in the past and put this as a string between these quotes and then use this square bracket notation so this will help us get the information that we are looking for so in a nutshell this is how we can parse Json into a JavaScript object and when we have a JavaScript object everything that we know about JavaScript objects still applies the way we work with this object the way we read properties the way we change things and so on previously we have seen how convenient it is to set a postman variable and then have a bunch of requests magically work just because we have set the right value this is the power of using Postman variables as you have seen where we have tested our collection there are a few things that we still need to copy around so for example we went here as all products and we have found a product and then what we need to do is copy a value and then set it in the upcoming request well while there's still a bit of work to do this we can use Postman variables and later on we're gonna even improve this process so let me show you what I mean by that so in this case we have here this value product ID so let's say we want to order this product but first we want to check if this product exists so we're going to send this request and checked oh okay this is the product that exists and it's actually a product that is available great and then we need to copy the same value and go into the orders create a new order and then put that value here for example now let's say for some reason we decide we no longer want to order this product we want to order a different product then again would have to search for a product check that a product exists and that is this may be the right product that we want to order and also update to create a new order request we can slightly optimize this process by using Postman variables so what I'm gonna do here in the get single product request I'm going to replace this hardcoded value here and I'm gonna set a postman variable so you can see here if I select this text I'm gonna get this context menu here set as variable now if you don't see this that's absolutely fine you can simply go ahead and manually create that variable I'm going to show you in a second how to do that as well but if you see this simply click on set as variable and what we're going to do here we're gonna set as a new variable and all we have to do is provide a variable name and I are going to be very creative here I'm gonna just write product ID and in terms of the scope I'm gonna select the collection scope so essentially we're gonna save this as a collection variable so let's go ahead click here set variable and now this is a variable of V hover over this we're going to see its value if you didn't see this context menu which allows you to add a variable from here no problem we can hover over the collection name until this Ellipsis shows up click on edit and from the variables tab you will be able here to Simply go ahead and add a variable manually from here of course later on if you want to change this variable that we have created earlier you can simply change its value from here remember if you want this value to take effect in Postman you always need to change the current value because this is the one that's being used by Postman all right so we have it now in a single place here so what to do next well we wanted to reference it here when we're creating a new order so all we have to do is remove this value and then I'm going to write here two braces and all I have to do is start typing product ID you're going to see here appearing in the list of suggestions and let's go ahead and submit this request so what we're getting back here are the products that we have ordered and you'll see here this is the product that we have then referenced through this Postman collection variable so this saves us a bit of time in terms of ensuring that a product that we have retrieved earlier is also available and we can manage all this through a postman variable so let's take a look at an example where we're going to change this to something else let's copy this other ID that we have here and I'm gonna go inside the collection and simply change the variable here so this time when we're getting a single product we're not going to make any changes to the request just submit it you will see here this ID has changed and just as well in the create new order we're going to submit this again and we're gonna see here this ID has changed as well we can do also something similar here with get all orders so from the list of all the orders available we can simply take a look and getting an existing order ID in this case we're gonna have to hard code one of these values so let's copy one of these I'm gonna go back in the collection and I'm going to Define here another variable which I'm going to call order ID and I'm going to Simply paste the value here make sure to save the collection otherwise the variable will not be saved and then when I'm trying to get an order by ID instead of having this hardcoded value can I simply go ahead and select here from the list of variables that are available order ID by hover over it I'm gonna see what is the current value that will be used for this request we can go ahead and submit this request and then we're gonna see we're getting back status 200 okay we're gonna get information about this to order maybe it doesn't seem so useful at this point but understanding that you can use post my variables to store this kind of data that are coming from one request and use it in other requests as well is super important and we're going to work towards eliminating this manual process of copy pasting data in this lesson we're gonna take a look at how we can set Postman variables directly from a script just as a recap we have learned about Postman variables and we have learned about JavaScript variables JavaScript variables are not the same as postband variables while essentially a variable is a way to store something they work a bit differently JavaScript variables are scoped only to the script where they are defined and no variables are persisted meaning we set a variable in a script and then if we remove it we're not going to be able to retrieve it once again well this is why we also have Postman variables Postman variables allow us to store some information between requests and even later on if we need so so for example we can store settings and persisting data on the long term such as the base URL or the API key that we have previously generated or any other details that we need so we have this information as Postman collection variables but both my variables are also useful for passing data between requests so sometimes we retrieve some information in one request but we also need it in another request for example here with the orders we're creating a new order but maybe you also want to get the same order later on and check if that order has been properly created that order ID is something that changes all the time so yes we can use a postman variable but we'll have to constantly change this so let's take a look at a way on how we can improve this process the concept I want you to get familiar with is that we can set Postman variables from scripts so I'm gonna go ahead and run this request once again so let's say we have this value here which is the ID of the order we have just created so we can go here inside the test and here inside the test we can write something like PM Dot collection variables dot set and we can either update or create a variable if it doesn't exist in our case if we're looking here at the get an order by ID request we're gonna see here we already have here this variable order ID so let's try and update that I'm going to use here the name of the variable which is order ID and then we can also set here a value so we're going to take this value that we have here in the body let's run this you will see here this is something with fb8t and so on we open this other request and we are hovering over order ID we'll see here that the current value has been updated so we have updated this variable from a script now okay the problem with this approach is that we now have another ID here so if you're always trying to get the latest ID and then get an order by that ID this approach is still not super useful now in that case there's still something else we can do we are gonna go ahead and actually read this information from here because we now know how to write some scripts and we can level up our automation game essentially by employing this nice trick so what we'll do next is we're going to Define a variable which we're going to call response and we're going to store inside the result of parsing the response body so for that we're going to use pm.response dot Json we're going to call it as a method so now response holds this information and whenever we're trying to do something it's always a good idea just use console.log and what we're trying to do we have here response let's open the postman console and we can see here okay we have access to the response so it looks good what are we trying to get we're trying to get this ID so let's right here response.id can we see this information here in the postman console yes we can here it is this is the latest ID and you can see it's the same as we see in the response body all right perfect we're making amazing progress how can we update the postman variable with this information that is in the body well all we have to do is remove this hardcoded value that we have here and use response.id so let's see again we are parsing the response body we're updating a postman variable called order ID let's run this so now we have this value I'm going to copy it just to cross reference it and now let's run this request you can see that the postman variable has been updated let's click on send and we can search here the body I'm going to click on this one paste the value that we have copied we're able to see that is the exact same ID so what has happened here is that we no longer need to copy paste data from the create and order request to the get an order by ID if we're trying to retrieve the latest order so we can just run this once go to the next request and write as well this is the power of being able to know how to write a script and know how to use Postman variables to store information between the request we will conclude this unit with an easy assignment if you have been following along you already did most of the work now all you need to do is to go back to the original workspace from where you have forked the collection inside here you'll see this list of assignments that you need to complete by the end of the course completing all these assignments is necessary for you to get the postman badge that certifies you have taken this course and have done the work let's begin with the first assignment in order to complete the first assignment what you need to do is work this collection so all you have to do is hover over this until this Ellipsis shows up and from the menu select create a fork make sure to Fork this collection in the same workspace where you have also forked The Collection containing the API each assignment contains instruction so if you're not sure all you have to do is click on the collection and what you will see here is the documentation just in case the documentation doesn't show up you can also access it from here since this is your first assignment I will guide you through the steps you need to take so we already did a first step and that is to Fork The Collection now the next step is to actually read the instructions that we have here so there are multiple tasks that you need to complete and these are things that we already did in this unit in a nutshell you need to put here inside the API request folder some of the requests that we have worked on on the original collection so what you need to do for example for the first task is to take the get API status request to duplicate it here and then to Simply drag it into the API request folder inside here we want to make sure that we remove copy so in the end the name of the request should be exactly the same as here now you will do the same with all the requests as instructed by the documentation so there are three requests that you need to add to get API status the get single product and also get all orders once you have done so you can jump to the next folder and this is where you can check your solution this folder contains a request as well as instructions on how you can verify your work essentially it is a way for you to check that you did everything accordingly this request also contains documentation which are essentially stepbystep instructions on what you need to do but let me give you a hand essentially this request here will try to fetch your collection and we'll do some tests on it to make sure that you have written the code and did all the tasks that were required so let's go ahead and run this request and see what is happening now in this case we're going to get an authentication error because we actually need an API key to be able to use this API just as well we also need here the collection ID this is an internal ID that the collection has so let's start with that one how can we get the internal collection ID well all we have to do here is click on the assignment and what you will see here is this I button here if you click on it you will get additional information about this collection including the collection ID so all you have to do is copy this collection ID edit the collection and go to the variables you will see here that there are already two variables that have no value so for the collection ID I'll have to paste here the current value the next thing that we need is still the API key so if we try this request once again it will still not work so what you will need to do is click here on our profile picture and select settings and this will take us to our Postman account next from the menu we're going to select API keys and we're going to generate a new API key let's name this API key Postman I'll go ahead and copy this API key and go back to the workspace and the collection select the collection assignment 1 go to the variables and in the current value paste this API key and save it let's expand the assignment once again and go to the verify your work request kind of go ahead and send this so what we're getting back now is a status 200 okay and if you take a look here at the test results you will also see that some of the tests you will see here an indication if the tasks that you've done are complete or not now ideally you will start with this once you're getting a status 200 okay because this indicates this request is working in the sense that it can fetch your Postman collection It's always important that when you're making changes that you're saving them otherwise the test that you see here will continue to fail so this is just a quick introduction on how you can approach this assignment and this is also valid for the upcoming assignments as well your job is to ensure that everything here will get a pass sign and you do that by closely following the instructions given here in the tasks always check that you are naming the request exactly as indicated and that you follow all the instructions I wish you good luck with this one and if you're encountering any issues please use the postman Community forum for posting about the problem you're encountering and add there as many details as possible so that we can help you out welcome to the second level in our API test automation Quest where we Flex our brain muscles and craft some tests that will put our API to the ultimate challenge aren't you tired of clicking through your Postman collection and squinting at each response to see if everything is working as expected so far we have inspected the status code and response body to determine if our API calls were successful a very basic form of testing we have manually tested if the API Works doing it once is fun but doing it multiple times not so much well my friends buckle up because in this unit we're going to automate all this tedious work we'll be diving into writing API tests using Postman with Postman we can write a tiny bit of code that automatically checks if all the criteria with deem relevant have been fulfilled will be checking status codes response headers and response bodies we'll even dive into Json schemas we're doing all this work now so that later we can kick back and relax while Postman does the heavy lifting for us so no more manual checks or copy pasting data between requests it is time to level up your API game and embrace the power of automation so without further Ado let's jump in and start writing some tests in this lecture we will discuss the structure of a test in Postman so what do I mean by the structure of a test let's open up the status endpoint and start writing here test now a test in Postman needs to start with pm.test and this method has two arguments we need to specify the name of the test we're gonna call it like example for a moment and we also need to specify a callback function so we can write here function and this will be our callback function I'm gonna hit here the enter key so that we have a bit more space and this is the basic structure of this test now at this point this test doesn't do anything this is like an empty shell so we can go ahead and click on send this test will show up here in the test results you will see here the name example but it doesn't do anything in order to make this a test that will fail if needed we need to write assertions and we're gonna write these assertions exactly here in this callback function this is why we need this entire structure so how do we write assertions well insertion is essentially something that we expect so with an assertion we are gonna assert something so for example let's write PM dot expect and we're gonna expect for example one to eql which comes from equal 1. so in this case we're practically saying we expect 1 to equal one of course this is a very simple expectation and all the data that we have is our coded but let's take a look and understand how this works so in this case the test passes because 1 does equal one however just as well we could have here the expectation that 2 equals 1. or three now in this case this test will fail so the first test with the status code will pass but then our second test that we have will fail we're gonna get you this assertion error it's going to tell us hey look 3 doesn't equal one and it's gonna fail a test in Postman can contain one or multiple assertions as soon as one of these assertion fields the entire test is considered fail once Postman detects a failure it will stop the test and not execute the upcoming exertions if there are multiple of them in this assertion we also have a bit of a structure what we expect here this is what you will typically get from the response so this is something that we don't know this is why we need to make an expectation about it and on the second part here to equal this is the part that we know for example maybe we expect a product to be available and then would say something in regards to the product to be true because available will be a Boolean the point of this initial lesson is to get you familiar with the structure of having a test and having assertions inside that test there's also something that you need to pay attention for example if you write something like PM that expect one to equal one with a triple equal sign this test will appear as it passes however if you write here 1 equals three this test will also pass what you see here is actually an incomplete and incorrect way of writing an assertion so to write an assertion in Postman you have to use PM that expect and you're specifying here something then you need to specify the expectation the value that you think this initial part will equal just writing something like this is totally incomplete and will give the impression that everything is working fine when actually it isn't so pay attention to how you're writing this test and make sure that you are following the structure that I've mentioned earlier and this is using pm.expect having something here then to equal something else let's turn our attention back to this test and in particular to this assertion as you can notice this assertion is not using PM that expect it's using something else well in Postman there are a few expectations that we can write a bit differently but probably most of the time like 95 of the time we're gonna use PM that expect still I wanted to show you a different way on how we can write the exact same expectation but using PM that expect now in order to use PM that expect which looks like this PM not expect we need here somehow the status code we don't know from where we can get at and then we need to write something like to equal when we expect it to equal 200 right so this would be in a nutshell the expectation the missing part is this one here now what we could do here is use console.log and use pm.response because this is where the response is being stored in Postman so let's take a look at what is happening here but our test will fail because we have written here essentially undefined to equal 200 and this will not work but we have also logged here PM that response so let's see what this thing is well as you can see here in essence pm.response is an object that has some properties so we have here a property status and we have here a property code well we could use property code so let's write here PM that response dot code run this once again and we're going to see here the value 200. so what we want to do next is we want to make a assertion with this one we're gonna copy pm.response.code this is what is coming from the response this is essentially what we don't know and then we're saying well we're expecting the code to equal to 100. let's go ahead and run it it's working perfectly if you're writing here status 2 so we're changing the URL to something that doesn't exist this assertion will still fail so this is just an alternative way of writing the same assertion but this time using PM that expect welcome to the second assignment of this course your job is to write a status code test for Every request that we have in this collection having at least a status code test is the most basic thing that we can do when we're doing API testing so whenever we're testing an endpoint the status code test is the first test that we're gonna write so this is why when we're starting API testing we should ensure that every request has documented status code test which indicates what is the expected status code for that particular endpoint from the original workspace I have Linked In the course notes you need to Fork The Collection named assignment 2 and follow the instructions from there before we start doing something with the response body it is best not to assume we get Json Bank sometimes the API might misbehave and return something unexpected like HTML let me show you I'm gonna go ahead and expand the products folder and take a look at the get single product where we already inside the test have some code where we're parsing the response body and then we're trying to log property now typically if we're getting back Json this works without any issues however let's make a change to this instead of products here I'm going to write here products too and I'm going to go ahead and submit this request now what we're getting back here is a status 404 not found and apart from this we're getting back here HTML this is essentially what's being used to display web pages and this API is not perfect and in some situations does return back HTML without knowing that we're not really interested in HTML still we need to be prepared for such situations apart from this what I want you to notice is that here the test results appear in red now even though we haven't written any tests we're gonna get this nasty error here telling us there was an error evaluating the test script and there's some problems here when we're writing code in Postman it is best to encapsulate this in a test if an error occurs in a test it's not going to propagate outside of the test though essentially that callback function provides some protection around the code that we're writing let me show you what I mean so we're gonna write here a test where we want to assert that the response body is Json so I'm going to write pm.test and then right here response body is Json so this is the first argument then I'm gonna write the Callback function and inside the Callback function let's move our test so I know that currently this code is not properly working now let's send this once again and this time what we're gonna get back is a test result and we're gonna get the information that this test here which doesn't contain any assertions but the code that is inside this test has actually failed and we're getting here a Json error and it is practically the same error but what's important here to notice is that this code doesn't prevent other code that we have inside our test from running so any errors that appear will be limited to this callback function still this is not a way of actually testing if the response body is Json so in order to test if the response body is Json we actually need to write an assertion and this is again one of these special assertions that don't use PM that expect in this case we're going to write pm.response to B Json super easy to read and also super easy to write let's run this once again and see what is happening and in this case now the test is still failing this is expected but we're gonna get here this assertion error it's gonna tell us expected response body to be a valid Json but God error unexpected token at something okay and if this assertion here fails this code here is no longer being executed so when we're working with Json and we expect to get back Json from an API it is not a bad idea to start with a test where we are checking that the response body is Json the resource button is not Json you shouldn't worry with further assertions because we're gonna get some unexpected errors just testing if the status is 200 or checking that we're getting back Json is not enough to really verify that an endpoint is working as expected sometimes we want to wish if a property from the response has an expected value so how can we do that let's take a look at the response once again and in this case I'm just grabbing a product here it doesn't really matter which product it is but I'm having here Bagel so I would like to check that this property name is actually bagel let's go ahead and write a test pm.test and the name of the test will be productivism and I'm gonna also add here the Callback function perfect so in order to write these assertions first of all we need access to the response body and as you have seen here we already passed the response once so theoretically we would be able to use it here as well we can use pm.expect I'm gonna write here response and from the response what are we trying to get we're trying to get here the property name I'm gonna write here 2 equal and we're going to hard code the value bail if you're using a different product make sure to specify a different value let's go ahead and run this and surprisingly this test is failing and we're getting here this reference error response is not defined but response is defined how come it doesn't work here well this is where understanding the JavaScript Basics are super important remember those code blocks well when we are here inside the function we are essentially inside the code block so whatever we Define here is not going to be available somewhere else still if we put this outside that's going to cause other problems because we're gonna try to parse the response without knowing if it is actually a valid Json so what we could do in this case is simply Define here response outside we're gonna remove here const and this time I'm going to use let response because we're changing its value we cannot Define it with const so we have here let outside in the global scope which means we have access in our callback functions to this so then we can use response.name let's give it another try and we're going to see here response body is Json product is beagle this is passing without any issues just as well we can take a look at another property for example let's say we want to check the price so we're just going to go ahead and simply copy paste the same expectation that we had before and you notice me I'm using here copy paste always use copy paste when you're working with properties from the response body because this ensures you're not making any mistakes so response at price well what is the price it's going to be 195. so let's put that price here and run this once again and again this test is failing why is it failing because 195 does not deeply equal 195 and this can be a bit of a confusing error how do you mean well 195 in the body doesn't have any quotes which means is a number here 195 is between quotes which means it is a string when we're comparing things in JavaScript a string will never equal a number even if the value is the same so in order to get this to work all we have to do is remove this quote and then our restoration will work just as well okay continue also with other assertions for example we could check if this is available so you'll notice here I'm grouping multiple assertions under the same test so maybe later on we can decide to change the name of the test but we're just trying to understand how these assertions are actually working so let's go ahead and start here that this property is available is actually true so again true is a Boolean so we don't need any quotes we can put it like this so the test will continue to pass or an alternative way to write this is to still use PM that expect instead of writing to equal we can write to B true different syntax Works absolutely the same if you would think that this is for some reason false we can write this false but of course in this case the test is failing it's a good idea to test our assertions to make sure that they're actually work the way we expect them to work now there's still one thing that I would like to test here and that is we have here this Postman collection variable with the product ID and we manage this somewhere so we can change this later on so how can we ensure that the product that we have requested by specifying this product ID is also the one that we're getting here in the body now of course we can check all these properties name and so on but maybe testing out the ID would be a good idea as well so let's write here pm.expect what are respecting we're expecting response dot ID to equal and what is the name of the variable let's go ahead and copy paste this and put it inside here okay maybe we need some quotes no problem let's put this between quotes no errors I'm gonna give it a try and the test is failing what is happening in this case why is this working here when we're sending the request but when we're putting this inside our test is not working anymore well what's important to remember is that this syntax only works in the request Builder essentially you can use this Syntax for variables when we're working with params with path variables with authorization headers in the body anywhere else apart from the script we cannot use this syntax in the script it's simply a string Postman is not going to replace it so if we're trying to get the product ID in a programmatic way essentially from a script we need to use something similar to The Way We have set a variable from the script we can use pm.colection variables because this is a collection variable and this time we're going to use get we're going to specify okay what are we trying to get trying to get a product ID let's give it a chance now there's something even more interesting you can see now we're getting the value right but we're getting this problem that we've seen before when we're comparing a number with a string if you're looking here inside a collection at the variables you'll notice that you know there are no quotes here and the question is why doesn't this work well the thing where we're manually managing information here most of the time behind the scenes Postman will save this as a string and then when we are making comparisons here then we're gonna get a string and we're gonna compare string with a number and that's not gonna work if we want to rescue the situation and we are pretty sure that we have a string there we can use a function which is called parse int so with parse end it's gonna try to transform that string into a number into an integer then we can run this and our assertion is working because now we're comparing a number with another number now let's go ahead and change this product to some other product you will see here we are using the product ID so what we need to do is to figure out another valid product ID say for example let's disable the category that we have enabled and let's simply go with the cappuccino so we have here this ID for a cappuccino I'm gonna go inside the collection and edit the variables I'm Gonna Change here the product ID to a different value I'm going to go ahead and save it and let's get a single product so now we expect to get back cappuccino if we're taking a look at the body yes we have a cappuccino and yeah the response body looks absolutely fine now if you're taking a look at the test results they are not so fine well okay it says here product is a bagel and we have here some tests that verify some parameters well the thing is the response itself is still fine it still looks like a valid response it just isn't a bagel now we can debate if this is a good test or a bad test but this for our situation here this test is overly specific if there's any change in the data for example maybe the price is changing or the product name is slightly changing then our test will fail so the only Dynamic part that we have here inside our test are the product ID and of course it's always a good idea to assume that a product that we're trying to work with is available but the name and the price they are problematic there are situations like this one where it makes little sense to hard code values in tests do we really care if the product is called a bagel or a cappuccino or how much it costs and in most cases reality is we don't we just want to check if the product that we have received is a valid product so instead of asserting if a property has a specific value we can change our assertion to check the data type of that property so let me give an example we know that the response body has a property called name so let's check if there is a property code name there instead of just checking it has a specific value so to do that we can write here another expectation so I'm gonna remove here bagel and the expectation that I'm gonna write is PM that expect and the expectation goes against the response because this is the object that contains the product and we can write here to have property and the property is name and for a second I'm also then remove this price from here so now we are just checking if the response has a property called name and the test is passing we can check also if it has property called Product name and if we run this the test will fail because there is no property product name in the response body we can check that easily so there's only a property called name now we don't only care that we have a property called name but we also care if this name property is actually a string so we can write another expectation but this time on the property we can see PM not expect and we have response dot name and we can say here 2B oh and then as a string we're going to write here strings we're going to have here string between quotes so we're checking if the response body has a property called name and we're checking that this property is a string and it is a string we can also check if it is a number and this is not a number it is actually a string so we're gonna get this assertion error so let's switch it back to string in a similar fashion we can also go about the price so instead of checking a specific price we can simply go ahead and D here if the responsive price to be a number and the price indeed is a number so the test is passing and now from a logical sense we typically expect our price to be higher than zero right so no price can be zero or we can't have any negative prices this is just the business logic that we have we are trying to make a profit so we're not going to sell something where we have to give mine to the customer right so it's a valid expectation to say whatever price we have it must be at least one cent so it needs to be greater than zero so we can write here another expectation with PM that expect against the response price 2 B and we have here greater than always follow the auto completion to be faster and more accurate I'm gonna write here the price to be greater than zero the test is passing now this product costs three dollars so let's change it for example to let's say four here to be greater than four and it's not going to be greater than 4 because 3 is not above 4. so we have also tested that the assertion that we have written makes sense from this perspective now of course we have grouped here a lot of assertions around this test but we can just also split them for example we can write a test that only deals with price to ensure that it has a valid price we can write a test that just ensures that a property is as expected and so on so we're not going too much into how we organize this test and how we name things but we're just trying to understand how we can write these assertions better and now the advantage of this approach is that we can change the product and the test will still work only if something changes about the structure of the data will we have issues now you notice here that this syntax is relatively easy to read right so maybe you don't know exactly how to write everything but once something is written you can just look at it and say oh response to have property name that's understandable response that name to be a string that's also understandable well what makes these assertions work so well and be so easily readable is a thirdparty library that is being used by Postman so this easy to read syntax is made possible by a JavaScript assertion Library named chai JS and you can find out more about chijs at chijs.com and I also linked this documentation in the course notes so what you will find here are many many other options that you can use now you'll notice here that the documentation uses expect to equal so the only thing that you need to get something like this working in post is to Simply add here PM don't expect and it will work in Postman so let me show you an example here just to understand we can copy this assertion here take it inside Postman if you paste it as it is we're gonna get an error telling us that expect is not defined so all you have to do is add pm.expect getting familiar with the chai assertion library is a very powerful way of writing more sophisticated Postman tests and this is a very powerful assertion Library so do spend some time and go over the examples that are being listed here I'm sure you will find something useful let's take a look for a second at the create an order request inside this request we have a few interesting things when one of these things is here this variable which is a postman generated random variable it's not a variable that we are setting however how can we guarantee that the data that we're sending has actually been received by the API exactly as we intended well let's go ahead and see how we can write a test for this particular use case we're going to begin with a few Basics and we're gonna borrow from one of the previous requests that we have and this comes from the products endpoint for what we already have here is this part with response body is Json so this is something that's super useful we want to make sure that the response body is Json so we're parsing the response body and storing this in a variable and of course once the response body is Json maybe we also want to set this Postman variable here but that's not the scope of it let's go ahead and write a new test that verifies the customer name so let's name the test simply customer name and we're going to have here our callback function and we can start writing some assertions so how do we write an assertion well we can go ahead and use pm.expect and what do we have here well we have the response and on the response we have the property customer name that we can use perfect so far so good and then we write 2 equal and then what do we put inside here well we could try something like this right so we could go ahead and put this as a string inside here and see what is happening and what is happening is that we're gonna get a test that is failing so this syntax doesn't work inside here it works inside the body but doesn't work inside here still there is a way to resolve Postman variables like this one inside Scripts the syntax is a bit tricky but I'm going to show you anyway so what we need to use is pm.variables dot replace in it's a bit tricky but hang on for a second so we're going to replace in and here we can essentially specify a string pretty similar to what we have here so if you're unsure about the outcome of this we can simply wrap everything in a console.log statement and take a look in the postman console to see what is happening let's clear everything here and run this so what you will see here being logged is the result of us writing this line of code so this is a way how we can still use this syntax with braces without using pm.collection variables.get or something and when we're working with this random Postman variables there is any way no other alternative to reaching one of these values all right so you can see here that we are now getting this random Postman variable and it changes all the time so we can simply go ahead and use this in our code so we're gonna stay here pm.variables replace in and we have our expectation right about here let's run it once again and our test is still failing and the reason for that is whenever Postman invokes this call when we say we want to use here random full name or random something else a new value is generated with every call so Postman generates one value here in the body and in the test it's going to generate a different value so this is why our test is still failing we haven't made a lot of progress have we well not so fast I have a different idea I'm going to go ahead and copy this from here and I'm gonna go here in the prequest script so here in the prequest script what we could do is to set another Postman collection variable we can use here pm.collection variables.set and we could call this customer name and the value would be you know whatever comes back from here and then in the body we can replace this random variable here with a collection variable which currently doesn't exist but it will exist in a second and also in the test we can use BMW collection variables dot get and we're getting the customer name so we're letting Postman generate this once set it in a postman collection variable by using it in the body and we're using it in assertion let's give it a try to see if it works and what do you see this is how we can take advantage of random Postman variables and Postman collection variables to pass data between the prequest to request the tests and so on let's continue thinking about what kind of tests we could write against this particular endpoint so we know that we have the right customer name and of course there's also other details that we could check but one interesting one would be this ID this ID is the order ID and it does follow some rules for example this order ID can only be composed of uppercase letters and numbers and it has a fixed size of nine characters so how can we write a test for something like this well let's go ahead and copy the skeleton for a test and we can write here something like order ID format so we're testing the format of the order ID how can we do that well we can again use PM that expect a response dot ID and then what we could do here is to write a regular expression now regular expression is a way how you can Define in a programmatic way the kind of structure that you expect from data in this case we can write a regular expression that says this ID can only contain numbers and letters and those letters need to be in uppercase and the size of this thing needs to be nine characters we're not going to go into how we can write regular Expressions because that's a topic on its own but we're going to take a look at a simple example at how to do this in Postman so what we're going to use here is to match so to match allows us to write a regular expression and we're gonna write it here and I want you to pay attention this is not a string here what we're writing inside match so a regular expression goes more or less like this we are starting it here then we're adding here this carrot sign and then what we'll have here between brackets we're gonna say something like this must contain letters from A to Z and from n numbers from 0 to 9. and we expect to see this exactly nine times and this is the end of the regular expression you'll see here I have no errors if you're having trouble finding any of these characters on your keyboard don't worry I've added this expression to the course notes as well so that you can easily copy paste it if needed so let's take a look and see if this is working as expected I'm gonna go ahead and click on send and you'll see the test is passing now the thing is I know that this API has a bug and from time to time in the ID it will include a character that is not a letter from A to Z or a number from 0 to 9. so it's just a matter of time until you're running this test and you're noticing all of the sudden this test failing because you will find there a character that shouldn't be there oh there it is look have you spotted it you'll see initially the test has passed but after a while we are getting this Dash here and this is not something that we expect according to how this ID should work so this is why it's a good thing to have a test here that will fail and warn us if all of the sudden something changes about the behavior of this API it is now time for the third assignment and for you to get some HandsOn practice we have gone through various ways of testing the API endpoints and writing various tests and assertions now I want you to go inside the orders endpoint and take a look at this get an order by ID request in this case you're getting here back information about this order and I want you to use everything that you have learned so far to write some tests make sure that you go to the original workspace and work the collection named assignment 3. let's continue exploring ways on how we can test this endpoint so I'm here at the create a new order endpoint and we are checking out the response buddies Json we are checking the customer name and we're also checking that the order ID has the right format but there's still also other information here how can we do that well in order to test the response structure we could again go property by property check if the property exists check if the property has a particular type check maybe other things about those properties with relatively simple responses that is relatively okay but once our responses get a bit longer or are a bit more complex this approach is no longer so valid a solution to this is to use a Json schema and to validate the response that we're getting against the schema okay let's back it up for a second what is adjacent schema adjacent schema is essentially a way to describe the structures and rules of our responses when our responses are in Json we can use a Json schema adjacent schema is also written in Json and essentially helps us understand if the Json that we're having here actually follows the expected format and it is a bit easier to catch errors in that way so let me show you what I mean by that we're going to start with a very very simple test so I'm gonna use here the test skeleton that we already have and just one line below I'm gonna write here schema is valid and what you will need here is a Json schema so we're gonna Define here a new constant call it schema and what we have here is the assertions or resolution will be pm.response and this is going to be one of those special assertions so we're going to stay here PM that response to have Json schema and we're going to reference here the schema so we can simply run it and see if we're getting anything back okay we're getting again the test field the failed test because of the ID which is sometimes inconsistent but we're gonna get here schema is valid okay so we haven't done a lot in terms of this schema it's just an empty schema but just by default it kind of like passes the test okay fair enough let's go ahead and actually talk about the body that we have here about the structure that we have inside here so first of all we're gonna say look we have here an object this is an object which has properties so we're gonna write here type and the type is gonna be object okay fair enough then we can again check is it still working perfect no problem let's say if we say type is array does it fail okay it fails it says here expecting data to satisfy schema but found following errors data should be an array our data is not an array it's an object okay so this is a simple way to make sure that we are on track let's continue with properties so inside properties which is again an object we can start defining the kind of properties we have in our body so for example ID client ID created and so on they're all properties and we can stay for these properties for example ID is a string client ID is a string any other information is also a string so this should be pretty straightforward but I'm gonna go ahead and right here we have the property ID and again as an object we're gonna write here type and the type will be string okay so we're gonna repeat this a couple of times so I'm just gonna copy this code block here make sure to add a comma and do this for maybe three or four times let me make it a bit larger so that you can see it so we have here ID the next one on the list is client ID after this we have created after created we have customer name and actually we need another one but this one is no longer an ID this is actually an array so we'll see here products so we can write here products column and also as an object type will be array very well let's go ahead and run this and it seems to be working fine now how do we know if this schema that we have written here is any good well we could essentially go ahead and maybe again play around with stuff and see string let's change this to a number see if it fails and it does fail okay fair enough seems to be working but this is a very rudimentary way of testing if our schema works we need to find a better way when we are writing tests in Postman it is our duty to ensure that this test will actually fail if needed if we have tests that never fail when they should then we got a problem because then our tests will not be so useful and we have wasted a lot of time writing tests that never fail now when we're working with Json schema The Experience shows that writing a schema that doesn't do what we expect to do is much much higher than any other assertions we have written before so when you're writing a Json schema or when we're working with Json schema we need to be extra careful that what our tests do is actually what we think that the test should do now testing if the Json schema works as expected actually requires us to make some changes to the response body well this is easier said than done because this is the response that is coming from the API we cannot easily make changes to it well luckily we have a builtin Postman tool that we can use to our advantage and this is a postman mock servers now Postman Max servers allows us to create fake API endpoints so in this context the word Mark simply means to imitate or simulate something it refers to creating a fake version of the actual API let me put this in plain terms a mock server will pretend to be the real API provide us with some responses to our requests but it will not actually process anything so for example if were to create a mock endpoint for this create an order endpoint that mock endpoint will not save the order will not do any validation or things like that no the advantage of using a mock server is that it allows us to actually test our test and to ensure that they work as expected without actually changing the real API which in most situations we cannot do anyway so we are going to use this particular use case for mock servers to modify the response body so that we can test our schema now in order to create our mock the first thing that we need to do is go to the create a new order request and click here on save as example and what this will do is it's going to save this response body as an example and this example will be used by the mock this is the first step that we need to do and then the second step is by going over the collection and hovering over it until this Ellipsis shows up and from the context menu we're gonna select Mark collection what we need to specify here is the mock server name so for example we can call it Valentinos coffee API mock We're Gonna Save the mock URL as a new environment variable and all you need to do next is to click on create mock server so the mock server has been created we can close this tab here and if we go here over the environment we'll see here that we have a new environment this is Valentino's coffee API mock this is the environment that stores information about this mock server and we have there the address we can go over these environment and we'll have here this variable URL we're going to change this to base URL so that it is the same variable we're using in our request we'll notice here we have base URL and here it should be also base URL when we don't have an environment selected we're gonna use the URL that is configured inside the collection however when we select an environment this base URL variable will be overridden and now we are actually calling using the exact same request without making any changes to the request itself we're now calling the mock API so you can notice here I'm running this once twice three times and getting the exact same information back nothing changes about it now if we're looking at the test results we're gonna see that a few things fail obviously our mock API doesn't behave like a real API so for example where we checking the customer name if it is a specific name that test is going to fail we also have this problem with the order ID so this is something that we can change here from the response itself so if we're going over this example EG here this is an example this is what's being used by the mock server see here we remove this and click on Save we can check if our test isn't passing no it's not passing because it's not long enough so let's add here a new character and this schema seems to be valid so the only problem is the customer name so let's go back how can we make sure that this schema is actually a good schema that it is working as we expect what could go wrong with this response for example what if we don't have the property client ID anymore how can we stimulate this we go back to this where we have this essentially temporary response which you wouldn't modify and I'm going to remove here the client ID all together from the response let's say some developer has removed it from the response and we no longer have it will any test say anything about this and we can run this again and if we're looking here at the schema the schema is valid that's weird How about if a developer would add here a new property for example new property new prop I'm gonna call it hello just for fun adding a new property to the response body this should definitely raise the alarm nope doesn't schema is still valid so now by using mock servers we can play around with the response that the server sends us or doesn't send us and we can then figure out what can we change about this to see if the schema will fail if needed if one of the situations should occur if we then have a valid test for that case well it seems that we don't have a valid test for that case and the problem with this is that our schema is valid is a good schema but it does have some problem and one of these problems is that it doesn't say that these properties are required so yes we have defined them in the schema if they are there they're going to be checked to be a string or an array or anything else but if they're missing that's not a problem if we add new properties that are not mentioned here that's not a problem so for this use case this is a problem and this is something that we can easily Overlook by looking at this schema and thinking yeah seems to be working fine when actually it is not so what we need to do next here is to specify another property and this property will be the required property so the required property allows us to specify essentially an array of values that are required so for example ID is required or do we have else client ID it's also required created is required everything that we have here in the response body is actually required we need to specify this here so that when we're doing the schema validation we're also checking that none of these properties are missing so we now saving this let's take a look here in the response we are still missing this particular property client ID so let's see if now something is failing and yes now we're getting an error and it's telling us data should have required property client ID but it doesn't so now we have tested that this particular feature is working as expected okay so let's reenable here the client ID let's save this I'm gonna check here again that everything is working fine schema is valid perfect let's add here at the end another property I'm gonna call it new again an additional property that appeared all of the sudden in our responses and we don't know about it keema is valid how can we change this Behavior well by default any additional properties inside the Json data that are not specified in the schema are allowed and will not cause the validation to fail while this is useful in some situations in our particular use case it's not what we want ideally when new data is added to an API New Field something changes you want to be alerted about this because we might want to check that we may want to write a test about it and we don't want to be surprised that something new appeared all of the sudden so if we don't want any surprises then we need to specify this explicitly in our Json schema that we don't allow additional properties again this is another setting that we're gonna add here so just on the steam level as type properties required we're gonna write here additional properties and we're going to set additional properties to false we don't allow additional properties and now luckily our Json schema is failing and is telling us data should not have additional properties it does have additional properties here so let's go ahead and remove this from our mock server and now our schema is again valid if we need to check back in with the real API all we have to do here is disable the environment and then we're gonna start interacting again with the API but using mock servers is a very powerful way of working with a schema defining it and making sure that it works as expected writing Json schemas is no easy task and so far we have just scratched the surface however I want it to go a bit deeper and show you a more advanced example of how we can really ensure that this response body looks pretty much the way we expect it to look like there's still a few flaws here for example we haven't done anything about these properties ID and client identity they can be anything in terms of created we haven't checked for a specific format and also in terms of the products we just said there must be an array but we haven't really looked into like the data structure that these products need to have here so there's still a bit of work to be done now there are a few things that I wanted to point out first of all we can have here a string but just as well we can add here another property which is called pattern and this pattern allows us to write here a regular expression now this time we're going to write it here between quotes and in this case we already have Here regular expression that we can employ so we're gonna simply go ahead and copy it from here and put it here inside a pattern now apart from this because it is already between quotes you can go ahead and remove this at the beginning and at the end the forward slashes and we can go ahead and save this but not before we remove this other test which we no longer need so let's see if this is working properly seems not to be working properly let's see why oh actually is a good example because now we have a character that we shouldn't have so we already made the test with this one let's run it once again and now the schema is working so obviously just better luck the first request went into one of these edge cases where the ID is not what it should be perfect so we have done this here with a pattern in a pretty similar way we can do it also for the client ID but I want you to take a look here at created so created here is a date so what we could do here is write for example a format and we can say the format needs to be date time so this is a date time format let's go ahead and run it seems to be working fine let's switch back to the mock endpoint just to make sure that in case we're having here something else that it does so I'm just going to remove the last part of this daytime format and make it a bit shorter let's see if this causes any issues and it is going to cause an issue because it's gonna stay here does not match the format date time so luckily again using mock servers can help us identify if there are any issues at this point let's switch back to the real API and take a look at another thing and these are the products we mentioned earlier that we have here an array but we want to go a bit deeper so we have here an array but this is an array of objects and we can actually go a level deeper and say look this is an array of objects and every object in this array must have the property ID and must have the property quantity so let's see how we can do this as well essentially when we're having an array we can then specify items and items will be then an object where we can write additional things now the thing about this is that we're going back to how we Define an object so this is super interesting because you can write here type and the type will be object and we can write properties and we can start writing the kind of properties that we have so for example we have here an ID property and this is type integer and just as well we have here a quantity property go ahead and copy it from here and this is of type also integer let's go ahead and see if this works we're getting here an error Let's Take a Look Ah probably again the problem with the ID no worries we're gonna write once again so the schema seems to be working fine however you need to remember this is an object so we also need to add here required and we're gonna see here that ID is required and quantity is required so if any of these are missing you want to get notified if you also want to allow or disallow additional properties that's a different discussion but let's give it a try with this one schema is valid gonna switch back here to the mark endpoint and let's change a few things so I'm gonna make here ID all in uppercase just to give it a try Gonna Save this gonna select the mock environment and let's try this again to see if this error is being picked up and it is being picked up and it says here should have required property ID now we just briefly went over this to exemplify how we can reduce some of the tests that we have written previously and integrate everything in a schema and still get a pretty decent level of testing instead of having to write all these manual tests where we go property by property and so on now as we have seen by writing this Json schema is not really straightforward so I must warn you that the Json schemas are a topic on their own and we are just scratching the surface here learning to write Json schemas is not easy there are two pitfalls I must warn you about first of all and I see this all the time don't use websites which generator schema for you from a given response most of the time the schema that you're getting is simply not good second of all you're not gonna understand that schema so it's going to be very hard for you to determine what is inside that schema what is actually being tested and so on and so forth whatever approach you're taking always test if the schema will fail if needed I've seen so many times complex schemas being written that simply don't do what they're supposed to do and we get this false sense of security because we have this complex schema which is having all this regular expressions and is checking arrays and objects and everything and then when something changes about the response the schema says no okay everything is fine don't worry about it now if your project is programmatically generating a Json schema based on its code and given annotation that is fine you don't need to write that schema from scratch you can use it however this is not a real placement for understanding what the schema contains and how to test it so my advice is if you're just getting started with Json schemas is to learn about Json schemas step by step and to write them on your own a good resource for learning about Json schemas is Json Dash schema.org a link in the course notes the website is a bit hard to navigate but if you spend a bit of time and take a look at the documentation that is available you will soon get the hang of it and you will see how powerful Json schemas are alright so you have learned so much about Json schemas and now it's time for an assessment you want to really check how you would apply and create a Json schema for the get single product endpoint we currently have all these things here but I want you to write a Json schema based on what you have learned from the previous lectures go ahead to the original workspace and Fork the assignment number four inside your workspace and follow the instructions there apart from the status code in the response body a response also has headers and we already know how to test the status code and we know how to work with response body and make assertions there but what if there is a header that we would like to test while headers tend to be very technical you may find yourself in a situation that you want to make an assertion against a header to make sure that it has an expected value for example what if we want to check here if this x powered by header has the value expressed so let's write the test for the headers I'm just gonna copy here the structure of the test that we don't have to write it from scratch and I'm just gonna write here headers now before we actually make an assertion let's make sure that we can actually get to these headers and for that we're going to use pm.response because the headers are in the response dot headers we'll see here we have the auto completion four headers and in order to get a specific header we're gonna use dot get and as a string we need to pass the name of the header so it is best if we go here in the headers select the name of the header we want to use and paste it here this will ensure that we don't make any mistakes apart from this let's wrap this up in a postman console to make sure that we are getting the right value right so we're going to open up the console clear it and let's send this request so what you will see here in a console is the value Express and this is the value that we need okay so it seems that we have everything that we need so we can go ahead and write our expectation which would be a typical expectation that we're going to write with PM that expect so what are we expecting well we're expecting that this value that we're grabbing from this header to equal Express let's go ahead and see if it works and we have here a new test headers seems to be passing without any issues and this is anyway a test structure that we have used in the past so we know that it is working so this is how easy it is to test the header in Postman can you imagine testing 100 endpoints in just a few seconds with Postman you can do exactly that and I'm here to show you how you can unlock this super power welcome to the third level of our API automation testing challenge we now have a postman collection with some requests and each request has the associated test so we can go through the collection request by request and all we need to do is check if the test passed still this is a manual process and it is really Time to Say Goodbye to clicking around in this unit we'll explore postman's powerful automation tools that will turn you into an API testing Rockstar we are entering the most exciting part of this course where all the effort we have been putting into writing this test pays off so let's Dive In before we jump into automating things we need to make sure that the request as it is right now is working without any issues so what we need to do is to go through every request standard request and check here the test results so we need to do this for every request in this collection because if we have some issues at this point then it doesn't make sense to automate it so we need to check that all the test results are passing now once we have done that this is when we can talk about the Automation and the first tool I wanted to show you is the postman collection Runner so the postman collection Runner is a tool that allows us to run this entire collection with just a single click of a button so just remember all the work that you did for this just a few requests here if you have maybe 20 30 100 requests that you need to send that's a lot of work so we can replace all that with just the click of a button so let me show you how it works and it's super super easy all you have to do is go over our collection until this Ellipsis shows up and from the menu we're gonna select run collection this will open up a new tab and this is the postman collection run so let me briefly explain what we're seeing here on the left hand side here we see a list of all our requests now the way requests are executed in Postman is by the order that we have in the collection so essentially post model will go folder by folder and grab all the requests that are inside there and we'll display them here of course sometimes maybe this is not the way we want to have this but that's not the problem we can easily drag and drop requests anywhere else so we can move requests around if we're not happy with a particular execution order apart from this there can be situations where we say for example register a new client we have already executed that request manually so we don't really want to automate that we can disable that all right so this is the order in which this request will be executed the postman collection Runner will execute this request from top to bottom so it will start with get API status get all products and so on and so forth in this order now on the right hand side we need to choose how we want to run our collection and the first option that is already selected is run manually this is what we want to do apart from this there are also some other settings but they are not relevant at this point so all you need to do is click on this big orange run button and start automating this collection run with just a single click now look at this magic as Postman goes through all this requests that we have and in a matter of essentially second the entire collection has been executed and now we have the results we know what has happened so what has happened we have here all the tests and we see here past 11. so 11 tests have passed none have failed now of course we can find ourselves in a situation where maybe one of the tests is failing of course we know that this API has an issue and if we run this a couple of times one of these schema validations will fail because the idea of the order doesn't match the given pattern if that is the case what we will see here is we have how many have passed and we'll see here failed now generally we're not interested in how many have passed but we're interested in why something has failed so we'll get you information about okay create a new order has failed and we're getting here the reason why this has failed now if you're trying to debug this a bit deeper we'll notice here that the response is not available it says your response body is not available and this is a bit of a bummer because without the response body we can't really understand what has happened but we're also given here information that hey you can change this in the Run configuration right so let's go back to the Run configuration and what has happened this time is that postman has set this flag for us persist responses in a session so by default for performance reasons Postman doesn't save the response body doesn't allow you to take a look at it and see what has happened but if we enable this one it is very powerful because it will allow us to take a look at the response and understand what has happened now there's another setting that I want to show you and this one is the iteration this bug that we're experiencing only occurs from time to time so either we can manually click maybe three four five six times through that run button until the error occurs or we can see from the beginning look just run this 10 times for example and I will take a look and see which of these times didn't work and I can investigate that in particular so let's go ahead and click that run button once again and you can see here Postman is doing the heavy lifting for us everything is in place imagine just the work that would have to do to run this request so many times and inspect all the tests and see if everything is working well okay so in this situation we have executed this so many times nothing has failed so let's try it again and what you will see here is that some of our runs have failed so this is another opportunity to go ahead and investigate what has happened and we're gonna see it is the create new order request that is constantly failing so that's a good thing that there's nothing else that is failing but let's this time take a look and see what is wrong with this now we'll actually have access to the response and we'll see oh look at this character this is not what we expect according to the schema this is why this test is failing so in a nutshell this is how we can use the postman collection Runner to run our collection with a click of a button and then if something fails we can dive into the results and understand what is the reason for the failure using the postman collection Runner is the first step that we need to take just to verify that we can actually automate our collection run so this is going to be probably the first thing that we want to do just to manually run the collection a couple of times to make sure that everything is working fine but this is still a semiautomatic step because we need to open a collection we need to go inside it we need to open the postman collection Runner we need to click that button we need to inspect the results and everything now there is also the possibility in Postman of scheduling a run so essentially when scheduling a run we are no longer executing the postman collection on our personal computer we're not using Postman at all instead the execution takes place on the postman cloud so there's no need to keep a postman open or even our computer can be turned off during this process so this is essentially a fully automated collection run in order to schedule a run all you have to do is hover over the collection click on the Ellipsis and from the context menu we're gonna select run collection by default we have here run manually but just as well we can select the option schedule runs so when we are scheduling a run we are taking our collection and running it in the postman cloud in this case we can also decide which is the order in which we want to execute this request or if there are any requests that we would like to disable like registering a new client apart from this on the lower part there are also a few things that we need to configure we should give this schedule a name for example if you wanna run this once per week or once per day we can decide this here just going to give it a name weekly API test and then we can select the Run frequency and this can be like every hour every week every day and so on in this case we are on the week timer so we can decide we want to run it every day or we want to run it every weekday because if it fails on a Sunday and nobody is going to be in the office to take a look at the results or maybe we can decide just to run this once per week let's say that we want to run it every weekday and we're gonna decide when do we want to run it probably early in the morning would be a good choice apart from this we can also get email notifications and you can also add other people there is also some advanced settings that you may want to look into but they're not relevant for what we're trying to do right now let's go ahead and click on schedule run so in this case we're going to get information about when is this run scheduled scheduling is a good way to keep an eye on an already deployed API to see if it is still working as expected in other words we are monitoring the API if there are any issues this will be reported and will get a notification running this at regular intervals also allows us to understand the time frame when a problem occurred if one occurs now of course we have the option of waiting until this collection will be automatically executed just to make sure that you know everything is working fine in theory before we wait for the first run we can manually click on run now but if we don't do this Postman will do this for us from the cloud so when we're clicking here on a run now this is not the same as manually running the collection on our own computer now we are using the postman Cloud to run this collection now instantly we're gonna get some information here we're gonna get information that this is unhealthy so there's some problems with this API and apart from this we're gonna see here how many tests have failed and what is going on and why these tests have failed now we can notice here a few things for example get API status seems to be working fine getting all products get single products everything works well until we start working with requests that have authentication we're gonna get here the status 403 Forbidden now this can be a bit confusing because we have executed this collection locally and it worked without any issues so why is this failing now well the thing is the following you need to remember that inside our collection we have stored a secret so if we go inside the collection and edit it and jump to the variables we're gonna see here that we have some secrets we have this API key now the current value this is what we have here on our computer however when we're sharing this collection and in this case we're also sharing our collection with the postman cloud Postman from the cloud only has access to this information and as you can notice here we don't have a valid API key now we can change our workflow in a way that this information is available so that we generate an API key when we're running this flow or what's a bit quicker in our situation we can simply go ahead and take this from the current value and put it here in the initial value now you need to be very careful with this because remember this workspace is public anything that is in the initial value is public for this particular collection this API key is Not So problematic but you may find yourself in a different setting and in that case exposing this API key as an initial value may not be such a good idea but typically when you're trying to run a collection and you're having authentication issues when using a schedule run but the exact same run is working without any problems when you're using the manual run install Postman probably 99 of the cases this is related to postman variables so remember the postman cloud is only using this initial value doesn't have access to the current value so this is just a small hack to ensure that this is not working properly so let's go ahead over the collection and we can open here the tab runs and we can see here that we have scheduled runs so this is our schedule here and we can click on view to go back to the previous View that we had so all we have to do now is Click again on run wait a few seconds and we'll see now that our API is healthy meaning everything that we have inside our collection is working as expected well the requests are working as expected all the tests are working as expected there are no script errors or anything like that of course we can also go into the details and see the test results and see which tests have been executed and the fact that they have passed but this is less relevant also have access to the console log and see if there's any details here that might interest us but apart from this there's nothing else that we need to do here so typically we are going here when something doesn't work anymore when we get an alert that our API has issues now this tool can be very valuable for verifying that your public API operates as intended particularly in relation to configuration updates or recent deployments so it's just a good idea if you're having a public API to schedule one of these runs and let it run at a regular interval so that you get information about this if something goes wrong you will be notified now preproduction environments are usually not publicly accessible which somehow restricts the usage of this feature professional and Enterprise plans provide access to a static IP address that can be configured as a firewall exception but that's a separate conversation on its own now once you have understood how this scheduled runs work it is also best once you don't need them anymore to simply delete them so all you have to do is again go here inside the collection go to the runs tab and then all you have to do is hover over the scheduled run that you have click on the Ellipsis and either pause it or delete it all together so in a nutshell scheduling a run essentially creates a monitor which runs at a predefined interval and keeps an eye on your API and ensure that it's still working properly in this lecture I will introduce you to the postman CLI a tool that runs a postman collection using the command line we'll learn its Basics setup and how to use it for a more efficient API testing process in order to get started with a postman CLI again we're gonna hover over the collection until this Ellipsis shows up and select run collection from the options available here this time we're gonna select here automate runs via CLI once we do this we're gonna get instructions on how to use Postman CLI to run this collection but first of all we need to install so let's go ahead and download Postman CLI to install Postman CLI we need to follow a few steps I'm going to demonstrate this process in Windows because most of you are using Windows but it works in a similar way for Mac OS and Linux first of all you need to open a terminal window if you never did this before that's absolutely fine simply search for a program called Powershell if you are on a Mac you need to search for a program called terminal and if you're on a Linux you're probably done with installing this by now anyway let's go back to Windows you will see this window where you can type in commands let me make this a bit bigger for you now if we're going back to the documentation we'll see here that we have installation instructions for Windows Mac and Linux so for every operating system there is a different command so for Windows all you have to do is copy this command if you have a newer Mac you probably have the newer CPU for Mac so you may want to use this first command if your Mac is a bit older you use this one and for Linux you have this command at the end so I'm going to copy this one for Windows and we'll have to paste it in the terminal window that we have open you can use your keyboard shortcuts or simply click on the window bar and use the context menu to paste after this the command will show up and you need to press the enter key to execute the command the installation should only take a few minutes to ensure that the installation has been successful we need to type in the following command Postman space minus V and this will print out the current Postman version now when you're seeing this process and all these weird commands you're probably like are you sure is this a good idea I mean why do we need this can we go back to this nice Postman interface that we had before and I can totally understand a command line interface tool CLI tool is invaluable for streamlining the testing process as it allows for automation easy integration with continuous integration and continuous deployment pipelines and overall a faster execution apart from this we can also run a postman collection on our own infrastructure without using the posting cloud let me put this plainly if we want to let the computer run our Postman collection without our human intervention we need to use a CLI tool if we wish to run Postman tests in a CI CD server like Jenkins GitHub actions or gitlab we need to use a CLI tool we cannot use the graphical interface from Postman so let's jump back into Postman and try to run our collection using the postman CLI now if we're looking here on the lower part we're gonna get here instructions about some commands we need to run and they're essentially to command one of them is Postman login and the other one is a command that will actually run the collection now let's just copy the last command that you see here jumping into the terminal I'm gonna paste it and what we're gonna get here is an error it's going to tell us that no authorization data was found and that we need to use the postman login command now whenever you're getting errors when using these tli tools it's important not to just panic because there is an error but just take a bit the time to read line by line understand what has happened you have executed a command and then the tool is telling you no authorization data was found and sometimes these tools teacher to be helpful in telling you hey you need to use Postman login so obviously we have missed something here we first need to run the First Command which is Postman login okay how do we run this let's copy this command here and we're going to paste it again and again we're gonna get an error now when we're trying to log in with an API key in this case we actually need to provide that API key and the graphical interface here is trying to help us you like you don't have an API key let's how about you add one here so we're going to click here on ADD API key and we can either use an existing key that we have or we can simply click here on generate key we can call this key Postman CLI so that we know what we have created it and click on generate okay no spaces are allowed let's put this together and now we have a key and we can click here on insert key so this key then will be part of this command here so all we need to do then is to copy this entire command go back here and paste it so the First Command will log us in and the second command will execute the postman collection so let's see how this will go so we're gonna see here a few issues but first of all we have been logged in successfully and then we can actually see our API here but then we're getting some errors here now the first error is a type error and we're going to take a look at the logs to understand what is going on and the second one is coming here from the orders and this is probably the schema that has failed in the past so that's nothing to worry about so the first error is actually complaining that in the get API status request we have this console clear function so it's telling us this is not a function so obviously Postman CLI doesn't know about console.clear or doesn't make sense to have a console got clear in this context so we need to figure out a way around that and the second assertion error is that schema is valid but apart from this this is how we can run a collection using Postman CLI and we can take a look here and see all the requests that have been executed we'll have here essentially a report at the end so we know how many requests have failed how many requests are still working and so on let's jump back into Postman and try to fix this console.clearprom so what we can do here in the status request get API status and in a prequest script you see here we have console.clear so what we could do here is we could add an if statement so if console.clear without actually calling it and we're going to move the statement inside here we can quickly verify if the console is still being cleared let's send this request so we see console was cleared we have saved this request and then if we need to run this once again all we need is the second command because postman has logged us in so when we're trying to run any other commands here we don't need to log in once again because we are already logged in so all we need to do is use this command Postman collection run and this thing that we see here this is actually the internal ID of the collection this is how Postman identifies our collection and now we have apparently got rid of that issue with console.clear and we still have this problem with the schema is valid now apart from this we're also getting information that this execution has been uploaded to the postman cloud so what does that mean well it means that we can see this detail inside Postman let me show you go back to postman and click on our collection we're gonna see here the Run step and what we'll be able to see here are test runs and we have here the source so we have here the source being Postman CLI or Runner which means the manual run that we have used and we can also dig here into the results and see what is going on for example we're gonna click here on this icon to view the report and we can take a look and see what exactly has failed and hopefully what is the reason for this and of course if you need to troubleshoot this we can go back to either running the request manually in Postman or using the manual collection Runner to run this collection from the beginning to see if whatever error we have encountered is still occurring now as you can see the response body is also not available so this is something that we need to change in the Run configuration but for Postman cli's this is not something that we can do at this moment so this is why we need to run this manually to see if we can replicate that specific issue when you're using the postman CLI to run a postman collection that actually a lot of things that you can configure that are not visible here directly in post now to understand how you can use Postman CLI like like a pro it is important to spend a bit of time and go over the postman CLI documentation and its command options essentially whenever we're running a command like Postman collection run we can also specify some additional options that change the behavior of this command now there are a lot of options here and I highly recommend going over them and seeing if you may want to use them sometime in the future at least to note that they are available and that this is possible however there is something that I wanted to show you just to give you an idea on how we can use this let's say that in our collection run we only want to run a specific folder and for this we can use this option minus I and specify the folder name let me show you how it works all I have to do is go back to postman and let's just copy again only the command that runs the entire collection in Postman CLI I'm going to go ahead and paste this and after this I'm going to add here space then minus I and then between quotes I'm going to put here a name of the folder that I want to execute for the sake of this let's just say I want to execute status so only the requests that are inside status I want to execute them I'm going to write inside here status let's go ahead and run this and what you will see this time is that only one request has been executed because now with this additional option we have configured the way this collection run functions so only one request has been executed and this is sometimes very powerful because we can decide to run only a couple of folders so for example if you need to run only three folders from a collection then you can just use minus I the name of a folder and then after this also the other folders Let me Give an example let's say one run status and then there's another folder that way we want to use products I'm gonna write here product as well and you will see here that only status and products as folders have been executed again it's super important that you go over the documentation and understand what these options do and how you can use them welcome to the last level of our API automation testing game in this unit we'll be tackling the integration of Postman tests in cicd in the upcoming lessons my goal is to help you understand why this is important and how to do it integrating Postman API tests in a cicd pipeline is essential because it automates the testing process ensuring that apis are continuously validated and function as expected during development and deployment let me put this in simpler terms where basically firing ourselves from the testing department and letting computers take over while we still keep a watchful eye to make sure nothing goes Haywire we will kick things off by discussing the fundamentals of cicd and the importance it holds in our testing process next we'll embark on a stepbystep journey to run Postman tests using GitHub action one of the leading cicd tools out there if you are using a different CI CD Solution that's also fine I will provide you with some guidance on how to get started with other tools as well apart from this we will talk about Postman workspaces reports and effective collaboration techniques within your team if you have been following Along on this Grand Adventure give yourself a hearty pad on the back this is the fun part so grab your gear and let's Dive In let's talk about cicd for a second the ICD stands for continuous integration and continuous deployment it is a practice used in software development to make the process faster and more reliable with continuous integration every time a developer changes the software those changes are tested automatically this helps catch any problems early in the process once the CI pipeline is done we start the CD pipeline where we typically deploy the software to a test environment which allows us to do further tests if all tests pass the changes are automatically deployed to the production environment and go live this practice allows for improvements that can be made quickly without having to wait for a big update this process helps teams work together more efficiently and it makes easier to keep the software running smoothly now what does this have to do with Postman tests and automation well the thing is if we're working on an API using CI CD it makes absolute sense and we also want to integrate our Postman API test in the CI CD pipeline there are at least two steps in the process where it makes sense to run Postman tests after deploying the API to a preproduction environment such as a test environment and after deploying to the production environment using the postman CLI allows us to run a postman collection and the associated tests in our continuous deployment pipeline without us manually triggering a run let's talk for a second about the ICD providers using a CI CD tool allows us to automate the process of integrating code changes testing and deploying applications making our lives easier now it is important to understand that there isn't a single best tool for CI CD the best tool for you will depend on your specific needs your team's familiarity with the tool and the specific requirements of your project your organization may already use a tool so you could be forced to use whatever option is available anyway some popular solutions for cicd include Jenkins gitlab Circle CI and GitHub actions among others in the upcoming lesson I'm going to show you how to use Postman CLI to run a collection in GitHub actions now I want to make it clear that this isn't intended as an introduction to GitHub action we're focusing here on how to use Postman CLI within the context of GitHub actions if you are not familiar with GitHub actions that is absolutely fine I will take you through the process step by step now you might be using a different CI CD tool and that's perfectly fine the beauty of Postman CLI is that once you understand how to use it integrating it in any cicd server is relatively straightforward the principles we'll cover here can be applied to other cicd tools as well before we start you will need to sign up for a free GitHub account if you don't already have one GitHub actions is a feature of GitHub so you need to have an account to be able to use it signing up is relatively easy and quick and it will give you access to a wide range of tools and resources Beyond just GitHub actions so let's go ahead and run bothman API test with GitHub actions for that we're gonna need a GitHub repository so let's go ahead and create a new repository I'm gonna name the repository my API project and also want to make sure that this repository is public let's go ahead and click on create Repository in order to configure a pipeline with GitHub actions we need to go here from the project page to actions and we're going to set up a workflow ourselves essentially a workflow is something that we want to execute with the help of GitHub action I'm going to call this workflow Postman and here we will have to put in the configuration that is needed to run our Postman collection using Postman CLI now luckily we don't have to write everything from scratch but we have postpon on our site to help us with this process so what I'm going to do next is I'm going to jump here inside Postman hover over the collection and select a run collection from the option then gonna go to automate runs via CLI and what you will notice here on the lower part of the screen is run in CI CD a little bit hidden and I wouldn't be surprised if you missed this before so let's go ahead and click on configure command because with this tool here we'll be able to configure our pipeline in just a few seconds so first of all we want to make sure that we have the right collection here and then from the list of cicd providers we're gonna select GitHub action and what we'll see here is the command that we need to execute so let's go ahead and copy this command I'm gonna jump back to GitHub actions and here in this window I'm gonna paste this now this is a git repository so we need to commit these changes and we can just go with the defaults here and click on Commit so now our project contains a folder which is dot GitHub forward slash workflows and inside here we have our configuration file and this should run our Postman collection if you want to see what exactly is happening we can click here on view runs or you can simply go here to actions now if we take a look at one of these workflow runs here we're able to see if they were successful or not so in essence we have here a job which is called automated API test we can go on it and we'll see it is red so it's already not looking good but when something doesn't work it is important to understand what has happened so you'll see here there are various steps that are happening I don't know setting up the job running something and then this is the part that is interesting for us it is installing Postman CLI because it is not installed so you'll see here okay Postman CLI has been installed this work without any issues and it is trying to log into Postman CLI and it's going to tell us hey there's some argument missing here so again we haven't specified the API key and what we definitely don't want to do is to put that API key inside our code so we're not going to put any keys in our configuration so how can we handle this well if we're looking back at the configuration we're going to see here that there is something that is referencing an API key so let's open up here postman.yamu and what you're going to see here is something with secrets that Postman underscore API underscore key every CI CD system out there will allow you to store some secrets so let's go ahead and do exactly that I'm going to copy here Postman underscore API underscore key and go to settings for this project and then under security here you should see secrets and variables we're gonna select from the list actions and this allows us to define a new repository Secret so let's go ahead and click on new repository stick wrap we're gonna give it this name that we have just copied from the pipeline then from Postman we need a secret key so from here from Postman we can see here again the option of generating an API key and this time we're gonna write here GitHub action and this is very helpful because then we know that this API key is associated with GitHub actions so you can simply go ahead and copy this entire thing and paste it here and then click on ADD Secret now I'm showing this openly because I'm going to revoke these secrets later on just in case you're wondering but I want you to understand exactly how this process works and how these secrets look like it's also important that you name them exactly as you see and that you don't add any spaces or any other characters new line and things like that to them otherwise they tend not work so well let's go back to actions here and we can take a look at one of these runs that has failed here and we can simply click on this button rerun jobs this will essentially restart this job so now the job has started and we can even click on it to see what is it doing and we can see the installation part is done it has logged in into the postman CLI so we have that information there and then now we're running some API tests and we can see here what is going on with API tests and we have the exact same report that we see when we're running Postman CLI locally but this time it is running in the cloud now whenever something goes wrong with this you need to determine is this because there was an issue executing the postman collection so essentially a postman test has failed or is it a problem with a script that we have written in any case it is important to have the patience to go over the logs and understand what has happened if there are some errors it's important to understand if there are any hints or any information here in this log so don't get scared that you see some failures here that's absolutely normal actually you want to make sure that whatever we're doing here actually fails if they need to fail just as running Postman CLI locally when we're running Postman CLI with the help of a cicd provider like GitHub actions the results of this execution will be published to postman so you can go back inside Postman and if we close the steps and click on the collection name itself we'll see here runs and this time we're going to see again information about the one that just happened there are also additional information here so you can see here this is the second build this is being linked actually to GitHub action so we can click on it and see more details about this what has happened why something has failed but just as well we can also visualize the results that we have from within Postman I hope you have managed to follow along because now it's time for another assignment it is super important that you understand how to use Postman CLI and if you manage to run the API test with the help of GitHub actions then essentially your job is done if you haven't done that please go to the previous lecture and tried it once again because for this assignment you will need your GitHub repository and you need to submit your guitar repository in order to be able to complete this final assignment anyway go to the original Postman workspace work the assignment number five and follow all the details that you will find inside there if you are not using GitHub actions that is also absolutely fine you can run Postman CLI in virtually any CI CD system out there however for the most popular ones Postman makes your life a bit easier so when you're going here over your collection and selecting a run collection then automating via CLI and then under run on cicd you click on configure command what you will see here are different cicd providers that you can use so you have bit pocket pipelines Circle CI gitlab Jenkins Azure pipelines Travis CI and probably many others in the near future apart from this you can also go and select the operating system where this provider is running so if there are any particularities if you know that this is running for example on Windows then you can also select the operating system there and what you will be given here is the configuration that you can use to get started with this and this of course changes depending on the provider but for most situations this is just enough to get started just enough to see that these tests are executing in your cicd pipeline and then you can make improvements based upon this but in a nutshell what you need to do is you need to ensure that Postman CLI is installed you need to make sure that you are all dedicated and that you don't expose your API credentials anywhere in the pipeline configuration and then you need to run the postman collection run command specifying the ID of your collection and after this the results of this execution will be displayed in your CI CD system and will also be ingested into Postman so that you can see the reports from the collection itself Postman is all about collaboration most of the time when you're using Postman you want to collaborate with other people in your team for that you need a team and you need to use team workspace so not to create a team workspace all you have to do is go here to workspaces and click on create workspace next if it's not already selected you need to select your team let's call this workspace my API my account doesn't have a team so a team will be created as well so let's go ahead and go directly to the workspace and let's see what we can do here team workspaces allow you to collaborate on a collection you can create Forks essentially which are a copy of a collection when you're working on a collection and making changes of course you can also collaborate with others and comment and have conversations with others within your team to understand why some changes are made or why maybe something isn't working as expected and you're also able to track everything that is going on within your collection knowing exactly who has made which changes and most importantly why when you're working with many many apis it's also super helpful to be able to search around and to find what you're looking for okay so let's go ahead and see exactly how we can benefit from this team workspaces and especially how we can benefit from working Collections and merging changes into them so let's go ahead and switch back to our Dark theme and I'm going to make this a bit bigger for you so that you can properly see we're gonna go ahead and create a new collection and I'm going to call this collection Postman Echo but let's imagine that we want to collaborate on this collection but we don't want to make changes directly to the collection in that case what we can do is hover over the collection until this menu pops up and then we can select create Fork so then we're creating a fork of this particular collection but receiving it in the same workspace so this will be my Fork we can give it any other label for example we can call it new request because let's say we want to work on a new request we're gonna Fork this collection we're gonna have an exact copy of this collection and in this new collection we can go ahead and add a request and let's say for example we want to add a request to the following endpoints so we're going to use Postman Dash echo.com forward slash get this will be a very simple request against this API which is provided by Postman and we're gonna get here some information back not so relevant just gonna go ahead and save this and close this so our original collection doesn't have any request now we have added a request here just want to test it a bit to make sure it works then we'll say okay now we want to integrate these changes back into the previous collection because we know that everything will be done here adding The Collection maybe writing some tests and other script everything works as expected what we can do is we're gonna go over our fork and from the context menu we can do two things we can create a pull request which essentially is a request for merging these changes back into original collection or simply merging the changes now of course this depends on the permissions that you have sometimes you can merge changes but sometimes you can only create a pull request so let's go ahead and do that so it's a pull request we have to provide here some information like why are we making these changes to the collection so for example you can say that a title is added request and we can provide here a description like we have added another request which is necessary for whatever project we're working on we can also add here reviewers from our team and then we can go ahead and create that pull request so we can see here a few things so we'll be able to see exactly what has been added so we'll see it's a new request it is with the method get and this is the URL where this request is going so here you will be given an overview of everything that has changed in that collection and it's important to notice here that we are having this particular source with a label that we have specified and we want to integrate these changes in the original collection so this is the original collection this is the one that we have for now depending on how things are configured we may or may not have the permission to merge in this case we do have the permission to merge so this merge pattern appears here so we're gonna go ahead and click on it and here there are various options that we can consider essentially once we merge these changes we don't need the copy that we have made the one with the label so in this case I'm going to select the merge changes and delete Source but you can just go ahead and click on merge changes and manually delete it later on if you feel more comfortable so let's go ahead and click on merge so the pull request has been merged so the changes that we have proposed are now inside this collection in a nutshell this is a very simple workflow that you and your team can use when working on a postman collection in a collaborative way and you want to keep track of which changes are being made and most importantly why we are coming towards the end of the course and it is time for you to claim your Postman badge for completing this course and doing all those assignments now go to the original workspace and Fork The Collection named claim your badge inside there you'll find detailed instructions on what you need to do in order to claim that badge I hope you have been able to follow along and do all the assignments if you need any help or you got stuck please refer to the course notes for every individual assignment congratulations you reached the grand finale of this API test automation course with Postman give yourself a pat on the back or even a round of applause yes because you have earned it my friend I hope you had as much fun learning as I did teaching sure it was a bit of work but who says we can't enjoy a little brain workout right API testing and automation with Postman can be a bit of a maze but I aimed to guide you through this as smooth as possible of course some things just couldn't fit into the course but don't worry the course notes for this lesson have got you covered with both free and paid resources to help you continue your Postman Journey just like you Postman and apis are constantly growing and evolving so make sure to keep up to date in this everchanging world of API testing it was a pleasure having you throughout this course and I can't wait to see many of you proudly wearing that Postman badge on social media and when you do so don't forget to tag me it will make my day if you enjoyed this course I'll be thrilled if you could check out my YouTube channel for more amazing content and smash that subscribe button your support will keep me fired up to create more content like this one and while you're at it please show some love to the sponsor of this course Postman with that I just want to say a massive thank you for joining me in this adventure and I hope to see you again in the next one until then Happy testing with Postman
