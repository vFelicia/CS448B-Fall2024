With timestamps:

00:00 - What is up, how's it going? This is kazi from 
clever programmer calm. What I wanted to cover  
00:05 - in this series is Django. And what I wanted to 
cover was like the most commonly referenced Django  
00:17 - documentation, I personally couldn't really find 
any videos of people like covering it. So I just  
00:23 - wanted to do that. Because, you know, I see, like 
everybody who starts learning Django, this is the  
00:31 - first place you're gonna go to like the docs, 
the Django official documentation that shows you  
00:36 - how to, you know, do their getting started guide. 
And so I just want to kind of cover that in this  
00:42 - series. And just right now, I just want to kind of 
cover the overview, and then we're gonna jump into  
00:46 - actually, the parts of the tutorial, okay, and 
you're just gonna follow me along. Alright, so  
00:54 - I'm going to cover this kind of touch on this. So 
if you have some experience with it, it will make  
01:00 - a little bit of sense. So designing your models. 
So in Django, you can kind of design your database  
01:05 - and models like this, you don't need to type in 
raw SQL queries or mess with too many ora, or  
01:11 - MS is just simply classes. So it's literally 
like Python and object oriented programming,  
01:16 - and boom, you have stuff populating your database, 
which is pretty cool. It also has a built in kind  
01:24 - of API. So it says, you know, as soon as your 
models are done, the API is created on the fly,  
01:29 - no code generation necessary. Okay. So here, you 
can see that if you create a model, like let's  
01:36 - say that you're creating an app, right, it has 
reporters, and your app has articles, you know,  
01:42 - well, what you can just do is just be like, hey, 
reported, I'd objects dot all. And they'll tell  
01:47 - you how many reporters are there. For example, if 
you made a game app for like, let's say, a street  
01:52 - fighter, and you did fighter dot objects at all, 
it might say empty set, which means you didn't  
01:58 - put in any fighters yet, right. But then let's say 
you create a fighter or a reporter with the name  
02:03 - john smith, and you save it. Then when you check 
objects at all, all of a sudden, you'll say, hey,  
02:09 - reporter john smith actually does exist. So that's 
pretty cool. And a really nice way to interface  
02:16 - with it. And then also, you can search for things 
in a really easy way to so you can search in your  
02:22 - database with an ID. But you know, a lot of the 
times what a more human way to search instead of  
02:27 - an ID is like searching with, what does the name 
start with or if the name contains the word myth,  
02:34 - which Smith actually contains, and l match it. 
So then what you can do on your front end later  
02:39 - is right now like you're not going to have your 
client interface with draft from the code command  
02:44 - line, right? What you can do later is then give 
them a front end and interface so then they can  
02:49 - actually type it in the search bar and look up 
john smith or typing myth. And they'll still find  
02:55 - john smith. Kind of like when you guys go to like 
Shopify stores, or, you know, YouTube and type in  
03:02 - a videos name. And even if you're off, you'll 
still find it, it's using this contained search  
03:06 - mechanism, which Django comes built in with. 
Another thing I want to touch on is, yeah, so  
03:15 - if you have your model, you can register them in 
the admin interface with just a simple line that  
03:20 - says admin dot site dot register. And then that 
model votes lets you create the article model,  
03:25 - you can now register it in the admin interface. 
So then you can go and point and click an admin  
03:31 - interface, and then delete, or create new articles 
or whatnot, right? For example, when you have a  
03:37 - WordPress blog, you know how you have an admin 
interface there. And you can create a new blog  
03:42 - post or delete a post or edit, you have full crud 
functionality? Well, that's what it mimics by you  
03:48 - just doing this, right. And that's you creating 
code from scratch. That's kind of powerful. And  
03:53 - then, obviously, lets you design your URLs, 
right, so how do you want your URLs to be,  
04:00 - so for example, you can have it like, you know, 
my ab.com slash articles slash the year, followed  
04:09 - by whatever, right, so you can create your own 
URL, parameters, and whatever. So this is pretty  
04:16 - standard. But it looks Django lets you do it in 
a really clean way, especially with Django 2.0,  
04:23 - their new latest release. Alright, so writing 
your views is also pretty easy. You can have  
04:31 - a just like return HTTP response or HTML file you 
made. So for example, here you can see, we render  
04:39 - and return like this archive dot html file. So 
if you create a HTML file in your templates,  
04:44 - then it's going to be there. Again, if you're 
watching this and you're like, I'm a complete  
04:49 - beginner and I have no idea what the heck you're 
talking about. Don't worry. If this part is just  
04:54 - not making any sense, skip a little bit ahead to 
the part where we jump into the tutorial. This is  
04:59 - just for People who are maybe coming from other 
frameworks, and they want to grasp how Python  
05:04 - and Django is working, okay, so you do need some 
experience to understand what I'm talking about  
05:10 - here. And then yeah, templates are using, it's, 
it's using Django templates, which is kind of like  
05:18 - Jinja. I'll go into this later. So at this point, 
like, let's just get started. Alright, so for your  
05:26 - installation, all you really need to do is make 
sure you have Python installed. So for myself,  
05:32 - I got Anaconda installed, which is, which is what 
I would recommend for you. So if you do Anaconda,  
05:38 - download online, kind of install that. And that's 
pretty much all you need to go on. And then  
05:46 - obviously, install Django as well, which I'll show 
you in one second, okay. All right, and then you  
05:53 - can go ahead and create a project. So we're going 
to just get started from scratch and follow along  
05:58 - with this tutorial. So let's, let's get started. 
Okay, so I'm gonna open up my command line here.  
06:05 - So I'm just gonna open up my terminal. If you're 
watching this, you can open up your, you know,  
06:12 - CMD on Windows, or, what I recommend installing 
is cmd. Er, on your Windows. And, yeah, basically  
06:24 - just see if you have Anaconda installed. And if 
you do, and if you type in conda, this distinction  
06:30 - come up, okay. If you don't have Anaconda 
installed, that's okay, you can still follow  
06:35 - me along. But what I'm doing here is kind of like 
for best practice. So if you want to do it, like  
06:40 - the best practice way, then I recommend that you 
get conda installed here, let me just make this a  
06:46 - little bit smaller. Alright, so basically, what I 
want to do here is first, check my J. So what I'm  
06:55 - going to do is install my environment with conda. 
Okay, so I'm going to do and, again, installing  
07:05 - Anaconda. And like making you understand 
everything about virtual environments is outside  
07:10 - the scope of this specific tutorial. So you can 
look up stuff, like how to install Anaconda on  
07:16 - Windows, or how to install Anaconda on a Mac. 
But I'm just going to go ahead and do conda. Or,  
07:22 - first I'm going to create this project. So let's 
see, I'm going to go to my GitHub. Alright, what  
07:27 - I've also done is I have gone into preferences 
in my atom. And I have went in under install,  
07:35 - and I've installed terminal, platform meal ID 
terminal, and I've installed it. So then the  
07:47 - beauty of that is that when I'm coding, right, 
if I'm coding, I can just pop open my terminal,  
07:53 - right in here, and I don't have to leave my adult. 
So I will do Django admin, start project my site,  
08:06 - like that, and then go into my site. Okay, and 
then I will come over here, and I will open,  
08:16 - I'll go to GitHub, and then I'll go my site, and 
then just click that. Okay, that's about it. This  
08:25 - is just so if you guys are following along, 
like I don't want you to get confused. Okay,  
08:30 - I'm gonna open up my Chrome. So they're saying 
that this is pretty much what it should look like.  
08:37 - And for us, it does look like that, right? We have 
my site, and it has all these files inside of it,  
08:42 - and you can see my site, and it has all these 
files inside of that. Okay. Um, and then they say,  
08:50 - hey, just go ahead and run Python manage that 
py run server. So let's go ahead and give that a  
08:56 - try. So I'm gonna open up my terminal and how I do 
that how I open up the little prompt is by doing  
09:02 - Command Shift P. for you on Windows, that might 
be a different command, like maybe Ctrl Shift P.  
09:10 - But yeah, for me, that opens it up and then I 
just click terminal pops open my terminal. I'm  
09:18 - going to do conda create dash dash name. My site's 
Python is equal to 3.6. And I will activate this  
09:36 - environment. Okay, and now I will install Django. 
Okay, so if I do PIP freeze, it should show  
09:56 - me that Django and much other stuff is installed 
Jango right here, so we're good. Alright, I'm just  
10:06 - gonna make the font bigger so you guys can see it 
a lot easier. Okay, so now, we're going to try to  
10:15 - run this Python managed up py run server. And 
we will go to this URL on our chrome and see  
10:24 - if it shows us something. Okay, cool. So it says 
install works successfully congratulations. And,  
10:33 - believe it or not, this is actually pretty 
exciting, because this is the first hint  
10:42 - that your app is actually running. Okay. Now to 
this, we're going to add a lot more features to  
10:47 - it and make it really awesome. But right now, 
it's being actually served over your localhost,  
10:52 - and it's running, okay. And once we get it to a 
point where it's doing a lot of cool stuff, we'll  
10:59 - develop it locally, and then later on, or you can 
even do is and put it online, so then anybody in  
11:05 - the world can use your Django app. Let's go back. 
And let's take a look at what the tutorial is  
11:11 - telling us to do at this point. So it says that 
you should see this stuff, and we do. And then it  
11:19 - says, ignore the warning about unapplied database 
migrations for now. We'll deal with the database  
11:24 - shortly. Cool. And it says we have started Django 
development server, which is a lightweight web  
11:33 - server written purely in Python. We've included 
this with Django, so you can develop things  
11:39 - rapidly without having to deal with configuring 
a production server such as paci until you're  
11:45 - ready for production. Cool. All right. And they 
say don't use the server in anything resembling  
11:51 - a production environments tended for developing 
cool, no problem. All right. And now they want us  
11:58 - to get started on creating the polls, polls app. 
Now that your environment a project is set up,  
12:07 - you're set to start doing work. Each application 
you write in Django consists of a pure hour of a  
12:12 - Python package that follows a certain convention. 
Django comes with a utility that automatically  
12:18 - generates a basic directory structure of 
an app, so you can focus on writing code  
12:22 - rather than creating directories. Cool. All right, 
projects vs. app. So what's the difference between  
12:27 - a project and an app? Now, the cool thing with 
Django is that everything is considered an app.  
12:35 - Okay, so let's say that you create a website that 
has a blog that has an e commerce capability. Now,  
12:42 - the blog is considered a so let's say you created 
this website with Django, right, the blog would be  
12:48 - considered a Django app, and your ecommerce store 
would actually be considered a different Django  
12:56 - app. Okay. So there'll be two different apps that 
your web application is comprised of. That's how  
13:01 - Jango handles the logic. So basically, it's one 
project that has multiple apps inside of it. Okay,  
13:08 - that's pretty much what they're saying here. 
Okay, so an app is a web application that does  
13:16 - something. Okay. So a web blog system, a database 
of public records are simple pull up a project  
13:21 - is a collection of configuration apps for a 
particular website. A project can contain multiple  
13:26 - apps, an app can be in multiple projects. So you 
can have one app that you build for one project,  
13:36 - and you can actually have it in different projects 
that you're doing, which is really cool. It's like  
13:42 - plug and chug. Your apps can live anywhere on your 
Python path. In this tutorial, we will create our  
13:48 - poll app right next year, manage that py file, 
so that it can be imported as its own top level  
13:54 - module rather than a sub module of my site. Okay. 
To create your app, make sure you're in the same  
14:00 - directory as manage.py and type this command. 
Okay, so now this command Python manage that  
14:06 - py startup polls, we're going to do that, okay. 
So, we're going to break our server with Ctrl C.  
14:13 - case I did that I'm going to hit LS, and it looks 
like I'm at the same level as my manage.py file,  
14:20 - and if I had pwd, pwd will show me where I'm at. 
And now, I'm going to do Python managed.py start  
14:31 - app. And the app is called polls, I believe 
just let's just double check. Okay, so now our  
14:38 - polls app is created. And let's just take a look 
inside of polls. Polls. Okay. So inside of polls,  
14:47 - you can see that we have a bunch of Oh, actually, 
let's look right over here. It's easier that way.  
14:52 - So Paul's comes with migrations in net dot p y, 
admin apps, models, tests, views. There's a lot  
14:59 - of things That polls comes up with automatically, 
which is really nice. But a lot of this stuff is,  
15:06 - you know, just kind of empty. The main things 
that you're going to be working with is models  
15:13 - and views, okay, that's, that's the thing you're 
going to be working with like all the time,  
15:17 - when you're developing apps for yourself later, 
you're also going to be playing around quite,  
15:21 - you're going to be doing adding stuff to test 
to make sure you can test your app as you're  
15:25 - building it. And then migrations is going to 
be important, because it's going to kind of let  
15:29 - you time travel in your database. So when we keep 
making changes to your database, with migrations,  
15:35 - you can like roll forward to a certain time. 
But let's say like things get really messed up,  
15:40 - you can roll back to a previous point in time. All 
right. So the disk directory structure will how's  
15:51 - the poll application. So this is the directory 
structure that we actually saw, okay. And now they  
15:57 - want us to write our first view of view is what 
lets you go to a specific URL, and then it returns  
16:05 - some kind of response. Okay. So for example, 
so Django works off of something called MVT,  
16:11 - which is called Model View templates, your 
normal apps, you know, node.js, or whatever those  
16:19 - frameworks work off of MVC model view controller. 
So to give you an example of this in real life, is  
16:27 - when you go to google.com, slash, you know, when 
you go to google.com, and you type in like cats,  
16:34 - right? Or let's say you go to google.com. And you 
type in whatever the response that comes to you,  
16:40 - right, that maps to the current URL you're at. So 
how does Google know to show you the Google logo  
16:47 - and the Google homepage when you go to google.com? 
Right. So google.com, when you type it in,  
16:54 - it sees what your current URL path is, then it 
goes into the Google code base. And then it finds  
17:02 - this HTML file that says, if somebody goes to this 
path that says google.com, then show them this  
17:10 - HTML page that has Google's image on it, followed 
by a search bar, and then shows you that, okay,  
17:18 - so it returns a response, you request something 
and it returns a response. If you go to apple.com,  
17:26 - slash, watches, or watch, I don't know if that's 
actually a real Apple URL, but like, let's just  
17:33 - say you're trying to get an Apple Watch. Okay? So 
if you go to apple.com, slash watch, how would it  
17:38 - return to you all of their watches, right? So 
what actually happens is apple.com slash watch  
17:46 - will match that path in their code base. And then 
it'll see if there is a HTML file that corresponds  
17:54 - to it. And it'll show you that HTML file, okay, 
as a response. And that's essentially what we're  
18:00 - going to do. Well, we're going to have a very 
basic version of it. So we're going to go in our  
18:05 - poll slash views that py. So I'm in my polls, and 
I'm going to go in my views that py. So when they  
18:12 - say it, like this poll slash views that py, that's 
what they mean. And in here, I'm going to say from  
18:17 - Django dot HTTP import HTTP response. Right. And 
then I'm going to go here, I'll say define index  
18:27 - requests, take in a request, and then return 
an HTTP response. And I will say, Hello, world,  
18:38 - your ad. Let's do it with double quotes, because, 
hello, world, you're at the polls index, right.  
18:54 - And then they have a little comma here, this 
doesn't matter so much, there's just a string.  
18:59 - So it doesn't matter what you do. Make sure you 
always save what you're doing, because otherwise  
19:03 - it won't take any effect. So make sure you do 
Ctrl S or Command S the whole time. So I just  
19:11 - created this, but the thing is that it's not going 
to show up. So now what I need to do is like, tell  
19:17 - my app that when somebody goes to the home page, 
yo, you got to show this exact this thing right  
19:23 - here. Okay. This is the simplest view possible 
in Django to call the view, we need to map it  
19:30 - to a URL and for this, we need a URL con for a URL 
configuration. To create a URL confit in the polls  
19:37 - directory, create a file called URLs dot p y. Your 
app directory should now look like this. So now  
19:44 - notice there's a URLs dot p y here, which was not 
there before. Okay, so we're going to go in our  
19:51 - polls, right click here and create a new file and 
call it urls.pi. Okay, And now in our URLs, r p y,  
20:03 - we got to add from Django dot URLs, import path 
from Django dot URLs, import path. And then we're  
20:11 - going to do from import views. And then we're 
going to do URL patterns. So what you want to do  
20:24 - is try not to indent, but use four spaces instead. 
Okay? 1234 if it doesn't automatically bring you  
20:32 - to the right place. All right. And I want to 
do pass. So if somebody goes to the empty path,  
20:41 - then I want you to go into our views file and use 
the index function. And we're going to call give  
20:49 - it a name index. Okay? So what does this mean? 
If somebody goes to, let's say, your website is  
20:57 - called john, calm, right? somebody goes to john 
calm, followed by nothing else. So not like john  
21:04 - calm slash article slash blog, none of that is 
just john calm your homepage. What happens? Well,  
21:11 - then we say, going to the views file and 
run the index function. So in under views,  
21:16 - this is index function, I'll run that. We're 
naming it index. So then later, if we want to,  
21:22 - from our templates, or HTML, if you want to refer 
to this specific URL path, we can just call it by  
21:29 - index, no, reference it. Okay, the next step is 
to point the route URL configuration at the polls,  
21:37 - that URLs module. Okay, so you're all content, and 
we got to point it to this. So Alright, in my site  
21:47 - slash urls.pi, add an import for Django dot URLs 
include and insert include in the URL patterns  
21:52 - list. So you have this. So we're going to go in 
our my site slash URLs right here. And in here,  
22:00 - we're going to add this line, okay? Because we're 
saying if somebody goes to the path polls, then  
22:09 - run the polls, URLs. Okay. So from Django contrib, 
import admin from Django, import from Django dot  
22:23 - URLs, import include, comma path, okay. And that's 
because we're gonna do the include thing right  
22:32 - now, just like that. Okay, and then hit save. 
So if somebody types in john comm slash polls,  
22:40 - now we'll say, hey, try to match this pattern by 
going to the polls, our URLs file. Well, where's  
22:48 - that that's in the polls app. And it's this file 
right here. So then it'll go to this file, and  
22:53 - then it'll match this first guy, and they'll say, 
Okay, I'm going to run the home function, okay. So  
23:01 - anytime somebody goes, anything, polls will refer 
to that file, that URLs file. Alright, the, this  
23:08 - is what they're basically saying here. The include 
function allows referencing other URL cons,  
23:13 - whenever genuine counters include, it chops off 
whatever part of the URL match up to that point,  
23:18 - and sends the remaining string to the included 
URL con for further processing. The idea behind  
23:24 - include is to make it easy to plug and play URLs. 
Since poles are in their own URL client, they can  
23:30 - be placed under or any path and that will still 
work. Okay, you have now wired. So now it says,  
23:39 - You should always include, you should always use 
include when you include other URL patterns. Okay.  
23:47 - And now it says you have now wired an index view 
into the urine. Let's verify it's working. Run the  
23:52 - following command. Okay, so now we're going to run 
this thing. And we'll go to our localhost or this  
24:01 - HTTP is port over here. And hit run. And now we 
are getting an error. Oh, yes. Basically, you have  
24:15 - to do slash polls, okay, of course. Because it's 
not a home page thing that we've added to because  
24:23 - I just saw this and I was like, oh, homepage, but 
it's because we got to go to the polls path. Okay.  
24:28 - So everything after so it's like, when you put 
this online, when you put this app online, right,  
24:35 - it will essentially be like, your app comm slash 
polls, is where you'll have to go to and then I'll  
24:43 - know what to do. Okay, so let's say you're at the 
polls index. And that's exactly what we see. Now.  
24:49 - Cool. Go to this in your browser, you should 
see the text which you define in the index. The  
24:55 - path function is Pat is passed four arguments to 
require In view and to optional, at this point,  
25:02 - it's worth reviewing what these arguments are 
for. Alright, so we're not going to go into  
25:06 - too much detail is going to be like still casual, 
and we're gonna keep moving forward. We're gonna  
25:14 - do part two of the official Django tutorial, we 
have already done quite a bit of stuff, right,  
25:21 - we've gotten our local servers started. But what 
we want to do now is in this video, we're gonna  
25:28 - actually cover our admin interface, and we're 
gonna actually start playing around with it.  
25:33 - So it's gonna be pretty exciting. I hope you're 
willing and excited to see how that works. Okay,  
25:39 - and we're going to go through this one a little 
bit faster. So Okay, so first thing we want to  
25:44 - do is like, look at the database setup, which you 
can, frankly ignore if you're new. But later on,  
25:50 - like, this is something that you should read. 
But for now, we're only going to focus on this  
25:56 - command that says Python managed up, py migrate. 
Okay, so this is a complete continuation from the  
26:01 - last video, okay, so make sure you're caught 
up on everything from part one, I'm gonna open  
26:06 - up Adam. And I'm going to break out of this by 
doing Ctrl. C, and I will do Python managed up,  
26:11 - py migrate, and it should give you a bunch of 
okays. And what that did is created these tables  
26:18 - that weren't created before, okay. So they're all 
created, like stuff with usernames and emails, and  
26:25 - permissions and all the stuff that it has to do 
on the back end. Okay. All right. And from here,  
26:35 - we're going to go on, and we're going to try to 
now create models. Alright, so we'll define your  
26:40 - models, essentially, your database layout with 
some additional metadata. How Django models work  
26:50 - is their philosophy follows the DRI principle, 
which stands for do not repeat yourself,  
26:55 - which is a really common, commonly used acronym 
in the programming world. And it emphasizes using  
27:03 - logic that helps you never really repeat yourself, 
right. So for example, just to give you a simple  
27:11 - example, imagine if you had to print out a letter 
or print out the word Boom, 100 times, you could  
27:21 - keep writing print, boom, print, boom, print, 
boom. Or you could do it in the dry way, which  
27:27 - is write a for loop that prints it out 100 times, 
okay? So that way, it allows you to stop yourself  
27:34 - from repeating, and just helps you do it at once. 
Now, when you start abstracting it and taking it  
27:40 - to a higher level, that might mean taking your 
code from basic, basic code, and modularizing it  
27:47 - into a function or into a class or into a package, 
things of that nature, okay. And that's the same  
27:53 - philosophy Jango goes off on so instead of like, 
repeating yourself over and over again, it lets  
27:57 - you create a class, which then creates models out 
of and handles a lot of that stuff for you. Okay,  
28:04 - so we're going to create this these models, okay, 
and basically what we're going to be working on in  
28:10 - our simple poll app, we're going to create two 
models question and a choice. A question as a  
28:16 - question and a publication dates, almost imagine 
like a spreadsheet. Let's say you create a new  
28:21 - sheet in the spreadsheet and you call the sheet 
question. You have column one that says question  
28:26 - tax, column two that has a publication date. So 
question tax on your first row might be, what the  
28:33 - hell is going on? And the publication date may be 
like, February, whatever. And your next question  
28:38 - might be like, when is causing you going to make 
the next piece of content, stop making all these  
28:43 - crazy videos where he's outside talking to the 
camera, and then your publication date next to it,  
28:48 - right? So that's how I want you to picture when 
we create these models. Alright, with that said,  
28:56 - let's move on. Our choice is going to be its own 
spreadsheet or its own sheet. Okay. And basically,  
29:02 - what it does is a choice has two fields, the text 
of the choice and a vote Tally. Okay. So the chat  
29:08 - text and the vote Tally. And then the question 
that you get to choose is actually referenced  
29:15 - from the question model. Okay, so let's actually 
now write this code out. So let's go to our polls.  
29:21 - And I'm just going to copy paste it, I recommend 
that you actually write it out because it's really  
29:26 - helpful exercise for you. But just for a time, I'm 
going to go through it faster, we're going to put  
29:33 - it I'm going to paste it right here. Okay, 
I'm going to save it. Alright. Now we have to  
29:42 - activate our models. Okay, so I'm going to go into 
my settings, my site slash settings. And inside of  
29:50 - here, I want to tell Django that we actually have 
this app installed. Okay. So what I want to do is  
29:58 - polls dot apps dot, I think it's polls config like 
that, okay, and make sure to put a comma after  
30:07 - it because after all it is a list with 1234567 
elements. Okay, so now Django knows to include  
30:18 - the polls app, let's run another command. So up 
until now Django had no idea what this thing that  
30:23 - you created this polls app. But now that you went 
in my site and added this under settings and added  
30:29 - to your installed apps, now it knows that it's 
actually there. Okay. It's the equivalent of kind  
30:34 - of like, let's say you downloaded an app on your 
Mac or your windows, but you never installed it,  
30:40 - right, like downloaded a game, but you never 
installed it's kind of like that. So we just  
30:45 - installed it by doing this. Okay, and now what we 
want to do is let's run another command, Python,  
30:51 - manage that py make migrations polls, okay? So I'm 
going to come in to my command line. And again,  
30:58 - to activate your virtual environment, you'll 
do source activate, followed by the name of  
31:04 - your virtual environment. And to deactivate your 
virtual environment, you will do source deactivate  
31:10 - if you're on a Mac, if you're on Windows, and all 
you need to do is activate, followed by the name  
31:15 - of your virtual environment. So in this case, 
it will be my site. Okay, so since I'm already  
31:22 - activated on my virtual environment, I'm just 
going to do Python manage that py make migrations,  
31:28 - poles. And now you see that it says Create model 
choice, create model question, add field question  
31:37 - to choice, okay. All right. By running make 
migrations, you're telling Django that you've made  
31:47 - some changes to your models, in this case, you've 
made new ones, and that you'd like to change this  
31:52 - to be stored as a migration. Cool. And this is 
effectively what the sequel will look like for  
31:59 - this. So this is not something you have to worry 
about. If you're a beginner, and you don't even  
32:03 - know what SQL is totally fine. But if you have 
a little bit of experience, check it out. What's  
32:08 - really cool is like a bunch of this code that you 
would normally add, like generally anything to do  
32:13 - with databases requires you to know SQL or write 
SQL, okay, SQL. And for you to write raw SQL,  
32:22 - it looks pretty complicated, right? Like, for 
example, if you go here, there's a lot going on.  
32:27 - If you write SQL every day may not be that big of 
a deal, but it's a lot going on. Whereas Django,  
32:34 - it's automatically generating all this code for 
you. And you don't actually even have to worry  
32:39 - about it, I just showed it to you. So you can see 
what it actually looks like, on the back end. So  
32:45 - that's what they're showing here. And we're not 
just gonna, we're not going to worry about that.  
32:51 - And since we made the migrations, we're going 
to commit those migrations to our database by  
32:55 - doing Python managed.pi and typing in migrate. 
Okay, so now it says applying polls initial,  
33:02 - and it says, Okay, if I go to my migrations, I 
can also see this specific migration that I made,  
33:08 - okay, and I can read this migration whenever I 
want. Do not mess around with this file too much  
33:13 - unless you know exactly what you're doing. Okay, 
cool. And now we're going to play with the API.  
33:22 - Another thing about migrations, when you get 
a little bit more advanced, it allows you to  
33:27 - update your database without ever losing track 
of it. So flask has kind of a weird migration  
33:33 - thing going on, whereas Django kind of comes with 
it. And so it's databases a lot easier to play  
33:39 - around with. Like it says, migrations are very 
powerful that you choose your models over time,  
33:45 - as you develop your project without the need 
to delete your database or tables and make new  
33:49 - ones. That's generally what you have to do. If 
you're working with, you know, like just kind of  
33:55 - working from scratch. It specializes in upgrading 
your database live without losing data. So again,  
34:02 - this is going to be really powerful and helpful as 
you get more advanced. And as you do more things  
34:06 - with models. So now let's play around with the 
API that actually Django gives to us for free.  
34:14 - Alright, so we don't actually have to write it, it 
just kind of comes with it. So I'm going to go and  
34:19 - instead of just typing in Python, I'm going to do 
Python manage.py shell, okay. And here, I will do  
34:30 - from polls on models, import question, comma, 
choice. And then now we can play around with  
34:38 - it. So since we don't have any questions in our 
system yet, when we actually look up questions,  
34:43 - and the objects for it, it should show us 
empty, right, because we didn't create any  
34:48 - thing from in the question model. Guess if I do 
this at all. It should show us none. And that's  
34:55 - exactly what is showing us like, hey, the query 
set is actually empty. Now what we want to do is  
35:00 - create a new question. All right. Django expects 
a time date use time. So now instead of this and  
35:08 - it will do the right thing. Okay, so we're gonna 
go from Django dot utils import timezone. Okay.  
35:15 - And what does our question take? Remember, if we 
look in our questions model, it takes two things.  
35:23 - It takes a question tax and a publication date. 
And that's what we want to give it to create a  
35:30 - new question object, okay. So pretty much typed 
that in what is it saying? It's saying, Hey,  
35:38 - I'm creating a question object. This question. 
Class essentially takes in a few things, question  
35:49 - tax and publication date, and I'm using keyword 
arguments. So I'm putting question underscore  
35:54 - text equals. So for the question text, it takes in 
a car field. So let's go actually here in models,  
36:02 - and you can see that it takes in a character field 
right here. And that's why I'm actually passing it  
36:07 - in as a string. And then publication date takes 
in date time field, and that's why I'm passing  
36:12 - in the timezone dot now, object, okay. And just 
gonna hit enter here, and now, Q is created. So  
36:23 - I should be able to do something like, well, let's 
follow along with their documentation is saying,  
36:30 - but if we actually do this now, right question 
that objects dot all let's see if it shows us. So  
36:36 - that's because we haven't saved this yet. So once 
we save it, it's going to show up in our as one  
36:42 - of our created objects for a question. So let's 
follow along. So now it says, save the object into  
36:48 - the database, you have to call save explicitly. 
So we're going to do that I'm going to say q dot  
36:52 - save. And let's try it again. And now look, it 
shows us that there is indeed one question and  
37:02 - that even has a number an extra one. Okay, but 
it's not very helpful, because it's not showing  
37:08 - us what that question is. Or it's not giving us 
a very easily readable name when we actually use  
37:14 - this API. So I'll show you guys how to overcome 
that, too. Alright, so now it has an ID if you do  
37:22 - q.id, it'll show you its ID. It says access model 
field values via Python attributes. So I could  
37:30 - do q question, tax. So that question text right 
there. And they'll show us like, what's new, and I  
37:37 - can do q dot pub location, date. And they'll show 
me the date as a date time object 2018 two, which  
37:47 - is February 19. And let's go down here. And we can 
even change the values by changing the attributes  
37:58 - and then calling save on it. Okay. So for example, 
before we had the question, that's what's new,  
38:04 - we can now save that question as What's up, okay. 
So for example, I can do cute question, underscore  
38:11 - text is equal to what's up kids at home. And I can 
do q dot save. And now if I do Q, question, text,  
38:24 - you'll see that it actually says what's up, right? 
displays all the questions in the database. So now  
38:32 - if I again, do this, which you've seen, it'll 
show me all of the questions right. Now we only  
38:37 - have one question. Okay. So if I wanted to add 
multiple questions, I could do that. You know,  
38:45 - let's say that we add q2. And then I do q three, 
and then I go right over here. Instead of saying  
38:57 - what's new, say what's poppin that, hit Enter. And 
now if I do question dot objects, dot all you can  
39:09 - see that it shows me Oh, sorry, I have to save q2 
dot save q three dot save. And now if I do this,  
39:18 - you'll see that it shows me I've one question 
two questions, three questions. And I can even  
39:24 - say for a question and question dot objects 
dot all I can loop through it, print question,  
39:38 - dot question underscore text like that. And if I 
run that, it'll loop through all of these and then  
39:46 - they'll print out the question text, okay, so you 
can do it. This is just like playing around with  
39:52 - xAPI and kind of getting comfortable with it. 
Okay, and it's close. Wait a minute. Question  
39:58 - isn't a helpful representation. You know this 
object? So let's fix that by editing the question  
40:03 - model in the thing. So that's what I was talking 
about, right? Like, they're saying it in their  
40:10 - technical terms. Basically what they're saying 
is like, hey, look, this looks ugly as hell,  
40:13 - and doesn't give us any information like what 
this is about. So let's make it into something  
40:19 - that a human can read and be like, Okay, I 
get what this question is, and it's readable,  
40:24 - right? So that's what we want to do. All 
we need to do is add a string method. Okay,  
40:30 - so we're going to add string representation to 
it, you'll see what I mean, in just a second. So  
40:35 - right now just shows us like, blob like whatever, 
right? Well, we're going to do is under the class  
40:41 - question, we're going to add string method like 
that. Okay. And it's going to take in self, and  
40:50 - then we're going to say return self dot question 
underscore text, like that. Okay. So instead of  
40:57 - showing us this, wouldn't it be nicer if it showed 
us that question? Because that's a much easier way  
41:03 - of identifying what that question is, when you're 
just looking at the list. It's just more readable  
41:09 - that way, okay. And we're going to do the same 
thing with choice, we're just going to go here,  
41:15 - create a function, or create a method, because 
we're inside of a class. And I also self and I'm  
41:23 - going to say return. So self dot, what do I want 
to do here? choice underscore tax. All right. And  
41:32 - I don't think I have to here. Let's try it. Okay, 
cool. So now, it's important to add string methods  
41:47 - to your models, not only for your convenience, own 
convenience when dealing with interactive prom,  
41:51 - but also because object representations are used 
throughout Django is automatically generated  
41:56 - admin. So later, when we go and I show you the 
admin, this is actually going to be helpful there.  
42:03 - Because then when we're reading these names, the 
admin is going to be using it. All the however,  
42:10 - we're showing it in the console right now is going 
to be showing it on our admin interface, right. So  
42:16 - like, imagine, if you create an app, and you give 
it to your client, where it's like a blogging app,  
42:23 - right, or if it's an e commerce app, you don't 
want them to go to the store. And when they're  
42:30 - trying to differentiate between items, it just 
says item one, item two, item three, item four,  
42:34 - it'd be much nicer if it says, like bicycle, or 
watch or iPhone x or whatever they're selling,  
42:42 - right? It'll be easier for them to identify. 
That's essentially what we're doing right  
42:45 - here. Note that these are normal Python methods, 
let's add a custom method just for demonstration.  
42:53 - So they're adding a new method here. So we're 
going to do that I'm going to go into my models,  
42:59 - and we will import date time at the top. And 
then we're also going to import timezone. Oops,  
43:09 - right underneath this guy. And we will add 
this method under a question. Okay. Okay,  
43:18 - so was published recently is a method in the 
question class, so you can do like q dance was  
43:25 - published recently. And it will tell you what it's 
going to do is going to basically tell you true or  
43:30 - false, okay, so I think what it's checking for is 
like if it was published within one day, or later  
43:37 - than 24 hours, let's see what they say. No, the 
addition of import and to and from Django, import  
43:45 - timezone. to reference Python standard date time 
module on Django is timezone related utilities,  
43:51 - respectively. save these changes and start a new 
Python interactive shell by running Python managed  
43:58 - up py shell again. Now, because we didn't make any 
changes to the models, we just added new methods,  
44:06 - we don't have to migrate this to our database, all 
we need to do just like exit out of this shell and  
44:12 - just like, come to it again, I'm gonna do exit 
open closed paren. And I'm just gonna do Python  
44:18 - manage that py shell again. And then let's see 
if we can get that command from poles or models.  
44:28 - So basically, from this file polls dot models, 
I'm importing this class question and this model  
44:37 - choice model, both are models, classes, whatever. 
And make sure our string our addition is working.  
44:46 - Okay, so now we're going to try to do the same 
thing except this time, it's not going to show  
44:50 - us question whatever is gonna actually show us the 
text of each question. So there you go. What's up,  
44:56 - what's new, what's poppin Okay, much easier for 
To see this Okay, so again think of it like if  
45:04 - you had a fighter database instead of it saying 
fighter one fighter to fighter three, it show it  
45:09 - to as like can write you and like say got Django 
provides a rich database lookup API is entirely  
45:17 - driven by keyword arguments. Okay, so you can do 
something like, hey, I want you to filter by where  
45:23 - the ID is one. So give me that specific question 
only, or I can say filter by 82. And it'll give  
45:29 - me the question that has ID of two, okay? Or I can 
filter by question tax that says new inside of it,  
45:36 - or what's new inside of it? Just like it's showing 
me here, like, if so let's try this one. Okay. So  
45:46 - question text starts with what? Okay, so let's 
see. So far, all of these start with a what? So  
45:52 - it's going to show us all three. But what if I do 
instead of starts with I say contains? And I say,  
46:01 - often? Okay, there's only one question 
that contains that, okay, then later,  
46:08 - we can provide a front end to our client where 
you can like, in the search bar, type it in,  
46:14 - but on the back end, we're using this contains 
method to find the exact thing that you need,  
46:21 - and then return it as a response from our HTML 
file. Get the question that was published this  
46:29 - year. Okay. So let's get the question as published 
this year, we're gonna do this. We're gonna say  
46:35 - current year is timezone. Now that year, so 
that's going to get basically 2018. Right? If  
46:42 - I do current year, it'll say 2018. And question 
that objects I get, where the publication date,  
46:50 - year is the current year. Okay. So let's do that. 
Get returned more than one question or turn three.  
47:04 - So because we have multiple questions, instead of 
one, RS is going to be different than theirs very  
47:12 - slightly. Okay. So for ours, since it matches 
all of them and gets like Yo, what's going on,  
47:17 - I'm matching all of them. So but nothing to worry 
about, it's still working for us. If you request  
47:24 - an ID that doesn't doesn't exist, it will raise 
an exception. So for us, we do have ID two, so  
47:29 - it won't raise an exception. But like, let's say 
that we try to find something with an ID of four,  
47:34 - or five. Sorry, we have to do dot get is going to 
raise an exception, okay. Also, for this, let's  
47:51 - try. So what would happen if instead of dot get 
we use filter? Would we get an error? Or would we  
47:57 - get something in return, we would get something in 
return, which is like, all of these that match it.  
48:02 - Okay? So the difference between filter is like, 
return everything that matches and get is like  
48:08 - get one. And if more than one match, then like 
throwing an error or something like that. Okay,  
48:16 - so look up by a primary key is the most common use 
case. So Django provides a shortcut for a primary  
48:24 - key lookups a falling question. The following is 
identical to questions that objects dot get ID,  
48:29 - so PK, which is a primary key. Okay, so every 
model will have a primary key. So for example,  
48:39 - question we'll have a primary key choice, we'll 
have a primary Kanda think about this is like,  
48:44 - let's say you have a database with people in it 
right? or employee names. But what if you have two  
48:51 - john smith employees, right out of 100? employees? 
Or what if you have two Apple watches in your  
48:56 - ecommerce store that you're selling, that are the 
same name? Or the two people that have the same  
49:01 - name? How are you going to differentiate? What 
if they have the same email address or whatever,  
49:06 - right? So you need one thing that's always always 
always always unique. So if you can't rely on  
49:11 - their first name, last name, or email address, 
or whatever else, one thing you can always rely  
49:16 - on is a primary key. It could be an automatically 
generated key from Python and could be like random  
49:24 - words or whatever, right? Django will handle 
the primary keys for you Everything will have  
49:30 - a primary key even if it doesn't show it to you 
on the back end. This way, you can always find,  
49:37 - you know, the unique way of referring to 
something, okay. All right. So let's go  
49:46 - here saying that makes sure our custom method 
worked. So it says cute dogs that get PK one,  
49:53 - okay, so basically what I'm going to do is go 
here and say hey, Get me the object where the  
50:01 - primary key is one and save it as Q. And now I'm 
going to ask if q was published recently. Okay,  
50:10 - and it says true. Okay, cool. So that's the result 
we got. Give the question question a couple of  
50:18 - choices. The create call constructs a new choice 
object does insert statement as the choices  
50:25 - set available choice and returns a new choice 
object. Django creates a set to hold other side  
50:31 - of foreign key relation questions for which can 
be accessed via the API. Alright, so we're gonna  
50:37 - do this guy again. If you haven't done so already, 
display any choices from the related objects set,  
50:45 - so we don't have any choices so far. Okay. We're 
right now basically voting for questions kind of  
50:54 - like you can upvote comments on YouTube. So 
now we're going to create three choices. So  
51:02 - cue that choice that create. So we're going to 
take a question, which is our first question,  
51:08 - which was like, what's up? And we're going to 
create choice taxes equal to not much with zero  
51:15 - votes. Okay, and you can see choice has a field 
called votes, and then it has choice tax. So our  
51:25 - first answer to that question, what's up is not 
much. But we're saying like, Look, it only has  
51:32 - zero votes. Okay. Okay. And now we're going 
to create another choice, but called the sky,  
51:49 - what's up the sky? I mean, I guess that's kind of 
funny. I say the ceiling. And then here's another  
51:57 - one that is, and we're going to store this one 
actually. As see, Oh, okay. There we go. Okay,  
52:21 - so now choice objects have API access to their 
related question objects, because then if I do see  
52:27 - that question. So even though I've created this 
model from choice, you know, you'd be looking,  
52:35 - I be like, hey, how does it have access to the 
specific question like, how did it access this  
52:40 - field? Here's how I did it. Because we're saying, 
in this question, go to the foreign key, and the  
52:48 - foreign key is this model over here. When I do 
choice question, it'll go and get the question  
52:56 - from up there. That's essentially what it's doing. 
Okay. So that's what, when I do see that question,  
53:01 - that's what's happening. It's referencing and 
getting me back this object. Okay. And vice versa.  
53:09 - So you can also reference from question you could 
reference choice. Question objects had access to  
53:16 - choice objects, okay. So they both have access to 
each other kind of like, you can have a book and,  
53:22 - you know, like, who was the author of this book. 
So that relation goes to the author. And then  
53:29 - you can say, like, this author has which books 
and it can relate back to the books. Alright,  
53:35 - so now we're going to see how many choices we 
have. And so we have not much is one choice,  
53:45 - the other one we have is the sky. And then the 
other choice that we have is just hacking again,  
53:52 - all of these have zero votes, as we see right 
here. And we're gonna say q dot choice underscore  
54:00 - set counts. So this is just a count that there 
are actually three choices. The API automatically  
54:11 - follows relationships as far as you need us double 
underscores to separate relationships. This works  
54:16 - as many levels deep as you want. There's no 
limit, find all choices for any questions whose  
54:21 - publication date is in this year, we're using 
the current year variable we created above,  
54:26 - okay. So I can say choice that objects or 
filter, question. Double underscore means like,  
54:34 - you are kind of going backwards. So we're saying 
question, and then we're going publication date.  
54:43 - Okay, so actually, we're going this question 
here, and then we're going to publication date,  
54:48 - and then checking the year getting the year of 
that publication date. Okay. So let's try that  
54:56 - right over here. So it's going to get us all the 
way questions that are from this current year.  
55:03 - So it should get us all three of these. Let's 
delete one of the choices use delete for that.  
55:10 - So now what I can say is, I can get the question 
that starts with just hacking. Right? And how do  
55:20 - I do that? I say cue that choice set da filter by 
where choice text starts with just hacking. Okay,  
55:30 - so it's only going to get one question that 
has just hacking in there. And if I do see,  
55:35 - I'll show you which one it is. And now to 
deleted all I do is see dot delete. Again,  
55:42 - I'm copy pasting, copying and pasting for time, 
purposes, saving time, but for yourself, like  
55:51 - take the time to actually write all of this out, 
because it's very, very helpful for you. So now  
55:58 - that I deleted, it showed me that it's deleted. 
And if we actually check again, right, it'll only  
56:05 - show us these two choices right here. Okay. Now, 
we're going to get into a pretty exciting part,  
56:16 - which is introducing the Django admin and we're 
actually going to just touch on it a little  
56:20 - bit. And let's get started. This is a super cool 
part. philosophies of generating admin sites for  
56:28 - your staff or clients to add, change and delete 
content is tedious work that doesn't require much  
56:34 - creativity, okay? is usually like a pretty rinse 
and repeat process. It's frustrating, it's boring.  
56:41 - You can make mistakes, it takes a lot of time, and 
development, and which means like, it'll cost your  
56:49 - client a lot. And it slows down your development 
speed. For that reason, Django entirely automates  
56:56 - creation of admin interfaces for models. Okay, 
so let's check it out. The admin isn't intended  
57:04 - intended to be used by site visitors, it's for 
site managers. Okay. So now we're going to create  
57:11 - an admin user, I'm going to do Python, manage 
that py create. So we're going to exit out of this  
57:18 - and do Python, manage that py, create super user. 
And I'll leave this blank, I'll use this email.  
57:30 - And even though it's not gonna show you anything 
here, it's still typing in your password. So don't  
57:36 - worry about that. Okay, so you can put in whatever 
as your email, whatever is your username. And now  
57:44 - the final step is to answer enter your password 
I have. And now it says start the development  
57:49 - server. So we're going to do just that. I'm going 
to start the development server, we're going to go  
57:54 - to Chrome, we're going to go to our local app on 
127 dot 0.01, colon 8000 port, instead of polls,  
58:03 - I'm actually going to go to admin. And when I go 
to admin, look, it brought up this nice interface  
58:10 - that you and I did not make, we didn't make this 
beautiful looking form, where when you hover over  
58:17 - log in it, like turns dark and looks good. And 
we didn't add functionality that add security,  
58:28 - right? We didn't add this thing where passwords 
automatically looks like dots so nobody can see  
58:35 - it. All of this keep in mind is just automatically 
generated. When I click login, boom, here's the  
58:42 - administrator interface. Okay, so as the admin, 
you can change your password, you can log out,  
58:49 - you can check what who are the users. So here's 
one user, you can like, go into this user and like  
58:55 - delete this user, or change the permissions of 
this user, right? So you can go in and like boom,  
59:03 - it's not a super user anymore, or is not a staff 
anymore. It's not active anymore. Or you can go in  
59:09 - here and like change all kinds of permissions, 
like can delete choice can add a question but  
59:14 - cannot like delete a question can change a 
session, but cannot delete a content type,  
59:20 - you know, you can get like as specific with it 
as you want. And this is just for the model that  
59:28 - we have registered new users. But imagine later 
when if we register our choice model and whatever,  
59:34 - those will all show up right over here. And any 
recent actions that you do actually show up on the  
59:39 - right hand side. So imagine like somebody deleted 
something, you're like, what the hell happened,  
59:44 - like, one part of our app or this website is 
now broken? Well, if you go into recent actions,  
59:50 - you'll see what took place and exactly who did 
it and who to hold responsible for that. I think  
59:55 - that's pretty cool. Right and it comes built in 
right out of the gate. That's one of the reasons  
60:01 - why Django is such a powerful tool. And it fosters 
productivity and effectiveness. I believe over any  
60:10 - other framework, right. And their tagline, which 
is awesome. It's for Django is for perfectionist  
60:17 - with deadlines. That's what I believe in to 
like, if I have to put a project together,  
60:21 - and I'm doing something solo, I'm going 
Django, all day baby. But you know,  
60:27 - if you're working on some long term project, you 
know, you're going to be doing for a long time,  
60:33 - and nothing else really matters, then yeah, you 
can choose whatever you want. But I like speed,  
60:37 - I like productivity, I like to take my ideas from 
my head and launch them online fast. Alright,  
60:43 - with that said, let's go back and see what 
they're saying. So we go to our admin,  
60:50 - enter the admin site. And now it says, make 
the poll app modifiable in the admin. How  
60:55 - do we do that? We're going to take these three 
lines of code. So I'm going to go into my polls  
61:00 - slash admin. And this line is already added. 
So I'm not going to add it in from dot models,  
61:08 - import question. Okay. So basically, what I'm 
saying is from this directory, get the models,  
61:16 - so right here. And import the class question from 
the models. Okay, so import the question model.  
61:26 - And then I'm going to say, registered that model 
inside of admin. So check out what happens. Okay,  
61:34 - this is super, super cool. Check it out. I'm 
gonna hit save. And let's go back to our app.  
61:44 - And let's hit refresh. And look at that. It's 
here. That questions model is the one we made,  
61:51 - it shows under polls, questions, and you can see 
all of those questions. What's poppin? What's new,  
61:57 - you can go in and you can change the text. So I 
can change it to like, what's cracking? Right,  
62:06 - I can hit save. And now it's changed. And if I 
go to my, if I start Python managed up py shell.  
62:15 - From polls, dot models, import question. Question 
objects. All right, look, it says what's cracking.  
62:32 - So what we actually changed from the GUI interface 
with our mouse, and our keyboard is now showing up  
62:39 - in our database in our local database, SQL lite 
database actually being stored on our computer,  
62:45 - this database is not online yet. So pretty freakin 
cool, right? How quickly and how effectively  
62:53 - works. So I'm going to exit out of this, I'm going 
to run my server again. And we're going to go back  
62:59 - to the app refresh. Cool. And like, let's see 
what they're saying. Now that we have registered  
63:06 - question, Django knows that it should be displayed 
on the admin index page. And it is right and I  
63:11 - showed it to you. And we went inside of it. And 
we saw question tax and we saw date published  
63:16 - and we can actually change the date published 
and everything. Now things to note here, the  
63:21 - form is automatically generated from the question 
model. So this form is automatically generated,  
63:28 - we didn't generate anything, the different model 
field types, date, time field and car field. So  
63:34 - remember, we had one of the models as a date 
time field, and the other one is car field.  
63:40 - And you can see where it says date published 
load Date field, right? And for question,  
63:45 - text is just a straight up character field, 
or what you know, in Python to be as a string.  
63:51 - These correspond to the appropriate HTML input 
widget, each type of field knows how to display  
63:58 - itself in the Django admin. Pretty cool. Each day 
time field gets free JavaScript shortcuts, whoo,  
64:05 - free JavaScript shortcuts. That's awesome, too. 
Normally, you'd have to write JavaScript for all  
64:11 - this stuff, but like, look at this, okay, so let's 
say I go to what's cracking, and I click here,  
64:15 - boom, look at this beautiful date time picker 
thing opens up, and you could pick today, or you  
64:21 - could pick another date, and like automatically 
pick it and you could pick the time. And that's  
64:27 - cool. This is this is something you'd have to 
write a lot of manual JavaScript for, that's  
64:32 - automatically written for you. Dates get it today, 
shortcut and calendar pop up and times get a now  
64:39 - shortcut and convenient pop up that lists commonly 
entered times. The bottom part of the page gives  
64:44 - you a couple of options, right? So save saves 
changes and returns the change list page for this  
64:50 - type of object. So you can do save, or you can do 
save and continue editing. So continue editing the  
64:55 - same page or you can just save and add another 
add a new question. Right. Or you can do delete,  
65:02 - which displays a delete confirmation page. So 
check this out, okay? Normally when you hit,  
65:07 - you have to add all this functionality. Plus 
when you hit delete, you have to then remember to  
65:12 - add a confirmation thing to it. And they have it 
automatically. So if I hit delete, it'll be like,  
65:17 - are you sure you want to delete the question? 
what's cracking? All of the following related  
65:23 - items will be deleted. Questions, one. So only one 
question and objects. What's cracking? You can say  
65:30 - yes, I'm sure or no, take me back. Now notice, 
it's showing the question is what's cracking?  
65:36 - That's because of your string method that you 
added your str method. If you did not have that,  
65:41 - it would not show like what's cracking, it was 
show like question one. And you just have to use  
65:46 - your memory to remember that. I'm going to say 
no, take me back, and it'll take me back. Okay.  
65:50 - Cool. Let's go back. Let's see what they're saying 
here. And then if the value of the date published  
65:59 - doesn't match the time you create it, it probably 
means you forgot to set the time. We can also set  
66:05 - the current timezone, right. So that's not a big 
deal. If I go in history here, it says I changed  
66:12 - at 3am. It's not 3am right now. So that means 
like, I need to go inside of my settings and  
66:18 - in my timezone and change what my timezone is. 
So for example, I think there's like, America  
66:26 - slash Los Angeles, something like that. Oh, 
actually work sweet. for yourself, just look up  
66:35 - like timezone Django timezone settings, and then 
find yours and put that in for me, I put this in,  
66:43 - and it fixed my time instantly, right. Okay, so 
yeah, I essentially that's it for part two. We're  
66:56 - gonna jump into part three. And we're gonna get 
started. So if you haven't already open up, Adam,  
67:04 - go to where you created your mind site project, 
right? For me, it was in GitHub, my site,  
67:10 - I'm going to click Open. And I'm going to say, 
whatever open and recover state. Cool. And here  
67:17 - it is. And then if I do command, shift P and type 
in Terminal, my terminal pops up. But uh, bam,  
67:23 - and also make sure to do source activate my site. 
And we are good. Okay, so writing your first  
67:34 - Django app, part three. So what they're talking 
about here, is they're saying, okay, like, Look,  
67:40 - you have everything in Jango is essentially 
called a view. Okay? So for example, if you  
67:47 - have a blog homepage, that's a view, if you have 
the ability to comment, like a comment action,  
67:53 - right? That's considered a view. If you click 
on a blog post, and it shows you the details we  
67:59 - refer to that is a detail page, but that's still 
part of the view. That's essentially what they're  
68:04 - saying right over here. Another example of this 
is like, let's say I take you to Instagram. So  
68:10 - let's say I click on clever kasi, right? This is 
essentially for Instagram. And let me just plug  
68:16 - my Instagram here to go follow me if you aren't 
already. Because awesome. And if you go here,  
68:22 - right, like, Look, this is the home page for all 
my posts, okay, this would be considered the home  
68:29 - page view. If I click into it, that's considered 
a detail view, because it's only showing that one  
68:36 - particular post, okay, if I click here, that's 
a comment action, which is, you know, you can  
68:42 - work that into the views. So just wanted to show 
you that. So you understand where all of this is  
68:49 - coming from. Now, we come over here, and that's 
now they're saying that in our poll application,  
68:54 - we're essentially going to have an index page in 
our views. So this is going to display the latest  
69:00 - few questions. We're going to have a detail page, 
which is going to display a tax with no results,  
69:08 - but with a form to vote. So when you click so 
like, you come in you a bunch of questions, you  
69:12 - click on a question, and then boom, it has like 
ability to vote it up and down. Okay, I assume.  
69:17 - And we have a question results page. So it's going 
to display the result for a particular question.  
69:22 - How did that question do? How many votes it got? 
And then we have vote action. So handles voting  
69:29 - for a particular choice in a particular question. 
Okay, cool. All right. So now, we kind of know  
69:38 - that we're going to be creating like these things. 
Okay. We're going to be creating an index homepage  
69:43 - detail and results. And also what they're saying 
over on this part. Is it saying like, Hey, man,  
69:49 - have you ever seen really ugly URLs like this? 
Well, don't worry, because in Django, you can  
69:57 - make them really beautiful. So you can Have them 
like this instead, like john smith comm slash news  
70:03 - archives slash 2018 slash two or slash February, 
whatever. And you can make them look really nice.  
70:11 - How does it work? It works off of URL concepts or 
your current URL configuration mapping, okay? So  
70:18 - you map URL patterns to views. So somebody goes 
to this URL, it knows which view to run. Alright,  
70:26 - so now we're going to write more views. Okay, 
so we're going to write these guys here. Again,  
70:30 - I'm just going to copy it and talk about it for 
you, I encourage you to type it all out and walk  
70:36 - through it. Okay, I'm just going to highlight the 
main parts, I'm going to go in my poll slash views  
70:40 - that p y. So in polls, I'm going to go inside 
of views are actually we're going to leave the  
70:45 - index for now. paste it here. Okay. So now we 
got detail, we got results, and we got vote. Did  
70:52 - everything always takes in a request object? Okay, 
a request is passed whenever you do anything. I'm  
71:00 - not going to touch on too much right now. But this 
is a first parameter you kind of always put in.  
71:05 - And then as your second parameter, we're putting 
in the specific question ID this way, we can look  
71:10 - up that particular question from the database. 
So let's say you wanted to look up a blog post,  
71:15 - right? So you have multiple blog posts, you want 
to be able to look up a specific one? Well, we're  
71:20 - going to use ID for that. And in this case, our 
ID is our primary key. And that will allow us to  
71:26 - look up that unique thing, or in Instagrams case, 
it allowed us to look up that unique post. Okay,  
71:33 - cool. Now, what we want to do is wire these 
new views into the polls dot URLs module,  
71:39 - but adding the following path calls, okay, so 
that's what it's showing here. I'm going to call,  
71:45 - I'm going to copy this and I'm going to paste it 
into our polls slash URLs up here. Go slash URLs  
71:51 - and paste it here. Alright, so what does this 
mean? If you just go to slash polls, right,  
71:57 - so john smith comm slash polls, it's going to run 
this thing is going to match the empty pattern  
72:03 - after polls. And then it's going to run the views 
dot index function, okay? If you go to polls,  
72:12 - slash, if you want to go to something like 
polls, slash five, or Instagram post slash,  
72:16 - whatever your post is, right? If you want to 
build to do that, you want a pattern that can  
72:24 - match that, okay. So if I put in 20, it shouldn't 
break. If I put in eight, it shouldn't break,  
72:30 - it should always be matched. And so how we can 
do that is we basically do this thing with angle  
72:35 - brackets and int, colon, question underscore 
ID. And this can dynamically match whatever  
72:42 - pattern you put in. And another beautiful 
thing, you guys, usually for URL mapping,  
72:47 - you have to deal with ugly regular expressions, 
except for the latest Django, you don't have to  
72:53 - worry about regular expressions anymore. So 
for example, let's say you wanted to match  
72:57 - this particular pattern. Well, you can put this 
in, and if somebody puts in a five here, right,  
73:03 - they'll automatically know that it's an integer 
and work. If they put in something else, it might  
73:08 - freak out. Okay? So it's really smart. And then 
it says, Hey, if somebody goes to a URL like this  
73:16 - automatically takes them to the detail view. And 
if somebody goes to a URL that ends in a results,  
73:23 - like this, then, which is essentially what you're 
saying here, hey, any number, followed by results.  
73:30 - Take them to the results, one, and any number 
followed by the word vote, take them to the vote,  
73:38 - view. Cool. And let's see what happened. So I'm 
going to run I'm going to do Python, manage that  
73:45 - py run server. Cool. And I will open up my Chrome. 
And we will go to this guy over here. Okay, so now  
73:57 - we're getting an error is because we actually have 
to go to that particular URL. So in this case,  
74:01 - let's go to slash polls, and it should run our 
index function. So I'm going to do slash polls,  
74:06 - boom, it ran our index function. What 
does our index function say? Let's go  
74:13 - to our views. And that's what it says, Hello, 
world, you're at the polls index. Perfect. Well,  
74:20 - what if somebody goes to polls slash five or polls 
slash 193? What happens then? It'll take us to the  
74:27 - detail function, and what does the detail function 
say? It says, you're looking at question number.  
74:31 - What the question ID cool. So let's try and 
let's see what happens. I'm gonna do 193. Okay,  
74:43 - so the cool thing here that's happening is that 
you're able to take what's in the URL and you're  
74:48 - able to pass it down to your HTML. So right here 
that 193 right. If I make it like some other crazy  
74:59 - number pass that down here, right? So now we're 
able to actually take in arguments from our URL  
75:04 - and use them in our code. What if I said something 
like this, it'll say, hey, that pattern actually  
75:11 - is not matched. So that's exactly what we want 
it. If you don't put in a number here, it should  
75:15 - automatically detect it. Now, if you want to go 
to something like slash poll slash number slash  
75:21 - results, what do you do? Okay, so let's say I have 
this number, and I go to results, just like that.  
75:26 - And now, it should say something like, you're 
looking at the results of question, followed  
75:36 - by whatever it is. Okay? So you're looking at the 
results of question, right? Or question two. And  
75:47 - then if you go and try to do this thing with vote, 
you're gonna get the same thing. So if I go to my  
75:53 - URLs, it says, hey, go to slash polls slash number 
slash vote. So we're going to do slash polls slash  
75:59 - numbers slash votes. And I hit Enter, and it 
says, you're voting on question two, perfect.  
76:04 - That's exactly what we should be getting here. 
And it's looking great. All right. So it's saying,  
76:11 - hey, like, take a look at this in your browser, 
and it will display the placeholders? And that's  
76:15 - exactly what it did. And how does it work? Well, 
detail our function that we have, will take in  
76:23 - a request object followed by the question ID. So 
when we pass in the question ID to be 193. Right,  
76:30 - this part became 193. And this part is just that 
request object. So what they have here? Again,  
76:42 - if you're confused about objects, and what the 
hell is going on, it's not completely necessary,  
76:45 - but you should look at some object oriented 
programming stuff. Okay. And I do have a course  
76:51 - on object oriented programming, then you could 
comment on it if you're interested. Alright,  
76:56 - so the question ID is equal 34 comes from this 
thing, and I've explained that to you already,  
77:02 - when you put that in the URL, this dynamically 
actually pulls it out. And once it dynamically  
77:08 - pulls that out, because you see it says, 
here, it says, question ID question ID,  
77:15 - that's where it's actually pulling it from. Okay. 
And that's essentially it. And then it says, Hey,  
77:22 - you don't need to do ugly things like latest 
dot html, because it's not necessary. And it's  
77:27 - apparently silly. Okay, so don't do it. And you 
should write views that actually do something.  
77:33 - And here, they're saying, hey, look, each view 
is responsible for doing one of two things,  
77:38 - either as your return what it's supposed to return 
or give you like a 404. And then the rest is up  
77:44 - to you. So, you know, basically, you can have a 
view, or it can read records from a database. So  
77:53 - meaning reading records, reading posts, from 
a database, Instagram posts, Facebook posts,  
78:00 - or it can generate PDF files, or output XML or 
create a zip file on the fly, anything you want.  
78:06 - And pretty much using whatever Python libraries 
you want, because Django is 100% Python, so you  
78:12 - have full Python power. And then all Django wants 
is that HTTP response, okay. So you can return it  
78:21 - as a string, you can return it, you have to return 
it as some kind of an HTTP response. or throw an  
78:29 - exception. Okay, so now, here's what they're 
doing. They're like, Alright, we're going to do  
78:33 - something cool. Well, we're gonna do is we're 
gonna take like, all of the questions you have,  
78:37 - we're going to order it by the publication date, 
and then show the top five most recent ones. Okay,  
78:44 - how are they doing that? Well, I'm going to copy 
this, and then we're going to play around with  
78:50 - it. Okay. So we're going to go back to our thing, 
and what do they have here from dot models, import  
78:56 - questions, and they're in our poll slash views. 
Okay, so this is one thing that we need to do  
79:02 - from dot models, import question, because we don't 
have that. So we're going to paste it in here. And  
79:08 - then they want us to redefine our index. Okay. So 
we're going to do just that I'm going to change  
79:15 - my definition of what my index function is. 
Alright. So how is this working? Well, question  
79:22 - dot question that objects are ordered by. And what 
this thing does, is it'll take all your questions  
79:29 - and order it by something. So in our model, if 
you look, we have this thing, publication date,  
79:35 - so pub underscore date. So we're going to order 
it by publication date. Now what we're doing with  
79:41 - this minus sign is we're saying in the reverse 
order, okay. So instead of the oldest publication  
79:49 - dates and showing us the oldest, we wanted to show 
it in a descending order. So we wanted to show us  
79:54 - the recent ones first, and then what we're doing 
is that we're just and So this will return to us  
80:01 - a list, okay? And then you can index a list in 
Python by doing this. And we're just saying,  
80:06 - Give us the first five. So from zero, up to, 
but not including five. So 01234, that's five,  
80:15 - okay. And then as output, we're saying, hey, join 
all of them all of the questions by a comma. Okay?  
80:24 - So if you want to know a little bit more about, 
like how the Python is working in there. So here,  
80:30 - we're doing a list comprehension. And you can 
read more about list comprehensions. If you don't  
80:36 - know what that is, it's not too important. 
And it's just a cool way of writing this,  
80:41 - you know, instead of multiple lines is writing one 
line. And we're just saying, for each question,  
80:49 - give us its text. That's all we're saying. 
And then we're saying join it all by commas.  
80:55 - So that's how it's going to output it. So it's 
going to return to us pretty much a string, okay?  
81:02 - And then we want to return that. Okay, as our 
outputs originally HTTP response output. That's  
81:11 - it. So now, let's take a look at it. So I'm going 
to save it and we're going to go to our thing,  
81:18 - and we'll try to go to our index, and where's 
our index? It's just that slash polls. Okay,  
81:24 - that should trigger our index. And let's see 
what happens. So I hit Enter. And it shows me  
81:29 - all my questions. If you remember, I created three 
questions, what's cracking, what's new, what's up,  
81:35 - and it's showing us with separated by a comma, I 
could do show it to us separated by three stars,  
81:41 - if I refresh, it separates it by three stars, you 
could separate it by an image, whatever you want,  
81:48 - you know, this is just pure Python. Okay, so 
that's essentially it. But there's something  
81:54 - wrong here. And the thing that's actually wrong 
here is like, Look, you're not gonna have your  
81:58 - toilet and your refrigerator in the same room, 
right, you're muddying the water, just like that.  
82:04 - You don't want to have your HTML code and your 
Python in the same place, we want to kind of  
82:09 - separate it out. So right now, the design of our 
page is in the same place that handles our logic,  
82:17 - okay, so what we want to do is handle our logic 
by pure Python in one place, and all our HTML.  
82:23 - And the design of the page should be outside of 
this logic, okay. So we want to create something  
82:30 - for that. So what we're going to do, and what 
this tutorial tells us to do, is inside polls,  
82:36 - you want to create a new folder, and you want to 
call this folder templates. This is important the  
82:42 - case sensitivity of this is important as well as 
the name. So if you mess up the name, or you put a  
82:47 - typo, you're going to kind of get messed up here. 
also pay attention to the order of all this, okay?  
82:53 - It's under my site. So under polls, you're going 
to have templates. And then inside of templates,  
83:00 - you want to create a new folder, and you want 
to call it polls. All right. And inside of this  
83:08 - is where you're gonna throw all your HTML file. 
So we're gonna create, we're gonna create a new  
83:13 - file in here, and we're gonna call it index dot 
HTML. Okay, so just in slow motion for you, polls,  
83:21 - templates, polls, index. Okay. So essentially, 
it's like polls, templates, polls, index like  
83:32 - that. Alright, let's go back to our tutorial. 
And that's what it's saying. It's saying that,  
83:37 - hey, Django will automatically look for it 
and find these templates. And essentially,  
83:44 - to Django, the path will look like polls 
slash index HTML, because of how Django  
83:50 - works and looks for these. And you can override 
it and do all kinds of advanced stuff, you know,  
83:56 - if you want to read more into that, we're 
gonna just kind of keep it a little bit basic,  
84:01 - so everybody can follow. Alright, and now we're 
going to put the following code into into that  
84:07 - template. So it's telling us which file to 
put that code. And so I'm just going to hit  
84:10 - this button, copy this code. And we're going 
to go into our index HTML, and I will paste it  
84:16 - right over here. Okay, what is this code saying? 
It's saying, hey, if there are any questions,  
84:24 - then I want you to create an unordered list. Okay, 
that's what a ul tag is in HTML. And then what I  
84:35 - want you to say is for a question and so for any 
questions, I want you to put it as like a bullet  
84:41 - point and show that question, okay. And link to 
that particular question. Otherwise, say that  
84:48 - there are no polls available. So if we didn't have 
any questions at all, Elsa, no polls available,  
84:52 - and then end The if statement. Okay, so we're 
starting our for loop here. We're ending it here.  
84:57 - We start our if statement here. And then we have 
our l statement here. And we have our end if here.  
85:04 - Alright, so that's cool. Now we want to make sure 
that we actually link to this index dot HTML file.  
85:13 - How are we going to do that? Here's how. Now let's 
update our index view in polls slash views that  
85:19 - py to use the template. Okay, so we're going to 
do just that. And also, let's update our index  
85:26 - function just a little bit. So here's a few lines 
that we're adding. Let's go back to our views. And  
85:34 - we will see the latest question. We'll keep that 
and we'll just paste this in here. All right,  
85:41 - save. So what's going on? We're still getting 
those remotes recent five questions. But that's  
85:48 - what latest question list is going to become. And 
if you don't have five questions, they'll pick  
85:52 - the top three or top or the recent most for, okay, 
something like that. And then what we're doing is  
86:01 - we're loading that template poll slash index HTML. 
Okay, so we're using loader, arm. And then there's  
86:10 - something called context dictionary in Django. And 
what you can do is you can pass from the backend  
86:16 - server side, pass this to your front ends, your 
HTML code, it'll know about it. Okay. So if I go  
86:24 - back to our templates, my index dot HTML, how 
is it getting access to this variable, latest  
86:31 - question list? Well, we're actually passing it 
in our context. All right, that's, that's what's  
86:37 - going on. And then we're saying, as HTTP response 
template dot render, we're saying, hey, send that  
86:48 - context with that request and send it over to 
the HTML file. So it sends all that over to the  
86:54 - HTML file, and then our HTML file has access 
to that latest question, okay. And this weird  
87:00 - stuff you're seeing here with this with a percent 
sign, squiggly bracket, that's Django templating.  
87:06 - Engine. Okay. So it's basically HTML with a little 
Django pizzazz. Cool. And so now they're like,  
87:17 - Hey, this is such a common step to load a 
template, and then to do template dot render, that  
87:23 - there, they made a shortcut for it, which is just 
render. So how can you use that? Like this? Okay,  
87:30 - so basically, you can remove this line, you don't 
need this line anymore. And thanks to this line at  
87:36 - the top from Django, shortcuts, import render, 
which you should have, we're going to use this  
87:41 - render, and how are we going to do it, we can just 
replace all of this. And we can say render. The  
87:48 - first argument is request, okay. And then after 
that, the path to that index file, so polls slash  
87:56 - index dot HTML, just like that, followed by the 
context dictionary. So in this case, we're just  
88:03 - calling it context. Okay. Sometimes what I like 
to call this is stuff for front end, alright,  
88:12 - just to keep it consistent. And just so you 
know, the thing that you're accessing on the back  
88:20 - end is not this guy. It's a dictionary context, 
dictionary key. So it's actually this string. All  
88:27 - right. And that will give you back this guy. Okay, 
so know that once you've done all this in views,  
88:36 - we no longer need to import loader, blah, blah, 
blah. Exactly. That's what we did. And now they're  
88:41 - going to show us how to raise a 404 error. All 
right, so what happens if it doesn't exist? So  
88:49 - let's tackle the question detail view. The page 
that displays the question tax for a given poll,  
88:55 - here's the view. So in polls slash views that 
py we're gonna do is we're gonna from Django  
89:01 - HTTP import http 404. So since we're already 
using Django dot HTTP to import HTTP response,  
89:09 - we're also going to say http 404. Okay, just 
like that, we're going to save it. And then we're  
89:16 - going to come back. And now it wants us to make 
changes to our detail view. And it's saying, hey,  
89:21 - turn it into this. So let's turn it into that. And 
I'm going to save it. So try accept blocks, all it  
89:28 - does is if there's an error, try except blocks 
will catch it. Okay. Try accept block, it is  
89:33 - pretty much the same thing as if then condition, 
except that if you're running into some kind of  
89:40 - crazy error tracks, that blocks will catch it and 
still run. For example, if you divided a number by  
89:46 - zero in Python, your code will just freaking 
crash, right? It'll give you this red blob,  
89:52 - your Apple crash, whatever. But if you run a try 
accept block that says, if you get a zero division  
89:58 - error, then Just pass, you'll not get that error. 
I'll just pass it. Okay. So what we're saying is  
90:06 - we're saying try to get that particular that one 
specific question. Okay. So we're saying, we're  
90:14 - getting that question ID and we're saying get that 
object that has that primary care that question  
90:19 - ID, or right, that primary key is equal to the 
question ID. So if I pass in a URL like m AP comm  
90:27 - slash polls slash six, right, what is it going to 
do? Or let's say slash two, what it'll do is pass  
90:36 - this two in two here, that this will become two. 
And the question will get the question object that  
90:47 - has an ID of two in this case, it might be one of 
my question that I think is what's new, right now?  
90:52 - What's new question? So then this question will 
become the What's New question object? And then  
91:00 - what we do is that we just return that, okay. And 
we pass it in our context dictionary, and we pass  
91:06 - that question in here. Except if the question does 
not exist, then we raise HTTP four. And we said  
91:13 - question does not exist. Okay. Cool. Let me make 
sure to delete that. That's not supposed to be  
91:19 - there. I just added that to show you guys what's 
up. Okay. The new concept here, the view raises.  
91:27 - Yep. We'll discuss what you could put in that poll 
slash detail that HTML template a bit later, but  
91:34 - if you'd like to quickly get the above example, 
working a file containing just this. Okay, so  
91:44 - we're going to get that thing working. Okay, it's 
right in here. We're going to create a new file,  
91:50 - and we're going to call it detail dot html. And 
in detail, we're just gonna put question just like  
91:59 - that. Okay. So now we got to make it work. And 
we're going to go and get our question too. Okay.  
92:06 - So because that specific question exists, look, 
it says, What's new? Now, if I change this ID to  
92:12 - one is going to get the question that was what's 
up. If I change it to three, it's going to be the  
92:17 - what's cracking. But what happens if I change it 
to four? Remember, I only created three questions.  
92:23 - If I change it to four, it says page not found. 
And look, the error throws up his question does  
92:29 - not exist. Now, if we didn't have that, right, if 
we actually don't have that, so let's go back to  
92:35 - our views. And I'll just remove this. And I'll 
just say, instead of rays, I'll just say, pass,  
92:42 - okay, passes the equivalent of saying ignore 
to Python. Let's go back and let's refresh.  
92:48 - We're going to get this ugly error, which we 
don't actually know what to do with or what  
92:53 - it means. And it is very confusing. But when we 
have this when we raise this thing, and I refresh,  
92:59 - you see it says question does not exist. So it's 
a lot easier for us to see what the problem is,  
93:08 - is because we know it's coming from here, then 
we can like start debugging and know what's going  
93:12 - on. Okay. So that's why that particular thing is 
important. Alright, let's move on along. Alright,  
93:19 - so a shortcut. So instead of having this try 
accepting or raise, we can actually do a cute  
93:26 - shortcut that says get object or 404. And that's a 
method that's in Python. In Django, it comes with  
93:32 - it. So we'll throw that and it's in our shortcuts. 
So from Django, shortcuts, import, render, and  
93:39 - actually import get object or 404. Okay, and just 
to stay consistent with them, we'll do it in this  
93:45 - because starts with the G and starts with R. So 
alphabetical orders and pep eight. Okay. Alright,  
93:54 - so we're gonna go here, we will go to where it 
says question in detail. And we're going to remove  
94:02 - this whole thing, okay, make our life easier. And 
all we're gonna do is we're gonna say, bam, right?  
94:11 - We're gonna say, Hey, get object or 404. So that 
particular question with the primary key of this,  
94:17 - if it doesn't exist, then it'll automatically 
say it doesn't exist. And then pretty much the  
94:23 - last line, we'll keep it what it was. We'll save 
this. And basically as our context dictionary,  
94:29 - we're saying pass a question as a question. Okay. 
So there are three arguments in here, request,  
94:35 - the HTML, passive HTML file as a string, and then 
a dictionary. So then we can use it on our back  
94:41 - end. Again, in our detail, HTML, we can actually 
use we can see that question. Save. And now let's  
94:50 - try to go to it again. So I'll say four. And now 
look, it says no question. No question matches  
94:58 - the given query question, as Unlike no question 
object, okay, but if I do three, it finds us and  
95:06 - takes us to it. So this is what we mean, this 
is what I mean, when I say Python is really,  
95:12 - Django is really awesome and comes with a lot of 
intelligent defaults. Whereas you don't have to  
95:18 - write a lot of a lot of this code, right? It works 
on that DRI principle, do not repeat yourself. And  
95:23 - a lot of these things just come built in out of 
the box, and it it speeds up your development  
95:28 - time, saves you a lot of those new code lines, 
because every new code line that you write,  
95:35 - there's an additional chance for an error. So the 
amount of code lines that you can reduce, the less  
95:42 - errors you will make. Plus your code just 
looks beautiful and so much more readable,  
95:48 - right get object or 404. Instead of try that 
at all. Except object dot does not exist,  
95:55 - right? So it's confusing. Okay, let's go on. 
Get object or 404. This is some advanced stuff,  
96:02 - we're gonna skip that for now. Now it says use 
the template system. So in our detail dot html,  
96:08 - we're gonna go and I'm going to paste that there, 
save it. And let's see what it's saying. Back to  
96:14 - the detail view for our poll application. Here's 
what it should look like. Okay, so now let's go  
96:23 - to the detail. And let's see, first, let's just 
see what the result is right? And then we'll talk  
96:27 - about it, I'll hit enter. What's cracking is 
showing it to me in a nicer way. Let's do two,  
96:33 - it's showing it to me in a nicer way. 
What happens if I do four? Same thing,  
96:38 - no question matches the given query. Okay, 
so what are they doing here? They take your  
96:42 - particular question and they wrap it up in 
a h1 tag in HTML, anything that's an h1 tag,  
96:47 - will make it's called the heading one. And you can 
go all the way down to heading six, heading six  
96:53 - being the smallest heading one being the biggest 
boulders. So we have an in a heading one. And  
96:58 - then right underneath it, we say for choice in 
question, dot choice underscore set dot all. So  
97:07 - for all of the choices, as like at choices as in 
particular answers, you can have to each question,  
97:16 - right, though, those answers are the ones that 
actually get an upvote. Or there's no downvote,  
97:22 - sign up vote, show me all of those answers, 
except in this case, we don't have any answers  
97:31 - or any choices. So that's why it's not showing 
those. How is it working? The template system  
97:37 - uses dot look up syntax. So you'll do question 
question tax. So we'll go into the question,  
97:43 - and then it'll access a question or score text. 
Another thing to notice if you're more advanced,  
97:48 - if the question underscore text attribute did not 
exist, it would go and try to access it as a list  
97:55 - index. Okay, so imagine if it was like if you 
did question dot zero or something like that.  
97:59 - So you're still using dot notation. So that's 
something that could trip you up later. Okay. It  
98:06 - would have tried a list index lookup, okay. And 
then method calling happens in the for loop. So  
98:12 - this for loop method calling is happening there? 
Because you know, you're doing question that  
98:18 - choice underscore set dot all, okay. And then 
it's interpret as Python code, which is cool,  
98:29 - like right here. And it returns an iterable of 
choice objects. And then we iterate over it,  
98:34 - right. So that's why we use a for loop, and then 
we iterate over it. Now. Remember, when we wrote  
98:41 - the link to a question the poll slash index HTML, 
so let's go to our polls slash index dot HTML,  
98:46 - you can see what we did here. Right? So we said, 
slash so for the links. We said slash polls slash  
98:56 - this. Right. So let's go take a look at this page. 
One more time, we're going to go right here. And  
99:02 - I'm just going to hit pause and hit enter. So 
you can see how it's showing me what's cracking,  
99:08 - what's new, what's up to each of this. And when 
you click into it, you go into the detail view,  
99:13 - right? Kind of like when you click into a blog 
post. And also under What's up, you can actually  
99:20 - see the choices. So that's just a recent thing 
we just added. Right? So how is that working?  
99:28 - How are we linking it and how we're linking and 
we're saying slash polls, slash that question ID,  
99:34 - which matches, one of the paths in our URLs are 
p y. So if I take you to my URLs, it'll match  
99:41 - the path of this guy. And that takes you to the 
detail view. And that's how we can see the detail  
99:48 - view. So let's go back, but we're hard wiring the 
URL paths this way if we have a lot of URL pads,  
99:56 - or logic and get messed up or if we change if 
we go in our URLs that py and I, I don't know,  
100:02 - change this path to be something else, right? It 
has like, it says polls here, again, followed by  
100:10 - something else, it could like mess us up. So what 
we want to do is we want to use it in a dynamic  
100:17 - way. So that's what they're showing us here. So 
they're saying, hey, replace this guy with this  
100:22 - guy. So we're gonna do just that. Okay, so we're 
gonna go back to our index HTML, and we will just  
100:32 - do this. Okay. So now what this is saying is, 
for the URL, use detail, detail as in this,  
100:42 - that's where we're getting the name from. And 
then as the argument passed in the question.id,  
100:48 - so this question, since we're looping over it, if 
you do question dot use a dot notation, it'll get  
100:54 - you that particular questions ID. So question 
ID, that's what you pass in as argument. And so  
101:01 - then when you go to your URLs, to this question, 
ID, that's what it's going to pass. Okay, that's  
101:07 - essentially it. And I believe you should also be 
able to do question underscore, ID equals that,  
101:14 - but in this case, we're just going to keep it 
like this. Okay. So no need for keyword arguments.  
101:21 - Okay. And then in in between here. So that's what 
it's going to link to, it's going to link to the  
101:28 - detail view of that particular question. And the 
text that we're generating is just from right  
101:35 - here. So that's question dot question underscore 
text. If you are confused by this, look up stuff  
101:42 - on HTML, okay, and look up how links work in HTML. 
Again, I'm not going to go into too much HTML,  
101:49 - because that's outside the scope of this tutorial. 
Okay, and that's how it's essentially working now.  
101:59 - namespacing url names. It's basically just telling 
us like, Hey, look. So let's go down over here.  
102:07 - Let's just make sure we're not missing anything. 
Okay, from the top. Okay, they're saying,  
102:18 - if you want to change the URL to something else, 
perhaps it's something like polls slash specific  
102:22 - slash 12. So this is something that I've already 
said, but but they're just reiterating here. And  
102:28 - they're saying it like, if you change the URL, 
it's still going to work now that we change it to  
102:32 - be the dynamic way. Okay, so now we can change our 
URL pattern to whatever. And it's not hardwired  
102:40 - anymore. And now they're talking about namespacing 
URL names. Okay. So this way, you want to make  
102:50 - sure that all of your apps actually have, there's 
no way for like, right now we only have the poles  
102:56 - app, right. But what if we wanted to have more 
apps inside of this, then what can happen is  
103:02 - that if any of our HTML files name matched, so 
let's say you have a polls app, and it has an  
103:08 - index dot HTML file, right? What if you had a blog 
app, and that also had an index dot HTML file,  
103:14 - now you're gonna have a collision. So what we do 
for that, that's, that's the reason why we create  
103:21 - under templates, another folder called polls. And 
if we wanted to add templates for our blogging  
103:28 - app, that's why we would have an app called blog. 
And then under that, we'd have templates and then  
103:33 - under that, we'd have blog, and then under that 
would put our HTML stuff, okay, that's the reason  
103:40 - why we do it like that. And this way, there's 
going to be no collisions. Okay. Now change  
103:52 - your poll slash index dot HTML. So let's see what 
it's saying here. So we can have our app name, app  
104:03 - underscore named avatar name is equal to poll. So 
this is in our URLs. py. So let's go right there.  
104:10 - urls.py. And they're saying, hey, add that guy 
right over here, okay. And pretty much everything  
104:19 - else we want to just leave as is. Now change your 
poll slash index dot HTML template from this to  
104:28 - this. So in our index HTML, we're gonna go right 
here, and we're gonna paste that guy. So notice  
104:37 - the difference. All we did is we do polls equals 
d polls colon detail, okay? That's really the  
104:44 - only difference. There's no other difference. I'm 
gonna save that. And this way, our URLs will never  
104:52 - collide. And everything has a proper name spacing, 
right, because right now we created a detail for  
104:59 - our problem. What if you want to create in what 
if you had an add a new app called blog, and then  
105:04 - create details in there. You don't want it to just 
be called detail because it's going to collide  
105:09 - with the polls detail. But now because it's 
polls colon detailed, then later, you could do  
105:15 - blog colon detail, or Instagram, post colon detail 
or Facebook status, colon detail. And this way,  
105:23 - you can differentiate all of those different apps 
you have within one of your Django projects. Okay.  
105:33 - writing your first Django app, Part Four. Alright, 
so we're continuing a web poll application. And  
105:39 - we'll focus on simple processing, simple form 
processing and cutting down our code. So the big  
105:46 - things we're going to be doing is how do you add 
a form, that where you can submit information to,  
105:52 - so basically, it's going to be a form is gonna 
have radio buttons, you're gonna pick your choice,  
105:56 - you're going to click on it, and then you're gonna 
be able to send that data over, that's number one  
106:02 - big thing we're going to be doing. The second big 
thing we're going to be doing is cutting down our  
106:07 - code using something called Django is a generic 
views that are super, super powerful. And it makes  
106:17 - your code a lot more readable, and it stops you 
from doing the same thing over and over again.  
106:23 - Okay, so it makes things a lot simpler for you. It 
does have a little bit of magic involved. But hey,  
106:29 - that's what I'm here for. And I'm gonna break 
it down. So let's jump right into it. Alright,  
106:36 - so writing a simple form, I'm going to copy this 
guy, and then I'm going to break it down to you,  
106:40 - you my friend should not be copying, you're 
learning this stuff. You should be writing this  
106:45 - down line by line and going, huh? How does this 
work? Ah, that's how it works. Oh, hmm. And then  
106:55 - you should be googling it and looking it up. Okay. 
For me, I know how this works. I don't want to  
107:01 - waste my time a copy, paste it and then break it 
down for you. capiche. Let's get going. Alright,  
107:07 - so let's pop open our atom. And we will go into 
our detail dot html. And we're going to put this  
107:18 - over that. Okay. So what is going on at a higher 
level? We have a for our heading one. So this  
107:25 - is where, what the specific question is, okay, so 
what's up? What's crackhead what's pop and things  
107:30 - like that? All right. Here, this line is saying, 
Hey, man, look, if there are any error messages,  
107:35 - I just want you to freaking show them. That's all. 
And this guy over here is just a form where you  
107:41 - actually submit and vote, okay, at a high level, 
that's all that's happening. Okay, now getting  
107:47 - down more into the code level. This is pretty self 
explanatory is just h1 tags is just HTML, here is  
107:55 - a little bit of Django going on. So here we're 
saying, if there are there is an error message,  
108:01 - then show it, okay, and show it covered in strong 
tags, that looks nice. And then here's where we're  
108:09 - creating a form. So we started the form tag here 
and the form tag here. The action is to go to this  
108:16 - specific URL, so trigger this URL. So basically, 
action means what the heck happens when you submit  
108:24 - a form? Right? what's an example of a form? 
You? Every almost every website has it? Okay,  
108:31 - so you going on Instagram and logging in, you 
are submitting a form you logging in on YouTube,  
108:36 - you logging in on Facebook, you are submitting 
a form, you posting a status hitting post,  
108:41 - you are submitting a form, okay. So 
that's essentially what's going on.  
108:46 - So what we can say here for action, once 
you submit a form, what should happen,  
108:51 - okay? One thing you could do here is just type 
in facebook.com. So once you submit this form,  
108:57 - it just takes you to facebook.com. Okay, you can 
certainly do that. Except in our application, what  
109:02 - you want to do is, once somebody submits a form, 
you want to send them over to some other part of  
109:07 - your app with that information with that data. For 
example, if somebody adds shoes to their cart, it  
109:16 - then takes them to the new page with information 
where they previously added shoes to their cart,  
109:21 - and then shows the shoes and the shirt and the 
tie on. proceed to checkout page. Okay, that's  
109:29 - essentially how you use forms in real life. Okay, 
so here we have it to Hey, take me to the vote.  
109:37 - View, okay, or the vote function in our views 
file. Cool. CSRF token so there's something called  
109:47 - cross side. I forget what it fully stands for. 
Let's take a look at it. They mentioned it cross  
109:54 - site request forgery is okay. So it's a security 
mechanism and All you have to do is really not  
110:01 - to worry about it too much. All you have to do is 
just add that token. Okay, so actually, that's it,  
110:06 - that token doesn't even need an end. That's it. 
This is just a line that you add, usually when  
110:11 - you're adding Django forms unless you're using 
something like crispy forms, which is, again,  
110:15 - outside the scope of this tutorial. So that's what 
this line is here. We're doing a simple for loop.  
110:22 - Okay, the for loop goes through all the question 
choices. And what are question choices? Well,  
110:28 - remember each, so you have question, and then 
one question can have multiple answers to it.  
110:34 - Those answers are the things that get voted on. So 
what we're doing now is listing out all of those  
110:41 - answers or, or those choices. And, and, and I'll 
show you right now, how al actually look Okay, so  
110:51 - let's go ahead and check out what this looks like. 
So now, we're gonna go over to our app. And let's  
110:58 - click on what's cracking. And you can see it says 
what's cracking followed by vote right underneath  
111:03 - that. Okay. Let's go to what's up. What's up has 
two choices. Remember, I had not much and the sky?  
111:11 - Those are two possible answers. kind of funny. 
I don't know which one I like more. But yeah,  
111:18 - you could you could vote on one. And then you 
could certainly hit vote, okay. Yours is not  
111:25 - going to look as big as mine. That's because I 
have it zoomed in. So you could see on my 5k,  
111:29 - iMac retina screen, and you can pick whichever 
one you want. That's it, and then you hit vote,  
111:34 - boom. Okay, you're voting on question one, it will 
redirect you to that. Cool. So that was that the  
111:43 - radio buttons are coming from these lines, okay, 
how's this working input type radio, when you do  
111:49 - this, then it creates those radio buttons on the 
side, okay. I for ID something you don't have  
111:56 - to worry about too much. But for ID, we're just 
using the built in Django templating systems for  
112:01 - loop counter. So we'll give the id 1234. As it's 
looping through. And yeah, values, just a choice  
112:09 - that ID and Name, we're just calling a choice. 
Name is very important. Once you get this on the  
112:16 - server side, the back end, you could reference 
this post data using that particular name, okay,  
112:23 - so you're gonna be able to do something like 
request, I post bracket choice. Okay, and then  
112:28 - label for, that's just for labeling purposes. 
Again, not incredibly important to what we're  
112:35 - doing. And then we end the loop right over here. 
And then right over here, we're saying this form  
112:41 - is basically what we're saying is like, put that 
Submit button, and then just call it vote. Okay,  
112:50 - so that's why you see, you know, if I called 
it something else and saved it and refresh now  
112:56 - calls it that. So here we're saying call it 
vote. And then for type, we're going to say  
113:03 - it's a submit button. So the type which is 
going to give us submit, so once you hit it,  
113:07 - it sends that information over to the next page. 
Cool, let's go back to our tutorial. Alright,  
113:16 - so that's pretty much what is gonna explain to us, 
but let's just see and make sure we're not missing  
113:20 - anything. Right, so the value of each radio button 
is associated, is associated question choices ID,  
113:30 - the name of each radio button is choice. Yep. 
That means when somebody selects one of the  
113:36 - radio buttons and submit the form, it'll send 
a post data choice, where a number is the ID  
113:43 - of the selected choice does the basic component of 
HTML forms, okay? We said the forms action to that  
113:51 - particular URL, and we said method is equal to 
post. So here's another important thing to note,  
113:56 - this is pretty important. Whenever you're 
generally submitting data, or filling out a form  
114:03 - and sending it over, you want to use post request. 
Because it's safer, and it's better. You don't  
114:10 - want to be using GET requests when you're sending 
data over because it's insecure, and you can get  
114:16 - screwed. Okay, so simply put, as opposed to get 
it's very important, because the act of submitting  
114:24 - this form will alter data server side, whenever 
you create a form that alters or data service  
114:29 - side, use method post. This tip isn't specific. 
Django is just good web development practice. For  
114:36 - loop counter indicates how many times a four tag 
has gone through its loops. Okay, I've explained  
114:42 - this already. Since we're creating a post form, we 
need to worry about cross site request forgeries  
114:50 - and I've already gone over this as well. Okay. 
And that's why we're using CSRF token. All right,  
114:59 - now, let's go Create a Django view that handles 
the submitted data and does something with it.  
115:03 - Remember, in tutorial three, we create a URL con 
for the that includes this line. So we already  
115:09 - have this line, we don't have to add it. So if 
I go to my URLs dot p y, you'll see four votes,  
115:15 - I have this line right over here, and so should 
you. Alright, now let's add the knowledge,  
115:23 - we're gonna create a real version for our vote. So 
up until now, we had functionality for our vote,  
115:30 - but it was just dummy placeholder didn't really 
do anything. Okay, so now we're gonna actually  
115:34 - add real functionality, what are the few things 
we need that we don't have? Let's see, we'll need  
115:40 - HTTP response redirect, because we don't have 
that. So we're gonna put that in. All right,  
115:47 - we're gonna save. What else do we need? We need 
from Django dot URLs, import reverse. So we're  
115:54 - going to add that in and hit save. And then that's 
essentially, essentially and then it except we're  
116:02 - gonna have choice right here, save cool. Okay, now 
we're gonna go in our vote, and we need to add all  
116:09 - of this code. Okay, and I'll break it down for you 
right about now. Okay, so what's going on here?  
116:15 - Question? We get that particular question, or we 
throw 404 error, we then get the answers for that  
116:28 - particular question. Okay, or selected choice. 
one specific choice, that's what we get. Okay? So  
116:36 - for example, whether the choice is going to be the 
sky or whether the choice is going to be something  
116:43 - else, right? It's not going to show it to me right 
now. Cuz the app is offline right now the server's  
116:49 - close. But since we had two choices, and you 
couldn't vote for this choice, or this choice, how  
116:55 - are you going to know which one is sent? Right? So 
that's what we're trying to pick here. Whichever  
117:00 - choice you select the radio button next to that's 
whose primary key we're going to be passing in.  
117:07 - And how we get that as request our post choice 
request, our post is just a dictionary, and you  
117:15 - could index you could get pull out the key choice 
from that. Okay. Just to have it make sense. Let's  
117:23 - see, let's run this code. So what is it saying? 
The problem is right here. Alright, we're gonna  
117:30 - run this code. Cannot import name reverse http 
404. Let's see where that error is coming from.  
117:41 - Hmm. Right there, reverse, okay. And you could 
still have http 404. Not a problem. All right.  
117:53 - So let's go back to our app. Let's go to what's 
up. And also, let's go back to this, save it,  
118:02 - come back, let's refresh. This should save votes 
here. Now, when I hit the sky, we're gonna see  
118:08 - what happens. So I'm going to hit inspect here. 
And our console pops up, right? We're going to go  
118:13 - to sources. console is looking pretty insane 
right now, but that's fine. I'm going to click on  
118:20 - network. And we're gonna click vote. So we're just 
voted for the sky. Okay, now in our network. Let's  
118:30 - see if we can zoom out a little bit because it's 
a little too crazy. Alright, so in our network,  
118:40 - we can see that the request method is post, right. 
And we can actually check out the response. And in  
118:47 - this case, it says the response failed. Let's 
click here, right now, when I click results,  
118:54 - because it was sent to results, it says you're 
looking at the results of question one, right?  
119:00 - So there is a response. And now if I look in the 
headers, it tells me the request method right now  
119:05 - is get, and it tells me kind of all the things 
that go along with it. Right. So let's try it  
119:10 - out again. Let's pick another question. Not much. 
And vote. Let's see what happens. So 302 found,  
119:21 - right. Okay, so let's go here, preview response, 
failed to load response data. If I go and results,  
119:29 - it's showing me are looking at the results of 
question number one, okay, so pretty much it says  
119:33 - the same thing and it's giving my statuses What 
do these mean? We're gonna break it down a little  
119:39 - bit later. Okay. So let's go back to our tutorial 
and go down. index HTML. Okay, so this is looking  
119:53 - good, our views. It's looking fine. Cool. Now So 
yeah, so basically we're selecting the specific  
120:02 - choice from here, whatever we get, we send over 
in our request. And then we throw an accept choice  
120:12 - that we throw an exception here, okay? And we 
also check for if like the choice does not exist,  
120:20 - or if there's an here. And in the case that the 
choice does not exist, we return polls slash  
120:30 - detail dot html, we render that and we return 
that question object. And for error message,  
120:39 - we say that you didn't select a choice, okay? So 
if you somehow selected, you know, nothing. And  
120:46 - otherwise, if we have selected it, and we haven't 
ran into this issue, we want to say is for that  
120:53 - particular choice, we want to upload it by one. 
So we're in incrementing, the vote count by one,  
120:58 - we want to save it. And then we redirect. Okay. 
So we're going to go into more depth of that.  
121:05 - But let's just check this part out one more time. 
Refresh. Let's hit inspect. Let's go to network.  
121:17 - Let's select this guy, let's click vote. So you 
can see, okay, so that's that's exactly what I  
121:27 - needed here. So a little hard to see though. 
So you can see when I scroll all the way down,  
121:34 - that it actually pulls out the form data. And 
it's telling me that the choice I selected was  
121:42 - the second choice, right? That's an important 
part. And it's also has a CSRF middleware token,  
121:48 - which, remember we did CSRF underscore token, 
that's where it's generating now from, but the  
121:54 - choice is the most important one. So whether it 
was choice one or choice two, and we're picking  
121:58 - this based on the choice ID, okay. So that's 
essentially what's happening. Now, if I go back,  
122:04 - and I pick Not much, and I vote, and when I 
go back up to vote, and I go all the way down,  
122:09 - you'll see that it's showing me choice one, right. 
So that's the thing that we're actually pulling  
122:14 - out. So this will essentially turn to a one or a 
two. That's what I was trying to get at earlier,  
122:19 - but it was just my screws too big. So it was hard 
for me to show it. But that's what gets selected  
122:25 - here. And once this evaluates to something like 
a one or something like a two, this whole thing  
122:31 - evaluates to that specific question object. 
And then we up voted, and then we save it,  
122:41 - and then we redirect. Okay? The reason why you 
so when you're done with all of this, you don't  
122:48 - want to say, hey, go back to the home page, or 
you don't want to just say like render the home  
122:52 - page. Because if the user refreshes, it will keep 
submitting that data over and over again. So like,  
123:00 - imagine, right, if you were about to pay for 
your credit card, and you buy like, whatever,  
123:10 - right? You buy shoes, or you buy grocery. If you 
refresh, like something happens during half of it,  
123:16 - then it gets submitted. But then you go back 
and you refresh, or you resubmit. It shouldn't  
123:21 - let you resubmit and pay again, right? Every 
time you refresh, and then all of a sudden,  
123:26 - you're charged like $300? Or what if you were on 
an online trading app, and you just put down like  
123:34 - $3,000 for Bitcoin. And then you refresh, or you 
go back and forward a page and it reads a mess.  
123:41 - 3000 $3,000. Again, you're going to run out of 
money pretty fast, right? $9,000 like that. So  
123:46 - it's a pretty serious issue. So what you want to 
do instead is redirect This prevents data from  
123:53 - being posted twice if a user hits the Back button, 
okay. There's a better way to do redirect, which I  
124:00 - think they'll show us later. But it's essentially 
I think, from shortcuts, you can pull out redirect  
124:06 - and just call redirect, and it's much simpler. 
But they do it this way. Should you be response,  
124:10 - redirect, reverse and then take me to the results 
view, right. So it takes you back to this results  
124:17 - view. And for argument it just passes in the 
question ID cool. So that's looking good. Now  
124:29 - let's play around with it and let's just check out 
what happened so I've already voted for like one  
124:34 - or two questions multiple times. Let's see what's 
going on on our database. I'm going to go in  
124:38 - Python manage that py shell so we're gonna do is 
from polls dot models. I'm an import choice. And  
124:47 - I'm also going to do from polls dot models, import 
question. Question dot objects, dot get Let's say  
125:00 - we want to get our first question or what's up 
question. And we're going to save this question  
125:07 - as like q or something. And now what I'll do is 
I'll do Q, that choice underscore set that all.  
125:13 - Now show me all the choices or answers for it. 
And then I'll pull out the, the sky one. And then  
125:25 - for the sky one, we can see it's vote count. In 
models, I forget what is voters votes. So you can  
125:33 - see that it has two votes. And then the other 1/3 
one, it also has two votes. So it's a tie. Okay,  
125:42 - so both have two votes. So you see that what 
we're doing on our front end, and we're voting,  
125:48 - it's actually being counted here, okay. Usually 
where it says choice underscore set, that's kind  
125:54 - of weird. So how you want to say it is like cute 
choices. And, again, like I've mentioned in our  
126:01 - for, at the end of our first video, like if you 
want to change that, I'm not going to change it  
126:05 - now just to stay consistent with Django, official 
docs. But essentially, like right in here, right,  
126:12 - right in the top, we can actually write something 
called related underscore name, and then fix this  
126:19 - issue, like right there. call it something like 
related underscore name, and give it choice says,  
126:27 - okay, something like that. But we're not going 
to do it right. Now, we're going to stick to  
126:33 - a Django because otherwise, I'll have to make 
migrations and things like that. Everything is  
126:37 - fine. For now. I'm going to exit out of this. And 
I will just do Python, manage that py run server,  
126:43 - and just go back to using our regular app. Cool. 
All right. So now let's see what they want us to  
126:51 - do. So that's all good. That's working. Alright, 
let's see what they're saying here. requests are  
126:58 - post is a dictionary like object lets you access 
submitted data by key name. Yep. So that's how we,  
127:04 - we use the choice key name. requests that post 
values are always strings. Cool. Note that Django  
127:15 - also provides request I get that's by default, 
that's there. But we're explicitly using requests  
127:22 - our posts and our code to ensure the data is 
only altered via post call. It will raise a  
127:29 - cure if choice wasn't provided in post data, the 
above code checks for key error right over here.  
127:37 - And redisplay is the question form with an error 
message if choice isn't given. After incrementing,  
127:44 - the choice count the code returns an HTTP 
response redirect rather than a normal redirect.  
127:51 - This redirect takes a single argument the URL to 
which the user will be redirected to the following  
127:57 - point for how we construct the URL in this case. 
And you should always return an HTTP response  
128:04 - redirect after successfully dealing with post 
Okay, we're using reverse function constructor,  
128:14 - this function helps avoid having to hard code a 
URL in the view function. It is given the name of  
128:20 - the view that we want to pass control to and the 
variable portion of the URL pattern that points to  
128:25 - that view. Cool. So right here. Now after somebody 
votes in a question, the vote view redirects to  
128:35 - the results page for the question. Let's write 
that view. So now, it should point us back to the  
128:42 - results, and we're going to write it okay. So here 
is what it should be looking like, let's check our  
128:49 - results. Pop that bad boy, whoops, pop that boy 
right in here. And we just say get that particular  
128:59 - question. or otherwise, throw four or four. And 
once you get it, take me to. And once you get that  
129:13 - question, take me to results dot html. So you can 
already see there's some similarities, right? Like  
129:20 - here, there's a similarity and here's there's a 
similarity. Both of these have to do with getting  
129:25 - that one particular question. So think of it like 
you're getting the result detail view for both of  
129:34 - them. But in one, you're sending me to detail that 
HTML and the other one you're selling, sending me  
129:40 - two results, that HTML, okay. And we're gonna kind 
of address this issue of like our code being a  
129:53 - little bit repeated. This is almost exactly the 
same as a detail View from tutorial three. The  
130:01 - only difference is the template name. We'll fix 
this redundancy later. So they mentioned that. Now  
130:05 - let's create a poll slash read zoals dot html. 
So we're going to go in and create a new file,  
130:15 - I'm going to call it results dot html just like 
that. I'll paste it here. And we'll go to our app.  
130:21 - And we'll vote for the sky. And then it'll take 
us to the results of what's up and look at that  
130:30 - now much says two votes and the sky. three votes, 
vote again. And then it takes me back to the vote.  
130:35 - And I'll vote for not much. All right, so it's 
coming out pretty cool. So far. All right, is this  
130:41 - is exciting, guys. This is exciting. So now, what 
is this code saying, Let's read our code who just  
130:50 - added header unordered list unordered list, the 
loop is saying go through all of the choices, or  
130:57 - all of the answers. I don't know why they call it 
choice, I just think is a bad name. And get that  
131:05 - choices choice text, put two dashes in between it. 
So for example, this would turn this whole thing  
131:12 - would turn into like the sky or not much, followed 
by the number of votes, followed by it saying  
131:19 - vote, choice out votes, pluralized. Right. So what 
this is doing is it's either gonna put an S here  
131:28 - or not. So for example, let's go here. So if you 
only had one vote, it wouldn't this would turn  
131:37 - into nothing. And if you had multiple votes, it 
would turn into it would put an S here. Okay, so  
131:47 - it's a pretty cool way of pluralizing something. 
But you're doing choice dot votes. So this will  
131:56 - evaluate to like, let's say three, and then you're 
piping it over to pluraleyes. And then pluraleyes,  
132:02 - will be like, hey, yes, you should pluraleyes and 
put an S here. And then I'll put like an S like  
132:07 - that. Okay. Cool. With that said, That ends a for 
loop. So you're doing not too much here. And then  
132:15 - what you say is like, Hey, you want to vote again? 
And how you how you're doing that is you're just  
132:20 - providing a link to the tax vote again. And it'll 
essentially take you to the detail view of that  
132:27 - particular question. Okay. So if I hit vote again, 
it takes me to the detail view of that question,  
132:36 - what's up, not much vote, it takes me to the 
results view. If I hit vote again, it takes  
132:41 - me to detail view, click here takes me to the 
results view. So this app is starting to have some  
132:48 - functionality again. So again, that's pretty cool. 
Let's go here. Let's check out now go to polls  
132:55 - slash one in your browser and vote in the question 
we did. It gets updated each time you vote if you  
133:01 - submit the form without having chosen a choice, 
you should see the error message. Okay, so let's  
133:06 - see if we can try to do that. Let's hit vote. 
And it says you didn't select a choice. Perfect.  
133:13 - That's exactly what we want it. Note, the code for 
our vote view does have a small problem, it first  
133:23 - gets the selected choice object from the database, 
then computes the new value of votes, and then  
133:32 - it saves it back to the database. If two users of 
your website try to vote at exactly the same time,  
133:38 - this might go wrong, the same value, let's say 42, 
will be retrieved for votes. Then for both users,  
133:45 - the new value of 43 is computed and saved. But 
44 would be the next expected value. This is  
133:53 - called a race condition. If you're interested, 
you can read avoiding race conditions using F to  
133:58 - learn how you can solve this issue. Okay, that's a 
little bit advanced, it would have to be literally  
134:03 - at the same like fraction of a second. could it 
happen? Yes. If you're trying to scale your app  
134:10 - to a lot of users? Yes. Should you worry about it 
right now? Hell no. So let's continue. Alright,  
134:16 - so remember what I mentioned in our views, 
some of the code is looking similar like here,  
134:21 - these are detailed views, right? They're showing 
the specific question. And they need one specific  
134:27 - question. Looks a little redundant, right? And 
then we're using also specific question like  
134:34 - allowing us to vote here, but these, there's a 
little bit of redundancy going on. So how can we  
134:39 - address this? How can we manage this in a better 
way? Well, luckily for you, Django has something  
134:46 - called generic views. These are class based views 
that essentially have you once you use them. You  
134:54 - don't even have to write down much real code. It 
just does a lot of the things automatically in  
134:59 - Pretty intelligent way. So I like this and check 
it out. Alright, the detail and results views  
135:07 - are very simple as mentioned above, but they're 
redundant, okay? The index view, which displays a  
135:15 - list of poles is similar. These views represent a 
common case of basic web development, getting data  
135:20 - from the database according to a parameter passed 
in the URL, loading a template and returning the  
135:26 - rendered template. So we pass stuff, and we get 
it from the URL, and then we load up a template  
135:33 - and we return the render template. That's 
essentially what we have been doing. And when  
135:38 - I say return the render template, another way to 
say it is returning that HTML file you're looking  
135:42 - for right or that page on the front end that you 
see. Because this is so common, Django provides a  
135:47 - shortcut called generic views system. Generic 
views, abstract common patterns to the point  
135:54 - where he doesn't even need to write Python code 
to write an app, you could literally be sleeping,  
135:58 - and the app just writes itself. Let's convert our 
poll app to use the generic view system. So we can  
136:05 - delete a bunch of our own code, we'll just have to 
take a few steps to make the conversion. We will  
136:12 - one, convert the URL cons, delete some of the old 
unneeded views and introduce new views based on  
136:20 - generics. Generic Django views. Alright, read on 
for details. Okay, so why the code shuffle? What  
136:30 - they're basically saying is, hey, you should know 
basic math before you start using a calculator. So  
136:35 - why did we do this up until this point, only to 
now refactor our code? Will we have to refactor  
136:42 - our code all the time? No, you will not. Next 
time, when you're doing your app, you already  
136:47 - know how the class based views work, you'll start 
from more generic class based views. So basically,  
136:55 - what they're saying is like, hey, look, we don't 
want to just give you the calculator before you  
136:59 - can do basic two plus two, or in my case, in one 
of my videos, I think I had to do 2000 divided  
137:04 - by 10. On a calculator. That was a pretty sad 
moment. And that has a lot of upvotes makes me  
137:14 - sad to this day. I wish my editor took it out. Oh, 
well, you don't always get what you want in life,  
137:19 - but Django generic views comes pretty close. So 
let's keep going. Alright, amend URL con, First,  
137:26 - open the polls slash URLs, r p, why you're 
on Khan, then change it like so. So we're  
137:35 - going to go and pull slash urls.pi. And I'm just 
going to paste it over this bad boy and explain  
137:41 - what the heck we just changed, right? So besides 
the fact that we took out some notes, what else  
137:46 - just changed? So let me let me take this out. So 
you can kind of see it side by side and really see  
137:54 - what changed. So if you look at this index thing, 
all the change before it was just dot index,  
138:02 - now it's index view.as. View, detail view as view 
results. view.as view? And those are the middle  
138:11 - arguments that changed, right? What are the other 
arguments that changed? Everything after the name,  
138:17 - all the name, keyword arguments remained the same. 
But there was something else that changed. So here  
138:23 - it says question underscore ID everywhere. But in 
the new one, it says PK everywhere if you notice,  
138:29 - right, so that's another big change to keep in the 
back of your forehead. Alright. That's what they  
138:42 - mentioned over here. Cool. So that's essentially 
what we're going to be focusing on here. So here,  
138:49 - we still have question ID, okay. Now, when we're 
using these generic views, they take things in as  
138:56 - PK, and they'll explain that later. And now we 
need to make changes to our views. We're going  
139:00 - to remove our old index detail and results views 
and use Django as generic views instead, to do  
139:07 - so open and change it like so. So we definitely 
need this generic thing. So we're gonna do, we're  
139:15 - gonna go to our views. And here we're going to 
do from Django dot views import generic. Alright,  
139:22 - so we got that. Other things that we need. Now we 
need to make a class here. So I'm gonna completely  
139:28 - remove this guy and add a little class here. How 
will this work, it will automatically know which  
139:37 - template to use based on this variable. These 
variables are not just random, you can just call  
139:44 - it this, it will not work. These variables have 
to have this specific name for them to work. Okay,  
139:52 - this is something important for you to remember. 
Django does have a bit of magic but once you  
139:58 - learn how it works, It'll be really, really 
helpful. Okay. So template underscore name,  
140:04 - you have to use this variable, we assign it 
to the index HTML. For a context object name,  
140:13 - we say latest question list. And for a query 
set, we're just returning the last five published  
140:20 - published options. Okay? So this we're saying, 
only be referenced if somebody says this. So  
140:29 - when somebody says this, you can get me that, 
okay. Let's go in our class detail view. So for  
140:39 - our detail, all we need to write is instead of 
doing this get object 404, passing the question,  
140:45 - passing the primary key and all that stuff, 
and saying render requests, followed by the  
140:51 - context dictionary and all that. It's pretty 
simple. How is it working? Well, it's actually  
140:59 - pretty cool. Um, okay, so let's go back to our 
URLs. And since we're passing PK right in here,  
141:09 - it already has it, you don't even have to pass it 
as an argument or anything. Which model? Again,  
141:15 - these variable names matter. We're telling it use 
the question model, so it's directly communicating  
141:21 - with this model right over here. template name, 
we just give it the template name. And that's it.  
141:27 - It knows what to do. Okay. pretty beautiful. Now, 
let's do the same thing for results view. So it's  
141:33 - going to change from this obfuscated looking code 
to something pretty simple, check it out. Clean,  
141:41 - right? Looks a lot cleaner, no need for request 
and question ID no need for a get object or 404.  
141:50 - No need for passing in question or primary 
key, no need for saying render request. And  
141:57 - passing in a context dictionary, it just 
does it all automatically. And then vote,  
142:06 - we're gonna keep it the same. Okay, we're gonna 
hit Save. Now we're using two generic views here  
142:13 - list view and detail view, respectively. Those 
two views abstract the concept of display a list  
142:19 - of objects. That's one concept. So list view is 
going to do that. And then the other concept is  
142:27 - display a detail page for a particular type of 
object? So are you looking at the home page of  
142:34 - Instagram? Or are you clicking into one particular 
post, I'm looking at its detail. A generic view  
142:43 - needs to know what model it will be acting upon. 
This is providing using the model attribute,  
142:48 - which is this. The detail view generic view 
expects a primary key value captured from the  
142:56 - URL to be called pk. That's why here it has to be 
called pk. So we have changed question underscore  
143:03 - ID to PK for the generic views, but not for the 
non generic view. By default, the detail generic  
143:13 - view uses a template called app name slash model 
name underscore detail dot html. In our case,  
143:21 - it would use the template the following template, 
right. So if I go in my views, Paul, so app name,  
143:28 - our app name is polls, slash results dot html, 
so slash slash the model name dot html, okay. In  
143:39 - our case, we just called it results at HTML. The 
template name attribute is used to tell Django to  
143:47 - use a specific template name instead of the auto 
generated default template name. We also specify  
143:52 - the template name for the results list view. This 
makes sure that the results view in the detail  
143:57 - view have a different appearance when rendered 
even though they're both a detail view behind  
144:02 - the scenes. So they're both a generic detail 
view. Okay. Similarly, the list view generic  
144:10 - view uses a default template called similar to the 
other one, we use template name to tell ListView  
144:17 - to use our existing one. So by using template 
name, right over here, we're telling it which  
144:25 - one to use specifically. In previous parts of the 
tutorial, the templates have been provided with  
144:33 - a context that contains the question and latest 
question list context variables. For detail view,  
144:39 - the question variable is provided automatically. 
So the question variable is provided automatically  
144:45 - instead of us even having to pass it in as 
a context dictionary because generic views  
144:50 - are smart. Since we're using a Django model, 
our models called question Django is able to  
144:58 - determine and improve Britain name for the context 
variable. That's why it would pull out question.  
145:04 - This would be the variable name that you can use 
automatically on your front end in your templates.  
145:12 - However, for ListView, to automatically generated 
context variables, question underscore list. So  
145:19 - if it's a list of things, right, like the list 
of choices, or those answers, it would call them  
145:25 - question underscore list. to override this, we 
provide the context underscore object underscore  
145:31 - name attribute, so we override it. And we give it 
our own name. If we didn't give it our own name,  
145:37 - we'd have to access it using question or score 
list. But by giving it our own name, now we can  
145:42 - access it on our template side as latest question 
list. Okay, specifying that we want to use latest  
145:52 - question list instead, as an alternative approach, 
you could change your templates to match the new  
145:57 - default context variables, but it's a lot easier 
to just tell Django to use the variable that you  
146:02 - want, run the server and your new polling app 
based on generic views. So let's actually give  
146:09 - it a try. My server is indeed running, I'm 
going to refresh, I'll take a vote. And it  
146:15 - voted correctly. I'll vote for the sky. And it 
looks like it votes correctly. I will go to the  
146:20 - polls like homepage, just polls. And it shows 
me all the detail views for all of them. Right,  
146:28 - what's new? And when I go on, what's up, 
not only does it show me the detail view,  
146:32 - but it also shows me the choices that go along 
with it. So working fan in a fantastic way.  
146:44 - Right, your first Django app, Part Five? So what 
are we doing in this tutorial, we are going to  
146:53 - be doing a lot of automated testing. Okay, 
so what the hell is automated testing? Well,  
146:58 - here, let me break it down in a simple, easy to 
understand way. For you mere mortals out there.  
147:04 - Let's say you have something like Amazon, right? 
Something giant with millions of lines of code?  
147:11 - Are you really going to like every time you add 
a new feature, are you going to test all of the  
147:17 - older features to make sure that they're working 
correctly? Probably not, it's going to take up  
147:22 - a lot of your time plus, you're going to kill 
yourself. So what you're going to do is actually  
147:25 - write these automated tests. So every time you 
add a new feature to Amazon, let's say that you  
147:32 - add this new cool feature that recommends new 
shoes, you want to make sure that the ability,  
147:38 - when user clicks add to cart, that still 
works when a user clicks Checkout, that still  
147:44 - works. So what you would normally do is go and 
manually test it except because Amazon is so big,  
147:49 - you're not going to be doing that. So you're 
gonna write automated test, I'll test all of  
147:53 - those things every time you add a new feature. So 
when you add a new feature, it automatically tests  
147:57 - everything that was before it. That's the point of 
testing. Okay, that's kind of the beautiful thing  
148:03 - about it. Okay, so why you need to create tests, 
tests will save you time. Yep, they will save  
148:11 - you a lot of time. Because let's say you were to 
run into a bug or something unexpected behavior,  
148:16 - you will know exactly why it's happening. 
Or you'll catch on to it a lot faster. If  
148:21 - you have code that tests those things. as you go 
along. rather than waiting till everything breaks,  
148:27 - the whole world comes falling down. And then 
you're like, wait, what went wrong? Yeah, good  
148:32 - luck finding the bug in your millions of lines 
of code, right? You want to quality test, each  
148:38 - thing as it comes in. Tests don't just identify 
problems, they prevent them. Okay, so this helps  
148:45 - you identify any problematic new bugs that could 
be coming in. And not only like, identify them,  
148:51 - but prevent them before it even happens. almost 
think of testing kinda like if you just hired  
148:57 - people without interviewing them. I mean, you 
would have no, right, you would hire people  
149:02 - like this guy. And you would have people who you 
would have no control over, don't know. And like,  
149:08 - let's say something was going wrong in your 
company, you're not going to know who to blame,  
149:12 - because you never really tested any person, right. 
But if you run through an interview or a test with  
149:19 - them, then oftentimes you don't even have to hire 
them. And you can kind of prevent it. Before that  
149:25 - problems spreads. Or if they're awesome, then you 
can add them in right to your company. Tests also  
149:30 - make your code more attractive. So basically, 
like, your code will look nice if you have tests  
149:36 - otherwise, developers won't take you seriously and 
test how teams work together. So if your team is  
149:42 - working, and some complex applications will be 
maintained by teams right and test guaranteed  
149:47 - that call leagues don't inadvertently break your 
code, and that you don't break theirs without  
149:53 - knowing. So this way, it also helps you when you 
get employed and you have a job. You know, a lot  
149:59 - We'll help you identify like where the problem is 
coming from and the people who are working with  
150:03 - you on your team, they know exactly what you're 
thinking. And won't cause problems in your code  
150:10 - either. So those are the benefits of testing. 
Now you have some basic testing strategies,  
150:17 - something called a test driven development, 
it's a pretty common thing. It's called TD d,  
150:24 - t, d. d, okay? And basically, it's like testing 
as you go, rather than wait till I write my  
150:29 - millions of lines of code and then freaking 
test it right? Wait till I have 30 employees,  
150:34 - and then I'll ask them and interview them and find 
out like, don't do that test as you go. Okay. Now,  
150:42 - all we're gonna do is we're gonna write our 
first test. So, oh, we identify our bug who  
150:49 - look at that. Well, they purposely planted a bug 
in our code. And now we're going to use testing  
150:54 - to solve it. Okay, we're gonna go Sherlock Holmes. 
Alright, so fortunately, there's a little bug in  
151:03 - the polls application for us to fix right away. 
The question was published recently. So you guys  
151:07 - remember that a little method we had was published 
recently in our models for question. Well, it had  
151:14 - a little bug. And basically how it works is the 
method returns true if the question was published  
151:18 - within the last day, which is correct. So if it 
was within the last 24 hours, it shows you true,  
151:24 - but it also shows you true if it was published in 
the future. Okay. So it shouldn't say that it's  
151:34 - recent, if it was going to happen in the future, 
right? You wouldn't say, Oh, I recently got a car,  
151:38 - if you're going to get a car 20 years from 
now, when you finally get a job, right? So  
151:42 - I'm just kidding, you probably already have a job 
I don't. Let's continue to check if the bug really  
151:50 - exists using the admin create a question whose 
date lies in the future and check the method,  
151:54 - check and check the method using the shell. So 
first, we're going to check what's going on using  
151:59 - the shell. Alright, so let's go back to our code. 
Alright, so the first thing we're going to do is  
152:04 - run our Python. So we're gonna run that from 
we're gonna do Python managed up py shell,  
152:10 - don't just do Python and hit enter, like an idiot 
like I kind of did. So once you run the Python  
152:20 - with this particular shell, then what happens 
is you can like import your, you know, models  
152:26 - and everything. Okay, so now import date time, 
we're going to do from Django dot utils, import  
152:34 - timezone. And then we're going to do from polls 
dot models import question on. With that said,  
152:43 - Now we're going to create a question instance with 
the publication date, 30 days in the future. Okay,  
152:50 - so how does this work? We're going to create a 
variable called a future question. And we're gonna  
152:55 - create it from the question class. And we will 
say the pub date is equal to timezone dot now,  
153:02 - so we're saying that it's published right 
now. And then, but to that timezone, now,  
153:10 - we're going to add some time to it. Okay, so 
we're going to do date, time, dot time, delta,  
153:17 - and we will do days is equal to 30. Just like 
that. Okay, and then we're going to hit enter. So  
153:23 - I say i'm saying is like, right now plus 30 days, 
which in other words, translates 30 days from now.  
153:30 - Right. So basically, right now, where I am at and 
what my current day for me is February 20. Okay.  
153:38 - 2018. So it's gonna do February 20 plus 30, days 
after February 20. Okay, so no, it's not gonna  
153:46 - be February 15. It's gonna be March something, 
right? Cool. Was it published recently? Now we're  
153:57 - going to ask it, and it should say no, it's not 
published recently, right? It should return false,  
154:01 - except that it returns true. So there you have it, 
we know that something with our code is broken,  
154:09 - right? So since things in the future or not 
recent, this is clearly wrong. Now we're  
154:16 - going to create a test to expose the bug. So right 
now we expose the bug through the command line,  
154:22 - right? We just use the interactive terminal shell. 
But like, you don't want to be doing that every  
154:26 - single time. You also don't want to be doing that 
manually, every single time. So we're gonna write  
154:33 - a test for it, they'll automatically test it for 
us. Okay, cool. So now we're going to go into our  
154:40 - test file and write this code and then I'll kind 
of break it down. So in our under our polls app,  
154:46 - we're going to go into our tests and we will paste 
this guy here. Okay, I copied over everything  
154:52 - and I pasted it over it. So what's going on? 
we're importing date time, just like we did in  
154:56 - the shell. we're importing timezone nor importing 
test case. And we're importing the question model  
155:03 - from our models. And how is this working? The 
class is we're calling a question model tests.  
155:10 - So the good idea is like, every time you want to 
test, a model, make a class for that test. Ok.  
155:18 - So this way, it's nice and organized. This class 
inherits from test case that's coming from here,  
155:25 - you kind of put that in without really thinking 
about it. Okay, just like, look at the Django  
155:29 - Doc's is saying, and just like follow it all 
along, it's not necessary for you to like, learn  
155:33 - about this test case class and how it's being 
inherited and like, get a PhD in it, you can,  
155:38 - but it's not necessary. And then, for a year, 
the name of the function that you're testing,  
155:45 - you want to a good practice, you want to like 
break each thing you're testing have a function  
155:50 - for that particularly, right. So for example, if 
I go into my models, I have a method called was  
155:58 - published recently. So since we want to test that 
specific method, under that class, look, I'm doing  
156:03 - test was published recently, right? And name, 
the test make it pretty specific. So somebody  
156:11 - who's reading your test method, or your test 
function should kind of know what it's supposed  
156:16 - to do just from reading the name. So we're testing 
was published recently, but with future question,  
156:22 - so what if the question was like, published 30 
days in advance? Right? Here's the documentation  
156:29 - for it was published recently returns false for 
questions whose publication date is in the future?  
156:32 - Cool. That's what it's supposed to do. Except 
it doesn't do that. So now we're checking this,  
156:39 - okay. We're saying, hey, set the time to 30 days 
from now, that's what this is doing. And then we  
156:45 - make the future question just from question 
class. And then we set the publication date  
156:53 - to that particular time from here, line 16. And 
then on line 18. We're just saying, hey, assert,  
156:59 - if this is this, however, this turns to true, 
as we saw earlier, right, like right here. So  
157:12 - this is gonna this whole thing, what if you run 
it right now is going to turn to true. And that's  
157:18 - really the problem that we're having, right? And 
we need to fix that in our tests. We'll expose it,  
157:23 - how do we run our tests, we're just going to go 
to our command line. And we're going to do Python  
157:27 - managed up pi test polls. So I'm going to exit 
out of this exit. And now I will simply do python  
157:35 - manage.pi. Test polls. So what I'm saying is like 
test the polls app, and then it'll automatically  
157:42 - basically run the test.py file inside of the 
polls, after you created, run it. And look,  
157:49 - it says failed failures is equal to one. And 
basically, it says assertion error, it tried this  
157:56 - line solve that assert is and what it found out 
was this was not this. And so it's an assertion  
158:04 - error, and it says true is not false. Now, 
if this whole thing evaluated to false,  
158:09 - which is it's supposed to, then it would go false 
as false. And then this thing would return true,  
158:15 - and it will throw any errors, okay. Now, as you 
have more and more tests in here, all you'll have  
158:23 - to do is just run that once, or you can set up 
a web server, it runs that once automatically.  
158:28 - And that way, it'll only alert you if something's 
broken. Otherwise, it'll just go silently. That's  
158:33 - the beauty of tests. By the way, have you 
guys ever heard the song Fly Me To The Moon,  
158:40 - but I've been in love with it, and I can't stop 
thinking about it's like playing in my head, non  
158:47 - stop. Anyways, let's continue. So what happened 
is this, Python managed up pi test pulls, looked  
158:54 - for tests in the polls application. And explain 
that to already. It found a subclass of the Django  
159:01 - test, a test case, subclass. It created a special 
database for the purpose of testing. If I go here,  
159:09 - look, it says destroying test database. So it 
created its own database from what was happening  
159:14 - right now. It looks for test methods, ones whose 
ones whose names begin with test. Okay, so it's  
159:22 - looking for everything that starts with test. 
If you don't have these, starting with tests,  
159:26 - it will find it okay. So like, let's just say it 
was like this, and I'll hit save, and then we'll  
159:32 - also run this test polls. And it didn't even find 
it. It said ran zero test and zero seconds. But  
159:38 - as soon as I do that, and if I run it, boom, ran. 
It created a in tests was published recently with  
159:51 - feature requests, it created a question instance, 
whose publication field is 30 days in the future,  
159:54 - right over here. And using the cert is method 
discovered. It was published recently returns  
160:01 - true though we want to return false what we found 
out here, cool. The test informs us which test  
160:09 - failed and even the line on which the failure 
occurred. So here, it'll tell us which line we  
160:15 - failed on line 18. Right? This is line 18. Cool. 
So now we're gonna go ahead and fix this bug. How  
160:26 - are we going to fix it? Well, this is the code 
that's gonna help us fix it, we already know what  
160:31 - the problem is. amend the method and models up UI. 
So it will return true if the date is also in the  
160:37 - past. So we're gonna go into models. And we will 
change this to this indentation and whitespace in  
160:48 - Python is important. So make sure it's indented 
correctly underneath this was published recently  
160:53 - method. And basically, we're saying, hey, set the 
timezone to now like exactly right now and then  
161:00 - subtract one day from now, if that's less than 
or equal to the publish, and check if that's  
161:09 - less than or equal to the self published date. 
Okay, so if that's less than or equal to the  
161:13 - published date, and then check if self published 
date is less than or equal to now. Okay, so in  
161:22 - other words, check that this publication date is 
in between this. And this. Does that make sense?  
161:34 - It has to be sandwiched between the two. And run 
the test again. So now I'm going to hit save. And  
161:46 - I will simply run the test again. And now look, 
it says ran one test. And it gave me an okay,  
161:54 - and it's saying destroying the database. So cool. 
It looks like it had no errors. It ran all the  
162:00 - tests successfully. If it showed me something red 
or said failures, I know something failed. So now  
162:10 - it's working. Cool. Now we can also do After 
identifying a bug, we wrote a test that exposes  
162:17 - it and corrected the bug in the code. So our test 
passes. Many other things might go wrong with our  
162:24 - application in the future, but we can be sure that 
we want inadvertently reintroduced this bug. So it  
162:30 - will automatically keep checking it and we will 
we're not going to be reintroducing this bug,  
162:33 - because we'll always find it because simply 
running the tests will warn us immediately,  
162:37 - we can consider this little portion 
of the application pin down safely,  
162:42 - forever. Pretty cool. I think that's pretty 
freakin cool. And now they're like, Alright, we're  
162:50 - gonna get into some more comprehensive tests. 
While we're here, we can further pin down the  
163:01 - was published recently method. In fact, it would 
be positively embarrassing if in fixing one bug,  
163:08 - we had introduced another. Cool, add two more test 
methods to the same class to test the behavior of  
163:18 - the method more comprehensively. So now we're 
going to test was we're going to test the was  
163:27 - published recently method with old question. 
And then we're also going to test it with recent  
163:32 - question. And we already have the future question. 
So you can only have three cases, future question,  
163:37 - recent question or old question. If a question 
is older than one day, it should basically say  
163:45 - that it's not. If the question is older than one 
day, it will should return false, it should say  
163:52 - it's not recent. If it's in the future, it should 
say it's not recent. If it's been posted less than  
164:01 - one day, then it should say it's recent. So for 
example, if we just look at this test code at  
164:06 - a high level, old question, look, it's ask it's 
making sure that it's asserting to be false. So  
164:17 - if it's one day and one second ago, right, so if 
it's one, if it's exactly one day ago, then what  
164:24 - it should do is it should say yes, it's still 
true. But if it's one day and one second ago,  
164:30 - now, I should say it's too late and it should be 
considered false. Okay, it should be considered  
164:37 - not recent, and then publish recently with recent 
or with recent question. So the question is, as  
164:44 - you can see here, not even one day ago, 23 hours, 
59 minutes and 59 seconds ago, almost one day, it  
164:52 - should assert it to be true. Okay. But take these 
and we will go into our Our tests, and we will add  
165:02 - this into our tests. Okay? There we go 12341234 
and 1234123412341234. Okay, so just make sure that  
165:29 - it's all indented correctly, and then that you 
should be good there. So now we have all of those  
165:36 - scenarios covered future old or recent question. 
Let's run our test. And let's see if we have any  
165:43 - bugs. No bugs, it looks like our method is working 
perfectly. Okay. Just so you understand this code  
165:55 - right here, it will only return true when the 
publication date is in between this and that.  
166:01 - Okay, so this is basically saying it's within one 
day. And this is saying it's less than now. Okay,  
166:13 - so if this is in between Illa match. And now 
we have three tests that confirmed the question  
166:20 - was published recently returned sensible values 
for past recent future questions? Good. Again,  
166:27 - polls is a simple application, but however complex 
it grows in the future, and whatever other code  
166:32 - interacts with, we now have some guarantee that 
the method we have written tests for will behave  
166:37 - in expected ways. Test the view so you can also 
test views. The polls application is fairly  
166:46 - undiscriminating, it will publish any question 
including ones whose publication date feel lies  
166:53 - in the future, we should improve this setting a 
publication date in the future should mean that  
166:56 - the question is published at that moment, but 
invisible until then. Alright, so what are we  
167:01 - doing here? Well, when we post our question, if 
it's some data in the future, it shouldn't show  
167:09 - it just like for example, on WordPress, if you 
publish a blog post for let's say, you know, two  
167:15 - days later, it doesn't show until two days later, 
right, you can schedule your post or on YouTube,  
167:21 - sometimes I schedule my videos. And you know, I'll 
say real show this video to the audience in one  
167:28 - week from now, right. So if I do show it from one 
week from now, it shouldn't be showing it. At that  
167:36 - same time, that would be crazy. That wouldn't make 
sense. Just like that. We also want to do with our  
167:42 - questions and make sure that it doesn't just show 
out of nowhere. And we want to make a test for a  
167:47 - view. When we fix a bug above, we wrote the test 
first and then the code to fix it. In fact, that  
167:53 - was a simple example of test driven development. 
But it doesn't really matter in which order we do  
167:57 - the work. In our first test, we focus closely on 
the internal behavior of the code for this test,  
168:03 - we want to check its behavior as it would be 
experienced by a user through a web browser.  
168:07 - Okay. So the first one, it was like the logic 
of the code. This one we're focusing on what  
168:13 - happens if the user is like, testing it, and 
the user is actually on the front end of the  
168:18 - website? What does it show to them. And isn't 
that cool, so you can automatically test that  
168:25 - every time your code runs, and you don't have 
to like go and check if your cart is working,  
168:29 - or your blog is showing things like that. Alright, 
so the Django test client, so here's the command,  
168:35 - we're going to go in our command line and type in 
so I'm going to copy this guy again. And remember,  
168:43 - we got to do Python, manage that py shell, then 
paste this guy, and then we will get set up test  
168:49 - environment just like that. Okay. installed the 
template render, which will allow us to blah,  
168:58 - blah, blah, blah, blah, okay. We will get this 
guy and then we will also this say something about  
169:04 - timezone, so make sure your timezone is correct. 
Mine is in America slash Los Angeles, if I go  
169:12 - in my settings and show you for you, it might be 
something different. So you can go in this, go to  
169:19 - this link and look up what your timezone is okay. 
So we're going to import the client and then we're  
169:32 - going to create an instance of the client. So here 
we're creating an instance. And now we can get a  
169:39 - response from our home page now. When the response 
from your home page should give you something like  
169:46 - not found or a 404 it's because if you go to your 
home page, there's nothing there right if you just  
169:53 - go to right now your localhost 127 dot o dot o dot 
one colon eight And it should give you an error.  
170:01 - The only routes that are mapped is like if you 
go to slash admin or if you go to slash polls,  
170:06 - remember that. So that's why the home is giving 
us a 404. Right now, we should expect a 404. From  
170:14 - that address. Let's just do response dot status 
code. And here it is 404. We should expect to find  
170:22 - something at polls though. Okay, so let's try that 
we'll use reverse, rather than a hard coded URL.  
170:28 - So instead of doing like, you know, whatever slash 
polls, we're gonna just do a reverse here. Okay,  
170:37 - so from Django, we're gonna import, reverse. 
And we'll paste this guy right here. And now,  
170:46 - if we do response, that status code, it shows 
me something, if I do response, it's saying,  
170:51 - template response status code is 200. And it's a 
text slash HTML file, which it is. Okay, and now  
171:01 - we can also get the content, we can do response 
content. So now showing me the content of that  
171:05 - file. And if you remember, we do have a unordered 
list in the start. And then we have bullet points.  
171:13 - So here you have what's cracking. in HTML to show 
an apostrophe, they have to do this ampersand  
171:21 - number sign, 39, semi colon, that's basically 
apostrophe. And we also have another question  
171:32 - what's new, and you can see their links here as 
well. Okay. So this is like just showing the code  
171:40 - version of what the user or we actually see on the 
front end. And we can also do a response context  
171:49 - and get the latest question list. And look 
at give us the questions, what's cracking,  
171:54 - what's new, what's up? Now we can improve our 
view as well, the list of Polish, the the list  
172:03 - of poll shows polls that aren't published yet. 
Those that have publication date in the future,  
172:09 - let's fix that. So right, that's a problem. So we 
need to fix that. We introduced a class based view  
172:17 - based on list view. So we're gonna go ahead and 
fix things in there. Now we need to amend it. So  
172:22 - let's go to our views and our index view, we need 
to fix this. And changes that also checks the date  
172:32 - by comparing it with the timezone. Now, first, we 
need to add an import. So at the top of our code,  
172:38 - we're going to add this here, import timezone. 
And then our query set. We're going to change it  
172:50 - a bit. So where is our query set? All right, can 
we put this on one line? So it looks slightly less  
173:06 - confusing? Yeah, we're fine. We're not following 
Pep eight. We're running across a little bit.  
173:11 - But according to my boy, Raymond, the Oji, heading 
anger, or head injure. You know, according to him,  
173:21 - he says 90 to 95 characters should be good enough. 
Pepe, I think with the whole 80 character line,  
173:28 - that's kind of stupid. Because, honestly, breaking 
this down into new lines, messes up the code  
173:34 - readability. But right now, this looks pretty 
easy to read, if you just have it much easier if  
173:40 - you just have it on one line anyway. Okay, what 
is it doing? It returns the last five published  
173:45 - questions, not including those set to be published 
in the future. All right. So how is it doing that?  
173:51 - It's taking the questions model. It's finding all 
the objects and it's filtering those objects and  
173:58 - only finding the following. Okay. This statement 
here, it's looking at the publication date,  
174:07 - and it's only finding so this underscore 
underscore, lt means you're doing a reverse  
174:12 - search. And you're saying less than or equal to, 
that's what LTE means less than or equal to. So  
174:18 - any publication date that was less than or equal 
to the current time meaning only past or current  
174:25 - posts, filter those. And then once we find those, 
we order those by descending publication date. So  
174:36 - which one was the most recent ones? And then we 
show the first five, that's it. Okay. A lot going  
174:47 - on. And now we can also test our new view. So 
now you can satisfy yourself that this behaves as  
174:52 - expected by firing up the run server, loading the 
site in your browser creating questions with dates  
174:58 - in the past and future and type checking that 
only those that have been published are listed.  
175:03 - You don't want to have to do that every single 
time you make a change that might affect this.  
175:08 - So let's create a test based on our shell session 
above seashells. See, what is it? See She sells  
175:18 - seashells down the seashore. Okay, as a falling 
two poles slash test dot p y poles. Alright,  
175:34 - we're adding reverse boom. And we'll create a 
shortcut function to create questions as well as a  
175:42 - new test class. So this will create questions for 
us. Cool. Since this is not going to be a method  
175:50 - is going to be a function, we're going to put it 
outside like that. This will create questions,  
175:57 - how will it create questions, you give it a 
question text and you give it days? And then  
176:01 - what it does is it'll create a question Would that 
number of days in the future? Or would that number  
176:08 - of days in the past based on whether you pass in a 
positive number here, or a negative number here or  
176:14 - something like zero? Okay. Right here, and then it 
goes into question that I've just entered creates  
176:22 - that object in questions class. And for the 
question, text keyword argument and passes  
176:29 - in question texts, and for the pub date, keyword 
argument passes in the time, which it gets from  
176:34 - here. Cool. Cool. Okay, so question view index, 
what are we doing there? Question view, question  
176:45 - index view test. So we're creating a new class 
here. So I'm going to go right there and paste  
176:51 - it and save. So now we're creating tests for our 
index view. Instead of model. Okay, so this is our  
177:01 - model test. And what we're saying is like test no 
questions, if no question exists, and appropriate,  
177:07 - and appropriate messages displayed. So if I go 
into my views, and you can see, in my views,  
177:17 - let's see, is there is it not there? Or is it an R 
h, I think it's in our HTML right index. So here,  
177:28 - you can see it says if there are recent questions 
and show them else said, No polls are available.  
177:35 - So we want to test that it actually does 
say no polls are available on our front end,  
177:41 - we can actually do that, and right here and we 
say, hey, first, check that the status code for  
177:49 - this page is a 200. Meaning that you actually 
find this page second test that that response  
177:56 - that you find it contains no polls are available. 
Okay, so right now, remember, we have no questions  
178:04 - at the moment. And then also, make sure that 
the cert query set is equal to the response  
178:13 - is equal to the following. So this thing? latest 
question list should be empty. That makes sense,  
178:22 - right? That means there are no questions, such as 
a no polls are available. And it should check that  
178:26 - this is actually just an empty list. Cool. Now, 
what we want to do is test past questions. Okay,  
178:42 - again, this could go on, could this go on one 
line, or this will be too crazy? This is pretty  
178:51 - crazy. So I can I can break that up a little 
bit. That's fine. Still readable for me? Okay,  
179:00 - so we're saying? If we create a question, 
okay. Again, this creates its own database,  
179:10 - so it doesn't have our what's cracking and 
whatever tests available anymore for these tests,  
179:15 - it creates its own database, and then it destroys 
that database afterward. So within this database,  
179:20 - we're creating a question and the question texts 
will be called past question instead of what's  
179:26 - cracking or what's poppin or whatever. And we're 
gonna say that it should be 30. It should have  
179:32 - been created 30 days ago. Okay, so this is a past 
question, hence, test past question. And then what  
179:42 - we're going to say is, hey, response, get that 
particular page. And once we get that page, we  
179:49 - want to say, Hey, is the are the latest questions 
of that page contain that question? And the answer  
179:56 - will be yes, it does. Because we just created it. 
Right here. And if this thing is equal to this,  
180:03 - then the test should pass. We're also going to 
create a future question. So this should test  
180:18 - a question 30 days in the future, pretty much 
the same thing. And make sure that a response  
180:27 - contains no polls are available. That makes sense, 
right? Because if the question is in the future,  
180:34 - then it shouldn't be available right now. So it 
should say no polls are available. And also make  
180:41 - sure that the response context latest question is 
empty. Because there are no latest questions is  
180:48 - going to be posted in the future. Okay. Cool. 
And let's check this guy with the recent and  
180:58 - past questions. Again, think it's a little bit 
more readable like that. You can break it down  
181:09 - like this, that should be fine, too. But I like it 
like this. And basically, what we're testing here  
181:15 - is that this thing should equal to this thing. 
And what's going on here? Are the doc for this  
181:24 - as this is test future question and past question, 
even if both past and future questions exist, only  
181:30 - past questions are displayed. That makes sense 
to and how does it work? We create a question 30  
181:37 - days in the past, we create a question 30 days in 
the future? Question. One is called past question.  
181:44 - Question two is called future question. We get the 
polls index page. And then we say that this thing,  
181:54 - the latest question list should only have 
the past question those created 30 days ago,  
182:00 - and not the recent question. And it should match 
that. And indeed, and it should, right? If we did  
182:07 - everything, right, we shouldn't get an error if we 
run this. And then all we need to do is define to  
182:13 - past questions. All right, now this is getting 
a little too big. So let's break this one down  
182:28 - now. And you can indent this too. Okay, so what 
am I saying here? I'm saying? So test to past  
182:50 - questions. So the questions index page may display 
multiple questions. So we also want to see that it  
182:56 - doesn't just display one question. It displays 
multiple ones, right? So we have past question,  
183:01 - one, which was created 30 days ago, we have past 
question two, which was created five days ago,  
183:05 - we get the polls index page. And then we say make 
sure that the question list. Actually, let's do it  
183:15 - like this? Because I think it's more readable, 
actually. So you want to say that this should  
183:20 - equal to this? latest question list should have 
both of the past questions. Why in this order?  
183:29 - Because remember, the most recent ones it shows 
at first, right? If we look at our views, and how  
183:36 - it does it, ascending order, sorry, descending 
order, and then the five. So that's why that's  
183:45 - why I would show the past question to first. 
And then this one right here. Cool. Basically,  
183:53 - the most recent question and show all the way 
at the top. Alright, so first of the question,  
184:02 - shortcut function, create question to take some 
repetition? Yeah, well, we pretty much went over  
184:10 - this whole thing. So we don't have to check that 
answer. So on in effect, we are using the test to  
184:15 - tell a story of admin input and user experience 
on the site and checking that at every state. And  
184:20 - for every new change in the state of the system, 
the expected results are published. Now. That's a  
184:26 - really important point, like you're telling a 
story with your test guys like this is what's  
184:31 - really important to understand. So if you're 
working on a team with somebody and somebody  
184:34 - is reading through your test, they understand 
what each of your view is supposed to do,  
184:39 - and what it's supposed to return like so so, 
so key, like if I'm looking at somebody's code,  
184:45 - I don't know what the hell it's supposed to 
do, right? I don't know what the right answer  
184:49 - is supposed to be. But if I look at their tests, 
and they have like bunch of examples, and what  
184:54 - the correct answer and the wrong answer should be 
and that these documentation I totally understand  
185:01 - what each function is supposed to do what each 
class is supposed to do. And then effectively,  
185:06 - I'm on the same page. And then I can actually 
contribute to this project, right, I can go,  
185:11 - that's where you guys hear like, hey, just go 
ahead and contribute to open source projects is  
185:16 - one of the ways that you can do that. Understand, 
look at their test first. And then, like, I can't  
185:21 - tell you enough, for those of you who are a little 
bit more advanced to understand the library,  
185:25 - here's a pro tip, one of the best ways to do it is 
not just like, instead of just reading the code,  
185:30 - go and look at their tests, and they will have so 
many things in there and what it's supposed to do,  
185:36 - you'll start understanding how this library 
supposed to work, and it's how it's supposed  
185:40 - to behave, literally tells a story. Now we want 
to test the detail view. Okay. So what we have  
185:55 - works well, however, even though future questions 
don't appear in the index, users can still reach  
186:00 - them if they know or guests the right URL. So 
we need to add a similar constraint to detail  
186:06 - view. Okay, so we don't want to our users to 
be able to reach those questions, obviously,  
186:12 - because they don't exist. So they shouldn't just 
be able to go to that particular URL. Okay, like,  
186:23 - let's say you had a blog post, like, whatever 
your blog post is called banana. So it's like,  
186:32 - john comm slash blog slash banana. If 
you scheduled it for like, a month later,  
186:39 - I shouldn't be able to just go to it from the URL. 
Okay, so what's going on here? We have the detail  
186:50 - view. So let's go into our views. Let's go into 
our detail view. It's right here. What do they  
186:55 - want us to do? They want us to create a query set 
and do this with it. Okay, excludes any questions  
187:02 - that aren't published yet. So filter, make sure 
the publication date is less than or equal to,  
187:08 - then the time zone now. That's, that's it. That's 
essentially it. And those are the only ones you  
187:18 - can check. Pretty cool. Okay. Very, very powerful. 
Again, you can see how powerful the generic method  
187:25 - is. And of course, we will add some tests to check 
that a question is publication date is in the past  
187:33 - can be displayed, and now one with the publication 
date in the future is not. So let's go into our  
187:43 - tests. And let's add the test for this. So again, 
it's a new class, it should have its own methods  
187:55 - and everything, right. So for the index view, we 
created a class. Okay, for those tests. And now,  
188:06 - for our detail views, we're also creating a class. 
Okay, very important. Now we test future question  
188:14 - and we test pass question, how do we do that? 
We create the question five days in advance,  
188:19 - we send you to the polls Detail page. So like, for 
example, on Instagram, if you click into a image,  
188:31 - and it shows you that specific image that's 
equivalent in our app of polls, detail, or  
188:38 - questions, detail view. And for the arguments, we 
give it that questions ID from right here. And as  
188:47 - a response, we get that particular URL, and then 
we say, hey, make sure that the response actually  
188:53 - returns a 404. And it will, because here's 
how we told it. And then test pass question.  
189:08 - So basically, here we're saying 404, meaning 
it doesn't exist, right. So the detail view of  
189:14 - a question or the publication date in the past 
displays two questions, text. So past question  
189:21 - we create the question here is created five 
days ago. We get the URL for the polls detail,  
189:28 - and we pass an ID for the past question. And then 
as a response, we get that specific URL. And then  
189:37 - we assert and make sure that it can the response 
contains the following thing. So response, and  
189:42 - then it should have the question text in there. 
Okay. It's a past question. Question text. Cool.  
189:50 - And, let's see. Let us Let's see if we're gonna be 
using any more command line stuff or not. Let's go  
189:59 - an exit. And let's just see right now for tests 
are working. In our poll slash views, something's  
190:07 - happening on line 18. What is happening? Ah, oh, 
okay, it's not indented correctly, obviously. Save  
190:28 - up and Enter. And look at that all our tests ran 
in here. And they all ran successfully. So you can  
190:38 - see all these tests have already gotten pretty 
complicated, and they're testing our app pretty  
190:43 - thoroughly. You know, this is not something you 
want to do manually every single time, and you  
190:49 - can already see the power of it. Alright, ideas 
for more tests. So we got to add similar query  
191:02 - set method to results view and create a new test 
class for that view. So we can also test results  
191:07 - view. It'll be very similar to what we have just 
created. In fact, there'll be a lot of repetition,  
191:14 - we could also improve our application and other 
ways adding tests along the way, for example, it's  
191:18 - silly that questions can be published on the site 
that have no choices. So our views could check  
191:25 - for this and exclude such questions. Our tests 
could create a question without choice and then  
191:29 - test that it's not published, as well as create a 
similar question with choices and test that it is  
191:35 - published. Also, you can have logged in admin 
users who should be allowed to see unpublished  
191:42 - questions, but like ordinary visitors shouldn't 
be. So if you're an admin, right, and you have  
191:46 - WordPress blog, and you schedule one in advance, 
you can see it but other people can't just like,  
191:51 - I can't schedule my YouTube videos, you can see it 
I can. whatever needs to be added to the software  
191:58 - to accomplish this should be accompanied by a test 
whether you write the test first and then make the  
192:03 - code pass the test. This is the test driven way 
of doing it. Or work out the logic in your code  
192:10 - first, and then write a test to prove it. At a 
certain point, you're bound to look at your test  
192:15 - and wonder whether your code is suffering from 
test bloat, which brings us to the following.  
192:20 - So the thing that they say is when testing more 
is actually better. Okay. So it might seem that  
192:29 - your test is going out of control. And there's a 
lot of like test bloat. And you know what? Your  
192:34 - beautiful, elegant and concise code compared to 
your tests looks so much better. That's totally  
192:39 - okay. Tests are supposed to be bulky and a 
lot. And they should cover your ass. Okay,  
192:46 - that's their job. And so they don't have to look 
pretty, they don't have to look beautiful, they  
192:50 - have to tell a story and have to tell it clearly. 
So it doesn't matter. Right? let them grow. And  
192:57 - for the most part, you can write a test once and 
then forget about it, it will continue performing  
193:02 - its useful function. As you continue to develop 
your program. Sometimes they will need to be  
193:07 - updated just like we had to update ours, telling 
us exactly which test needs to be amended to bring  
193:14 - up to date so that extent, tests help look after 
themselves. At worst, as you continue developing,  
193:20 - you might find that you have some tests that are 
redundant. In testing redundancy is actually a  
193:26 - good thing. And even that redundancy is not a 
problem. Okay? So the more you test, the better  
193:34 - and you don't have to go back and wipe anything 
clean. As long as they're sensibly arranged,  
193:41 - they won't become unmanageable, okay? So the good 
rules of thumbs. Good rules of thumb include the  
193:47 - following. You should have a separate test class 
for each model or view. So for remember, for each  
193:53 - of our models, right, or question model, question 
model test, we had a different class for this. And  
194:02 - for each of our views, we actually had a different 
class for a detail view, we had a different class  
194:09 - for our index view. And if you wanted to go 
further, we could also add a different class for  
194:15 - our results view. A separate test method for each 
set of conditions you want to test. So instead of  
194:23 - testing test, no questions has passed question and 
kind of like testing an all in one, it's a good  
194:29 - idea to break it down into separate different 
tests. Each test doing only one job so here  
194:35 - if no questions exist, and appropriate message 
displayed, that's what this is. Test is supposed  
194:40 - to do. This test over here. Questions with the 
publication date in the past are displayed on  
194:46 - this page. Like you can see each each test is 
trying to do one and one thing only. Okay. test  
194:57 - method names that describe their functions. So the 
names themselves should describe the function of  
195:02 - the test. Okay, so test no questions, test pass 
questions, test future questions. And once you  
195:07 - build this naming convention, you and your team 
starts understanding it. And most of the times,  
195:12 - you guys will be able to just look at each other 
tests and know what your app is supposed to be  
195:16 - doing, or it's not supposed to be doing. further 
testing, this tutorial only introduces some of the  
195:24 - basics of testing, there's a great deal more that 
you can do and a number of very useful tools at  
195:29 - your disposal to achieve some very clever things. 
For example, so this is a pretty cool part. Right  
195:37 - now, we just kind of tested our back end and 
a little bit of our front end. But what if we  
195:41 - wanted to test our JavaScript and how it loads and 
literally, like, moving the mouse, like have the  
195:48 - computer, move the mouse and select one of the 
votes and click vote? How does that experience  
195:53 - work? How can we test that on autopilot? where 
it happens automatically? Well, there's something  
195:58 - called selenium, selenium, or Selenium. And 
it's a way to test your HTML actually renders  
196:06 - in a browser. Okay. So these tools allow you to 
check not just the behavior of your Django code,  
196:12 - but also, for example of your JavaScript and your 
browser, pretty freaking mind blowing. It's quite  
196:20 - something to see the tests, launch a browser and 
start interacting with your site as if a human  
196:26 - being were driving it. And Django includes live 
server testcase, to facilitate integration with  
196:32 - tools like selenium, okay, so if you want to get 
more advanced, look up Django and selenium. And  
196:39 - you can even look up YouTube videos online and 
add those kinds of tests within your app. If  
196:44 - you have a complex application, you may want to 
run tests automatically with every commit for  
196:50 - the purposes of continuous integration. So if you 
guys know about GitHub, and commits, you can make  
196:57 - it so that when you're writing the code, and as 
soon as you commit it, I like to call it like the  
197:03 - time machine, because that's what Git and version 
control allows you to do. You can make it so then  
197:08 - it tests it on every commit. So that if any one 
of your commits, you know fails any of the tests,  
197:15 - it'll be like, Hey, this is broken. And you'll 
find out right away, before you actually push  
197:20 - that code onto GitHub, and destroy your life, 
embarrass yourself, Let down your family and be  
197:27 - fired from your job. So that quality control 
it is itself at least partially automated,  
197:34 - a good way, a good way to spot untested parts of 
your application is to check code coverage. This  
197:41 - also helps identify fragile or even dead 
code. If you can't test a piece of code,  
197:46 - it usually means that code should be refactored or 
removed. that's those are some big words. coverage  
197:54 - will help to identify dead code c integration 
coverage dot p y. And you can check you know  
198:02 - what's dead code and what's not. And, yeah, so 
a lot of testing, I hope that you enjoyed that.  
198:14 - We're going to be covering essentially how static 
files work in Jango. Okay, and how you can use  
198:20 - them to customize your apps look and feel. Okay, 
so without any further ado, let's jump right into  
198:29 - it. Okay, so writing your first app, Part Six, 
right? So how are what are we doing now? Now  
198:36 - we've built a tested web poll application. If you 
haven't done that, go back to part five. If you  
198:41 - haven't done part five, go back to Part Part Four. 
Make sure you're following this in order. And now  
198:49 - will now add a stylesheet and an image. Okay. So 
aside from HTML that your app generates, right,  
198:57 - and shows which is your front end, so far, the 
voting thing that we have, or it shows some text  
199:03 - with radio buttons, your website needs to be able 
to do other things to like show people images,  
199:09 - or pictures of cats or blog post images. It also 
needs to be able to serve up JavaScript if you  
199:16 - have any JavaScript, right? So for example, if 
you don't know what JavaScript is, is totally  
199:20 - fine. But like, anytime you're clicking a button, 
and it like pops up a menu kind of thing. That's  
199:25 - usually JavaScript going on there. Okay. If 
you click something like a pop up comes up,  
199:30 - there's JavaScript, JavaScript is pretty much 
everywhere. So your website needs to be able  
199:35 - to show some JavaScript and it also needs 
to be able to serve CSS, okay, which is,  
199:42 - it's called CAS stands for cascading style sheet 
and you use this to stylize your app and make it  
199:50 - look cool and beautiful. Okay. And yeah, so 
that's usually what's necessary to complete  
199:57 - a web page. In Django. We refer to these files as 
static files. Now for small projects, right? This  
200:06 - isn't a big deal, because you can just keep the 
static file somewhere where your web server can  
200:11 - find it. However, in bigger projects, especially 
those comprise of like multiple attributes,  
200:16 - if you have multiple apps like polls and blog, 
and e commerce, like whatever, dealing with  
200:22 - the multiple sets of static files provided by 
each application starts to get tricky. That's  
200:28 - why Django contrib that static files is there for 
you, if you're a beginner, don't worry about this  
200:34 - part too much. But this is for more advanced 
people mentioning this part, okay? Otherwise,  
200:39 - I've kind of skipped over. It collects static 
files from each of your applications and any other  
200:45 - places you specify into a single location that can 
be that can easily be served in production. Okay,  
200:52 - so now let's get to customizing your app's look 
and feel. So first, we're going to need to create  
200:59 - a directory called static in your polls directory. 
Okay, so let's go ahead and do that. And I  
201:03 - will open up, Adam, and we will go in our polls. 
Hopefully, you can see that on the left hand side,  
201:10 - I don't know how to make tab bigger. So I'm 
sorry about that. But yeah, we're gonna go  
201:15 - inside of our polls, and inside of our polls, 
I think this is where it wants us to make it.  
201:21 - So I'm going to right click this polls, not the 
templates one. So right click, right click here,  
201:27 - create a new folder and call it static. Done. 
Okay, cool. And for those of you wondering, like,  
201:40 - how do I switch like that it's command and tab, 
and on Windows, that's all done tab. Cool. Django  
201:49 - will look for static files. They're similarly 
to how Django finds templates inside polls,  
201:53 - template polls slash templates. So you know how 
there's like polls slash templates, and Django  
201:58 - automatically looks for templates there. Well, 
just like that, for your static files, Django  
202:03 - is going to look inside of your folder static. 
Okay, so Django static file setting contains a  
202:09 - list of finders that know how to discover static 
files from various sources. One of the defaults  
202:14 - is AB directories finder, which looks for a static 
subdirectory in each of the installed apps, okay,  
202:21 - so Django will automatically look for a folder 
called static under each of the installed apps.  
202:30 - Okay, so right now, we have polls as one of our 
apps that we created. And remember to install  
202:35 - this app, we had to do this line in our settings 
file under installed apps. And then, now Django  
202:45 - is able to find its static folder. If you have 
another app, again, like a blog app, and you have  
202:54 - static folder under there and you install the blog 
app, then you'll be able to then Django will be  
202:59 - able to find the blogs, blog apps, static files, 
okay, like images, JavaScript, CSS, those are all  
203:06 - considered static files. All right, the admin uses 
the same directory structure for its static files.  
203:15 - Cool. So admin site works the same way. Within 
the static directory, you've just created creating  
203:22 - another directory called polls. So inside of 
static, we're going to create another directory,  
203:27 - and we're going to call it polls, okay? So kind of 
like how you have polls, templates, polls, you're  
203:34 - gonna have polls, static polls, okay, similar. And 
then inside of here, we're going to create a file  
203:41 - called styles dot CSS, I'm going to do new file, 
and I'll do style dot CSS, just like that. Okay,  
203:48 - so this is our CSS. Again, in the command line, 
if you haven't activated your virtual environment,  
203:55 - make sure to do conda or sorry, source, activate 
my sites. If you haven't done that, just in case  
204:04 - you need to do something in the command line, 
which you're not going to in this video i don't  
204:07 - think because of how the app directories find 
your static files. Find your works you can refer  
204:15 - to this data file and Django simply as polls slash 
styles dot CSS similar to how you reference a path  
204:21 - for templates. So remember how for templates 
you just go pole slash index dot HTML well  
204:25 - for this is pole slash style dot CSS, okay. And 
for namespacing it's just like templates. So the  
204:34 - same reason why you put templates under the same 
reason why you make a new folder called polls,  
204:44 - under templates is the same reason why you create 
another folder called polls under static it so  
204:50 - then if you have multiple different apps, there 
is no collision based on like you having the same  
204:55 - name for any of your CSS files or any of your HTML 
Mel files. That's what they're saying here. Okay,  
205:04 - now we're gonna do some fun CSS stuff, okay, 
and we're going to keep it pretty simple. So  
205:09 - in our style dot CSS, what I'm basically saying is 
that any link tag under a bullet point are listed  
205:19 - thing, color red and green. Okay? So A stands for 
is like your link tags, anything that contains a  
205:27 - link, basically returning for now returning almost 
all of our links on our current site green. Next,  
205:36 - add the following at the top of polls, slash 
templates, slash polls slash index dot HTML. So  
205:42 - we're going to go in our templates polls index 
dot HTML, and at the top we're going to add is  
205:48 - we're going to say load static. So we're going to 
add that right here, load static. So what this is  
205:54 - not able to do is load our static files. And 
then right here, I'm going to add this. So I'm  
206:03 - creating, I'm creating a link to a stylesheet. The 
type is text slash CSS. And the link is this. Now  
206:10 - I'm using the link in a dynamic way. This is 
the best way to link it instead of like hard  
206:17 - coding natural path. And you just say Polo slash 
style dot CSS, okay, that's how we refer to it.  
206:24 - And that's pretty much it. Okay, so now, let's 
go to our, our website. So I'm gonna do Python,  
206:33 - manage that py run server. And we're gonna 
open up a new tab, and I'm going to go 127  
206:42 - that slash 1000. Or I'm sorry, slash polls. 
And you can see that all the links are green,  
206:52 - right, if I go back to my stylesheet, and turn it 
into something else. So let's go back into sorry,  
207:00 - style that CSS is right there, I'll bring it 
here. If I change this to like blue, save,  
207:07 - Command S go back here refresh, you can see that 
all of this is now blue. If your didn't turn blue,  
207:13 - close out of your server, or break the server with 
Ctrl C, and then try it again and then should be  
207:20 - fixed. And Yep, there we go. And also make sure to 
save Okay, and another way to go to this same link  
207:29 - is doing HTTP localhost colon 8000. Slash polls, 
okay. And that should take you to localhost colon  
207:36 - 8000 slash pauses the same thing as your 
127 dot o dot o dot one colon 8000. Do the  
207:42 - same thing. Alright, so that's essentially how 
we got that to work. Bring this guy here. Now,  
207:52 - we also can add a background image. Okay, so we'll 
create a subdirectory for images create an images  
207:58 - subdirectory. So basically, inside of our static, 
and polls, we're going to create static holes,  
208:09 - we're going to create a new directory, and we're 
going to call it images. This is where we're  
208:14 - going to put all up all of our images. So it 
should look like this. And then you can put  
208:20 - whatever image you want, right background dot GIF, 
or. So what we'll do is we'll go online and like,  
208:27 - grab an image. So let's get cats. Right click, 
and then just save the image. And you can save  
208:41 - it whatever you I'm going to call it like 
cat back round. Oh, sorry, we can just save  
208:47 - it wherever we want. I'm going to save it under 
my site, my site, or sorry, polls, static polls,  
208:54 - images, and I'm going to save this cat underscore 
background. And it's automatically dot JPG file.  
209:01 - Because I have the format selected like that. I'm 
going to hit save. It saved I'm going to open up  
209:07 - my atom. And under images, I now have my cat 
background JPEG. So let's go back to this  
209:15 - tutorial. And it's basically saying to do this, 
add this to your style sheet. So I'm going to add  
209:23 - this now, I'm going to say so from images 
instead of background that GIF mine is called  
209:32 - cat underscore background dot jpg, like that. So 
now, it's gonna find basically in our HTML code,  
209:43 - it's going to find anywhere we have the body tag, 
it's gonna make its background, this cat image,  
209:51 - okay, so if I go to, you know, our index dot 
HTML, if any of this stuff is In a body tag,  
210:00 - it'll add that to the background. So let's check 
it out. It says, and you should see the background  
210:08 - loaded in the top left of the screen. Okay, let's 
give it a try. Let's see if they're in line. And  
210:14 - there you go. It's there, right? So pretty cool 
how it works. And what I could also do is I could  
210:25 - go to my index dot HTML, and like wrap maybe 
a certain part of it in the body tag. So like,  
210:31 - maybe the part that's in the for loop, right? So 
I can, I can go like, body tag. And I can choose  
210:42 - to close the body tag outside of this unordered 
list, I can go body like that. Okay, if I want to,  
210:53 - and I go back, I refresh. And the same thing. 
Okay. So this is essentially like a little bit  
211:02 - of how HTML and CSS like talk with each other. 
Okay, and now let's look at kind of their last  
211:12 - notes here. So there, okay, so warning, of course, 
the static template tag is not available for use  
211:18 - in static files, like your style sheet, which 
aren't generated by Django. So in your CSS file,  
211:23 - you can't use something like, static. Like that. 
It's not going to know what that is. And you can  
211:33 - do like if then statements here. These are just 
your static files, hence, they're not dynamic and  
211:40 - can't do like variables and cool stuff, right? 
Like your index, your HTML file can with the,  
211:46 - which has a Django templating. system. And in 
there, you should always use relative paths.  
211:54 - So here, we're not using like, slash user slash 
clever programmers slash GitHub, slash my site,  
212:04 - slash my site or slash polls, slash what else is 
it? static slash polls slash images, right, we're  
212:17 - not using the absolute path. That's the definition 
of absolute path, we're using a relative path to  
212:23 - it. Do you're satisfied between each other because 
then you can change static underscore URL. So this  
212:30 - is again, a little bit more advanced. I'm gonna 
I'm gonna skip over this one. But you can read  
212:33 - that if you want. And that's essentially how you 
work with general like static files on Django.  
212:42 - There you have it, folks, I hope you enjoyed this 
tutorial. I hope it was informative, and juicy,  
212:48 - and you loved it. If you did love it, please leave 
a comment, please like it and share it with at  
212:55 - least one friend. Because if you have at least one 
friend or family member, sorry, what's happening  
213:02 - in my mind, if you have one friend or one family 
member who's doing development alongside you,  
213:07 - is going to boost your success rate up by at least 
60%. They have like scientific studies on this. So  
213:14 - share it, maybe somebody will watch it alongside 
and you will become web developers together.

Cleaned transcript:

What is up, how's it going? This is kazi from clever programmer calm. What I wanted to cover in this series is Django. And what I wanted to cover was like the most commonly referenced Django documentation, I personally couldn't really find any videos of people like covering it. So I just wanted to do that. Because, you know, I see, like everybody who starts learning Django, this is the first place you're gonna go to like the docs, the Django official documentation that shows you how to, you know, do their getting started guide. And so I just want to kind of cover that in this series. And just right now, I just want to kind of cover the overview, and then we're gonna jump into actually, the parts of the tutorial, okay, and you're just gonna follow me along. Alright, so I'm going to cover this kind of touch on this. So if you have some experience with it, it will make a little bit of sense. So designing your models. So in Django, you can kind of design your database and models like this, you don't need to type in raw SQL queries or mess with too many ora, or MS is just simply classes. So it's literally like Python and object oriented programming, and boom, you have stuff populating your database, which is pretty cool. It also has a built in kind of API. So it says, you know, as soon as your models are done, the API is created on the fly, no code generation necessary. Okay. So here, you can see that if you create a model, like let's say that you're creating an app, right, it has reporters, and your app has articles, you know, well, what you can just do is just be like, hey, reported, I'd objects dot all. And they'll tell you how many reporters are there. For example, if you made a game app for like, let's say, a street fighter, and you did fighter dot objects at all, it might say empty set, which means you didn't put in any fighters yet, right. But then let's say you create a fighter or a reporter with the name john smith, and you save it. Then when you check objects at all, all of a sudden, you'll say, hey, reporter john smith actually does exist. So that's pretty cool. And a really nice way to interface with it. And then also, you can search for things in a really easy way to so you can search in your database with an ID. But you know, a lot of the times what a more human way to search instead of an ID is like searching with, what does the name start with or if the name contains the word myth, which Smith actually contains, and l match it. So then what you can do on your front end later is right now like you're not going to have your client interface with draft from the code command line, right? What you can do later is then give them a front end and interface so then they can actually type it in the search bar and look up john smith or typing myth. And they'll still find john smith. Kind of like when you guys go to like Shopify stores, or, you know, YouTube and type in a videos name. And even if you're off, you'll still find it, it's using this contained search mechanism, which Django comes built in with. Another thing I want to touch on is, yeah, so if you have your model, you can register them in the admin interface with just a simple line that says admin dot site dot register. And then that model votes lets you create the article model, you can now register it in the admin interface. So then you can go and point and click an admin interface, and then delete, or create new articles or whatnot, right? For example, when you have a WordPress blog, you know how you have an admin interface there. And you can create a new blog post or delete a post or edit, you have full crud functionality? Well, that's what it mimics by you just doing this, right. And that's you creating code from scratch. That's kind of powerful. And then, obviously, lets you design your URLs, right, so how do you want your URLs to be, so for example, you can have it like, you know, my ab.com slash articles slash the year, followed by whatever, right, so you can create your own URL, parameters, and whatever. So this is pretty standard. But it looks Django lets you do it in a really clean way, especially with Django 2.0, their new latest release. Alright, so writing your views is also pretty easy. You can have a just like return HTTP response or HTML file you made. So for example, here you can see, we render and return like this archive dot html file. So if you create a HTML file in your templates, then it's going to be there. Again, if you're watching this and you're like, I'm a complete beginner and I have no idea what the heck you're talking about. Don't worry. If this part is just not making any sense, skip a little bit ahead to the part where we jump into the tutorial. This is just for People who are maybe coming from other frameworks, and they want to grasp how Python and Django is working, okay, so you do need some experience to understand what I'm talking about here. And then yeah, templates are using, it's, it's using Django templates, which is kind of like Jinja. I'll go into this later. So at this point, like, let's just get started. Alright, so for your installation, all you really need to do is make sure you have Python installed. So for myself, I got Anaconda installed, which is, which is what I would recommend for you. So if you do Anaconda, download online, kind of install that. And that's pretty much all you need to go on. And then obviously, install Django as well, which I'll show you in one second, okay. All right, and then you can go ahead and create a project. So we're going to just get started from scratch and follow along with this tutorial. So let's, let's get started. Okay, so I'm gonna open up my command line here. So I'm just gonna open up my terminal. If you're watching this, you can open up your, you know, CMD on Windows, or, what I recommend installing is cmd. Er, on your Windows. And, yeah, basically just see if you have Anaconda installed. And if you do, and if you type in conda, this distinction come up, okay. If you don't have Anaconda installed, that's okay, you can still follow me along. But what I'm doing here is kind of like for best practice. So if you want to do it, like the best practice way, then I recommend that you get conda installed here, let me just make this a little bit smaller. Alright, so basically, what I want to do here is first, check my J. So what I'm going to do is install my environment with conda. Okay, so I'm going to do and, again, installing Anaconda. And like making you understand everything about virtual environments is outside the scope of this specific tutorial. So you can look up stuff, like how to install Anaconda on Windows, or how to install Anaconda on a Mac. But I'm just going to go ahead and do conda. Or, first I'm going to create this project. So let's see, I'm going to go to my GitHub. Alright, what I've also done is I have gone into preferences in my atom. And I have went in under install, and I've installed terminal, platform meal ID terminal, and I've installed it. So then the beauty of that is that when I'm coding, right, if I'm coding, I can just pop open my terminal, right in here, and I don't have to leave my adult. So I will do Django admin, start project my site, like that, and then go into my site. Okay, and then I will come over here, and I will open, I'll go to GitHub, and then I'll go my site, and then just click that. Okay, that's about it. This is just so if you guys are following along, like I don't want you to get confused. Okay, I'm gonna open up my Chrome. So they're saying that this is pretty much what it should look like. And for us, it does look like that, right? We have my site, and it has all these files inside of it, and you can see my site, and it has all these files inside of that. Okay. Um, and then they say, hey, just go ahead and run Python manage that py run server. So let's go ahead and give that a try. So I'm gonna open up my terminal and how I do that how I open up the little prompt is by doing Command Shift P. for you on Windows, that might be a different command, like maybe Ctrl Shift P. But yeah, for me, that opens it up and then I just click terminal pops open my terminal. I'm going to do conda create dash dash name. My site's Python is equal to 3.6. And I will activate this environment. Okay, and now I will install Django. Okay, so if I do PIP freeze, it should show me that Django and much other stuff is installed Jango right here, so we're good. Alright, I'm just gonna make the font bigger so you guys can see it a lot easier. Okay, so now, we're going to try to run this Python managed up py run server. And we will go to this URL on our chrome and see if it shows us something. Okay, cool. So it says install works successfully congratulations. And, believe it or not, this is actually pretty exciting, because this is the first hint that your app is actually running. Okay. Now to this, we're going to add a lot more features to it and make it really awesome. But right now, it's being actually served over your localhost, and it's running, okay. And once we get it to a point where it's doing a lot of cool stuff, we'll develop it locally, and then later on, or you can even do is and put it online, so then anybody in the world can use your Django app. Let's go back. And let's take a look at what the tutorial is telling us to do at this point. So it says that you should see this stuff, and we do. And then it says, ignore the warning about unapplied database migrations for now. We'll deal with the database shortly. Cool. And it says we have started Django development server, which is a lightweight web server written purely in Python. We've included this with Django, so you can develop things rapidly without having to deal with configuring a production server such as paci until you're ready for production. Cool. All right. And they say don't use the server in anything resembling a production environments tended for developing cool, no problem. All right. And now they want us to get started on creating the polls, polls app. Now that your environment a project is set up, you're set to start doing work. Each application you write in Django consists of a pure hour of a Python package that follows a certain convention. Django comes with a utility that automatically generates a basic directory structure of an app, so you can focus on writing code rather than creating directories. Cool. All right, projects vs. app. So what's the difference between a project and an app? Now, the cool thing with Django is that everything is considered an app. Okay, so let's say that you create a website that has a blog that has an e commerce capability. Now, the blog is considered a so let's say you created this website with Django, right, the blog would be considered a Django app, and your ecommerce store would actually be considered a different Django app. Okay. So there'll be two different apps that your web application is comprised of. That's how Jango handles the logic. So basically, it's one project that has multiple apps inside of it. Okay, that's pretty much what they're saying here. Okay, so an app is a web application that does something. Okay. So a web blog system, a database of public records are simple pull up a project is a collection of configuration apps for a particular website. A project can contain multiple apps, an app can be in multiple projects. So you can have one app that you build for one project, and you can actually have it in different projects that you're doing, which is really cool. It's like plug and chug. Your apps can live anywhere on your Python path. In this tutorial, we will create our poll app right next year, manage that py file, so that it can be imported as its own top level module rather than a sub module of my site. Okay. To create your app, make sure you're in the same directory as manage.py and type this command. Okay, so now this command Python manage that py startup polls, we're going to do that, okay. So, we're going to break our server with Ctrl C. case I did that I'm going to hit LS, and it looks like I'm at the same level as my manage.py file, and if I had pwd, pwd will show me where I'm at. And now, I'm going to do Python managed.py start app. And the app is called polls, I believe just let's just double check. Okay, so now our polls app is created. And let's just take a look inside of polls. Polls. Okay. So inside of polls, you can see that we have a bunch of Oh, actually, let's look right over here. It's easier that way. So Paul's comes with migrations in net dot p y, admin apps, models, tests, views. There's a lot of things That polls comes up with automatically, which is really nice. But a lot of this stuff is, you know, just kind of empty. The main things that you're going to be working with is models and views, okay, that's, that's the thing you're going to be working with like all the time, when you're developing apps for yourself later, you're also going to be playing around quite, you're going to be doing adding stuff to test to make sure you can test your app as you're building it. And then migrations is going to be important, because it's going to kind of let you time travel in your database. So when we keep making changes to your database, with migrations, you can like roll forward to a certain time. But let's say like things get really messed up, you can roll back to a previous point in time. All right. So the disk directory structure will how's the poll application. So this is the directory structure that we actually saw, okay. And now they want us to write our first view of view is what lets you go to a specific URL, and then it returns some kind of response. Okay. So for example, so Django works off of something called MVT, which is called Model View templates, your normal apps, you know, node.js, or whatever those frameworks work off of MVC model view controller. So to give you an example of this in real life, is when you go to google.com, slash, you know, when you go to google.com, and you type in like cats, right? Or let's say you go to google.com. And you type in whatever the response that comes to you, right, that maps to the current URL you're at. So how does Google know to show you the Google logo and the Google homepage when you go to google.com? Right. So google.com, when you type it in, it sees what your current URL path is, then it goes into the Google code base. And then it finds this HTML file that says, if somebody goes to this path that says google.com, then show them this HTML page that has Google's image on it, followed by a search bar, and then shows you that, okay, so it returns a response, you request something and it returns a response. If you go to apple.com, slash, watches, or watch, I don't know if that's actually a real Apple URL, but like, let's just say you're trying to get an Apple Watch. Okay? So if you go to apple.com, slash watch, how would it return to you all of their watches, right? So what actually happens is apple.com slash watch will match that path in their code base. And then it'll see if there is a HTML file that corresponds to it. And it'll show you that HTML file, okay, as a response. And that's essentially what we're going to do. Well, we're going to have a very basic version of it. So we're going to go in our poll slash views that py. So I'm in my polls, and I'm going to go in my views that py. So when they say it, like this poll slash views that py, that's what they mean. And in here, I'm going to say from Django dot HTTP import HTTP response. Right. And then I'm going to go here, I'll say define index requests, take in a request, and then return an HTTP response. And I will say, Hello, world, your ad. Let's do it with double quotes, because, hello, world, you're at the polls index, right. And then they have a little comma here, this doesn't matter so much, there's just a string. So it doesn't matter what you do. Make sure you always save what you're doing, because otherwise it won't take any effect. So make sure you do Ctrl S or Command S the whole time. So I just created this, but the thing is that it's not going to show up. So now what I need to do is like, tell my app that when somebody goes to the home page, yo, you got to show this exact this thing right here. Okay. This is the simplest view possible in Django to call the view, we need to map it to a URL and for this, we need a URL con for a URL configuration. To create a URL confit in the polls directory, create a file called URLs dot p y. Your app directory should now look like this. So now notice there's a URLs dot p y here, which was not there before. Okay, so we're going to go in our polls, right click here and create a new file and call it urls.pi. Okay, And now in our URLs, r p y, we got to add from Django dot URLs, import path from Django dot URLs, import path. And then we're going to do from import views. And then we're going to do URL patterns. So what you want to do is try not to indent, but use four spaces instead. Okay? 1234 if it doesn't automatically bring you to the right place. All right. And I want to do pass. So if somebody goes to the empty path, then I want you to go into our views file and use the index function. And we're going to call give it a name index. Okay? So what does this mean? If somebody goes to, let's say, your website is called john, calm, right? somebody goes to john calm, followed by nothing else. So not like john calm slash article slash blog, none of that is just john calm your homepage. What happens? Well, then we say, going to the views file and run the index function. So in under views, this is index function, I'll run that. We're naming it index. So then later, if we want to, from our templates, or HTML, if you want to refer to this specific URL path, we can just call it by index, no, reference it. Okay, the next step is to point the route URL configuration at the polls, that URLs module. Okay, so you're all content, and we got to point it to this. So Alright, in my site slash urls.pi, add an import for Django dot URLs include and insert include in the URL patterns list. So you have this. So we're going to go in our my site slash URLs right here. And in here, we're going to add this line, okay? Because we're saying if somebody goes to the path polls, then run the polls, URLs. Okay. So from Django contrib, import admin from Django, import from Django dot URLs, import include, comma path, okay. And that's because we're gonna do the include thing right now, just like that. Okay, and then hit save. So if somebody types in john comm slash polls, now we'll say, hey, try to match this pattern by going to the polls, our URLs file. Well, where's that that's in the polls app. And it's this file right here. So then it'll go to this file, and then it'll match this first guy, and they'll say, Okay, I'm going to run the home function, okay. So anytime somebody goes, anything, polls will refer to that file, that URLs file. Alright, the, this is what they're basically saying here. The include function allows referencing other URL cons, whenever genuine counters include, it chops off whatever part of the URL match up to that point, and sends the remaining string to the included URL con for further processing. The idea behind include is to make it easy to plug and play URLs. Since poles are in their own URL client, they can be placed under or any path and that will still work. Okay, you have now wired. So now it says, You should always include, you should always use include when you include other URL patterns. Okay. And now it says you have now wired an index view into the urine. Let's verify it's working. Run the following command. Okay, so now we're going to run this thing. And we'll go to our localhost or this HTTP is port over here. And hit run. And now we are getting an error. Oh, yes. Basically, you have to do slash polls, okay, of course. Because it's not a home page thing that we've added to because I just saw this and I was like, oh, homepage, but it's because we got to go to the polls path. Okay. So everything after so it's like, when you put this online, when you put this app online, right, it will essentially be like, your app comm slash polls, is where you'll have to go to and then I'll know what to do. Okay, so let's say you're at the polls index. And that's exactly what we see. Now. Cool. Go to this in your browser, you should see the text which you define in the index. The path function is Pat is passed four arguments to require In view and to optional, at this point, it's worth reviewing what these arguments are for. Alright, so we're not going to go into too much detail is going to be like still casual, and we're gonna keep moving forward. We're gonna do part two of the official Django tutorial, we have already done quite a bit of stuff, right, we've gotten our local servers started. But what we want to do now is in this video, we're gonna actually cover our admin interface, and we're gonna actually start playing around with it. So it's gonna be pretty exciting. I hope you're willing and excited to see how that works. Okay, and we're going to go through this one a little bit faster. So Okay, so first thing we want to do is like, look at the database setup, which you can, frankly ignore if you're new. But later on, like, this is something that you should read. But for now, we're only going to focus on this command that says Python managed up, py migrate. Okay, so this is a complete continuation from the last video, okay, so make sure you're caught up on everything from part one, I'm gonna open up Adam. And I'm going to break out of this by doing Ctrl. C, and I will do Python managed up, py migrate, and it should give you a bunch of okays. And what that did is created these tables that weren't created before, okay. So they're all created, like stuff with usernames and emails, and permissions and all the stuff that it has to do on the back end. Okay. All right. And from here, we're going to go on, and we're going to try to now create models. Alright, so we'll define your models, essentially, your database layout with some additional metadata. How Django models work is their philosophy follows the DRI principle, which stands for do not repeat yourself, which is a really common, commonly used acronym in the programming world. And it emphasizes using logic that helps you never really repeat yourself, right. So for example, just to give you a simple example, imagine if you had to print out a letter or print out the word Boom, 100 times, you could keep writing print, boom, print, boom, print, boom. Or you could do it in the dry way, which is write a for loop that prints it out 100 times, okay? So that way, it allows you to stop yourself from repeating, and just helps you do it at once. Now, when you start abstracting it and taking it to a higher level, that might mean taking your code from basic, basic code, and modularizing it into a function or into a class or into a package, things of that nature, okay. And that's the same philosophy Jango goes off on so instead of like, repeating yourself over and over again, it lets you create a class, which then creates models out of and handles a lot of that stuff for you. Okay, so we're going to create this these models, okay, and basically what we're going to be working on in our simple poll app, we're going to create two models question and a choice. A question as a question and a publication dates, almost imagine like a spreadsheet. Let's say you create a new sheet in the spreadsheet and you call the sheet question. You have column one that says question tax, column two that has a publication date. So question tax on your first row might be, what the hell is going on? And the publication date may be like, February, whatever. And your next question might be like, when is causing you going to make the next piece of content, stop making all these crazy videos where he's outside talking to the camera, and then your publication date next to it, right? So that's how I want you to picture when we create these models. Alright, with that said, let's move on. Our choice is going to be its own spreadsheet or its own sheet. Okay. And basically, what it does is a choice has two fields, the text of the choice and a vote Tally. Okay. So the chat text and the vote Tally. And then the question that you get to choose is actually referenced from the question model. Okay, so let's actually now write this code out. So let's go to our polls. And I'm just going to copy paste it, I recommend that you actually write it out because it's really helpful exercise for you. But just for a time, I'm going to go through it faster, we're going to put it I'm going to paste it right here. Okay, I'm going to save it. Alright. Now we have to activate our models. Okay, so I'm going to go into my settings, my site slash settings. And inside of here, I want to tell Django that we actually have this app installed. Okay. So what I want to do is polls dot apps dot, I think it's polls config like that, okay, and make sure to put a comma after it because after all it is a list with 1234567 elements. Okay, so now Django knows to include the polls app, let's run another command. So up until now Django had no idea what this thing that you created this polls app. But now that you went in my site and added this under settings and added to your installed apps, now it knows that it's actually there. Okay. It's the equivalent of kind of like, let's say you downloaded an app on your Mac or your windows, but you never installed it, right, like downloaded a game, but you never installed it's kind of like that. So we just installed it by doing this. Okay, and now what we want to do is let's run another command, Python, manage that py make migrations polls, okay? So I'm going to come in to my command line. And again, to activate your virtual environment, you'll do source activate, followed by the name of your virtual environment. And to deactivate your virtual environment, you will do source deactivate if you're on a Mac, if you're on Windows, and all you need to do is activate, followed by the name of your virtual environment. So in this case, it will be my site. Okay, so since I'm already activated on my virtual environment, I'm just going to do Python manage that py make migrations, poles. And now you see that it says Create model choice, create model question, add field question to choice, okay. All right. By running make migrations, you're telling Django that you've made some changes to your models, in this case, you've made new ones, and that you'd like to change this to be stored as a migration. Cool. And this is effectively what the sequel will look like for this. So this is not something you have to worry about. If you're a beginner, and you don't even know what SQL is totally fine. But if you have a little bit of experience, check it out. What's really cool is like a bunch of this code that you would normally add, like generally anything to do with databases requires you to know SQL or write SQL, okay, SQL. And for you to write raw SQL, it looks pretty complicated, right? Like, for example, if you go here, there's a lot going on. If you write SQL every day may not be that big of a deal, but it's a lot going on. Whereas Django, it's automatically generating all this code for you. And you don't actually even have to worry about it, I just showed it to you. So you can see what it actually looks like, on the back end. So that's what they're showing here. And we're not just gonna, we're not going to worry about that. And since we made the migrations, we're going to commit those migrations to our database by doing Python managed.pi and typing in migrate. Okay, so now it says applying polls initial, and it says, Okay, if I go to my migrations, I can also see this specific migration that I made, okay, and I can read this migration whenever I want. Do not mess around with this file too much unless you know exactly what you're doing. Okay, cool. And now we're going to play with the API. Another thing about migrations, when you get a little bit more advanced, it allows you to update your database without ever losing track of it. So flask has kind of a weird migration thing going on, whereas Django kind of comes with it. And so it's databases a lot easier to play around with. Like it says, migrations are very powerful that you choose your models over time, as you develop your project without the need to delete your database or tables and make new ones. That's generally what you have to do. If you're working with, you know, like just kind of working from scratch. It specializes in upgrading your database live without losing data. So again, this is going to be really powerful and helpful as you get more advanced. And as you do more things with models. So now let's play around with the API that actually Django gives to us for free. Alright, so we don't actually have to write it, it just kind of comes with it. So I'm going to go and instead of just typing in Python, I'm going to do Python manage.py shell, okay. And here, I will do from polls on models, import question, comma, choice. And then now we can play around with it. So since we don't have any questions in our system yet, when we actually look up questions, and the objects for it, it should show us empty, right, because we didn't create any thing from in the question model. Guess if I do this at all. It should show us none. And that's exactly what is showing us like, hey, the query set is actually empty. Now what we want to do is create a new question. All right. Django expects a time date use time. So now instead of this and it will do the right thing. Okay, so we're gonna go from Django dot utils import timezone. Okay. And what does our question take? Remember, if we look in our questions model, it takes two things. It takes a question tax and a publication date. And that's what we want to give it to create a new question object, okay. So pretty much typed that in what is it saying? It's saying, Hey, I'm creating a question object. This question. Class essentially takes in a few things, question tax and publication date, and I'm using keyword arguments. So I'm putting question underscore text equals. So for the question text, it takes in a car field. So let's go actually here in models, and you can see that it takes in a character field right here. And that's why I'm actually passing it in as a string. And then publication date takes in date time field, and that's why I'm passing in the timezone dot now, object, okay. And just gonna hit enter here, and now, Q is created. So I should be able to do something like, well, let's follow along with their documentation is saying, but if we actually do this now, right question that objects dot all let's see if it shows us. So that's because we haven't saved this yet. So once we save it, it's going to show up in our as one of our created objects for a question. So let's follow along. So now it says, save the object into the database, you have to call save explicitly. So we're going to do that I'm going to say q dot save. And let's try it again. And now look, it shows us that there is indeed one question and that even has a number an extra one. Okay, but it's not very helpful, because it's not showing us what that question is. Or it's not giving us a very easily readable name when we actually use this API. So I'll show you guys how to overcome that, too. Alright, so now it has an ID if you do q.id, it'll show you its ID. It says access model field values via Python attributes. So I could do q question, tax. So that question text right there. And they'll show us like, what's new, and I can do q dot pub location, date. And they'll show me the date as a date time object 2018 two, which is February 19. And let's go down here. And we can even change the values by changing the attributes and then calling save on it. Okay. So for example, before we had the question, that's what's new, we can now save that question as What's up, okay. So for example, I can do cute question, underscore text is equal to what's up kids at home. And I can do q dot save. And now if I do Q, question, text, you'll see that it actually says what's up, right? displays all the questions in the database. So now if I again, do this, which you've seen, it'll show me all of the questions right. Now we only have one question. Okay. So if I wanted to add multiple questions, I could do that. You know, let's say that we add q2. And then I do q three, and then I go right over here. Instead of saying what's new, say what's poppin that, hit Enter. And now if I do question dot objects, dot all you can see that it shows me Oh, sorry, I have to save q2 dot save q three dot save. And now if I do this, you'll see that it shows me I've one question two questions, three questions. And I can even say for a question and question dot objects dot all I can loop through it, print question, dot question underscore text like that. And if I run that, it'll loop through all of these and then they'll print out the question text, okay, so you can do it. This is just like playing around with xAPI and kind of getting comfortable with it. Okay, and it's close. Wait a minute. Question isn't a helpful representation. You know this object? So let's fix that by editing the question model in the thing. So that's what I was talking about, right? Like, they're saying it in their technical terms. Basically what they're saying is like, hey, look, this looks ugly as hell, and doesn't give us any information like what this is about. So let's make it into something that a human can read and be like, Okay, I get what this question is, and it's readable, right? So that's what we want to do. All we need to do is add a string method. Okay, so we're going to add string representation to it, you'll see what I mean, in just a second. So right now just shows us like, blob like whatever, right? Well, we're going to do is under the class question, we're going to add string method like that. Okay. And it's going to take in self, and then we're going to say return self dot question underscore text, like that. Okay. So instead of showing us this, wouldn't it be nicer if it showed us that question? Because that's a much easier way of identifying what that question is, when you're just looking at the list. It's just more readable that way, okay. And we're going to do the same thing with choice, we're just going to go here, create a function, or create a method, because we're inside of a class. And I also self and I'm going to say return. So self dot, what do I want to do here? choice underscore tax. All right. And I don't think I have to here. Let's try it. Okay, cool. So now, it's important to add string methods to your models, not only for your convenience, own convenience when dealing with interactive prom, but also because object representations are used throughout Django is automatically generated admin. So later, when we go and I show you the admin, this is actually going to be helpful there. Because then when we're reading these names, the admin is going to be using it. All the however, we're showing it in the console right now is going to be showing it on our admin interface, right. So like, imagine, if you create an app, and you give it to your client, where it's like a blogging app, right, or if it's an e commerce app, you don't want them to go to the store. And when they're trying to differentiate between items, it just says item one, item two, item three, item four, it'd be much nicer if it says, like bicycle, or watch or iPhone x or whatever they're selling, right? It'll be easier for them to identify. That's essentially what we're doing right here. Note that these are normal Python methods, let's add a custom method just for demonstration. So they're adding a new method here. So we're going to do that I'm going to go into my models, and we will import date time at the top. And then we're also going to import timezone. Oops, right underneath this guy. And we will add this method under a question. Okay. Okay, so was published recently is a method in the question class, so you can do like q dance was published recently. And it will tell you what it's going to do is going to basically tell you true or false, okay, so I think what it's checking for is like if it was published within one day, or later than 24 hours, let's see what they say. No, the addition of import and to and from Django, import timezone. to reference Python standard date time module on Django is timezone related utilities, respectively. save these changes and start a new Python interactive shell by running Python managed up py shell again. Now, because we didn't make any changes to the models, we just added new methods, we don't have to migrate this to our database, all we need to do just like exit out of this shell and just like, come to it again, I'm gonna do exit open closed paren. And I'm just gonna do Python manage that py shell again. And then let's see if we can get that command from poles or models. So basically, from this file polls dot models, I'm importing this class question and this model choice model, both are models, classes, whatever. And make sure our string our addition is working. Okay, so now we're going to try to do the same thing except this time, it's not going to show us question whatever is gonna actually show us the text of each question. So there you go. What's up, what's new, what's poppin Okay, much easier for To see this Okay, so again think of it like if you had a fighter database instead of it saying fighter one fighter to fighter three, it show it to as like can write you and like say got Django provides a rich database lookup API is entirely driven by keyword arguments. Okay, so you can do something like, hey, I want you to filter by where the ID is one. So give me that specific question only, or I can say filter by 82. And it'll give me the question that has ID of two, okay? Or I can filter by question tax that says new inside of it, or what's new inside of it? Just like it's showing me here, like, if so let's try this one. Okay. So question text starts with what? Okay, so let's see. So far, all of these start with a what? So it's going to show us all three. But what if I do instead of starts with I say contains? And I say, often? Okay, there's only one question that contains that, okay, then later, we can provide a front end to our client where you can like, in the search bar, type it in, but on the back end, we're using this contains method to find the exact thing that you need, and then return it as a response from our HTML file. Get the question that was published this year. Okay. So let's get the question as published this year, we're gonna do this. We're gonna say current year is timezone. Now that year, so that's going to get basically 2018. Right? If I do current year, it'll say 2018. And question that objects I get, where the publication date, year is the current year. Okay. So let's do that. Get returned more than one question or turn three. So because we have multiple questions, instead of one, RS is going to be different than theirs very slightly. Okay. So for ours, since it matches all of them and gets like Yo, what's going on, I'm matching all of them. So but nothing to worry about, it's still working for us. If you request an ID that doesn't doesn't exist, it will raise an exception. So for us, we do have ID two, so it won't raise an exception. But like, let's say that we try to find something with an ID of four, or five. Sorry, we have to do dot get is going to raise an exception, okay. Also, for this, let's try. So what would happen if instead of dot get we use filter? Would we get an error? Or would we get something in return, we would get something in return, which is like, all of these that match it. Okay? So the difference between filter is like, return everything that matches and get is like get one. And if more than one match, then like throwing an error or something like that. Okay, so look up by a primary key is the most common use case. So Django provides a shortcut for a primary key lookups a falling question. The following is identical to questions that objects dot get ID, so PK, which is a primary key. Okay, so every model will have a primary key. So for example, question we'll have a primary key choice, we'll have a primary Kanda think about this is like, let's say you have a database with people in it right? or employee names. But what if you have two john smith employees, right out of 100? employees? Or what if you have two Apple watches in your ecommerce store that you're selling, that are the same name? Or the two people that have the same name? How are you going to differentiate? What if they have the same email address or whatever, right? So you need one thing that's always always always always unique. So if you can't rely on their first name, last name, or email address, or whatever else, one thing you can always rely on is a primary key. It could be an automatically generated key from Python and could be like random words or whatever, right? Django will handle the primary keys for you Everything will have a primary key even if it doesn't show it to you on the back end. This way, you can always find, you know, the unique way of referring to something, okay. All right. So let's go here saying that makes sure our custom method worked. So it says cute dogs that get PK one, okay, so basically what I'm going to do is go here and say hey, Get me the object where the primary key is one and save it as Q. And now I'm going to ask if q was published recently. Okay, and it says true. Okay, cool. So that's the result we got. Give the question question a couple of choices. The create call constructs a new choice object does insert statement as the choices set available choice and returns a new choice object. Django creates a set to hold other side of foreign key relation questions for which can be accessed via the API. Alright, so we're gonna do this guy again. If you haven't done so already, display any choices from the related objects set, so we don't have any choices so far. Okay. We're right now basically voting for questions kind of like you can upvote comments on YouTube. So now we're going to create three choices. So cue that choice that create. So we're going to take a question, which is our first question, which was like, what's up? And we're going to create choice taxes equal to not much with zero votes. Okay, and you can see choice has a field called votes, and then it has choice tax. So our first answer to that question, what's up is not much. But we're saying like, Look, it only has zero votes. Okay. Okay. And now we're going to create another choice, but called the sky, what's up the sky? I mean, I guess that's kind of funny. I say the ceiling. And then here's another one that is, and we're going to store this one actually. As see, Oh, okay. There we go. Okay, so now choice objects have API access to their related question objects, because then if I do see that question. So even though I've created this model from choice, you know, you'd be looking, I be like, hey, how does it have access to the specific question like, how did it access this field? Here's how I did it. Because we're saying, in this question, go to the foreign key, and the foreign key is this model over here. When I do choice question, it'll go and get the question from up there. That's essentially what it's doing. Okay. So that's what, when I do see that question, that's what's happening. It's referencing and getting me back this object. Okay. And vice versa. So you can also reference from question you could reference choice. Question objects had access to choice objects, okay. So they both have access to each other kind of like, you can have a book and, you know, like, who was the author of this book. So that relation goes to the author. And then you can say, like, this author has which books and it can relate back to the books. Alright, so now we're going to see how many choices we have. And so we have not much is one choice, the other one we have is the sky. And then the other choice that we have is just hacking again, all of these have zero votes, as we see right here. And we're gonna say q dot choice underscore set counts. So this is just a count that there are actually three choices. The API automatically follows relationships as far as you need us double underscores to separate relationships. This works as many levels deep as you want. There's no limit, find all choices for any questions whose publication date is in this year, we're using the current year variable we created above, okay. So I can say choice that objects or filter, question. Double underscore means like, you are kind of going backwards. So we're saying question, and then we're going publication date. Okay, so actually, we're going this question here, and then we're going to publication date, and then checking the year getting the year of that publication date. Okay. So let's try that right over here. So it's going to get us all the way questions that are from this current year. So it should get us all three of these. Let's delete one of the choices use delete for that. So now what I can say is, I can get the question that starts with just hacking. Right? And how do I do that? I say cue that choice set da filter by where choice text starts with just hacking. Okay, so it's only going to get one question that has just hacking in there. And if I do see, I'll show you which one it is. And now to deleted all I do is see dot delete. Again, I'm copy pasting, copying and pasting for time, purposes, saving time, but for yourself, like take the time to actually write all of this out, because it's very, very helpful for you. So now that I deleted, it showed me that it's deleted. And if we actually check again, right, it'll only show us these two choices right here. Okay. Now, we're going to get into a pretty exciting part, which is introducing the Django admin and we're actually going to just touch on it a little bit. And let's get started. This is a super cool part. philosophies of generating admin sites for your staff or clients to add, change and delete content is tedious work that doesn't require much creativity, okay? is usually like a pretty rinse and repeat process. It's frustrating, it's boring. You can make mistakes, it takes a lot of time, and development, and which means like, it'll cost your client a lot. And it slows down your development speed. For that reason, Django entirely automates creation of admin interfaces for models. Okay, so let's check it out. The admin isn't intended intended to be used by site visitors, it's for site managers. Okay. So now we're going to create an admin user, I'm going to do Python, manage that py create. So we're going to exit out of this and do Python, manage that py, create super user. And I'll leave this blank, I'll use this email. And even though it's not gonna show you anything here, it's still typing in your password. So don't worry about that. Okay, so you can put in whatever as your email, whatever is your username. And now the final step is to answer enter your password I have. And now it says start the development server. So we're going to do just that. I'm going to start the development server, we're going to go to Chrome, we're going to go to our local app on 127 dot 0.01, colon 8000 port, instead of polls, I'm actually going to go to admin. And when I go to admin, look, it brought up this nice interface that you and I did not make, we didn't make this beautiful looking form, where when you hover over log in it, like turns dark and looks good. And we didn't add functionality that add security, right? We didn't add this thing where passwords automatically looks like dots so nobody can see it. All of this keep in mind is just automatically generated. When I click login, boom, here's the administrator interface. Okay, so as the admin, you can change your password, you can log out, you can check what who are the users. So here's one user, you can like, go into this user and like delete this user, or change the permissions of this user, right? So you can go in and like boom, it's not a super user anymore, or is not a staff anymore. It's not active anymore. Or you can go in here and like change all kinds of permissions, like can delete choice can add a question but cannot like delete a question can change a session, but cannot delete a content type, you know, you can get like as specific with it as you want. And this is just for the model that we have registered new users. But imagine later when if we register our choice model and whatever, those will all show up right over here. And any recent actions that you do actually show up on the right hand side. So imagine like somebody deleted something, you're like, what the hell happened, like, one part of our app or this website is now broken? Well, if you go into recent actions, you'll see what took place and exactly who did it and who to hold responsible for that. I think that's pretty cool. Right and it comes built in right out of the gate. That's one of the reasons why Django is such a powerful tool. And it fosters productivity and effectiveness. I believe over any other framework, right. And their tagline, which is awesome. It's for Django is for perfectionist with deadlines. That's what I believe in to like, if I have to put a project together, and I'm doing something solo, I'm going Django, all day baby. But you know, if you're working on some long term project, you know, you're going to be doing for a long time, and nothing else really matters, then yeah, you can choose whatever you want. But I like speed, I like productivity, I like to take my ideas from my head and launch them online fast. Alright, with that said, let's go back and see what they're saying. So we go to our admin, enter the admin site. And now it says, make the poll app modifiable in the admin. How do we do that? We're going to take these three lines of code. So I'm going to go into my polls slash admin. And this line is already added. So I'm not going to add it in from dot models, import question. Okay. So basically, what I'm saying is from this directory, get the models, so right here. And import the class question from the models. Okay, so import the question model. And then I'm going to say, registered that model inside of admin. So check out what happens. Okay, this is super, super cool. Check it out. I'm gonna hit save. And let's go back to our app. And let's hit refresh. And look at that. It's here. That questions model is the one we made, it shows under polls, questions, and you can see all of those questions. What's poppin? What's new, you can go in and you can change the text. So I can change it to like, what's cracking? Right, I can hit save. And now it's changed. And if I go to my, if I start Python managed up py shell. From polls, dot models, import question. Question objects. All right, look, it says what's cracking. So what we actually changed from the GUI interface with our mouse, and our keyboard is now showing up in our database in our local database, SQL lite database actually being stored on our computer, this database is not online yet. So pretty freakin cool, right? How quickly and how effectively works. So I'm going to exit out of this, I'm going to run my server again. And we're going to go back to the app refresh. Cool. And like, let's see what they're saying. Now that we have registered question, Django knows that it should be displayed on the admin index page. And it is right and I showed it to you. And we went inside of it. And we saw question tax and we saw date published and we can actually change the date published and everything. Now things to note here, the form is automatically generated from the question model. So this form is automatically generated, we didn't generate anything, the different model field types, date, time field and car field. So remember, we had one of the models as a date time field, and the other one is car field. And you can see where it says date published load Date field, right? And for question, text is just a straight up character field, or what you know, in Python to be as a string. These correspond to the appropriate HTML input widget, each type of field knows how to display itself in the Django admin. Pretty cool. Each day time field gets free JavaScript shortcuts, whoo, free JavaScript shortcuts. That's awesome, too. Normally, you'd have to write JavaScript for all this stuff, but like, look at this, okay, so let's say I go to what's cracking, and I click here, boom, look at this beautiful date time picker thing opens up, and you could pick today, or you could pick another date, and like automatically pick it and you could pick the time. And that's cool. This is this is something you'd have to write a lot of manual JavaScript for, that's automatically written for you. Dates get it today, shortcut and calendar pop up and times get a now shortcut and convenient pop up that lists commonly entered times. The bottom part of the page gives you a couple of options, right? So save saves changes and returns the change list page for this type of object. So you can do save, or you can do save and continue editing. So continue editing the same page or you can just save and add another add a new question. Right. Or you can do delete, which displays a delete confirmation page. So check this out, okay? Normally when you hit, you have to add all this functionality. Plus when you hit delete, you have to then remember to add a confirmation thing to it. And they have it automatically. So if I hit delete, it'll be like, are you sure you want to delete the question? what's cracking? All of the following related items will be deleted. Questions, one. So only one question and objects. What's cracking? You can say yes, I'm sure or no, take me back. Now notice, it's showing the question is what's cracking? That's because of your string method that you added your str method. If you did not have that, it would not show like what's cracking, it was show like question one. And you just have to use your memory to remember that. I'm going to say no, take me back, and it'll take me back. Okay. Cool. Let's go back. Let's see what they're saying here. And then if the value of the date published doesn't match the time you create it, it probably means you forgot to set the time. We can also set the current timezone, right. So that's not a big deal. If I go in history here, it says I changed at 3am. It's not 3am right now. So that means like, I need to go inside of my settings and in my timezone and change what my timezone is. So for example, I think there's like, America slash Los Angeles, something like that. Oh, actually work sweet. for yourself, just look up like timezone Django timezone settings, and then find yours and put that in for me, I put this in, and it fixed my time instantly, right. Okay, so yeah, I essentially that's it for part two. We're gonna jump into part three. And we're gonna get started. So if you haven't already open up, Adam, go to where you created your mind site project, right? For me, it was in GitHub, my site, I'm going to click Open. And I'm going to say, whatever open and recover state. Cool. And here it is. And then if I do command, shift P and type in Terminal, my terminal pops up. But uh, bam, and also make sure to do source activate my site. And we are good. Okay, so writing your first Django app, part three. So what they're talking about here, is they're saying, okay, like, Look, you have everything in Jango is essentially called a view. Okay? So for example, if you have a blog homepage, that's a view, if you have the ability to comment, like a comment action, right? That's considered a view. If you click on a blog post, and it shows you the details we refer to that is a detail page, but that's still part of the view. That's essentially what they're saying right over here. Another example of this is like, let's say I take you to Instagram. So let's say I click on clever kasi, right? This is essentially for Instagram. And let me just plug my Instagram here to go follow me if you aren't already. Because awesome. And if you go here, right, like, Look, this is the home page for all my posts, okay, this would be considered the home page view. If I click into it, that's considered a detail view, because it's only showing that one particular post, okay, if I click here, that's a comment action, which is, you know, you can work that into the views. So just wanted to show you that. So you understand where all of this is coming from. Now, we come over here, and that's now they're saying that in our poll application, we're essentially going to have an index page in our views. So this is going to display the latest few questions. We're going to have a detail page, which is going to display a tax with no results, but with a form to vote. So when you click so like, you come in you a bunch of questions, you click on a question, and then boom, it has like ability to vote it up and down. Okay, I assume. And we have a question results page. So it's going to display the result for a particular question. How did that question do? How many votes it got? And then we have vote action. So handles voting for a particular choice in a particular question. Okay, cool. All right. So now, we kind of know that we're going to be creating like these things. Okay. We're going to be creating an index homepage detail and results. And also what they're saying over on this part. Is it saying like, Hey, man, have you ever seen really ugly URLs like this? Well, don't worry, because in Django, you can make them really beautiful. So you can Have them like this instead, like john smith comm slash news archives slash 2018 slash two or slash February, whatever. And you can make them look really nice. How does it work? It works off of URL concepts or your current URL configuration mapping, okay? So you map URL patterns to views. So somebody goes to this URL, it knows which view to run. Alright, so now we're going to write more views. Okay, so we're going to write these guys here. Again, I'm just going to copy it and talk about it for you, I encourage you to type it all out and walk through it. Okay, I'm just going to highlight the main parts, I'm going to go in my poll slash views that p y. So in polls, I'm going to go inside of views are actually we're going to leave the index for now. paste it here. Okay. So now we got detail, we got results, and we got vote. Did everything always takes in a request object? Okay, a request is passed whenever you do anything. I'm not going to touch on too much right now. But this is a first parameter you kind of always put in. And then as your second parameter, we're putting in the specific question ID this way, we can look up that particular question from the database. So let's say you wanted to look up a blog post, right? So you have multiple blog posts, you want to be able to look up a specific one? Well, we're going to use ID for that. And in this case, our ID is our primary key. And that will allow us to look up that unique thing, or in Instagrams case, it allowed us to look up that unique post. Okay, cool. Now, what we want to do is wire these new views into the polls dot URLs module, but adding the following path calls, okay, so that's what it's showing here. I'm going to call, I'm going to copy this and I'm going to paste it into our polls slash URLs up here. Go slash URLs and paste it here. Alright, so what does this mean? If you just go to slash polls, right, so john smith comm slash polls, it's going to run this thing is going to match the empty pattern after polls. And then it's going to run the views dot index function, okay? If you go to polls, slash, if you want to go to something like polls, slash five, or Instagram post slash, whatever your post is, right? If you want to build to do that, you want a pattern that can match that, okay. So if I put in 20, it shouldn't break. If I put in eight, it shouldn't break, it should always be matched. And so how we can do that is we basically do this thing with angle brackets and int, colon, question underscore ID. And this can dynamically match whatever pattern you put in. And another beautiful thing, you guys, usually for URL mapping, you have to deal with ugly regular expressions, except for the latest Django, you don't have to worry about regular expressions anymore. So for example, let's say you wanted to match this particular pattern. Well, you can put this in, and if somebody puts in a five here, right, they'll automatically know that it's an integer and work. If they put in something else, it might freak out. Okay? So it's really smart. And then it says, Hey, if somebody goes to a URL like this automatically takes them to the detail view. And if somebody goes to a URL that ends in a results, like this, then, which is essentially what you're saying here, hey, any number, followed by results. Take them to the results, one, and any number followed by the word vote, take them to the vote, view. Cool. And let's see what happened. So I'm going to run I'm going to do Python, manage that py run server. Cool. And I will open up my Chrome. And we will go to this guy over here. Okay, so now we're getting an error is because we actually have to go to that particular URL. So in this case, let's go to slash polls, and it should run our index function. So I'm going to do slash polls, boom, it ran our index function. What does our index function say? Let's go to our views. And that's what it says, Hello, world, you're at the polls index. Perfect. Well, what if somebody goes to polls slash five or polls slash 193? What happens then? It'll take us to the detail function, and what does the detail function say? It says, you're looking at question number. What the question ID cool. So let's try and let's see what happens. I'm gonna do 193. Okay, so the cool thing here that's happening is that you're able to take what's in the URL and you're able to pass it down to your HTML. So right here that 193 right. If I make it like some other crazy number pass that down here, right? So now we're able to actually take in arguments from our URL and use them in our code. What if I said something like this, it'll say, hey, that pattern actually is not matched. So that's exactly what we want it. If you don't put in a number here, it should automatically detect it. Now, if you want to go to something like slash poll slash number slash results, what do you do? Okay, so let's say I have this number, and I go to results, just like that. And now, it should say something like, you're looking at the results of question, followed by whatever it is. Okay? So you're looking at the results of question, right? Or question two. And then if you go and try to do this thing with vote, you're gonna get the same thing. So if I go to my URLs, it says, hey, go to slash polls slash number slash vote. So we're going to do slash polls slash numbers slash votes. And I hit Enter, and it says, you're voting on question two, perfect. That's exactly what we should be getting here. And it's looking great. All right. So it's saying, hey, like, take a look at this in your browser, and it will display the placeholders? And that's exactly what it did. And how does it work? Well, detail our function that we have, will take in a request object followed by the question ID. So when we pass in the question ID to be 193. Right, this part became 193. And this part is just that request object. So what they have here? Again, if you're confused about objects, and what the hell is going on, it's not completely necessary, but you should look at some object oriented programming stuff. Okay. And I do have a course on object oriented programming, then you could comment on it if you're interested. Alright, so the question ID is equal 34 comes from this thing, and I've explained that to you already, when you put that in the URL, this dynamically actually pulls it out. And once it dynamically pulls that out, because you see it says, here, it says, question ID question ID, that's where it's actually pulling it from. Okay. And that's essentially it. And then it says, Hey, you don't need to do ugly things like latest dot html, because it's not necessary. And it's apparently silly. Okay, so don't do it. And you should write views that actually do something. And here, they're saying, hey, look, each view is responsible for doing one of two things, either as your return what it's supposed to return or give you like a 404. And then the rest is up to you. So, you know, basically, you can have a view, or it can read records from a database. So meaning reading records, reading posts, from a database, Instagram posts, Facebook posts, or it can generate PDF files, or output XML or create a zip file on the fly, anything you want. And pretty much using whatever Python libraries you want, because Django is 100% Python, so you have full Python power. And then all Django wants is that HTTP response, okay. So you can return it as a string, you can return it, you have to return it as some kind of an HTTP response. or throw an exception. Okay, so now, here's what they're doing. They're like, Alright, we're going to do something cool. Well, we're gonna do is we're gonna take like, all of the questions you have, we're going to order it by the publication date, and then show the top five most recent ones. Okay, how are they doing that? Well, I'm going to copy this, and then we're going to play around with it. Okay. So we're going to go back to our thing, and what do they have here from dot models, import questions, and they're in our poll slash views. Okay, so this is one thing that we need to do from dot models, import question, because we don't have that. So we're going to paste it in here. And then they want us to redefine our index. Okay. So we're going to do just that I'm going to change my definition of what my index function is. Alright. So how is this working? Well, question dot question that objects are ordered by. And what this thing does, is it'll take all your questions and order it by something. So in our model, if you look, we have this thing, publication date, so pub underscore date. So we're going to order it by publication date. Now what we're doing with this minus sign is we're saying in the reverse order, okay. So instead of the oldest publication dates and showing us the oldest, we wanted to show it in a descending order. So we wanted to show us the recent ones first, and then what we're doing is that we're just and So this will return to us a list, okay? And then you can index a list in Python by doing this. And we're just saying, Give us the first five. So from zero, up to, but not including five. So 01234, that's five, okay. And then as output, we're saying, hey, join all of them all of the questions by a comma. Okay? So if you want to know a little bit more about, like how the Python is working in there. So here, we're doing a list comprehension. And you can read more about list comprehensions. If you don't know what that is, it's not too important. And it's just a cool way of writing this, you know, instead of multiple lines is writing one line. And we're just saying, for each question, give us its text. That's all we're saying. And then we're saying join it all by commas. So that's how it's going to output it. So it's going to return to us pretty much a string, okay? And then we want to return that. Okay, as our outputs originally HTTP response output. That's it. So now, let's take a look at it. So I'm going to save it and we're going to go to our thing, and we'll try to go to our index, and where's our index? It's just that slash polls. Okay, that should trigger our index. And let's see what happens. So I hit Enter. And it shows me all my questions. If you remember, I created three questions, what's cracking, what's new, what's up, and it's showing us with separated by a comma, I could do show it to us separated by three stars, if I refresh, it separates it by three stars, you could separate it by an image, whatever you want, you know, this is just pure Python. Okay, so that's essentially it. But there's something wrong here. And the thing that's actually wrong here is like, Look, you're not gonna have your toilet and your refrigerator in the same room, right, you're muddying the water, just like that. You don't want to have your HTML code and your Python in the same place, we want to kind of separate it out. So right now, the design of our page is in the same place that handles our logic, okay, so what we want to do is handle our logic by pure Python in one place, and all our HTML. And the design of the page should be outside of this logic, okay. So we want to create something for that. So what we're going to do, and what this tutorial tells us to do, is inside polls, you want to create a new folder, and you want to call this folder templates. This is important the case sensitivity of this is important as well as the name. So if you mess up the name, or you put a typo, you're going to kind of get messed up here. also pay attention to the order of all this, okay? It's under my site. So under polls, you're going to have templates. And then inside of templates, you want to create a new folder, and you want to call it polls. All right. And inside of this is where you're gonna throw all your HTML file. So we're gonna create, we're gonna create a new file in here, and we're gonna call it index dot HTML. Okay, so just in slow motion for you, polls, templates, polls, index. Okay. So essentially, it's like polls, templates, polls, index like that. Alright, let's go back to our tutorial. And that's what it's saying. It's saying that, hey, Django will automatically look for it and find these templates. And essentially, to Django, the path will look like polls slash index HTML, because of how Django works and looks for these. And you can override it and do all kinds of advanced stuff, you know, if you want to read more into that, we're gonna just kind of keep it a little bit basic, so everybody can follow. Alright, and now we're going to put the following code into into that template. So it's telling us which file to put that code. And so I'm just going to hit this button, copy this code. And we're going to go into our index HTML, and I will paste it right over here. Okay, what is this code saying? It's saying, hey, if there are any questions, then I want you to create an unordered list. Okay, that's what a ul tag is in HTML. And then what I want you to say is for a question and so for any questions, I want you to put it as like a bullet point and show that question, okay. And link to that particular question. Otherwise, say that there are no polls available. So if we didn't have any questions at all, Elsa, no polls available, and then end The if statement. Okay, so we're starting our for loop here. We're ending it here. We start our if statement here. And then we have our l statement here. And we have our end if here. Alright, so that's cool. Now we want to make sure that we actually link to this index dot HTML file. How are we going to do that? Here's how. Now let's update our index view in polls slash views that py to use the template. Okay, so we're going to do just that. And also, let's update our index function just a little bit. So here's a few lines that we're adding. Let's go back to our views. And we will see the latest question. We'll keep that and we'll just paste this in here. All right, save. So what's going on? We're still getting those remotes recent five questions. But that's what latest question list is going to become. And if you don't have five questions, they'll pick the top three or top or the recent most for, okay, something like that. And then what we're doing is we're loading that template poll slash index HTML. Okay, so we're using loader, arm. And then there's something called context dictionary in Django. And what you can do is you can pass from the backend server side, pass this to your front ends, your HTML code, it'll know about it. Okay. So if I go back to our templates, my index dot HTML, how is it getting access to this variable, latest question list? Well, we're actually passing it in our context. All right, that's, that's what's going on. And then we're saying, as HTTP response template dot render, we're saying, hey, send that context with that request and send it over to the HTML file. So it sends all that over to the HTML file, and then our HTML file has access to that latest question, okay. And this weird stuff you're seeing here with this with a percent sign, squiggly bracket, that's Django templating. Engine. Okay. So it's basically HTML with a little Django pizzazz. Cool. And so now they're like, Hey, this is such a common step to load a template, and then to do template dot render, that there, they made a shortcut for it, which is just render. So how can you use that? Like this? Okay, so basically, you can remove this line, you don't need this line anymore. And thanks to this line at the top from Django, shortcuts, import render, which you should have, we're going to use this render, and how are we going to do it, we can just replace all of this. And we can say render. The first argument is request, okay. And then after that, the path to that index file, so polls slash index dot HTML, just like that, followed by the context dictionary. So in this case, we're just calling it context. Okay. Sometimes what I like to call this is stuff for front end, alright, just to keep it consistent. And just so you know, the thing that you're accessing on the back end is not this guy. It's a dictionary context, dictionary key. So it's actually this string. All right. And that will give you back this guy. Okay, so know that once you've done all this in views, we no longer need to import loader, blah, blah, blah. Exactly. That's what we did. And now they're going to show us how to raise a 404 error. All right, so what happens if it doesn't exist? So let's tackle the question detail view. The page that displays the question tax for a given poll, here's the view. So in polls slash views that py we're gonna do is we're gonna from Django HTTP import http 404. So since we're already using Django dot HTTP to import HTTP response, we're also going to say http 404. Okay, just like that, we're going to save it. And then we're going to come back. And now it wants us to make changes to our detail view. And it's saying, hey, turn it into this. So let's turn it into that. And I'm going to save it. So try accept blocks, all it does is if there's an error, try except blocks will catch it. Okay. Try accept block, it is pretty much the same thing as if then condition, except that if you're running into some kind of crazy error tracks, that blocks will catch it and still run. For example, if you divided a number by zero in Python, your code will just freaking crash, right? It'll give you this red blob, your Apple crash, whatever. But if you run a try accept block that says, if you get a zero division error, then Just pass, you'll not get that error. I'll just pass it. Okay. So what we're saying is we're saying try to get that particular that one specific question. Okay. So we're saying, we're getting that question ID and we're saying get that object that has that primary care that question ID, or right, that primary key is equal to the question ID. So if I pass in a URL like m AP comm slash polls slash six, right, what is it going to do? Or let's say slash two, what it'll do is pass this two in two here, that this will become two. And the question will get the question object that has an ID of two in this case, it might be one of my question that I think is what's new, right now? What's new question? So then this question will become the What's New question object? And then what we do is that we just return that, okay. And we pass it in our context dictionary, and we pass that question in here. Except if the question does not exist, then we raise HTTP four. And we said question does not exist. Okay. Cool. Let me make sure to delete that. That's not supposed to be there. I just added that to show you guys what's up. Okay. The new concept here, the view raises. Yep. We'll discuss what you could put in that poll slash detail that HTML template a bit later, but if you'd like to quickly get the above example, working a file containing just this. Okay, so we're going to get that thing working. Okay, it's right in here. We're going to create a new file, and we're going to call it detail dot html. And in detail, we're just gonna put question just like that. Okay. So now we got to make it work. And we're going to go and get our question too. Okay. So because that specific question exists, look, it says, What's new? Now, if I change this ID to one is going to get the question that was what's up. If I change it to three, it's going to be the what's cracking. But what happens if I change it to four? Remember, I only created three questions. If I change it to four, it says page not found. And look, the error throws up his question does not exist. Now, if we didn't have that, right, if we actually don't have that, so let's go back to our views. And I'll just remove this. And I'll just say, instead of rays, I'll just say, pass, okay, passes the equivalent of saying ignore to Python. Let's go back and let's refresh. We're going to get this ugly error, which we don't actually know what to do with or what it means. And it is very confusing. But when we have this when we raise this thing, and I refresh, you see it says question does not exist. So it's a lot easier for us to see what the problem is, is because we know it's coming from here, then we can like start debugging and know what's going on. Okay. So that's why that particular thing is important. Alright, let's move on along. Alright, so a shortcut. So instead of having this try accepting or raise, we can actually do a cute shortcut that says get object or 404. And that's a method that's in Python. In Django, it comes with it. So we'll throw that and it's in our shortcuts. So from Django, shortcuts, import, render, and actually import get object or 404. Okay, and just to stay consistent with them, we'll do it in this because starts with the G and starts with R. So alphabetical orders and pep eight. Okay. Alright, so we're gonna go here, we will go to where it says question in detail. And we're going to remove this whole thing, okay, make our life easier. And all we're gonna do is we're gonna say, bam, right? We're gonna say, Hey, get object or 404. So that particular question with the primary key of this, if it doesn't exist, then it'll automatically say it doesn't exist. And then pretty much the last line, we'll keep it what it was. We'll save this. And basically as our context dictionary, we're saying pass a question as a question. Okay. So there are three arguments in here, request, the HTML, passive HTML file as a string, and then a dictionary. So then we can use it on our back end. Again, in our detail, HTML, we can actually use we can see that question. Save. And now let's try to go to it again. So I'll say four. And now look, it says no question. No question matches the given query question, as Unlike no question object, okay, but if I do three, it finds us and takes us to it. So this is what we mean, this is what I mean, when I say Python is really, Django is really awesome and comes with a lot of intelligent defaults. Whereas you don't have to write a lot of a lot of this code, right? It works on that DRI principle, do not repeat yourself. And a lot of these things just come built in out of the box, and it it speeds up your development time, saves you a lot of those new code lines, because every new code line that you write, there's an additional chance for an error. So the amount of code lines that you can reduce, the less errors you will make. Plus your code just looks beautiful and so much more readable, right get object or 404. Instead of try that at all. Except object dot does not exist, right? So it's confusing. Okay, let's go on. Get object or 404. This is some advanced stuff, we're gonna skip that for now. Now it says use the template system. So in our detail dot html, we're gonna go and I'm going to paste that there, save it. And let's see what it's saying. Back to the detail view for our poll application. Here's what it should look like. Okay, so now let's go to the detail. And let's see, first, let's just see what the result is right? And then we'll talk about it, I'll hit enter. What's cracking is showing it to me in a nicer way. Let's do two, it's showing it to me in a nicer way. What happens if I do four? Same thing, no question matches the given query. Okay, so what are they doing here? They take your particular question and they wrap it up in a h1 tag in HTML, anything that's an h1 tag, will make it's called the heading one. And you can go all the way down to heading six, heading six being the smallest heading one being the biggest boulders. So we have an in a heading one. And then right underneath it, we say for choice in question, dot choice underscore set dot all. So for all of the choices, as like at choices as in particular answers, you can have to each question, right, though, those answers are the ones that actually get an upvote. Or there's no downvote, sign up vote, show me all of those answers, except in this case, we don't have any answers or any choices. So that's why it's not showing those. How is it working? The template system uses dot look up syntax. So you'll do question question tax. So we'll go into the question, and then it'll access a question or score text. Another thing to notice if you're more advanced, if the question underscore text attribute did not exist, it would go and try to access it as a list index. Okay, so imagine if it was like if you did question dot zero or something like that. So you're still using dot notation. So that's something that could trip you up later. Okay. It would have tried a list index lookup, okay. And then method calling happens in the for loop. So this for loop method calling is happening there? Because you know, you're doing question that choice underscore set dot all, okay. And then it's interpret as Python code, which is cool, like right here. And it returns an iterable of choice objects. And then we iterate over it, right. So that's why we use a for loop, and then we iterate over it. Now. Remember, when we wrote the link to a question the poll slash index HTML, so let's go to our polls slash index dot HTML, you can see what we did here. Right? So we said, slash so for the links. We said slash polls slash this. Right. So let's go take a look at this page. One more time, we're going to go right here. And I'm just going to hit pause and hit enter. So you can see how it's showing me what's cracking, what's new, what's up to each of this. And when you click into it, you go into the detail view, right? Kind of like when you click into a blog post. And also under What's up, you can actually see the choices. So that's just a recent thing we just added. Right? So how is that working? How are we linking it and how we're linking and we're saying slash polls, slash that question ID, which matches, one of the paths in our URLs are p y. So if I take you to my URLs, it'll match the path of this guy. And that takes you to the detail view. And that's how we can see the detail view. So let's go back, but we're hard wiring the URL paths this way if we have a lot of URL pads, or logic and get messed up or if we change if we go in our URLs that py and I, I don't know, change this path to be something else, right? It has like, it says polls here, again, followed by something else, it could like mess us up. So what we want to do is we want to use it in a dynamic way. So that's what they're showing us here. So they're saying, hey, replace this guy with this guy. So we're gonna do just that. Okay, so we're gonna go back to our index HTML, and we will just do this. Okay. So now what this is saying is, for the URL, use detail, detail as in this, that's where we're getting the name from. And then as the argument passed in the question.id, so this question, since we're looping over it, if you do question dot use a dot notation, it'll get you that particular questions ID. So question ID, that's what you pass in as argument. And so then when you go to your URLs, to this question, ID, that's what it's going to pass. Okay, that's essentially it. And I believe you should also be able to do question underscore, ID equals that, but in this case, we're just going to keep it like this. Okay. So no need for keyword arguments. Okay. And then in in between here. So that's what it's going to link to, it's going to link to the detail view of that particular question. And the text that we're generating is just from right here. So that's question dot question underscore text. If you are confused by this, look up stuff on HTML, okay, and look up how links work in HTML. Again, I'm not going to go into too much HTML, because that's outside the scope of this tutorial. Okay, and that's how it's essentially working now. namespacing url names. It's basically just telling us like, Hey, look. So let's go down over here. Let's just make sure we're not missing anything. Okay, from the top. Okay, they're saying, if you want to change the URL to something else, perhaps it's something like polls slash specific slash 12. So this is something that I've already said, but but they're just reiterating here. And they're saying it like, if you change the URL, it's still going to work now that we change it to be the dynamic way. Okay, so now we can change our URL pattern to whatever. And it's not hardwired anymore. And now they're talking about namespacing URL names. Okay. So this way, you want to make sure that all of your apps actually have, there's no way for like, right now we only have the poles app, right. But what if we wanted to have more apps inside of this, then what can happen is that if any of our HTML files name matched, so let's say you have a polls app, and it has an index dot HTML file, right? What if you had a blog app, and that also had an index dot HTML file, now you're gonna have a collision. So what we do for that, that's, that's the reason why we create under templates, another folder called polls. And if we wanted to add templates for our blogging app, that's why we would have an app called blog. And then under that, we'd have templates and then under that, we'd have blog, and then under that would put our HTML stuff, okay, that's the reason why we do it like that. And this way, there's going to be no collisions. Okay. Now change your poll slash index dot HTML. So let's see what it's saying here. So we can have our app name, app underscore named avatar name is equal to poll. So this is in our URLs. py. So let's go right there. urls.py. And they're saying, hey, add that guy right over here, okay. And pretty much everything else we want to just leave as is. Now change your poll slash index dot HTML template from this to this. So in our index HTML, we're gonna go right here, and we're gonna paste that guy. So notice the difference. All we did is we do polls equals d polls colon detail, okay? That's really the only difference. There's no other difference. I'm gonna save that. And this way, our URLs will never collide. And everything has a proper name spacing, right, because right now we created a detail for our problem. What if you want to create in what if you had an add a new app called blog, and then create details in there. You don't want it to just be called detail because it's going to collide with the polls detail. But now because it's polls colon detailed, then later, you could do blog colon detail, or Instagram, post colon detail or Facebook status, colon detail. And this way, you can differentiate all of those different apps you have within one of your Django projects. Okay. writing your first Django app, Part Four. Alright, so we're continuing a web poll application. And we'll focus on simple processing, simple form processing and cutting down our code. So the big things we're going to be doing is how do you add a form, that where you can submit information to, so basically, it's going to be a form is gonna have radio buttons, you're gonna pick your choice, you're going to click on it, and then you're gonna be able to send that data over, that's number one big thing we're going to be doing. The second big thing we're going to be doing is cutting down our code using something called Django is a generic views that are super, super powerful. And it makes your code a lot more readable, and it stops you from doing the same thing over and over again. Okay, so it makes things a lot simpler for you. It does have a little bit of magic involved. But hey, that's what I'm here for. And I'm gonna break it down. So let's jump right into it. Alright, so writing a simple form, I'm going to copy this guy, and then I'm going to break it down to you, you my friend should not be copying, you're learning this stuff. You should be writing this down line by line and going, huh? How does this work? Ah, that's how it works. Oh, hmm. And then you should be googling it and looking it up. Okay. For me, I know how this works. I don't want to waste my time a copy, paste it and then break it down for you. capiche. Let's get going. Alright, so let's pop open our atom. And we will go into our detail dot html. And we're going to put this over that. Okay. So what is going on at a higher level? We have a for our heading one. So this is where, what the specific question is, okay, so what's up? What's crackhead what's pop and things like that? All right. Here, this line is saying, Hey, man, look, if there are any error messages, I just want you to freaking show them. That's all. And this guy over here is just a form where you actually submit and vote, okay, at a high level, that's all that's happening. Okay, now getting down more into the code level. This is pretty self explanatory is just h1 tags is just HTML, here is a little bit of Django going on. So here we're saying, if there are there is an error message, then show it, okay, and show it covered in strong tags, that looks nice. And then here's where we're creating a form. So we started the form tag here and the form tag here. The action is to go to this specific URL, so trigger this URL. So basically, action means what the heck happens when you submit a form? Right? what's an example of a form? You? Every almost every website has it? Okay, so you going on Instagram and logging in, you are submitting a form you logging in on YouTube, you logging in on Facebook, you are submitting a form, you posting a status hitting post, you are submitting a form, okay. So that's essentially what's going on. So what we can say here for action, once you submit a form, what should happen, okay? One thing you could do here is just type in facebook.com. So once you submit this form, it just takes you to facebook.com. Okay, you can certainly do that. Except in our application, what you want to do is, once somebody submits a form, you want to send them over to some other part of your app with that information with that data. For example, if somebody adds shoes to their cart, it then takes them to the new page with information where they previously added shoes to their cart, and then shows the shoes and the shirt and the tie on. proceed to checkout page. Okay, that's essentially how you use forms in real life. Okay, so here we have it to Hey, take me to the vote. View, okay, or the vote function in our views file. Cool. CSRF token so there's something called cross side. I forget what it fully stands for. Let's take a look at it. They mentioned it cross site request forgery is okay. So it's a security mechanism and All you have to do is really not to worry about it too much. All you have to do is just add that token. Okay, so actually, that's it, that token doesn't even need an end. That's it. This is just a line that you add, usually when you're adding Django forms unless you're using something like crispy forms, which is, again, outside the scope of this tutorial. So that's what this line is here. We're doing a simple for loop. Okay, the for loop goes through all the question choices. And what are question choices? Well, remember each, so you have question, and then one question can have multiple answers to it. Those answers are the things that get voted on. So what we're doing now is listing out all of those answers or, or those choices. And, and, and I'll show you right now, how al actually look Okay, so let's go ahead and check out what this looks like. So now, we're gonna go over to our app. And let's click on what's cracking. And you can see it says what's cracking followed by vote right underneath that. Okay. Let's go to what's up. What's up has two choices. Remember, I had not much and the sky? Those are two possible answers. kind of funny. I don't know which one I like more. But yeah, you could you could vote on one. And then you could certainly hit vote, okay. Yours is not going to look as big as mine. That's because I have it zoomed in. So you could see on my 5k, iMac retina screen, and you can pick whichever one you want. That's it, and then you hit vote, boom. Okay, you're voting on question one, it will redirect you to that. Cool. So that was that the radio buttons are coming from these lines, okay, how's this working input type radio, when you do this, then it creates those radio buttons on the side, okay. I for ID something you don't have to worry about too much. But for ID, we're just using the built in Django templating systems for loop counter. So we'll give the id 1234. As it's looping through. And yeah, values, just a choice that ID and Name, we're just calling a choice. Name is very important. Once you get this on the server side, the back end, you could reference this post data using that particular name, okay, so you're gonna be able to do something like request, I post bracket choice. Okay, and then label for, that's just for labeling purposes. Again, not incredibly important to what we're doing. And then we end the loop right over here. And then right over here, we're saying this form is basically what we're saying is like, put that Submit button, and then just call it vote. Okay, so that's why you see, you know, if I called it something else and saved it and refresh now calls it that. So here we're saying call it vote. And then for type, we're going to say it's a submit button. So the type which is going to give us submit, so once you hit it, it sends that information over to the next page. Cool, let's go back to our tutorial. Alright, so that's pretty much what is gonna explain to us, but let's just see and make sure we're not missing anything. Right, so the value of each radio button is associated, is associated question choices ID, the name of each radio button is choice. Yep. That means when somebody selects one of the radio buttons and submit the form, it'll send a post data choice, where a number is the ID of the selected choice does the basic component of HTML forms, okay? We said the forms action to that particular URL, and we said method is equal to post. So here's another important thing to note, this is pretty important. Whenever you're generally submitting data, or filling out a form and sending it over, you want to use post request. Because it's safer, and it's better. You don't want to be using GET requests when you're sending data over because it's insecure, and you can get screwed. Okay, so simply put, as opposed to get it's very important, because the act of submitting this form will alter data server side, whenever you create a form that alters or data service side, use method post. This tip isn't specific. Django is just good web development practice. For loop counter indicates how many times a four tag has gone through its loops. Okay, I've explained this already. Since we're creating a post form, we need to worry about cross site request forgeries and I've already gone over this as well. Okay. And that's why we're using CSRF token. All right, now, let's go Create a Django view that handles the submitted data and does something with it. Remember, in tutorial three, we create a URL con for the that includes this line. So we already have this line, we don't have to add it. So if I go to my URLs dot p y, you'll see four votes, I have this line right over here, and so should you. Alright, now let's add the knowledge, we're gonna create a real version for our vote. So up until now, we had functionality for our vote, but it was just dummy placeholder didn't really do anything. Okay, so now we're gonna actually add real functionality, what are the few things we need that we don't have? Let's see, we'll need HTTP response redirect, because we don't have that. So we're gonna put that in. All right, we're gonna save. What else do we need? We need from Django dot URLs, import reverse. So we're going to add that in and hit save. And then that's essentially, essentially and then it except we're gonna have choice right here, save cool. Okay, now we're gonna go in our vote, and we need to add all of this code. Okay, and I'll break it down for you right about now. Okay, so what's going on here? Question? We get that particular question, or we throw 404 error, we then get the answers for that particular question. Okay, or selected choice. one specific choice, that's what we get. Okay? So for example, whether the choice is going to be the sky or whether the choice is going to be something else, right? It's not going to show it to me right now. Cuz the app is offline right now the server's close. But since we had two choices, and you couldn't vote for this choice, or this choice, how are you going to know which one is sent? Right? So that's what we're trying to pick here. Whichever choice you select the radio button next to that's whose primary key we're going to be passing in. And how we get that as request our post choice request, our post is just a dictionary, and you could index you could get pull out the key choice from that. Okay. Just to have it make sense. Let's see, let's run this code. So what is it saying? The problem is right here. Alright, we're gonna run this code. Cannot import name reverse http 404. Let's see where that error is coming from. Hmm. Right there, reverse, okay. And you could still have http 404. Not a problem. All right. So let's go back to our app. Let's go to what's up. And also, let's go back to this, save it, come back, let's refresh. This should save votes here. Now, when I hit the sky, we're gonna see what happens. So I'm going to hit inspect here. And our console pops up, right? We're going to go to sources. console is looking pretty insane right now, but that's fine. I'm going to click on network. And we're gonna click vote. So we're just voted for the sky. Okay, now in our network. Let's see if we can zoom out a little bit because it's a little too crazy. Alright, so in our network, we can see that the request method is post, right. And we can actually check out the response. And in this case, it says the response failed. Let's click here, right now, when I click results, because it was sent to results, it says you're looking at the results of question one, right? So there is a response. And now if I look in the headers, it tells me the request method right now is get, and it tells me kind of all the things that go along with it. Right. So let's try it out again. Let's pick another question. Not much. And vote. Let's see what happens. So 302 found, right. Okay, so let's go here, preview response, failed to load response data. If I go and results, it's showing me are looking at the results of question number one, okay, so pretty much it says the same thing and it's giving my statuses What do these mean? We're gonna break it down a little bit later. Okay. So let's go back to our tutorial and go down. index HTML. Okay, so this is looking good, our views. It's looking fine. Cool. Now So yeah, so basically we're selecting the specific choice from here, whatever we get, we send over in our request. And then we throw an accept choice that we throw an exception here, okay? And we also check for if like the choice does not exist, or if there's an here. And in the case that the choice does not exist, we return polls slash detail dot html, we render that and we return that question object. And for error message, we say that you didn't select a choice, okay? So if you somehow selected, you know, nothing. And otherwise, if we have selected it, and we haven't ran into this issue, we want to say is for that particular choice, we want to upload it by one. So we're in incrementing, the vote count by one, we want to save it. And then we redirect. Okay. So we're going to go into more depth of that. But let's just check this part out one more time. Refresh. Let's hit inspect. Let's go to network. Let's select this guy, let's click vote. So you can see, okay, so that's that's exactly what I needed here. So a little hard to see though. So you can see when I scroll all the way down, that it actually pulls out the form data. And it's telling me that the choice I selected was the second choice, right? That's an important part. And it's also has a CSRF middleware token, which, remember we did CSRF underscore token, that's where it's generating now from, but the choice is the most important one. So whether it was choice one or choice two, and we're picking this based on the choice ID, okay. So that's essentially what's happening. Now, if I go back, and I pick Not much, and I vote, and when I go back up to vote, and I go all the way down, you'll see that it's showing me choice one, right. So that's the thing that we're actually pulling out. So this will essentially turn to a one or a two. That's what I was trying to get at earlier, but it was just my screws too big. So it was hard for me to show it. But that's what gets selected here. And once this evaluates to something like a one or something like a two, this whole thing evaluates to that specific question object. And then we up voted, and then we save it, and then we redirect. Okay? The reason why you so when you're done with all of this, you don't want to say, hey, go back to the home page, or you don't want to just say like render the home page. Because if the user refreshes, it will keep submitting that data over and over again. So like, imagine, right, if you were about to pay for your credit card, and you buy like, whatever, right? You buy shoes, or you buy grocery. If you refresh, like something happens during half of it, then it gets submitted. But then you go back and you refresh, or you resubmit. It shouldn't let you resubmit and pay again, right? Every time you refresh, and then all of a sudden, you're charged like $300? Or what if you were on an online trading app, and you just put down like $3,000 for Bitcoin. And then you refresh, or you go back and forward a page and it reads a mess. 3000 $3,000. Again, you're going to run out of money pretty fast, right? $9,000 like that. So it's a pretty serious issue. So what you want to do instead is redirect This prevents data from being posted twice if a user hits the Back button, okay. There's a better way to do redirect, which I think they'll show us later. But it's essentially I think, from shortcuts, you can pull out redirect and just call redirect, and it's much simpler. But they do it this way. Should you be response, redirect, reverse and then take me to the results view, right. So it takes you back to this results view. And for argument it just passes in the question ID cool. So that's looking good. Now let's play around with it and let's just check out what happened so I've already voted for like one or two questions multiple times. Let's see what's going on on our database. I'm going to go in Python manage that py shell so we're gonna do is from polls dot models. I'm an import choice. And I'm also going to do from polls dot models, import question. Question dot objects, dot get Let's say we want to get our first question or what's up question. And we're going to save this question as like q or something. And now what I'll do is I'll do Q, that choice underscore set that all. Now show me all the choices or answers for it. And then I'll pull out the, the sky one. And then for the sky one, we can see it's vote count. In models, I forget what is voters votes. So you can see that it has two votes. And then the other 1/3 one, it also has two votes. So it's a tie. Okay, so both have two votes. So you see that what we're doing on our front end, and we're voting, it's actually being counted here, okay. Usually where it says choice underscore set, that's kind of weird. So how you want to say it is like cute choices. And, again, like I've mentioned in our for, at the end of our first video, like if you want to change that, I'm not going to change it now just to stay consistent with Django, official docs. But essentially, like right in here, right, right in the top, we can actually write something called related underscore name, and then fix this issue, like right there. call it something like related underscore name, and give it choice says, okay, something like that. But we're not going to do it right. Now, we're going to stick to a Django because otherwise, I'll have to make migrations and things like that. Everything is fine. For now. I'm going to exit out of this. And I will just do Python, manage that py run server, and just go back to using our regular app. Cool. All right. So now let's see what they want us to do. So that's all good. That's working. Alright, let's see what they're saying here. requests are post is a dictionary like object lets you access submitted data by key name. Yep. So that's how we, we use the choice key name. requests that post values are always strings. Cool. Note that Django also provides request I get that's by default, that's there. But we're explicitly using requests our posts and our code to ensure the data is only altered via post call. It will raise a cure if choice wasn't provided in post data, the above code checks for key error right over here. And redisplay is the question form with an error message if choice isn't given. After incrementing, the choice count the code returns an HTTP response redirect rather than a normal redirect. This redirect takes a single argument the URL to which the user will be redirected to the following point for how we construct the URL in this case. And you should always return an HTTP response redirect after successfully dealing with post Okay, we're using reverse function constructor, this function helps avoid having to hard code a URL in the view function. It is given the name of the view that we want to pass control to and the variable portion of the URL pattern that points to that view. Cool. So right here. Now after somebody votes in a question, the vote view redirects to the results page for the question. Let's write that view. So now, it should point us back to the results, and we're going to write it okay. So here is what it should be looking like, let's check our results. Pop that bad boy, whoops, pop that boy right in here. And we just say get that particular question. or otherwise, throw four or four. And once you get it, take me to. And once you get that question, take me to results dot html. So you can already see there's some similarities, right? Like here, there's a similarity and here's there's a similarity. Both of these have to do with getting that one particular question. So think of it like you're getting the result detail view for both of them. But in one, you're sending me to detail that HTML and the other one you're selling, sending me two results, that HTML, okay. And we're gonna kind of address this issue of like our code being a little bit repeated. This is almost exactly the same as a detail View from tutorial three. The only difference is the template name. We'll fix this redundancy later. So they mentioned that. Now let's create a poll slash read zoals dot html. So we're going to go in and create a new file, I'm going to call it results dot html just like that. I'll paste it here. And we'll go to our app. And we'll vote for the sky. And then it'll take us to the results of what's up and look at that now much says two votes and the sky. three votes, vote again. And then it takes me back to the vote. And I'll vote for not much. All right, so it's coming out pretty cool. So far. All right, is this is exciting, guys. This is exciting. So now, what is this code saying, Let's read our code who just added header unordered list unordered list, the loop is saying go through all of the choices, or all of the answers. I don't know why they call it choice, I just think is a bad name. And get that choices choice text, put two dashes in between it. So for example, this would turn this whole thing would turn into like the sky or not much, followed by the number of votes, followed by it saying vote, choice out votes, pluralized. Right. So what this is doing is it's either gonna put an S here or not. So for example, let's go here. So if you only had one vote, it wouldn't this would turn into nothing. And if you had multiple votes, it would turn into it would put an S here. Okay, so it's a pretty cool way of pluralizing something. But you're doing choice dot votes. So this will evaluate to like, let's say three, and then you're piping it over to pluraleyes. And then pluraleyes, will be like, hey, yes, you should pluraleyes and put an S here. And then I'll put like an S like that. Okay. Cool. With that said, That ends a for loop. So you're doing not too much here. And then what you say is like, Hey, you want to vote again? And how you how you're doing that is you're just providing a link to the tax vote again. And it'll essentially take you to the detail view of that particular question. Okay. So if I hit vote again, it takes me to the detail view of that question, what's up, not much vote, it takes me to the results view. If I hit vote again, it takes me to detail view, click here takes me to the results view. So this app is starting to have some functionality again. So again, that's pretty cool. Let's go here. Let's check out now go to polls slash one in your browser and vote in the question we did. It gets updated each time you vote if you submit the form without having chosen a choice, you should see the error message. Okay, so let's see if we can try to do that. Let's hit vote. And it says you didn't select a choice. Perfect. That's exactly what we want it. Note, the code for our vote view does have a small problem, it first gets the selected choice object from the database, then computes the new value of votes, and then it saves it back to the database. If two users of your website try to vote at exactly the same time, this might go wrong, the same value, let's say 42, will be retrieved for votes. Then for both users, the new value of 43 is computed and saved. But 44 would be the next expected value. This is called a race condition. If you're interested, you can read avoiding race conditions using F to learn how you can solve this issue. Okay, that's a little bit advanced, it would have to be literally at the same like fraction of a second. could it happen? Yes. If you're trying to scale your app to a lot of users? Yes. Should you worry about it right now? Hell no. So let's continue. Alright, so remember what I mentioned in our views, some of the code is looking similar like here, these are detailed views, right? They're showing the specific question. And they need one specific question. Looks a little redundant, right? And then we're using also specific question like allowing us to vote here, but these, there's a little bit of redundancy going on. So how can we address this? How can we manage this in a better way? Well, luckily for you, Django has something called generic views. These are class based views that essentially have you once you use them. You don't even have to write down much real code. It just does a lot of the things automatically in Pretty intelligent way. So I like this and check it out. Alright, the detail and results views are very simple as mentioned above, but they're redundant, okay? The index view, which displays a list of poles is similar. These views represent a common case of basic web development, getting data from the database according to a parameter passed in the URL, loading a template and returning the rendered template. So we pass stuff, and we get it from the URL, and then we load up a template and we return the render template. That's essentially what we have been doing. And when I say return the render template, another way to say it is returning that HTML file you're looking for right or that page on the front end that you see. Because this is so common, Django provides a shortcut called generic views system. Generic views, abstract common patterns to the point where he doesn't even need to write Python code to write an app, you could literally be sleeping, and the app just writes itself. Let's convert our poll app to use the generic view system. So we can delete a bunch of our own code, we'll just have to take a few steps to make the conversion. We will one, convert the URL cons, delete some of the old unneeded views and introduce new views based on generics. Generic Django views. Alright, read on for details. Okay, so why the code shuffle? What they're basically saying is, hey, you should know basic math before you start using a calculator. So why did we do this up until this point, only to now refactor our code? Will we have to refactor our code all the time? No, you will not. Next time, when you're doing your app, you already know how the class based views work, you'll start from more generic class based views. So basically, what they're saying is like, hey, look, we don't want to just give you the calculator before you can do basic two plus two, or in my case, in one of my videos, I think I had to do 2000 divided by 10. On a calculator. That was a pretty sad moment. And that has a lot of upvotes makes me sad to this day. I wish my editor took it out. Oh, well, you don't always get what you want in life, but Django generic views comes pretty close. So let's keep going. Alright, amend URL con, First, open the polls slash URLs, r p, why you're on Khan, then change it like so. So we're going to go and pull slash urls.pi. And I'm just going to paste it over this bad boy and explain what the heck we just changed, right? So besides the fact that we took out some notes, what else just changed? So let me let me take this out. So you can kind of see it side by side and really see what changed. So if you look at this index thing, all the change before it was just dot index, now it's index view.as. View, detail view as view results. view.as view? And those are the middle arguments that changed, right? What are the other arguments that changed? Everything after the name, all the name, keyword arguments remained the same. But there was something else that changed. So here it says question underscore ID everywhere. But in the new one, it says PK everywhere if you notice, right, so that's another big change to keep in the back of your forehead. Alright. That's what they mentioned over here. Cool. So that's essentially what we're going to be focusing on here. So here, we still have question ID, okay. Now, when we're using these generic views, they take things in as PK, and they'll explain that later. And now we need to make changes to our views. We're going to remove our old index detail and results views and use Django as generic views instead, to do so open and change it like so. So we definitely need this generic thing. So we're gonna do, we're gonna go to our views. And here we're going to do from Django dot views import generic. Alright, so we got that. Other things that we need. Now we need to make a class here. So I'm gonna completely remove this guy and add a little class here. How will this work, it will automatically know which template to use based on this variable. These variables are not just random, you can just call it this, it will not work. These variables have to have this specific name for them to work. Okay, this is something important for you to remember. Django does have a bit of magic but once you learn how it works, It'll be really, really helpful. Okay. So template underscore name, you have to use this variable, we assign it to the index HTML. For a context object name, we say latest question list. And for a query set, we're just returning the last five published published options. Okay? So this we're saying, only be referenced if somebody says this. So when somebody says this, you can get me that, okay. Let's go in our class detail view. So for our detail, all we need to write is instead of doing this get object 404, passing the question, passing the primary key and all that stuff, and saying render requests, followed by the context dictionary and all that. It's pretty simple. How is it working? Well, it's actually pretty cool. Um, okay, so let's go back to our URLs. And since we're passing PK right in here, it already has it, you don't even have to pass it as an argument or anything. Which model? Again, these variable names matter. We're telling it use the question model, so it's directly communicating with this model right over here. template name, we just give it the template name. And that's it. It knows what to do. Okay. pretty beautiful. Now, let's do the same thing for results view. So it's going to change from this obfuscated looking code to something pretty simple, check it out. Clean, right? Looks a lot cleaner, no need for request and question ID no need for a get object or 404. No need for passing in question or primary key, no need for saying render request. And passing in a context dictionary, it just does it all automatically. And then vote, we're gonna keep it the same. Okay, we're gonna hit Save. Now we're using two generic views here list view and detail view, respectively. Those two views abstract the concept of display a list of objects. That's one concept. So list view is going to do that. And then the other concept is display a detail page for a particular type of object? So are you looking at the home page of Instagram? Or are you clicking into one particular post, I'm looking at its detail. A generic view needs to know what model it will be acting upon. This is providing using the model attribute, which is this. The detail view generic view expects a primary key value captured from the URL to be called pk. That's why here it has to be called pk. So we have changed question underscore ID to PK for the generic views, but not for the non generic view. By default, the detail generic view uses a template called app name slash model name underscore detail dot html. In our case, it would use the template the following template, right. So if I go in my views, Paul, so app name, our app name is polls, slash results dot html, so slash slash the model name dot html, okay. In our case, we just called it results at HTML. The template name attribute is used to tell Django to use a specific template name instead of the auto generated default template name. We also specify the template name for the results list view. This makes sure that the results view in the detail view have a different appearance when rendered even though they're both a detail view behind the scenes. So they're both a generic detail view. Okay. Similarly, the list view generic view uses a default template called similar to the other one, we use template name to tell ListView to use our existing one. So by using template name, right over here, we're telling it which one to use specifically. In previous parts of the tutorial, the templates have been provided with a context that contains the question and latest question list context variables. For detail view, the question variable is provided automatically. So the question variable is provided automatically instead of us even having to pass it in as a context dictionary because generic views are smart. Since we're using a Django model, our models called question Django is able to determine and improve Britain name for the context variable. That's why it would pull out question. This would be the variable name that you can use automatically on your front end in your templates. However, for ListView, to automatically generated context variables, question underscore list. So if it's a list of things, right, like the list of choices, or those answers, it would call them question underscore list. to override this, we provide the context underscore object underscore name attribute, so we override it. And we give it our own name. If we didn't give it our own name, we'd have to access it using question or score list. But by giving it our own name, now we can access it on our template side as latest question list. Okay, specifying that we want to use latest question list instead, as an alternative approach, you could change your templates to match the new default context variables, but it's a lot easier to just tell Django to use the variable that you want, run the server and your new polling app based on generic views. So let's actually give it a try. My server is indeed running, I'm going to refresh, I'll take a vote. And it voted correctly. I'll vote for the sky. And it looks like it votes correctly. I will go to the polls like homepage, just polls. And it shows me all the detail views for all of them. Right, what's new? And when I go on, what's up, not only does it show me the detail view, but it also shows me the choices that go along with it. So working fan in a fantastic way. Right, your first Django app, Part Five? So what are we doing in this tutorial, we are going to be doing a lot of automated testing. Okay, so what the hell is automated testing? Well, here, let me break it down in a simple, easy to understand way. For you mere mortals out there. Let's say you have something like Amazon, right? Something giant with millions of lines of code? Are you really going to like every time you add a new feature, are you going to test all of the older features to make sure that they're working correctly? Probably not, it's going to take up a lot of your time plus, you're going to kill yourself. So what you're going to do is actually write these automated tests. So every time you add a new feature to Amazon, let's say that you add this new cool feature that recommends new shoes, you want to make sure that the ability, when user clicks add to cart, that still works when a user clicks Checkout, that still works. So what you would normally do is go and manually test it except because Amazon is so big, you're not going to be doing that. So you're gonna write automated test, I'll test all of those things every time you add a new feature. So when you add a new feature, it automatically tests everything that was before it. That's the point of testing. Okay, that's kind of the beautiful thing about it. Okay, so why you need to create tests, tests will save you time. Yep, they will save you a lot of time. Because let's say you were to run into a bug or something unexpected behavior, you will know exactly why it's happening. Or you'll catch on to it a lot faster. If you have code that tests those things. as you go along. rather than waiting till everything breaks, the whole world comes falling down. And then you're like, wait, what went wrong? Yeah, good luck finding the bug in your millions of lines of code, right? You want to quality test, each thing as it comes in. Tests don't just identify problems, they prevent them. Okay, so this helps you identify any problematic new bugs that could be coming in. And not only like, identify them, but prevent them before it even happens. almost think of testing kinda like if you just hired people without interviewing them. I mean, you would have no, right, you would hire people like this guy. And you would have people who you would have no control over, don't know. And like, let's say something was going wrong in your company, you're not going to know who to blame, because you never really tested any person, right. But if you run through an interview or a test with them, then oftentimes you don't even have to hire them. And you can kind of prevent it. Before that problems spreads. Or if they're awesome, then you can add them in right to your company. Tests also make your code more attractive. So basically, like, your code will look nice if you have tests otherwise, developers won't take you seriously and test how teams work together. So if your team is working, and some complex applications will be maintained by teams right and test guaranteed that call leagues don't inadvertently break your code, and that you don't break theirs without knowing. So this way, it also helps you when you get employed and you have a job. You know, a lot We'll help you identify like where the problem is coming from and the people who are working with you on your team, they know exactly what you're thinking. And won't cause problems in your code either. So those are the benefits of testing. Now you have some basic testing strategies, something called a test driven development, it's a pretty common thing. It's called TD d, t, d. d, okay? And basically, it's like testing as you go, rather than wait till I write my millions of lines of code and then freaking test it right? Wait till I have 30 employees, and then I'll ask them and interview them and find out like, don't do that test as you go. Okay. Now, all we're gonna do is we're gonna write our first test. So, oh, we identify our bug who look at that. Well, they purposely planted a bug in our code. And now we're going to use testing to solve it. Okay, we're gonna go Sherlock Holmes. Alright, so fortunately, there's a little bug in the polls application for us to fix right away. The question was published recently. So you guys remember that a little method we had was published recently in our models for question. Well, it had a little bug. And basically how it works is the method returns true if the question was published within the last day, which is correct. So if it was within the last 24 hours, it shows you true, but it also shows you true if it was published in the future. Okay. So it shouldn't say that it's recent, if it was going to happen in the future, right? You wouldn't say, Oh, I recently got a car, if you're going to get a car 20 years from now, when you finally get a job, right? So I'm just kidding, you probably already have a job I don't. Let's continue to check if the bug really exists using the admin create a question whose date lies in the future and check the method, check and check the method using the shell. So first, we're going to check what's going on using the shell. Alright, so let's go back to our code. Alright, so the first thing we're going to do is run our Python. So we're gonna run that from we're gonna do Python managed up py shell, don't just do Python and hit enter, like an idiot like I kind of did. So once you run the Python with this particular shell, then what happens is you can like import your, you know, models and everything. Okay, so now import date time, we're going to do from Django dot utils, import timezone. And then we're going to do from polls dot models import question on. With that said, Now we're going to create a question instance with the publication date, 30 days in the future. Okay, so how does this work? We're going to create a variable called a future question. And we're gonna create it from the question class. And we will say the pub date is equal to timezone dot now, so we're saying that it's published right now. And then, but to that timezone, now, we're going to add some time to it. Okay, so we're going to do date, time, dot time, delta, and we will do days is equal to 30. Just like that. Okay, and then we're going to hit enter. So I say i'm saying is like, right now plus 30 days, which in other words, translates 30 days from now. Right. So basically, right now, where I am at and what my current day for me is February 20. Okay. 2018. So it's gonna do February 20 plus 30, days after February 20. Okay, so no, it's not gonna be February 15. It's gonna be March something, right? Cool. Was it published recently? Now we're going to ask it, and it should say no, it's not published recently, right? It should return false, except that it returns true. So there you have it, we know that something with our code is broken, right? So since things in the future or not recent, this is clearly wrong. Now we're going to create a test to expose the bug. So right now we expose the bug through the command line, right? We just use the interactive terminal shell. But like, you don't want to be doing that every single time. You also don't want to be doing that manually, every single time. So we're gonna write a test for it, they'll automatically test it for us. Okay, cool. So now we're going to go into our test file and write this code and then I'll kind of break it down. So in our under our polls app, we're going to go into our tests and we will paste this guy here. Okay, I copied over everything and I pasted it over it. So what's going on? we're importing date time, just like we did in the shell. we're importing timezone nor importing test case. And we're importing the question model from our models. And how is this working? The class is we're calling a question model tests. So the good idea is like, every time you want to test, a model, make a class for that test. Ok. So this way, it's nice and organized. This class inherits from test case that's coming from here, you kind of put that in without really thinking about it. Okay, just like, look at the Django Doc's is saying, and just like follow it all along, it's not necessary for you to like, learn about this test case class and how it's being inherited and like, get a PhD in it, you can, but it's not necessary. And then, for a year, the name of the function that you're testing, you want to a good practice, you want to like break each thing you're testing have a function for that particularly, right. So for example, if I go into my models, I have a method called was published recently. So since we want to test that specific method, under that class, look, I'm doing test was published recently, right? And name, the test make it pretty specific. So somebody who's reading your test method, or your test function should kind of know what it's supposed to do just from reading the name. So we're testing was published recently, but with future question, so what if the question was like, published 30 days in advance? Right? Here's the documentation for it was published recently returns false for questions whose publication date is in the future? Cool. That's what it's supposed to do. Except it doesn't do that. So now we're checking this, okay. We're saying, hey, set the time to 30 days from now, that's what this is doing. And then we make the future question just from question class. And then we set the publication date to that particular time from here, line 16. And then on line 18. We're just saying, hey, assert, if this is this, however, this turns to true, as we saw earlier, right, like right here. So this is gonna this whole thing, what if you run it right now is going to turn to true. And that's really the problem that we're having, right? And we need to fix that in our tests. We'll expose it, how do we run our tests, we're just going to go to our command line. And we're going to do Python managed up pi test polls. So I'm going to exit out of this exit. And now I will simply do python manage.pi. Test polls. So what I'm saying is like test the polls app, and then it'll automatically basically run the test.py file inside of the polls, after you created, run it. And look, it says failed failures is equal to one. And basically, it says assertion error, it tried this line solve that assert is and what it found out was this was not this. And so it's an assertion error, and it says true is not false. Now, if this whole thing evaluated to false, which is it's supposed to, then it would go false as false. And then this thing would return true, and it will throw any errors, okay. Now, as you have more and more tests in here, all you'll have to do is just run that once, or you can set up a web server, it runs that once automatically. And that way, it'll only alert you if something's broken. Otherwise, it'll just go silently. That's the beauty of tests. By the way, have you guys ever heard the song Fly Me To The Moon, but I've been in love with it, and I can't stop thinking about it's like playing in my head, non stop. Anyways, let's continue. So what happened is this, Python managed up pi test pulls, looked for tests in the polls application. And explain that to already. It found a subclass of the Django test, a test case, subclass. It created a special database for the purpose of testing. If I go here, look, it says destroying test database. So it created its own database from what was happening right now. It looks for test methods, ones whose ones whose names begin with test. Okay, so it's looking for everything that starts with test. If you don't have these, starting with tests, it will find it okay. So like, let's just say it was like this, and I'll hit save, and then we'll also run this test polls. And it didn't even find it. It said ran zero test and zero seconds. But as soon as I do that, and if I run it, boom, ran. It created a in tests was published recently with feature requests, it created a question instance, whose publication field is 30 days in the future, right over here. And using the cert is method discovered. It was published recently returns true though we want to return false what we found out here, cool. The test informs us which test failed and even the line on which the failure occurred. So here, it'll tell us which line we failed on line 18. Right? This is line 18. Cool. So now we're gonna go ahead and fix this bug. How are we going to fix it? Well, this is the code that's gonna help us fix it, we already know what the problem is. amend the method and models up UI. So it will return true if the date is also in the past. So we're gonna go into models. And we will change this to this indentation and whitespace in Python is important. So make sure it's indented correctly underneath this was published recently method. And basically, we're saying, hey, set the timezone to now like exactly right now and then subtract one day from now, if that's less than or equal to the publish, and check if that's less than or equal to the self published date. Okay, so if that's less than or equal to the published date, and then check if self published date is less than or equal to now. Okay, so in other words, check that this publication date is in between this. And this. Does that make sense? It has to be sandwiched between the two. And run the test again. So now I'm going to hit save. And I will simply run the test again. And now look, it says ran one test. And it gave me an okay, and it's saying destroying the database. So cool. It looks like it had no errors. It ran all the tests successfully. If it showed me something red or said failures, I know something failed. So now it's working. Cool. Now we can also do After identifying a bug, we wrote a test that exposes it and corrected the bug in the code. So our test passes. Many other things might go wrong with our application in the future, but we can be sure that we want inadvertently reintroduced this bug. So it will automatically keep checking it and we will we're not going to be reintroducing this bug, because we'll always find it because simply running the tests will warn us immediately, we can consider this little portion of the application pin down safely, forever. Pretty cool. I think that's pretty freakin cool. And now they're like, Alright, we're gonna get into some more comprehensive tests. While we're here, we can further pin down the was published recently method. In fact, it would be positively embarrassing if in fixing one bug, we had introduced another. Cool, add two more test methods to the same class to test the behavior of the method more comprehensively. So now we're going to test was we're going to test the was published recently method with old question. And then we're also going to test it with recent question. And we already have the future question. So you can only have three cases, future question, recent question or old question. If a question is older than one day, it should basically say that it's not. If the question is older than one day, it will should return false, it should say it's not recent. If it's in the future, it should say it's not recent. If it's been posted less than one day, then it should say it's recent. So for example, if we just look at this test code at a high level, old question, look, it's ask it's making sure that it's asserting to be false. So if it's one day and one second ago, right, so if it's one, if it's exactly one day ago, then what it should do is it should say yes, it's still true. But if it's one day and one second ago, now, I should say it's too late and it should be considered false. Okay, it should be considered not recent, and then publish recently with recent or with recent question. So the question is, as you can see here, not even one day ago, 23 hours, 59 minutes and 59 seconds ago, almost one day, it should assert it to be true. Okay. But take these and we will go into our Our tests, and we will add this into our tests. Okay? There we go 12341234 and 1234123412341234. Okay, so just make sure that it's all indented correctly, and then that you should be good there. So now we have all of those scenarios covered future old or recent question. Let's run our test. And let's see if we have any bugs. No bugs, it looks like our method is working perfectly. Okay. Just so you understand this code right here, it will only return true when the publication date is in between this and that. Okay, so this is basically saying it's within one day. And this is saying it's less than now. Okay, so if this is in between Illa match. And now we have three tests that confirmed the question was published recently returned sensible values for past recent future questions? Good. Again, polls is a simple application, but however complex it grows in the future, and whatever other code interacts with, we now have some guarantee that the method we have written tests for will behave in expected ways. Test the view so you can also test views. The polls application is fairly undiscriminating, it will publish any question including ones whose publication date feel lies in the future, we should improve this setting a publication date in the future should mean that the question is published at that moment, but invisible until then. Alright, so what are we doing here? Well, when we post our question, if it's some data in the future, it shouldn't show it just like for example, on WordPress, if you publish a blog post for let's say, you know, two days later, it doesn't show until two days later, right, you can schedule your post or on YouTube, sometimes I schedule my videos. And you know, I'll say real show this video to the audience in one week from now, right. So if I do show it from one week from now, it shouldn't be showing it. At that same time, that would be crazy. That wouldn't make sense. Just like that. We also want to do with our questions and make sure that it doesn't just show out of nowhere. And we want to make a test for a view. When we fix a bug above, we wrote the test first and then the code to fix it. In fact, that was a simple example of test driven development. But it doesn't really matter in which order we do the work. In our first test, we focus closely on the internal behavior of the code for this test, we want to check its behavior as it would be experienced by a user through a web browser. Okay. So the first one, it was like the logic of the code. This one we're focusing on what happens if the user is like, testing it, and the user is actually on the front end of the website? What does it show to them. And isn't that cool, so you can automatically test that every time your code runs, and you don't have to like go and check if your cart is working, or your blog is showing things like that. Alright, so the Django test client, so here's the command, we're going to go in our command line and type in so I'm going to copy this guy again. And remember, we got to do Python, manage that py shell, then paste this guy, and then we will get set up test environment just like that. Okay. installed the template render, which will allow us to blah, blah, blah, blah, blah, okay. We will get this guy and then we will also this say something about timezone, so make sure your timezone is correct. Mine is in America slash Los Angeles, if I go in my settings and show you for you, it might be something different. So you can go in this, go to this link and look up what your timezone is okay. So we're going to import the client and then we're going to create an instance of the client. So here we're creating an instance. And now we can get a response from our home page now. When the response from your home page should give you something like not found or a 404 it's because if you go to your home page, there's nothing there right if you just go to right now your localhost 127 dot o dot o dot one colon eight And it should give you an error. The only routes that are mapped is like if you go to slash admin or if you go to slash polls, remember that. So that's why the home is giving us a 404. Right now, we should expect a 404. From that address. Let's just do response dot status code. And here it is 404. We should expect to find something at polls though. Okay, so let's try that we'll use reverse, rather than a hard coded URL. So instead of doing like, you know, whatever slash polls, we're gonna just do a reverse here. Okay, so from Django, we're gonna import, reverse. And we'll paste this guy right here. And now, if we do response, that status code, it shows me something, if I do response, it's saying, template response status code is 200. And it's a text slash HTML file, which it is. Okay, and now we can also get the content, we can do response content. So now showing me the content of that file. And if you remember, we do have a unordered list in the start. And then we have bullet points. So here you have what's cracking. in HTML to show an apostrophe, they have to do this ampersand number sign, 39, semi colon, that's basically apostrophe. And we also have another question what's new, and you can see their links here as well. Okay. So this is like just showing the code version of what the user or we actually see on the front end. And we can also do a response context and get the latest question list. And look at give us the questions, what's cracking, what's new, what's up? Now we can improve our view as well, the list of Polish, the the list of poll shows polls that aren't published yet. Those that have publication date in the future, let's fix that. So right, that's a problem. So we need to fix that. We introduced a class based view based on list view. So we're gonna go ahead and fix things in there. Now we need to amend it. So let's go to our views and our index view, we need to fix this. And changes that also checks the date by comparing it with the timezone. Now, first, we need to add an import. So at the top of our code, we're going to add this here, import timezone. And then our query set. We're going to change it a bit. So where is our query set? All right, can we put this on one line? So it looks slightly less confusing? Yeah, we're fine. We're not following Pep eight. We're running across a little bit. But according to my boy, Raymond, the Oji, heading anger, or head injure. You know, according to him, he says 90 to 95 characters should be good enough. Pepe, I think with the whole 80 character line, that's kind of stupid. Because, honestly, breaking this down into new lines, messes up the code readability. But right now, this looks pretty easy to read, if you just have it much easier if you just have it on one line anyway. Okay, what is it doing? It returns the last five published questions, not including those set to be published in the future. All right. So how is it doing that? It's taking the questions model. It's finding all the objects and it's filtering those objects and only finding the following. Okay. This statement here, it's looking at the publication date, and it's only finding so this underscore underscore, lt means you're doing a reverse search. And you're saying less than or equal to, that's what LTE means less than or equal to. So any publication date that was less than or equal to the current time meaning only past or current posts, filter those. And then once we find those, we order those by descending publication date. So which one was the most recent ones? And then we show the first five, that's it. Okay. A lot going on. And now we can also test our new view. So now you can satisfy yourself that this behaves as expected by firing up the run server, loading the site in your browser creating questions with dates in the past and future and type checking that only those that have been published are listed. You don't want to have to do that every single time you make a change that might affect this. So let's create a test based on our shell session above seashells. See, what is it? See She sells seashells down the seashore. Okay, as a falling two poles slash test dot p y poles. Alright, we're adding reverse boom. And we'll create a shortcut function to create questions as well as a new test class. So this will create questions for us. Cool. Since this is not going to be a method is going to be a function, we're going to put it outside like that. This will create questions, how will it create questions, you give it a question text and you give it days? And then what it does is it'll create a question Would that number of days in the future? Or would that number of days in the past based on whether you pass in a positive number here, or a negative number here or something like zero? Okay. Right here, and then it goes into question that I've just entered creates that object in questions class. And for the question, text keyword argument and passes in question texts, and for the pub date, keyword argument passes in the time, which it gets from here. Cool. Cool. Okay, so question view index, what are we doing there? Question view, question index view test. So we're creating a new class here. So I'm going to go right there and paste it and save. So now we're creating tests for our index view. Instead of model. Okay, so this is our model test. And what we're saying is like test no questions, if no question exists, and appropriate, and appropriate messages displayed. So if I go into my views, and you can see, in my views, let's see, is there is it not there? Or is it an R h, I think it's in our HTML right index. So here, you can see it says if there are recent questions and show them else said, No polls are available. So we want to test that it actually does say no polls are available on our front end, we can actually do that, and right here and we say, hey, first, check that the status code for this page is a 200. Meaning that you actually find this page second test that that response that you find it contains no polls are available. Okay, so right now, remember, we have no questions at the moment. And then also, make sure that the cert query set is equal to the response is equal to the following. So this thing? latest question list should be empty. That makes sense, right? That means there are no questions, such as a no polls are available. And it should check that this is actually just an empty list. Cool. Now, what we want to do is test past questions. Okay, again, this could go on, could this go on one line, or this will be too crazy? This is pretty crazy. So I can I can break that up a little bit. That's fine. Still readable for me? Okay, so we're saying? If we create a question, okay. Again, this creates its own database, so it doesn't have our what's cracking and whatever tests available anymore for these tests, it creates its own database, and then it destroys that database afterward. So within this database, we're creating a question and the question texts will be called past question instead of what's cracking or what's poppin or whatever. And we're gonna say that it should be 30. It should have been created 30 days ago. Okay, so this is a past question, hence, test past question. And then what we're going to say is, hey, response, get that particular page. And once we get that page, we want to say, Hey, is the are the latest questions of that page contain that question? And the answer will be yes, it does. Because we just created it. Right here. And if this thing is equal to this, then the test should pass. We're also going to create a future question. So this should test a question 30 days in the future, pretty much the same thing. And make sure that a response contains no polls are available. That makes sense, right? Because if the question is in the future, then it shouldn't be available right now. So it should say no polls are available. And also make sure that the response context latest question is empty. Because there are no latest questions is going to be posted in the future. Okay. Cool. And let's check this guy with the recent and past questions. Again, think it's a little bit more readable like that. You can break it down like this, that should be fine, too. But I like it like this. And basically, what we're testing here is that this thing should equal to this thing. And what's going on here? Are the doc for this as this is test future question and past question, even if both past and future questions exist, only past questions are displayed. That makes sense to and how does it work? We create a question 30 days in the past, we create a question 30 days in the future? Question. One is called past question. Question two is called future question. We get the polls index page. And then we say that this thing, the latest question list should only have the past question those created 30 days ago, and not the recent question. And it should match that. And indeed, and it should, right? If we did everything, right, we shouldn't get an error if we run this. And then all we need to do is define to past questions. All right, now this is getting a little too big. So let's break this one down now. And you can indent this too. Okay, so what am I saying here? I'm saying? So test to past questions. So the questions index page may display multiple questions. So we also want to see that it doesn't just display one question. It displays multiple ones, right? So we have past question, one, which was created 30 days ago, we have past question two, which was created five days ago, we get the polls index page. And then we say make sure that the question list. Actually, let's do it like this? Because I think it's more readable, actually. So you want to say that this should equal to this? latest question list should have both of the past questions. Why in this order? Because remember, the most recent ones it shows at first, right? If we look at our views, and how it does it, ascending order, sorry, descending order, and then the five. So that's why that's why I would show the past question to first. And then this one right here. Cool. Basically, the most recent question and show all the way at the top. Alright, so first of the question, shortcut function, create question to take some repetition? Yeah, well, we pretty much went over this whole thing. So we don't have to check that answer. So on in effect, we are using the test to tell a story of admin input and user experience on the site and checking that at every state. And for every new change in the state of the system, the expected results are published. Now. That's a really important point, like you're telling a story with your test guys like this is what's really important to understand. So if you're working on a team with somebody and somebody is reading through your test, they understand what each of your view is supposed to do, and what it's supposed to return like so so, so key, like if I'm looking at somebody's code, I don't know what the hell it's supposed to do, right? I don't know what the right answer is supposed to be. But if I look at their tests, and they have like bunch of examples, and what the correct answer and the wrong answer should be and that these documentation I totally understand what each function is supposed to do what each class is supposed to do. And then effectively, I'm on the same page. And then I can actually contribute to this project, right, I can go, that's where you guys hear like, hey, just go ahead and contribute to open source projects is one of the ways that you can do that. Understand, look at their test first. And then, like, I can't tell you enough, for those of you who are a little bit more advanced to understand the library, here's a pro tip, one of the best ways to do it is not just like, instead of just reading the code, go and look at their tests, and they will have so many things in there and what it's supposed to do, you'll start understanding how this library supposed to work, and it's how it's supposed to behave, literally tells a story. Now we want to test the detail view. Okay. So what we have works well, however, even though future questions don't appear in the index, users can still reach them if they know or guests the right URL. So we need to add a similar constraint to detail view. Okay, so we don't want to our users to be able to reach those questions, obviously, because they don't exist. So they shouldn't just be able to go to that particular URL. Okay, like, let's say you had a blog post, like, whatever your blog post is called banana. So it's like, john comm slash blog slash banana. If you scheduled it for like, a month later, I shouldn't be able to just go to it from the URL. Okay, so what's going on here? We have the detail view. So let's go into our views. Let's go into our detail view. It's right here. What do they want us to do? They want us to create a query set and do this with it. Okay, excludes any questions that aren't published yet. So filter, make sure the publication date is less than or equal to, then the time zone now. That's, that's it. That's essentially it. And those are the only ones you can check. Pretty cool. Okay. Very, very powerful. Again, you can see how powerful the generic method is. And of course, we will add some tests to check that a question is publication date is in the past can be displayed, and now one with the publication date in the future is not. So let's go into our tests. And let's add the test for this. So again, it's a new class, it should have its own methods and everything, right. So for the index view, we created a class. Okay, for those tests. And now, for our detail views, we're also creating a class. Okay, very important. Now we test future question and we test pass question, how do we do that? We create the question five days in advance, we send you to the polls Detail page. So like, for example, on Instagram, if you click into a image, and it shows you that specific image that's equivalent in our app of polls, detail, or questions, detail view. And for the arguments, we give it that questions ID from right here. And as a response, we get that particular URL, and then we say, hey, make sure that the response actually returns a 404. And it will, because here's how we told it. And then test pass question. So basically, here we're saying 404, meaning it doesn't exist, right. So the detail view of a question or the publication date in the past displays two questions, text. So past question we create the question here is created five days ago. We get the URL for the polls detail, and we pass an ID for the past question. And then as a response, we get that specific URL. And then we assert and make sure that it can the response contains the following thing. So response, and then it should have the question text in there. Okay. It's a past question. Question text. Cool. And, let's see. Let us Let's see if we're gonna be using any more command line stuff or not. Let's go an exit. And let's just see right now for tests are working. In our poll slash views, something's happening on line 18. What is happening? Ah, oh, okay, it's not indented correctly, obviously. Save up and Enter. And look at that all our tests ran in here. And they all ran successfully. So you can see all these tests have already gotten pretty complicated, and they're testing our app pretty thoroughly. You know, this is not something you want to do manually every single time, and you can already see the power of it. Alright, ideas for more tests. So we got to add similar query set method to results view and create a new test class for that view. So we can also test results view. It'll be very similar to what we have just created. In fact, there'll be a lot of repetition, we could also improve our application and other ways adding tests along the way, for example, it's silly that questions can be published on the site that have no choices. So our views could check for this and exclude such questions. Our tests could create a question without choice and then test that it's not published, as well as create a similar question with choices and test that it is published. Also, you can have logged in admin users who should be allowed to see unpublished questions, but like ordinary visitors shouldn't be. So if you're an admin, right, and you have WordPress blog, and you schedule one in advance, you can see it but other people can't just like, I can't schedule my YouTube videos, you can see it I can. whatever needs to be added to the software to accomplish this should be accompanied by a test whether you write the test first and then make the code pass the test. This is the test driven way of doing it. Or work out the logic in your code first, and then write a test to prove it. At a certain point, you're bound to look at your test and wonder whether your code is suffering from test bloat, which brings us to the following. So the thing that they say is when testing more is actually better. Okay. So it might seem that your test is going out of control. And there's a lot of like test bloat. And you know what? Your beautiful, elegant and concise code compared to your tests looks so much better. That's totally okay. Tests are supposed to be bulky and a lot. And they should cover your ass. Okay, that's their job. And so they don't have to look pretty, they don't have to look beautiful, they have to tell a story and have to tell it clearly. So it doesn't matter. Right? let them grow. And for the most part, you can write a test once and then forget about it, it will continue performing its useful function. As you continue to develop your program. Sometimes they will need to be updated just like we had to update ours, telling us exactly which test needs to be amended to bring up to date so that extent, tests help look after themselves. At worst, as you continue developing, you might find that you have some tests that are redundant. In testing redundancy is actually a good thing. And even that redundancy is not a problem. Okay? So the more you test, the better and you don't have to go back and wipe anything clean. As long as they're sensibly arranged, they won't become unmanageable, okay? So the good rules of thumbs. Good rules of thumb include the following. You should have a separate test class for each model or view. So for remember, for each of our models, right, or question model, question model test, we had a different class for this. And for each of our views, we actually had a different class for a detail view, we had a different class for our index view. And if you wanted to go further, we could also add a different class for our results view. A separate test method for each set of conditions you want to test. So instead of testing test, no questions has passed question and kind of like testing an all in one, it's a good idea to break it down into separate different tests. Each test doing only one job so here if no questions exist, and appropriate message displayed, that's what this is. Test is supposed to do. This test over here. Questions with the publication date in the past are displayed on this page. Like you can see each each test is trying to do one and one thing only. Okay. test method names that describe their functions. So the names themselves should describe the function of the test. Okay, so test no questions, test pass questions, test future questions. And once you build this naming convention, you and your team starts understanding it. And most of the times, you guys will be able to just look at each other tests and know what your app is supposed to be doing, or it's not supposed to be doing. further testing, this tutorial only introduces some of the basics of testing, there's a great deal more that you can do and a number of very useful tools at your disposal to achieve some very clever things. For example, so this is a pretty cool part. Right now, we just kind of tested our back end and a little bit of our front end. But what if we wanted to test our JavaScript and how it loads and literally, like, moving the mouse, like have the computer, move the mouse and select one of the votes and click vote? How does that experience work? How can we test that on autopilot? where it happens automatically? Well, there's something called selenium, selenium, or Selenium. And it's a way to test your HTML actually renders in a browser. Okay. So these tools allow you to check not just the behavior of your Django code, but also, for example of your JavaScript and your browser, pretty freaking mind blowing. It's quite something to see the tests, launch a browser and start interacting with your site as if a human being were driving it. And Django includes live server testcase, to facilitate integration with tools like selenium, okay, so if you want to get more advanced, look up Django and selenium. And you can even look up YouTube videos online and add those kinds of tests within your app. If you have a complex application, you may want to run tests automatically with every commit for the purposes of continuous integration. So if you guys know about GitHub, and commits, you can make it so that when you're writing the code, and as soon as you commit it, I like to call it like the time machine, because that's what Git and version control allows you to do. You can make it so then it tests it on every commit. So that if any one of your commits, you know fails any of the tests, it'll be like, Hey, this is broken. And you'll find out right away, before you actually push that code onto GitHub, and destroy your life, embarrass yourself, Let down your family and be fired from your job. So that quality control it is itself at least partially automated, a good way, a good way to spot untested parts of your application is to check code coverage. This also helps identify fragile or even dead code. If you can't test a piece of code, it usually means that code should be refactored or removed. that's those are some big words. coverage will help to identify dead code c integration coverage dot p y. And you can check you know what's dead code and what's not. And, yeah, so a lot of testing, I hope that you enjoyed that. We're going to be covering essentially how static files work in Jango. Okay, and how you can use them to customize your apps look and feel. Okay, so without any further ado, let's jump right into it. Okay, so writing your first app, Part Six, right? So how are what are we doing now? Now we've built a tested web poll application. If you haven't done that, go back to part five. If you haven't done part five, go back to Part Part Four. Make sure you're following this in order. And now will now add a stylesheet and an image. Okay. So aside from HTML that your app generates, right, and shows which is your front end, so far, the voting thing that we have, or it shows some text with radio buttons, your website needs to be able to do other things to like show people images, or pictures of cats or blog post images. It also needs to be able to serve up JavaScript if you have any JavaScript, right? So for example, if you don't know what JavaScript is, is totally fine. But like, anytime you're clicking a button, and it like pops up a menu kind of thing. That's usually JavaScript going on there. Okay. If you click something like a pop up comes up, there's JavaScript, JavaScript is pretty much everywhere. So your website needs to be able to show some JavaScript and it also needs to be able to serve CSS, okay, which is, it's called CAS stands for cascading style sheet and you use this to stylize your app and make it look cool and beautiful. Okay. And yeah, so that's usually what's necessary to complete a web page. In Django. We refer to these files as static files. Now for small projects, right? This isn't a big deal, because you can just keep the static file somewhere where your web server can find it. However, in bigger projects, especially those comprise of like multiple attributes, if you have multiple apps like polls and blog, and e commerce, like whatever, dealing with the multiple sets of static files provided by each application starts to get tricky. That's why Django contrib that static files is there for you, if you're a beginner, don't worry about this part too much. But this is for more advanced people mentioning this part, okay? Otherwise, I've kind of skipped over. It collects static files from each of your applications and any other places you specify into a single location that can be that can easily be served in production. Okay, so now let's get to customizing your app's look and feel. So first, we're going to need to create a directory called static in your polls directory. Okay, so let's go ahead and do that. And I will open up, Adam, and we will go in our polls. Hopefully, you can see that on the left hand side, I don't know how to make tab bigger. So I'm sorry about that. But yeah, we're gonna go inside of our polls, and inside of our polls, I think this is where it wants us to make it. So I'm going to right click this polls, not the templates one. So right click, right click here, create a new folder and call it static. Done. Okay, cool. And for those of you wondering, like, how do I switch like that it's command and tab, and on Windows, that's all done tab. Cool. Django will look for static files. They're similarly to how Django finds templates inside polls, template polls slash templates. So you know how there's like polls slash templates, and Django automatically looks for templates there. Well, just like that, for your static files, Django is going to look inside of your folder static. Okay, so Django static file setting contains a list of finders that know how to discover static files from various sources. One of the defaults is AB directories finder, which looks for a static subdirectory in each of the installed apps, okay, so Django will automatically look for a folder called static under each of the installed apps. Okay, so right now, we have polls as one of our apps that we created. And remember to install this app, we had to do this line in our settings file under installed apps. And then, now Django is able to find its static folder. If you have another app, again, like a blog app, and you have static folder under there and you install the blog app, then you'll be able to then Django will be able to find the blogs, blog apps, static files, okay, like images, JavaScript, CSS, those are all considered static files. All right, the admin uses the same directory structure for its static files. Cool. So admin site works the same way. Within the static directory, you've just created creating another directory called polls. So inside of static, we're going to create another directory, and we're going to call it polls, okay? So kind of like how you have polls, templates, polls, you're gonna have polls, static polls, okay, similar. And then inside of here, we're going to create a file called styles dot CSS, I'm going to do new file, and I'll do style dot CSS, just like that. Okay, so this is our CSS. Again, in the command line, if you haven't activated your virtual environment, make sure to do conda or sorry, source, activate my sites. If you haven't done that, just in case you need to do something in the command line, which you're not going to in this video i don't think because of how the app directories find your static files. Find your works you can refer to this data file and Django simply as polls slash styles dot CSS similar to how you reference a path for templates. So remember how for templates you just go pole slash index dot HTML well for this is pole slash style dot CSS, okay. And for namespacing it's just like templates. So the same reason why you put templates under the same reason why you make a new folder called polls, under templates is the same reason why you create another folder called polls under static it so then if you have multiple different apps, there is no collision based on like you having the same name for any of your CSS files or any of your HTML Mel files. That's what they're saying here. Okay, now we're gonna do some fun CSS stuff, okay, and we're going to keep it pretty simple. So in our style dot CSS, what I'm basically saying is that any link tag under a bullet point are listed thing, color red and green. Okay? So A stands for is like your link tags, anything that contains a link, basically returning for now returning almost all of our links on our current site green. Next, add the following at the top of polls, slash templates, slash polls slash index dot HTML. So we're going to go in our templates polls index dot HTML, and at the top we're going to add is we're going to say load static. So we're going to add that right here, load static. So what this is not able to do is load our static files. And then right here, I'm going to add this. So I'm creating, I'm creating a link to a stylesheet. The type is text slash CSS. And the link is this. Now I'm using the link in a dynamic way. This is the best way to link it instead of like hard coding natural path. And you just say Polo slash style dot CSS, okay, that's how we refer to it. And that's pretty much it. Okay, so now, let's go to our, our website. So I'm gonna do Python, manage that py run server. And we're gonna open up a new tab, and I'm going to go 127 that slash 1000. Or I'm sorry, slash polls. And you can see that all the links are green, right, if I go back to my stylesheet, and turn it into something else. So let's go back into sorry, style that CSS is right there, I'll bring it here. If I change this to like blue, save, Command S go back here refresh, you can see that all of this is now blue. If your didn't turn blue, close out of your server, or break the server with Ctrl C, and then try it again and then should be fixed. And Yep, there we go. And also make sure to save Okay, and another way to go to this same link is doing HTTP localhost colon 8000. Slash polls, okay. And that should take you to localhost colon 8000 slash pauses the same thing as your 127 dot o dot o dot one colon 8000. Do the same thing. Alright, so that's essentially how we got that to work. Bring this guy here. Now, we also can add a background image. Okay, so we'll create a subdirectory for images create an images subdirectory. So basically, inside of our static, and polls, we're going to create static holes, we're going to create a new directory, and we're going to call it images. This is where we're going to put all up all of our images. So it should look like this. And then you can put whatever image you want, right background dot GIF, or. So what we'll do is we'll go online and like, grab an image. So let's get cats. Right click, and then just save the image. And you can save it whatever you I'm going to call it like cat back round. Oh, sorry, we can just save it wherever we want. I'm going to save it under my site, my site, or sorry, polls, static polls, images, and I'm going to save this cat underscore background. And it's automatically dot JPG file. Because I have the format selected like that. I'm going to hit save. It saved I'm going to open up my atom. And under images, I now have my cat background JPEG. So let's go back to this tutorial. And it's basically saying to do this, add this to your style sheet. So I'm going to add this now, I'm going to say so from images instead of background that GIF mine is called cat underscore background dot jpg, like that. So now, it's gonna find basically in our HTML code, it's going to find anywhere we have the body tag, it's gonna make its background, this cat image, okay, so if I go to, you know, our index dot HTML, if any of this stuff is In a body tag, it'll add that to the background. So let's check it out. It says, and you should see the background loaded in the top left of the screen. Okay, let's give it a try. Let's see if they're in line. And there you go. It's there, right? So pretty cool how it works. And what I could also do is I could go to my index dot HTML, and like wrap maybe a certain part of it in the body tag. So like, maybe the part that's in the for loop, right? So I can, I can go like, body tag. And I can choose to close the body tag outside of this unordered list, I can go body like that. Okay, if I want to, and I go back, I refresh. And the same thing. Okay. So this is essentially like a little bit of how HTML and CSS like talk with each other. Okay, and now let's look at kind of their last notes here. So there, okay, so warning, of course, the static template tag is not available for use in static files, like your style sheet, which aren't generated by Django. So in your CSS file, you can't use something like, static. Like that. It's not going to know what that is. And you can do like if then statements here. These are just your static files, hence, they're not dynamic and can't do like variables and cool stuff, right? Like your index, your HTML file can with the, which has a Django templating. system. And in there, you should always use relative paths. So here, we're not using like, slash user slash clever programmers slash GitHub, slash my site, slash my site or slash polls, slash what else is it? static slash polls slash images, right, we're not using the absolute path. That's the definition of absolute path, we're using a relative path to it. Do you're satisfied between each other because then you can change static underscore URL. So this is again, a little bit more advanced. I'm gonna I'm gonna skip over this one. But you can read that if you want. And that's essentially how you work with general like static files on Django. There you have it, folks, I hope you enjoyed this tutorial. I hope it was informative, and juicy, and you loved it. If you did love it, please leave a comment, please like it and share it with at least one friend. Because if you have at least one friend or family member, sorry, what's happening in my mind, if you have one friend or one family member who's doing development alongside you, is going to boost your success rate up by at least 60%. They have like scientific studies on this. So share it, maybe somebody will watch it alongside and you will become web developers together.
