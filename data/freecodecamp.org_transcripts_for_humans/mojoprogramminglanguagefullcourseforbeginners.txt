With timestamps:

00:00 - the Mojo programming language combines
00:02 - the usability of python with the
00:04 - performance of C it's basically an
00:06 - enhanced version of python specifically
00:08 - designed for artificial intelligence
00:10 - developers in this course Elliott
00:12 - Arledge will teach you how to use Mojo
00:14 - Ellie has created many popular courses
00:16 - related to Ai and he's the perfect
00:18 - person to teach this course let's start
00:21 - learning welcome
00:23 - to intro to the Mojo programming
00:25 - language
00:26 - course you're going to learn the
00:28 - fundamentals of using Mojo you're going
00:30 - to learn some of the intermediate and
00:32 - advanced features of it as well
00:34 - but before I touch on those
00:36 - I should cover some Basics first so you
00:37 - might be wondering who the heck is this
00:39 - guy on your screen
00:40 - well my name is Elliot I'm a computer
00:43 - science student a computer science
00:45 - student undergraduate and I like to mess
00:48 - around with code I like to train
00:49 - language models in my free time and I
00:53 - build awesome content like this
00:55 - so if you end up enjoying this feel free
00:58 - to subscribe my YouTube channel is just
00:59 - in the link in the description so you
01:02 - can totally check that out if you want
01:04 - uh a little disclaimer Mojo's a very new
01:07 - programming language it was actually
01:08 - released a week or two ago and by the
01:12 - time you're seeing this this course may
01:13 - actually be out of date so a little
01:16 - disclaimer there uh there there might be
01:17 - some new features there might be some
01:19 - weird syntactical things that don't work
01:21 - the same but this is to cover right now
01:25 - there may be some new tutorials that
01:27 - come out in the next you know little few
01:29 - months here or maybe even the upcoming
01:31 - years
01:32 - so just a little disclaimer
01:34 - this may be out of day by the time
01:36 - you're watching this this video is
01:37 - uploaded in September of 2023
01:40 - so a little discommer there the docs
01:44 - specifically the Mojo docs the Mojo
01:47 - documentation says that this language is
01:49 - actually designed for experience systems
01:51 - programmers but the point of this course
01:53 - is to provide you with the fundamentals
01:55 - of getting using Mojo and being able to
01:58 - easily bounce off the documentation when
02:00 - needed so it assumes some fundamental
02:03 - knowledge of simple languages like
02:05 - python uh if you don't have any
02:07 - programming experience I recommend you
02:09 - touch on python a little bit or you
02:12 - could even just chat GPT your way
02:13 - through it that's what a lot of people
02:15 - do in fact that's what I did to learn a
02:17 - lot of what I know now
02:19 - uh understanding a programming language
02:21 - in depth will help you adapt to other
02:24 - languages as well so if you have some
02:26 - knowledge from ABC or C plus plus
02:28 - or JavaScript or python this course will
02:31 - just be even more easy for you to
02:33 - understand
02:34 - uh we're not going to be doing any
02:35 - intensive projects we're just going to
02:37 - explain how the language and the Mojo
02:40 - command line interface works so we're
02:42 - going to be building some simple scripts
02:44 - we're going to be building Jupiter
02:46 - notebooks using the Mojo language and
02:49 - we're going to be doing some command
02:50 - line stuff too
02:52 - this materials only backtested on
02:54 - Windows all you really need is a Linux
02:56 - terminal like Ubuntu and everything is
02:58 - the same
02:59 - so this means if you're on a Macbook for
03:01 - example you could search up a little
03:04 - tutorial on YouTube for how to install
03:06 - Ubuntu and get that set up but anyways
03:09 - as long as you have Ubuntu and that
03:11 - little Linux environment everything
03:13 - should be the same
03:15 - we will be using visual studio code to
03:17 - edit things here jupyter notebooks will
03:20 - be in the browser you'll you'll see that
03:22 - later if you're not familiar with
03:23 - Jupiter notebooks yet but
03:25 - um just the premises that we'll be using
03:27 - vs code as our text editor
03:30 - and lastly before we jump into what Mojo
03:33 - is
03:34 - I want to say that for those AI
03:36 - enthusiasts I'll begin with some simple
03:39 - sequential cpu-based processing and then
03:42 - later in the course we'll jump into some
03:45 - still CPU processing but in parallel so
03:49 - parallel is essentially or at least
03:52 - sequential is when you do things one by
03:55 - one you wait for one to complete and you
03:56 - start the next and then parallel would
03:58 - mean you do a bunch of tasks at the same
04:00 - time so
04:02 - we're going to start off with some
04:03 - simple sequential based processing just
04:05 - to understand the language because we
04:06 - don't really need anything else to
04:07 - understand the language we don't need
04:08 - super high computational speeds
04:11 - we're just going to need yeah just some
04:13 - simple sequential we'll jump into
04:15 - parallel processing later
04:17 - so you might be wondering what the heck
04:18 - is this whole Mojo thing maybe maybe you
04:21 - clicked on it because Mojo is kind of
04:22 - the hype right now but we're just
04:24 - assuming you know you're completely new
04:25 - to Mojo you don't even know what the
04:27 - language is about what does it do
04:30 - um so essentially Mojo is kind of like a
04:32 - it quite literally is a superset of
04:34 - python so you can use all the same
04:36 - python syntax which a little bit of
04:39 - limitations of course since it's a brand
04:41 - new language
04:42 - uh and you can get the the scale and
04:45 - performance of a language like C plus so
04:48 - you can use very simple syntax to write
04:51 - the language and you can get insane
04:53 - performance out of it so
04:55 - why the heck do we need insane
04:56 - performance well the thing with python
04:58 - is that python is quite slow actually
05:01 - python is not a compiled language so
05:04 - python takes a long time and all of AI
05:08 - research right now or most of it is
05:10 - actually built and deployed with python
05:13 - so all of the models that you'll see a
05:16 - lot of the machine learning courses that
05:17 - you'll see on YouTube and in other
05:19 - places are purely based on python so
05:23 - what is mojo exactly doing well it's
05:25 - it's like python except you're getting
05:27 - that speed where you're able to train
05:29 - models or do renders way quicker
05:32 - so imagine it taking you you know four
05:34 - hours to get your model to a certain
05:36 - prediction accuracy than with Mojo if
05:39 - you were if you were able to optimize
05:41 - around that and you know put a little
05:44 - bit more effort into it you know some
05:46 - key features that Mojo uses will allow
05:47 - you to speed up the process and you will
05:50 - essentially be able to train the model
05:51 - in a fraction of the time so instead of
05:53 - taking say four hours it would take you
05:56 - maybe a few minutes if you do it right
05:58 - uh so as advertised Mojo has insane
06:02 - speedups over Python Meaning up to I
06:06 - think 77 000 times greater uh 70 77 000
06:11 - times faster than python in some cases
06:14 - and that's
06:17 - we're actually going to prove that in
06:18 - this video we're going to actually walk
06:20 - through and show how it speeds up and
06:22 - I'm going to walk you through how that
06:23 - all works but anyways this is a language
06:26 - to sort of revolutionize the whole AI
06:28 - space to make AI way faster to make
06:33 - training quicker to make just
06:34 - computation in general quicker through
06:36 - language and the lower level
06:39 - optimizations what I mean by lower level
06:41 - is just closer to machine code
06:43 - essentially higher level is like more
06:45 - abstract closer to English and then
06:46 - lower level would be closer to Binary
06:49 - machine code so in case you haven't seen
06:51 - the actual speed up that Mojo provides
06:53 - we're just going to go into the
06:55 - docs.modular.com I'll actually go back
06:57 - here modular.com Mojo and then you just
07:00 - click on the Mojo docs here
07:03 - and then we can go to Mojo notebooks
07:06 - matrix multiplication and then just roll
07:09 - all the way down I'm going to cover this
07:11 - material later in the course but just
07:14 - pretty much scroll all the way down and
07:16 - you can see that after a bunch of
07:18 - optimizations they end up with a 77
07:22 - 000 X speed up over python which is
07:25 - insane like that's almost taking an
07:28 - entire day of python code running and
07:31 - compressing it down into just a little
07:33 - over a second that's crazy there are 86
07:37 - 400 seconds in a day and if we divide
07:40 - that by 77 000
07:43 - that means it's about
07:46 - one one or or sorry 77 000 divided by
07:51 - eighty six thousand four hundred
07:53 - gives us that's zero that's 89 of a day
07:57 - so before I even begin setting up I want
07:59 - to emphasize that Mojo is a completely
08:02 - new programming language was released
08:04 - not even a few weeks ago
08:06 - with minimal support on anywhere but the
08:09 - GitHub or Discord so as for the Discord
08:12 - server I'm just going to go to the the
08:14 - modular Discord server you should be
08:15 - able to find it through the the website
08:17 - here
08:18 - and essentially you sign up do your
08:21 - verification or whatever and then you
08:23 - can actually search errors so be like
08:26 - you know uh error for example and then
08:29 - it would give you you know a bunch of a
08:31 - bunch of results so just search up like
08:33 - specific keywords be smart about it uh
08:36 - if you're encountering like certain
08:37 - types of errors that are like really
08:39 - long don't copy and paste the entire
08:41 - error into the search bar uh rather just
08:44 - look at like what are the keywords that
08:46 - this that this error throws and then
08:48 - just paste those in and just experiment
08:49 - and see if anybody else has encountered
08:51 - that because there are actually a lot of
08:53 - people in this community if I scroll
08:56 - down
08:59 - 2000 members so there are there's over
09:02 - two thousand people in this community a
09:04 - lot of which are actually offline right
09:05 - now
09:06 - but the point is there's a lot of people
09:08 - that can definitely help you out and
09:10 - some people that have already
09:11 - encountered errors so you can totally
09:13 - use the Discord to search for answers or
09:16 - even ask answer or ask ask questions and
09:19 - the other feature that you have through
09:20 - Discord is if you navigate down to this
09:23 - Mojo section and then go to Mojo bot
09:25 - help they actually have an AI That's
09:27 - trained on all of the Mojo documentation
09:29 - so if you go at Kappa Ai and you say
09:34 - um you know
09:36 - what are
09:37 - some basics of
09:40 - Mojo
09:43 - I could say
09:45 - absolute beginner
09:51 - and then it'll create a new little
09:53 - thread here
09:54 - and it'll say stand by for 20 seconds or
09:57 - so
09:58 - and in the meantime I'll actually show
10:00 - you the GitHub so we go to github.com
10:04 - modular ml
10:10 - and this is everything really you have
10:13 - the Mojo programming language here you
10:15 - have a bunch of you know issues and
10:16 - whatnot that you can submit to it what I
10:20 - would recommend though is that you
10:22 - absolutely make sure that if you're
10:23 - going to be posting issues on this Mojo
10:25 - GitHub that you make sure it's on fault
10:27 - of Mojo because if it's your fault then
10:30 - that doesn't really help out Mojo at all
10:32 - because that was just how the language
10:34 - was intended to work
10:35 - but if you were able to verify and you
10:38 - can verify through asking the Kappa AI
10:41 - about your issues and even looking in
10:44 - the Discord
10:45 - and if you happen to come across errors
10:47 - that are on fault of Mojo then you can
10:49 - just go on the issues here and later in
10:52 - the course I'll show you how to actually
10:53 - uh post these errors and properly ask
10:57 - questions so anyways those are some of
11:00 - your sources for now there's a little
11:02 - bit of stack Overflow but not that much
11:04 - so your main sources are going to be a
11:06 - little code issues
11:09 - searching for answers using this Discord
11:11 - search bar
11:13 - and asking the Kappa Ai and the Mojo bot
11:17 - help
11:18 - so if I scroll up
11:20 - says Mojo is a powerful language
11:22 - designed for high performance systems
11:24 - programming I'm sure similarities with
11:26 - system languages like rust and C plus
11:28 - but also designed to become a super set
11:31 - of python
11:32 - this means that many language features
11:34 - and Concepts from python translate
11:36 - nicely to Mojo Etc and it'll give you a
11:40 - nice little summary it tells you how to
11:41 - print stuff you can actually copy code
11:43 - directly from it it tells you how to
11:45 - make functions
11:47 - uh
11:49 - yeah essentially it you could just ask
11:51 - it anything about Mojo and it'll
11:53 - probably give you the best answer and as
11:56 - soon as summarized form and yes you can
11:58 - ask it to summarize things for you if
12:00 - you don't understand a systems program
12:01 - and concept uh you can definitely just
12:03 - say hey Kappa AI summarize this for me
12:06 - modular and Mojo only exist on Linux
12:09 - machines or at least you can only
12:10 - download them on Linux machines this is
12:12 - a Windows machine but I'm going to use a
12:14 - terminal and a Linux environment called
12:16 - Ubuntu so in order to download that go
12:19 - to Microsoft store
12:22 - wait for that to load
12:32 - move on to awesome search up Ubuntu app
12:37 - and then
12:39 - should be able to just install it there
12:49 - when we open it
12:51 - I'm not going to set up Ubuntu all over
12:53 - again because I already have it so just
12:56 - make up a username whatever and do that
12:58 - whole process
13:00 - um I'm going to go ahead and open mine
13:02 - here so this is the current Ubuntu that
13:04 - I have it's all signed in for me you can
13:07 - do clear to get rid of things
13:10 - uh you could do it LS to list it all the
13:14 - directories that you have uh you can go
13:16 - CD and then space dot dot to go back a
13:19 - directory and then CD and then type in
13:22 - the name of the directory you want to go
13:24 - into and let's just look at what we have
13:27 - so I'll CD into the Elliott directory
13:29 - and you can just press tab to uh
13:31 - autofill that
13:33 - awesome so this is our Ubuntu terminal
13:36 - so what exactly are we going to do next
13:38 - well we have to make sure that we have
13:40 - vs code installed that's also really
13:42 - important so if you don't have vs code
13:44 - go ahead and do that right now now
13:46 - before we We Begin developing in the
13:49 - Mojo programming language you're going
13:51 - to pop over to extensions in vs code
13:52 - here and then just simply go to Mojo
13:56 - like that and you should see this
13:58 - verified modular Creator and just going
14:02 - to go ahead and install this this is
14:04 - essentially the language support so
14:06 - it'll be able to read Mojo files Mojo
14:09 - files mean you can have this fire Emoji
14:13 - which I'll try to
14:14 - copy here
14:19 - and
14:21 - uh yeah essentially this this fire Emoji
14:24 - I don't know where I can paste it into
14:25 - maybe here
14:27 - no that didn't work uh anyways
14:30 - you can have your file extensions as
14:32 - this fire Emoji or the dot Mojo
14:34 - extension both of them work so that's
14:37 - pretty cool uh Unicode characters for
14:40 - file extensions gotta love it
14:42 - anyways I'm gonna go ahead and close vs
14:44 - code here and I'm going to make a new
14:46 - directory I'm going to call it uh intro
14:49 - to
14:51 - I'll jump and I can CD into that so
14:54 - you're going to go ahead and pop over to
14:56 - developer.modular.com download and this
14:59 - is just how you essentially get to
15:02 - downloading Mojo So Go download now
15:05 - and then says Mojo SDK is now available
15:07 - awesome and here it says setup on
15:09 - Windows Linux Mac Mac Intel well you
15:13 - might be wondering why the heck did he
15:14 - just tell us to only use a Linux
15:16 - terminal Linux environment well the
15:18 - thing is if we go to Windows it's not
15:21 - available for Windows yet but you can
15:22 - use it on the Linux container remote
15:24 - system
15:25 - you can use that with wsl2
15:28 - we're just going to use Ubuntu for a
15:30 - Linux environment same thing with Mac
15:32 - right
15:33 - not available for Apple silicon yet but
15:36 - you can use Linux system
15:38 - and then to install Linux there's no
15:40 - warning there so awesome to install the
15:42 - modular CLI you essentially just copy
15:45 - this code here I don't know if the code
15:47 - is different for different people but
15:49 - you're just going to go ahead and copy
15:50 - this and paste it into the terminal here
15:57 - oh
16:09 - okay awesome so it's newly installed and
16:13 - then what do we do after this well we've
16:15 - been let's actually check our modular
16:17 - version so make sure it actually exists
16:20 - so we have modular here and actually
16:22 - another way of installing a modular is
16:25 - to Simply go
16:26 - sudo apt install modular that's a
16:29 - different way of doing it if you'd like
16:30 - to do that
16:32 - um
16:32 - but this way is more guaranteed I know
16:34 - some people get
16:36 - errors with the authentication key so
16:39 - just just be explicit and put this curl
16:42 - command
16:43 - next up we're just going to need to
16:45 - install Mojo So we go modular
16:48 - install Mojo
16:52 - we found a release let's install it cool
16:56 - and then we don't need the rest of this
16:57 - this is um already done
16:59 - so I'm just going to close this out
17:02 - and I'll come back when this is done so
17:04 - to begin to run our first Mojo script
17:07 - we're going to go ahead and open this in
17:09 - Visual Studio code or vs code for short
17:12 - and all you do is you just go code dot
17:15 - period the period just says open in the
17:18 - local directory so I go enter and we get
17:21 - it to open up in vs code right here
17:24 - so I'm not going to use this terminal
17:27 - anymore I'm going to use the one built
17:29 - into Visual Studio code so it'll do that
17:31 - if you're on Windows you just go control
17:33 - and then the grave symbol it's right
17:36 - below the uh Escape key so awesome we
17:38 - have this terminal opened up let's go
17:40 - ahead and make a new a new file
17:43 - so we go main dot Mojo and uh I'm just
17:48 - going to zoom in on here
17:51 - hopefully that's good enough
17:53 - all right
17:55 - I can it's cutting me off a little bit
18:01 - awesome we fixed it cool so in order to
18:04 - actually print hello world you might be
18:07 - saying you know can we just do
18:09 - can we just print out this way
18:11 - and we get an error it says to do
18:14 - expressions are not yet supported at
18:15 - paloscope so file scope just means that
18:18 - it's not inside of a function or a class
18:20 - so this is not inside of anything except
18:23 - for the file hence it being file scope
18:25 - level so this is global and Mojo doesn't
18:28 - like that right now so
18:30 - to counteract this all we need to do is
18:33 - just go FN main FN is short for function
18:36 - that's what functions is what functions
18:38 - look like in Mojo you just go colon like
18:41 - that and then print
18:46 - hello world and then if you really
18:48 - wanted to
18:49 - you could just do a variable here you
18:51 - could go
18:52 - let X or let's
18:56 - hello equal
18:59 - hello world
19:01 - and then
19:05 - you go in a print hello like that
19:10 - Mojo
19:11 - Main and so variables do work at file
19:14 - scope but we're going to dive more into
19:16 - that later but anyways we're able to
19:18 - print hello world this is great so some
19:20 - of you who use Jupiter notebooks might
19:22 - be wondering well how the heck do I get
19:24 - a Jupiter notebook running on my machine
19:25 - and for those of you who don't know what
19:27 - a jupyter notebook is it's essentially
19:29 - just a giant notebook it's like a white
19:31 - HTML notebook of a bunch of code that
19:34 - you can paste into code blocks and just
19:36 - run it in any order you want
19:38 - so anyways you're going to see what that
19:40 - looks like in a second and to do that
19:42 - you're going to make sure python is
19:44 - installed so make sure you go python3
19:46 - version awesome
19:49 - and then to install Jupiter just go pip
19:52 - install
19:54 - Jupiter just like that
19:56 - so collecting Jupiter as you can see I
19:59 - already have a lot of the dependencies
20:01 - or requirements installed
20:03 - so now we can simply just go
20:07 - oh shoot there
20:10 - notebook just like that
20:12 - and should be able to open it up
20:16 - right there
20:17 - so as you can see this is what the
20:19 - Jupiter notebooks look like and I can
20:22 - actually create a new file
20:23 - make sure that it's in the Mojo kernel
20:26 - so you do Mojo and then you'll see it in
20:29 - the top right here if you try to open it
20:30 - up in the python
20:32 - the Python 3 kernel then it will not
20:35 - work
20:36 - so we could simply just go
20:41 - for example let x equals three and then
20:44 - go ahead and print X
20:48 - run that
20:50 - awesome we get three and then if you
20:53 - wanted to you could you could say print
20:54 - X down here as well and you would also
20:57 - get three so essentially everything
20:59 - carries down from the bottom from the
21:01 - top all the way to the bottom so you can
21:03 - store some variables up here and then
21:05 - just run them later down here as well
21:07 - this is used for a lot of tools in data
21:10 - science because or at least in data
21:13 - science and training models you'll have
21:15 - some you know trained model or something
21:17 - you'll have spend a lot of compute power
21:19 - on training a model
21:21 - and you don't just want to throw it away
21:24 - you don't just want to run a single
21:25 - script and then just not be able to use
21:27 - it ever again so you can either save
21:29 - model files which is a bit slower and
21:32 - you would do that with scripting or you
21:35 - could use jupyter notebooks and just
21:37 - save model parameters from a previous
21:39 - code block and then reference it again
21:41 - so that's essentially what this allows
21:43 - you to do
21:44 - and then I'm just going to delete all of
21:47 - these awesome so this is our uh notebook
21:50 - right now this is what it looks like so
21:52 - you can choose to code along with the
21:53 - notebook or not I will be using vs code
21:57 - so I'm going to go ahead and close this
21:59 - here
21:59 - uh I'm going to exit in order to cancel
22:03 - it you just go Ctrl C like that
22:07 - so that's how your Jupiter notebooks
22:09 - work I'm just going to right click
22:11 - delete enter
22:13 - awesome so that's Jupiter notebooks for
22:16 - you now we're actually going to jump
22:17 - into
22:18 - how the Mojo language itself actually
22:21 - works so now let's actually begin with
22:23 - some variables so what are the different
22:26 - types of variable declarations that
22:28 - exist right now so there's let which
22:31 - essentially is declaring the variable a
22:33 - constant it cannot change
22:35 - in in programming terms it is immutable
22:38 - immutable cannot mutate it cannot change
22:40 - it
22:41 - VAR means it's it can change so let is
22:46 - constant VAR is not constant so varlets
22:49 - allows variables to be changed
22:51 - hence it being VAR for variable meaning
22:54 - it can vary
22:56 - uh and then we have Alias which
22:59 - essentially just uh compiles it stores
23:03 - the variable at compile time
23:05 - so compile time is when it's converting
23:08 - your code to Binary form and runtime is
23:11 - when it's actually just like running
23:12 - code itself so if you have variables
23:16 - that are sort of compile time you might
23:17 - save yourself you know some some
23:19 - nanoseconds or milliseconds whatever it
23:21 - ends up being so most commonly you would
23:23 - end up storing what we call libraries
23:25 - with Alias but we'll go into libraries
23:27 - more later
23:28 - so we have let Varan alias
23:31 - so if we go you know let x equal three
23:36 - and then we were to
23:39 - print out X
23:41 - go Mojo like that
23:43 - and we get a A3 here awesome what if we
23:47 - were to change X to 2.
23:50 - we can already see a red underline there
23:52 - it says expression must be mutable in
23:55 - assignment
23:56 - so this x must be mutable meaning it
23:58 - must be able to be changed when we
24:01 - declare it with let that means it's a
24:03 - constant it cannot be changed so if we
24:05 - change the slides to a bar
24:08 - then boom we get a two
24:11 - so awesome and then if we were to just
24:13 - go uh alias
24:18 - it must be mutable in assignment so
24:20 - alias
24:21 - is essentially the equivalent of let but
24:23 - for compile time rather than run time
24:26 - so
24:27 - far is specifically for runtime and it
24:30 - allows the argument to be it deems the
24:32 - argument mutable
24:34 - and uh
24:37 - let deems the argument immutable but it
24:41 - goes at runtime whereas Alias would be
24:44 - immutable at compile time so awesome
24:47 - that's essentially just all the variable
24:49 - declarations and information you're
24:51 - going to need so next up let's go ahead
24:54 - and jump into data types so I'm just
24:56 - going to specifically use the let
24:57 - declaration here we're going to go let X
25:00 - and then you put a colon after
25:02 - and there are a bunch of different data
25:04 - types that currently exist so you can go
25:07 - you can use a string you can use an
25:10 - integer
25:13 - you can use a floating Point number or a
25:15 - float
25:16 - you can use a Bool
25:20 - you can use a
25:22 - unsigned integer and we'll go over what
25:24 - that means
25:26 - and that's that's pretty much it you
25:28 - have these These are the five uh common
25:30 - data types that we're going to be using
25:31 - there's one more that we're going to
25:32 - introduce later
25:34 - uh but these are the basic data types
25:36 - that you're going to be using so what is
25:38 - a string well a string good so we want
25:42 - to declare it explicitly a string
25:44 - and we let that equal
25:46 - and all we would do is we would put
25:48 - either some single quotes or double
25:50 - quotes around it or even these ones but
25:53 - I don't think it likes these ones very
25:55 - much so we're just going to stick with
25:56 - single and double quotes
25:58 - I like to use single quotes because you
26:00 - don't have to press shift when you're
26:01 - pressing the quote button just it's just
26:03 - easier that way and you don't have too
26:06 - extra quotes to see through anyways
26:10 - uh that's that's enough about quotes but
26:13 - essentially you could just put whatever
26:15 - you want in here any word I could
26:17 - literally put one two three and
26:22 - it would just say one two three but it's
26:24 - in a string form so it wouldn't actually
26:26 - be like the number one two three it
26:28 - would just be like I guess the word One
26:29 - Two Three or the string one two three if
26:31 - you will
26:33 - uh so that's strings for you you could
26:35 - put you know you could put alphanumeric
26:37 - symbols in it like like a question mark
26:39 - or like like a Pam symbol or a percent
26:42 - whatever you want
26:43 - uh so that's what strings look like
26:46 - next up we have integers
26:49 - so integers are any counting numbers I
26:53 - guess I guess you could say that so
26:55 - accounting number would be like
26:58 - pretty much negative one to infinity or
27:02 - negative 1 0 1 3
27:06 - 462 or something right
27:09 - um
27:10 - so integers are any counting number they
27:11 - don't have decimal places
27:13 - and you can either say int equals and
27:17 - then say like six thousand or you could
27:19 - be explicit and say you know int 8
27:23 - equals six thousand and eight means it
27:25 - occupies uh eight bits on your memory
27:29 - so if you actually want to calculate
27:31 - what the highest number is that it could
27:34 - store it would be two since it's binary
27:37 - bits right and you do 2 to the power of
27:40 - 8 which is 256. so this could
27:44 - essentially store uh 256 different
27:47 - numbers on it
27:48 - or 256 combinations if you will that
27:52 - goes all the way from 0 up to
27:55 - it goes from zero all the way up to 255.
27:57 - so instead of 1 to 256 it would be 0 to
28:01 - 255 so just shift it over one but it's
28:03 - still the same amount of numbers so if I
28:05 - were to do 6000 in here it would
28:06 - actually uh
28:08 - it would not print that out it would it
28:10 - would actually overload our into Data
28:13 - quite a lot
28:14 - so if we were to lower this number to
28:16 - say you know 60 then we would get that
28:20 - to properly print out some other uh int
28:23 - bits I like bit occupying I guess you
28:26 - could use is n16 there's an n32 and an
28:31 - n64. there is no int 128 though so you
28:34 - just have 8 16 32 and 64.
28:39 - awesome and then if you don't want to
28:41 - put any any number after it it'll just
28:44 - default to N64 for for safety purposes
28:48 - uh so next up we have the I'm going to
28:52 - go over actually this this uint next
28:54 - because it's very close to the integer
28:56 - so U ins
29:00 - if I can type
29:02 - you end we'll just go eight for example
29:05 - I don't think you can leave it just like
29:08 - that unknown declaration must require an
29:10 - explicit variable declarations so that
29:13 - just means we have to put a number after
29:14 - it we can go either eight uh 16
29:18 - 32
29:19 - and 64. so same as int
29:22 - and essentially U and what does the u
29:24 - mean well the u means unsigned so if we
29:27 - have a variable say
29:30 - so we have an integer it could be you
29:32 - know negative one zero one right that
29:36 - would be an integer can be negative
29:37 - numbers or positive
29:39 - and a uint would just be an unsigned so
29:42 - it cannot have a negative or positive
29:43 - sign and when we normally write out an
29:45 - and without a sign say like 60 we assume
29:49 - that this is positive if we go 60 you
29:51 - know plus 30 we're assuming that both of
29:54 - these numbers are positives because they
29:55 - just don't have a sign on them
29:58 - um so that's what unit means it just
30:00 - Only One Direction it can only go
30:01 - positive whereas the int just int
30:05 - without the u could also go negative
30:08 - so so do your range for like an INT 8
30:10 - for example would be uh 255 to negative
30:14 - 255. uh we can actually type that out
30:18 - here
30:21 - 255 and we could print this out
30:24 - oh it's going to go to negative one
30:27 - if we go 254 Maybe
30:32 - 256
30:33 - there we go okay so yeah 256 different
30:36 - ones I got a little bit messed up there
30:38 - but if we were to put
30:41 - say
30:42 - negative 256.
30:48 - you would also get a zero as well so
30:51 - that kind of just shows the range there
30:53 - and you go uint
30:55 - and
30:57 - uh I just don't think that would work so
31:00 - if you were to go like
31:03 - maybe negative one
31:06 - I wouldn't like that so I just default
31:07 - to a positive number so that's what
31:10 - antonuent are just signed an unsite
31:12 - enters
31:13 - and then next we have the floating Point
31:16 - number so a float is just a decimal
31:18 - number just imagine like
31:21 - 60 is an integer and then 60.01 would be
31:24 - a floating Point number just a float
31:27 - and to declare these we just go
31:32 - we have to actually write a little
31:34 - number after it how many bits it
31:35 - occupies if we're going to be explicit
31:37 - about it
31:38 - uh if you weren't explicit you would
31:40 - just go let x equal you know 3.14
31:45 - 3.14 and uh if you want it to be
31:49 - explicit about it
31:51 - you would just go colon
31:54 - float and then you would put however
31:56 - however many bits you want so you can't
31:58 - go eight but you can go 16
32:01 - 32
32:03 - and 64.
32:05 - so if float 16 is just a essentially uh
32:11 - like a half Precision number if you will
32:13 - just lower Precision it's commonly used
32:15 - in machine learning for training models
32:17 - with like less numbers in them so float
32:19 - 16 is quite useful and a lot of Mojo
32:22 - cases but anyways don't worry about that
32:24 - too much that's just what these
32:27 - variables look like or these data types
32:29 - rather
32:30 - and then the last one that I like to
32:33 - show
32:34 - here go ahead and print that go to 3.14
32:36 - and then some little error there I don't
32:37 - know why that is but that's that's
32:39 - something on the Mojo end that we don't
32:41 - have to worry about
32:43 - um
32:44 - but yeah now we have Bool which is the
32:46 - last one
32:47 - so we just do
32:49 - ol just like that and we assign it to a
32:52 - pool is either a true or false variable
32:54 - so just go true we have to make sure we
32:57 - have a capital first letter so it's case
32:59 - sensitive
33:00 - or we can go false if we were to type
33:03 - like 3.14 it would say oh
33:06 - cannot convert float literal to Bull so
33:08 - it's thinking that this is uh it's
33:10 - thinking that you're trying to put a
33:11 - float here and it's like we don't allow
33:13 - that we only allow for true or false so
33:15 - a pool can either be true
33:18 - or cross if we were to say print that
33:21 - out
33:21 - you get false
33:23 - so awesome that is all of the basic data
33:26 - types let's move on
33:27 - so a lot of people that come from
33:28 - languages like python JavaScript or C
33:31 - plus or just any other language really
33:33 - you might be asking why the heck aren't
33:35 - you covering arrays or lists or
33:37 - dictionaries
33:38 - so the reason is because they simply
33:41 - don't exist yet in Mojo I'll show you
33:43 - kind of a little bit of a cheat way to
33:45 - make an array but it's not quite the
33:47 - same
33:48 - but simply arrays just don't exist yet
33:50 - in Mojo that's something that they're
33:52 - working on right now so I can't really
33:55 - go over that because it doesn't exist
33:57 - but anyways uh what we're going to jump
34:00 - into next is
34:02 - how to get a user input and then just
34:05 - print that out for example because
34:06 - that's what a lot of you learned in
34:08 - Python an introductory python course is
34:10 - how to get a user input and then print
34:11 - it out
34:12 - So currently the simplest way to do that
34:15 - is to go
34:17 - we're going to import the python Library
34:20 - you could say go python from python
34:24 - uh
34:25 - import python just like that make sure
34:28 - the p is capital
34:30 - and then inside of this FN Main
34:34 - or outside of it rather you have to type
34:36 - a raises I'll go into more of why raises
34:38 - is needed later on but you just need
34:41 - that to be there for now don't worry
34:43 - about it
34:44 - and then we're going to go let's
34:48 - we're going to go let's pi equals
34:51 - python dot import module and then we
34:55 - would go built-ins
34:57 - just like that
34:58 - so essentially we're just importing the
35:01 - built-ins module with which comes
35:03 - default in Python if you were writing a
35:04 - python script you wouldn't actually need
35:06 - to import built-ins because it's already
35:08 - done for you it just exists as a part of
35:10 - python so you don't really need that but
35:13 - in Mojo we need to explicitly import
35:17 - this
35:18 - and we're just going to give it a
35:19 - variable name py
35:21 - awesome so now we can go let some say
35:26 - user input
35:27 - equals Pi Dot input just like that so
35:33 - inputs exist as a part of the built-ins
35:36 - module inside of python so we could just
35:40 - call input directly on that
35:42 - and then we could say
35:45 - um you know
35:46 - what is your favorite
35:50 - color
35:52 - let me go ahead and print out
35:55 - user input
35:57 - say it
36:03 - your
36:05 - favorite color is
36:09 - go Mojo
36:11 - what is your favorite color
36:13 - let's say I like green
36:15 - your favorite color is green cool so
36:18 - that's how you get user inputs in Mojo
36:20 - use the assistance of python which is
36:23 - a little bit funny but that's currently
36:25 - how you do it right now in Mojo so
36:27 - that's pretty cool so now we're going to
36:29 - jump into if else statements so what the
36:32 - heck is an if out statement well
36:35 - it's simply if a condition is met then
36:39 - you execute some code and if it is not
36:41 - met then you default to some other code
36:43 - and I'll show you exactly what that
36:44 - looks like right now
36:46 - so inside of our FN main I'm just going
36:48 - to set a variable X
36:49 - we're going to make it let's just say an
36:51 - INT we're going to make it an INT 16 and
36:55 - we're going to set that to maybe 100
36:57 - okay
36:59 - so now we can we can actually do the if
37:01 - statement we could say if
37:03 - X which is what the variable name is and
37:07 - then double equals you might ask why are
37:09 - we doing a double equals well double
37:12 - equals because we're doing a comparison
37:14 - so if we do a single equals up here we
37:16 - are assigning uh the value 100 as an
37:20 - integer 16 2X
37:23 - we're assigning the value 100 to integer
37:26 - 16 data type
37:28 - 2x to the X variable if you will
37:31 - and all we're checking is that if the
37:34 - value of this x is equal to a hundred so
37:37 - this should actually just
37:39 - should go through so any code that you
37:41 - actually put under this you have to make
37:44 - sure that it's indented same thing for
37:46 - like functions I didn't cover that
37:48 - explicitly before but you do need to
37:51 - make sure that you have indents so that
37:53 - Mojo knows what to
37:55 - uh essentially how to interpret your
37:58 - script
37:59 - so we could print out huh
38:03 - true
38:04 - that
38:06 - wait wait get true awesome so if we were
38:09 - to change X to say 101
38:11 - we just wouldn't get anything it would
38:13 - simply just say oh this condition is not
38:15 - met uh this this little block inside of
38:17 - here is not equal to true
38:19 - so in other words essentially all if
38:23 - looks for is if whatever this little
38:25 - block of code or that whatever this
38:27 - comparison is if it does not evaluate to
38:29 - true then just skip it and and if it
38:32 - does evaluate to true then we just print
38:34 - whatever is indented inside of the if
38:36 - statement so if you were to
38:39 - say to else
38:42 - this would be the defaulting that would
38:44 - occur so you would print
38:46 - uh
38:48 - failed
38:51 - and you would get failed because it says
38:53 - this isn't true so we're just going to
38:55 - default to else
38:56 - if this is true
38:59 - and then else if it's not then just
39:01 - default to whatever is indented inside
39:02 - of this else little block here
39:05 - and the last one which you may or may
39:08 - not use is called alif let's go LF just
39:11 - like this and we could do another
39:13 - comparison if x equals 102.
39:18 - then we would print
39:21 - same X is 102.
39:27 - so it's still a hundred it's not a
39:29 - hundred and one it's not 102 so it's
39:31 - still going to go to failed but if we
39:33 - change it to say 101
39:35 - then we would get true if we change it
39:37 - to 102
39:39 - we would get X is 102 and then of course
39:42 - if you wanted to add more of these lfs
39:44 - you would only have an if and then an
39:46 - out at the bottom
39:48 - but if you wanted to have like a bunch
39:49 - of alifs in between you could totally do
39:51 - that so go L if x equals say 103.
39:58 - X is 103 like you could totally do that
40:02 - you can have as many LS as you want in
40:04 - here but it does start to get redundant
40:05 - after a while
40:06 - so that's that's essentially how if L if
40:09 - and out statements work if you're
40:11 - wondering like what the heck does LF
40:12 - mean that's just like a blending of the
40:15 - word if and else so it's like taking the
40:18 - first two letters of L and then
40:20 - you know the word if so LF
40:23 - um
40:24 - awesome so that's your if statements
40:26 - let's go ahead and jump into Loops next
40:27 - so next up we have loops so what the
40:30 - heck are Loops well there's two types of
40:32 - Loops so there's
40:34 - there's a for Loop and a while loop
40:37 - a for Loop will typically execute
40:39 - iteration by iteration until something
40:42 - is met until an end goal is met whereas
40:45 - while would just go on forever until
40:47 - something is met so 4 would typically
40:50 - stop somewhere whereas while would just
40:52 - go on forever until some conditions are
40:54 - met
40:55 - uh
40:57 - so let's actually start off with a for
40:58 - Loop and a lot of you python people have
41:01 - probably
41:01 - seen this exact sort of form before but
41:05 - essentially we go for index or four uh
41:09 - iteration for iteration
41:12 - and in short we could just say 4i
41:14 - because it's less characters to type and
41:16 - we'll just go 4i in and we would go
41:19 - range and you could put any number here
41:22 - I'm just going to put 10.
41:24 - and then you put your colon indent and
41:28 - we're just going to go ahead and print
41:29 - out I so this is what a basic for Loop
41:32 - will look like
41:33 - shouldn't it clear this
41:35 - and we get numbers printed out from 0
41:37 - through 10 or 0 through 9 sorry because
41:40 - it starts it actually starts at zero and
41:43 - then goes
41:44 - you know one by one until it until it
41:47 - satisfies you know a range of ten so ten
41:49 - different numbers there's a zero all the
41:52 - way through nine so if you were to shift
41:53 - that over one through ten
41:56 - um
41:56 - so anyways that's what for Loops look
41:58 - like and
42:01 - I'm going to go more into how we can
42:02 - like play around with these later I
42:04 - actually might do it after this Loop
42:06 - part but anyways next up you have while
42:09 - loops so
42:11 - what do while Loops look like
42:13 - well it's sort of the same thing as an
42:16 - if statement it looks for a condition
42:18 - being true so we could say you know
42:21 - while
42:23 - or
42:24 - while X is say less than 10
42:29 - we could go
42:30 - X plus equals one and we would just
42:35 - maybe declare X since it doesn't exist
42:37 - yet let's say Lex or let X and then we
42:41 - would say maybe an integer say being
42:44 - into eight
42:45 - uh and eight equals zero
42:49 - uh must be mutable so we have to change
42:52 - that to VAR good catch
42:56 - uh while X is less than 10 we would do
42:59 - this and then just to you know make sure
43:01 - it's working properly but just print out
43:02 - X if I run that
43:05 - uh it'll print out I just oh
43:10 - it would print out one through ten so
43:12 - it'll start at zero it'll add one two x
43:14 - so plus equals you could also do you
43:17 - know minus equals or multiply equals or
43:20 - divide equals
43:21 - uh
43:23 - we're just going to do plus equals for
43:25 - this instance and
43:27 - that'll essentially just add one to this
43:29 - current value here so it'll add One X
43:31 - will become one then it'll print at X
43:33 - and then we see that's why we see the
43:34 - one first so it looks for until this
43:37 - condition is met until or while X is
43:41 - less than 10 once it becomes equal to 10
43:43 - then we stop so
43:45 - uh X is therefore equal to 10 then we do
43:48 - this last editor and then it cuts off
43:51 - and then also what you could do is
43:54 - you could just put it true in here and
43:56 - then go
43:57 - uh you put a little if statement inside
43:59 - of it saying you know if x
44:02 - if x is
44:05 - say greater than or equal to 10.
44:08 - we would break
44:09 - so what does break do break is
44:11 - essentially like extremely simple it'll
44:13 - just stop the loop so if you put break
44:16 - inside of any Loop it'll just stop it
44:18 - and we can actually print this out over
44:21 - time so we go
44:23 - print X
44:25 - and we would get the same behavior so
44:28 - Loops are a little bit more complex but
44:30 - that's essentially what you have is you
44:32 - have your for loops and your while loops
44:34 - so I'm actually going to show a little
44:38 - like array I guess thing you could say
44:40 - with loops and all we're going to do is
44:43 - we're going to let X
44:44 - we're going to make it equal a python
44:46 - object
44:47 - so in order to do that we're going to
44:49 - need to actually import python up here
44:51 - so from python
44:54 - import python object
44:58 - and we're going to set this equal to say
45:01 - an array so we go 2 4
45:04 - 6 8 10. an array is just a list of
45:08 - numbers wrapped in square brackets and
45:10 - then each of these numbers here is
45:13 - assigned to an index so 2 would be index
45:17 - 0. everything starts at zero in arrays
45:19 - so
45:20 - to be at index 0 4 would be at the next
45:23 - one
45:24 - six would be at index two eight would be
45:27 - uh three and then ten would be four so
45:29 - if we were to
45:30 - say you know print X at position three
45:36 - uh oh
45:43 - why are we getting this cannot call
45:45 - function that would raise okay so
45:49 - we're gonna have to add braces in here
45:50 - again ignore the raises for now but uh
45:54 - essentially this this is a python array
45:57 - and we're just printing out the third
45:58 - index of it so zero one two three
46:01 - zero one two three
46:05 - and then it a three is equal to eight so
46:07 - we get eight the third index is eight so
46:09 - we get eight sorry
46:11 - um so that's what that's what arrays
46:12 - look like and we can iterate over these
46:14 - using a for Loop because we go four I in
46:18 - range and then we could just say
46:21 - I'm going to say 4i in X for example
46:24 - because X is actually the array itself
46:26 - so we go 4i and x and then just print
46:29 - out I
46:33 - oh
46:37 - I guess we can't do that we can maybe go
46:39 - range and then
46:42 - length go
46:45 - x dot underscore
46:49 - length and then under Splinter score
46:54 - maybe that'll work
46:57 - okay yeah
46:59 - so we could go uh X at position I
47:05 - and then we would be able to print all
47:07 - those out don't worry about this too
47:08 - much this is just me taking some Python
47:11 - and transferring it over to Mojo this
47:14 - little length thing this Len uh is just
47:17 - a short short form for length and then
47:19 - you put these around it because that's
47:21 - the that's the method that it calls but
47:23 - don't worry about this at all this is
47:25 - just porting some python stuff over to
47:28 - Mojo and it it's still being like mostly
47:30 - python so
47:31 - don't worry about this at all this is
47:33 - like not part of the course this is just
47:35 - me playing around with stuff
47:36 - but anyways
47:38 - now we can actually jump into functions
47:41 - so you might be wondering about
47:42 - functions and if you've done Python
47:44 - Programming before you've probably seen
47:46 - this def uh this def function so for
47:49 - example def add numbers you pass in two
47:51 - function arguments uh A and B
47:54 - you let c equal to and that the sum of A
47:58 - and B and then you return whatever C is
47:59 - so if a were to equal 2 and B would
48:01 - equal five you would say uh C is equal
48:05 - to a which is 2 and B which is five so C
48:07 - would be seven and then you would return
48:09 - seven which is C
48:11 - so uh that's what python functions or
48:14 - defs look like and in Mojo they're
48:17 - actually quite close so be an FN short
48:20 - for function and then you would put
48:22 - whatever your function name is you would
48:24 - wrap it in these round brackets
48:27 - you would pass in your function
48:28 - arguments and we'll go over these in a
48:31 - second here and how you can put function
48:33 - arguments into it from like actually
48:35 - calling the function uh and then you
48:37 - would put whatever you're going to
48:39 - return inside of uh like outside of
48:41 - these uh round brackets so you put an
48:44 - arrow and then whatever The Returned
48:46 - data type should be
48:47 - so in this example we go you know let c
48:51 - equal to uh
48:54 - an integer and that's equal to a plus b
48:58 - assuming these are both integers from
49:00 - here
49:01 - and then we would return C which would
49:03 - be again an integer because that's what
49:05 - the specified data type was and then
49:07 - since we know it integer we would return
49:09 - as an integer data type so
49:12 - sort of a that's that's the main
49:13 - difference between Mojo and python is uh
49:16 - FNS or FN functions are more explicit
49:19 - whereas defs are less explicit and they
49:21 - would take a little bit more time
49:22 - because
49:24 - um that computer actually has to like
49:25 - understand what you're doing rather than
49:26 - just having you know the rules just like
49:28 - hard to find and just like full steam
49:30 - ahead
49:31 - so
49:32 - that's kind of the difference there and
49:35 - uh so what we could do is actually go
49:37 - ahead and call this function so I'm
49:39 - going to go FN Main
49:43 - well passion no function arguments in
49:45 - here and I'll just go
49:48 - add numbers same
49:51 - let's
49:52 - X will that be an INT
49:56 - we'll say add numbers and we'll go ahead
49:58 - and pass in
50:00 - say two and five
50:03 - and then if we were to go ahead and
50:05 - print out what x is
50:08 - we should get seven just like that so
50:12 - let's actually walk through step by step
50:14 - what's happening here because to an inch
50:16 - like
50:17 - newer programmers this might be actually
50:19 - quite scary to look at
50:21 - so the reason we put add numbers above
50:24 - here actually if I were to put it below
50:25 - you might see that
50:27 - uh does it still work I should actually
50:30 - double check that okay I guess it does
50:32 - still work so you can have your
50:34 - functions in any order top or bottom and
50:36 - Mojo will be aware of where they are so
50:38 - you won't need to have something above
50:40 - it for Mojo to recognize that it exists
50:43 - um we'll just go ahead and put it back
50:44 - there though because that looks better
50:46 - so you have this you have this function
50:50 - add numbers you have a parameter a which
50:53 - is an integer type it just defaults to
50:55 - N64 because we don't tell it how many
50:58 - bits to occupy
51:00 - and then you have a b as well which is
51:03 - also an INT we say that this this
51:05 - function is going to return an integer
51:07 - type or an N64 type
51:10 - and we say let's see let C be an integer
51:14 - data type
51:15 - meaning this is a constant
51:17 - C is a constant integer 64 and it's
51:20 - going to be equal to whatever the
51:22 - integer A and B are equal to and then we
51:25 - would return C whatever the value is
51:27 - that's what you would return from the
51:28 - function so you call a function it does
51:31 - some operations and then the function
51:32 - returns a value to its caller so the
51:35 - caller in this case would be in our F
51:38 - and it would be on our main function so
51:40 - this add numbers is the caller here we
51:42 - pass in two integers two and five
51:46 - we make sure that this is a constant X
51:49 - integer 64.
51:50 - uh
51:52 - and
51:54 - then we would we would essentially just
51:56 - have the output of that so X would be
51:58 - equal to whatever this function returns
52:00 - which would be seven and then we could
52:02 - just print that out so
52:04 - that's essentially how functions work on
52:07 - the explicit level when you're explicit
52:09 - about what variables you're using then
52:12 - that's how that works so we could
52:13 - actually like replace all these ins with
52:15 - int 8.
52:21 - and then here as well you could go int 8
52:24 - and everything be the same we're going
52:27 - to jump into a concept called object
52:29 - oriented programming so object oriented
52:32 - programming is concerned with these
52:33 - things called objects or classes or
52:35 - structs whatever they happen to be
52:38 - called in the programming language
52:40 - and
52:42 - anyways I I'm not going to philosophize
52:44 - about it I'm just going to jump right
52:45 - into it so
52:47 - uh the best way to really compare this
52:50 - is to look at what do they look like in
52:52 - Python and what do they look like in
52:53 - Mojo so I'm going to create a new file
52:55 - called main.py and this is what an
52:59 - object would look like in Python so just
53:02 - clear this drag it down
53:04 - so what's happening here
53:07 - we have a class called a banana
53:11 - um
53:13 - actually I'm not going to go through the
53:15 - class first so initially we have if name
53:18 - equals main it'll essentially just run
53:20 - this main function just it's just it's
53:23 - the way that Mojo works when you call
53:24 - this main by default it's the same thing
53:26 - going on here it just calls the main by
53:29 - default
53:30 - so this this main function is going to
53:33 - create a banana instance it's going to
53:36 - pass in a a bunch of arguments here and
53:40 - then we're going to print some attribute
53:41 - about this banana so what does this
53:43 - banana look like
53:44 - well
53:45 - we have an init so in it it you could
53:48 - think of it as a Constructor it makes it
53:50 - actually initializes the banana clasp
53:54 - so
53:56 - what are we actually passing in here
53:57 - well we have self is required we have a
54:02 - ripe attribute
54:03 - which would be Boolean so true or false
54:06 - a length which would be a float in
54:08 - Python
54:09 - and a color so a string and these are
54:12 - these are just things that I picked out
54:14 - sweet
54:15 - ripe could be like you know a floating
54:17 - Point number if you want to put on a
54:19 - scale for example but these are this is
54:21 - just what I'm working with
54:23 - um
54:24 - so in the in your init or in your
54:26 - Constructor you would say uh self you
54:29 - would say self Dot and then all the
54:31 - attributes for example self.ripe would
54:33 - be equal to this this ripe argument
54:36 - self.length these are just the variables
54:39 - of the actual class itself that's what
54:41 - the self dot whatever it looks like
54:44 - and then you have length and color
54:47 - so these are all the variables that
54:49 - we're initializing for our Banana class
54:51 - and then if we were to
54:54 - say call The Ripe attribute on
54:57 - on banana
54:59 - like we do here
55:01 - it would essentially just return
55:02 - whatever ripe is so we have a def ripe
55:07 - um
55:08 - we pass in self as a function as a
55:10 - function argument because it's a def
55:12 - it's a def function
55:13 - and then we're returning the Bool value
55:16 - so
55:18 - we return self.ripe which happens to be
55:20 - a Bool so we return Bool here
55:23 - uh
55:24 - and then we also have say a length as
55:27 - well I'm actually going to add the color
55:29 - in because I didn't add that in yet so
55:30 - we go uh def go color
55:35 - self and then we would return color
55:37 - which is a string so go Str
55:41 - and then we go return self dot color
55:45 - awesome
55:46 - if I were to print you know banana which
55:49 - is our we've created an instance of this
55:52 - object so you can have as many objects
55:54 - as you want
55:55 - and they have a bunch of different
55:57 - attributes and you can just call those
55:59 - attributes
56:00 - um
56:01 - so we go banana dot open out dot save
56:04 - like color for example
56:06 - and we would just go python3 main.py
56:10 - it's going to print out banana.ripe
56:13 - which is false as we passed in and then
56:17 - yellow because the typically the color
56:19 - of bananas are yellow I don't know what
56:21 - type bananas you eat maybe you eat red
56:23 - bananas but
56:25 - uh anyways that's that all works out
56:28 - nice and smoothly so uh if you want like
56:31 - feel free to pause the video and just
56:33 - try to like conceptually make sense of
56:35 - what this class looks like because these
56:37 - are very important classes and objects
56:39 - and structs are essentially the basis of
56:42 - all languages
56:43 - except for languages like C which don't
56:45 - have them but uh so in in Python this is
56:50 - what your object would look like and
56:51 - this is just a banana object for example
56:53 - so now we're going to jump over to what
56:56 - does this look like in Mojo So let's
56:58 - compare this side by side here so in
57:01 - Python we have a class banana in Mojo we
57:03 - have a struck banana
57:05 - in Python we initialize our variables
57:07 - with an init method uh self and a bunch
57:10 - of arguments in here with their
57:12 - corresponding data types and then here
57:14 - we initialize our variables with self
57:17 - Dot and then whatever the variable is
57:19 - equals whatever the parameter goes
57:21 - passed in there
57:22 - you could also do like lowercase that's
57:24 - fine too but I just find uppercase to be
57:27 - more consistent and it's like easier to
57:28 - read
57:29 - especially for classes I I don't know
57:33 - some people like to do it differently
57:34 - but that's just what I'm doing in this
57:35 - case
57:36 - so in Mojo you would actually Define
57:39 - your variables here you would say you
57:41 - know what the variable name is and you
57:43 - would say what data type it is you don't
57:44 - have to declare uh really what it's
57:48 - equal to but just that it exists it has
57:50 - a name and what data type it has
57:53 - and then you would have your init method
57:55 - here as well I'll go into this in out
57:57 - little piece here in a little bit but
57:59 - this is not in the basics of the chords
58:02 - this is a little bit after
58:04 - so uh you you get the idea it's sort of
58:07 - the same arguments in here uh you have
58:09 - yourself ripe length color
58:11 - uh self-ripe length color
58:14 - uh awesome and then they're declared
58:16 - literally the same way as python in this
58:17 - like this block of code is equal to the
58:20 - same as this block of code
58:22 - um
58:23 - and then for our little methods here so
58:25 - you have or rather functions inside of
58:27 - the class
58:28 - you have a you have your FNS instead of
58:31 - defs
58:32 - ripe and then you would pass itself
58:35 - because that's self is essentially the
58:38 - object itself so self is needed in
58:41 - objects and then we say rhs because rhs
58:46 - is equal to right hand side and this is
58:47 - on the right hand side just it's just
58:49 - kind of a common practice you could say
58:51 - like value or or something else but it's
58:55 - commonly just seen as like rhs that's
58:57 - that's typically what it ends up being
59:00 - someone in in our death ripe we pass in
59:03 - a self and we return a pool uh
59:06 - and then we actually return the bull
59:08 - here so this is like what type we're
59:09 - going to be returning and then we return
59:12 - the actual ripe
59:14 - um
59:15 - variable if you will
59:18 - here we'd we also have this right hand
59:21 - side so we we pass in uh the banana
59:24 - itself and then we say
59:27 - we're gonna return a bull type and then
59:30 - we return this this ripe which is up
59:32 - we'll type hence returning pool here
59:35 - uh and then it's just kind of the same
59:37 - same thing it's a pattern for the rest
59:38 - of it so as long as this one makes sense
59:42 - as long as this init method makes sense
59:44 - and these variables make sense
59:47 - everything else below here should as
59:49 - well and in order to actually create an
59:53 - instance of this banana yes you can
59:55 - create multiple instances
59:57 - you would essentially just give it a
59:59 - variable you say VAR or let a banana
60:01 - equals and you would call this struct
60:03 - and you would pass in what variables or
60:06 - what arguments are required so you have
60:09 - a ripe which is a bull so we'll just say
60:11 - false let's say the banana isn't ripe
60:15 - um
60:16 - and we give it a length maybe it's 4.7
60:18 - centimeters long the float 32. and then
60:21 - yellow which is a string so we have a
60:24 - banana that isn't ripe 4.7 centimeters
60:27 - long and is yellow
60:29 - so cool that's how you create an
60:32 - instance so you can actually go like you
60:34 - know for our
60:39 - I can't type banana two and then you
60:41 - would just you would you would
60:43 - essentially call this banana struct and
60:45 - you would pass in whatever arguments are
60:47 - required so
60:48 - hopefully that all makes sense and if we
60:51 - want it to say return the ripeness of
60:53 - this particular banana instance
60:55 - then
60:56 - you would just go called banana dot ripe
61:00 - so this particular banana then you would
61:03 - call The Ripe function on it the right
61:05 - method
61:06 - and you would pass in banana to it so
61:09 - this would ultimately return
61:11 - uh
61:15 - oh let me try this up
61:17 - banana was declared as a VAR but was
61:19 - never mutated consider switching to a
61:21 - lead so it's just giving us a warning
61:22 - and saying oh you're never really
61:24 - changing this instance so you may as
61:26 - well just set it to a constant because
61:28 - variable is
61:30 - is a mutable or not constant so we could
61:32 - save let and that would resolve that
61:35 - warning
61:36 - so awesome
61:37 - we return banana.ripe and we get false
61:41 - so cool that's what objects look like in
61:44 - Mojo versus python so hopefully that
61:47 - hopefully that is super clear now if
61:50 - something didn't make sense totally feel
61:52 - free to uh pause the video look back
61:54 - play it on half speed even chat gbt your
61:57 - way through it because that's honestly
61:58 - how a lot of people learn nowadays and
62:01 - it is a pretty good way to learn as to
62:03 - at least with these basic concepts is to
62:06 - just plug it into gpd4 and say hey I
62:08 - don't understand this or if you you have
62:10 - a particular question about maybe the
62:12 - init method like why is it called why
62:14 - does it have two of these underscores
62:15 - around it right
62:17 - you could pass that into chat CPT and
62:19 - say hey why why is this why is this a
62:21 - thing and then I would hopefully be able
62:23 - to help you but as for Mojo specifically
62:26 - uh
62:28 - chat gbt isn't really trained on it
62:30 - because its cut off was 2021 so your
62:32 - best bet would just be to go to the
62:34 - Kappa AI in the modular Discord and just
62:37 - ask it that way
62:39 - so that's what I would recommend if you
62:41 - don't understand something is to just
62:42 - ask the Kappa AI
62:45 - um anyways let's move on so before we
62:48 - actually jump into importing libraries
62:50 - modules just other people's code in
62:52 - general uh I should let you guys know
62:54 - that inheritance uh inheritance exists
62:58 - in Python
62:59 - uh essentially if you don't know what
63:01 - inheritance is essentially it's imagine
63:04 - you have a a class and it's an animal
63:07 - you have an animal class and you have
63:10 - like a dog cat or a dog class and maybe
63:12 - a cat class maybe a giraffe class okay
63:14 - you have a bunch of animals
63:16 - and then you have this one main animal
63:18 - class so typically what you would do is
63:20 - instead of writing all of the dog cat
63:22 - and maybe giraffe classes from scratch
63:24 - you would inherit some of the attributes
63:27 - from the animal class so you'd have some
63:29 - like General variables and
63:32 - some general things to find in the
63:34 - animal class and then you would inherit
63:36 - those uh in the uh in those other
63:41 - animal classes so like the dog cat and
63:43 - giraffe so that way you wouldn't have to
63:45 - write a bunch of code that way so you
63:47 - would just inherit and it would be less
63:49 - work for you and essentially this is
63:51 - actually how a lot of games work so if
63:53 - you have like you know different enemies
63:55 - uh typically you would have like an
63:57 - enemy class and the enemy would have
64:00 - some attributes like when you touch it
64:01 - or when you get hit by it then you take
64:04 - damage or
64:05 - you can do damage to it
64:07 - or they you know they they only spawn in
64:10 - uh danger zones or whatever it is and
64:14 - you would have you know a bunch of
64:16 - subclasses that inherit from that
64:17 - initial enemy class that would say oh
64:19 - these are some things that are
64:20 - describing uh each different unique
64:22 - enemy but it also has these General
64:25 - attributes that all enemies have
64:27 - so that's just what inheritance is and a
64:30 - general overview but it does not exist
64:32 - in Mojo yet unfortunately so we are able
64:35 - to create classes like these and pass in
64:37 - attributes to them but we cannot
64:39 - actually use inheritance we cannot
64:41 - inherit from other classes yet in Mojo
64:43 - that does not exist so anyways let me
64:47 - get rid of this here and we can actually
64:50 - begin to import some libraries we're
64:53 - just going to import one
64:54 - so we're going to import from python a
64:57 - lot of the libraries here we're going to
64:58 - just import them from python so we could
65:00 - go
65:01 - from python
65:04 - uh oh not capital I import
65:09 - python just like that
65:11 - and then we record an uh F and Main and
65:15 - we would need raises here and I figure
65:17 - this is a good time to tell you exactly
65:19 - what raises does so raises essentially
65:23 - you need to include it in functions that
65:25 - could potentially raise errors so if you
65:28 - were importing a library from python say
65:30 - like numpy for example uh some of you
65:32 - might be familiar with numpy and
65:35 - sometimes you might get errors importing
65:38 - that or at least you might get little
65:39 - underlined saying oh what if this messes
65:41 - up what if the library doesn't exist but
65:43 - we're still trying to import it well
65:45 - then you would just say you know the
65:46 - function raises what raises means
65:48 - because it can raise an error the
65:50 - function is capable of raising its own
65:53 - error aside of Just The Interpreter and
65:56 - compiler so uh this is just super useful
66:00 - I'm going to go more into depth into
66:02 - raises and all of these errors and
66:04 - exception handling a little bit later on
66:06 - but essentially it's just to say we
66:09 - might get errored out but don't worry
66:11 - about it too much because we're sort of
66:14 - expecting it in a way
66:16 - um
66:19 - so we can go ahead and uh
66:22 - you could just create we could just
66:23 - import numpy here so we go let's numpy
66:26 - and then oh not that python
66:31 - import module and instead of built-ins
66:33 - like we did before we can go uh numpy
66:37 - just like that and then we can
66:40 - essentially create arrays with numpy so
66:42 - we go let's array ARR for short for
66:45 - array numpy Dot
66:47 - array and then we would put our array in
66:50 - it so maybe you know one four nine
66:54 - 16. a bunch of squared numbers
66:57 - uh and then we could just
67:00 - say print
67:05 - square roots
67:07 - uh
67:08 - now we don't have to do that we could
67:10 - just say
67:11 - print array
67:13 - times two
67:14 - and then we're just going to Mojo Main
67:17 - dot Mojo
67:18 - and
67:20 - 1 times 2 2 4 times 2 is 8. 9 times 2 is
67:24 - 18. 16 times 2 is 32. so we actually get
67:28 - that returned in the numpy array form so
67:30 - that's essentially just how you import
67:33 - modules in libraries as you would you
67:35 - would do from whatever and then import a
67:38 - certain you know sub object or whatever
67:41 - and it's it's very similar to python as
67:44 - a matter of fact it's like the syntax is
67:46 - the exact same except your the libraries
67:48 - just look different when you're
67:49 - importing them
67:50 - uh and then to actually import it from
67:52 - python you would do this python.import
67:55 - module and then whatever it's called so
67:57 - if you're going to import tensorflow you
67:59 - would put
68:00 - you would put tensorflow here
68:02 - if you were to put numpy you would do
68:04 - just as we did before and Etc
68:06 - so uh later on in the course I'm
68:09 - actually going to show you how to create
68:10 - your own packages so uh so instead of
68:13 - just importing them from somewhere else
68:15 - on the Internet or somewhere else that's
68:17 - like downloaded a part of your mojo but
68:19 - you didn't create it
68:22 - I'm going to show you how to create once
68:23 - and then use them so that's a cool
68:25 - little feature that modular has been uh
68:29 - super you know easy going about I guess
68:32 - it's it's just really easy to make your
68:34 - own packages in this language and in
68:36 - this whole modular framework thing so
68:38 - I'm going to show you how to do that a
68:40 - little bit later but for now let's just
68:43 - jump a little bit more into what exactly
68:46 - does raises do so in Mojo we use four
68:50 - error four words for error handling so
68:53 - as you've seen before we use raises and
68:55 - raises is
68:57 - uh essentially in any function that may
69:01 - raise an error needs to be explicitly
69:02 - marked with this as we went over before
69:04 - it's part of Mojo's error handling
69:07 - semantics uh so oftentimes you're going
69:10 - to use this when you're importing other
69:11 - libraries because it may or may not work
69:13 - right you may have an error there
69:16 - um but most of your errors will be
69:18 - raised automatically by the compiler and
69:20 - interpreter so don't go like out of your
69:22 - way to just include raises in every
69:24 - single function if if you are getting
69:26 - little underlines like red underlines
69:28 - like errors uh just try to include
69:31 - raises and then see if that changes
69:33 - anything but you shouldn't need to
69:35 - explicitly include raises in every
69:36 - single function
69:39 - um so that that's what raises does you
69:41 - put that after the round brackets of a
69:43 - function to essentially say this might
69:45 - raise an error
69:47 - um and then this try try accept and
69:49 - finally all go together
69:51 - so I'm actually going to paste in
69:54 - some code here that I've gotten from
69:57 - before so we have a function main raises
70:02 - so it might may or may not raise an
70:03 - error and we just explicitly declare
70:06 - that
70:07 - and then we have this try so what does
70:09 - try do
70:10 - try will attempt to run some code
70:13 - for example open a file so let's say we
70:16 - have some input.txt file over here and
70:18 - we're trying to open it and maybe like
70:19 - read the contents inside what try will
70:22 - do is it'll maybe we'll try to open that
70:25 - open that file we'll try to open it
70:27 - we'll create like a new resource for
70:30 - example and then open that file with the
70:31 - resource
70:32 - and then accept will
70:35 - look for an error say a file encoding
70:38 - issue say our file is like has some
70:40 - corrupt data in it the encoding is messy
70:43 - for example uh and accept will
70:46 - essentially just catch that error and
70:47 - say hey uh we found something and then
70:51 - here's a little error reporting on what
70:53 - it was about if this code fails so it'll
70:56 - attempt to run it if it's successful
70:57 - it'll just go all the way through in
71:00 - this except block will not be triggered
71:02 - but if there is an error then
71:05 - this will still finish
71:08 - and we'll get a we'll get an A little uh
71:11 - what we can essentially raise an error
71:13 - so we can do raise instead of raises
71:16 - we just do raise and then error because
71:18 - we're raising an error right it kind of
71:20 - converts to English easily that way
71:22 - uh and then you would just in round
71:24 - brackets put whatever your error
71:26 - reporting is so you have an error number
71:28 - you would go like
71:31 - error number one zero three nine or or
71:34 - whatever you do
71:36 - um
71:39 - awesome
71:40 - and then this finally is very important
71:44 - in some cases not as important in other
71:46 - cases but
71:48 - I'm just going to use an analogy for
71:49 - this
71:50 - so imagine you're trying to say
71:53 - uh open you're you're trying to open a
71:56 - microphone resource here so this
71:58 - microphone that I have right here let's
72:00 - say I want to just use it with like Mojo
72:03 - or something even though it's not
72:04 - supported yet
72:06 - um
72:06 - imagine we're trying to open this
72:08 - microphone and we're trying to record
72:09 - something so we attempt we attempt to
72:12 - open the microphone resource and then
72:14 - say we get an error with like maybe
72:16 - there's something wrong with the
72:17 - microphone who knows
72:19 - um so we get an error it says
72:21 - something's wrong with your microphone
72:22 - fix it
72:24 - but what this finally does is instead of
72:27 - just stopping at this error and then
72:29 - terminating the code finally we'll
72:32 - instead uh still follow through whatever
72:35 - is inside of it whatever this indented
72:37 - code is inside of the finally block
72:40 - so
72:41 - if we were opening a microphone we
72:43 - probably don't just want to leave it
72:44 - hanging we probably don't just want to
72:46 - have it you know go on forever and just
72:48 - essentially leak the microphone right we
72:51 - don't want to be leaking that resource
72:52 - at least to other errors that you don't
72:53 - want to deal with
72:55 - and essentially finally just says I got
72:58 - you covered man we're gonna
73:00 - we're gonna take care of that so
73:02 - typically and finally you would just
73:04 - essentially close that resource so
73:07 - we oh we attempt to open a resource we
73:09 - say it fails instead of stopping there
73:12 - we stead we instead guarantee finally
73:15 - guarantees that we actually follow
73:17 - through with whatever this code is and
73:19 - there we could close the file instead of
73:21 - having memory leaks or resource leaks so
73:24 - finally is really useful there if you're
73:26 - taking advantage of resources but if
73:28 - you're just trying to you know attempt
73:30 - some block of code and then you see if
73:32 - you get an error see if it faults then
73:34 - you wouldn't really need to finally
73:36 - block for that finally it would just be
73:38 - you know when you need to run something
73:40 - even though there's an error that
73:41 - happens
73:43 - so that's kind of how that works that's
73:45 - that's pretty cool uh very good for
73:48 - debugging of course if you're trying to
73:50 - if you if you think your error is in you
73:52 - know some piece of code then you would
73:53 - put try around it and then if it errors
73:55 - out be like oh so that there's some like
73:57 - specific thing wrong with my code it's
73:59 - in that section and then you can debug
74:00 - further
74:02 - um
74:03 - but yeah if we were to Instead try to
74:06 - close the file after it errors out if we
74:08 - were to Instead try to close it down
74:10 - here
74:11 - uh that wouldn't work because this code
74:13 - isn't guaranteed to run once you uh once
74:17 - you post it once you raise this error
74:19 - uh essentially nothing else other than
74:22 - finally is allowed to execute code so
74:24 - you raise this error and then
74:26 - immediately it says we have an error we
74:28 - cannot execute whatever this is but
74:30 - finally says we're guaranteed to execute
74:32 - this no matter what so hopefully that
74:35 - clarifies the whole uh error handling
74:37 - exception thing uh
74:40 - what we're going to do now is we're
74:42 - going to go ahead and move on to some of
74:44 - these function arguments like in outs
74:46 - and some other ones that you may or may
74:48 - not have seen before so what the heck
74:50 - are these function arguments you speak
74:51 - of well function arguments could be one
74:56 - of many there's like quite a few I'm
74:58 - meaning like three or four in this
74:59 - language
75:00 - and the first one I'm going to cover is
75:02 - called in out
75:03 - so what this means we we already went
75:06 - over function so I'm not going to go
75:07 - over that again but essentially when you
75:10 - mark a function argument within out it
75:12 - means that that argument is mutable or
75:16 - changeable
75:17 - and changes made inside of the function
75:20 - so meaning changes made to for example a
75:23 - we pass it in as a equals 4 and then
75:27 - we mark it with n Out
75:31 - um and we change it to three then that
75:34 - change would also be visible to
75:35 - everything outside the function so I
75:37 - highlight the words inside and outside
75:39 - because that's what in out comes from in
75:44 - and out changes made inside the function
75:46 - are visible outside and out
75:49 - and then the next one is called borrowed
75:53 - so let me go ahead and copy I've
75:56 - borrowed code in here
75:58 - not really borrowed I created it but we
76:01 - use this label or called borrowed and
76:04 - this essentially just labels these
76:06 - explicitly immutable meaning you cannot
76:09 - change them so if we were to say to Mojo
76:14 - Main dot Mojo
76:16 - um
76:17 - we initialize a a and b so we have a
76:20 - four and a five we call add nums on
76:22 - those uh
76:25 - and let's say we were to try to change
76:27 - it to
76:28 - uh let's see if we're to change you know
76:31 - a equals three and then b equals two
76:34 - well why are we getting underlines
76:36 - expression must be mutable in assignment
76:38 - okay
76:40 - so what if we change it to
76:42 - in out for example
76:47 - and out
76:50 - because argument zero must be mutable in
76:52 - order so argument zero is essentially
76:54 - the first one it's catching the error on
76:55 - the first little function argument here
76:58 - uh
76:59 - in order to essentially run our code so
77:02 - uh notice that we've declared with let
77:05 - so if we change this to VAR
77:08 - then
77:10 - everything works so we set a to 3 and b
77:12 - to 2 we get five
77:14 - um
77:15 - but if we were to say set these two
77:18 - borrowed
77:23 - then this wouldn't work because these
77:25 - these initially are variable meaning
77:27 - they can change they are mutable and
77:30 - then we explicitly label them as
77:31 - immutable meaning you cannot change them
77:33 - and inside of the function
77:36 - so
77:37 - Express expression must be mutable in
77:39 - assignment so essentially that's what
77:41 - borrow does it says this belongs to the
77:45 - other function and we're not allowed to
77:46 - change it even if in the other function
77:48 - you say that it's a VAR or variable
77:51 - um
77:52 - so yeah that's that's uh in out and
77:56 - borrowed for you and the next one I'd
77:57 - like to cover
77:59 - is
78:00 - uh owned owned is an interesting one
78:03 - Owen will essentially say with with
78:05 - whatever variables we've labeled here
78:07 - that those variables now belong to this
78:10 - current function so for example even
78:12 - though we uh initialized uh these
78:15 - variables as immutable using the let
78:18 - declaration
78:20 - uh when we pass them into here using
78:23 - owned it says okay now this function
78:26 - owns them so we can do whatever we want
78:28 - so this essentially takes off that
78:30 - little immutability feature and says we
78:34 - can do whatever we want to them and if I
78:36 - go ahead and run this code
78:37 - uh you'll see that so now these actually
78:40 - belong to this function and they are now
78:42 - mutable
78:43 - so uh if I were to say you know
78:47 - something else like
78:48 - if borrowed
78:51 - then that wouldn't work because we're
78:53 - taking it we're taking it from this
78:56 - function here
78:57 - if I were to even go
79:01 - like that it would say
79:03 - expression must be mutable because we're
79:05 - initializing it as let over here which
79:08 - is immutable
79:09 - we're trying to change it even though it
79:11 - cannot be changed so essentially own
79:13 - says
79:15 - um
79:17 - it's just explicitly saying that this
79:20 - this current function which owned is in
79:21 - uh we can do whatever we want with that
79:24 - variable this function now owns it
79:26 - so the next statement that I want to
79:27 - cover is called with so the with
79:29 - statement you may have seen this in
79:30 - Python before but like especially in
79:33 - Python width is typically used to open a
79:36 - file so in Python you would go
79:39 - um so with open here we go input.txt and
79:45 - you would go
79:47 - right
79:49 - or read sorry and then as F you would go
79:53 - say text equals F dot read
79:57 - and then we would print out some text
79:59 - if I were to create an input.txt
80:03 - say
80:05 - you know peekaboo
80:08 - maybe we go in
80:09 - run this main file and it would open
80:13 - this in read mode as F or file and we
80:16 - would read the file put that in a
80:18 - variable and then print that variable
80:20 - out
80:21 - so essentially What's Happening Here is
80:23 - with is acquiring a resource meaning
80:26 - files right we're acquiring a file read
80:29 - maybe a write resource
80:31 - and we want to make sure that after
80:34 - we're done with the resource that we
80:35 - dump it so we're going to open it we're
80:37 - going to use we're going to use some
80:40 - file reading and writing resource we're
80:42 - going to do some code we're going to do
80:43 - something with it and then we're going
80:44 - to close the resource afterwards
80:47 - um this isn't this isn't too common with
80:50 - Mojo yet it doesn't really doesn't
80:52 - really exist doesn't there's essentially
80:55 - nothing you can really do with it right
80:56 - now
80:58 - um so I'm not going to worry about that
81:00 - at all you might be asking what is the
81:03 - difference between with and like a try
81:05 - except finally block
81:07 - well the thing is is that with
81:09 - uh by default isn't really going to
81:13 - uh run some code no matter what so
81:17 - typically in the try except finally you
81:20 - would attempt some code you would
81:22 - potentially throw an error and then you
81:24 - wouldn't do some stuff after so
81:28 - um I'm not my awareness of the whole
81:29 - with statement isn't like too in-depth
81:32 - but uh I know there's there's definitely
81:35 - some differences there in terms of how
81:38 - it compares to try except finally versus
81:40 - just with so you could actually look
81:43 - into that on your free time but we're
81:45 - not really going to be using with in
81:46 - this course at all so don't worry about
81:48 - it
81:49 - so next up I want to cover something
81:51 - called variable scope so in Mojo you
81:55 - would typically see like you know let's
81:57 - say x equals three and then you have a
81:59 - FN Main
82:00 - and you would say maybe y equals say let
82:03 - y equals four
82:06 - so
82:07 - this is a concern with something called
82:08 - variable scope so variable scope is like
82:11 - you just have a variable and then what
82:13 - is the scope of it so this one would be
82:16 - file scope since it's in the file
82:18 - everything else in the file can access
82:20 - it if we were to go ahead and print X we
82:23 - would get uh
82:26 - we will get an output there so we this
82:28 - uh this is included in all the functions
82:31 - so all the functions can access like
82:33 - file scope or interchangeably
82:36 - Global variables file scope and
82:39 - Global scope variables are pretty much
82:41 - the same thing
82:43 - and
82:44 - whereas this let y would be specifically
82:47 - in the function so if I tried to
82:50 - uh
82:51 - you know if I had a different function
82:53 - to
82:55 - I don't know who I would show this but
82:58 - essentially this is
83:00 - specifically only accessible to this
83:04 - function only so there can't be any
83:07 - other functions that can access y so if
83:10 - I if I said
83:11 - um
83:13 - if we had another function say
83:16 - FN
83:19 - print y
83:20 - uh
83:22 - and then I work to
83:24 - you know say
83:28 - print y we return that
83:34 - uh come on let me just keep that
83:40 - all right move this up
83:42 - and then
83:43 - we were to say
83:46 - Maybe
83:47 - print y will return
83:49 - whatever Y is whatever Y is equal to so
83:52 - it'll say unknown Declaration of Y uh
83:55 - require explicit variable so essentially
83:58 - saying that y cannot access this y
84:01 - because this Y is specifically in the
84:04 - main function so therefore other
84:06 - functions cannot access it so this is
84:07 - what we call local scope
84:10 - so local scope just means it's like
84:12 - defined to a specific function or a
84:14 - specific struct or something
84:17 - um and that's essentially what variable
84:19 - variable scope is so if you've worked
84:21 - with python before you've probably
84:22 - experienced some errors with variable
84:24 - scope
84:25 - um but anyways that's just essentially
84:28 - saying you can't make a variable in a
84:30 - function and then call it in another
84:32 - function without like passing in the
84:34 - argument of it so
84:35 - that's what that is
84:37 - now let's move on to some of the tools
84:40 - with the Mojo Mojo command line
84:43 - interface or the Mojo CLI
84:46 - so if you pop over to the Mojo modular
84:49 - documentation here and just scroll down
84:51 - to the Mojo CLI and go to yep you could
84:55 - just essentially click on maybe just
84:57 - click on Mojo
84:59 - and you'll see that essentially this
85:02 - Mojo thing is actually a command line
85:04 - interface in and of itself so we've seen
85:06 - that we can call Mojo files or we can
85:08 - run Mojo files with just the Mojo
85:10 - keyword and then pass in whatever file
85:12 - you're running very similar to python
85:15 - you can use modular to of course update
85:18 - Mojo but modular is not really the focus
85:21 - of this it's more like Mojo command uh
85:23 - commands
85:25 - so Mojo run
85:28 - built and executes a Mojo file I won't
85:30 - be really using this much because it's
85:32 - not as important
85:34 - but what is important is this little
85:37 - build command here and this will
85:38 - actually accelerate your speed by quite
85:40 - a bit not by like 5 10x I mean it might
85:43 - but it honestly depends on what you're
85:45 - doing
85:46 - anyways let's just cut to the Chase and
85:48 - I'm going to show you what build does
85:50 - let's actually use this Mojo build
85:52 - command so I've I've just ported some
85:55 - code that I've written to essentially
85:57 - test uh Pi torch on both CPU and GPU so
86:02 - we went over sequential processing and
86:04 - parallel processing uh this is
86:07 - essentially just doing that and we're
86:08 - just comparing speeds so uh you don't
86:10 - this this is probably scary to look at
86:12 - at first but essentially if I do uh
86:16 - Mojo Main dot Mojo give it a second
86:21 - Cuda
86:39 - okay
86:40 - and we get a CPU time
86:43 - a lot of this time is spent actually
86:44 - importing the packages itself
86:47 - so now some of this is going to be spent
86:49 - you know so some of it is going to be
86:51 - spent on Cuda time as well so CPU
86:54 - actually performed almost 5x better than
86:56 - the Cuda time which is insane
86:59 - and if I wanted instead build if I want
87:02 - to instead build this into a binary form
87:03 - and then run it which should be faster I
87:05 - would just go Mojo build and then main
87:08 - dot Mojo just like that
87:10 - and we should see main binary file
87:12 - pop-up in order to run this we would
87:14 - just go uh dot slash
87:18 - dot slash main
87:38 - we can say we get a Cuda 1.2 seconds or
87:42 - sorry CPU 1.2 seconds and Cuda is sped
87:45 - up by quite a bit so this sort of just
87:47 - proves that normally running Mojo in
87:50 - this way is less efficient or less less
87:54 - quick rather than
87:58 - making a bill uh making a binary file
88:00 - using the build command so if you're
88:03 - just testing around and playing with
88:04 - things in Mojo you shouldn't really need
88:06 - to build it but once you're ready to
88:08 - push it and like really like see what
88:10 - the limits are of of that file and just
88:13 - see like how fast can this possibly go
88:15 - then you would want to use the build so
88:17 - if you're pushing something to
88:18 - production or you just want to you know
88:20 - say in the future you're able to train
88:22 - some neural network and you want it to
88:24 - go as fast as possible you might want to
88:26 - use the build command rather than just
88:28 - running it normally
88:30 - so anyways that's how that works it's
88:32 - fairly simple you just build this and
88:34 - then you do dot slash and then whenever
88:36 - the name is in this case it's main so uh
88:40 - awesome that's how that works now we're
88:43 - actually going to go into how you can
88:45 - build your own package so for example
88:48 - python is we're able to import it it
88:51 - counts as its own module or library or
88:53 - package whatever you want to call it and
88:57 - we're just going to create our own we're
88:59 - going to create some object or class or
89:01 - struct and we're going to import it into
89:03 - a different script even though it exists
89:05 - on a completely different place on the
89:07 - computer so I want to build a package
89:09 - just to use to maybe use later and so
89:13 - first of all we're gonna have to go to
89:14 - the docs I skipped ahead a little bit
89:16 - there but essentially you go to Mojo
89:19 - uh and then
89:22 - I might full screen this for a second
89:26 - or just CLI and we go to Mojo package
89:29 - and then
89:30 - uh so there's a whole description here
89:32 - about just like some extra options you
89:34 - can pass into it but what we really care
89:36 - about is this see more about modules and
89:39 - packages so let's go ahead and click on
89:41 - this I'm going to drag this over to uh
89:44 - like a split screen and we're just going
89:46 - to follow the instructions
89:47 - so provide the packaging system that
89:50 - allows you to organize and compile code
89:52 - libraries into importable files so when
89:55 - you like import python for instance you
89:57 - go from python
89:59 - import Python and then you can use some
90:02 - of the built-in libraries it's
90:04 - essentially like that except we're big
90:06 - we're making our own libraries
90:08 - uh introduces necessary Concepts blah
90:11 - blah blah and to understand you don't
90:14 - understand motion modules so single
90:17 - source file that includes code suitable
90:19 - for use by other files that import it so
90:22 - you can create a module to define a
90:23 - struct such as this one so let's go
90:25 - ahead and follow along I'm going to go
90:27 - ahead and uh actually we're going to
90:29 - scroll down just to make sure we have
90:31 - this structure correct because there's a
90:33 - structure down here that we're supposed
90:34 - to follow
90:35 - uh so we go make a new directory we call
90:38 - it maybe uh my package
90:43 - and then we make a new file inside of it
90:45 - we go init
90:48 - .mojo and then we make a my
90:53 - module
90:54 - dot Mojo awesome and then we have our
90:57 - main here it's awesome these are all
90:58 - empty what do we put in them next
91:01 - so we have this my module.mojo here so
91:04 - we'll just
91:05 - pop this in and let's let's first look
91:07 - at what this does this is a struct uh we
91:10 - have some we have some variables uh two
91:14 - integers essentially we're just making a
91:16 - pair hence it being called my pair uh
91:18 - you those those are essentially just the
91:21 - the instance arguments that we're going
91:23 - to pass in when we call this with our
91:25 - package
91:27 - so awesome now what
91:29 - now we have a main dot Mojo so we're
91:32 - going to have to actually import
91:36 - from this we're gonna have to go my
91:39 - package
91:41 - you're going to see this a crash happen
91:43 - in the Mojo parser so
91:46 - I can actually go ahead and run this
91:49 - main dot Mojo and it we're getting
91:51 - aborted this is currently still
91:53 - something that Mojo was figuring out
91:55 - right now I was running into this error
91:57 - quite a little bit and we're just gonna
92:00 - sort of Go full steam ahead and we're
92:03 - gonna go to the end result that we
92:05 - actually want we're not going to be
92:06 - concerned about this for too long
92:09 - so
92:11 - for example import something that's in
92:14 - the same directory so so essentially
92:16 - what's happening when we import this
92:18 - we have from so it's going to come from
92:21 - somewhere else so it's going to come
92:22 - from the my package directory dot my
92:25 - module so it's going to come from my
92:27 - package dot my module and we're going to
92:30 - import my pair
92:32 - so that's exactly what this like quite
92:34 - literally what this says from my Mac
92:36 - from my my package.my module import my
92:39 - pair and so this should work fine and
92:41 - really all we have to do to fill in the
92:44 - blanks here is essentially just create
92:48 - we're going to create a package out of
92:51 - this and you can leave the init.mojo you
92:53 - don't have to edit this at all
92:55 - so essentially uh how this goes is we
92:59 - just go Mojo
93:02 - package and then we look at whatever the
93:05 - name of this package is called
93:08 - save my package we're going to do Dash o
93:12 - and then whatever name we want it to be
93:15 - just be like maybe
93:17 - test pack
93:20 - oh testpack dot Mojo package and you
93:23 - have a nice little Unicode character
93:25 - here as well which is really cute so
93:27 - just a DOT Mojo package file extension
93:30 - and we can go ahead and create that and
93:33 - we see that it shows up here
93:34 - so in order to actually import this into
93:36 - our main dot Mojo now we see that it's
93:38 - in the same directory it's in the same
93:41 - local directory as
93:42 - main dot Mojo So these are together so
93:45 - we don't need to like import from
93:47 - something you know far out
93:49 - all we can do is essentially just
93:54 - go
93:57 - from testpack.my module because keep in
93:59 - mind it's still going into this my
94:03 - module instead of my pack but this is
94:04 - just compressed into like a shorter form
94:07 - so if we go ahead and run main dot Mojo
94:11 - now we should see
94:14 - uh main dot Mojo we get two and four we
94:17 - passed in the pair two and four and we
94:19 - get that output so that's that's really
94:22 - it that's that's honestly how you make
94:24 - packages just uh you make sure that you
94:27 - create a directory in the local folder
94:29 - and then you put an init Mojo it has to
94:33 - have two underscores on both sides and
94:36 - then whatever your module name is called
94:37 - and then you do whatever you need to in
94:39 - here maybe a struct maybe a few of maybe
94:42 - a few structs if you want
94:44 - and uh that's that's pretty much it so
94:47 - that's how you create packages so we
94:50 - just covered two of the command line
94:51 - tools that Mojo uses so Mojo build and
94:54 - Mojo package so uh if we want to
94:57 - actually look at some others you could
94:59 - just go down to Mojo here and we we can
95:02 - see that we have
95:03 - we have run build which we already did
95:06 - uh repl that's not something I'm going
95:08 - to cover in this video we just did
95:10 - package formats I don't think this is as
95:13 - important uh docs I haven't seen a lot
95:16 - of usage with like deem angle dot format
95:19 - a little bit of Rebel but uh just just
95:22 - for like the basics and creating your
95:24 - own packages and building a binary
95:26 - executable files build and package are
95:29 - going to be your Best Bets if you want
95:31 - to you could totally dive into
95:33 - other commands but those are the only
95:35 - that I feel like are very necessary for
95:38 - the basics uh anyways you should give
95:40 - yourself a pat on the back you made it
95:42 - really far and there's actually only a
95:44 - few more Concepts we have to cover
95:45 - there's there's not that much you're
95:47 - like almost done so give yourself a pat
95:49 - on the back grab some coffee or whatever
95:51 - you do and let's jump right back into it
95:54 - so I want to introduce the coolest data
95:57 - type ever it's called a simdi so what
95:59 - does simd stand for what is this Cindy
96:01 - what does it mean well simdi is short
96:03 - for single instruction multiple data so
96:06 - that means you can have say an array and
96:09 - instead of doing an operation on each
96:11 - element in the array
96:12 - you just do one on everything so it's
96:15 - only one operation
96:17 - so what does this actually look like if
96:19 - we were to say use python
96:22 - so in Python you'd have like an array
96:25 - say maybe you know two four six eight
96:28 - or two four
96:32 - and essentially you would have to Loop
96:34 - through this entire array and do an
96:37 - operation date element let's just say
96:39 - we're multiplying by two so you have to
96:41 - go through each element you'd go to the
96:43 - first index you would you would set the
96:45 - new you set a new array to equal
96:50 - uh what is this times two and then what
96:53 - does this times 2 and then what is 6
96:54 - times 2 and then what is 8 times 2 you
96:56 - would do all of this sequentially
96:58 - but Sim d
96:59 - is different so you can just do times
97:03 - two one time you multiply the entire
97:05 - thing by two and it's done
97:07 - just like that in one operation it's
97:10 - essentially a CPU instruction so
97:14 - it's it's a it's an easy way to write it
97:16 - but essentially CPUs accept a certain
97:19 - type of instruction or the CPUs will
97:22 - accept some instructions that will allow
97:24 - them to take like shortcuts and
97:25 - loopholes around things so 70 is an
97:28 - example of that where you don't have to
97:30 - iteratively multiply or add things
97:32 - together you could just do it all at
97:34 - once in one operation
97:36 - so for example if I were to print say x
97:40 - which is the 70 and then I
97:42 - multiply by 2.
97:45 - I could run this and we would get
97:47 - essentially everything multiplied by two
97:49 - and this all happened in a singular
97:51 - operation
97:53 - so
97:54 - next up there's a there's an interesting
97:57 - uh
98:00 - I guess method you could say we could
98:01 - call on
98:02 - the 70 type which is len so Len is
98:06 - equivalent to
98:08 - essentially length of x
98:10 - in Python that's what it would look like
98:13 - but in Mojo we would do x dot when and
98:16 - then
98:17 - so just some round brackets
98:19 - so this will print out four because we
98:23 - made the length of it four and this is a
98:26 - good time to actually delve into what
98:28 - each of these parameters are so first of
98:31 - all you initialize a variable say let x
98:33 - equals
98:34 - and then
98:36 - we could just say it's equal to a single
98:39 - instruction multiple data data type and
98:42 - then we have some square brackets here
98:43 - and inside of these square brackets
98:45 - you're going to pass in the data type
98:48 - that you desire it to be and the length
98:50 - of this multiple data if you will
98:54 - and
98:56 - so to do that we use D type and then dot
99:00 - whatever you want it has a this this
99:02 - data this data type needs to have a
99:05 - lowercase letter so you can't just do
99:07 - like float 16 it has to be a lowercase
99:09 - letter
99:11 - um and then this uh this four is
99:14 - essentially just how long it's going to
99:16 - be because it's one dimensional it's
99:18 - just like one dimension so after these
99:20 - square brackets you just have these
99:22 - round brackets here and this is the
99:23 - contents of what you want and there's an
99:25 - interesting thing we can do with these
99:27 - because consider these this is four
99:29 - elements here and we explicitly declare
99:31 - that this is going to be four elements
99:33 - long
99:34 - so what happens if we add a fifth in say
99:36 - 25. and then we print out what is X
99:40 - multiplied by two
99:42 - we get uh this number we get this Sim d
99:46 - uh returned back so this essentially
99:49 - means that we're going to take the first
99:51 - four numbers of whatever you put in here
99:54 - and then everything else we're just
99:56 - going to splice It Off
99:57 - so that's a cool little feature I don't
100:00 - know if that's a feature or a bug but
100:02 - I think that's pretty cool how you don't
100:04 - get errors for doing that so
100:07 - anyways there's a lot of operations you
100:09 - can do with these uh you can there's
100:12 - certain ways to make like a really long
100:14 - uh
100:15 - what we call Vector that's just the same
100:18 - exact number all the way through
100:21 - um
100:22 - and this actually leads me into
100:25 - a little bit more Deep dive of what this
100:29 - Sim D type is so let me go ahead and
100:33 - just uh
100:34 - get rid of this and I'm going to copy
100:36 - some code in oh
100:40 - so
100:42 - we have a function add and we have a
100:44 - function main no no don't get scared by
100:46 - this too early
100:47 - so what does this function main going to
100:50 - call well we're going to let x equal the
100:52 - same D type float float 16. it's
100:55 - literally the same one we just used and
100:58 - we're gonna we're gonna pass it into a
101:00 - function called add so x and x
101:04 - so what's actually happening in this add
101:07 - function well
101:09 - first of all
101:11 - we have some uh we have some square
101:13 - brackets here this is going to determine
101:16 - uh what the data type is and what the
101:19 - length is so these are the two uh
101:22 - essentially needed
101:24 - function Arguments for operating with
101:27 - simd types so
101:30 - you would essentially give a name for
101:33 - what the data type is so D type we would
101:35 - give that data type
101:37 - and then the lengths we would just set
101:40 - that to the data type int we could it
101:42 - could be like an in 32 and 64. it
101:44 - doesn't really matter we're just saying
101:45 - that's going to be an end here so this
101:48 - is like converting your data types to
101:50 - names that we can use later
101:53 - now we have these round brackets and
101:56 - notice how oh notice how these actually
101:59 - stretch out quite far
102:01 - so in here we specify the actual
102:03 - function arguments themselves what is
102:06 - this first X going to be that's going to
102:07 - be a that's going to be this piece right
102:10 - here so a is going to be a Sim D type
102:12 - with data type D type and length of type
102:16 - integer
102:17 - and then same thing for B here except we
102:20 - can't just we simply can't have a twice
102:22 - because that would that would give us
102:24 - errors so we're just going to do a and b
102:27 - so
102:29 - next up we have uh we're essentially
102:32 - just returning
102:33 - what this is what this entire function
102:35 - is going to return which of course has
102:37 - to be a simdi type with a data type D
102:41 - type and integer so
102:44 - that's that that's a lot of content but
102:46 - essentially all that really happens is
102:49 - we just add them together it's a single
102:51 - single operation that we do and if I go
102:54 - ahead and run this here
102:57 - we will get uh this we could even we
103:01 - could even multiply them together
103:03 - can even multiply them
103:06 - one times one four times four nine times
103:10 - nine and sixteen times sixteen we could
103:12 - even divide them if you want since
103:14 - they're a float float 16.
103:18 - so
103:20 - everything divides by itself or if
103:22 - something divides by itself it's equal
103:23 - to one so that's why we have ones there
103:26 - but anyways these instructions are super
103:28 - cool I'm not going to dive like an
103:31 - insanely amount I'm more into them but
103:33 - we're going to use sim D types A little
103:35 - bit later on to do some speed tests but
103:38 - before we jump into that I want to cover
103:40 - some other uh Concepts and topics
103:44 - the next one being decorators and meta
103:46 - programming so I've just kind of
103:48 - implemented it it doesn't really do
103:50 - anything but this is what it looks like
103:52 - this is called a decorator
103:54 - and
103:56 - decorators come from a practice called
103:58 - meta programming where meta programming
104:00 - implementations look at the code
104:02 - architecture you've attached the
104:04 - implementations to and have the code
104:07 - optimize itself based on the specific
104:10 - meta programming feature you're using so
104:13 - uh in the context of unroll essentially
104:16 - what this does is it unrolls the loop
104:18 - you have some Loop and it unrolls it
104:20 - into a bunch of individual uh iterations
104:24 - if you will so if we have if We're
104:26 - looping over this 10 times if we're
104:29 - doing I 10 times
104:31 - instead of going sequentially
104:34 - it'll split it out into 10 different uh
104:37 - individual Loops that it'll uh
104:39 - individual iterations that it'll do
104:42 - um and so we can even pass parameters
104:45 - into unroll
104:46 - we could go for example uh two and what
104:51 - two would do is it would split it into
104:54 - iterations of two and loop over five
104:57 - times so there's a bunch of ways that
104:59 - you can mess around with these meta
105:01 - programming features they make
105:03 - everything super hackable hence the word
105:05 - meta programming it's it's a beautiful
105:07 - word
105:08 - and this essentially allows you to take
105:11 - advantage of maybe parallelizing some
105:14 - operations maybe you have a loop where
105:16 - instead of sequentially running it you
105:19 - want to split it into a bunch of
105:20 - individual iterations and then plug
105:22 - you know say a fraction of them into
105:25 - each processor that you have and have it
105:29 - done in a fraction of the time
105:31 - so little optimizations like
105:32 - optimizations like this will greatly
105:35 - help performance but meta programming
105:38 - has always been sort of an advanced
105:39 - feature so I thought I'd share with you
105:42 - uh what exactly they look like and an
105:45 - example of what one of them does meaning
105:46 - unroll but they are an advanced feature
105:49 - so I'm not going to go super into it
105:51 - this video however if you are interested
105:53 - and wanted to dive deeper into
105:55 - decorators and meta programming I would
105:58 - highly recommend that you refer to the
106:00 - documentation so let me now show you the
106:02 - case for an up to 77 000 X beat up over
106:06 - python it's blown a lot of people's
106:08 - minds in the past little bit but so if
106:12 - we just go to the modular documentation
106:14 - here
106:15 - uh just docs and then Mojo notebooks
106:18 - matrix multiplication and Mojo just
106:20 - scroll to the top I'm not going to walk
106:22 - through like the actual Matrix
106:24 - multiplications going on the algorithm
106:26 - here isn't important
106:27 - a fact of the matter is is that we just
106:30 - need to plug these code blocks in and
106:32 - see how it progresses based on what
106:35 - features we add to it and what
106:36 - optimizations we add so what I've done
106:38 - is I've ported all of this code block by
106:41 - block
106:42 - all N2 and you can see they have a 77
106:46 - 000x speed up and I've ported all of
106:49 - this into my own notebook here
106:52 - so I've already run everything and as
106:56 - you can see uh initially we get you know
107:00 - 0.001 gigaflops and then after an
107:04 - optimization we get a 0.01 gigaflops
107:07 - which is an 8X speed up
107:09 - and then like everything here is uh
107:12 - compared to the original by the way so
107:14 - everything is compared to the first
107:15 - three code blocks
107:17 - so we get an 8X beat up and a 3000x
107:20 - speed up
107:21 - and I'll go into what exactly well what
107:25 - exactly is making it go up to 3000x
107:27 - and then a 13 000 X
107:30 - a little bit more
107:32 - and then at 22 000x
107:34 - and then 19 000 just due to some
107:38 - Hardware stuff it could go up or down
107:39 - depending on your Hardware
107:41 - um
107:42 - and then it just kind of settles around
107:44 - a 20 000 X beat up and this is just for
107:46 - my machine again mode uh the modular
107:49 - team probably tested it on a machine
107:52 - that was favoring this code that they
107:55 - used so there might be other ways to
107:57 - optimize around your own Machinery but
107:59 - that's not something you should worry
108:00 - about as a beginner all you should worry
108:02 - about is what are the fundamental uh
108:05 - what are the fundamental concepts and
108:07 - practices you can use to get the most
108:09 - significant speed up without over
108:11 - complicating your entire thing so if you
108:13 - can get like a 5000x speed up and it
108:15 - takes you five minutes to implement it
108:17 - maybe just stick with that maybe you
108:19 - don't even have to go to
108:20 - you know a 10 000 X beat up because
108:22 - that's just that's just making it twice
108:24 - as efficient it's not as big as a uh a
108:28 - 5000 x jump so anyways I'm gonna walk
108:32 - through this uh sort of what's Happening
108:34 - Here
108:35 - so initially uh we're using python to do
108:38 - a matrix multiplication and the thing
108:41 - with python is that it's not very good
108:43 - at running code on multiple CPU
108:46 - processors so if we actually look I can
108:48 - check my current CPU processors if I go
108:51 - to
108:52 - uh performance we go to CPU and it'll
108:56 - just say logical processors here or your
108:59 - threads logical processors and threads
109:01 - are used interchangeably
109:03 - so you can see what your number is there
109:05 - and that's essentially how many
109:08 - processors can do computations in
109:11 - parallel
109:12 - so initially
109:14 - python is only using one of those 12
109:16 - threads
109:18 - and
109:19 - then what we do afterwards through uh
109:23 - through this next jump let's take a look
109:25 - and see what it's doing
109:31 - so what this appears to be is instead of
109:34 - using all python we're actually jumping
109:37 - over to some Mojo syntax so we're using
109:40 - FNS and we're being uh more explicit
109:44 - about what types we're giving things
109:46 - we're being more explicit we're getting
109:49 - more to the point about what exactly the
109:51 - code is time to accomplish
109:53 - and then
109:56 - I'll just navigate back here because
109:58 - it's hard to follow along when
109:59 - everything is black and white
110:04 - so initially we use One processor
110:08 - and then we use some modules from Mojo
110:11 - and we use some Mojo based kind of
110:13 - syntax we do some importations here
110:16 - uh
110:17 - then what
110:21 - then we add types okay
110:24 - so yeah just just adding types in is
110:26 - going to give us significant speed up
110:28 - and then
110:56 - and then we have a benchmark function
110:58 - which is built into Mojo and it's used
111:00 - to just sort of do speed tests like
111:02 - these do benchmarks
111:05 - so
111:07 - now we get into the the cooler stuff
111:09 - that I actually enjoy talking about
111:12 - so one is vectorizing what the heck is
111:14 - vectorizing
111:15 - so imagine you have uh you're you're in
111:19 - a I mean some of you have probably taken
111:21 - introductory physics before or something
111:22 - close maybe a science class and so when
111:25 - you think of a vector you think of a
111:27 - direction and a magnitude a scalar is
111:29 - just a magnitude but Vector has a
111:31 - Direction with it as well
111:33 - so for example
111:35 - um if you were if you were say had a
111:37 - velocity maybe you'd be going you know
111:40 - 10 meters per second at this you know
111:43 - amount of this this amount of degrees
111:44 - right so you'd have some direction and a
111:47 - speed at which you're going in that
111:49 - direction so that'd be a vector
111:50 - so some ways to actually store that
111:52 - would be maybe an X attribute so if you
111:55 - have a you have your little hypotenuse
111:57 - here you have an X attribute and a y
112:00 - attribute so you have your X as one
112:03 - in your in your zero with index and then
112:07 - you have your y attribute in the first
112:10 - index and then you have maybe your
112:13 - um
112:13 - maybe your direction in the
112:17 - uh
112:18 - in the second index and if you wanted to
112:21 - increase the dimensionality of this
112:23 - meaning if you wanted to instead of just
112:25 - have two Dimensions you would go to
112:27 - three so you're having vectors in 3D
112:28 - space or you could just increase it up
112:31 - to like 10d or 100d whatever you wanted
112:33 - to and essentially vectors are ways to
112:36 - describe uh
112:38 - essentially Direction and magnitudes in
112:41 - it any dimensional space so with
112:45 - vectorizing we essentially convert
112:46 - things to the Sim D type and this allows
112:51 - us to do these Matrix multiplications
112:54 - with far less operations so I was
112:57 - talking about the simdi types before and
112:59 - we're essentially just treating our
113:01 - vectors as some D types and then working
113:03 - with those
113:04 - so that's what vectorizing is converting
113:06 - to something that you can do one
113:08 - operation on that's going to scale up
113:11 - computationally wise
113:13 - and we can see that we get an insane
113:15 - speed up there so 1600 all the way to
113:18 - 7000 so we've just sped up this a ton
113:22 - just by using vectors
113:25 - then what's next
113:26 - so parallelizing so you might think
113:29 - parallelizing has to do with the GPU but
113:31 - in this case it doesn't actually what
113:33 - parallelizing does is instead of just
113:36 - using one thread we're going to be using
113:39 - maybe not all 12 but pretty close like
113:41 - maybe 10 or maybe eight of them or maybe
113:43 - 11 who knows we'll be using a lot more
113:46 - of these threads or logical processors
113:48 - essentially in parallel so imagine you
113:52 - have a giant piece of data and you have
113:54 - you know four processors that can go
113:57 - through it so instead of having one
113:59 - processor or each of them go through the
114:02 - same amount of data just from from the
114:04 - start all the way to the end what you do
114:06 - instead is you give them each little
114:08 - jobs so the first processor can do the
114:11 - first quarter second processor second
114:12 - quarter third processor third quarter
114:14 - and Etc
114:16 - you split it into jobs and what ends up
114:18 - happening is everything is run at the
114:21 - same time all the processors are run at
114:23 - the same time and each of them complete
114:26 - uh their jobs at the same time because
114:28 - these lists are or these pieces of data
114:31 - you have to sort through are now a
114:32 - quarter in size in comparison to the
114:34 - entire length so now you've just
114:37 - essentially decreased your total run
114:39 - time by a quarter just by having four
114:42 - processors that you're running things on
114:44 - So based on the number of processors
114:46 - that Mojo is allowed to access this is
114:49 - governed by the operating system and
114:50 - some other features I'm not going to get
114:52 - into
114:52 - but essentially that's what
114:54 - parallelizing is is splitting a task
114:57 - among a bunch of processors instead of
114:59 - doing the entire thing on one
115:01 - so with parallelizing we go from 6800
115:06 - all the way up to 62 000. so in this
115:10 - case they probably had a lot of
115:11 - processors that were being utilized to
115:13 - get this 10x speed up compared to uh
115:16 - about 6000 x beat up
115:18 - uh and then the last and then the last
115:20 - one that's quite interesting is called
115:22 - tiling
115:24 - so tiling and tiling is an interesting
115:26 - one uh the best way to sort of
115:28 - conceptualize this is to think of a
115:30 - giant grid of numbers like a giant two
115:32 - by two like a times table if you will a
115:35 - giant two by two times table and instead
115:39 - of calculating everything all at once
115:40 - and this this might not be like a 10 by
115:43 - 10 times table this might be like a a
115:45 - 500 by 500 times table or even way way
115:48 - uh larger than that
115:50 - so what piling allows you to do is
115:53 - instead of uh doing everything at once
115:56 - and drawing it from your RAM your slow
115:59 - memory it will cache it in your CPU your
116:02 - CPU has little RAM chips that are way
116:05 - higher bandwidth and they allow uh
116:08 - information to be transferred almost
116:10 - instantaneously
116:11 - so
116:13 - what this allows you to do is
116:15 - essentially load in little bits of this
116:17 - times table at a time so you can do
116:20 - computations on them so say you want the
116:22 - first you know five numbers one two
116:23 - three four five one two three four five
116:25 - so you've got a you've got five times
116:27 - five there you've got essentially 25
116:30 - boxes that you're gonna do instead of
116:32 - say 2 million or 2.5 million or there's
116:35 - some crazy number and you can load these
116:38 - into your caches your CPU caches
116:41 - preemptively so you don't have to do
116:43 - this right away or else that would that
116:45 - would essentially degrade away at your
116:47 - runtime constantly having to move things
116:49 - into your cache and then use them that
116:51 - just adds on to extra time
116:53 - so the compiler could be smart and
116:56 - instead of move over what it knows it's
116:58 - going to need before it has to use it
117:00 - and then once it's actually asked to do
117:03 - those computations it can like very
117:05 - quickly draw from that little cache uh
117:09 - and then get the next one in so that's
117:10 - it's ready to do the next computation so
117:13 - this way you're saving time uh from
117:16 - avoiding that giant delay and drawing
117:19 - all of that information from your RAM
117:21 - and rather just having it ready in your
117:24 - CPU caches
117:26 - and to look at those
117:28 - we can see our CPU caches we have an L1
117:31 - L2 L3 so your L3 would be the slowest L3
117:35 - would be or sorry L2 would be a little
117:38 - bit faster than L3 and then your L1 is
117:40 - like extreme speed like this is almost
117:43 - incomprehensibly fast and so probably a
117:47 - lot of these uh this tiling operations
117:50 - are going to be stored on your L1 L2
117:52 - maybe L3 cache
117:54 - so that's kind of just what what what's
117:57 - happening with uh tiling when we do
118:00 - matrix multiplication it's like storing
118:02 - times tables in little uh tiles
118:05 - essentially
118:06 - hence it being called tiling and that
118:10 - way you're saving the memory uh draw
118:12 - time the transfer time
118:14 - so
118:15 - that's vectorizing
118:18 - parallelizing and tiling for you so
118:21 - hopefully that all made sense if it
118:23 - didn't totally chat GPT your way through
118:25 - it man I totally encourage you guys to
118:26 - use generative AI to help understand the
118:28 - stuff better it's such an amazing tool
118:30 - but anyways
118:33 - that pretty much sums up uh everything
118:36 - that's
118:37 - this course covers so
118:40 - bear with me I'm going to do a little uh
118:42 - outro here with some more little facts
118:46 - and stuff that you may want to know
118:47 - about the language and so next up I'm
118:49 - going to walk through how to report
118:51 - errors and actually before you actually
118:54 - report any errors there's a lot of
118:56 - things you have to check over first
118:58 - so one
118:59 - uh actually just go to the Mojo bot help
119:02 - and then type you know Kappa AI I have a
119:06 - problem and then it'll open up a new
119:10 - thread and you can ask it questions just
119:13 - by tagging it through the at symbol
119:16 - so Kappa AI is essentially memorized all
119:19 - of the Mojo docs and knows everything
119:20 - about modular so you can just bombard
119:23 - your questions with it it's not a human
119:27 - so there's that and then also being able
119:31 - to search through errors through this
119:32 - search bar this is a huge help so what
119:34 - if I uh say like environment
119:38 - variable
119:40 - and then I get a bunch of uh I can go
119:42 - new old or relevant and get a bunch of
119:45 - data about how do I read environment
119:46 - variables in Mojo right like there's a
119:48 - bunch of comments here so you might be
119:51 - able to find your error maybe someone
119:52 - else has already ran into it and they've
119:54 - gotten an answer
119:56 - or you can collaborate with somebody
119:57 - else in this Discord server so this will
120:00 - be in the GitHub repository and also you
120:02 - want to make sure I'm going to go to
120:04 - github.com
120:07 - go to Mojo and
120:09 - if you're actually looking at an error
120:13 - what you want to make sure is that you
120:15 - check issues because there's a lot of
120:17 - errors that have been asked here there's
120:18 - actually like a lot of pages of errors
120:21 - so what you might want to do is just
120:22 - take a quick scroll through these and
120:25 - just look for any keywords say you know
120:27 - maybe I can't access
120:31 - environment variables and you go to the
120:33 - next page
120:36 - and then nothing is found here right and
120:38 - you keep going through your pages and
120:40 - just look for your keyword essentially
120:41 - to see if that and if anybody has ran
120:43 - into this problem before and to see if
120:45 - it has been answered
120:47 - so that way you're not just bombarding
120:49 - this whole issues issues page with the
120:52 - same error twice
120:54 - because if you have the same error twice
120:55 - then that means they have to you know
120:57 - it's that's a little bit of a hassle for
120:59 - the modular team and you don't want that
121:00 - because you want a good programming
121:03 - language faster so just be cautious
121:05 - about that it shouldn't be too hard to
121:08 - look through and just see if errors have
121:10 - existed yet just look through the GitHub
121:12 - look through stack Overflow look to the
121:14 - Discord server ask the Kappa AI and then
121:18 - your last resort is probably going to be
121:22 - if it's at fault of Mojo So if it's not
121:24 - your fault it might be Mojo's fault and
121:26 - it's something that nobody has asked yet
121:28 - and you actually need to
121:31 - propose an error or a question
121:33 - so
121:35 - a few key points that are very important
121:37 - when you're asking a question
121:38 - so you need to be specific so clearly
121:41 - State what you're trying to achieve uh
121:43 - where you're facing issues secondly you
121:46 - want to show effort indicate what you've
121:47 - already tried so include some relevant
121:49 - code or error messages so you want to
121:51 - have full information be respectful so
121:54 - you want to be polite and appreciative
121:56 - because these are other people that are
121:58 - taking time out of their day to
122:00 - potentially help you so you want to just
122:01 - be respectful and sure that you care and
122:05 - aren't just trying to
122:06 - care only about yourself
122:08 - you also want to use descriptive titles
122:10 - because when these developers and
122:13 - debuggers are going through and they're
122:16 - they're looking at all the titles they
122:18 - want to be something that's easy to read
122:19 - something that they can make sense of if
122:21 - it's like
122:22 - you know just a bunch of random
122:24 - characters it's like hmm maybe that
122:26 - person doesn't quite know how to ask
122:28 - about errors and so that's going to be
122:30 - harder for them to approach because they
122:32 - don't know what's going on
122:34 - uh so you want to address the issue or
122:36 - question within your title
122:38 - you want to keep it relevant so stick to
122:40 - the main topic and avoid any unnecessary
122:42 - details make sure everything is
122:44 - formatted properly I'm going to show you
122:46 - how to do that in a second here how to
122:48 - make sure your code and logs are
122:49 - formatted properly
122:51 - you want to also include some system and
122:53 - platform details so since this is closer
122:57 - to a systems programming language you
122:59 - want to include some information about
123:01 - your system such as maybe your RAM maybe
123:04 - just some other aspects that might that
123:08 - might affect the reason you're getting
123:09 - an error so anything it could be
123:12 - remotely close to that you want to make
123:15 - sure you have full information once
123:16 - again and lastly avoid emotional
123:19 - language don't get mad don't don't swear
123:22 - uh
123:23 - so just just be super polite about it
123:26 - and don't get like mad or anything I
123:29 - mean we're all developers here we're all
123:30 - on the same page we're trying to Make a
123:32 - Better Community for the development of
123:35 - artificial intelligence systems so uh
123:39 - don't get mad just
123:41 - take a chill pill if you can and uh yeah
123:45 - so anyways I'm going to walk you through
123:47 - how to actually submit errors so here
123:50 - are some examples of both good and bad
123:53 - examples so
123:56 - if you're on GitHub and you're trying to
123:58 - propose an issue you go new issue you
124:01 - say title a bat a bad example would be
124:05 - software
124:06 - keeps
124:11 - crashing dot dot dot and then
124:17 - your software sucks
124:19 - fix it
124:21 - am getting
124:22 - compiler
124:27 - getting compiler error so first of all
124:31 - the title is misleading it doesn't
124:33 - really give any information about it uh
124:35 - it's a little bit disrespectful because
124:38 - you're not considering uh what it looks
124:41 - like from their perspective
124:43 - your software sucks that's like you
124:46 - don't need that fix it it's hard to know
124:49 - what to fix if you don't give any
124:51 - details and getting compiler error well
124:53 - you need to spell things correctly first
124:55 - of all and
124:57 - uh just getting compiler error could
124:59 - mean anything there's like billions of
125:01 - compiler errors that probably exist so
125:03 - uh don't go down that route instead uh
125:07 - what a good example would be
125:09 - would be
125:11 - um
125:15 - unable to save settings in version at
125:18 - 2.1.4 so it's showing like a version
125:21 - specifically that you're getting errors
125:22 - in
125:23 - um and then just something around saving
125:26 - settings and then
125:29 - maybe your body would look something
125:30 - like hello first of all thanks for the
125:33 - great software so you're like oh this
125:34 - software's great you're being polite I
125:36 - recently updated to you know version one
125:39 - two three or two one four and notice I
125:41 - can't save my settings anymore every
125:43 - time I click save the software crashes
125:45 - and then maybe you would provide
125:50 - um
125:51 - maybe you would provide some steps to
125:52 - reproduce so uh you know open software
125:57 - go to settings change any setting click
125:59 - on save so this way that developers can
126:01 - reproduce the error if other developers
126:03 - are able to reproduce your error then
126:05 - it's easier for them to pinpoint where
126:07 - it's going wrong because if it's working
126:09 - normally for everybody else and not you
126:11 - then if you can show a way where they
126:13 - could get the same thing as you then
126:15 - they can compare what's working to
126:17 - what's not working and try to mess with
126:19 - things in between to get to a breaking
126:21 - point where it works and then doesn't
126:23 - work because of maybe one line or
126:24 - something so that's really useful and
126:27 - then what your expected result maybe it
126:30 - was right to I mean expected result you
126:32 - don't always need to put it there but
126:34 - it's still a good practice
126:36 - then your actual result is you know
126:38 - whatever error you get some system
126:40 - information as well like maybe your
126:42 - operating system for example if you
126:44 - tried to install mojo on a MacBook and
126:47 - you didn't have the Linux terminal if
126:49 - you just use the Mac terminal of course
126:51 - you're going to get errors because it
126:52 - doesn't support Mac OS yet so system
126:55 - system information is always good to
126:57 - have
126:58 - um and then just you know be polite any
127:00 - help would be appreciated thanks
127:01 - so that's a wonderful example and even
127:05 - if you wanted to you could also consider
127:10 - uh maybe just putting some quotes around
127:12 - things so let's say steps we produce
127:17 - um
127:18 - you put three quotes around it
127:20 - like that
127:22 - and
127:23 - uh we should we should when we submit
127:25 - this issue I'll actually go
127:28 - just to show you guys what that looks
127:30 - like
127:31 - so when you put the three quotes both on
127:34 - the top and bottom of something then you
127:36 - get this
127:37 - and then if you put single single quotes
127:40 - we're talking about uh these things by
127:42 - the way not these not these just the the
127:44 - grave
127:45 - and essentially those those quotes are
127:48 - going to
127:50 - allow you to make little code blocks in
127:51 - here that people can copy and paste from
127:54 - um so this takes a little bit of
127:56 - practice you can create your own GitHub
127:58 - repositories and practice it on your own
127:59 - but this is generally what it's supposed
128:02 - to look like it's supposed to be very
128:03 - clear you would probably include your
128:06 - logs in the form of this and then maybe
128:08 - some code that you have in the form of
128:09 - this like where your line is uh erroring
128:12 - out so since Mojo is kind of an AI
128:15 - derived language it's used for
128:17 - accelerating a lot of these artificial
128:20 - intelligence systems through just faster
128:23 - Computing so a big question is is since
128:26 - it's so early a lot of people are
128:28 - wondering if you can actually build and
128:30 - train neural networks in Mojo so I can't
128:33 - really say yes or no to this but if you
128:35 - were to use something like say
128:37 - tensorflow
128:38 - um that wouldn't work quite or
128:40 - tensorflow or Pi torch that wouldn't
128:42 - work quite as well because uh you depend
128:45 - on a lot of things like file read and
128:47 - writing inheritance maybe Lambda
128:50 - functions arrays whatever which just
128:52 - doesn't exist yet
128:54 - um
128:55 - so technically if you want to go the
128:57 - easy route and use a lot of the Python
129:00 - libraries that wouldn't work however
129:02 - there are still some people uh building
129:04 - some pretty cool projects right now that
129:07 - are more like a lower level uh like they
129:11 - kind of look like C plus plus code a
129:12 - little bit so they're
129:14 - not as pythonic if you will and I'll
129:17 - actually leave a project like that into
129:18 - the in the description somebody actually
129:20 - was able to uh
129:23 - build or at least attempt building the
129:25 - lamma2 model using Mojo
129:28 - so that's cool that's just going to be
129:30 - in the GitHub repo in the description so
129:32 - feel free to check that out
129:35 - uh the other point is that since we
129:38 - cannot read and write uh to files uh
129:42 - there there would be no point in
129:43 - actually doing a lot of this training so
129:45 - we would have to rely on third parties
129:47 - like python to do this read in writing
129:49 - and saving the actual model files for us
129:52 - or else what's the point of even
129:53 - training right if you have a script that
129:55 - trains a model and then just dumps all
129:58 - the parameters after then I mean you've
130:00 - maybe used it one time maybe you prompt
130:02 - the model once but that's just a lot of
130:06 - wasted computation so we want to be able
130:08 - to save the model files so that we can
130:09 - use them again and that's just not super
130:11 - compatible with uh plain Mojo right now
130:15 - so
130:16 - my answer right now is like no for
130:18 - beginners you should not attempt to
130:20 - build any neural networks from scratch
130:21 - or anything or even use pythonic
130:25 - Frameworks so for now my answer is no
130:30 - um
130:30 - and I should probably add to that
130:32 - meaning like what doesn't exist in the
130:34 - Mojo language if neural networks don't
130:36 - really exist
130:37 - they they kind of do but they also kind
130:39 - of don't
130:41 - um what doesn't exist yet so you have
130:43 - list comprehensions like arrays
130:45 - dictionaries
130:46 - Etc you have Lambda functions from
130:49 - python those don't exist yet struck
130:51 - inheritance uh you would see something
130:53 - like this with pi torch and inheriting
130:56 - an N dot module if any of you have
130:58 - worked with pi torch before so you can't
131:01 - really keep track of your gradients that
131:03 - way and then again file read and write
131:06 - does not exist yet so uh there might be
131:09 - a few other things that I maybe didn't
131:11 - cover but those are kind of the
131:13 - the the huge ones the outliers that are
131:16 - uh really important that you should know
131:18 - about
131:20 - and then lastly if you are really
131:22 - curious uh
131:24 - I would honestly just consider reviewing
131:26 - the roadmap which you can find at uh the
131:29 - modular website if we actually head over
131:32 - to the modular docs here
131:34 - you can go to
131:36 - roadmap and sharp edges
131:39 - and you have some priorities here so CNC
131:42 - plus plus interop protocols traits just
131:44 - just a bunch of uh cool things here to
131:47 - look over and stay up to date with so
131:49 - now you should have all the tools in
131:51 - your belts to actually get started with
131:52 - you know reading Mojo documentation
131:55 - building your own projects playing
131:56 - around with the language and all that
131:59 - fun stuff so I hope you enjoyed the
132:02 - video this tutorial was designed as a
132:04 - sort of beginner uh emphasizing for
132:07 - beginners people transferring from
132:09 - Python and trying out mojo as well as
132:12 - just some you know Concepts that you
132:14 - should be aware of when you're doing
132:15 - more advanced systems programming so
132:18 - hopefully this tutorial was informative
132:20 - to you hopefully it helped my YouTube
132:22 - channel is in the description below so
132:25 - if you didn't want to check me out and
132:27 - maybe even subscribe that's I mean it's
132:29 - totally free you can unsubscribe later
132:31 - but I make pretty good content on there
132:33 - so uh you might want to go subscribe uh
132:36 - that's just in the description so
132:38 - anyways that's all I got
132:40 - have fun my fellow magicians

Cleaned transcript:

the Mojo programming language combines the usability of python with the performance of C it's basically an enhanced version of python specifically designed for artificial intelligence developers in this course Elliott Arledge will teach you how to use Mojo Ellie has created many popular courses related to Ai and he's the perfect person to teach this course let's start learning welcome to intro to the Mojo programming language course you're going to learn the fundamentals of using Mojo you're going to learn some of the intermediate and advanced features of it as well but before I touch on those I should cover some Basics first so you might be wondering who the heck is this guy on your screen well my name is Elliot I'm a computer science student a computer science student undergraduate and I like to mess around with code I like to train language models in my free time and I build awesome content like this so if you end up enjoying this feel free to subscribe my YouTube channel is just in the link in the description so you can totally check that out if you want uh a little disclaimer Mojo's a very new programming language it was actually released a week or two ago and by the time you're seeing this this course may actually be out of date so a little disclaimer there uh there there might be some new features there might be some weird syntactical things that don't work the same but this is to cover right now there may be some new tutorials that come out in the next you know little few months here or maybe even the upcoming years so just a little disclaimer this may be out of day by the time you're watching this this video is uploaded in September of 2023 so a little discommer there the docs specifically the Mojo docs the Mojo documentation says that this language is actually designed for experience systems programmers but the point of this course is to provide you with the fundamentals of getting using Mojo and being able to easily bounce off the documentation when needed so it assumes some fundamental knowledge of simple languages like python uh if you don't have any programming experience I recommend you touch on python a little bit or you could even just chat GPT your way through it that's what a lot of people do in fact that's what I did to learn a lot of what I know now uh understanding a programming language in depth will help you adapt to other languages as well so if you have some knowledge from ABC or C plus plus or JavaScript or python this course will just be even more easy for you to understand uh we're not going to be doing any intensive projects we're just going to explain how the language and the Mojo command line interface works so we're going to be building some simple scripts we're going to be building Jupiter notebooks using the Mojo language and we're going to be doing some command line stuff too this materials only backtested on Windows all you really need is a Linux terminal like Ubuntu and everything is the same so this means if you're on a Macbook for example you could search up a little tutorial on YouTube for how to install Ubuntu and get that set up but anyways as long as you have Ubuntu and that little Linux environment everything should be the same we will be using visual studio code to edit things here jupyter notebooks will be in the browser you'll you'll see that later if you're not familiar with Jupiter notebooks yet but um just the premises that we'll be using vs code as our text editor and lastly before we jump into what Mojo is I want to say that for those AI enthusiasts I'll begin with some simple sequential cpubased processing and then later in the course we'll jump into some still CPU processing but in parallel so parallel is essentially or at least sequential is when you do things one by one you wait for one to complete and you start the next and then parallel would mean you do a bunch of tasks at the same time so we're going to start off with some simple sequential based processing just to understand the language because we don't really need anything else to understand the language we don't need super high computational speeds we're just going to need yeah just some simple sequential we'll jump into parallel processing later so you might be wondering what the heck is this whole Mojo thing maybe maybe you clicked on it because Mojo is kind of the hype right now but we're just assuming you know you're completely new to Mojo you don't even know what the language is about what does it do um so essentially Mojo is kind of like a it quite literally is a superset of python so you can use all the same python syntax which a little bit of limitations of course since it's a brand new language uh and you can get the the scale and performance of a language like C plus so you can use very simple syntax to write the language and you can get insane performance out of it so why the heck do we need insane performance well the thing with python is that python is quite slow actually python is not a compiled language so python takes a long time and all of AI research right now or most of it is actually built and deployed with python so all of the models that you'll see a lot of the machine learning courses that you'll see on YouTube and in other places are purely based on python so what is mojo exactly doing well it's it's like python except you're getting that speed where you're able to train models or do renders way quicker so imagine it taking you you know four hours to get your model to a certain prediction accuracy than with Mojo if you were if you were able to optimize around that and you know put a little bit more effort into it you know some key features that Mojo uses will allow you to speed up the process and you will essentially be able to train the model in a fraction of the time so instead of taking say four hours it would take you maybe a few minutes if you do it right uh so as advertised Mojo has insane speedups over Python Meaning up to I think 77 000 times greater uh 70 77 000 times faster than python in some cases and that's we're actually going to prove that in this video we're going to actually walk through and show how it speeds up and I'm going to walk you through how that all works but anyways this is a language to sort of revolutionize the whole AI space to make AI way faster to make training quicker to make just computation in general quicker through language and the lower level optimizations what I mean by lower level is just closer to machine code essentially higher level is like more abstract closer to English and then lower level would be closer to Binary machine code so in case you haven't seen the actual speed up that Mojo provides we're just going to go into the docs.modular.com I'll actually go back here modular.com Mojo and then you just click on the Mojo docs here and then we can go to Mojo notebooks matrix multiplication and then just roll all the way down I'm going to cover this material later in the course but just pretty much scroll all the way down and you can see that after a bunch of optimizations they end up with a 77 000 X speed up over python which is insane like that's almost taking an entire day of python code running and compressing it down into just a little over a second that's crazy there are 86 400 seconds in a day and if we divide that by 77 000 that means it's about one one or or sorry 77 000 divided by eighty six thousand four hundred gives us that's zero that's 89 of a day so before I even begin setting up I want to emphasize that Mojo is a completely new programming language was released not even a few weeks ago with minimal support on anywhere but the GitHub or Discord so as for the Discord server I'm just going to go to the the modular Discord server you should be able to find it through the the website here and essentially you sign up do your verification or whatever and then you can actually search errors so be like you know uh error for example and then it would give you you know a bunch of a bunch of results so just search up like specific keywords be smart about it uh if you're encountering like certain types of errors that are like really long don't copy and paste the entire error into the search bar uh rather just look at like what are the keywords that this that this error throws and then just paste those in and just experiment and see if anybody else has encountered that because there are actually a lot of people in this community if I scroll down 2000 members so there are there's over two thousand people in this community a lot of which are actually offline right now but the point is there's a lot of people that can definitely help you out and some people that have already encountered errors so you can totally use the Discord to search for answers or even ask answer or ask ask questions and the other feature that you have through Discord is if you navigate down to this Mojo section and then go to Mojo bot help they actually have an AI That's trained on all of the Mojo documentation so if you go at Kappa Ai and you say um you know what are some basics of Mojo I could say absolute beginner and then it'll create a new little thread here and it'll say stand by for 20 seconds or so and in the meantime I'll actually show you the GitHub so we go to github.com modular ml and this is everything really you have the Mojo programming language here you have a bunch of you know issues and whatnot that you can submit to it what I would recommend though is that you absolutely make sure that if you're going to be posting issues on this Mojo GitHub that you make sure it's on fault of Mojo because if it's your fault then that doesn't really help out Mojo at all because that was just how the language was intended to work but if you were able to verify and you can verify through asking the Kappa AI about your issues and even looking in the Discord and if you happen to come across errors that are on fault of Mojo then you can just go on the issues here and later in the course I'll show you how to actually uh post these errors and properly ask questions so anyways those are some of your sources for now there's a little bit of stack Overflow but not that much so your main sources are going to be a little code issues searching for answers using this Discord search bar and asking the Kappa Ai and the Mojo bot help so if I scroll up says Mojo is a powerful language designed for high performance systems programming I'm sure similarities with system languages like rust and C plus but also designed to become a super set of python this means that many language features and Concepts from python translate nicely to Mojo Etc and it'll give you a nice little summary it tells you how to print stuff you can actually copy code directly from it it tells you how to make functions uh yeah essentially it you could just ask it anything about Mojo and it'll probably give you the best answer and as soon as summarized form and yes you can ask it to summarize things for you if you don't understand a systems program and concept uh you can definitely just say hey Kappa AI summarize this for me modular and Mojo only exist on Linux machines or at least you can only download them on Linux machines this is a Windows machine but I'm going to use a terminal and a Linux environment called Ubuntu so in order to download that go to Microsoft store wait for that to load move on to awesome search up Ubuntu app and then should be able to just install it there when we open it I'm not going to set up Ubuntu all over again because I already have it so just make up a username whatever and do that whole process um I'm going to go ahead and open mine here so this is the current Ubuntu that I have it's all signed in for me you can do clear to get rid of things uh you could do it LS to list it all the directories that you have uh you can go CD and then space dot dot to go back a directory and then CD and then type in the name of the directory you want to go into and let's just look at what we have so I'll CD into the Elliott directory and you can just press tab to uh autofill that awesome so this is our Ubuntu terminal so what exactly are we going to do next well we have to make sure that we have vs code installed that's also really important so if you don't have vs code go ahead and do that right now now before we We Begin developing in the Mojo programming language you're going to pop over to extensions in vs code here and then just simply go to Mojo like that and you should see this verified modular Creator and just going to go ahead and install this this is essentially the language support so it'll be able to read Mojo files Mojo files mean you can have this fire Emoji which I'll try to copy here and uh yeah essentially this this fire Emoji I don't know where I can paste it into maybe here no that didn't work uh anyways you can have your file extensions as this fire Emoji or the dot Mojo extension both of them work so that's pretty cool uh Unicode characters for file extensions gotta love it anyways I'm gonna go ahead and close vs code here and I'm going to make a new directory I'm going to call it uh intro to I'll jump and I can CD into that so you're going to go ahead and pop over to developer.modular.com download and this is just how you essentially get to downloading Mojo So Go download now and then says Mojo SDK is now available awesome and here it says setup on Windows Linux Mac Mac Intel well you might be wondering why the heck did he just tell us to only use a Linux terminal Linux environment well the thing is if we go to Windows it's not available for Windows yet but you can use it on the Linux container remote system you can use that with wsl2 we're just going to use Ubuntu for a Linux environment same thing with Mac right not available for Apple silicon yet but you can use Linux system and then to install Linux there's no warning there so awesome to install the modular CLI you essentially just copy this code here I don't know if the code is different for different people but you're just going to go ahead and copy this and paste it into the terminal here oh okay awesome so it's newly installed and then what do we do after this well we've been let's actually check our modular version so make sure it actually exists so we have modular here and actually another way of installing a modular is to Simply go sudo apt install modular that's a different way of doing it if you'd like to do that um but this way is more guaranteed I know some people get errors with the authentication key so just just be explicit and put this curl command next up we're just going to need to install Mojo So we go modular install Mojo we found a release let's install it cool and then we don't need the rest of this this is um already done so I'm just going to close this out and I'll come back when this is done so to begin to run our first Mojo script we're going to go ahead and open this in Visual Studio code or vs code for short and all you do is you just go code dot period the period just says open in the local directory so I go enter and we get it to open up in vs code right here so I'm not going to use this terminal anymore I'm going to use the one built into Visual Studio code so it'll do that if you're on Windows you just go control and then the grave symbol it's right below the uh Escape key so awesome we have this terminal opened up let's go ahead and make a new a new file so we go main dot Mojo and uh I'm just going to zoom in on here hopefully that's good enough all right I can it's cutting me off a little bit awesome we fixed it cool so in order to actually print hello world you might be saying you know can we just do can we just print out this way and we get an error it says to do expressions are not yet supported at paloscope so file scope just means that it's not inside of a function or a class so this is not inside of anything except for the file hence it being file scope level so this is global and Mojo doesn't like that right now so to counteract this all we need to do is just go FN main FN is short for function that's what functions is what functions look like in Mojo you just go colon like that and then print hello world and then if you really wanted to you could just do a variable here you could go let X or let's hello equal hello world and then you go in a print hello like that Mojo Main and so variables do work at file scope but we're going to dive more into that later but anyways we're able to print hello world this is great so some of you who use Jupiter notebooks might be wondering well how the heck do I get a Jupiter notebook running on my machine and for those of you who don't know what a jupyter notebook is it's essentially just a giant notebook it's like a white HTML notebook of a bunch of code that you can paste into code blocks and just run it in any order you want so anyways you're going to see what that looks like in a second and to do that you're going to make sure python is installed so make sure you go python3 version awesome and then to install Jupiter just go pip install Jupiter just like that so collecting Jupiter as you can see I already have a lot of the dependencies or requirements installed so now we can simply just go oh shoot there notebook just like that and should be able to open it up right there so as you can see this is what the Jupiter notebooks look like and I can actually create a new file make sure that it's in the Mojo kernel so you do Mojo and then you'll see it in the top right here if you try to open it up in the python the Python 3 kernel then it will not work so we could simply just go for example let x equals three and then go ahead and print X run that awesome we get three and then if you wanted to you could you could say print X down here as well and you would also get three so essentially everything carries down from the bottom from the top all the way to the bottom so you can store some variables up here and then just run them later down here as well this is used for a lot of tools in data science because or at least in data science and training models you'll have some you know trained model or something you'll have spend a lot of compute power on training a model and you don't just want to throw it away you don't just want to run a single script and then just not be able to use it ever again so you can either save model files which is a bit slower and you would do that with scripting or you could use jupyter notebooks and just save model parameters from a previous code block and then reference it again so that's essentially what this allows you to do and then I'm just going to delete all of these awesome so this is our uh notebook right now this is what it looks like so you can choose to code along with the notebook or not I will be using vs code so I'm going to go ahead and close this here uh I'm going to exit in order to cancel it you just go Ctrl C like that so that's how your Jupiter notebooks work I'm just going to right click delete enter awesome so that's Jupiter notebooks for you now we're actually going to jump into how the Mojo language itself actually works so now let's actually begin with some variables so what are the different types of variable declarations that exist right now so there's let which essentially is declaring the variable a constant it cannot change in in programming terms it is immutable immutable cannot mutate it cannot change it VAR means it's it can change so let is constant VAR is not constant so varlets allows variables to be changed hence it being VAR for variable meaning it can vary uh and then we have Alias which essentially just uh compiles it stores the variable at compile time so compile time is when it's converting your code to Binary form and runtime is when it's actually just like running code itself so if you have variables that are sort of compile time you might save yourself you know some some nanoseconds or milliseconds whatever it ends up being so most commonly you would end up storing what we call libraries with Alias but we'll go into libraries more later so we have let Varan alias so if we go you know let x equal three and then we were to print out X go Mojo like that and we get a A3 here awesome what if we were to change X to 2. we can already see a red underline there it says expression must be mutable in assignment so this x must be mutable meaning it must be able to be changed when we declare it with let that means it's a constant it cannot be changed so if we change the slides to a bar then boom we get a two so awesome and then if we were to just go uh alias it must be mutable in assignment so alias is essentially the equivalent of let but for compile time rather than run time so far is specifically for runtime and it allows the argument to be it deems the argument mutable and uh let deems the argument immutable but it goes at runtime whereas Alias would be immutable at compile time so awesome that's essentially just all the variable declarations and information you're going to need so next up let's go ahead and jump into data types so I'm just going to specifically use the let declaration here we're going to go let X and then you put a colon after and there are a bunch of different data types that currently exist so you can go you can use a string you can use an integer you can use a floating Point number or a float you can use a Bool you can use a unsigned integer and we'll go over what that means and that's that's pretty much it you have these These are the five uh common data types that we're going to be using there's one more that we're going to introduce later uh but these are the basic data types that you're going to be using so what is a string well a string good so we want to declare it explicitly a string and we let that equal and all we would do is we would put either some single quotes or double quotes around it or even these ones but I don't think it likes these ones very much so we're just going to stick with single and double quotes I like to use single quotes because you don't have to press shift when you're pressing the quote button just it's just easier that way and you don't have too extra quotes to see through anyways uh that's that's enough about quotes but essentially you could just put whatever you want in here any word I could literally put one two three and it would just say one two three but it's in a string form so it wouldn't actually be like the number one two three it would just be like I guess the word One Two Three or the string one two three if you will uh so that's strings for you you could put you know you could put alphanumeric symbols in it like like a question mark or like like a Pam symbol or a percent whatever you want uh so that's what strings look like next up we have integers so integers are any counting numbers I guess I guess you could say that so accounting number would be like pretty much negative one to infinity or negative 1 0 1 3 462 or something right um so integers are any counting number they don't have decimal places and you can either say int equals and then say like six thousand or you could be explicit and say you know int 8 equals six thousand and eight means it occupies uh eight bits on your memory so if you actually want to calculate what the highest number is that it could store it would be two since it's binary bits right and you do 2 to the power of 8 which is 256. so this could essentially store uh 256 different numbers on it or 256 combinations if you will that goes all the way from 0 up to it goes from zero all the way up to 255. so instead of 1 to 256 it would be 0 to 255 so just shift it over one but it's still the same amount of numbers so if I were to do 6000 in here it would actually uh it would not print that out it would it would actually overload our into Data quite a lot so if we were to lower this number to say you know 60 then we would get that to properly print out some other uh int bits I like bit occupying I guess you could use is n16 there's an n32 and an n64. there is no int 128 though so you just have 8 16 32 and 64. awesome and then if you don't want to put any any number after it it'll just default to N64 for for safety purposes uh so next up we have the I'm going to go over actually this this uint next because it's very close to the integer so U ins if I can type you end we'll just go eight for example I don't think you can leave it just like that unknown declaration must require an explicit variable declarations so that just means we have to put a number after it we can go either eight uh 16 32 and 64. so same as int and essentially U and what does the u mean well the u means unsigned so if we have a variable say so we have an integer it could be you know negative one zero one right that would be an integer can be negative numbers or positive and a uint would just be an unsigned so it cannot have a negative or positive sign and when we normally write out an and without a sign say like 60 we assume that this is positive if we go 60 you know plus 30 we're assuming that both of these numbers are positives because they just don't have a sign on them um so that's what unit means it just Only One Direction it can only go positive whereas the int just int without the u could also go negative so so do your range for like an INT 8 for example would be uh 255 to negative 255. uh we can actually type that out here 255 and we could print this out oh it's going to go to negative one if we go 254 Maybe 256 there we go okay so yeah 256 different ones I got a little bit messed up there but if we were to put say negative 256. you would also get a zero as well so that kind of just shows the range there and you go uint and uh I just don't think that would work so if you were to go like maybe negative one I wouldn't like that so I just default to a positive number so that's what antonuent are just signed an unsite enters and then next we have the floating Point number so a float is just a decimal number just imagine like 60 is an integer and then 60.01 would be a floating Point number just a float and to declare these we just go we have to actually write a little number after it how many bits it occupies if we're going to be explicit about it uh if you weren't explicit you would just go let x equal you know 3.14 3.14 and uh if you want it to be explicit about it you would just go colon float and then you would put however however many bits you want so you can't go eight but you can go 16 32 and 64. so if float 16 is just a essentially uh like a half Precision number if you will just lower Precision it's commonly used in machine learning for training models with like less numbers in them so float 16 is quite useful and a lot of Mojo cases but anyways don't worry about that too much that's just what these variables look like or these data types rather and then the last one that I like to show here go ahead and print that go to 3.14 and then some little error there I don't know why that is but that's that's something on the Mojo end that we don't have to worry about um but yeah now we have Bool which is the last one so we just do ol just like that and we assign it to a pool is either a true or false variable so just go true we have to make sure we have a capital first letter so it's case sensitive or we can go false if we were to type like 3.14 it would say oh cannot convert float literal to Bull so it's thinking that this is uh it's thinking that you're trying to put a float here and it's like we don't allow that we only allow for true or false so a pool can either be true or cross if we were to say print that out you get false so awesome that is all of the basic data types let's move on so a lot of people that come from languages like python JavaScript or C plus or just any other language really you might be asking why the heck aren't you covering arrays or lists or dictionaries so the reason is because they simply don't exist yet in Mojo I'll show you kind of a little bit of a cheat way to make an array but it's not quite the same but simply arrays just don't exist yet in Mojo that's something that they're working on right now so I can't really go over that because it doesn't exist but anyways uh what we're going to jump into next is how to get a user input and then just print that out for example because that's what a lot of you learned in Python an introductory python course is how to get a user input and then print it out So currently the simplest way to do that is to go we're going to import the python Library you could say go python from python uh import python just like that make sure the p is capital and then inside of this FN Main or outside of it rather you have to type a raises I'll go into more of why raises is needed later on but you just need that to be there for now don't worry about it and then we're going to go let's we're going to go let's pi equals python dot import module and then we would go builtins just like that so essentially we're just importing the builtins module with which comes default in Python if you were writing a python script you wouldn't actually need to import builtins because it's already done for you it just exists as a part of python so you don't really need that but in Mojo we need to explicitly import this and we're just going to give it a variable name py awesome so now we can go let some say user input equals Pi Dot input just like that so inputs exist as a part of the builtins module inside of python so we could just call input directly on that and then we could say um you know what is your favorite color let me go ahead and print out user input say it your favorite color is go Mojo what is your favorite color let's say I like green your favorite color is green cool so that's how you get user inputs in Mojo use the assistance of python which is a little bit funny but that's currently how you do it right now in Mojo so that's pretty cool so now we're going to jump into if else statements so what the heck is an if out statement well it's simply if a condition is met then you execute some code and if it is not met then you default to some other code and I'll show you exactly what that looks like right now so inside of our FN main I'm just going to set a variable X we're going to make it let's just say an INT we're going to make it an INT 16 and we're going to set that to maybe 100 okay so now we can we can actually do the if statement we could say if X which is what the variable name is and then double equals you might ask why are we doing a double equals well double equals because we're doing a comparison so if we do a single equals up here we are assigning uh the value 100 as an integer 16 2X we're assigning the value 100 to integer 16 data type 2x to the X variable if you will and all we're checking is that if the value of this x is equal to a hundred so this should actually just should go through so any code that you actually put under this you have to make sure that it's indented same thing for like functions I didn't cover that explicitly before but you do need to make sure that you have indents so that Mojo knows what to uh essentially how to interpret your script so we could print out huh true that wait wait get true awesome so if we were to change X to say 101 we just wouldn't get anything it would simply just say oh this condition is not met uh this this little block inside of here is not equal to true so in other words essentially all if looks for is if whatever this little block of code or that whatever this comparison is if it does not evaluate to true then just skip it and and if it does evaluate to true then we just print whatever is indented inside of the if statement so if you were to say to else this would be the defaulting that would occur so you would print uh failed and you would get failed because it says this isn't true so we're just going to default to else if this is true and then else if it's not then just default to whatever is indented inside of this else little block here and the last one which you may or may not use is called alif let's go LF just like this and we could do another comparison if x equals 102. then we would print same X is 102. so it's still a hundred it's not a hundred and one it's not 102 so it's still going to go to failed but if we change it to say 101 then we would get true if we change it to 102 we would get X is 102 and then of course if you wanted to add more of these lfs you would only have an if and then an out at the bottom but if you wanted to have like a bunch of alifs in between you could totally do that so go L if x equals say 103. X is 103 like you could totally do that you can have as many LS as you want in here but it does start to get redundant after a while so that's that's essentially how if L if and out statements work if you're wondering like what the heck does LF mean that's just like a blending of the word if and else so it's like taking the first two letters of L and then you know the word if so LF um awesome so that's your if statements let's go ahead and jump into Loops next so next up we have loops so what the heck are Loops well there's two types of Loops so there's there's a for Loop and a while loop a for Loop will typically execute iteration by iteration until something is met until an end goal is met whereas while would just go on forever until something is met so 4 would typically stop somewhere whereas while would just go on forever until some conditions are met uh so let's actually start off with a for Loop and a lot of you python people have probably seen this exact sort of form before but essentially we go for index or four uh iteration for iteration and in short we could just say 4i because it's less characters to type and we'll just go 4i in and we would go range and you could put any number here I'm just going to put 10. and then you put your colon indent and we're just going to go ahead and print out I so this is what a basic for Loop will look like shouldn't it clear this and we get numbers printed out from 0 through 10 or 0 through 9 sorry because it starts it actually starts at zero and then goes you know one by one until it until it satisfies you know a range of ten so ten different numbers there's a zero all the way through nine so if you were to shift that over one through ten um so anyways that's what for Loops look like and I'm going to go more into how we can like play around with these later I actually might do it after this Loop part but anyways next up you have while loops so what do while Loops look like well it's sort of the same thing as an if statement it looks for a condition being true so we could say you know while or while X is say less than 10 we could go X plus equals one and we would just maybe declare X since it doesn't exist yet let's say Lex or let X and then we would say maybe an integer say being into eight uh and eight equals zero uh must be mutable so we have to change that to VAR good catch uh while X is less than 10 we would do this and then just to you know make sure it's working properly but just print out X if I run that uh it'll print out I just oh it would print out one through ten so it'll start at zero it'll add one two x so plus equals you could also do you know minus equals or multiply equals or divide equals uh we're just going to do plus equals for this instance and that'll essentially just add one to this current value here so it'll add One X will become one then it'll print at X and then we see that's why we see the one first so it looks for until this condition is met until or while X is less than 10 once it becomes equal to 10 then we stop so uh X is therefore equal to 10 then we do this last editor and then it cuts off and then also what you could do is you could just put it true in here and then go uh you put a little if statement inside of it saying you know if x if x is say greater than or equal to 10. we would break so what does break do break is essentially like extremely simple it'll just stop the loop so if you put break inside of any Loop it'll just stop it and we can actually print this out over time so we go print X and we would get the same behavior so Loops are a little bit more complex but that's essentially what you have is you have your for loops and your while loops so I'm actually going to show a little like array I guess thing you could say with loops and all we're going to do is we're going to let X we're going to make it equal a python object so in order to do that we're going to need to actually import python up here so from python import python object and we're going to set this equal to say an array so we go 2 4 6 8 10. an array is just a list of numbers wrapped in square brackets and then each of these numbers here is assigned to an index so 2 would be index 0. everything starts at zero in arrays so to be at index 0 4 would be at the next one six would be at index two eight would be uh three and then ten would be four so if we were to say you know print X at position three uh oh why are we getting this cannot call function that would raise okay so we're gonna have to add braces in here again ignore the raises for now but uh essentially this this is a python array and we're just printing out the third index of it so zero one two three zero one two three and then it a three is equal to eight so we get eight the third index is eight so we get eight sorry um so that's what that's what arrays look like and we can iterate over these using a for Loop because we go four I in range and then we could just say I'm going to say 4i in X for example because X is actually the array itself so we go 4i and x and then just print out I oh I guess we can't do that we can maybe go range and then length go x dot underscore length and then under Splinter score maybe that'll work okay yeah so we could go uh X at position I and then we would be able to print all those out don't worry about this too much this is just me taking some Python and transferring it over to Mojo this little length thing this Len uh is just a short short form for length and then you put these around it because that's the that's the method that it calls but don't worry about this at all this is just porting some python stuff over to Mojo and it it's still being like mostly python so don't worry about this at all this is like not part of the course this is just me playing around with stuff but anyways now we can actually jump into functions so you might be wondering about functions and if you've done Python Programming before you've probably seen this def uh this def function so for example def add numbers you pass in two function arguments uh A and B you let c equal to and that the sum of A and B and then you return whatever C is so if a were to equal 2 and B would equal five you would say uh C is equal to a which is 2 and B which is five so C would be seven and then you would return seven which is C so uh that's what python functions or defs look like and in Mojo they're actually quite close so be an FN short for function and then you would put whatever your function name is you would wrap it in these round brackets you would pass in your function arguments and we'll go over these in a second here and how you can put function arguments into it from like actually calling the function uh and then you would put whatever you're going to return inside of uh like outside of these uh round brackets so you put an arrow and then whatever The Returned data type should be so in this example we go you know let c equal to uh an integer and that's equal to a plus b assuming these are both integers from here and then we would return C which would be again an integer because that's what the specified data type was and then since we know it integer we would return as an integer data type so sort of a that's that's the main difference between Mojo and python is uh FNS or FN functions are more explicit whereas defs are less explicit and they would take a little bit more time because um that computer actually has to like understand what you're doing rather than just having you know the rules just like hard to find and just like full steam ahead so that's kind of the difference there and uh so what we could do is actually go ahead and call this function so I'm going to go FN Main well passion no function arguments in here and I'll just go add numbers same let's X will that be an INT we'll say add numbers and we'll go ahead and pass in say two and five and then if we were to go ahead and print out what x is we should get seven just like that so let's actually walk through step by step what's happening here because to an inch like newer programmers this might be actually quite scary to look at so the reason we put add numbers above here actually if I were to put it below you might see that uh does it still work I should actually double check that okay I guess it does still work so you can have your functions in any order top or bottom and Mojo will be aware of where they are so you won't need to have something above it for Mojo to recognize that it exists um we'll just go ahead and put it back there though because that looks better so you have this you have this function add numbers you have a parameter a which is an integer type it just defaults to N64 because we don't tell it how many bits to occupy and then you have a b as well which is also an INT we say that this this function is going to return an integer type or an N64 type and we say let's see let C be an integer data type meaning this is a constant C is a constant integer 64 and it's going to be equal to whatever the integer A and B are equal to and then we would return C whatever the value is that's what you would return from the function so you call a function it does some operations and then the function returns a value to its caller so the caller in this case would be in our F and it would be on our main function so this add numbers is the caller here we pass in two integers two and five we make sure that this is a constant X integer 64. uh and then we would we would essentially just have the output of that so X would be equal to whatever this function returns which would be seven and then we could just print that out so that's essentially how functions work on the explicit level when you're explicit about what variables you're using then that's how that works so we could actually like replace all these ins with int 8. and then here as well you could go int 8 and everything be the same we're going to jump into a concept called object oriented programming so object oriented programming is concerned with these things called objects or classes or structs whatever they happen to be called in the programming language and anyways I I'm not going to philosophize about it I'm just going to jump right into it so uh the best way to really compare this is to look at what do they look like in Python and what do they look like in Mojo so I'm going to create a new file called main.py and this is what an object would look like in Python so just clear this drag it down so what's happening here we have a class called a banana um actually I'm not going to go through the class first so initially we have if name equals main it'll essentially just run this main function just it's just it's the way that Mojo works when you call this main by default it's the same thing going on here it just calls the main by default so this this main function is going to create a banana instance it's going to pass in a a bunch of arguments here and then we're going to print some attribute about this banana so what does this banana look like well we have an init so in it it you could think of it as a Constructor it makes it actually initializes the banana clasp so what are we actually passing in here well we have self is required we have a ripe attribute which would be Boolean so true or false a length which would be a float in Python and a color so a string and these are these are just things that I picked out sweet ripe could be like you know a floating Point number if you want to put on a scale for example but these are this is just what I'm working with um so in the in your init or in your Constructor you would say uh self you would say self Dot and then all the attributes for example self.ripe would be equal to this this ripe argument self.length these are just the variables of the actual class itself that's what the self dot whatever it looks like and then you have length and color so these are all the variables that we're initializing for our Banana class and then if we were to say call The Ripe attribute on on banana like we do here it would essentially just return whatever ripe is so we have a def ripe um we pass in self as a function as a function argument because it's a def it's a def function and then we're returning the Bool value so we return self.ripe which happens to be a Bool so we return Bool here uh and then we also have say a length as well I'm actually going to add the color in because I didn't add that in yet so we go uh def go color self and then we would return color which is a string so go Str and then we go return self dot color awesome if I were to print you know banana which is our we've created an instance of this object so you can have as many objects as you want and they have a bunch of different attributes and you can just call those attributes um so we go banana dot open out dot save like color for example and we would just go python3 main.py it's going to print out banana.ripe which is false as we passed in and then yellow because the typically the color of bananas are yellow I don't know what type bananas you eat maybe you eat red bananas but uh anyways that's that all works out nice and smoothly so uh if you want like feel free to pause the video and just try to like conceptually make sense of what this class looks like because these are very important classes and objects and structs are essentially the basis of all languages except for languages like C which don't have them but uh so in in Python this is what your object would look like and this is just a banana object for example so now we're going to jump over to what does this look like in Mojo So let's compare this side by side here so in Python we have a class banana in Mojo we have a struck banana in Python we initialize our variables with an init method uh self and a bunch of arguments in here with their corresponding data types and then here we initialize our variables with self Dot and then whatever the variable is equals whatever the parameter goes passed in there you could also do like lowercase that's fine too but I just find uppercase to be more consistent and it's like easier to read especially for classes I I don't know some people like to do it differently but that's just what I'm doing in this case so in Mojo you would actually Define your variables here you would say you know what the variable name is and you would say what data type it is you don't have to declare uh really what it's equal to but just that it exists it has a name and what data type it has and then you would have your init method here as well I'll go into this in out little piece here in a little bit but this is not in the basics of the chords this is a little bit after so uh you you get the idea it's sort of the same arguments in here uh you have yourself ripe length color uh selfripe length color uh awesome and then they're declared literally the same way as python in this like this block of code is equal to the same as this block of code um and then for our little methods here so you have or rather functions inside of the class you have a you have your FNS instead of defs ripe and then you would pass itself because that's self is essentially the object itself so self is needed in objects and then we say rhs because rhs is equal to right hand side and this is on the right hand side just it's just kind of a common practice you could say like value or or something else but it's commonly just seen as like rhs that's that's typically what it ends up being someone in in our death ripe we pass in a self and we return a pool uh and then we actually return the bull here so this is like what type we're going to be returning and then we return the actual ripe um variable if you will here we'd we also have this right hand side so we we pass in uh the banana itself and then we say we're gonna return a bull type and then we return this this ripe which is up we'll type hence returning pool here uh and then it's just kind of the same same thing it's a pattern for the rest of it so as long as this one makes sense as long as this init method makes sense and these variables make sense everything else below here should as well and in order to actually create an instance of this banana yes you can create multiple instances you would essentially just give it a variable you say VAR or let a banana equals and you would call this struct and you would pass in what variables or what arguments are required so you have a ripe which is a bull so we'll just say false let's say the banana isn't ripe um and we give it a length maybe it's 4.7 centimeters long the float 32. and then yellow which is a string so we have a banana that isn't ripe 4.7 centimeters long and is yellow so cool that's how you create an instance so you can actually go like you know for our I can't type banana two and then you would just you would you would essentially call this banana struct and you would pass in whatever arguments are required so hopefully that all makes sense and if we want it to say return the ripeness of this particular banana instance then you would just go called banana dot ripe so this particular banana then you would call The Ripe function on it the right method and you would pass in banana to it so this would ultimately return uh oh let me try this up banana was declared as a VAR but was never mutated consider switching to a lead so it's just giving us a warning and saying oh you're never really changing this instance so you may as well just set it to a constant because variable is is a mutable or not constant so we could save let and that would resolve that warning so awesome we return banana.ripe and we get false so cool that's what objects look like in Mojo versus python so hopefully that hopefully that is super clear now if something didn't make sense totally feel free to uh pause the video look back play it on half speed even chat gbt your way through it because that's honestly how a lot of people learn nowadays and it is a pretty good way to learn as to at least with these basic concepts is to just plug it into gpd4 and say hey I don't understand this or if you you have a particular question about maybe the init method like why is it called why does it have two of these underscores around it right you could pass that into chat CPT and say hey why why is this why is this a thing and then I would hopefully be able to help you but as for Mojo specifically uh chat gbt isn't really trained on it because its cut off was 2021 so your best bet would just be to go to the Kappa AI in the modular Discord and just ask it that way so that's what I would recommend if you don't understand something is to just ask the Kappa AI um anyways let's move on so before we actually jump into importing libraries modules just other people's code in general uh I should let you guys know that inheritance uh inheritance exists in Python uh essentially if you don't know what inheritance is essentially it's imagine you have a a class and it's an animal you have an animal class and you have like a dog cat or a dog class and maybe a cat class maybe a giraffe class okay you have a bunch of animals and then you have this one main animal class so typically what you would do is instead of writing all of the dog cat and maybe giraffe classes from scratch you would inherit some of the attributes from the animal class so you'd have some like General variables and some general things to find in the animal class and then you would inherit those uh in the uh in those other animal classes so like the dog cat and giraffe so that way you wouldn't have to write a bunch of code that way so you would just inherit and it would be less work for you and essentially this is actually how a lot of games work so if you have like you know different enemies uh typically you would have like an enemy class and the enemy would have some attributes like when you touch it or when you get hit by it then you take damage or you can do damage to it or they you know they they only spawn in uh danger zones or whatever it is and you would have you know a bunch of subclasses that inherit from that initial enemy class that would say oh these are some things that are describing uh each different unique enemy but it also has these General attributes that all enemies have so that's just what inheritance is and a general overview but it does not exist in Mojo yet unfortunately so we are able to create classes like these and pass in attributes to them but we cannot actually use inheritance we cannot inherit from other classes yet in Mojo that does not exist so anyways let me get rid of this here and we can actually begin to import some libraries we're just going to import one so we're going to import from python a lot of the libraries here we're going to just import them from python so we could go from python uh oh not capital I import python just like that and then we record an uh F and Main and we would need raises here and I figure this is a good time to tell you exactly what raises does so raises essentially you need to include it in functions that could potentially raise errors so if you were importing a library from python say like numpy for example uh some of you might be familiar with numpy and sometimes you might get errors importing that or at least you might get little underlined saying oh what if this messes up what if the library doesn't exist but we're still trying to import it well then you would just say you know the function raises what raises means because it can raise an error the function is capable of raising its own error aside of Just The Interpreter and compiler so uh this is just super useful I'm going to go more into depth into raises and all of these errors and exception handling a little bit later on but essentially it's just to say we might get errored out but don't worry about it too much because we're sort of expecting it in a way um so we can go ahead and uh you could just create we could just import numpy here so we go let's numpy and then oh not that python import module and instead of builtins like we did before we can go uh numpy just like that and then we can essentially create arrays with numpy so we go let's array ARR for short for array numpy Dot array and then we would put our array in it so maybe you know one four nine 16. a bunch of squared numbers uh and then we could just say print square roots uh now we don't have to do that we could just say print array times two and then we're just going to Mojo Main dot Mojo and 1 times 2 2 4 times 2 is 8. 9 times 2 is 18. 16 times 2 is 32. so we actually get that returned in the numpy array form so that's essentially just how you import modules in libraries as you would you would do from whatever and then import a certain you know sub object or whatever and it's it's very similar to python as a matter of fact it's like the syntax is the exact same except your the libraries just look different when you're importing them uh and then to actually import it from python you would do this python.import module and then whatever it's called so if you're going to import tensorflow you would put you would put tensorflow here if you were to put numpy you would do just as we did before and Etc so uh later on in the course I'm actually going to show you how to create your own packages so uh so instead of just importing them from somewhere else on the Internet or somewhere else that's like downloaded a part of your mojo but you didn't create it I'm going to show you how to create once and then use them so that's a cool little feature that modular has been uh super you know easy going about I guess it's it's just really easy to make your own packages in this language and in this whole modular framework thing so I'm going to show you how to do that a little bit later but for now let's just jump a little bit more into what exactly does raises do so in Mojo we use four error four words for error handling so as you've seen before we use raises and raises is uh essentially in any function that may raise an error needs to be explicitly marked with this as we went over before it's part of Mojo's error handling semantics uh so oftentimes you're going to use this when you're importing other libraries because it may or may not work right you may have an error there um but most of your errors will be raised automatically by the compiler and interpreter so don't go like out of your way to just include raises in every single function if if you are getting little underlines like red underlines like errors uh just try to include raises and then see if that changes anything but you shouldn't need to explicitly include raises in every single function um so that that's what raises does you put that after the round brackets of a function to essentially say this might raise an error um and then this try try accept and finally all go together so I'm actually going to paste in some code here that I've gotten from before so we have a function main raises so it might may or may not raise an error and we just explicitly declare that and then we have this try so what does try do try will attempt to run some code for example open a file so let's say we have some input.txt file over here and we're trying to open it and maybe like read the contents inside what try will do is it'll maybe we'll try to open that open that file we'll try to open it we'll create like a new resource for example and then open that file with the resource and then accept will look for an error say a file encoding issue say our file is like has some corrupt data in it the encoding is messy for example uh and accept will essentially just catch that error and say hey uh we found something and then here's a little error reporting on what it was about if this code fails so it'll attempt to run it if it's successful it'll just go all the way through in this except block will not be triggered but if there is an error then this will still finish and we'll get a we'll get an A little uh what we can essentially raise an error so we can do raise instead of raises we just do raise and then error because we're raising an error right it kind of converts to English easily that way uh and then you would just in round brackets put whatever your error reporting is so you have an error number you would go like error number one zero three nine or or whatever you do um awesome and then this finally is very important in some cases not as important in other cases but I'm just going to use an analogy for this so imagine you're trying to say uh open you're you're trying to open a microphone resource here so this microphone that I have right here let's say I want to just use it with like Mojo or something even though it's not supported yet um imagine we're trying to open this microphone and we're trying to record something so we attempt we attempt to open the microphone resource and then say we get an error with like maybe there's something wrong with the microphone who knows um so we get an error it says something's wrong with your microphone fix it but what this finally does is instead of just stopping at this error and then terminating the code finally we'll instead uh still follow through whatever is inside of it whatever this indented code is inside of the finally block so if we were opening a microphone we probably don't just want to leave it hanging we probably don't just want to have it you know go on forever and just essentially leak the microphone right we don't want to be leaking that resource at least to other errors that you don't want to deal with and essentially finally just says I got you covered man we're gonna we're gonna take care of that so typically and finally you would just essentially close that resource so we oh we attempt to open a resource we say it fails instead of stopping there we stead we instead guarantee finally guarantees that we actually follow through with whatever this code is and there we could close the file instead of having memory leaks or resource leaks so finally is really useful there if you're taking advantage of resources but if you're just trying to you know attempt some block of code and then you see if you get an error see if it faults then you wouldn't really need to finally block for that finally it would just be you know when you need to run something even though there's an error that happens so that's kind of how that works that's that's pretty cool uh very good for debugging of course if you're trying to if you if you think your error is in you know some piece of code then you would put try around it and then if it errors out be like oh so that there's some like specific thing wrong with my code it's in that section and then you can debug further um but yeah if we were to Instead try to close the file after it errors out if we were to Instead try to close it down here uh that wouldn't work because this code isn't guaranteed to run once you uh once you post it once you raise this error uh essentially nothing else other than finally is allowed to execute code so you raise this error and then immediately it says we have an error we cannot execute whatever this is but finally says we're guaranteed to execute this no matter what so hopefully that clarifies the whole uh error handling exception thing uh what we're going to do now is we're going to go ahead and move on to some of these function arguments like in outs and some other ones that you may or may not have seen before so what the heck are these function arguments you speak of well function arguments could be one of many there's like quite a few I'm meaning like three or four in this language and the first one I'm going to cover is called in out so what this means we we already went over function so I'm not going to go over that again but essentially when you mark a function argument within out it means that that argument is mutable or changeable and changes made inside of the function so meaning changes made to for example a we pass it in as a equals 4 and then we mark it with n Out um and we change it to three then that change would also be visible to everything outside the function so I highlight the words inside and outside because that's what in out comes from in and out changes made inside the function are visible outside and out and then the next one is called borrowed so let me go ahead and copy I've borrowed code in here not really borrowed I created it but we use this label or called borrowed and this essentially just labels these explicitly immutable meaning you cannot change them so if we were to say to Mojo Main dot Mojo um we initialize a a and b so we have a four and a five we call add nums on those uh and let's say we were to try to change it to uh let's see if we're to change you know a equals three and then b equals two well why are we getting underlines expression must be mutable in assignment okay so what if we change it to in out for example and out because argument zero must be mutable in order so argument zero is essentially the first one it's catching the error on the first little function argument here uh in order to essentially run our code so uh notice that we've declared with let so if we change this to VAR then everything works so we set a to 3 and b to 2 we get five um but if we were to say set these two borrowed then this wouldn't work because these these initially are variable meaning they can change they are mutable and then we explicitly label them as immutable meaning you cannot change them and inside of the function so Express expression must be mutable in assignment so essentially that's what borrow does it says this belongs to the other function and we're not allowed to change it even if in the other function you say that it's a VAR or variable um so yeah that's that's uh in out and borrowed for you and the next one I'd like to cover is uh owned owned is an interesting one Owen will essentially say with with whatever variables we've labeled here that those variables now belong to this current function so for example even though we uh initialized uh these variables as immutable using the let declaration uh when we pass them into here using owned it says okay now this function owns them so we can do whatever we want so this essentially takes off that little immutability feature and says we can do whatever we want to them and if I go ahead and run this code uh you'll see that so now these actually belong to this function and they are now mutable so uh if I were to say you know something else like if borrowed then that wouldn't work because we're taking it we're taking it from this function here if I were to even go like that it would say expression must be mutable because we're initializing it as let over here which is immutable we're trying to change it even though it cannot be changed so essentially own says um it's just explicitly saying that this this current function which owned is in uh we can do whatever we want with that variable this function now owns it so the next statement that I want to cover is called with so the with statement you may have seen this in Python before but like especially in Python width is typically used to open a file so in Python you would go um so with open here we go input.txt and you would go right or read sorry and then as F you would go say text equals F dot read and then we would print out some text if I were to create an input.txt say you know peekaboo maybe we go in run this main file and it would open this in read mode as F or file and we would read the file put that in a variable and then print that variable out so essentially What's Happening Here is with is acquiring a resource meaning files right we're acquiring a file read maybe a write resource and we want to make sure that after we're done with the resource that we dump it so we're going to open it we're going to use we're going to use some file reading and writing resource we're going to do some code we're going to do something with it and then we're going to close the resource afterwards um this isn't this isn't too common with Mojo yet it doesn't really doesn't really exist doesn't there's essentially nothing you can really do with it right now um so I'm not going to worry about that at all you might be asking what is the difference between with and like a try except finally block well the thing is is that with uh by default isn't really going to uh run some code no matter what so typically in the try except finally you would attempt some code you would potentially throw an error and then you wouldn't do some stuff after so um I'm not my awareness of the whole with statement isn't like too indepth but uh I know there's there's definitely some differences there in terms of how it compares to try except finally versus just with so you could actually look into that on your free time but we're not really going to be using with in this course at all so don't worry about it so next up I want to cover something called variable scope so in Mojo you would typically see like you know let's say x equals three and then you have a FN Main and you would say maybe y equals say let y equals four so this is a concern with something called variable scope so variable scope is like you just have a variable and then what is the scope of it so this one would be file scope since it's in the file everything else in the file can access it if we were to go ahead and print X we would get uh we will get an output there so we this uh this is included in all the functions so all the functions can access like file scope or interchangeably Global variables file scope and Global scope variables are pretty much the same thing and whereas this let y would be specifically in the function so if I tried to uh you know if I had a different function to I don't know who I would show this but essentially this is specifically only accessible to this function only so there can't be any other functions that can access y so if I if I said um if we had another function say FN print y uh and then I work to you know say print y we return that uh come on let me just keep that all right move this up and then we were to say Maybe print y will return whatever Y is whatever Y is equal to so it'll say unknown Declaration of Y uh require explicit variable so essentially saying that y cannot access this y because this Y is specifically in the main function so therefore other functions cannot access it so this is what we call local scope so local scope just means it's like defined to a specific function or a specific struct or something um and that's essentially what variable variable scope is so if you've worked with python before you've probably experienced some errors with variable scope um but anyways that's just essentially saying you can't make a variable in a function and then call it in another function without like passing in the argument of it so that's what that is now let's move on to some of the tools with the Mojo Mojo command line interface or the Mojo CLI so if you pop over to the Mojo modular documentation here and just scroll down to the Mojo CLI and go to yep you could just essentially click on maybe just click on Mojo and you'll see that essentially this Mojo thing is actually a command line interface in and of itself so we've seen that we can call Mojo files or we can run Mojo files with just the Mojo keyword and then pass in whatever file you're running very similar to python you can use modular to of course update Mojo but modular is not really the focus of this it's more like Mojo command uh commands so Mojo run built and executes a Mojo file I won't be really using this much because it's not as important but what is important is this little build command here and this will actually accelerate your speed by quite a bit not by like 5 10x I mean it might but it honestly depends on what you're doing anyways let's just cut to the Chase and I'm going to show you what build does let's actually use this Mojo build command so I've I've just ported some code that I've written to essentially test uh Pi torch on both CPU and GPU so we went over sequential processing and parallel processing uh this is essentially just doing that and we're just comparing speeds so uh you don't this this is probably scary to look at at first but essentially if I do uh Mojo Main dot Mojo give it a second Cuda okay and we get a CPU time a lot of this time is spent actually importing the packages itself so now some of this is going to be spent you know so some of it is going to be spent on Cuda time as well so CPU actually performed almost 5x better than the Cuda time which is insane and if I wanted instead build if I want to instead build this into a binary form and then run it which should be faster I would just go Mojo build and then main dot Mojo just like that and we should see main binary file popup in order to run this we would just go uh dot slash dot slash main we can say we get a Cuda 1.2 seconds or sorry CPU 1.2 seconds and Cuda is sped up by quite a bit so this sort of just proves that normally running Mojo in this way is less efficient or less less quick rather than making a bill uh making a binary file using the build command so if you're just testing around and playing with things in Mojo you shouldn't really need to build it but once you're ready to push it and like really like see what the limits are of of that file and just see like how fast can this possibly go then you would want to use the build so if you're pushing something to production or you just want to you know say in the future you're able to train some neural network and you want it to go as fast as possible you might want to use the build command rather than just running it normally so anyways that's how that works it's fairly simple you just build this and then you do dot slash and then whenever the name is in this case it's main so uh awesome that's how that works now we're actually going to go into how you can build your own package so for example python is we're able to import it it counts as its own module or library or package whatever you want to call it and we're just going to create our own we're going to create some object or class or struct and we're going to import it into a different script even though it exists on a completely different place on the computer so I want to build a package just to use to maybe use later and so first of all we're gonna have to go to the docs I skipped ahead a little bit there but essentially you go to Mojo uh and then I might full screen this for a second or just CLI and we go to Mojo package and then uh so there's a whole description here about just like some extra options you can pass into it but what we really care about is this see more about modules and packages so let's go ahead and click on this I'm going to drag this over to uh like a split screen and we're just going to follow the instructions so provide the packaging system that allows you to organize and compile code libraries into importable files so when you like import python for instance you go from python import Python and then you can use some of the builtin libraries it's essentially like that except we're big we're making our own libraries uh introduces necessary Concepts blah blah blah and to understand you don't understand motion modules so single source file that includes code suitable for use by other files that import it so you can create a module to define a struct such as this one so let's go ahead and follow along I'm going to go ahead and uh actually we're going to scroll down just to make sure we have this structure correct because there's a structure down here that we're supposed to follow uh so we go make a new directory we call it maybe uh my package and then we make a new file inside of it we go init .mojo and then we make a my module dot Mojo awesome and then we have our main here it's awesome these are all empty what do we put in them next so we have this my module.mojo here so we'll just pop this in and let's let's first look at what this does this is a struct uh we have some we have some variables uh two integers essentially we're just making a pair hence it being called my pair uh you those those are essentially just the the instance arguments that we're going to pass in when we call this with our package so awesome now what now we have a main dot Mojo so we're going to have to actually import from this we're gonna have to go my package you're going to see this a crash happen in the Mojo parser so I can actually go ahead and run this main dot Mojo and it we're getting aborted this is currently still something that Mojo was figuring out right now I was running into this error quite a little bit and we're just gonna sort of Go full steam ahead and we're gonna go to the end result that we actually want we're not going to be concerned about this for too long so for example import something that's in the same directory so so essentially what's happening when we import this we have from so it's going to come from somewhere else so it's going to come from the my package directory dot my module so it's going to come from my package dot my module and we're going to import my pair so that's exactly what this like quite literally what this says from my Mac from my my package.my module import my pair and so this should work fine and really all we have to do to fill in the blanks here is essentially just create we're going to create a package out of this and you can leave the init.mojo you don't have to edit this at all so essentially uh how this goes is we just go Mojo package and then we look at whatever the name of this package is called save my package we're going to do Dash o and then whatever name we want it to be just be like maybe test pack oh testpack dot Mojo package and you have a nice little Unicode character here as well which is really cute so just a DOT Mojo package file extension and we can go ahead and create that and we see that it shows up here so in order to actually import this into our main dot Mojo now we see that it's in the same directory it's in the same local directory as main dot Mojo So these are together so we don't need to like import from something you know far out all we can do is essentially just go from testpack.my module because keep in mind it's still going into this my module instead of my pack but this is just compressed into like a shorter form so if we go ahead and run main dot Mojo now we should see uh main dot Mojo we get two and four we passed in the pair two and four and we get that output so that's that's really it that's that's honestly how you make packages just uh you make sure that you create a directory in the local folder and then you put an init Mojo it has to have two underscores on both sides and then whatever your module name is called and then you do whatever you need to in here maybe a struct maybe a few of maybe a few structs if you want and uh that's that's pretty much it so that's how you create packages so we just covered two of the command line tools that Mojo uses so Mojo build and Mojo package so uh if we want to actually look at some others you could just go down to Mojo here and we we can see that we have we have run build which we already did uh repl that's not something I'm going to cover in this video we just did package formats I don't think this is as important uh docs I haven't seen a lot of usage with like deem angle dot format a little bit of Rebel but uh just just for like the basics and creating your own packages and building a binary executable files build and package are going to be your Best Bets if you want to you could totally dive into other commands but those are the only that I feel like are very necessary for the basics uh anyways you should give yourself a pat on the back you made it really far and there's actually only a few more Concepts we have to cover there's there's not that much you're like almost done so give yourself a pat on the back grab some coffee or whatever you do and let's jump right back into it so I want to introduce the coolest data type ever it's called a simdi so what does simd stand for what is this Cindy what does it mean well simdi is short for single instruction multiple data so that means you can have say an array and instead of doing an operation on each element in the array you just do one on everything so it's only one operation so what does this actually look like if we were to say use python so in Python you'd have like an array say maybe you know two four six eight or two four and essentially you would have to Loop through this entire array and do an operation date element let's just say we're multiplying by two so you have to go through each element you'd go to the first index you would you would set the new you set a new array to equal uh what is this times two and then what does this times 2 and then what is 6 times 2 and then what is 8 times 2 you would do all of this sequentially but Sim d is different so you can just do times two one time you multiply the entire thing by two and it's done just like that in one operation it's essentially a CPU instruction so it's it's a it's an easy way to write it but essentially CPUs accept a certain type of instruction or the CPUs will accept some instructions that will allow them to take like shortcuts and loopholes around things so 70 is an example of that where you don't have to iteratively multiply or add things together you could just do it all at once in one operation so for example if I were to print say x which is the 70 and then I multiply by 2. I could run this and we would get essentially everything multiplied by two and this all happened in a singular operation so next up there's a there's an interesting uh I guess method you could say we could call on the 70 type which is len so Len is equivalent to essentially length of x in Python that's what it would look like but in Mojo we would do x dot when and then so just some round brackets so this will print out four because we made the length of it four and this is a good time to actually delve into what each of these parameters are so first of all you initialize a variable say let x equals and then we could just say it's equal to a single instruction multiple data data type and then we have some square brackets here and inside of these square brackets you're going to pass in the data type that you desire it to be and the length of this multiple data if you will and so to do that we use D type and then dot whatever you want it has a this this data this data type needs to have a lowercase letter so you can't just do like float 16 it has to be a lowercase letter um and then this uh this four is essentially just how long it's going to be because it's one dimensional it's just like one dimension so after these square brackets you just have these round brackets here and this is the contents of what you want and there's an interesting thing we can do with these because consider these this is four elements here and we explicitly declare that this is going to be four elements long so what happens if we add a fifth in say 25. and then we print out what is X multiplied by two we get uh this number we get this Sim d uh returned back so this essentially means that we're going to take the first four numbers of whatever you put in here and then everything else we're just going to splice It Off so that's a cool little feature I don't know if that's a feature or a bug but I think that's pretty cool how you don't get errors for doing that so anyways there's a lot of operations you can do with these uh you can there's certain ways to make like a really long uh what we call Vector that's just the same exact number all the way through um and this actually leads me into a little bit more Deep dive of what this Sim D type is so let me go ahead and just uh get rid of this and I'm going to copy some code in oh so we have a function add and we have a function main no no don't get scared by this too early so what does this function main going to call well we're going to let x equal the same D type float float 16. it's literally the same one we just used and we're gonna we're gonna pass it into a function called add so x and x so what's actually happening in this add function well first of all we have some uh we have some square brackets here this is going to determine uh what the data type is and what the length is so these are the two uh essentially needed function Arguments for operating with simd types so you would essentially give a name for what the data type is so D type we would give that data type and then the lengths we would just set that to the data type int we could it could be like an in 32 and 64. it doesn't really matter we're just saying that's going to be an end here so this is like converting your data types to names that we can use later now we have these round brackets and notice how oh notice how these actually stretch out quite far so in here we specify the actual function arguments themselves what is this first X going to be that's going to be a that's going to be this piece right here so a is going to be a Sim D type with data type D type and length of type integer and then same thing for B here except we can't just we simply can't have a twice because that would that would give us errors so we're just going to do a and b so next up we have uh we're essentially just returning what this is what this entire function is going to return which of course has to be a simdi type with a data type D type and integer so that's that that's a lot of content but essentially all that really happens is we just add them together it's a single single operation that we do and if I go ahead and run this here we will get uh this we could even we could even multiply them together can even multiply them one times one four times four nine times nine and sixteen times sixteen we could even divide them if you want since they're a float float 16. so everything divides by itself or if something divides by itself it's equal to one so that's why we have ones there but anyways these instructions are super cool I'm not going to dive like an insanely amount I'm more into them but we're going to use sim D types A little bit later on to do some speed tests but before we jump into that I want to cover some other uh Concepts and topics the next one being decorators and meta programming so I've just kind of implemented it it doesn't really do anything but this is what it looks like this is called a decorator and decorators come from a practice called meta programming where meta programming implementations look at the code architecture you've attached the implementations to and have the code optimize itself based on the specific meta programming feature you're using so uh in the context of unroll essentially what this does is it unrolls the loop you have some Loop and it unrolls it into a bunch of individual uh iterations if you will so if we have if We're looping over this 10 times if we're doing I 10 times instead of going sequentially it'll split it out into 10 different uh individual Loops that it'll uh individual iterations that it'll do um and so we can even pass parameters into unroll we could go for example uh two and what two would do is it would split it into iterations of two and loop over five times so there's a bunch of ways that you can mess around with these meta programming features they make everything super hackable hence the word meta programming it's it's a beautiful word and this essentially allows you to take advantage of maybe parallelizing some operations maybe you have a loop where instead of sequentially running it you want to split it into a bunch of individual iterations and then plug you know say a fraction of them into each processor that you have and have it done in a fraction of the time so little optimizations like optimizations like this will greatly help performance but meta programming has always been sort of an advanced feature so I thought I'd share with you uh what exactly they look like and an example of what one of them does meaning unroll but they are an advanced feature so I'm not going to go super into it this video however if you are interested and wanted to dive deeper into decorators and meta programming I would highly recommend that you refer to the documentation so let me now show you the case for an up to 77 000 X beat up over python it's blown a lot of people's minds in the past little bit but so if we just go to the modular documentation here uh just docs and then Mojo notebooks matrix multiplication and Mojo just scroll to the top I'm not going to walk through like the actual Matrix multiplications going on the algorithm here isn't important a fact of the matter is is that we just need to plug these code blocks in and see how it progresses based on what features we add to it and what optimizations we add so what I've done is I've ported all of this code block by block all N2 and you can see they have a 77 000x speed up and I've ported all of this into my own notebook here so I've already run everything and as you can see uh initially we get you know 0.001 gigaflops and then after an optimization we get a 0.01 gigaflops which is an 8X speed up and then like everything here is uh compared to the original by the way so everything is compared to the first three code blocks so we get an 8X beat up and a 3000x speed up and I'll go into what exactly well what exactly is making it go up to 3000x and then a 13 000 X a little bit more and then at 22 000x and then 19 000 just due to some Hardware stuff it could go up or down depending on your Hardware um and then it just kind of settles around a 20 000 X beat up and this is just for my machine again mode uh the modular team probably tested it on a machine that was favoring this code that they used so there might be other ways to optimize around your own Machinery but that's not something you should worry about as a beginner all you should worry about is what are the fundamental uh what are the fundamental concepts and practices you can use to get the most significant speed up without over complicating your entire thing so if you can get like a 5000x speed up and it takes you five minutes to implement it maybe just stick with that maybe you don't even have to go to you know a 10 000 X beat up because that's just that's just making it twice as efficient it's not as big as a uh a 5000 x jump so anyways I'm gonna walk through this uh sort of what's Happening Here so initially uh we're using python to do a matrix multiplication and the thing with python is that it's not very good at running code on multiple CPU processors so if we actually look I can check my current CPU processors if I go to uh performance we go to CPU and it'll just say logical processors here or your threads logical processors and threads are used interchangeably so you can see what your number is there and that's essentially how many processors can do computations in parallel so initially python is only using one of those 12 threads and then what we do afterwards through uh through this next jump let's take a look and see what it's doing so what this appears to be is instead of using all python we're actually jumping over to some Mojo syntax so we're using FNS and we're being uh more explicit about what types we're giving things we're being more explicit we're getting more to the point about what exactly the code is time to accomplish and then I'll just navigate back here because it's hard to follow along when everything is black and white so initially we use One processor and then we use some modules from Mojo and we use some Mojo based kind of syntax we do some importations here uh then what then we add types okay so yeah just just adding types in is going to give us significant speed up and then and then we have a benchmark function which is built into Mojo and it's used to just sort of do speed tests like these do benchmarks so now we get into the the cooler stuff that I actually enjoy talking about so one is vectorizing what the heck is vectorizing so imagine you have uh you're you're in a I mean some of you have probably taken introductory physics before or something close maybe a science class and so when you think of a vector you think of a direction and a magnitude a scalar is just a magnitude but Vector has a Direction with it as well so for example um if you were if you were say had a velocity maybe you'd be going you know 10 meters per second at this you know amount of this this amount of degrees right so you'd have some direction and a speed at which you're going in that direction so that'd be a vector so some ways to actually store that would be maybe an X attribute so if you have a you have your little hypotenuse here you have an X attribute and a y attribute so you have your X as one in your in your zero with index and then you have your y attribute in the first index and then you have maybe your um maybe your direction in the uh in the second index and if you wanted to increase the dimensionality of this meaning if you wanted to instead of just have two Dimensions you would go to three so you're having vectors in 3D space or you could just increase it up to like 10d or 100d whatever you wanted to and essentially vectors are ways to describe uh essentially Direction and magnitudes in it any dimensional space so with vectorizing we essentially convert things to the Sim D type and this allows us to do these Matrix multiplications with far less operations so I was talking about the simdi types before and we're essentially just treating our vectors as some D types and then working with those so that's what vectorizing is converting to something that you can do one operation on that's going to scale up computationally wise and we can see that we get an insane speed up there so 1600 all the way to 7000 so we've just sped up this a ton just by using vectors then what's next so parallelizing so you might think parallelizing has to do with the GPU but in this case it doesn't actually what parallelizing does is instead of just using one thread we're going to be using maybe not all 12 but pretty close like maybe 10 or maybe eight of them or maybe 11 who knows we'll be using a lot more of these threads or logical processors essentially in parallel so imagine you have a giant piece of data and you have you know four processors that can go through it so instead of having one processor or each of them go through the same amount of data just from from the start all the way to the end what you do instead is you give them each little jobs so the first processor can do the first quarter second processor second quarter third processor third quarter and Etc you split it into jobs and what ends up happening is everything is run at the same time all the processors are run at the same time and each of them complete uh their jobs at the same time because these lists are or these pieces of data you have to sort through are now a quarter in size in comparison to the entire length so now you've just essentially decreased your total run time by a quarter just by having four processors that you're running things on So based on the number of processors that Mojo is allowed to access this is governed by the operating system and some other features I'm not going to get into but essentially that's what parallelizing is is splitting a task among a bunch of processors instead of doing the entire thing on one so with parallelizing we go from 6800 all the way up to 62 000. so in this case they probably had a lot of processors that were being utilized to get this 10x speed up compared to uh about 6000 x beat up uh and then the last and then the last one that's quite interesting is called tiling so tiling and tiling is an interesting one uh the best way to sort of conceptualize this is to think of a giant grid of numbers like a giant two by two like a times table if you will a giant two by two times table and instead of calculating everything all at once and this this might not be like a 10 by 10 times table this might be like a a 500 by 500 times table or even way way uh larger than that so what piling allows you to do is instead of uh doing everything at once and drawing it from your RAM your slow memory it will cache it in your CPU your CPU has little RAM chips that are way higher bandwidth and they allow uh information to be transferred almost instantaneously so what this allows you to do is essentially load in little bits of this times table at a time so you can do computations on them so say you want the first you know five numbers one two three four five one two three four five so you've got a you've got five times five there you've got essentially 25 boxes that you're gonna do instead of say 2 million or 2.5 million or there's some crazy number and you can load these into your caches your CPU caches preemptively so you don't have to do this right away or else that would that would essentially degrade away at your runtime constantly having to move things into your cache and then use them that just adds on to extra time so the compiler could be smart and instead of move over what it knows it's going to need before it has to use it and then once it's actually asked to do those computations it can like very quickly draw from that little cache uh and then get the next one in so that's it's ready to do the next computation so this way you're saving time uh from avoiding that giant delay and drawing all of that information from your RAM and rather just having it ready in your CPU caches and to look at those we can see our CPU caches we have an L1 L2 L3 so your L3 would be the slowest L3 would be or sorry L2 would be a little bit faster than L3 and then your L1 is like extreme speed like this is almost incomprehensibly fast and so probably a lot of these uh this tiling operations are going to be stored on your L1 L2 maybe L3 cache so that's kind of just what what what's happening with uh tiling when we do matrix multiplication it's like storing times tables in little uh tiles essentially hence it being called tiling and that way you're saving the memory uh draw time the transfer time so that's vectorizing parallelizing and tiling for you so hopefully that all made sense if it didn't totally chat GPT your way through it man I totally encourage you guys to use generative AI to help understand the stuff better it's such an amazing tool but anyways that pretty much sums up uh everything that's this course covers so bear with me I'm going to do a little uh outro here with some more little facts and stuff that you may want to know about the language and so next up I'm going to walk through how to report errors and actually before you actually report any errors there's a lot of things you have to check over first so one uh actually just go to the Mojo bot help and then type you know Kappa AI I have a problem and then it'll open up a new thread and you can ask it questions just by tagging it through the at symbol so Kappa AI is essentially memorized all of the Mojo docs and knows everything about modular so you can just bombard your questions with it it's not a human so there's that and then also being able to search through errors through this search bar this is a huge help so what if I uh say like environment variable and then I get a bunch of uh I can go new old or relevant and get a bunch of data about how do I read environment variables in Mojo right like there's a bunch of comments here so you might be able to find your error maybe someone else has already ran into it and they've gotten an answer or you can collaborate with somebody else in this Discord server so this will be in the GitHub repository and also you want to make sure I'm going to go to github.com go to Mojo and if you're actually looking at an error what you want to make sure is that you check issues because there's a lot of errors that have been asked here there's actually like a lot of pages of errors so what you might want to do is just take a quick scroll through these and just look for any keywords say you know maybe I can't access environment variables and you go to the next page and then nothing is found here right and you keep going through your pages and just look for your keyword essentially to see if that and if anybody has ran into this problem before and to see if it has been answered so that way you're not just bombarding this whole issues issues page with the same error twice because if you have the same error twice then that means they have to you know it's that's a little bit of a hassle for the modular team and you don't want that because you want a good programming language faster so just be cautious about that it shouldn't be too hard to look through and just see if errors have existed yet just look through the GitHub look through stack Overflow look to the Discord server ask the Kappa AI and then your last resort is probably going to be if it's at fault of Mojo So if it's not your fault it might be Mojo's fault and it's something that nobody has asked yet and you actually need to propose an error or a question so a few key points that are very important when you're asking a question so you need to be specific so clearly State what you're trying to achieve uh where you're facing issues secondly you want to show effort indicate what you've already tried so include some relevant code or error messages so you want to have full information be respectful so you want to be polite and appreciative because these are other people that are taking time out of their day to potentially help you so you want to just be respectful and sure that you care and aren't just trying to care only about yourself you also want to use descriptive titles because when these developers and debuggers are going through and they're they're looking at all the titles they want to be something that's easy to read something that they can make sense of if it's like you know just a bunch of random characters it's like hmm maybe that person doesn't quite know how to ask about errors and so that's going to be harder for them to approach because they don't know what's going on uh so you want to address the issue or question within your title you want to keep it relevant so stick to the main topic and avoid any unnecessary details make sure everything is formatted properly I'm going to show you how to do that in a second here how to make sure your code and logs are formatted properly you want to also include some system and platform details so since this is closer to a systems programming language you want to include some information about your system such as maybe your RAM maybe just some other aspects that might that might affect the reason you're getting an error so anything it could be remotely close to that you want to make sure you have full information once again and lastly avoid emotional language don't get mad don't don't swear uh so just just be super polite about it and don't get like mad or anything I mean we're all developers here we're all on the same page we're trying to Make a Better Community for the development of artificial intelligence systems so uh don't get mad just take a chill pill if you can and uh yeah so anyways I'm going to walk you through how to actually submit errors so here are some examples of both good and bad examples so if you're on GitHub and you're trying to propose an issue you go new issue you say title a bat a bad example would be software keeps crashing dot dot dot and then your software sucks fix it am getting compiler getting compiler error so first of all the title is misleading it doesn't really give any information about it uh it's a little bit disrespectful because you're not considering uh what it looks like from their perspective your software sucks that's like you don't need that fix it it's hard to know what to fix if you don't give any details and getting compiler error well you need to spell things correctly first of all and uh just getting compiler error could mean anything there's like billions of compiler errors that probably exist so uh don't go down that route instead uh what a good example would be would be um unable to save settings in version at 2.1.4 so it's showing like a version specifically that you're getting errors in um and then just something around saving settings and then maybe your body would look something like hello first of all thanks for the great software so you're like oh this software's great you're being polite I recently updated to you know version one two three or two one four and notice I can't save my settings anymore every time I click save the software crashes and then maybe you would provide um maybe you would provide some steps to reproduce so uh you know open software go to settings change any setting click on save so this way that developers can reproduce the error if other developers are able to reproduce your error then it's easier for them to pinpoint where it's going wrong because if it's working normally for everybody else and not you then if you can show a way where they could get the same thing as you then they can compare what's working to what's not working and try to mess with things in between to get to a breaking point where it works and then doesn't work because of maybe one line or something so that's really useful and then what your expected result maybe it was right to I mean expected result you don't always need to put it there but it's still a good practice then your actual result is you know whatever error you get some system information as well like maybe your operating system for example if you tried to install mojo on a MacBook and you didn't have the Linux terminal if you just use the Mac terminal of course you're going to get errors because it doesn't support Mac OS yet so system system information is always good to have um and then just you know be polite any help would be appreciated thanks so that's a wonderful example and even if you wanted to you could also consider uh maybe just putting some quotes around things so let's say steps we produce um you put three quotes around it like that and uh we should we should when we submit this issue I'll actually go just to show you guys what that looks like so when you put the three quotes both on the top and bottom of something then you get this and then if you put single single quotes we're talking about uh these things by the way not these not these just the the grave and essentially those those quotes are going to allow you to make little code blocks in here that people can copy and paste from um so this takes a little bit of practice you can create your own GitHub repositories and practice it on your own but this is generally what it's supposed to look like it's supposed to be very clear you would probably include your logs in the form of this and then maybe some code that you have in the form of this like where your line is uh erroring out so since Mojo is kind of an AI derived language it's used for accelerating a lot of these artificial intelligence systems through just faster Computing so a big question is is since it's so early a lot of people are wondering if you can actually build and train neural networks in Mojo so I can't really say yes or no to this but if you were to use something like say tensorflow um that wouldn't work quite or tensorflow or Pi torch that wouldn't work quite as well because uh you depend on a lot of things like file read and writing inheritance maybe Lambda functions arrays whatever which just doesn't exist yet um so technically if you want to go the easy route and use a lot of the Python libraries that wouldn't work however there are still some people uh building some pretty cool projects right now that are more like a lower level uh like they kind of look like C plus plus code a little bit so they're not as pythonic if you will and I'll actually leave a project like that into the in the description somebody actually was able to uh build or at least attempt building the lamma2 model using Mojo so that's cool that's just going to be in the GitHub repo in the description so feel free to check that out uh the other point is that since we cannot read and write uh to files uh there there would be no point in actually doing a lot of this training so we would have to rely on third parties like python to do this read in writing and saving the actual model files for us or else what's the point of even training right if you have a script that trains a model and then just dumps all the parameters after then I mean you've maybe used it one time maybe you prompt the model once but that's just a lot of wasted computation so we want to be able to save the model files so that we can use them again and that's just not super compatible with uh plain Mojo right now so my answer right now is like no for beginners you should not attempt to build any neural networks from scratch or anything or even use pythonic Frameworks so for now my answer is no um and I should probably add to that meaning like what doesn't exist in the Mojo language if neural networks don't really exist they they kind of do but they also kind of don't um what doesn't exist yet so you have list comprehensions like arrays dictionaries Etc you have Lambda functions from python those don't exist yet struck inheritance uh you would see something like this with pi torch and inheriting an N dot module if any of you have worked with pi torch before so you can't really keep track of your gradients that way and then again file read and write does not exist yet so uh there might be a few other things that I maybe didn't cover but those are kind of the the the huge ones the outliers that are uh really important that you should know about and then lastly if you are really curious uh I would honestly just consider reviewing the roadmap which you can find at uh the modular website if we actually head over to the modular docs here you can go to roadmap and sharp edges and you have some priorities here so CNC plus plus interop protocols traits just just a bunch of uh cool things here to look over and stay up to date with so now you should have all the tools in your belts to actually get started with you know reading Mojo documentation building your own projects playing around with the language and all that fun stuff so I hope you enjoyed the video this tutorial was designed as a sort of beginner uh emphasizing for beginners people transferring from Python and trying out mojo as well as just some you know Concepts that you should be aware of when you're doing more advanced systems programming so hopefully this tutorial was informative to you hopefully it helped my YouTube channel is in the description below so if you didn't want to check me out and maybe even subscribe that's I mean it's totally free you can unsubscribe later but I make pretty good content on there so uh you might want to go subscribe uh that's just in the description so anyways that's all I got have fun my fellow magicians
