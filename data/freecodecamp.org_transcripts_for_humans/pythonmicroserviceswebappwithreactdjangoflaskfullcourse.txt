With timestamps:

00:00 - hello and welcome to this tutorial i'm
00:03 - antonio papa from scalablescripts.com
00:06 - and in this tutorial we will create a
00:09 - microservices example using python and
00:12 - react
00:13 - let's start by understanding what is a
00:16 - monolith and what are microservices
00:19 - a monolith can be a large code base that
00:22 - has a lot of functionalities
00:24 - and is connected with the single big
00:26 - database
00:28 - in this example that i'm showing you you
00:30 - can think this as a nicomer site
00:34 - we have a search functionality that has
00:36 - a lot of traffic
00:38 - we have a product list
00:40 - which
00:41 - are cached
00:42 - we have a product recommendation
00:44 - functionality
00:46 - we which we can use machine learning to
00:49 - recommend different products
00:50 - and we have a contact page where we have
00:53 - less traffic there
00:55 - the problem with this architecture is if
00:58 - we want to scale this up
01:00 - because the search has a lot of traffic
01:02 - we have to replicate
01:04 - all the functionalities
01:05 - so we are replicating also the parts of
01:08 - the code that has no traffic like the
01:10 - contact page
01:12 - also since it is one repository there
01:15 - can be only one language and you can
01:18 - cause
01:19 - other problems with other teams if which
01:22 - if you change their code since there is
01:24 - only one repository
01:26 - now what are microservices microservices
01:28 - are smaller independent services that
01:32 - have their own database and they can
01:34 - communicate with each other using an
01:37 - event bus
01:38 - so in our example we will have four
01:41 - microservices
01:42 - all have their own database
01:45 - and they will communicate with each
01:46 - other via messages
01:49 - the advantages in this case are that we
01:52 - can scale the applications based on the
01:55 - traffic so if we see the search
01:57 - microservice we scaled
01:59 - that microservice four times compared to
02:02 - the contact
02:04 - where we have only one instance of the
02:06 - contact microservice another advantage
02:09 - is the separation of concerns now the
02:12 - product recommendation team can only
02:14 - focus on machine learning and not
02:16 - scaling up the application
02:19 - also each team can use a different
02:22 - programming language based on their
02:24 - needs
02:25 - now let's jump to the application that
02:28 - we will build
02:29 - in this example we will build a simple
02:32 - microservices example using python
02:35 - the front end of this app will be built
02:38 - with angular react view and swelt
02:42 - you can pick your favorite there
02:45 - the backend is composed into two apps an
02:48 - admin app and the main app the admin app
02:51 - will be built using django
02:53 - and the main app will be built using
02:55 - flask
02:57 - both will run in docker and will connect
03:01 - with their own database in mysql
03:05 - they will communicate with each other
03:07 - using rabbitmq events
03:10 - and in one case the main app will
03:12 - internally call the admin app
03:15 - now let's see what this app looks like
03:18 - so this is the app that we will build
03:21 - it's a simple app where this is the
03:24 - admin and this is the main app
03:27 - in the main app we can like the products
03:29 - and in the admin app we can create the
03:31 - products
03:33 - it is very simple but don't get deceived
03:35 - because it
03:37 - it has two backend apps with different
03:39 - database
03:40 - communicating with rabbitmq which i open
03:43 - it on my right side
03:45 - so
03:46 - let's see an example for example
03:48 - i will like this product here
03:51 - and when i like the product you will see
03:53 - an event happening in rabbitmq right now
04:01 - so the event has been triggered here
04:04 - and we have one ready event and now is
04:07 - zero so it means it was consumed
04:10 - so if we see here let's refresh the
04:13 - admin
04:15 - we can see that we got another like here
04:19 - so in essence it's really simple
04:21 - but
04:24 - this like
04:25 - has more functionality to it since it
04:28 - will internally call also the admin to
04:30 - get
04:31 - a random user
04:33 - and
04:34 - if
04:36 - we happen to like with the same user it
04:39 - will throw an error
04:41 - we can also create a new product
04:44 - so let's create a product
04:48 - and i will add a sample image
04:51 - we will see that
04:52 - rabbitmq will trigger another event so
04:55 - this is a product that we created
04:58 - another head event has been fired
05:01 - and when it's consumed here
05:04 - we will see the product here
05:08 - so it
05:09 - seems that the product is
05:13 - on the admin app on the main app
05:16 - so
05:17 - we got the product
05:19 - so we will see how this app will work by
05:23 - building them so let's start
05:25 - creating
05:27 - the apps
05:30 - so let's start building the admin app
05:32 - using django rest framework
05:35 - to create the project go to tutorial
05:37 - quick start
05:38 - and these are the commands to create a
05:40 - simple
05:41 - django project you have to install
05:44 - django and jungle rest framework from
05:47 - pip
05:48 - i already did it so i can directly go to
05:51 - the terminal and write django
05:54 - admin
05:55 - start
05:57 - project
05:59 - admin
06:02 - and the project is created i can go to
06:04 - the folder now and run python
06:08 - 3 manage that pi
06:10 - run server
06:14 - so the project is running now and i can
06:16 - copy this url
06:19 - and paste it to the browser and we can
06:22 - see that we successfully installed the
06:24 - django project
06:26 - now let's open the project with our ide
06:30 - and this is the app that we just
06:31 - generated
06:32 - now let's run
06:34 - docker so let's create two files one is
06:37 - docker file
06:40 - and the other one is docker compose
06:45 - dot yaml file
06:50 - so
06:50 - let's open the docker file first
06:53 - and what we will write here is first
06:56 - from
06:58 - what type of project is this so we want
07:00 - to get it from python
07:04 - and we have to specify the version of
07:06 - python i will pick the latest one which
07:09 - is 3.9
07:12 - next we will add an environment
07:14 - variable
07:16 - python and buffered one
07:20 - because this is useful to get logs so we
07:23 - can see whatever is happening
07:26 - and now we have to specify a working
07:28 - directory i will call it just up
07:33 - so before going further
07:35 - i will create
07:37 - a requirements
07:42 - txt file
07:44 - so in this file we can put all the
07:46 - dependencies that we will use in our app
07:50 - so i will paste them here
07:52 - we will use django django rest framework
07:54 - mysql client and java mysql so we will
07:58 - connect with mysql
08:00 - jungle course headers this is needed for
08:03 - the front end
08:04 - to access the backend and pica this is
08:07 - useful
08:08 - when we will connect with a rabbitmq
08:12 - now that we added our requirements let's
08:14 - go to the docker file and we will copy
08:18 - requirements.txt
08:20 - to
08:21 - up
08:22 - let's copy the name here
08:25 - requirements.txt so we are copying this
08:28 - file
08:29 - to the work to the working directory
08:32 - requirements so we are copying inside
08:34 - the docker container
08:36 - and now we have to install it so we have
08:37 - to run a command
08:39 - pip
08:41 - install
08:42 - minus r
08:43 - requirements so
08:45 - paste it
08:47 - so this will install all these
08:49 - requirements
08:51 - and
08:52 - in the end we will copy all the files so
08:55 - dot
08:56 - slash up
08:58 - dot in this case means
09:00 - all the files here so we are copying all
09:02 - the files to the app directory
09:05 - the last command is running
09:08 - the project so we have to add here
09:11 - python
09:12 - manage that pi
09:14 - run server
09:16 - and we also need to specify the host so
09:19 - the host will be
09:20 - 0.0.0 0.0.0.0
09:22 - with port 8000
09:25 - so we have to use it this way otherwise
09:27 - we cannot connect the port with our
09:30 - localhost
09:32 - now let's go to our docker compose file
09:36 - here we have to start by adding the
09:38 - version
09:39 - the latest version of docker compose is
09:41 - 3.8
09:44 - and then we have to specify the services
09:46 - so for the moment i will just add the
09:49 - backend service
09:51 - which is our app here
09:54 - first we have to specify the docker file
09:56 - so
09:58 - build
09:59 - we have to put here context which which
10:02 - is this folder
10:04 - and the docker file which is
10:07 - docker file
10:08 - so basically this means
10:11 - that this docker compose file should use
10:13 - this docker file
10:15 - so that's it
10:17 - next we need to specify a port here
10:22 - so this port
10:24 - that is running here is inside the
10:26 - docker container is not our local host
10:29 - so we have to
10:30 - tell
10:32 - our localhost
10:33 - to listen to a specific port
10:36 - so in my case this is
10:39 - the dockerfile port
10:41 - and this is our localhost port so
10:44 - if we don't use this we won't be able to
10:46 - access
10:48 - the server
10:50 - and the last change is the volumes
10:53 - so add here volumes
10:56 - and inside we will specify dot
11:00 - column
11:02 - up
11:04 - this means that
11:05 - [Music]
11:07 - dot means all the files here
11:09 - are connected with the docker container
11:11 - every time we make a change in the app
11:15 - it will
11:16 - pass it to the slash
11:18 - to the docker file up
11:20 - and the opposite if change happens in
11:22 - the docker file it will reflect it here
11:26 - so that's it this is our app
11:29 - now we have to start it
11:31 - first
11:32 - we have to stop the server here
11:36 - and
11:36 - open the terminal and write docker
11:39 - compose
11:40 - up
11:42 - now he's building the backend is
11:44 - downloading all the required libraries
11:46 - for python and it will also install all
11:49 - the requirements here
11:51 - let's wait till it's completed
11:54 - so now everything is running correctly
11:57 - we can see that the development server
12:00 - is running
12:01 - and also we stopped the server from this
12:04 - uh terminal
12:06 - and if we refresh now
12:09 - we'll see we'll get the same page
12:11 - now this is running from the docker
12:13 - container
12:14 - if we stop for example we won't be able
12:17 - to see it so
12:19 - now we don't see it if i start again
12:22 - now it will be much more faster
12:26 - so we can see it
12:28 - so this is how you connect
12:30 - django with docker
12:32 - now we have to connect with the database
12:35 - we already have an sqlite database here
12:37 - but we will remove it
12:40 - because
12:41 - we will be using mysql
12:44 - so the first thing we have to add the
12:46 - mysql service i will call it db
12:49 - and here i will add an image which is
12:51 - mysql
12:53 - version 5.7.22
13:01 - so we added mysql next we have to add
13:05 - restart
13:06 - always
13:08 - so we have to add this command because
13:10 - uh sometimes mysql stops and this will
13:13 - stop also our docker container and our
13:16 - app is no will not run
13:18 - so this will restart it again
13:22 - next we have to add some environment
13:24 - variables so these are some environment
13:27 - variables that we will connect with our
13:29 - backend
13:30 - so we have to add
13:32 - mysql database
13:36 - which is admin
13:39 - mysql
13:40 - user
13:43 - root
13:44 - mysql
13:46 - password
13:49 - i will also put root here
13:51 - and mysql
13:53 - root password
13:56 - root so these values you can pick
13:59 - whatever values you want so
14:01 - you can specify them here
14:04 - next we have to add volumes
14:07 - so this is really important
14:09 - so mysql when we start when it stores
14:12 - data it needs to map them to a folder so
14:15 - i will create a folder here db data
14:18 - which will map var
14:23 - lib
14:24 - mysql
14:27 - so all the files here
14:29 - will be reflected to a folder here
14:31 - called
14:32 - db data so we will see that once we
14:35 - start this container
14:38 - so we are finished now we have to add
14:40 - here ports this is not
14:42 - required at all
14:44 - i will just add it so we can see the
14:47 - data inside the database so
14:50 - the port will be
14:53 - the default port for mysql is 3306 and
14:56 - this is inside the docker container
14:59 - outside we will use 33066
15:03 - or whatever port we want
15:06 - i didn't put the same port because it
15:07 - will conflict with my mysql installation
15:11 - so that's it
15:12 - the last change
15:15 - is we should add here depends on db
15:18 - this means that
15:21 - this container should run first and then
15:23 - this container should run
15:26 - now
15:27 - let's
15:29 - close it and start it again
15:32 - now it's pulling mysql
15:39 - so we can see now the database is
15:41 - running so
15:43 - we can also see a db data folder here so
15:46 - this
15:46 - are the files that when we store
15:49 - anything it will be reflected here
15:52 - we don't have to touch this folder so
15:55 - this is
15:56 - just there to stay
15:58 - now let's connect
16:00 - with our
16:01 - ide so we need a new data source mysql
16:05 - and our port was 33066
16:10 - root for the user root for the password
16:12 - and the database was admin
16:16 - let's test if we connect so we connected
16:19 - successfully
16:20 - now we have only one schema with no
16:23 - tables so now let's
16:25 - add some tables to the database
16:28 - first we have to create a new app
16:31 - so we have to go inside the docker
16:32 - container now
16:34 - so to go inside the docker container
16:36 - open a new terminal and write docker
16:38 - compose
16:39 - exec
16:41 - now we need the name of the service
16:43 - which in our case is backend
16:46 - backend
16:47 - sh
16:49 - we are inside now and now let's run a
16:52 - juggle command to create a new app so
16:54 - python
16:56 - manage that pi
16:58 - startup
17:02 - products
17:05 - so we created the app
17:07 - we can see here
17:09 - the products is created and we run the
17:12 - command inside the docker container
17:14 - now let's uh go to
17:17 - admin and we need to connect
17:20 - we need to add this products to the
17:22 - installed apps
17:24 - first we have to add here
17:26 - rest
17:27 - framework
17:29 - next we have to add here course
17:33 - headers
17:35 - and the products that we just created
17:39 - our course headers needs also
17:42 - a middleware so this is a middleware
17:44 - that we need to add
17:49 - and also it needs a new constant
17:52 - i will add it here in the end
17:55 - course origin allow all so
17:58 - we added everything we need
18:00 - now we need to connect with mysql
18:03 - here we have to change this sqlite to
18:06 - mysql
18:08 - the name of the database would be admin
18:19 - next we have to add the user
18:23 - which is root
18:25 - the password
18:29 - which is also root
18:31 - the host
18:33 - those is no in our case will be this
18:36 - service here so just db
18:40 - db
18:41 - and the port
18:44 - and in this case
18:47 - we won't be using this port but we will
18:49 - use the port inside this service so is
18:51 - 3306
18:55 - so i 3306
18:59 - so this is our connection with mysql we
19:03 - can remove again this sql light here
19:06 - and uh
19:07 - let's restart
19:10 - again the docker containers
19:13 - now we have to run migrations to create
19:16 - tables in mysql so let's go to the
19:18 - products
19:20 - and models so we will create two models
19:22 - here the first one is
19:25 - product
19:28 - this will extend from models
19:30 - model
19:31 - and we will add the fields for the
19:33 - product that we need title
19:36 - which is models a chair field
19:41 - with a max length of 200
19:45 - let's do the same for the image
19:50 - and we need another field which is likes
19:54 - this will be a positive in the integer
19:58 - field
19:59 - and the default value will be zero
20:02 - so this is our product
20:04 - and we need another table now
20:07 - i'll call it user
20:11 - models model so we won't
20:14 - be really using the user table we will
20:16 - just use the user id so
20:19 - i'll just pass
20:21 - so with this this table will have only
20:24 - the id field
20:26 - and the product will have the id and
20:28 - these other three fields
20:31 - so now we have the models we need to
20:33 - generate migrations for these models and
20:36 - we have to migrate so
20:38 - open the terminal let's go inside the
20:40 - docker container again
20:43 - and here
20:45 - we have to write
20:47 - python
20:48 - manage that pi
20:50 - make
20:52 - migrations
20:55 - so we can see we generated migrations
20:59 - these are the migrations that we
21:01 - generated
21:02 - and to run them run
21:05 - python
21:07 - make
21:08 - manage
21:09 - that pi
21:10 - migrate
21:14 - so
21:15 - we run all the migrations if we open the
21:17 - database now and refresh
21:20 - we'll see a bunch of tables
21:22 - we won't be using all these tables
21:24 - the only two tables that we are
21:26 - interested is the products which
21:28 - we have title image and likes
21:31 - and the user which
21:33 - has only the id field
21:35 - so this is how we connect django with
21:38 - mysql and we run migrations
21:41 - so we created our models and now django
21:44 - when we return the objects in an api we
21:47 - need to use serializers so now i'll
21:50 - create a folder a file here sorry
21:53 - serializers
21:58 - and inside i will create
22:00 - a class product serializer
22:05 - this will extend from serializers
22:09 - so let's import it first
22:12 - from
22:13 - rest
22:14 - framework import
22:16 - serializers
22:18 - and this will extend from serializers
22:21 - dot
22:22 - model serializer
22:26 - so inside we'll add another class which
22:29 - is meta
22:31 - and we have to tell
22:33 - which is the model
22:37 - in our case is a product
22:41 - let's import the product here so i will
22:44 - remove this
22:48 - so we
22:49 - said that the product
22:51 - is a model and now we have to specify
22:53 - the fields
22:56 - and i will use all of them
23:00 - so this is our serializer
23:03 - is very simple
23:05 - we won't be using a serializer for the
23:07 - user since we will return a random id
23:10 - there
23:11 - now let's go to the views and now we
23:13 - will use the serializers so
23:15 - here we will create all the five methods
23:17 - for rest api crowd
23:20 - so there are multiple ways to do it
23:23 - in my case i will use the view set so
23:28 - from
23:29 - so i will
23:31 - remove the render from
23:33 - django
23:34 - so rest framework sorry
23:37 - import
23:38 - view set
23:41 - and what we'll do with this view set is
23:44 - we will create a class product
23:46 - view
23:47 - set
23:49 - this will extend from view sets
23:53 - view set
23:55 - so this will have a five methods that we
23:58 - want
23:59 - so i will add here
24:02 - list
24:03 - this will be the list of uh
24:06 - the products
24:08 - so i will list them one by one so this
24:11 - needs a request
24:15 - so
24:15 - i will add here
24:18 - create
24:20 - self
24:21 - request also
24:23 - so these are for
24:25 - slash products route
24:27 - for slash product slash
24:29 - so i will write it here this is r4
24:33 - i will add a comment
24:35 - slash api slash products
24:38 - route
24:40 - i'll let pass here so it won't throw an
24:42 - error
24:46 - so this will have a get request this
24:49 - will have a post request
24:51 - now
24:52 - there are other
24:54 - endpoints that we will use which is def
24:57 - retrieve
25:00 - in itself
25:02 - request
25:03 - and the primary key which is known by
25:07 - default
25:08 - and this will be
25:10 - like
25:11 - this
25:13 - so i will added
25:16 - string
25:17 - id
25:21 - and i will pass it here
25:23 - so there are three
25:24 - methods for
25:26 - a single product
25:29 - one is retrieve the other one is update
25:33 - and the last one is delete
25:40 - so
25:42 - these are all the five methods
25:44 - now i'll remove the this part
25:48 - so to use
25:50 - this
25:50 - methods we have to
25:54 - add here a new file
25:57 - urls
25:59 - i'll copy the same
26:02 - code from this
26:03 - admin urls here
26:05 - i'll paste it here
26:07 - and here we will use
26:10 - products
26:12 - i'll remove the slash
26:14 - and what is
26:16 - this next parameter
26:18 - it will be
26:20 - product
26:22 - view set
26:24 - let's import it from views
26:28 - we have to edit here as a view
26:31 - but we still need extra parameters we
26:34 - have to tell that the get method
26:37 - will
26:39 - point to the list function
26:41 - so as we can see here we have a list
26:44 - and the get
26:46 - method will point to this list function
26:49 - the post method will point to the
26:52 - create function
26:55 - and we have to add another router
26:57 - right now for product slash
27:01 - the
27:02 - it needs a string which is a primary key
27:06 - and this get method now we will call the
27:09 - retrieve
27:12 - function
27:14 - we don't have a post we have a put here
27:18 - this will point to update
27:21 - and delete
27:26 - will point to destroy
27:28 - so i made a mistake
27:30 - this is destroyer
27:36 - so now all the methods are here
27:39 - now let's use them first
27:42 - let's
27:43 - add the list of the products so first
27:45 - let's get the
27:46 - products we have to get the product here
27:52 - objects
27:53 - all of them
27:55 - let's import this product
27:58 - from models
28:00 - so we got all the products
28:02 - now we need to use the serializer we
28:04 - just created so serializer
28:08 - is equal to product
28:10 - serializer
28:13 - let's also import it
28:16 - so imported product serializer here
28:19 - the first parameter is the products
28:22 - and we need another parameter here we
28:24 - have to tell that many is equal to true
28:28 - so we have this is a list of the
28:30 - products
28:31 - and it needs to return an array
28:35 - now that we got the serializer we need
28:38 - to return response
28:41 - with serializer that data let's import
28:44 - also the response here from
28:47 - rest framework response
28:49 - so this is the import
28:52 - so this is our list function
28:55 - let's see how it looks like so i open
28:58 - postman here you have to install it to
29:00 - test
29:01 - the apis
29:02 - here i will use http
29:06 - localhost
29:08 - port 8000
29:10 - slash i forgot also one other thing
29:15 - so we added the routes here
29:18 - i also need to
29:20 - add them here
29:22 - first let's import
29:24 - from django url 0 we will import include
29:30 - and
29:30 - let's add the new path
29:34 - which will start with api
29:38 - we'll add a slash here and we will
29:40 - include here our project which is
29:43 - products
29:44 - so this project
29:46 - dot
29:46 - urls which is this file
29:50 - now that we included
29:51 - now we can use it here is api slash
29:55 - products
29:57 - and normally we don't have any
29:59 - product so it will return an empty array
30:02 - now let's add the next
30:04 - function which is create
30:08 - here
30:09 - we'll get the serializer
30:13 - which is equal to product serializer
30:16 - and we have to pass the data from the
30:18 - request
30:19 - so data is equal to request the data
30:25 - so we will use those data and
30:27 - we have to first
30:32 - call
30:33 - is valid so if
30:35 - we send valid data to this serializer
30:39 - if not we will erase an exception
30:43 - and if it's valid it means we will go to
30:46 - this line
30:47 - it means we'll save it
30:50 - after we save it we return the response
30:53 - so response
30:55 - serializer.data
30:57 - and we have to put a status here so
31:01 - we'll import from status
31:05 - let's import status
31:09 - so i don't remember the exact import
31:12 - here but we'll use status is equal to
31:14 - status
31:17 - dot
31:18 - http
31:21 - 201
31:23 - created
31:26 - let's import this status
31:30 - so it's from rest framework we'll import
31:33 - status here
31:36 - now let's
31:37 - use it so we will change this from get
31:40 - to post
31:41 - and we will send some
31:45 - from
31:46 - json here we'll send
31:48 - some request
31:50 - we need the title
31:52 - title
31:53 - and an image
31:57 - which is
31:58 - image let's send the request
32:02 - and we return the title notice that we
32:04 - get also the likes here
32:05 - by default is zero
32:08 - we got also an id
32:09 - so our first product is created if we go
32:12 - to the get
32:14 - method now
32:15 - we'll see an array with a one product
32:19 - so this is the create function
32:23 - the retrieve is really simple
32:25 - we have to get the product
32:28 - which is equal product
32:30 - objects get
32:33 - the id is equal to this primary key
32:37 - now that we got the product we have to
32:39 - get the serializer
32:42 - is equal to product serializer
32:44 - with the product
32:46 - and we have to return in response
32:49 - serializer.data
32:53 - let's use it so
32:55 - this has id1 so
32:57 - if we put a get request with id 1 we
33:00 - return a
33:01 - single object
33:03 - products returns an array of objects
33:08 - now let's go to the update
33:11 - let's copy this part i'll
33:13 - put it to the update and also destroy
33:15 - because we will use the object there
33:18 - so we'll get the serializer here
33:22 - is equal to product serializer
33:25 - we have to pass the instance
33:27 - which is this product so the instance is
33:30 - a product
33:31 - with the data that it has
33:34 - and we have to update it with a new data
33:36 - which we will get it from the request
33:39 - the data
33:41 - so this is a project that the product
33:43 - that we have
33:45 - and these are the data that we want to
33:46 - update it
33:49 - now we have to
33:50 - do the same thing we have to
33:53 - ask if the serializer is valid then we
33:56 - have to
33:57 - save
33:58 - in the end we'll return a response with
34:00 - the serializer.data
34:02 - and we have to change the status which
34:04 - is
34:05 - 202 accepted
34:08 - so let's change
34:09 - product with id1
34:12 - we'll send a boost reboot request here
34:14 - and this is new title and the new image
34:19 - send requests and we can see that these
34:22 - values are changed now also the status
34:25 - is 202 accepted
34:27 - last change is destroying the object
34:31 - this is really simple we have to call
34:33 - product
34:34 - delete
34:36 - and that's it so we have to return here
34:38 - response
34:40 - with the status
34:42 - status
34:44 - http 204 no content
34:49 - so let's
34:50 - delete this product
34:53 - send the request and we have 24 no
34:56 - content we don't have a product and if
34:58 - we go to the products
35:01 - uh
35:02 - not delete method so
35:05 - we have still an empty array now here
35:09 - now the last call that we need is the
35:12 - user's call so we'll create another
35:14 - class here
35:16 - user
35:17 - api
35:20 - view so i will not use a view set now i
35:23 - will use an api view
35:27 - api view here so let's import it
35:31 - from rest firm framework views we'll
35:34 - import api view and this will be really
35:36 - simple we need
35:38 - to define the get
35:41 - function
35:43 - and we need the parameter here which is
35:45 - a request
35:47 - which we won't use it i will put an
35:49 - underscore here
35:51 - we have to get the users
35:54 - users
35:56 - user sorry
35:58 - objects all
36:01 - so let's import also
36:03 - user from the models so we imported it
36:06 - here
36:07 - now we got the user
36:09 - we have to get a random user so
36:13 - here
36:14 - i will import
36:16 - random
36:20 - to get a random user
36:23 - is equal to
36:24 - random choice
36:27 - users
36:29 - and this will be a random user now let's
36:31 - return the id response
36:37 - id
36:39 - is user.id
36:41 - so this is a user so let's add it also
36:44 - to the urls
36:47 - the path will be
36:48 - user
36:50 - and we have to import it here
36:53 - user api view
36:56 - user api view here as view
37:00 - so let's test this
37:03 - route
37:04 - so this will be a get request to the
37:06 - user
37:09 - this returns an error because we don't
37:12 - have any users in the database
37:15 - so i will manually add here some values
37:19 - so
37:20 - i'll add here one
37:23 - two
37:24 - three
37:26 - four and five
37:28 - so i'll add five users
37:31 - or five numbers
37:33 - now let's send the request again and i
37:35 - get five
37:36 - if i send it again it's four so
37:39 - the result is randomized
37:43 - so this was our main app
37:46 - now we have to create another app
37:49 - so we can communicate it so that the
37:51 - other app will be a flask app
37:54 - now it's time to create the main app and
37:56 - i decided to make it with flask
37:59 - so i created a main folder and inside i
38:02 - created an empty main.pi file
38:05 - so let's start first
38:07 - i'll paste here the requirements
38:11 - that we need so we need to install flask
38:14 - flask sql alchemy sql alchemy
38:17 - flask migrate flash scripts flash course
38:20 - request mysql client and pica
38:23 - so there are a lot of
38:25 - requirements that we need
38:27 - and
38:28 - now we will go to the other project and
38:31 - i will copy the docker files here
38:33 - and paste them here
38:37 - so
38:39 - the docker file
38:40 - will be the same here
38:43 - except for
38:44 - the command which will be simpler
38:48 - just python
38:50 - main
38:52 - dot pi
38:54 - so this will be the docker file a docker
38:58 - compose file for mysql it will be the
39:00 - same except this will be a new port i'll
39:02 - put 7 here
39:05 - and i will change the database name to
39:06 - main
39:09 - there is no need to change the database
39:10 - name because this is another container
39:13 - but
39:14 - we changed it
39:16 - so the port the default port for flask
39:19 - will be 5000
39:21 - and
39:22 - 8000 is occupied with
39:25 - the jungle up so i will use
39:27 - 8001 here
39:29 - and that's it so
39:31 - the docker files are completed now let's
39:34 - create
39:35 - a flask up here so from
39:38 - flask
39:42 - import
39:43 - flask
39:46 - let's create
39:47 - the app
39:49 - is equal to flask
39:53 - name here
39:56 - so
39:58 - let's start a basic app so here i will
40:00 - add new route up
40:03 - route
40:05 - so
40:06 - just slash
40:08 - i'll create a function
40:10 - index
40:13 - and
40:13 - here i will return just hello
40:16 - so let's see if this works
40:20 - so i need to add a condition
40:22 - if name
40:25 - is equal to
40:27 - main
40:31 - then up
40:33 - run
40:34 - with debug is equal to true
40:37 - we also need the host so the host will
40:40 - be 0.0.0.0
40:46 - so
40:47 - that's it now let's try to run it
40:49 - without a docker container
40:52 - python
40:54 - 3
40:56 - main.play
40:58 - so we got this port
41:00 - let's copy it
41:04 - and open a new tab in postman
41:10 - so we have an error
41:15 - so
41:16 - is hello
41:18 - not sure why throw the narrow
41:21 - now let's do the same
41:22 - but this time with docker
41:25 - so
41:26 - we have all the requirements we don't
41:28 - need to change anything
41:30 - so let's start
41:31 - docker
41:32 - compose
41:33 - up
41:35 - and let's wait till it's completed
41:42 - so it's finished
41:44 - we can see a db data folder here
41:48 - and uh
41:49 - let's test it now the port will not be
41:52 - 5000
41:54 - because this will be inside the docker
41:56 - container
41:57 - the port will be 8001 so here i'll
42:00 - change it with localhost
42:04 - port 8001
42:07 - and that's it so
42:09 - we can see hello now
42:11 - so
42:11 - docker is working
42:14 - now let's add
42:15 - mysql to
42:17 - this main.pi file
42:20 - so let's import sql alchemy so from
42:26 - flask
42:28 - sql alchemy
42:32 - import
42:33 - sql alchemy
42:35 - and we need to use it here so up
42:39 - config
42:43 - and we need to set a
42:45 - constant so is sql alchemy
42:51 - underscore database
42:54 - underscore uri
42:57 - so with this we will add the db
42:59 - connection
43:00 - and what we need is to add mysql here
43:06 - and
43:08 - here we need to add the user and the
43:10 - password so root root in our case
43:15 - at now we need the host the host will be
43:19 - the service here which is db
43:21 - so the host will be db
43:23 - and in the end will be the table which
43:26 - is main
43:28 - so with this we can connect to this
43:31 - database
43:34 - i will add also of
43:36 - course here
43:39 - since the front end will need it so
43:42 - let's import it from flask course
43:46 - i'll add it to the app
43:48 - and
43:49 - now
43:51 - the database is equal to sql alchemy
43:58 - and
43:58 - here we'll pass up
44:00 - now let's create two models that we need
44:02 - so class
44:04 - product
44:06 - this will extend from db
44:08 - model
44:10 - and let's add all the required
44:14 - properties for the
44:15 - product we need the id
44:18 - which is a
44:20 - db
44:21 - column
44:23 - db integer
44:28 - and also is a primary key
44:33 - now we have to make another change for
44:36 - the id here
44:38 - we will add here
44:40 - auto increment to false
44:42 - why did i add this field
44:45 - because
44:46 - the product will not be created in this
44:48 - app the product will be created in
44:52 - the jungle app
44:54 - and this app will just catch the event
44:57 - from rabbitmq
44:58 - and it will create the product
45:01 - and when we create the product we don't
45:03 - want the id to be auto increment
45:06 - because the id will be different than
45:08 - the the jungle app
45:11 - so if we want the same id we have to put
45:14 - it onto incremental false and to insert
45:17 - directly the id as it is from the django
45:20 - app so we'll see by example a little bit
45:23 - later
45:25 - now let's add the title
45:30 - db
45:31 - column
45:34 - db
45:35 - string
45:37 - and this will be a
45:38 - 200 character
45:41 - let's do the same for the image
45:46 - so this is a product
45:49 - notice that uh
45:51 - this product will be different than the
45:53 - product from
45:54 - the other app
45:55 - because we don't have likes here
45:59 - and the id is different so we can you we
46:02 - can think this as a different type of uh
46:06 - the same thing
46:08 - let's add also another class that we
46:09 - need each which is product
46:15 - user
46:17 - from db
46:19 - model
46:21 - so this will have an id
46:23 - which
46:24 - is a
46:26 - column db integer
46:30 - primary key to true
46:32 - so this will increment normally
46:36 - we need here the user
46:39 - id
46:41 - which is a db column
46:43 - db integer
46:46 - and the same for the product id
46:56 - we need also a unique
47:02 - constraint
47:06 - for user id
47:11 - product id
47:14 - and we need to set the name which is a
47:16 - user product
47:19 - unique
47:22 - so this unique constraint so let's
47:25 - import it from
47:27 - sql alchemy
47:29 - from here
47:31 - so
47:32 - this unique constraint will make sure
47:35 - that the combination of user id and
47:37 - product id should be unique
47:39 - we should not repeat it
47:41 - so we created the models that we will
47:44 - use now we need to migrate so
47:47 - to migrate
47:48 - i will create a new file here
47:51 - i'll call it manager
47:55 - and now here we need some imports so
47:58 - first
47:59 - from the main app
48:02 - we need to import up and db
48:06 - we need to import from
48:09 - flask
48:10 - migrate we need to import
48:14 - migrate and migrate command
48:17 - and from
48:18 - flask script we need to import manager
48:24 - now
48:25 - migrate
48:26 - will be equal to
48:28 - migrate with our app and our db here
48:33 - then we have to get to the manager so
48:35 - manager
48:37 - is equal to manager
48:40 - we need to pass the app inside and the
48:43 - manager
48:45 - will
48:46 - add the command db
48:49 - we'll add the migrate command here
48:52 - so
48:54 - we will have a db command to run our
48:56 - migrations so we will see it
49:00 - now that we will add the
49:02 - if
49:04 - name
49:07 - is equal to main
49:09 - so
49:12 - we need to add manager run
49:17 - and that's it
49:19 - so
49:20 - if we open the terminal now
49:22 - and open a new tab we'll run here docker
49:26 - compose
49:27 - exec
49:28 - backend
49:30 - sh
49:32 - and now we are inside the docker
49:33 - container now if we run
49:36 - python
49:38 - manager dot pi
49:41 - and
49:42 - we will
49:44 - run the command db so we added the
49:46 - command here
49:47 - with help
49:50 - we can see
49:51 - now that we have a command that we can
49:53 - run
49:55 - now let's
49:56 - migrate so to migrate we have to run
49:59 - python
50:00 - manager
50:02 - dot py
50:04 - db init
50:08 - so we created
50:10 - some migration files
50:13 - we can see them here
50:15 - now we need to migrate them so
50:18 - now around python
50:20 - manage
50:22 - dot pi
50:24 - db migrate
50:28 - so
50:29 - it should be
50:30 - python
50:32 - manager
50:33 - that pi
50:35 - db
50:36 - migrate
50:40 - so we created a new table if we open the
50:43 - database now we'll connect with the
50:45 - database
50:47 - so
50:48 - this will be 7 here
50:50 - the user is root
50:53 - password is also root
50:55 - and the database will be main
51:00 - so let's connect
51:04 - we'll see a
51:06 - database now with the emblemic version
51:08 - but we won't see our tables because we
51:11 - need to run another command for it
51:14 - which is python
51:16 - manage
51:18 - that
51:18 - manager sorry that pi
51:21 - db
51:22 - upgrade
51:27 - and now we run the migration if we
51:29 - refresh we'll see the table so this is a
51:32 - product table
51:33 - and this is a product user table
51:37 - so this is how we connect flask with
51:41 - mysql
51:42 - using docker
51:45 - now it's time to use rabbitmq to our
51:47 - python apps
51:48 - so i will use this service cloud ampq
51:53 - and
51:54 - you have to create
51:55 - a free account
51:57 - this is the free account i already have
52:00 - created so i can log in
52:04 - so this is my free account
52:06 - and what i will do here is
52:08 - this ampq url i will just copy it and
52:12 - now i can move to the app so
52:14 - i will go to the jungle app
52:17 - and uh in the products here i'll create
52:19 - a python file
52:21 - producer
52:25 - and for the moment i will just copy this
52:27 - url
52:29 - now let's send an event to rabbitmq
52:32 - so first we have to import pica
52:36 - this is a package that
52:38 - will help us
52:39 - send events
52:41 - and let's create a variable params
52:44 - is equal to pica
52:47 - url parameters
52:49 - and here we can put the url that we just
52:52 - pasted here
52:54 - as a string
53:01 - so we created the params
53:04 - this is annoying
53:06 - the connection now
53:08 - is equal
53:10 - to
53:12 - pica
53:14 - blocking connection
53:16 - and we will pass the params here
53:19 - so
53:21 - we created the connection with rabbitmq
53:23 - now we have to create the channel
53:26 - which is equal to connection
53:28 - channel
53:31 - so with this we
53:33 - created the channel now we can publish
53:35 - so to publish i will create a function
53:40 - publish
53:42 - inside i will put a method
53:45 - and a body
53:48 - so
53:49 - for a moment i will just keep it empty
53:52 - so we can see an example
53:55 - of the publish
53:57 - method so channel here
53:59 - basic
54:01 - publish
54:03 - we need to put an exchange i will put an
54:05 - empty string
54:07 - routing key this is a queue that we want
54:10 - to send the
54:11 - event
54:12 - so for the moment i will put it admin so
54:15 - i will publish it in the same queue as
54:17 - this one
54:20 - with the hit we need the body
54:22 - which is for the moment hello
54:26 - so that's it
54:28 - we can use this publish function now i
54:31 - will use it
54:32 - in the views
54:33 - when we list the products
54:36 - i'll just publish here
54:44 - so i imported the function
54:46 - and when we retrieve all the products we
54:49 - will publish hello
54:51 - now we created the producer
54:54 - now we need to create the consumer so
54:56 - here we need to create the consumer
55:03 - so the beginning is the same let's copy
55:07 - everything from the the producer
55:12 - paste it here
55:14 - and now we have to declare a queue so
55:16 - channel
55:19 - cue
55:22 - declare
55:25 - and the queue will be
55:26 - admin
55:30 - so now we need the callback
55:32 - so call back
55:37 - this
55:38 - accepts a
55:39 - channel as a parameter method
55:42 - properties
55:45 - and body
55:47 - let's pass for the moment
55:51 - after the callback we have to
55:53 - call channel basic
55:57 - consume
55:59 - here we have to pass the queue which is
56:02 - admin
56:04 - and
56:05 - we have to pass on message callback
56:08 - which is this callback that we just
56:10 - created
56:12 - so
56:14 - we are basically consuming now
56:16 - we can print
56:20 - started
56:21 - consuming
56:25 - since we want to have a message to see
56:27 - if we started consuming and the channel
56:31 - start
56:33 - consuming
56:37 - so with this
56:38 - in the end we'll close it so channel
56:40 - close
56:43 - so we basically have finished now let's
56:46 - uh print a message also to
56:48 - know
56:49 - if we received a message so print here
56:53 - re
56:54 - sieve
56:57 - in admin
57:00 - so we received a message and i will
57:02 - print the body here
57:04 - if we go to hello there
57:08 - so that's it now let's try to open the
57:12 - terminal
57:13 - go to the docker file so docker compose
57:16 - exec
57:18 - backend
57:19 - sh
57:21 - here we have to call consumer.pi so
57:24 - python
57:25 - consumer.pine
57:28 - so we received this messages because i
57:31 - already
57:32 - sent some test events
57:35 - now let's test it
57:38 - let's go to the route for the products
57:42 - and we can expect when we get the
57:44 - products here to send an event hello
57:46 - there
57:47 - send
57:50 - we can we can see now we received an
57:53 - event hello
57:55 - now let's consume to the flask app so
57:58 - what i will do is copy this consumer
58:00 - file
58:01 - go to the flask app and here i'll paste
58:04 - the consumer
58:06 - so everything is the same except the
58:08 - queue here will be
58:11 - main
58:15 - so
58:17 - we are done
58:19 - now
58:19 - i can
58:22 - so
58:24 - i can start it with pub python
58:28 - consumer
58:31 - dot pi
58:33 - so we started consuming
58:36 - and
58:37 - in the producer here
58:39 - i will change the
58:41 - routing key to
58:43 - main
58:44 - so now i will not publish here in the
58:46 - admin app but i will publish here in the
58:49 - main app
58:50 - so let's see if
58:52 - this makes any difference let's send the
58:54 - event
58:56 - we can see hello here was from before
59:00 - but this
59:02 - received the hello now so
59:04 - to see the difference
59:07 - hello main i will say hello main
59:11 - so let's send it again
59:14 - we don't see a hello main here but we
59:16 - will see it here so this is
59:18 - how
59:19 - we send events
59:21 - to different apps using pica and
59:24 - rabbitmq
59:26 - now we successfully
59:28 - connect us with rabbitmq and we started
59:30 - consuming uh
59:32 - with the both apps
59:34 - now we don't want to have all the time
59:37 - to tabs here to start the consumer
59:40 - so
59:41 - we'll change the docker compose file now
59:44 - first
59:45 - let's change the docker file
59:47 - we will cut this command here
59:51 - and
59:52 - we will add it directly here
59:54 - so
59:56 - when we build
59:57 - we'll execute the command
60:00 - that we just cut so this is basically
60:02 - the same as before
60:04 - we run the command here but now we are
60:06 - running it here
60:09 - we did that because we will create
60:10 - another
60:11 - container now so is q
60:14 - i will call it
60:16 - which will have the same docker file
60:19 - and the the difference now is
60:22 - we will start a command now
60:26 - and the command will be python
60:31 - consumer dot pi
60:34 - so we will run the command directly here
60:37 - instead of manually running it every
60:40 - time
60:41 - this also depends on the database
60:44 - because we will
60:46 - insert data later
60:48 - so let's
60:50 - do the same for the flask app
60:52 - so
60:54 - i'll paste the queue here
60:59 - so this file is the same so
61:02 - the difference now is
61:05 - i will cut this command here
61:09 - and i will
61:12 - put it here
61:13 - command
61:15 - python main api
61:18 - so
61:19 - now
61:20 - let's
61:20 - restart
61:22 - all the containers so i will run
61:25 - docker
61:26 - compose
61:28 - up
61:29 - build
61:31 - now we don't need the other tab
61:34 - let's do the same for this
61:36 - also let's remove this tab and
61:41 - we will
61:42 - build
61:43 - all
61:44 - the containers now we are building the
61:46 - queue
61:48 - so as we can see
61:51 - we are getting the q so the q is here
61:55 - so one other thing that we can make
61:58 - is by running it like this a docker
62:00 - compose
62:02 - up
62:03 - minus d
62:05 - for the
62:06 - database
62:08 - so d
62:10 - means we won't see the logs
62:13 - let's do the same for the backend
62:15 - or
62:16 - for the back end and the queue we need
62:18 - to see the
62:20 - logs so now we are seeing the logs from
62:23 - the queue and from the back end
62:27 - let's do the same here
62:29 - so
62:30 - minus d here db
62:33 - and docker compose up
62:39 - now let's see if this works so
62:42 - we are the products here let's send the
62:45 - request again we won't see it here but
62:48 - we should see it here
62:50 - also another change that we have to make
62:54 - if we close
62:56 - our containers and run them again
62:59 - we'll notice so if i do it with a
63:02 - database like this
63:04 - and the others
63:06 - double compose up
63:08 - you will notice that i will still get
63:11 - the cues but they
63:14 - they are not consumed yet so
63:16 - there is one last change that we have to
63:18 - add in our consumer
63:21 - and here we have to add auto ack
63:24 - true
63:27 - so with this we will
63:30 - consume the
63:32 - calls and we will not get them again so
63:35 - let's do the same for the
63:38 - other consumer
63:40 - and let's restart the containers again
63:44 - with build
63:47 - also this one
63:50 - will build
63:54 - so they are rebuilt now
63:56 - if we do the same
63:58 - with the database and we
64:01 - start the other apps
64:04 - we will see that the queue started
64:06 - consuming but we cannot see anything
64:09 - here
64:10 - so that's it now
64:12 - with uh these changes
64:15 - consuming becomes easier
64:19 - now we want to send events every time a
64:22 - product is created updated or deleted
64:25 - so we have to change this publish method
64:28 - we will add here a method
64:31 - and a body
64:35 - so
64:36 - for the method
64:38 - we have to create
64:40 - variable properties
64:42 - which is equal to pica
64:45 - basic
64:46 - properties
64:48 - and here we will pass a method
64:52 - and here we'll pass the properties is
64:55 - equal to properties
64:58 - also for the body so we need to
65:01 - import json here
65:04 - and the body will be
65:06 - json
65:08 - dumps
65:10 - body
65:12 - so we will send objects or anything but
65:14 - we have to convert it to json before we
65:17 - send it
65:18 - so this is our publish function now
65:22 - let's use it to our views
65:24 - let's remove this publish here
65:26 - and now
65:27 - when we create
65:29 - we will publish
65:31 - product
65:32 - created
65:34 - and we will send the serial laser the
65:37 - data
65:40 - let's do the same for product updated
65:44 - product
65:45 - updated
65:47 - and for the product deleted
65:51 - now instead of the object we'll send
65:54 - directly the primary key
65:57 - so these are the main events that we
65:59 - want to send
66:02 - and now let's make changes to the flask
66:04 - app
66:05 - here we have to get the
66:09 - data which is equal to
66:12 - json so i will import json here
66:17 - json
66:19 - loads
66:21 - body
66:23 - so
66:24 - in the django app we will convert it to
66:26 - json so now we will con convert it back
66:31 - let's print it so we can see what data
66:33 - are we sending
66:35 - and now
66:37 - we'll make the condition if properties
66:40 - content type
66:44 - is equal to product
66:47 - created
66:50 - will create the project so
66:52 - the product sorry
66:54 - so the product
66:56 - is equal to product
66:59 - with an id
67:01 - data
67:02 - id here
67:05 - title
67:06 - so let's import also this product here
67:11 - is equal to data
67:13 - title
67:15 - and image is equal to data
67:19 - image
67:21 - in the end
67:22 - let's import also the db
67:26 - db session
67:29 - add product
67:31 - ndb session
67:33 - commit
67:35 - so this is how you create a
67:37 - an object
67:39 - with sql alchemy
67:41 - now let's do the same for the other
67:44 - conditions so properties
67:46 - content type
67:49 - product
67:50 - updated
67:54 - so
67:55 - now we will get the product
67:58 - is equal to product
68:00 - query
68:02 - get
68:03 - data
68:04 - with an id
68:06 - and we have to change this product so
68:08 - product
68:11 - title
68:12 - is equal to data
68:15 - with the title
68:17 - and the image
68:20 - so
68:24 - image here
68:27 - in the end we will
68:29 - call session commit
68:34 - the last change is deleting so
68:37 - properties
68:39 - content type
68:41 - product deleted
68:45 - and in this case we'll get the product
68:47 - like this
68:49 - but we don't send an object we
68:53 - send directly the id so this data is the
68:56 - id
68:58 - we have to do it like this now db
69:01 - session delete
69:04 - product
69:06 - and tb
69:08 - session
69:09 - commit
69:12 - so
69:13 - these are all the three cases
69:16 - that
69:16 - we will receive
69:19 - from the other app
69:21 - now let's see if they work but before
69:25 - we should restart our
69:28 - containers just to be sure so
69:32 - build
69:39 - so there is no need to
69:41 - restart this one but
69:43 - just let's do it to be sure
69:48 - so this is started
69:51 - and now
69:53 - we have the products here which we don't
69:55 - have any
69:57 - let's create a product
69:59 - here i will
70:01 - send some data
70:05 - title
70:09 - is a title here
70:11 - and the image
70:14 - an image
70:18 - let's send the request
70:20 - so we successfully created pro the
70:21 - product in
70:23 - the django app but let's see if we
70:25 - created it in the
70:26 - uh
70:29 - flask app
70:30 - so we received the queue
70:32 - we probably forgot we should add here
70:35 - some
70:36 - print statements like
70:39 - product
70:40 - created
70:43 - product
70:44 - updated
70:45 - and product
70:47 - deleted
70:48 - but doesn't matter let's see the
70:50 - database
70:52 - and we can see this is a product now so
70:55 - we successfully created the product
70:58 - from an event from rabbitmq now let's
71:01 - try to update it so this product
71:06 - will put send a put request with a new
71:08 - title and a new image
71:13 - so i will not save it let's send the
71:15 - request
71:17 - this is updated
71:19 - and if we see the event
71:22 - we got the new title and a new image we
71:26 - don't see the
71:28 - print that we just added because we have
71:30 - to rebuild the containers
71:33 - now we're just checking the database
71:34 - which is correct
71:37 - and now let's try to delete it
71:42 - and
71:43 - this is received
71:45 - and if we refresh here
71:49 - we can see we have no product so
71:52 - now the databases for the product are in
71:56 - sync from the jungle app and for the
71:59 - flask up
72:02 - so we completed the jungle app now let's
72:05 - finish the flask up since we have only
72:08 - one route here
72:10 - so let's
72:11 - change this route to just api slash
72:14 - products
72:16 - and here we'll return a list of products
72:20 - so
72:21 - let's import jsonify from flask here
72:27 - and we will return jsonify
72:30 - product
72:33 - query
72:35 - all
72:38 - so
72:39 - let's see if this works
72:45 - so let's see if this works
72:49 - so
72:50 - the endpoint is api slash products
72:55 - and we got one product
72:57 - let's create
72:59 - one product here so we can see it if it
73:02 - works
73:05 - so we got this product that we just
73:07 - created
73:09 - so
73:10 - we should see it in the database
73:13 - notice that the id is three
73:16 - so when we created this product
73:19 - we don't start with one but the idea
73:22 - that we have it on our django app
73:26 - now let's send the request
73:28 - and we get an error
73:30 - because object of type product is not
73:33 - json serializable
73:35 - to fix this error we have to add here it
73:39 - data class
73:42 - and let's import it from data classes
73:45 - so
73:47 - with this now the
73:49 - class will be json serializable let's do
73:51 - the same for the product user
73:55 - send the request again
73:58 - and we got an md object
74:01 - but we want to see the data which we got
74:04 - id title and image here
74:07 - to do it we have to declare it here
74:10 - id should be an int
74:14 - title
74:17 - should be a string
74:20 - str so and image
74:24 - should be a string
74:27 - with these changes now
74:29 - we can see the id image and the title
74:34 - so with this we completed
74:37 - the main route
74:38 - now let's add another route so
74:42 - i'll call it like
74:45 - and this will have
74:47 - up
74:49 - route
74:52 - api
74:55 - products
74:57 - we need the idea of the product which is
75:00 - an integer
75:01 - the id
75:03 - and
75:04 - we have to like it so this is the end
75:07 - point the method
75:09 - is a post request
75:12 - and when we like we will
75:15 - send an id here
75:19 - so
75:20 - how do we like the product so now it's a
75:23 - little bit complicated we have to
75:24 - internally call
75:26 - the
75:27 - django up
75:28 - so we have to internally call this user
75:31 - api view here to get a random id
75:34 - and we have to assign it to the product
75:36 - user so first we have to
75:41 - create a variable i will call it rec
75:43 - and this
75:44 - will call requests
75:49 - dot get
75:51 - let's import requests
75:54 - from
75:55 - so we import directly requests here
76:01 - and now we have to get
76:04 - the endpoint so the endpoint is http
76:10 - localhost
76:12 - port 8000
76:14 - slash api slash user
76:18 - and for the moment we will just return
76:21 - json if i
76:23 - request
76:25 - json
76:27 - not sure if i need jsonify here but
76:31 - let's try it
76:33 - so
76:36 - products with an id1 we need to like it
76:41 - let's send a post request
76:43 - send
76:44 - and we get an error connection refused
76:49 - so what is the error here
76:51 - there is localhost here because right
76:54 - now we are inside the docker container
76:57 - and the localhost inside the docker
76:59 - container is 0.0.0
77:03 - how to connect
77:05 - with another docker container localhost
77:07 - we have to specify here
77:09 - that this is
77:11 - docker
77:12 - for
77:14 - mac
77:15 - localhost
77:18 - so this is the way the docker knows that
77:21 - we are referring not the
77:23 - container localhost but
77:26 - another localhost so our local localhost
77:29 - so with this change
77:32 - let's try to send it again
77:33 - it seems we
77:36 - the server stops so we probably need to
77:38 - restart it
77:44 - send it again and now we got id2
77:47 - so this is id from
77:49 - the user so
77:52 - this will be user here
77:55 - so not post get
77:58 - so
78:00 - this
78:01 - endpoint 8001 will call this other
78:04 - endpoint
78:07 - now that we got the response let's use
78:10 - it and create a product user
78:13 - so here
78:16 - we will
78:17 - get a json
78:20 - is request.json
78:24 - in the end if it is successful we will
78:25 - return a message
78:28 - success
78:32 - and
78:32 - we will
78:33 - make a try
78:35 - accept here
78:37 - so what we will try is we will create a
78:40 - product
78:41 - user
78:42 - which is equal to product user
78:46 - with user id
78:48 - is equal to
78:51 - json
78:53 - id
78:54 - and the product id
79:02 - is equal to the id that we just set this
79:05 - one
79:06 - from the url
79:09 - and now that we set this product user we
79:11 - have to add it
79:12 - db session
79:14 - add
79:16 - product user
79:18 - and we have to commit
79:24 - and here we'll send an event
79:27 - which i will send it later
79:30 - and if an error happens
79:33 - there is
79:35 - when the user tries to
79:37 - like again because this is an unique
79:39 - constraint
79:41 - if that happens we will abort
79:45 - let's import a board
79:49 - from flask board
79:51 - we'll put 400 here and
79:54 - you
79:55 - already
79:56 - liked
79:58 - this product
80:01 - so
80:02 - a board we imported from from flask here
80:07 - so let's try it
80:09 - let's send the request again send
80:12 - success
80:14 - if we see the database
80:16 - product user we created one
80:19 - and it will happen that we will fail
80:25 - it seems that our unique constraint
80:28 - didn't work
80:30 - so
80:31 - i probably made a mistake here but i
80:33 - won't focus on that
80:35 - let's uh finish this up by sending an
80:38 - event
80:39 - now we need to
80:41 - get the producer
80:43 - i'll copy the same producer here
80:48 - so everything now is the same
80:51 - and we have to use it here
80:55 - now
80:56 - if this is completed we have to add
80:58 - here producer so
81:01 - publish
81:04 - let's import it
81:07 - product
81:08 - liked
81:09 - and we have to pass the id of the
81:11 - product
81:13 - so let's we need to import it here
81:18 - so this is our
81:20 - flask up
81:21 - only one thing that
81:23 - i think is easy fixable
81:25 - now let's make the last change here on
81:28 - the consumer
81:31 - we will get the
81:32 - data here
81:34 - which is equal so let's import json
81:39 - json
81:41 - loads
81:42 - body
81:45 - let's print the data
81:48 - and we here will
81:51 - like the product so we'll get a product
81:53 - first
81:55 - which is equal to product
81:58 - let's import it so from products models
82:02 - we'll import product
82:05 - that
82:06 - objects
82:08 - get
82:10 - id is equal to data
82:13 - so i will directly make this
82:15 - an id
82:19 - so we got the id now product
82:25 - likes
82:27 - will equal to product
82:29 - likes
82:30 - plus one
82:32 - so we will increment it by one in the
82:35 - end we'll save it
82:40 - and we will print that
82:42 - product
82:46 - is
82:48 - product likes
82:50 - increased
82:56 - just to be sure let's
82:59 - rebuild the containers
83:04 - and we will rebuild this too
83:13 - so this is completed
83:15 - now
83:18 - we have the products here
83:22 - so
83:24 - we have two products and they have zero
83:27 - likes
83:29 - now for the product with an id2
83:33 - let's see if we have that product in the
83:35 - main
83:37 - so three i guess
83:40 - so for the product with id3 i'll post
83:43 - here to like it
83:46 - and this should increase the likes
83:49 - so i guess we have an error
83:53 - received in main
83:56 - so my bed
83:58 - when i made the producer
84:01 - i should change here the
84:03 - routing key should be admin
84:07 - so
84:08 - let's rebuild
84:13 - and this should
84:15 - receive the event
84:18 - now let's like again
84:21 - not here here
84:24 - so this should not receive the event it
84:27 - didn't
84:28 - this
84:29 - did receive the event
84:32 - actually we got an error here
84:34 - so
84:36 - requested setting installed ups but
84:38 - settings are not configured this error
84:41 - happens because this file is outside of
84:44 - django and we are using the product here
84:47 - and
84:48 - to use a product regularly we have to
84:52 - load
84:53 - so we have to set up jungle before
84:55 - getting the product
84:57 - so we have to import here
85:00 - os
85:01 - and
85:01 - django
85:03 - we have to set uh an environment
85:05 - variable django sent is sending settings
85:08 - module is equal to admin settings so
85:10 - this settings here
85:13 - and we have to add django
85:16 - setup here
85:19 - with this
85:20 - we won't have that error so let's
85:23 - rebuild the containers
85:25 - we can see now that we started consuming
85:27 - so
85:28 - let's
85:30 - try it again
85:32 - now success let's send it again and we
85:35 - see the likes are increased here so
85:38 - we received the event
85:42 - so now we are communicating back and
85:44 - forth with both apps
85:47 - so this was
85:49 - the app that i wanted to show
85:52 - now it's time to create the react
85:54 - frontend
85:55 - i'll create a react project with
85:59 - typescript so to create it write mpx
86:04 - create
86:05 - react app
86:08 - i will call it react
86:10 - crud
86:12 - and the template
86:14 - will be typescript
86:20 - let's wait till it's completed
86:36 - now the project is created we can go to
86:39 - the folder
86:42 - and run npm start
86:46 - now the project is running and if you
86:48 - open the browser we can see
86:50 - on localhost port 3000 we have our app
86:53 - running
86:55 - now let's open the project with our ide
86:58 - and this is the project that we just
87:00 - created all the files are in typescript
87:03 - so i will remove the
87:06 - app.test.tsx file
87:08 - we won't be using uh
87:10 - tests here in this tutorial and now
87:12 - let's add the template
87:15 - for
87:16 - this project so we don't use the default
87:18 - react template
87:20 - go to
87:21 - getbootstrap.com
87:24 - examples
87:25 - and
87:27 - i will go to the dashboard here
87:30 - and get this template so
87:32 - let's view the page source
87:34 - and i will copy the html from the body
87:38 - till
87:39 - the
87:40 - end
87:41 - so
87:43 - and i will paste it here
87:47 - so my id is smart so all
87:51 - class now are have been converted to
87:53 - class name
87:54 - if your id doesn't do that you make sure
87:57 - to do it yourself so i will remove all
88:01 - these tr's here because there are a lot
88:05 - and i will keep only one so
88:08 - i will keep only this
88:10 - we don't need the canvas
88:13 - we don't need the buttons
88:16 - so
88:17 - let's make some changes so
88:20 - we can remove this ul nh6
88:24 - so
88:26 - this can be removed also
88:28 - so we can keep the dashboard
88:32 - and let's remove this pan
88:35 - so
88:36 - let's make everything
88:38 - much simpler so we remove the
88:41 - ally here
88:44 - so
88:45 - we have an error here also which is the
88:48 - error
88:50 - so there is this input which we need to
88:53 - add a slash here
88:56 - and everything should be
89:00 - correct
89:01 - now let's remove this logo here
89:04 - and
89:06 - it will look ugly
89:09 - so if we see our app it looks very ugly
89:12 - because we need to add also the styles
89:14 - so
89:15 - here
89:16 - we have the dashboard.css
89:19 - which we have to copy it
89:21 - and add it to our app css
89:25 - paste it here
89:28 - and
89:29 - now it will
89:30 - look a little bit better but we also
89:32 - need to add bootstrap so go to
89:36 - bootstrapcdn.com and here we need to
89:39 - copy the html link
89:41 - and add it to our index.html
89:46 - now that we added this link
89:49 - it will look much better so this is a
89:52 - template
89:53 - we will be using
89:56 - so let's make further changes
89:59 - so i'll create two components now
90:02 - this is
90:03 - the
90:04 - navigation
90:06 - so
90:07 - i will create a folder
90:10 - components
90:12 - inside i will create a new component
90:16 - i'll create it
90:17 - now
90:18 - and will be typescript.jsx file
90:24 - inside i will create a stateless react
90:26 - component and i will use this shortcut
90:30 - in my ide
90:33 - so we need to import react from react
90:37 - we need to create our component
90:39 - as a constant
90:40 - and this is a function which we need to
90:43 - export in the end
90:45 - here is html so the html
90:48 - let's cut this part here
90:52 - and paste it in our nav so let's replace
90:56 - it
90:58 - now that we replace the html we can use
91:01 - the component directly here
91:03 - so let's call it
91:06 - nav
91:08 - my id auto imports components so
91:12 - you should import now from components
91:16 - nav here and use it directly
91:19 - if we see the browser nothing will
91:21 - change
91:23 - let's create another component now which
91:25 - is the menu which is this one
91:27 - so let's do the same
91:34 - menu
91:37 - create the component
91:39 - and let's
91:41 - cut html
91:51 - actually the name here will not be
91:53 - dashboard will be products
91:57 - and let's use the menu in our app.esx
92:09 - so that's it now everything looks
92:12 - much more simpler and our component
92:14 - looks much better
92:16 - now we need to create more components
92:18 - for our app
92:19 - so we will have two main apps so one is
92:23 - the admin
92:25 - and the second one is the main app
92:30 - so first we will focus with the admin
92:33 - which is
92:34 - what we have been doing till now
92:37 - and then we will create the main app
92:40 - so inside the admin app we need to
92:42 - create the products component so let's
92:45 - create another component
92:47 - products
92:50 - let's let it be a jsx typescript file
92:54 - and this component
92:57 - for html will have the html
93:01 - for this table basically so let's
93:04 - cut it
93:06 - and let's
93:07 - paste it here
93:12 - so note that react doesn't allow to have
93:15 - two
93:17 - html elements
93:19 - nearby each other
93:20 - they all need to be wrapped inside a
93:23 - bigger one so this makes
93:25 - sense
93:27 - either that or i will just remove the
93:30 - section title so
93:33 - i will keep it much more cleaner this
93:35 - way
93:37 - now
93:38 - let's add these
93:40 - products here so
93:42 - one way is to add directly the product
93:45 - here
93:46 - but
93:47 - we don't want to do this because we will
93:50 - create more components which
93:52 - they will change here
93:54 - nav and menu will stay the same but this
93:56 - will change so
93:58 - uh to fix this we have to install
94:00 - another package we see which is react
94:03 - router dom
94:05 - so open the terminal and write npm
94:08 - install
94:09 - react router dom
94:12 - and types
94:14 - react
94:15 - router
94:16 - dom
94:18 - we need this second package because the
94:22 - first one is javascript package and the
94:24 - second one is
94:26 - the typescript package so for all the
94:28 - typescript apps you need the to do it
94:32 - this way
94:36 - now
94:37 - reactor router dom is installed
94:40 - now we have to use it here so
94:43 - to
94:44 - map the products
94:46 - via the router we have to import two
94:48 - packages
94:50 - so the first one is browser router
94:54 - and the second one is
94:56 - route
94:57 - not router route so let's replace this
95:02 - products here
95:03 - and inside we will add browser router
95:08 - this is a container for all our routes
95:11 - and let's add our first route which is
95:16 - for the products so
95:19 - we have to specify a path
95:22 - the path for products will be
95:25 - admin
95:26 - slash products
95:30 - and the second parameter we need to add
95:32 - the component
95:34 - which in our case is the products
95:39 - so that's it so
95:42 - this is a path we can reference the
95:45 - products now
95:47 - so
95:49 - right now nothing is happening because
95:51 - we are at the main app
95:54 - so if we go to
95:55 - admin slash products
95:58 - we can see we can see the table now
96:01 - so
96:02 - this is working
96:05 - now let's add the main template so
96:09 - let's go again to get bootstrap.com
96:13 - to the examples and this will be the
96:16 - template for our
96:18 - main app
96:19 - so let's copy the code from the body
96:23 - so
96:24 - from here
96:26 - till here
96:27 - and
96:28 - we have to create a new
96:30 - component for main
96:34 - main here
96:37 - let's create a component
96:39 - and here we'll paste
96:42 - the html we just cut
96:45 - so let's remove
96:47 - most of the
96:49 - call md4 here because
96:52 - we don't
96:54 - need all of them
97:01 - so we keep only one
97:05 - we don't need neither the
97:08 - jump drone here
97:10 - and neither the header
97:12 - so we can remove the header
97:16 - and
97:18 - this is almost what it will look like
97:23 - so we will make changes later
97:26 - but for now
97:28 - i will remove also the svg here
97:31 - so for now
97:33 - let's create
97:35 - a
97:36 - route for this so
97:39 - the route for the main app will be route
97:46 - the path will be the main path
97:49 - so slash
97:50 - and the component
97:54 - will be the main component
97:58 - don't forget to import it
98:01 - so if we go to the main component
98:04 - now
98:05 - it will look
98:08 - so first
98:10 - this is what the product component looks
98:12 - like which is
98:14 - weird and also if we go to the main page
98:19 - we can see this is what the main
98:20 - component looks like but
98:23 - we don't want the navigation in the menu
98:25 - here
98:26 - so
98:27 - what is that we are making a mistake so
98:32 - first
98:33 - we need to
98:34 - remove the nav and menu from this route
98:38 - so the only way to do it is by creating
98:41 - a new
98:42 - wrapper
98:43 - component for the admin
98:45 - so let's
98:46 - do it
98:48 - let's create here
98:50 - a typescript file called wrapper
98:57 - so
98:59 - inside i will create a component
99:02 - and the html for that component will be
99:04 - this
99:05 - nav and the menu
99:07 - so
99:09 - i will cut this part
99:12 - go to the wrapper and paste it here
99:16 - so inside the div
99:19 - let's also cut
99:21 - what
99:21 - i left here
99:24 - and paste it
99:26 - so
99:28 - this is
99:29 - now the wrapper component
99:31 - so why do we need this component so we
99:34 - have to use it directly in our products
99:37 - so we can wrap this with the wrapper so
99:41 - wrapper
99:45 - and now
99:46 - in this component we will use the
99:50 - menu and nav
99:51 - so we are having an error here because
99:54 - we are not using it correctly
99:56 - inside here we have to
99:59 - use
100:00 - the child properties that we have so we
100:03 - have to add here props
100:07 - uh we are having an error also here
100:09 - because we are
100:11 - using typescript
100:13 - we have to specify a type which is
100:16 - props
100:17 - with children
100:20 - any
100:21 - so these are the props that we have and
100:24 - to pass the child properties we have to
100:26 - use props
100:28 - children
100:31 - this way
100:33 - we will
100:34 - pass
100:36 - the html inside here to the rubber
100:40 - and
100:41 - if we go to the
100:43 - this is the main
100:45 - app now which looks much better and if
100:48 - you if you go to the
100:50 - admin slash products
100:53 - still
100:54 - doesn't look good
100:56 - still we see this
100:57 - main
101:01 - card
101:03 - so
101:04 - what is the issue here the issue is
101:07 - this slash
101:09 - the problem with
101:10 - this slash is that
101:12 - they both have slash and react confuses
101:14 - them
101:15 - and to solve that we have to use exact
101:18 - here
101:20 - this means that
101:21 - the path
101:23 - is exact here and don't confuse it with
101:26 - the other
101:28 - paths
101:29 - with this
101:31 - products will look
101:33 - the same as before and
101:37 - the main app will look
101:39 - different
101:41 - so
101:42 - this is how
101:44 - we use route so let's remove nav and
101:46 - menu we don't need it here
101:48 - actually these components which are nav
101:51 - and menu we have to move it to our admin
101:54 - because they belong there
101:56 - don't forget also to
101:58 - change the imports here which my id does
102:03 - it automatically
102:05 - so now we got the admin
102:08 - the main app
102:09 - which we will use it later
102:11 - and now let's focus on our products
102:14 - component
102:17 - now let's fill the table for the
102:19 - products
102:21 - to fill the table first we have to get
102:25 - all the products and
102:27 - to do it we have to use
102:29 - use effect
102:33 - and
102:34 - inside
102:35 - accepts
102:36 - a function as a parameter
102:38 - and the second parameter
102:40 - will be an empty array
102:42 - this
102:43 - empty array means that this will be
102:46 - called only once
102:48 - if we put a variable that changes
102:51 - use effect will be called every time the
102:53 - variable changes
102:55 - we'll see this later on
102:58 - now inside here we need to call our
103:01 - backend to get our data
103:04 - so
103:05 - we cannot
103:06 - make this use effect asynchronous here
103:12 - it doesn't accept it so the way to do it
103:15 - is to create a function
103:19 - get products
103:21 - and this will be an asynchronous
103:23 - function
103:25 - and
103:27 - in the end we will call it so get
103:30 - products
103:32 - this is a way to call asynchronous
103:34 - functions in
103:36 - react but there is an even easier way
103:40 - so we can remove
103:42 - get products totally
103:45 - so let's open a parenthesis here and
103:48 - close the parenthesis
103:51 - when we call it so
103:54 - this is my preferred way of calling
103:57 - asynchronous functions in react so open
104:00 - parenthesis close parenthesis and then
104:02 - you call it directly
104:05 - here inside now let's call our backend
104:08 - let's get a response
104:11 - is equal to await
104:13 - fetch
104:14 - the endpoint would be http
104:17 - localhost port 8000
104:20 - slash
104:22 - api slash products
104:28 - once we get the response we have to get
104:29 - the data which is equal to a weight
104:33 - response
104:34 - json
104:37 - so we got all the data so first let's
104:39 - console.log it
104:45 - and
104:46 - inspect here
104:48 - we will see that we get the products
104:50 - here and the console log works
104:53 - so we got all the products
104:56 - now we have to get them and loop them to
104:58 - do it we have to use another react hook
105:01 - command which is use state so
105:05 - use state
105:08 - accepts a default first parameter so
105:11 - a default value which is an empty
105:14 - uh array for the products and the
105:18 - returns
105:20 - products
105:21 - as a variable and set products
105:25 - as a function so these
105:27 - work together with each other once we
105:30 - set the products these products get set
105:33 - so
105:34 - set products will be used here
105:39 - data
105:41 - now we set the products it means this
105:44 - variable has changed so
105:47 - we have to use that variable here
105:51 - let's
105:52 - use it
105:54 - so we have to
105:55 - map it so
105:57 - products
105:58 - map
106:01 - it will return a product
106:04 - that returns
106:06 - this
106:09 - html
106:11 - so the we need to add a key here so for
106:14 - every
106:17 - loop that we have we have to have a key
106:20 - now we are having a type error here
106:22 - because we have to cast the product here
106:26 - so we have to create a folder here
106:28 - interfaces
106:31 - and inside will create a product
106:33 - interface
106:34 - so
106:36 - product
106:39 - not products but product
106:44 - here we'll export an interface
106:47 - product
106:49 - and this interface will have an id
106:51 - as a number
106:53 - a title as a string
106:56 - an image
106:58 - as a string
107:00 - and
107:02 - it will have
107:04 - likes
107:05 - as a number
107:08 - so this is a product that we have
107:11 - let's go back
107:13 - and now we have to cast this product as
107:18 - product
107:19 - don't forget also to import it here
107:23 - so we have the key now
107:27 - now let's call
107:29 - every other variable so this is id
107:33 - i also forgot here to put the headers so
107:36 - the first one is the image
107:40 - this is a title
107:43 - this is a likes
107:46 - and this is the action
107:50 - so
107:50 - the second one
107:52 - is the image so we have to put an image
107:55 - here
107:57 - with the source
107:58 - to be
107:59 - product that
108:00 - image
108:02 - and the height will be
108:05 - 180.
108:08 - this is a
108:09 - product
108:10 - title
108:11 - and this is a product
108:18 - likes
108:20 - for the moment i will
108:23 - keep actions to an empty
108:26 - td
108:27 - now let's see it on the browser
108:30 - so we retrieved products with images
108:33 - so for some reason the image doesn't
108:36 - show so
108:38 - this
108:39 - site lorem pixel doesn't work uh
108:42 - currently for me but if it works
108:45 - it will show images here
108:48 - so this is how we retrieve products and
108:51 - we loop them
108:53 - to show them as a table
108:56 - now let's delete a product
108:59 - in the actions here
109:01 - we need to add some more html
109:04 - so i will add this html which is just a
109:07 - button delete
109:10 - so we want to delete a product
109:12 - so first let's create a delete function
109:17 - i will call it d
109:20 - deal not delete because it's a keyword
109:23 - so
109:24 - this function
109:27 - will accept an id as a number
109:32 - and we have to call it here
109:34 - so to do it we have to add the non-click
109:38 - listener
109:40 - and we have to
109:42 - call
109:44 - the delete function
109:46 - with the product id
109:50 - so this is how
109:52 - we call
109:54 - the delete function for a different
109:56 - product
109:59 - now that we have the delete product we
110:02 - have to make it asynchronous
110:05 - and we have to call our backend to
110:07 - remove the product
110:09 - so to do it we have to
110:13 - make
110:15 - a weight method
110:17 - fetch so i will copy
110:19 - this part here
110:24 - so in this case now we need to pass
110:27 - the id
110:28 - so
110:29 - i will
110:30 - convert the quotes here to this kind of
110:33 - quotes i don't know the name of these
110:35 - quotes
110:36 - but
110:37 - with these quotes
110:39 - you can add
110:40 - variables to the string which is the id
110:43 - in this case
110:46 - this is not a get request
110:49 - this is a get request but we want to
110:51 - make a delete request here so we have to
110:54 - pass some parameters
110:56 - so
110:59 - the method
111:00 - will be
111:01 - delete
111:05 - so with this function call we will
111:08 - delete a product
111:10 - in the back end but we
111:12 - need also to remove it from the front
111:14 - end
111:15 - so we have to call set products again
111:19 - so set products
111:22 - and we have to get all the products
111:24 - except the product that have this id
111:28 - so
111:28 - we have to get all the products
111:34 - and we have to filter them
111:37 - and the filter will have the product
111:41 - as a product id
111:43 - so product is a product here
111:46 - and we will filter all the products that
111:51 - have the id
111:52 - different than this id
111:56 - we can keep it
111:58 - one liner here
112:02 - so this means that we are getting all
112:04 - the products except this product id and
112:07 - we are setting it so
112:09 - the
112:10 - table refreshes itself
112:14 - one last change that we need here is to
112:16 - add a confirmation
112:18 - since we don't want to delete the
112:20 - products directly
112:22 - so we add a new condition here
112:25 - window dot confirm
112:28 - are you sure you want to delete
112:33 - this product
112:38 - and
112:39 - we close
112:41 - all what we did
112:44 - inside this if statement
112:47 - so once we click delete
112:50 - the browser will ask this question if we
112:52 - type yes then the product will will be
112:55 - deleted
112:56 - let's see it on the browser
112:58 - so i will delete product number four
113:01 - when i click i will get a question are
113:04 - you sure you want to delete this product
113:06 - i type ok
113:08 - then
113:09 - we can see product with id4 is removed
113:12 - if i refresh
113:14 - it's also removed in the backend
113:17 - so this is how we delete products
113:22 - now let's create some products first
113:25 - let's create a new rear component
113:28 - products
113:30 - create
113:33 - and this will be a normal react
113:35 - component
113:37 - and
113:38 - now that we created it we have to add it
113:41 - to our router so
113:44 - the route for this
113:47 - component will be admin products slash
113:50 - create
113:53 - and this will be products
113:56 - create
113:58 - let's make every component exact
114:03 - so we don't have any problems
114:07 - this also
114:11 - now let's go to our products
114:13 - we will add here
114:15 - this
114:16 - html
114:18 - it's just a link
114:19 - and we will have to change this anchor
114:22 - link to a
114:24 - link
114:25 - from react router dom so i automatically
114:28 - imported it but
114:30 - you have to do it on your own so import
114:32 - link from react router dom
114:35 - and this link will redirect to
114:43 - admin
114:48 - products create
114:51 - let's add a slash in front
114:55 - and we don't need this curly braces so
114:59 - this is the link that we want
115:02 - so if we see the browser we can see an
115:04 - add button here that when we click
115:07 - we go to the products create page
115:10 - which is empty right now so
115:12 - in the products create let's convert
115:15 - this div to just wrapper
115:17 - and
115:18 - now it looks better
115:20 - inside here i will create this simple
115:23 - form
115:25 - that
115:25 - accepts only a title and an image
115:29 - and a button to save it so it will look
115:31 - like this
115:33 - now let's make this form work
115:36 - first
115:37 - we have to create variables from the
115:40 - state for the title and the image so
115:43 - we'll create
115:45 - the title
115:46 - set title
115:48 - from
115:50 - use state
115:53 - and the default
115:54 - value will be empty
115:57 - let's do the same for the image so this
116:01 - is image and this is
116:04 - set image
116:07 - now that we got
116:10 - the variables we can set it directly
116:13 - here so when we change this input we
116:17 - have to set the title
116:19 - so we had an unchanged listener here
116:24 - and the event will call set
116:28 - title
116:30 - and the value will be event that target
116:33 - that value
116:36 - this means every time this input changes
116:38 - so when we type here
116:40 - we'll set the title
116:43 - so let's do it the same for
116:45 - the image so on change
116:48 - event we'll call set
116:51 - image event.target.value
116:57 - now in this title an image we got the
117:00 - values that the user set
117:02 - so we are ready to use them in when the
117:05 - form is submitted so
117:08 - let's add an onsubmit
117:12 - call here
117:13 - let's create also the function
117:15 - submit
117:19 - and
117:20 - for the moment just console.log
117:23 - the title and the image
117:28 - and on the submit here we will call the
117:31 - submit function
117:36 - so
117:37 - let's test it on the browser let's
117:39 - inspect
117:42 - and
117:42 - let's put a title here and an image
117:47 - save
117:49 - i saw console log but immediately the
117:52 - page
117:52 - refreshed
117:54 - so
117:55 - that is a problem so we have to
117:57 - prevent that
117:59 - and to do it we have to call here to to
118:02 - add an event parameter here and to call
118:06 - event.
118:10 - prevent
118:12 - default
118:13 - typescript wants us to type the event
118:16 - here so synthetic
118:22 - event
118:25 - let me type it
118:27 - synthetic
118:29 - event
118:32 - so
118:34 - that
118:35 - will prevent the page refresh so if we
118:38 - try it again
118:42 - we can see that we consult log
118:45 - test and test
118:47 - now we are ready to call backend to
118:50 - create our
118:51 - product
118:53 - so let's make this function asynchronous
118:57 - and
118:58 - here
118:59 - we'll call weight
119:03 - fetch
119:05 - http localhost port 8000
119:09 - slash api slash products
119:13 - and we have to add some
119:16 - options
119:18 - the first one is a method which is a
119:21 - post method
119:24 - the second one is the headers so this is
119:28 - a
119:29 - http request so we want to work with
119:33 - json
119:34 - so we have to add
119:35 - content
119:37 - type
119:40 - application
119:42 - slash json
119:46 - and
119:47 - we need also to send the data which are
119:49 - these two variables that we have here
119:52 - so we have to send them in the body
119:56 - and we have to stringify them so json
120:00 - stringify because
120:02 - it accepts a string
120:04 - we want to send
120:06 - an object so
120:08 - we need to add the title here
120:11 - and the image
120:14 - note that this title here is the same as
120:16 - title title here
120:19 - but
120:20 - to keep it short and simple
120:22 - we can use it like this
120:25 - now we can create products with this
120:27 - request
120:28 - we need
120:29 - one more change because we want to
120:32 - redirect to the products once
120:35 - we submit the form
120:37 - so let's create another state here
120:42 - i will call it redirect
120:45 - and set redirect
120:49 - use state
120:51 - and the default value will be false
120:55 - here i will add the condition if
120:57 - redirect
120:59 - we want to return
121:01 - redirect
121:05 - so let's import it so importer direct
121:08 - from react router dom
121:11 - we want to redirect to
121:14 - admin slash
121:16 - products
121:19 - and once we create a product we want to
121:23 - set redirect to true
121:26 - so this means
121:28 - if this is successful we redirect to the
121:32 - main table
121:34 - let's try it out
121:36 - let's create a product
121:39 - title
121:40 - image
121:41 - save so if we
121:43 - redirect it means it works
121:46 - so we can see it did work so let's
121:50 - create another one with a
121:52 - correct image
121:54 - and let's put a title here
121:57 - bird
122:01 - so we can see
122:03 - this is working correctly and the
122:05 - redirect works correctly
122:09 - now we want to edit products
122:12 - to edit products is almost the same as
122:14 - creating products so i will copy the
122:18 - products create component
122:20 - and
122:21 - paste it and change the name to products
122:24 - edit
122:27 - let's rename also this variable products
122:31 - edit
122:33 - and
122:34 - rename this also products edit
122:38 - so
122:40 - now that we created products edit let's
122:42 - add it also to our routes
122:45 - let's duplicate this
122:47 - and the route now is different
122:50 - so we need to go to admin slash product
122:53 - slash
122:54 - id slash
122:56 - edit
122:58 - we need the id of the product that we
123:00 - want to edit
123:01 - and the component is products
123:06 - edit
123:09 - now we need to get the product from this
123:13 - id that we are fetching
123:15 - but first let's go to our products
123:19 - and here we need to add another link
123:22 - let's copy the link for the delete and
123:25 - name it edit
123:27 - we don't need a non-click listener here
123:29 - but
123:30 - we have to rename this to a link
123:34 - and we have to redirect to
123:38 - the path that we want to redirect is
123:42 - admin slash products
123:44 - slash
123:46 - the id so product dot id here slash edit
123:53 - and don't forget to end it with the link
123:55 - here
123:58 - so this button will appear on the table
124:00 - now
124:01 - so along with
124:04 - the delete button now we have an edit
124:06 - button
124:07 - let's click the edit button
124:09 - and right now nothing happens
124:12 - so i made a mistake a spelling mistake
124:15 - here so it's products here
124:22 - let's go back
124:23 - and type edit again let's refresh just
124:26 - in case so
124:27 - this is the product edit form
124:30 - now we have product with id number two
124:33 - we have to set the titles and the image
124:35 - for the product with id number two
124:39 - so
124:39 - to do it let's go to products edit now
124:43 - we have to call use effect
124:47 - and
124:49 - inside here we need to call our backend
124:52 - for
124:53 - that product
124:54 - so like we did before
124:57 - i will open two braces here and make a
125:00 - sync function
125:05 - so this is my way of
125:07 - calling uh
125:09 - an sync function inside use effect
125:13 - inside here we need to call the backend
125:16 - so
125:17 - response is equal to weight fetch
125:22 - let me copy this
125:25 - part here
125:26 - so i will use this braces
125:29 - now we need the id of the product so we
125:31 - have to get a product with the id that
125:33 - we got from the url
125:36 - to get it
125:37 - we have to add the props here
125:41 - and this time is props
125:43 - with reference
125:47 - and
125:48 - based on the props now
125:50 - the id is
125:53 - props
125:55 - match
125:57 - params
125:58 - dot id
126:02 - the id here corresponds to
126:05 - this id here so the the actual name
126:10 - and to get the query params we have to
126:12 - use
126:13 - props match params
126:16 - now
126:18 - we get the response let's get also the
126:22 - product
126:24 - which is equal to a weight
126:26 - response.json
126:30 - once we got the product we have to set
126:32 - the title and the image based on this
126:35 - product so set
126:36 - title
126:38 - to product
126:40 - dot title
126:43 - set image
126:45 - product
126:46 - dot
126:47 - image
126:50 - we can cast this product as a product
126:53 - here
126:54 - since
126:55 - it is a product
126:58 - so
127:00 - let's see how this looks on the browser
127:02 - now
127:03 - and this is not working because we
127:05 - forgot to add something else
127:08 - we set the values but
127:10 - this doesn't mean that the inputs will
127:12 - reflect that value
127:14 - so we have to add here
127:16 - a default value
127:18 - for the title
127:21 - same for the
127:23 - other input so default value will be
127:26 - image here
127:29 - now once this change
127:31 - the input will change also now we can
127:34 - see
127:35 - the data are pre-filled based on the
127:37 - product so if i change this from number
127:40 - two to number one
127:43 - we can see we have different values
127:47 - the last change we need is
127:49 - to change this fetch now
127:53 - this now is a different url
127:56 - we'll call api product slash
128:01 - props
128:02 - match
128:04 - params that id
128:07 - and the method is put
128:12 - all of the other things are the same
128:16 - now let's test it on the browser
128:19 - so i will change the image to
128:22 - this image and i will say
128:26 - updated
128:28 - title
128:29 - for the product with id 1
128:32 - let's save it
128:33 - now i'm redirected and we can see a new
128:36 - image and an updated title
128:39 - so
128:40 - this is how
128:41 - we update products
128:45 - now let's
128:46 - complete the main app
128:49 - so this should be a list of products so
128:53 - let's
128:54 - create
128:56 - products from the state so products
129:00 - set products
129:04 - equals to use state
129:06 - and
129:07 - the products will be an empty array in
129:09 - the beginning
129:11 - now we have to get all the products so
129:14 - we have to use use effect
129:18 - an empty array a
129:20 - function sorry and this will be an empty
129:22 - array
129:24 - inside here
129:25 - we'll call
129:27 - our backend
129:28 - so this will be an async function
129:32 - will get response
129:35 - from
129:36 - fetch
129:38 - http localhost
129:40 - port 8001 now
129:44 - so before it was 8 000 now it's 8001
129:48 - api slash
129:50 - products
129:55 - once we get the response we have to get
129:58 - the data which is equal to weight
130:02 - response
130:03 - dot json
130:08 - i forgot a weight here
130:13 - and in the end we have to set the
130:15 - products
130:16 - to this data that we got
130:20 - now we set the products we have to loop
130:22 - them here
130:24 - so
130:25 - this is the html that we want to loop so
130:30 - products
130:32 - map
130:35 - we have to get every product
130:39 - and return
130:40 - this html
130:43 - so this needs a key
130:47 - product.id
130:50 - this needs the product to be cast to
130:53 - product
130:58 - so let's make the other changes now
131:00 - first we need an image here
131:04 - so
131:04 - let's write an image stack
131:08 - with the source
131:10 - to be product
131:12 - that image
131:15 - height will be
131:17 - 180.
131:20 - this is
131:21 - the product
131:23 - title here
131:30 - here we need to only one button
131:33 - which is like
131:37 - and
131:38 - this is a number of likes so it's not
131:41 - minutes
131:42 - this should be
131:45 - likes
131:50 - likes so that's it let's see how it
131:53 - looks like
131:54 - let's go to the main app
131:57 - and this is what it looks like so we
132:00 - have only two images that work because
132:02 - the other that don't work
132:04 - but this is the main idea
132:06 - now let's make this like function work
132:10 - so
132:12 - let's add a new click here
132:19 - on click
132:21 - and this will call the function
132:24 - like
132:25 - so this will be like this
132:28 - like
132:29 - with the product id
132:32 - let's make the like function
132:38 - this will have an id
132:41 - as a number
132:44 - so this works fine now let's complete
132:47 - the like function let's make this
132:49 - asynchronous here
132:51 - and this will call our backend
132:55 - here we need to wait
132:58 - fetch
133:01 - the
133:02 - url is almost the same here
133:06 - let's change it to these brackets and
133:10 - the endpoint is api slash product slash
133:13 - the id that we
133:15 - got as a parameter slash like
133:19 - and this will be a post request
133:26 - we need also to send some data but in
133:29 - this case we don't need any data so we
133:32 - need only to send the headers
133:35 - which is content
133:39 - type
133:41 - application
133:44 - slash json
133:48 - usually the post requests have some data
133:50 - but in this case we don't have any
133:55 - now that we like a product we also need
133:57 - to update
133:59 - this html so we need to set the products
134:02 - again
134:03 - so to set the products
134:06 - we need to loop and change all
134:10 - the current products so
134:12 - set products products
134:15 - map
134:17 - and for every product
134:22 - we have to make a condition now
134:25 - if
134:26 - this product
134:28 - that id
134:29 - is equal to this id
134:32 - that we got as a parameter here
134:35 - then
134:36 - product that legs
134:39 - will increase
134:41 - in the end return the product
134:43 - so this means
134:45 - that only this product with this id
134:48 - will increase the likes
134:51 - now we are having an error
134:54 - like
134:55 - argument of type product is not
134:57 - assignable of parameter of type
135:00 - set state action never
135:03 - this means that
135:04 - when we initialize the products here
135:06 - this is never
135:10 - this
135:11 - typescript interprets this is never like
135:14 - this
135:15 - so to fix this problem we have to
135:17 - manually cast
135:19 - this empty array as product array
135:24 - so this is an empty array but as a
135:26 - product array
135:28 - and immediately we see that we don't
135:30 - have an error anymore
135:33 - so this is how we fix typescript errors
135:36 - by casting
135:38 - the products directly
135:40 - let's open the browser now
135:42 - and
135:43 - if we like a product
135:46 - we can see
135:47 - the number of likes increases and that's
135:50 - it is very is very simple
135:52 - so this was our app that we wanted to
135:55 - build
135:56 - and
135:58 - i hope you like it
136:00 - don't forget to subscribe to the channel
136:02 - for more content thank you

Cleaned transcript:

hello and welcome to this tutorial i'm antonio papa from scalablescripts.com and in this tutorial we will create a microservices example using python and react let's start by understanding what is a monolith and what are microservices a monolith can be a large code base that has a lot of functionalities and is connected with the single big database in this example that i'm showing you you can think this as a nicomer site we have a search functionality that has a lot of traffic we have a product list which are cached we have a product recommendation functionality we which we can use machine learning to recommend different products and we have a contact page where we have less traffic there the problem with this architecture is if we want to scale this up because the search has a lot of traffic we have to replicate all the functionalities so we are replicating also the parts of the code that has no traffic like the contact page also since it is one repository there can be only one language and you can cause other problems with other teams if which if you change their code since there is only one repository now what are microservices microservices are smaller independent services that have their own database and they can communicate with each other using an event bus so in our example we will have four microservices all have their own database and they will communicate with each other via messages the advantages in this case are that we can scale the applications based on the traffic so if we see the search microservice we scaled that microservice four times compared to the contact where we have only one instance of the contact microservice another advantage is the separation of concerns now the product recommendation team can only focus on machine learning and not scaling up the application also each team can use a different programming language based on their needs now let's jump to the application that we will build in this example we will build a simple microservices example using python the front end of this app will be built with angular react view and swelt you can pick your favorite there the backend is composed into two apps an admin app and the main app the admin app will be built using django and the main app will be built using flask both will run in docker and will connect with their own database in mysql they will communicate with each other using rabbitmq events and in one case the main app will internally call the admin app now let's see what this app looks like so this is the app that we will build it's a simple app where this is the admin and this is the main app in the main app we can like the products and in the admin app we can create the products it is very simple but don't get deceived because it it has two backend apps with different database communicating with rabbitmq which i open it on my right side so let's see an example for example i will like this product here and when i like the product you will see an event happening in rabbitmq right now so the event has been triggered here and we have one ready event and now is zero so it means it was consumed so if we see here let's refresh the admin we can see that we got another like here so in essence it's really simple but this like has more functionality to it since it will internally call also the admin to get a random user and if we happen to like with the same user it will throw an error we can also create a new product so let's create a product and i will add a sample image we will see that rabbitmq will trigger another event so this is a product that we created another head event has been fired and when it's consumed here we will see the product here so it seems that the product is on the admin app on the main app so we got the product so we will see how this app will work by building them so let's start creating the apps so let's start building the admin app using django rest framework to create the project go to tutorial quick start and these are the commands to create a simple django project you have to install django and jungle rest framework from pip i already did it so i can directly go to the terminal and write django admin start project admin and the project is created i can go to the folder now and run python 3 manage that pi run server so the project is running now and i can copy this url and paste it to the browser and we can see that we successfully installed the django project now let's open the project with our ide and this is the app that we just generated now let's run docker so let's create two files one is docker file and the other one is docker compose dot yaml file so let's open the docker file first and what we will write here is first from what type of project is this so we want to get it from python and we have to specify the version of python i will pick the latest one which is 3.9 next we will add an environment variable python and buffered one because this is useful to get logs so we can see whatever is happening and now we have to specify a working directory i will call it just up so before going further i will create a requirements txt file so in this file we can put all the dependencies that we will use in our app so i will paste them here we will use django django rest framework mysql client and java mysql so we will connect with mysql jungle course headers this is needed for the front end to access the backend and pica this is useful when we will connect with a rabbitmq now that we added our requirements let's go to the docker file and we will copy requirements.txt to up let's copy the name here requirements.txt so we are copying this file to the work to the working directory requirements so we are copying inside the docker container and now we have to install it so we have to run a command pip install minus r requirements so paste it so this will install all these requirements and in the end we will copy all the files so dot slash up dot in this case means all the files here so we are copying all the files to the app directory the last command is running the project so we have to add here python manage that pi run server and we also need to specify the host so the host will be 0.0.0 0.0.0.0 with port 8000 so we have to use it this way otherwise we cannot connect the port with our localhost now let's go to our docker compose file here we have to start by adding the version the latest version of docker compose is 3.8 and then we have to specify the services so for the moment i will just add the backend service which is our app here first we have to specify the docker file so build we have to put here context which which is this folder and the docker file which is docker file so basically this means that this docker compose file should use this docker file so that's it next we need to specify a port here so this port that is running here is inside the docker container is not our local host so we have to tell our localhost to listen to a specific port so in my case this is the dockerfile port and this is our localhost port so if we don't use this we won't be able to access the server and the last change is the volumes so add here volumes and inside we will specify dot column up this means that dot means all the files here are connected with the docker container every time we make a change in the app it will pass it to the slash to the docker file up and the opposite if change happens in the docker file it will reflect it here so that's it this is our app now we have to start it first we have to stop the server here and open the terminal and write docker compose up now he's building the backend is downloading all the required libraries for python and it will also install all the requirements here let's wait till it's completed so now everything is running correctly we can see that the development server is running and also we stopped the server from this uh terminal and if we refresh now we'll see we'll get the same page now this is running from the docker container if we stop for example we won't be able to see it so now we don't see it if i start again now it will be much more faster so we can see it so this is how you connect django with docker now we have to connect with the database we already have an sqlite database here but we will remove it because we will be using mysql so the first thing we have to add the mysql service i will call it db and here i will add an image which is mysql version 5.7.22 so we added mysql next we have to add restart always so we have to add this command because uh sometimes mysql stops and this will stop also our docker container and our app is no will not run so this will restart it again next we have to add some environment variables so these are some environment variables that we will connect with our backend so we have to add mysql database which is admin mysql user root mysql password i will also put root here and mysql root password root so these values you can pick whatever values you want so you can specify them here next we have to add volumes so this is really important so mysql when we start when it stores data it needs to map them to a folder so i will create a folder here db data which will map var lib mysql so all the files here will be reflected to a folder here called db data so we will see that once we start this container so we are finished now we have to add here ports this is not required at all i will just add it so we can see the data inside the database so the port will be the default port for mysql is 3306 and this is inside the docker container outside we will use 33066 or whatever port we want i didn't put the same port because it will conflict with my mysql installation so that's it the last change is we should add here depends on db this means that this container should run first and then this container should run now let's close it and start it again now it's pulling mysql so we can see now the database is running so we can also see a db data folder here so this are the files that when we store anything it will be reflected here we don't have to touch this folder so this is just there to stay now let's connect with our ide so we need a new data source mysql and our port was 33066 root for the user root for the password and the database was admin let's test if we connect so we connected successfully now we have only one schema with no tables so now let's add some tables to the database first we have to create a new app so we have to go inside the docker container now so to go inside the docker container open a new terminal and write docker compose exec now we need the name of the service which in our case is backend backend sh we are inside now and now let's run a juggle command to create a new app so python manage that pi startup products so we created the app we can see here the products is created and we run the command inside the docker container now let's uh go to admin and we need to connect we need to add this products to the installed apps first we have to add here rest framework next we have to add here course headers and the products that we just created our course headers needs also a middleware so this is a middleware that we need to add and also it needs a new constant i will add it here in the end course origin allow all so we added everything we need now we need to connect with mysql here we have to change this sqlite to mysql the name of the database would be admin next we have to add the user which is root the password which is also root the host those is no in our case will be this service here so just db db and the port and in this case we won't be using this port but we will use the port inside this service so is 3306 so i 3306 so this is our connection with mysql we can remove again this sql light here and uh let's restart again the docker containers now we have to run migrations to create tables in mysql so let's go to the products and models so we will create two models here the first one is product this will extend from models model and we will add the fields for the product that we need title which is models a chair field with a max length of 200 let's do the same for the image and we need another field which is likes this will be a positive in the integer field and the default value will be zero so this is our product and we need another table now i'll call it user models model so we won't be really using the user table we will just use the user id so i'll just pass so with this this table will have only the id field and the product will have the id and these other three fields so now we have the models we need to generate migrations for these models and we have to migrate so open the terminal let's go inside the docker container again and here we have to write python manage that pi make migrations so we can see we generated migrations these are the migrations that we generated and to run them run python make manage that pi migrate so we run all the migrations if we open the database now and refresh we'll see a bunch of tables we won't be using all these tables the only two tables that we are interested is the products which we have title image and likes and the user which has only the id field so this is how we connect django with mysql and we run migrations so we created our models and now django when we return the objects in an api we need to use serializers so now i'll create a folder a file here sorry serializers and inside i will create a class product serializer this will extend from serializers so let's import it first from rest framework import serializers and this will extend from serializers dot model serializer so inside we'll add another class which is meta and we have to tell which is the model in our case is a product let's import the product here so i will remove this so we said that the product is a model and now we have to specify the fields and i will use all of them so this is our serializer is very simple we won't be using a serializer for the user since we will return a random id there now let's go to the views and now we will use the serializers so here we will create all the five methods for rest api crowd so there are multiple ways to do it in my case i will use the view set so from so i will remove the render from django so rest framework sorry import view set and what we'll do with this view set is we will create a class product view set this will extend from view sets view set so this will have a five methods that we want so i will add here list this will be the list of uh the products so i will list them one by one so this needs a request so i will add here create self request also so these are for slash products route for slash product slash so i will write it here this is r4 i will add a comment slash api slash products route i'll let pass here so it won't throw an error so this will have a get request this will have a post request now there are other endpoints that we will use which is def retrieve in itself request and the primary key which is known by default and this will be like this so i will added string id and i will pass it here so there are three methods for a single product one is retrieve the other one is update and the last one is delete so these are all the five methods now i'll remove the this part so to use this methods we have to add here a new file urls i'll copy the same code from this admin urls here i'll paste it here and here we will use products i'll remove the slash and what is this next parameter it will be product view set let's import it from views we have to edit here as a view but we still need extra parameters we have to tell that the get method will point to the list function so as we can see here we have a list and the get method will point to this list function the post method will point to the create function and we have to add another router right now for product slash the it needs a string which is a primary key and this get method now we will call the retrieve function we don't have a post we have a put here this will point to update and delete will point to destroy so i made a mistake this is destroyer so now all the methods are here now let's use them first let's add the list of the products so first let's get the products we have to get the product here objects all of them let's import this product from models so we got all the products now we need to use the serializer we just created so serializer is equal to product serializer let's also import it so imported product serializer here the first parameter is the products and we need another parameter here we have to tell that many is equal to true so we have this is a list of the products and it needs to return an array now that we got the serializer we need to return response with serializer that data let's import also the response here from rest framework response so this is the import so this is our list function let's see how it looks like so i open postman here you have to install it to test the apis here i will use http localhost port 8000 slash i forgot also one other thing so we added the routes here i also need to add them here first let's import from django url 0 we will import include and let's add the new path which will start with api we'll add a slash here and we will include here our project which is products so this project dot urls which is this file now that we included now we can use it here is api slash products and normally we don't have any product so it will return an empty array now let's add the next function which is create here we'll get the serializer which is equal to product serializer and we have to pass the data from the request so data is equal to request the data so we will use those data and we have to first call is valid so if we send valid data to this serializer if not we will erase an exception and if it's valid it means we will go to this line it means we'll save it after we save it we return the response so response serializer.data and we have to put a status here so we'll import from status let's import status so i don't remember the exact import here but we'll use status is equal to status dot http 201 created let's import this status so it's from rest framework we'll import status here now let's use it so we will change this from get to post and we will send some from json here we'll send some request we need the title title and an image which is image let's send the request and we return the title notice that we get also the likes here by default is zero we got also an id so our first product is created if we go to the get method now we'll see an array with a one product so this is the create function the retrieve is really simple we have to get the product which is equal product objects get the id is equal to this primary key now that we got the product we have to get the serializer is equal to product serializer with the product and we have to return in response serializer.data let's use it so this has id1 so if we put a get request with id 1 we return a single object products returns an array of objects now let's go to the update let's copy this part i'll put it to the update and also destroy because we will use the object there so we'll get the serializer here is equal to product serializer we have to pass the instance which is this product so the instance is a product with the data that it has and we have to update it with a new data which we will get it from the request the data so this is a project that the product that we have and these are the data that we want to update it now we have to do the same thing we have to ask if the serializer is valid then we have to save in the end we'll return a response with the serializer.data and we have to change the status which is 202 accepted so let's change product with id1 we'll send a boost reboot request here and this is new title and the new image send requests and we can see that these values are changed now also the status is 202 accepted last change is destroying the object this is really simple we have to call product delete and that's it so we have to return here response with the status status http 204 no content so let's delete this product send the request and we have 24 no content we don't have a product and if we go to the products uh not delete method so we have still an empty array now here now the last call that we need is the user's call so we'll create another class here user api view so i will not use a view set now i will use an api view api view here so let's import it from rest firm framework views we'll import api view and this will be really simple we need to define the get function and we need the parameter here which is a request which we won't use it i will put an underscore here we have to get the users users user sorry objects all so let's import also user from the models so we imported it here now we got the user we have to get a random user so here i will import random to get a random user is equal to random choice users and this will be a random user now let's return the id response id is user.id so this is a user so let's add it also to the urls the path will be user and we have to import it here user api view user api view here as view so let's test this route so this will be a get request to the user this returns an error because we don't have any users in the database so i will manually add here some values so i'll add here one two three four and five so i'll add five users or five numbers now let's send the request again and i get five if i send it again it's four so the result is randomized so this was our main app now we have to create another app so we can communicate it so that the other app will be a flask app now it's time to create the main app and i decided to make it with flask so i created a main folder and inside i created an empty main.pi file so let's start first i'll paste here the requirements that we need so we need to install flask flask sql alchemy sql alchemy flask migrate flash scripts flash course request mysql client and pica so there are a lot of requirements that we need and now we will go to the other project and i will copy the docker files here and paste them here so the docker file will be the same here except for the command which will be simpler just python main dot pi so this will be the docker file a docker compose file for mysql it will be the same except this will be a new port i'll put 7 here and i will change the database name to main there is no need to change the database name because this is another container but we changed it so the port the default port for flask will be 5000 and 8000 is occupied with the jungle up so i will use 8001 here and that's it so the docker files are completed now let's create a flask up here so from flask import flask let's create the app is equal to flask name here so let's start a basic app so here i will add new route up route so just slash i'll create a function index and here i will return just hello so let's see if this works so i need to add a condition if name is equal to main then up run with debug is equal to true we also need the host so the host will be 0.0.0.0 so that's it now let's try to run it without a docker container python 3 main.play so we got this port let's copy it and open a new tab in postman so we have an error so is hello not sure why throw the narrow now let's do the same but this time with docker so we have all the requirements we don't need to change anything so let's start docker compose up and let's wait till it's completed so it's finished we can see a db data folder here and uh let's test it now the port will not be 5000 because this will be inside the docker container the port will be 8001 so here i'll change it with localhost port 8001 and that's it so we can see hello now so docker is working now let's add mysql to this main.pi file so let's import sql alchemy so from flask sql alchemy import sql alchemy and we need to use it here so up config and we need to set a constant so is sql alchemy underscore database underscore uri so with this we will add the db connection and what we need is to add mysql here and here we need to add the user and the password so root root in our case at now we need the host the host will be the service here which is db so the host will be db and in the end will be the table which is main so with this we can connect to this database i will add also of course here since the front end will need it so let's import it from flask course i'll add it to the app and now the database is equal to sql alchemy and here we'll pass up now let's create two models that we need so class product this will extend from db model and let's add all the required properties for the product we need the id which is a db column db integer and also is a primary key now we have to make another change for the id here we will add here auto increment to false why did i add this field because the product will not be created in this app the product will be created in the jungle app and this app will just catch the event from rabbitmq and it will create the product and when we create the product we don't want the id to be auto increment because the id will be different than the the jungle app so if we want the same id we have to put it onto incremental false and to insert directly the id as it is from the django app so we'll see by example a little bit later now let's add the title db column db string and this will be a 200 character let's do the same for the image so this is a product notice that uh this product will be different than the product from the other app because we don't have likes here and the id is different so we can you we can think this as a different type of uh the same thing let's add also another class that we need each which is product user from db model so this will have an id which is a column db integer primary key to true so this will increment normally we need here the user id which is a db column db integer and the same for the product id we need also a unique constraint for user id product id and we need to set the name which is a user product unique so this unique constraint so let's import it from sql alchemy from here so this unique constraint will make sure that the combination of user id and product id should be unique we should not repeat it so we created the models that we will use now we need to migrate so to migrate i will create a new file here i'll call it manager and now here we need some imports so first from the main app we need to import up and db we need to import from flask migrate we need to import migrate and migrate command and from flask script we need to import manager now migrate will be equal to migrate with our app and our db here then we have to get to the manager so manager is equal to manager we need to pass the app inside and the manager will add the command db we'll add the migrate command here so we will have a db command to run our migrations so we will see it now that we will add the if name is equal to main so we need to add manager run and that's it so if we open the terminal now and open a new tab we'll run here docker compose exec backend sh and now we are inside the docker container now if we run python manager dot pi and we will run the command db so we added the command here with help we can see now that we have a command that we can run now let's migrate so to migrate we have to run python manager dot py db init so we created some migration files we can see them here now we need to migrate them so now around python manage dot pi db migrate so it should be python manager that pi db migrate so we created a new table if we open the database now we'll connect with the database so this will be 7 here the user is root password is also root and the database will be main so let's connect we'll see a database now with the emblemic version but we won't see our tables because we need to run another command for it which is python manage that manager sorry that pi db upgrade and now we run the migration if we refresh we'll see the table so this is a product table and this is a product user table so this is how we connect flask with mysql using docker now it's time to use rabbitmq to our python apps so i will use this service cloud ampq and you have to create a free account this is the free account i already have created so i can log in so this is my free account and what i will do here is this ampq url i will just copy it and now i can move to the app so i will go to the jungle app and uh in the products here i'll create a python file producer and for the moment i will just copy this url now let's send an event to rabbitmq so first we have to import pica this is a package that will help us send events and let's create a variable params is equal to pica url parameters and here we can put the url that we just pasted here as a string so we created the params this is annoying the connection now is equal to pica blocking connection and we will pass the params here so we created the connection with rabbitmq now we have to create the channel which is equal to connection channel so with this we created the channel now we can publish so to publish i will create a function publish inside i will put a method and a body so for a moment i will just keep it empty so we can see an example of the publish method so channel here basic publish we need to put an exchange i will put an empty string routing key this is a queue that we want to send the event so for the moment i will put it admin so i will publish it in the same queue as this one with the hit we need the body which is for the moment hello so that's it we can use this publish function now i will use it in the views when we list the products i'll just publish here so i imported the function and when we retrieve all the products we will publish hello now we created the producer now we need to create the consumer so here we need to create the consumer so the beginning is the same let's copy everything from the the producer paste it here and now we have to declare a queue so channel cue declare and the queue will be admin so now we need the callback so call back this accepts a channel as a parameter method properties and body let's pass for the moment after the callback we have to call channel basic consume here we have to pass the queue which is admin and we have to pass on message callback which is this callback that we just created so we are basically consuming now we can print started consuming since we want to have a message to see if we started consuming and the channel start consuming so with this in the end we'll close it so channel close so we basically have finished now let's uh print a message also to know if we received a message so print here re sieve in admin so we received a message and i will print the body here if we go to hello there so that's it now let's try to open the terminal go to the docker file so docker compose exec backend sh here we have to call consumer.pi so python consumer.pine so we received this messages because i already sent some test events now let's test it let's go to the route for the products and we can expect when we get the products here to send an event hello there send we can we can see now we received an event hello now let's consume to the flask app so what i will do is copy this consumer file go to the flask app and here i'll paste the consumer so everything is the same except the queue here will be main so we are done now i can so i can start it with pub python consumer dot pi so we started consuming and in the producer here i will change the routing key to main so now i will not publish here in the admin app but i will publish here in the main app so let's see if this makes any difference let's send the event we can see hello here was from before but this received the hello now so to see the difference hello main i will say hello main so let's send it again we don't see a hello main here but we will see it here so this is how we send events to different apps using pica and rabbitmq now we successfully connect us with rabbitmq and we started consuming uh with the both apps now we don't want to have all the time to tabs here to start the consumer so we'll change the docker compose file now first let's change the docker file we will cut this command here and we will add it directly here so when we build we'll execute the command that we just cut so this is basically the same as before we run the command here but now we are running it here we did that because we will create another container now so is q i will call it which will have the same docker file and the the difference now is we will start a command now and the command will be python consumer dot pi so we will run the command directly here instead of manually running it every time this also depends on the database because we will insert data later so let's do the same for the flask app so i'll paste the queue here so this file is the same so the difference now is i will cut this command here and i will put it here command python main api so now let's restart all the containers so i will run docker compose up build now we don't need the other tab let's do the same for this also let's remove this tab and we will build all the containers now we are building the queue so as we can see we are getting the q so the q is here so one other thing that we can make is by running it like this a docker compose up minus d for the database so d means we won't see the logs let's do the same for the backend or for the back end and the queue we need to see the logs so now we are seeing the logs from the queue and from the back end let's do the same here so minus d here db and docker compose up now let's see if this works so we are the products here let's send the request again we won't see it here but we should see it here also another change that we have to make if we close our containers and run them again we'll notice so if i do it with a database like this and the others double compose up you will notice that i will still get the cues but they they are not consumed yet so there is one last change that we have to add in our consumer and here we have to add auto ack true so with this we will consume the calls and we will not get them again so let's do the same for the other consumer and let's restart the containers again with build also this one will build so they are rebuilt now if we do the same with the database and we start the other apps we will see that the queue started consuming but we cannot see anything here so that's it now with uh these changes consuming becomes easier now we want to send events every time a product is created updated or deleted so we have to change this publish method we will add here a method and a body so for the method we have to create variable properties which is equal to pica basic properties and here we will pass a method and here we'll pass the properties is equal to properties also for the body so we need to import json here and the body will be json dumps body so we will send objects or anything but we have to convert it to json before we send it so this is our publish function now let's use it to our views let's remove this publish here and now when we create we will publish product created and we will send the serial laser the data let's do the same for product updated product updated and for the product deleted now instead of the object we'll send directly the primary key so these are the main events that we want to send and now let's make changes to the flask app here we have to get the data which is equal to json so i will import json here json loads body so in the django app we will convert it to json so now we will con convert it back let's print it so we can see what data are we sending and now we'll make the condition if properties content type is equal to product created will create the project so the product sorry so the product is equal to product with an id data id here title so let's import also this product here is equal to data title and image is equal to data image in the end let's import also the db db session add product ndb session commit so this is how you create a an object with sql alchemy now let's do the same for the other conditions so properties content type product updated so now we will get the product is equal to product query get data with an id and we have to change this product so product title is equal to data with the title and the image so image here in the end we will call session commit the last change is deleting so properties content type product deleted and in this case we'll get the product like this but we don't send an object we send directly the id so this data is the id we have to do it like this now db session delete product and tb session commit so these are all the three cases that we will receive from the other app now let's see if they work but before we should restart our containers just to be sure so build so there is no need to restart this one but just let's do it to be sure so this is started and now we have the products here which we don't have any let's create a product here i will send some data title is a title here and the image an image let's send the request so we successfully created pro the product in the django app but let's see if we created it in the uh flask app so we received the queue we probably forgot we should add here some print statements like product created product updated and product deleted but doesn't matter let's see the database and we can see this is a product now so we successfully created the product from an event from rabbitmq now let's try to update it so this product will put send a put request with a new title and a new image so i will not save it let's send the request this is updated and if we see the event we got the new title and a new image we don't see the print that we just added because we have to rebuild the containers now we're just checking the database which is correct and now let's try to delete it and this is received and if we refresh here we can see we have no product so now the databases for the product are in sync from the jungle app and for the flask up so we completed the jungle app now let's finish the flask up since we have only one route here so let's change this route to just api slash products and here we'll return a list of products so let's import jsonify from flask here and we will return jsonify product query all so let's see if this works so let's see if this works so the endpoint is api slash products and we got one product let's create one product here so we can see it if it works so we got this product that we just created so we should see it in the database notice that the id is three so when we created this product we don't start with one but the idea that we have it on our django app now let's send the request and we get an error because object of type product is not json serializable to fix this error we have to add here it data class and let's import it from data classes so with this now the class will be json serializable let's do the same for the product user send the request again and we got an md object but we want to see the data which we got id title and image here to do it we have to declare it here id should be an int title should be a string str so and image should be a string with these changes now we can see the id image and the title so with this we completed the main route now let's add another route so i'll call it like and this will have up route api products we need the idea of the product which is an integer the id and we have to like it so this is the end point the method is a post request and when we like we will send an id here so how do we like the product so now it's a little bit complicated we have to internally call the django up so we have to internally call this user api view here to get a random id and we have to assign it to the product user so first we have to create a variable i will call it rec and this will call requests dot get let's import requests from so we import directly requests here and now we have to get the endpoint so the endpoint is http localhost port 8000 slash api slash user and for the moment we will just return json if i request json not sure if i need jsonify here but let's try it so products with an id1 we need to like it let's send a post request send and we get an error connection refused so what is the error here there is localhost here because right now we are inside the docker container and the localhost inside the docker container is 0.0.0 how to connect with another docker container localhost we have to specify here that this is docker for mac localhost so this is the way the docker knows that we are referring not the container localhost but another localhost so our local localhost so with this change let's try to send it again it seems we the server stops so we probably need to restart it send it again and now we got id2 so this is id from the user so this will be user here so not post get so this endpoint 8001 will call this other endpoint now that we got the response let's use it and create a product user so here we will get a json is request.json in the end if it is successful we will return a message success and we will make a try accept here so what we will try is we will create a product user which is equal to product user with user id is equal to json id and the product id is equal to the id that we just set this one from the url and now that we set this product user we have to add it db session add product user and we have to commit and here we'll send an event which i will send it later and if an error happens there is when the user tries to like again because this is an unique constraint if that happens we will abort let's import a board from flask board we'll put 400 here and you already liked this product so a board we imported from from flask here so let's try it let's send the request again send success if we see the database product user we created one and it will happen that we will fail it seems that our unique constraint didn't work so i probably made a mistake here but i won't focus on that let's uh finish this up by sending an event now we need to get the producer i'll copy the same producer here so everything now is the same and we have to use it here now if this is completed we have to add here producer so publish let's import it product liked and we have to pass the id of the product so let's we need to import it here so this is our flask up only one thing that i think is easy fixable now let's make the last change here on the consumer we will get the data here which is equal so let's import json json loads body let's print the data and we here will like the product so we'll get a product first which is equal to product let's import it so from products models we'll import product that objects get id is equal to data so i will directly make this an id so we got the id now product likes will equal to product likes plus one so we will increment it by one in the end we'll save it and we will print that product is product likes increased just to be sure let's rebuild the containers and we will rebuild this too so this is completed now we have the products here so we have two products and they have zero likes now for the product with an id2 let's see if we have that product in the main so three i guess so for the product with id3 i'll post here to like it and this should increase the likes so i guess we have an error received in main so my bed when i made the producer i should change here the routing key should be admin so let's rebuild and this should receive the event now let's like again not here here so this should not receive the event it didn't this did receive the event actually we got an error here so requested setting installed ups but settings are not configured this error happens because this file is outside of django and we are using the product here and to use a product regularly we have to load so we have to set up jungle before getting the product so we have to import here os and django we have to set uh an environment variable django sent is sending settings module is equal to admin settings so this settings here and we have to add django setup here with this we won't have that error so let's rebuild the containers we can see now that we started consuming so let's try it again now success let's send it again and we see the likes are increased here so we received the event so now we are communicating back and forth with both apps so this was the app that i wanted to show now it's time to create the react frontend i'll create a react project with typescript so to create it write mpx create react app i will call it react crud and the template will be typescript let's wait till it's completed now the project is created we can go to the folder and run npm start now the project is running and if you open the browser we can see on localhost port 3000 we have our app running now let's open the project with our ide and this is the project that we just created all the files are in typescript so i will remove the app.test.tsx file we won't be using uh tests here in this tutorial and now let's add the template for this project so we don't use the default react template go to getbootstrap.com examples and i will go to the dashboard here and get this template so let's view the page source and i will copy the html from the body till the end so and i will paste it here so my id is smart so all class now are have been converted to class name if your id doesn't do that you make sure to do it yourself so i will remove all these tr's here because there are a lot and i will keep only one so i will keep only this we don't need the canvas we don't need the buttons so let's make some changes so we can remove this ul nh6 so this can be removed also so we can keep the dashboard and let's remove this pan so let's make everything much simpler so we remove the ally here so we have an error here also which is the error so there is this input which we need to add a slash here and everything should be correct now let's remove this logo here and it will look ugly so if we see our app it looks very ugly because we need to add also the styles so here we have the dashboard.css which we have to copy it and add it to our app css paste it here and now it will look a little bit better but we also need to add bootstrap so go to bootstrapcdn.com and here we need to copy the html link and add it to our index.html now that we added this link it will look much better so this is a template we will be using so let's make further changes so i'll create two components now this is the navigation so i will create a folder components inside i will create a new component i'll create it now and will be typescript.jsx file inside i will create a stateless react component and i will use this shortcut in my ide so we need to import react from react we need to create our component as a constant and this is a function which we need to export in the end here is html so the html let's cut this part here and paste it in our nav so let's replace it now that we replace the html we can use the component directly here so let's call it nav my id auto imports components so you should import now from components nav here and use it directly if we see the browser nothing will change let's create another component now which is the menu which is this one so let's do the same menu create the component and let's cut html actually the name here will not be dashboard will be products and let's use the menu in our app.esx so that's it now everything looks much more simpler and our component looks much better now we need to create more components for our app so we will have two main apps so one is the admin and the second one is the main app so first we will focus with the admin which is what we have been doing till now and then we will create the main app so inside the admin app we need to create the products component so let's create another component products let's let it be a jsx typescript file and this component for html will have the html for this table basically so let's cut it and let's paste it here so note that react doesn't allow to have two html elements nearby each other they all need to be wrapped inside a bigger one so this makes sense either that or i will just remove the section title so i will keep it much more cleaner this way now let's add these products here so one way is to add directly the product here but we don't want to do this because we will create more components which they will change here nav and menu will stay the same but this will change so uh to fix this we have to install another package we see which is react router dom so open the terminal and write npm install react router dom and types react router dom we need this second package because the first one is javascript package and the second one is the typescript package so for all the typescript apps you need the to do it this way now reactor router dom is installed now we have to use it here so to map the products via the router we have to import two packages so the first one is browser router and the second one is route not router route so let's replace this products here and inside we will add browser router this is a container for all our routes and let's add our first route which is for the products so we have to specify a path the path for products will be admin slash products and the second parameter we need to add the component which in our case is the products so that's it so this is a path we can reference the products now so right now nothing is happening because we are at the main app so if we go to admin slash products we can see we can see the table now so this is working now let's add the main template so let's go again to get bootstrap.com to the examples and this will be the template for our main app so let's copy the code from the body so from here till here and we have to create a new component for main main here let's create a component and here we'll paste the html we just cut so let's remove most of the call md4 here because we don't need all of them so we keep only one we don't need neither the jump drone here and neither the header so we can remove the header and this is almost what it will look like so we will make changes later but for now i will remove also the svg here so for now let's create a route for this so the route for the main app will be route the path will be the main path so slash and the component will be the main component don't forget to import it so if we go to the main component now it will look so first this is what the product component looks like which is weird and also if we go to the main page we can see this is what the main component looks like but we don't want the navigation in the menu here so what is that we are making a mistake so first we need to remove the nav and menu from this route so the only way to do it is by creating a new wrapper component for the admin so let's do it let's create here a typescript file called wrapper so inside i will create a component and the html for that component will be this nav and the menu so i will cut this part go to the wrapper and paste it here so inside the div let's also cut what i left here and paste it so this is now the wrapper component so why do we need this component so we have to use it directly in our products so we can wrap this with the wrapper so wrapper and now in this component we will use the menu and nav so we are having an error here because we are not using it correctly inside here we have to use the child properties that we have so we have to add here props uh we are having an error also here because we are using typescript we have to specify a type which is props with children any so these are the props that we have and to pass the child properties we have to use props children this way we will pass the html inside here to the rubber and if we go to the this is the main app now which looks much better and if you if you go to the admin slash products still doesn't look good still we see this main card so what is the issue here the issue is this slash the problem with this slash is that they both have slash and react confuses them and to solve that we have to use exact here this means that the path is exact here and don't confuse it with the other paths with this products will look the same as before and the main app will look different so this is how we use route so let's remove nav and menu we don't need it here actually these components which are nav and menu we have to move it to our admin because they belong there don't forget also to change the imports here which my id does it automatically so now we got the admin the main app which we will use it later and now let's focus on our products component now let's fill the table for the products to fill the table first we have to get all the products and to do it we have to use use effect and inside accepts a function as a parameter and the second parameter will be an empty array this empty array means that this will be called only once if we put a variable that changes use effect will be called every time the variable changes we'll see this later on now inside here we need to call our backend to get our data so we cannot make this use effect asynchronous here it doesn't accept it so the way to do it is to create a function get products and this will be an asynchronous function and in the end we will call it so get products this is a way to call asynchronous functions in react but there is an even easier way so we can remove get products totally so let's open a parenthesis here and close the parenthesis when we call it so this is my preferred way of calling asynchronous functions in react so open parenthesis close parenthesis and then you call it directly here inside now let's call our backend let's get a response is equal to await fetch the endpoint would be http localhost port 8000 slash api slash products once we get the response we have to get the data which is equal to a weight response json so we got all the data so first let's console.log it and inspect here we will see that we get the products here and the console log works so we got all the products now we have to get them and loop them to do it we have to use another react hook command which is use state so use state accepts a default first parameter so a default value which is an empty uh array for the products and the returns products as a variable and set products as a function so these work together with each other once we set the products these products get set so set products will be used here data now we set the products it means this variable has changed so we have to use that variable here let's use it so we have to map it so products map it will return a product that returns this html so the we need to add a key here so for every loop that we have we have to have a key now we are having a type error here because we have to cast the product here so we have to create a folder here interfaces and inside will create a product interface so product not products but product here we'll export an interface product and this interface will have an id as a number a title as a string an image as a string and it will have likes as a number so this is a product that we have let's go back and now we have to cast this product as product don't forget also to import it here so we have the key now now let's call every other variable so this is id i also forgot here to put the headers so the first one is the image this is a title this is a likes and this is the action so the second one is the image so we have to put an image here with the source to be product that image and the height will be 180. this is a product title and this is a product likes for the moment i will keep actions to an empty td now let's see it on the browser so we retrieved products with images so for some reason the image doesn't show so this site lorem pixel doesn't work uh currently for me but if it works it will show images here so this is how we retrieve products and we loop them to show them as a table now let's delete a product in the actions here we need to add some more html so i will add this html which is just a button delete so we want to delete a product so first let's create a delete function i will call it d deal not delete because it's a keyword so this function will accept an id as a number and we have to call it here so to do it we have to add the nonclick listener and we have to call the delete function with the product id so this is how we call the delete function for a different product now that we have the delete product we have to make it asynchronous and we have to call our backend to remove the product so to do it we have to make a weight method fetch so i will copy this part here so in this case now we need to pass the id so i will convert the quotes here to this kind of quotes i don't know the name of these quotes but with these quotes you can add variables to the string which is the id in this case this is not a get request this is a get request but we want to make a delete request here so we have to pass some parameters so the method will be delete so with this function call we will delete a product in the back end but we need also to remove it from the front end so we have to call set products again so set products and we have to get all the products except the product that have this id so we have to get all the products and we have to filter them and the filter will have the product as a product id so product is a product here and we will filter all the products that have the id different than this id we can keep it one liner here so this means that we are getting all the products except this product id and we are setting it so the table refreshes itself one last change that we need here is to add a confirmation since we don't want to delete the products directly so we add a new condition here window dot confirm are you sure you want to delete this product and we close all what we did inside this if statement so once we click delete the browser will ask this question if we type yes then the product will will be deleted let's see it on the browser so i will delete product number four when i click i will get a question are you sure you want to delete this product i type ok then we can see product with id4 is removed if i refresh it's also removed in the backend so this is how we delete products now let's create some products first let's create a new rear component products create and this will be a normal react component and now that we created it we have to add it to our router so the route for this component will be admin products slash create and this will be products create let's make every component exact so we don't have any problems this also now let's go to our products we will add here this html it's just a link and we will have to change this anchor link to a link from react router dom so i automatically imported it but you have to do it on your own so import link from react router dom and this link will redirect to admin products create let's add a slash in front and we don't need this curly braces so this is the link that we want so if we see the browser we can see an add button here that when we click we go to the products create page which is empty right now so in the products create let's convert this div to just wrapper and now it looks better inside here i will create this simple form that accepts only a title and an image and a button to save it so it will look like this now let's make this form work first we have to create variables from the state for the title and the image so we'll create the title set title from use state and the default value will be empty let's do the same for the image so this is image and this is set image now that we got the variables we can set it directly here so when we change this input we have to set the title so we had an unchanged listener here and the event will call set title and the value will be event that target that value this means every time this input changes so when we type here we'll set the title so let's do it the same for the image so on change event we'll call set image event.target.value now in this title an image we got the values that the user set so we are ready to use them in when the form is submitted so let's add an onsubmit call here let's create also the function submit and for the moment just console.log the title and the image and on the submit here we will call the submit function so let's test it on the browser let's inspect and let's put a title here and an image save i saw console log but immediately the page refreshed so that is a problem so we have to prevent that and to do it we have to call here to to add an event parameter here and to call event. prevent default typescript wants us to type the event here so synthetic event let me type it synthetic event so that will prevent the page refresh so if we try it again we can see that we consult log test and test now we are ready to call backend to create our product so let's make this function asynchronous and here we'll call weight fetch http localhost port 8000 slash api slash products and we have to add some options the first one is a method which is a post method the second one is the headers so this is a http request so we want to work with json so we have to add content type application slash json and we need also to send the data which are these two variables that we have here so we have to send them in the body and we have to stringify them so json stringify because it accepts a string we want to send an object so we need to add the title here and the image note that this title here is the same as title title here but to keep it short and simple we can use it like this now we can create products with this request we need one more change because we want to redirect to the products once we submit the form so let's create another state here i will call it redirect and set redirect use state and the default value will be false here i will add the condition if redirect we want to return redirect so let's import it so importer direct from react router dom we want to redirect to admin slash products and once we create a product we want to set redirect to true so this means if this is successful we redirect to the main table let's try it out let's create a product title image save so if we redirect it means it works so we can see it did work so let's create another one with a correct image and let's put a title here bird so we can see this is working correctly and the redirect works correctly now we want to edit products to edit products is almost the same as creating products so i will copy the products create component and paste it and change the name to products edit let's rename also this variable products edit and rename this also products edit so now that we created products edit let's add it also to our routes let's duplicate this and the route now is different so we need to go to admin slash product slash id slash edit we need the id of the product that we want to edit and the component is products edit now we need to get the product from this id that we are fetching but first let's go to our products and here we need to add another link let's copy the link for the delete and name it edit we don't need a nonclick listener here but we have to rename this to a link and we have to redirect to the path that we want to redirect is admin slash products slash the id so product dot id here slash edit and don't forget to end it with the link here so this button will appear on the table now so along with the delete button now we have an edit button let's click the edit button and right now nothing happens so i made a mistake a spelling mistake here so it's products here let's go back and type edit again let's refresh just in case so this is the product edit form now we have product with id number two we have to set the titles and the image for the product with id number two so to do it let's go to products edit now we have to call use effect and inside here we need to call our backend for that product so like we did before i will open two braces here and make a sync function so this is my way of calling uh an sync function inside use effect inside here we need to call the backend so response is equal to weight fetch let me copy this part here so i will use this braces now we need the id of the product so we have to get a product with the id that we got from the url to get it we have to add the props here and this time is props with reference and based on the props now the id is props match params dot id the id here corresponds to this id here so the the actual name and to get the query params we have to use props match params now we get the response let's get also the product which is equal to a weight response.json once we got the product we have to set the title and the image based on this product so set title to product dot title set image product dot image we can cast this product as a product here since it is a product so let's see how this looks on the browser now and this is not working because we forgot to add something else we set the values but this doesn't mean that the inputs will reflect that value so we have to add here a default value for the title same for the other input so default value will be image here now once this change the input will change also now we can see the data are prefilled based on the product so if i change this from number two to number one we can see we have different values the last change we need is to change this fetch now this now is a different url we'll call api product slash props match params that id and the method is put all of the other things are the same now let's test it on the browser so i will change the image to this image and i will say updated title for the product with id 1 let's save it now i'm redirected and we can see a new image and an updated title so this is how we update products now let's complete the main app so this should be a list of products so let's create products from the state so products set products equals to use state and the products will be an empty array in the beginning now we have to get all the products so we have to use use effect an empty array a function sorry and this will be an empty array inside here we'll call our backend so this will be an async function will get response from fetch http localhost port 8001 now so before it was 8 000 now it's 8001 api slash products once we get the response we have to get the data which is equal to weight response dot json i forgot a weight here and in the end we have to set the products to this data that we got now we set the products we have to loop them here so this is the html that we want to loop so products map we have to get every product and return this html so this needs a key product.id this needs the product to be cast to product so let's make the other changes now first we need an image here so let's write an image stack with the source to be product that image height will be 180. this is the product title here here we need to only one button which is like and this is a number of likes so it's not minutes this should be likes likes so that's it let's see how it looks like let's go to the main app and this is what it looks like so we have only two images that work because the other that don't work but this is the main idea now let's make this like function work so let's add a new click here on click and this will call the function like so this will be like this like with the product id let's make the like function this will have an id as a number so this works fine now let's complete the like function let's make this asynchronous here and this will call our backend here we need to wait fetch the url is almost the same here let's change it to these brackets and the endpoint is api slash product slash the id that we got as a parameter slash like and this will be a post request we need also to send some data but in this case we don't need any data so we need only to send the headers which is content type application slash json usually the post requests have some data but in this case we don't have any now that we like a product we also need to update this html so we need to set the products again so to set the products we need to loop and change all the current products so set products products map and for every product we have to make a condition now if this product that id is equal to this id that we got as a parameter here then product that legs will increase in the end return the product so this means that only this product with this id will increase the likes now we are having an error like argument of type product is not assignable of parameter of type set state action never this means that when we initialize the products here this is never this typescript interprets this is never like this so to fix this problem we have to manually cast this empty array as product array so this is an empty array but as a product array and immediately we see that we don't have an error anymore so this is how we fix typescript errors by casting the products directly let's open the browser now and if we like a product we can see the number of likes increases and that's it is very is very simple so this was our app that we wanted to build and i hope you like it don't forget to subscribe to the channel for more content thank you
