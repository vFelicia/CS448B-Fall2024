With timestamps:

00:00 - welcome to this comprehensive video
00:01 - course on py test the powerful testing
00:04 - framework for python throughout this
00:06 - course you'll gain a deep understanding
00:08 - of piie tests features best practices
00:11 - and the nuances of writing effective
00:13 - tests and at the end you'll learn how to
00:15 - use chat GPT to help you write tests
00:18 - quicker Farhan Ali created this course
00:21 - he is a freelance web developer who
00:23 - specializes in both design and full
00:26 - stack web
00:28 - development
00:30 - what is going on you guys and welcome to
00:32 - this video brought to you both by
00:34 - rhythmic and free code camp now in this
00:37 - video we're going to be covering testing
00:39 - in Python and this is aimed mainly at
00:41 - beginners to introduce you to this world
00:43 - but also for professionals as well who
00:45 - are also curious in using pest in their
00:48 - day-to-day lives so first of all what is
00:51 - py test now py test is of course a
00:54 - testing framework it's in the name and
00:56 - also in the title of this video but what
00:59 - comes out of the box well first of all
01:01 - one of the great features of pie test is
01:03 - this thing called autodiscovery of tests
01:06 - now what does that mean well
01:08 - autodiscovery of tests all that means is
01:10 - that P test has the ability to pick up
01:14 - tests based on the way we name them so
01:16 - for example we can name a test test
01:19 - underscore and then the name of the file
01:22 - or we can have it as the name of the
01:24 - file and then underscore test and it
01:26 - will know that in this file there will
01:28 - be tests and usually IDE so for example
01:31 - if you're using py charm we'll also be
01:33 - able to detect this and you'll be able
01:34 - to just click play and run your test the
01:37 - other naming convention is also when we
01:39 - have test underscore and then the name
01:42 - of the function that that will then
01:44 - imply to the tpy tests that this is a
01:47 - test and you can also run those
01:49 - individually now another great thing
01:51 - around autodiscovery of tests is that
01:53 - there's no explicit registration needed
01:56 - so unlike some other Frameworks where
01:57 - you might need to build a list or a
01:59 - registry of tests manually P test
02:02 - automatically identifies which functions
02:04 - and methods are tests based on their
02:06 - names and it also simplifies test
02:09 - execution with autodiscovery you don't
02:11 - need to specify each test case to run
02:14 - manually you just run P test command and
02:17 - it will discover all the tests and
02:19 - you'll see that later on the next thing
02:22 - that comes with P test is Rich assertion
02:25 - introspection which sounds like a very
02:27 - fancy term but all that means is that
02:31 - with Rich assertion introspection that
02:34 - when a test fails in P test we get a
02:36 - really nice breakdown as to why that
02:39 - test failed so we get really nice clean
02:41 - reports that make it very easy for us
02:43 - the coder or the developer to understand
02:45 - so we know exactly where our test went
02:48 - wrong or not even just tests but what
02:49 - we're testing went
02:51 - wrong and another great thing that comes
02:54 - with P test is this support for
02:56 - parameterized and fixture based testing
02:59 - now what that allows us to do is it
03:02 - basically means that we can easily run a
03:06 - test function multiple times with
03:08 - different arguments ensuring that a
03:10 - broad test coverage with minimal code is
03:13 - that so we could test that a certain
03:17 - number will show up depending on the
03:20 - value and we can give it like a list of
03:22 - numbers and it will just run it for each
03:24 - one so we don't have to write each test
03:26 - manually which saves a lot of space and
03:29 - also provid us with a it makes it very
03:32 - readable for the uh
03:34 - developer now we've explained what pie
03:36 - test is the next is why do we need py
03:39 - test well first of all one of the great
03:41 - things with py test or the reason why
03:43 - you should be using p test is that it
03:45 - has a very simplified syntax pest allows
03:49 - you to write code or write test cases
03:51 - using plain assert statements which is
03:53 - the assert statement that comes with
03:55 - python without needing special assertion
03:58 - methods like assert equal or assert true
04:01 - which you may find in other uh python
04:03 - test testing libraries such as unit test
04:06 - or nose another one is of course Rich
04:09 - assertion introspection as mentioned
04:11 - earlier providing us with clear reports
04:13 - when our tests go wrong it also has a
04:15 - very powerful fixture system and what
04:18 - that means is pest fixture system is
04:22 - both flexible and Powerful allowing for
04:25 - setup and tear down operations so we can
04:27 - easily include operations to run before
04:30 - a test starts and also write in tear
04:33 - down code so when a test is finished we
04:35 - can clean it up we also have these scope
04:38 - or these fixtures can also have scope
04:40 - and auto use settings meaning we don't
04:43 - have to keep let's say we're testing an
04:44 - object we don't have to keep creating
04:46 - that object each time we can have a
04:48 - place where the object is created and we
04:50 - can use it for all of our tests this
04:52 - still might sound a bit confusing but
04:54 - we'll see it in the code and you'll get
04:55 - a better understanding of how powerful
04:57 - this fixture system actually is
05:00 - another great feature of py test or why
05:02 - you should use it is
05:04 - compatibility as py test can run tests
05:07 - for unit test or nose so other python
05:10 - testing libraries so you can kind of
05:12 - easily migrate over to py test if you're
05:14 - using another one and so it doesn't
05:17 - really get in the way if you want to try
05:18 - out a different testing Library P test
05:21 - will still work and that's why I want to
05:23 - focus on P test for beginners as once
05:25 - you understand the concepts of P test
05:28 - you can easily translate them over to
05:30 - different projects where you use
05:31 - different testing libraries and finally
05:33 - another reason why you should use py
05:35 - test is the extensibility now pest has a
05:38 - very rich plug-in architecture with many
05:40 - third third party plugins available so
05:43 - for example if you have ajango
05:45 - application and you want to start
05:46 - testing it there is of course a pie test
05:49 - Django plugin that you can use there as
05:51 - well which is tailored towards Django
05:53 - and you can just plug that in and get
05:55 - rolling with it but otherwise that's the
05:57 - reasons why you should be using py test
06:00 - it's enough talk for me I mean it's one
06:02 - thing talking about the theory but now
06:04 - we need to see it in
06:06 - action so I've gone ahead and opened up
06:09 - a new project a new python project I am
06:12 - using virtual environment in this
06:14 - example however you don't necessarily
06:15 - need to as we're not building out a
06:17 - fully fledged project we're just using
06:20 - pie test the library P test so whether
06:23 - or not you want to use it it's a matter
06:24 - of preference at this point but I've
06:26 - opened up in py charm you can also use
06:28 - vs code however I do recommend py charm
06:30 - for testing especially testing and you
06:33 - can also use the community version I am
06:35 - here as well and that's because the the
06:38 - way tests are integrated into py charm
06:41 - it's very easy to get up and running
06:43 - with it however we're also going to use
06:45 - a command line for this as well so
06:47 - regardless if you're using VSS code to
06:48 - notepad it doesn't matter it still work
06:51 - so first of all we have our empty
06:54 - project we need to go ahead and make the
06:56 - necessary installations so the first one
06:59 - I'm going to to make and the only one
07:00 - I'm going to make is PIP install and
07:02 - then pie test hit enter and in this one
07:06 - we're using the version
07:09 - 742 which I think which I guess is the
07:11 - latest version right now it doesn't
07:14 - matter I guess if you're using a I guess
07:16 - modern version of it it shouldn't really
07:18 - matter because the principles of py test
07:20 - and the way you use P test doesn't
07:22 - necessarily change so we have this
07:25 - version pest
07:27 - 742 now we need something to actually
07:29 - test because we don't have we don't have
07:31 - any code so there's no point testing so
07:33 - let's go ahead and create some functions
07:37 - we create a new python package I'm just
07:38 - going to call this
07:40 - source and within that I'm going to
07:42 - create a new file and I'm going to call
07:44 - this my functions and we're not going to
07:47 - add anything special here first we're
07:49 - just going to demonstrate how to write
07:52 - test how to write the most basic P test
07:54 - you can so first of all in my test we're
07:58 - going to have
08:00 - a function and all that does is add two
08:03 - numbers so this may be a throwback for a
08:05 - few of you folks as I guess this is
08:08 - tends to be the example a lot of books
08:10 - or people tend to use so return number
08:13 - one plus number
08:17 - two all right and let's just do one more
08:20 - we'll say
08:22 - divide say number one and number
08:27 - two and return number one divided by
08:31 - number two so pretty standard stuff but
08:34 - in this case the reason why we have that
08:36 - here is because we want to test it now
08:38 - the reason why I'm getting these lines
08:40 - is because I need to reformat so you'll
08:42 - see me do that from time to time in the
08:44 - tutorial that's just to stop the IDE
08:47 - from
08:47 - complaining all right so we have our
08:49 - source next let's create a new directory
08:52 - inside of our main project so the root
08:55 - of it and we'll call this tests like so
08:59 - now if you remember from what I was
09:01 - saying earlier in the presentation that
09:04 - what pest does is it has a great ability
09:06 - to pick up or figure out where our tests
09:09 - are going to be located so because we're
09:11 - calling this test you'll have an idea
09:13 - that tests are actually in here and
09:15 - within that and also it's good for us
09:17 - because we also know that teser in here
09:18 - because it's labeled and named correctly
09:21 - let's go ahead and create a new file and
09:22 - we'll say testore
09:25 - mycore
09:28 - functions all right so what are we going
09:30 - to do here so we're going to test our
09:32 - functions add and divide so let's get
09:35 - started we'll say import and then py
09:40 - test and we'll say import
09:45 - Source my
09:47 - functions as mycore
09:50 - functions all right so let's test our
09:53 - first one we'll say testore
09:57 - add and if you see here on pie charm you
10:00 - may also get this you probably will
10:02 - actually this play button right next to
10:05 - it that's because it's detected that
10:07 - this here is a test so py charm already
10:10 - has this great integration of tests so
10:13 - you don't really have to use a terminal
10:15 - but you can pretty much click this
10:17 - button and then the test should run but
10:19 - we're going to use a terminal in this
10:20 - example so we'll say clear and we can
10:23 - actually run this now and you may have
10:25 - already guessed it that this test should
10:28 - pass so we'll say
10:29 - P test and then tests and then test my
10:34 - functions and there we go we have one
10:37 - passed and at 100% because we only have
10:40 - a one test function and that test
10:42 - function is actually not testing
10:43 - anything but this passes because there's
10:45 - no complaints coming from a failed
10:48 - assertion so let's go ahead and actually
10:50 - write something in there so we'll say
10:51 - result equals my functions add and we'll
10:55 - say one and
10:57 - four so now we have a result so we know
11:00 - from our own intuition that this is
11:02 - going to be five so we'll go ahead and
11:05 - say assert results
11:08 - equals
11:10 - five so if this assertion fails then
11:14 - this is going to this is going to break
11:16 - and our test will fail however if it
11:18 - passes then we get a pass let's go ahead
11:21 - and test that so Pi test and then
11:26 - test my or test my function
11:30 - and enter and there we go we have 100%
11:33 - pass no complaints but what if we were
11:36 - to change this value and say six let's
11:39 - run it again enter and there we go we
11:42 - get a fail so it's telling us that our
11:45 - test ad failed and down here it's saying
11:49 - that where it fails so what line exactly
11:52 - and it's saying that assert result
11:54 - equals 6 is failing because result is
11:57 - actually five and we're saying that we
11:59 - want it to be six so yeah it's telling
12:02 - us what value that should be we'll set
12:04 - that to five so if you're working on a
12:06 - real life application you may be
12:08 - expecting a certain value but you're not
12:10 - getting that value back at least then
12:12 - you will know okay maybe something's
12:13 - wrong so you may go back either to fix
12:15 - your tests or to fix the application
12:17 - itself so there we go with our test ad
12:21 - but let's just quickly go over what this
12:24 - assert statement actually is so in
12:26 - Python the assert statement is a
12:29 - debugging Aid that tests a condition as
12:31 - an aid to debugging if the condition is
12:34 - true the program continues executing as
12:37 - if nothing happened so in our case it
12:39 - continues and there's nothing to
12:41 - continue to continue so there's a pass
12:43 - however if the condition is false and
12:45 - assertion error exception is raised
12:48 - which interrupts the normal flow of the
12:50 - program so if we go back
12:53 - here and we look at our error that we
12:56 - got we get here that it's an assertion
12:59 - error so every time an assert an
13:02 - assertion fails we get this assertion
13:04 - error that's why we're getting that
13:06 - value but that quickly addresses how
13:08 - assert works so you can see here that if
13:11 - this is not basically rendering to be
13:14 - true then it's going to break now let's
13:17 - go ahead and write our divide test
13:20 - function so here we'll
13:23 - say what should we call it let's just
13:25 - say divide so test divide and it's
13:28 - always good to make sure that you're
13:29 - naming your tests properly so divide in
13:33 - this case it's very basic we're just
13:35 - testing that divide works so result
13:37 - equals my functions do divide and we'll
13:41 - say 10 by 5 and for you Geniuses out
13:46 - there you should know that 10 ID 5 is 2
13:49 - so we'll say results equals
13:54 - two let's go ahead and run that so here
13:58 - just clear this and then Pi
14:02 - test tests and then test my functions
14:06 - enter and now we have two little dots
14:08 - here at 100% rate awesome so that covers
14:13 - our very basic P test examples where
14:17 - we're just throwing a simple Asser to
14:19 - make sure the value that we get back
14:20 - from functions are the values that we
14:23 - expect but what if we were to test this
14:26 - by saying number one divided by zero
14:30 - because we know you can't divide a
14:31 - number by zero so what would happen
14:33 - there well let's go and try it out and
14:36 - actually let's go ahead and try it out
14:38 - on a different function so we'll say
14:42 - test
14:46 - divide and divide SP properly divide by
14:52 - zero all right so here say result equals
14:57 - my functions do divide and then we'll
15:01 - say 10 and
15:04 - zero and then we'll say
15:07 - assert and let's right now just say
15:10 - assert true so if we say assert true
15:13 - then this will pass but let's see what
15:15 - we get when we test a test divide by
15:18 - zero so let's just
15:21 - go into just expand
15:26 - this and we'll say p test
15:30 - and tests test my functions and we get a
15:35 - fail even though we have this assert
15:37 - true so why is that the case so here in
15:39 - our
15:40 - divide our divide by zero um test here
15:45 - so it fails here on this my functions.
15:48 - divide and that's because if we scroll
15:50 - down a little bit we get this Zer
15:52 - division error so division by zero is
15:56 - the cause of this zero division error so
15:59 - what if we want to test that type what
16:01 - if we want to say okay if I divide a
16:03 - number by zero I'm expecting this zero
16:05 - division error so we can actually do
16:07 - that in P test and it's very simple what
16:10 - we can do is say something like the
16:13 - following so above this as we know it
16:17 - fails on the function call we can say
16:20 - with P
16:23 - test dot raises and then we can say zero
16:29 - division
16:31 - error all right and we don't need this
16:34 - result CU we don't care about it anymore
16:36 - we just want to call the function
16:37 - without storing it let's go ahead and
16:41 - try this out so back in the
16:44 - terminal let's go ahead clear all that
16:47 - and then P
16:49 - test run it again and there we go we get
16:52 - three passes because what we're saying
16:54 - here is that we're expecting a division
16:56 - error when we call this function so even
16:59 - though the function itself fails or
17:02 - there's an error in the function we can
17:04 - test to make sure that error is there
17:05 - and that can be very important let's say
17:07 - You're Building A an accounting tool and
17:10 - you're dividing by zero you want
17:11 - something there too but just to kind of
17:13 - drive this point further if we go back
17:15 - to our divide function we can say
17:19 - if number
17:21 - two equals zero then we can raise and
17:26 - let's change it to a value error let's
17:29 - do that now if we go back and we run
17:32 - this
17:33 - again and if I just clear all that run
17:37 - it we get an error because we're testing
17:40 - for a zero division error but in
17:42 - actuality we're getting a value error so
17:44 - all we have to do here is just change
17:46 - this to Value
17:47 - eror all right so that's our test pretty
17:51 - much summed up uh or our very basic test
17:54 - summed up excuse me but we're only
17:57 - testing for number numbers what about
17:59 - strings like how would that work well it
18:00 - work the exact same way and so what we
18:03 - can do
18:05 - is we can use the add function and we'll
18:09 - say test add
18:13 - strings we'll say results equals my
18:17 - functions. ADD and we'll pass
18:20 - in I
18:24 - like and we'll
18:26 - say burgers
18:30 - now we can say assert result
18:33 - equals I like burgers because it will
18:37 - concatenate it so if we run this now and
18:40 - we go into the
18:41 - terminal and we say p test test my
18:45 - functions we get an
18:47 - error and that's good because you can
18:50 - see here that there we made a mistake
18:53 - where we need to add an extra space
18:55 - here see there like I like bu Burgers
18:58 - like burgers one word and then the what
19:01 - we're expecting is I like burgers is
19:02 - three separate words so let's run that
19:04 - again and there we go we get four passes
19:07 - looking beautiful and that is what you
19:09 - want to aim for as a
19:11 - developer but that brings us to the end
19:14 - of the first part of this tutorial which
19:16 - is looking at how to write very basic
19:19 - tests and now let's go over and start
19:22 - looking at how we can write class-based
19:24 - tests because right now all of these are
19:27 - function based tests
19:29 - so for our class based test the first
19:32 - thing that we need to do is write some
19:35 - classes that we can actually test so
19:37 - write some extra code CU right now all
19:39 - we have are two very basic functions
19:42 - which you can throw into a class base
19:44 - test however I want to kind of you know
19:46 - spice it up a bit and add some more a
19:48 - bit more complex code so inside source
19:51 - I'm going to go ahead and create a new
19:53 - file and I'm going to go ahead and call
19:55 - this
19:56 - shapes So within shapes what we're going
19:59 - to have is
20:01 - a class called shape and we're just
20:04 - going to use this for inheritance so
20:07 - shape and this is going to have a
20:10 - function that we'll override called
20:12 - area and we'll have another one and that
20:16 - will calculate the perimeter of a shape
20:21 - let's go ahead and add that in now let's
20:24 - go ahead and create a class which is
20:26 - going to represent a
20:29 - Circle and I don't know what is wrong
20:32 - with my spelling and this is going to
20:34 - inherit from
20:35 - shape the init so init this will take in
20:40 - a
20:41 - radius and we'll say self.
20:47 - radius equals
20:49 - radius then let's do the area and in
20:53 - order to calculate the area of a circle
20:56 - if you remember back Frome Elementary is
20:59 - we need the or we need to do pi r 2 so
21:04 - math or return math do pi multiplied by
21:10 - radius and squared so double
21:13 - asteris and a two and then for the
21:18 - perimeter we'll say return two
21:22 - multiplied by math P pi and then by the
21:28 - radius and it'd be a bit embarrassing
21:31 - for me to say that I actually have to
21:32 - look this up quickly before just to make
21:34 - sure I'm right as uh yeah sometimes I
21:37 - forget these basic things but anyway so
21:40 - now we have our class our class uh
21:44 - circle now let's go ahead and test it
21:47 - using class based tests so what we need
21:49 - to do is create a new file and we'll
21:51 - call this test
21:53 - Circle and it's a good practice to just
21:56 - name your class or your your test
21:59 - classes or test files based on what
22:02 - you're testing so in this case we're
22:04 - testing the circle so everything related
22:05 - to the circle will be in this
22:08 - file and here we'll say import P test
22:11 - and we need to import Source do shapes
22:15 - as shapes all right so to define a
22:19 - class-based test we'll say class and
22:21 - then test and circle and let's just put
22:25 - pass there
22:26 - now and this should pick it
22:29 - up anytime
22:33 - soon if it doesn't let's go ahead and
22:36 - just add test
22:38 - one and we'll just say assert true and
22:42 - again if you're using py charm you
22:44 - should see these play buttons show up
22:46 - now if you're not if you're using VSS
22:47 - code you may have an extension or there
22:49 - may be an extension out there which I'm
22:50 - sure there is where you can have the
22:53 - exact same effect but I'm more familiar
22:55 - with
22:56 - running or writing most my python code
23:00 - on pycharm but anyway now let's go ahead
23:03 - and if we just run this if you remember
23:05 - from the last example with my functions
23:07 - when we had a test I didn't do much it
23:10 - would still run in our case it should
23:12 - pass anyway because we're asserting that
23:14 - it is true so we'll
23:16 - say high test and then
23:21 - test and test
23:24 - Circle and there we go it's working
23:27 - let's actually just jump into test
23:29 - because we're going to be running
23:30 - everything through
23:32 - there all right so one of the cool
23:35 - things about tests or class-based tests
23:38 - is that it comes with two functions that
23:40 - can be quite useful the first one is the
23:43 - setup method now the setup method is
23:46 - there or is defined to run setup code
23:49 - before each test method so for all the
23:52 - test classes or test functions or
23:54 - methods that we write inside our
23:56 - class-based test the setup method will
23:59 - run at the beginning of each test and
24:01 - then like as a partner to it or to
24:04 - complement it there is the tear down
24:06 - method and the tear down method is there
24:09 - or defined to run tear down code after
24:12 - each test me method so after each one
24:14 - runs there is a tear down method so
24:16 - let's go ahead and just show that off
24:18 - we'll
24:19 - say set
24:21 - upcore
24:23 - method and we'll pass in this argument
24:26 - method now now the method argument just
24:29 - represents the test method that we're
24:30 - about to run so we can just say here
24:34 - print and we'll have a setting up and
24:39 - then
24:41 - method and then we'll have another one
24:43 - and we'll say tear
24:45 - downcore
24:48 - method and throw method in
24:52 - there
24:55 - print and setting
24:58 - or in this case tearing
25:01 - down and then the
25:04 - method all right so if we test this
25:07 - let's go ahead and use the P test
25:09 - command and say test
25:13 - Circle hit enter so we get a test passed
25:16 - but if we look at what the report
25:19 - generated we're not getting anything
25:21 - else so we're not getting our prints and
25:22 - we're not getting our tear down and the
25:25 - reason why we're not doing that is
25:27 - because when we call or when we use the
25:29 - P test command in our terminal we need
25:31 - to add A- s so we can say p test and
25:37 - then - s and now we get our print
25:40 - statement so setting up and then the
25:43 - method name so bound method test Circle
25:45 - test one and so it's just printing out
25:48 - the name of this test function that we
25:50 - have and then it's called tear down so
25:52 - if we did another test let's just copy
25:54 - test
25:55 - one and then
25:58 - here we'll
26:01 - say test two and if we were to go back
26:05 - to the terminal run it all again now we
26:07 - have four so we have setting up test one
26:11 - tearing down test one setting up test
26:13 - two tearing down test two now you're
26:17 - saying to me okay this is all well and
26:19 - good but this is useless I mean we're
26:20 - just printing stuff out well one thing
26:23 - that can be quite useful is that in the
26:25 - setup method we can have some something
26:27 - like say self do
26:30 - Circle and we'll say shapes do Circle
26:34 - give it a radius say 10 now for every
26:38 - method that we have this a circle object
26:42 - is going to be created so now we can
26:44 - access it in test one and instead of
26:46 - calling it test one let's say
26:50 - test radius so test
26:54 - radius and then here we can say
26:58 - CT and then self. Circle
27:02 - radius equals and we will need the math
27:06 - function so let's just import
27:09 - math and we know that the radius has to
27:12 - be
27:13 - math and we need pi multiplied by self
27:18 - do Circle
27:20 - dot uh radius and this here should be
27:24 - area and we should name this part here
27:27 - to area I don't know why I put it as
27:28 - radius but
27:31 - area and
27:33 - then this should be multiplied and then
27:39 - squared now let's go back and inside the
27:43 - terminal we'll say high
27:47 - test and then test
27:52 - Circle and there we go we get our test
27:55 - and you can of course add the - S as
27:59 - well um
28:01 - so like
28:04 - this but that is how the setup method
28:07 - can be useful now on our tear down we
28:10 - can also do something like delete self.
28:13 - Circle and in this case it's not
28:15 - necessary because it will be doing that
28:18 - anyway but for more
28:20 - complicated um more complicated programs
28:23 - that you're testing this tear down
28:25 - method can be quite useful along with
28:27 - the setup method however that's our
28:30 - class base test sorted out let's just
28:33 - clean it let's just finish it off really
28:35 - let's add a new test and say test
28:39 - perimeter because repetition with this
28:43 - helps and then we'll
28:45 - say result equals self.
28:49 - Circle do
28:52 - perimeter and then expected
28:55 - value equals 2
28:57 - time math
29:00 - Pi Time by S do Circle radius and then
29:06 - we can say assert and
29:10 - result equals
29:14 - expected again spelling
29:16 - error
29:21 - expect am I just going crazy here oh
29:24 - yeah thought it was a spelling error we
29:25 - need to change that too sorry long day
29:29 - and there we go so that's our test
29:31 - parameter let's go ahead and test that
29:33 - out and we're all green cool so that's
29:38 - our class based tests like basically the
29:41 - overview of how class based test work
29:43 - how you can set it up and how you can
29:45 - use it with P test the next cool thing I
29:47 - want to show you are pie test
29:50 - fixtures so I'm back inside of the
29:53 - shapes file and what I want to do is go
29:56 - ahead and create another shape which
29:58 - we'll use to test well first of all
30:00 - we'll write our tests on and we'll then
30:03 - use fixtures to improve on those tests
30:05 - so down below I'm going to go ahead and
30:08 - create a new class this is going to
30:10 - represent a rectangle inherit from
30:14 - shape and we need to initialize it this
30:18 - will take in a length and a
30:21 - width self do
30:25 - length equals length
30:30 - and self.
30:32 - width equals
30:34 - width then let's calculate the
30:38 - area return self dot length by self.
30:44 - width and
30:48 - perimeter which we can do as return self
30:51 - dot length multiplied
30:56 - two
30:57 - [Music]
30:58 - and add that to self.
31:03 - width multipli 2 all right so we have
31:07 - now our rectangle now we need to go
31:09 - ahead and test it so let's create a new
31:12 - test file inside of the test directory
31:14 - we'll call
31:15 - this testore
31:19 - rectangle all right so let's just go
31:21 - ahead and use our functional tests and
31:25 - write the very basic test that we need
31:27 - so we know we need to test first let's
31:30 - just make the
31:32 - import import P
31:35 - test import
31:38 - Source do shapes
31:41 - as
31:45 - shapes then test
31:49 - area and here we'll say
31:52 - rectangle equals
31:55 - shapes Dot rectangle and we'll pass in
32:00 - 10 and
32:05 - 20 then we'll say
32:09 - assert rectangle do
32:11 - area
32:14 - equals or and
32:17 - rectangle or we'll say 10 multiplied by
32:21 - 20 all
32:24 - right new line reformat okay so we have
32:27 - our test area there now we can go ahead
32:29 - and run this just like we did before so
32:32 - we'll say test or P
32:34 - test and test
32:38 - rectangle and we have one pass all right
32:42 - now let's go ahead and create another
32:45 - test and we'll
32:48 - say test
32:51 - perimeter and here again we need a
32:53 - rectangle so we'll take this
32:56 - here paste it
32:58 - in and say assert rectangle.
33:03 - perimeter
33:05 - equals and that is 10 * 2 + 20 * by
33:14 - two now if we were to run this go back
33:18 - here clear and test it again we have two
33:22 - passes all right so nothing too special
33:24 - you're like okay we've seen this before
33:27 - what's so amazing about it well one
33:30 - thing we can do or one thing that you
33:32 - may have noticed is that our rectangle
33:34 - is being used and declared twice so we
33:37 - have two rectangles here both with a
33:39 - length of 10 and a width of 20 the
33:42 - values that don't really matter but the
33:44 - point is that we're repeating ourselves
33:46 - that we're needing a rectangle in both
33:47 - cases and we're creating a rectangle in
33:49 - both cases now if we were to use our
33:53 - where is it test Circle so if we were to
33:55 - use class based method we could or class
33:58 - base test we could of course have
33:59 - initialized it in the setup but what
34:02 - about with functional with functional we
34:04 - can use something called py test
34:06 - fixtures so we can do py test do
34:09 - fixture and then
34:11 - say how we can call it my rectangle you
34:14 - can name it whatever you
34:16 - want and all this will do is return a
34:23 - rectangle like
34:25 - so
34:27 - so now what we can do is we can
34:30 - literally plug this into each of our
34:32 - tests here so we can say my rectangle
34:37 - here and my rectangle
34:40 - here and we can remove this here this
34:44 - rectangle
34:45 - equals move it there as well and replace
34:49 - rectangle with my rectangle or whatever
34:52 - you named it so here and
34:55 - here
34:57 - go back up go back to the terminal let's
35:00 - clear that out High test and then
35:05 - test rectangle and there we go back to
35:09 - where we were but now we are using our
35:13 - py test
35:14 - fixture so just to kind of hone this in
35:16 - let's create another fixture
35:19 - and let's use that as well as our my
35:24 - rectangle so first of all let's just go
35:26 - back into shapes and I'm going to go
35:29 - ahead and create a
35:31 - new method which or not really create
35:34 - but at least overrides with the equals
35:37 - and here I'm going to say
35:39 - if is instance so if not is instance
35:45 - what we want to do here is say that if
35:48 - it's not a
35:50 - rectangle then we want to return false
35:53 - otherwise then we're going to check to
35:55 - see whether a rectangle is equal to to
35:56 - another so we'll say other and then
36:00 - rectangle and return
36:06 - false and then here we'll say return
36:08 - self do
36:10 - width equals
36:13 - other width
36:16 - and self do
36:19 - length equals other dot length so it's
36:23 - just a override for the equal so we can
36:25 - compare two different rectangles so now
36:27 - if we go back into test rectangle let's
36:29 - create a new
36:31 - fixture and we'll say
36:35 - fixture call this
36:38 - weird rectangle name it whatever you
36:40 - want I guess in a professional setting
36:43 - you'd want to name it something
36:45 - sensible but here we'll say shapes do
36:49 - rectangle and we'll
36:53 - say five and
36:55 - six
36:58 - all right now we can use this a weird
37:03 - rectangle and down below we'll
37:06 - say test
37:09 - not
37:11 - equal and we'll pass in my rectangle and
37:15 - a weird
37:16 - rectangle and we'll
37:20 - assert that my rectangle does not equal
37:24 - weird rectangle
37:28 - and we can go back to our terminal and
37:31 - just clear all that and say p
37:35 - test and test
37:39 - rectangle and there we go we have three
37:41 - passes but the important part here is
37:44 - that we're using our
37:46 - fixtures now one thing that is also
37:50 - important is that we can use something
37:52 - called con test so we can make our
37:54 - fixtures Global Within our tests so
37:57 - let's say for example you need the
37:59 - rectangle inside of test Circle for some
38:02 - reason um and you don't want to keep on
38:05 - declaring more um objects so you want it
38:09 - in a global play so you can access it
38:11 - easily now to do that is fairly simple
38:14 - all you need to do is inside of tests we
38:16 - have to create a file and we have to
38:18 - call this file conf
38:24 - test.py and in here this is is where we
38:27 - can Define our rectangles again so I'm
38:31 - going to go here and I'm just going to
38:32 - take this so my rectangle and weird
38:35 - rectangle I'm going
38:38 - to save that and go into com test paste
38:42 - it in of course we also need to import P
38:46 - test and shapes so
38:48 - import P test and import
38:54 - Source shapes as
38:58 - shapes there we go so
39:01 - now if we go back to test rectangle you
39:04 - can see that it's not complaining we can
39:06 - get rid of this and let's go ahead and
39:09 - run rectangle again so we'll say Pi
39:13 - test and test
39:17 - rectangle and there we go we have three
39:21 - clear tests and we have our my rectangle
39:24 - in use and our weird rectangle use which
39:27 - we' stored in a global place which is
39:28 - our com test we can also access in other
39:31 - files as well so inside let's say our
39:33 - test Circle we can
39:36 - do let's just come up with a silly
39:38 - example so test not
39:42 - same
39:44 - area
39:50 - rectangle and here we can pass in my
39:53 - rectangle like so and
39:57 - we'll say Circle equals self.
40:02 - Circle oh we already have the circle
40:05 - because we defined it up here so we can
40:07 - say assert does not
40:10 - equal or um self. Circle do area does
40:16 - not equal and then my
40:19 - rectangle do
40:22 - area all right now if we were to go into
40:25 - our terminal
40:27 - once again let's just clear all
40:30 - that and say p test and
40:34 - testore
40:35 - circle there we go everything is green
40:39 - and we're making use of our rectangle
40:41 - that we defined in com test accessible
40:44 - or we're using it in our test Circle
40:47 - file so this can be pretty useful
40:49 - especially if you've got like a really
40:50 - large code base where you have a lot of
40:52 - shared objects then the com test can of
40:55 - course be very helpful there so of
40:58 - course I wouldn't over abuse it like I
41:00 - wouldn't store everything in contest uh
41:03 - but this is just an example of how you
41:05 - can now the next thing that we're going
41:07 - to look at is something called pie test
41:10 - marking and
41:12 - parameterizing so the pie test Mark
41:15 - mechanism provides a way to add metadata
41:18 - to your test so you can think of it as
41:19 - tagging your test with labels that can
41:21 - influence how the test runs or is orted
41:25 - and the purpose of it is that you can
41:27 - label or tag your tests to categorize
41:28 - them for instance you might want to
41:30 - label some tests as being slow or some
41:33 - tests as be as to skip and um yeah which
41:37 - means that you can conditionally execute
41:39 - your tests so let's go ahead and do that
41:41 - so back in my
41:44 - functions we're just going to use add
41:47 - and divide as our examples because the
41:49 - purpose of Mark is just to demonstrate
41:52 - how they work not so much writing the
41:54 - test themselves so let's go ahead
41:58 - and if we I'm in my test we need my
42:01 - functions we need to go to test my
42:02 - functions so in here let's go ahead and
42:07 - let's look at the slow tag so let's say
42:11 - let's just import time at the top of
42:13 - this say import time go back
42:18 - down and we'll say
42:22 - test very
42:24 - slow um we will
42:27 - have let's take this here
42:32 - result actually let's just take all of
42:35 - this paste that in
42:37 - here and then above that what we'll do
42:39 - is just do time do sleep and we'll say
42:42 - 10 seconds so actually 10 seconds might
42:44 - be a bit too long for this video so
42:46 - let's do five so if we run this if we go
42:49 - into the
42:50 - terminal and say just clear that P test
42:55 - and then test my
42:59 - functions and it's still running cuz
43:02 - it's waiting for the last one and there
43:03 - we go it took 5
43:05 - Seconds however this is a slow test and
43:08 - it didn't do anything it didn't alter
43:09 - the way our test work so everything
43:12 - passed and it managed to get to the end
43:14 - of this but it can be helpful for us to
43:16 - know that this test is going to be a
43:19 - slow
43:21 - one so we can say something like that so
43:25 - that's just telling us is ADD adding
43:26 - some metadata to state that this is a
43:28 - slow test so if you want to see the slow
43:32 - test or just or test the slow test we
43:34 - can say Pi test and then- M and then
43:37 - slow and it will only run the test my
43:40 - functions one because that's the only
43:41 - one that has a mark of
43:45 - slow and we're getting a warning Mark
43:48 - slow is this a
43:51 - typo I guess in this case no um but
43:54 - anyway it passs anyway this is just a
43:56 - warning it wasn't a
43:57 - failure and let's go back so that's the
44:00 - slow one can be quite useful let's say
44:03 - if you're I don't know if you're
44:05 - calculating something that takes a while
44:07 - to calculate you might want to add that
44:09 - in the next one is the
44:12 - skip uh test so let's go ahead and
44:16 - say at P test Mark and then Skip and we
44:22 - can add a reason to it as well just for
44:25 - ourselves can be quite
44:27 - useful and here we'll say this feature
44:32 - is
44:33 - currently
44:36 - broken and here we'll
44:39 - say
44:41 - test uh ad and let's just assume the ad
44:45 - is broken in this case we'll go ahead
44:47 - and assert
44:50 - that my functions do add one and two
44:56 - equals
44:58 - 3 and give that some extra
45:02 - room now if we go to our terminal clear
45:06 - all
45:07 - this and we run it again so we'll say Pi
45:10 - test test my
45:13 - functions enter you can see here that
45:17 - there's one that has an S there as well
45:18 - that means skip so we're skipping one
45:20 - test the other one is a slow one but
45:24 - here we are like that's a way to skip
45:26 - your test so you just add that in there
45:28 - another one is the X fail so we can go
45:32 - here and say p
45:34 - test and then
45:38 - Mark and then X
45:41 - fail and we can add a reason to this as
45:44 - well we can
45:45 - say uh we know we cannot divide by
45:53 - zero and we'll go ahead and do exactly
45:56 - that so test
45:58 - divides
46:01 - zero um say broken let's assume V my Z
46:05 - is a broken function all right so um
46:08 - let's go ahead and say
46:11 - assert um well let's just make the cor
46:14 - because we know it fails so we'll say my
46:16 - functions divide three four and zero
46:21 - let's go ahead and run this now so clear
46:25 - that and then P test tests my
46:31 - functions give that a
46:34 - second and there we go so if you go back
46:38 - here we have the s that represents our
46:40 - skipped one then we have these Green
46:41 - Dots which represent our past and then
46:44 - we have this x which means that we know
46:46 - this is going to fail uh and you can see
46:48 - here this kind of this breakdown four P
46:51 - one skipped one failed One X failed so
46:55 - it didn't fail
46:56 - in the literal sense that tests
46:58 - themselves fail um it failed given that
47:01 - we marked it as something that can fail
47:03 - as well so this is how Mark or marking
47:07 - can work and it can be again quite
47:09 - beneficial to just add some extra
47:11 - information around your tests there may
47:13 - be some tests that you know will break
47:15 - and you don't want to fix those tests or
47:16 - there's certain reasons why you don't
47:18 - want to fix them you can of course use
47:20 - this xfil then there is the skip which
47:23 - just means that yeah you want to skip
47:24 - this test um and maybe you'll come back
47:27 - to it later on uh but you want the test
47:29 - in there just as a reminder and then
47:32 - it'll also be useful for other Engineers
47:34 - that you're working with so they know oh
47:36 - wait why is it skipped there's probably
47:37 - a reason for it and they'll know the
47:39 - reason so the mark pest Mark can be a
47:42 - very useful feature mainly for us as
47:44 - engineers and also for your testing as
47:47 - well depending on how you want to see it
47:49 - but anyway that's covered that or that
47:51 - covers P test marking now we'll look at
47:54 - parameterize so so for the example with
47:57 - parameterizing what we're going to do
47:59 - first is back inside our shape so we're
48:01 - going to add our last shape and that's
48:03 - going to be a square so we can actually
48:06 - inherit from our rectangle and the way
48:10 - we can do that is by saying class and
48:16 - then
48:17 - Square inherit from
48:20 - rectangle and here we'll
48:22 - say in
48:24 - it
48:26 - and it will just give it a side
48:29 - length and then here we can say
48:35 - super and we'll pass in the side length
48:39 - for the initializer and side length for
48:41 - the so for the width and the
48:43 - length all right so that's our Square
48:46 - sorted out so let's go ahead and create
48:48 - a new file inside of tests and we'll
48:50 - call this one
48:53 - test Square
48:57 - all right so for this let's go ahead and
49:00 - make the necessary Imports so P test and
49:03 - import Source do my functions actually
49:07 - shapes as
49:10 - shapes all right so what is this whole
49:13 - thing around parameterizing so imagine
49:16 - you have a light bulb and you want to
49:18 - test it with different brands of
49:20 - batteries to ensure that it works with
49:21 - all of them so instead of writing each
49:24 - uh separate test for each battery uh it
49:27 - would be more efficient to actually just
49:29 - write one test and run it for each
49:30 - battery brand now of course you can try
49:33 - this out with a full loop however full
49:35 - Loops can get a bit messy and it just
49:36 - kind of ruins readability after a while
49:39 - so instead what the team behind P test
49:42 - have done is created this parameterized
49:44 - concept so the way we can use it is
49:47 - let's say we want to calculate the area
49:51 - of a square but we want to give it
49:52 - multiple values so let's just first
49:55 - Define find it so test
49:58 - multiple
49:59 - Square
50:01 - areas and it will take in a side
50:05 - length and we'll Define that in a second
50:08 - as a parameter and a expected
50:10 - area and the way this will work is what
50:13 - we'll say is assert and then shapes do
50:18 - shape and pass in the side
50:21 - length do area equals the expect area
50:26 - now you're wondering okay where are
50:28 - these values coming from they're not
50:29 - coming from the com test because we
50:30 - haven't defined it there well the way we
50:32 - can do that is here we can say at pest.
50:36 - Mark in but this time
50:38 - parameterize and here we'll Define the
50:41 - first parameter which is side length and
50:44 - then comma and then expected
50:48 - area and then we need to give values for
50:51 - both side length and the expected area
50:54 - so to do that
50:55 - we'll
50:57 - say it's going to be a list the first
51:00 - value of this topple so we'll have a
51:03 - list of topples and inside the first
51:05 - topple the first element is going to
51:08 - refer to the side length and then the
51:11 - second one is going to refer to the
51:13 - expected area and let's create a few of
51:15 - them cuz right now that's just one and
51:17 - then we'll do four and
51:20 - 16 and we'll do say nine and
51:27 - 81 let me just format this to stop it
51:29 - from
51:30 - complaining all right so what do we have
51:33 - so we have this parameterized Mark that
51:35 - we've placed on top of this test
51:36 - multiple Square areas then we have side
51:39 - length and expected area now side length
51:41 - refers to the first elements of each of
51:44 - the topples that are in this list so 5 4
51:47 - and 9 the expected area however is
51:49 - referring to the second element of each
51:51 - of these uh the second element of each
51:54 - topple so 25 16 and
51:57 - 81 now we can actually just go ahead and
51:59 - run this so let's go ahead and clear
52:01 - this out and we'll say Pi test and then
52:06 - test
52:09 - square and we get an
52:11 - error because shape takes no this meant
52:13 - to be
52:14 - square it's good job that we're testing
52:17 - to see this
52:18 - error and then run it again and there we
52:21 - go and you can see here that we get
52:23 - three dots and that's because we have
52:25 - three different topples inside of our
52:28 - list now you can of course create
52:30 - another one so we say random here and if
52:33 - you want to use that you have to add
52:35 - another value to this as
52:39 - well like so so that's how
52:42 - parameterizing works now let's go ahead
52:44 - and do a bit of practice let's use it
52:46 - again on the perimeter so we'll
52:51 - say
52:53 - here we'll first add add our decorator
52:57 - Mark and then
52:59 - parameterize and for the perimeter we'll
53:02 - have a side
53:05 - length and comma
53:09 - and we'll call this one
53:14 - expected
53:16 - perimeter and then what we can say in
53:19 - this is the topple is going to be first
53:22 - one let's say three and the perimeter
53:26 - for that is going to be
53:28 - 12 then we'll have another one we say
53:33 - four and the perimet that is going to be
53:37 - 16 and then we'll say do another final
53:40 - one five and the perimeter of that is 20
53:44 - and then we'll say Define test
53:47 - multiple
53:50 - perimeters and then we'll say the side
53:54 - length
53:56 - and expected
53:58 - perimeter and we'll do the exact same
54:00 - thing so ass set and then shapes do
54:03 - shape and throw in side length do
54:07 - area
54:10 - equals the expected perimeter and this
54:13 - should not be area this instead should
54:15 - be the
54:17 - perimeter and there we go let's go back
54:19 - into our terminal and if we were to run
54:22 - this
54:23 - now we get a a bunch of M errors
54:27 - because we have fail test multiple
54:31 - Square areas in parameterize the number
54:34 - of
54:36 - names expected ah it's this one here we
54:39 - need to get rid of this
54:41 - random run that
54:43 - again shape again so another one so this
54:46 - has to be square don't know why I miss
54:49 - that but this should be square go again
54:53 - and there we go now we have six tests
54:55 - but we've only by looking at it at face
54:58 - value just written two tests so
55:00 - parameterized can be very useful if you
55:02 - want to try the same test with different
55:05 - values to see what output you get rather
55:07 - than writing like a for Loop where it
55:08 - gets all messy so yeah definitely use
55:11 - parameterize when you need to it can be
55:12 - very powerful and very useful for
55:15 - developers who are reading it later on
55:18 - so again yeah this covers the
55:21 - parameterize parameterizing with py test
55:24 - now let's move on to the next
55:27 - topic so for the next topic we're going
55:30 - to look at something a bit more advanced
55:33 - and that's called mocking now mocking is
55:36 - a powerful testing technique which is
55:39 - used to isolate the system that we're
55:41 - testing and replace the external
55:43 - dependencies with controlled
55:45 - implementations called mocks so when
55:48 - might you use mocking now imagine you're
55:51 - writing a or you're writing code that
55:54 - fetches data from an external API using
55:57 - let's say the request library and you
56:00 - when writing this test you don't want to
56:02 - actually call the API itself because it
56:05 - might be slow it might cost money or
56:07 - affect rate limits and depending on the
56:11 - api's actual data as that is subject to
56:14 - change it might cause your test to fail
56:16 - so we don't want to depend on the API
56:19 - itself let's say we just know what the
56:21 - API is going to respond and we want to
56:22 - test that the same may also go for for
56:25 - testing a database so you might have a
56:28 - test that is testing let's say getting a
56:30 - user from a database and you don't want
56:33 - to depend on the database itself as you
56:36 - know the connection might be disrupted
56:38 - and therefore your test might fail so
56:40 - that's where mocking can come into play
56:42 - now I'm talking a lot so let's go ahead
56:44 - and actually code an example up and see
56:46 - how useful mocking can be so first in
56:51 - the source directory I'm going to go
56:53 - ahead and create a new file I'm just
56:54 - going to going to call this
56:57 - service and within that what we'll do is
57:00 - create a
57:02 - dummy uh database where we'll get a user
57:05 - so we'll say our database
57:09 - equals and in there we'll say one that
57:12 - will represent the ID we'll have Alice
57:14 - in there two we'll have Bob in
57:20 - there
57:21 - and three let's say we'll have have
57:25 - Charlie in
57:27 - there all right now what we'll do is
57:32 - create a function which will get user
57:37 - from DB and it will take in a user
57:41 - ID and it will return
57:45 - our
57:47 - database. getet user ID so pretty much
57:51 - working a bit like if you're using an
57:53 - omm it might be similar
57:55 - but in this case we're just mocking it
57:57 - with a database or actually we're not
57:58 - mocking it in the sense of testing this
58:01 - is let's just say this is actually our
58:04 - database and we'll mock it in a second
58:08 - let me just format
58:10 - this and then let's create a new file
58:14 - inside of test and we'll call this one
58:17 - test
58:19 - service and
58:21 - enter all right so how do we actually
58:24 - mock
58:25 - this so first of all let's make the
58:27 - necessary Imports let's import py test
58:30 - we need to import Source do service
58:35 - let's say
58:36 - service and let's leave it at that
58:40 - so there is another import that we'll
58:42 - need and actually let's just do that now
58:44 - so let's go ahead and say
58:49 - import right there import and unit
58:55 - test and then mock as a mock all right
59:00 - so remember right at the beginning of
59:02 - this video we were talking about how you
59:04 - can use other testing libraries within P
59:07 - test without any issues so we're doing
59:09 - that exactly here and the reason why you
59:11 - don't need to install this is because
59:12 - unit test comes with python I think from
59:15 - 3.3 version 3.3 and onwards you'll have
59:18 - unit test with every python installation
59:21 - that you make so you don't have to make
59:23 - a installation here and mock is inside
59:26 - of there and we'll use that for
59:29 - this all right so let's go ahead and
59:32 - create our test so test get user from
59:38 - DB and let's just put pass there the
59:41 - first thing that we need to do is add a
59:43 - decorator to it and that will come from
59:45 - Mock and we'll say
59:48 - patch and then we need the route or the
59:52 - path to our basically the path to our
59:56 - function so we'll say Source do
60:01 - service. getet
60:04 - user from
60:08 - DB and so that's going into our source
60:11 - and then our service file and then our
60:14 - function which we called get user from
60:17 - DB then we need to map that to an
60:20 - argument here so a bit like how we did
60:22 - with fixtures so what we'll say or with
60:24 - parameterizing or parameterize as we
60:27 - looked at earlier we can say mock get
60:31 - user from DB and this doesn't have to
60:35 - match this um so this mock part this the
60:38 - naming convention there's nothing strict
60:40 - here I just named it that for
60:42 - readability but you can call this
60:43 - whatever you want so it doesn't
60:46 - matter then we'll say Mock and then get
60:49 - user from DB and we'll say that the
60:52 - return
60:53 - value is going to
60:56 - be
60:58 - mocked
61:00 - Alice and then we'll say
61:04 - username equals and we'll say service
61:09 - dot get user from DB we'll put in the ID
61:12 - one and then we can say
61:16 - assert and then username
61:21 - equals
61:22 - mocked Alice so let's just quickly go
61:25 - over what we've just done once again now
61:29 - we're using the patch function from mock
61:31 - to replace get user from DB so we're
61:35 - saying use this function that we've
61:37 - defined in our source service and
61:40 - replace that with mock get user from DB
61:44 - and then here we're saying that the
61:45 - return value from this function call so
61:48 - whenever we call it in this test so in
61:50 - this test get user from DB we want the
61:53 - result to be mocked Alle
61:55 - and then here that's where we're
61:57 - fetching from our database that's when
61:58 - we're actually making use of our get
62:00 - user from DB we call it we pass it in an
62:03 - ID and then we're saying assert username
62:06 - equals mocked Alice because we know as
62:09 - Engineers so in a real life setting you
62:11 - will know that when you call this it
62:13 - will return a string and so if anything
62:17 - changes you will have to adapt this test
62:18 - of course but that's how this is working
62:22 - here all right so so that sums up the
62:27 - database test let's actually go ahead
62:28 - and run it so let's go into
62:31 - terminal and we'll say p test and then
62:36 - test service enter and we get a
62:41 - pass so there we go now if we were just
62:43 - to replace this with
62:46 - say that and then we run
62:50 - this or maybe if I use a terminal
62:53 - instead so P
62:55 - test we're getting an error because a
62:57 - moed Alice the return value that we're
63:00 - getting from this so get from get user
63:02 - from DB does not equal ASDF
63:06 - ASDF so there you go so in this case
63:10 - we're not testing whether or not the
63:12 - database works or not we're just testing
63:14 - to make sure that the response we're
63:17 - getting is what we expect is what we
63:19 - would expect so that's where mock
63:21 - mocking can be quite useful but this is
63:23 - a very simple example of mocking let's
63:26 - actually use it with an API so the first
63:29 - thing that we need to do is back inside
63:32 - the root of our project let's pip
63:34 - install
63:35 - requests so we need this request Library
63:38 - I just installed it with Pip instore
63:40 - request just here now back inside
63:44 - service we're going to go ahead and make
63:46 - an API call with that so we'll say
63:50 - import
63:51 - requests and what we're going to do is
63:54 - make a call to this website called Json
63:58 - placeholder and you can go to Json
63:59 - placeholder do type I code.com and here
64:04 - it just gives like free fake API for
64:07 - testing and prototyping which can be
64:08 - quite useful for our case for example
64:11 - and we're going to use the users
64:12 - endpoint so this one here you can use
64:15 - whatever endpoint you want just going to
64:16 - go with the users so when we fetch or we
64:19 - do a get request we're going to get this
64:22 - here so back in our code let's go ahead
64:26 - and create a function which will get the
64:29 - users so down
64:31 - here we'll say get
64:37 - users then here we'll say response
64:39 - equals and we need to we've imported it
64:42 - yep
64:43 - requests.get and we need to paste in the
64:47 - URL so this URL here copy that paste it
64:51 - in with double quotes and then if if the
64:55 - response. status code equals 200 meaning
64:59 - that the request was successful we'll
65:01 - return
65:03 - response.
65:07 - Json and then here we'll say raise
65:10 - requests. HTTP error so if there is an
65:13 - issue if it's not 200 then we want to
65:16 - raise a HTTP error all right now let's
65:20 - test this so like I said when we started
65:23 - talking about
65:25 - our uh mocking is that you will use
65:28 - mocking for something like testing or
65:31 - fetching from an API but you don't want
65:33 - to test the API itself the API is
65:36 - someone else's responsibility we're just
65:38 - testing in our case that we get the
65:40 - response that we want uh or we're
65:42 - getting the expected data that we want
65:45 - so remember actually calling an API in a
65:47 - test might not be the most economical
65:50 - thing to do uh it might actually not be
65:52 - the most efficient thing to do as well
65:54 - because apis can be slow so let's go
65:57 - ahead
65:58 - and use or test our function so the
66:03 - first thing that we need to do is of
66:05 - course map it with the patch so we'll
66:09 - say this
66:11 - mock do patch and we want to mock the
66:16 - request.get and I'll explain it further
66:19 - in a second so requests so make sure
66:21 - it's s doget and then we'll say testore
66:27 - getet
66:28 - users and Mock undor getet and then
66:31 - we'll say pass so let's just quickly
66:33 - explain this so we're testing our get
66:36 - users but we don't want to test
66:38 - necessarily the
66:40 - function or we do want to test a
66:42 - function but we want to mock the
66:45 - request.get so whenever we call
66:47 - request.get within this which we will
66:50 - because we'll be testing the function
66:52 - then we want to mock we want want to get
66:54 - a certain response so let's go ahead and
66:56 - say mock response equals
67:00 - mock mock like
67:03 - that and then we'll say mock
67:07 - response. status code and don't worry if
67:10 - you're confused because I found this
67:12 - very confusing when I first learned it
67:15 - and then mock response.
67:20 - Json and then return value
67:25 - equals and we know that the data looks
67:28 - like this but because we already know
67:30 - that we can shorten it so we'll say
67:32 - something like ID usually you would use
67:36 - like an exact example of it but for the
67:39 - purpose of this it doesn't matter
67:40 - because we already have an idea name and
67:43 - then
67:45 - John
67:48 - do and then
67:50 - mock getet do return
67:56 - value equals mock response and then data
68:01 - equals API or
68:04 - service. get
68:07 - users and then we'll
68:09 - say SE data
68:13 - equals ID one and
68:19 - name
68:22 - John do
68:24 - okay so to explain it what we're doing
68:26 - here is where so let's start from line
68:30 - 18 so we're calling this get users and
68:33 - within get users we're using request.get
68:37 - and in our test this is what we're
68:40 - mocking so we're saying whenever this is
68:42 - going to be called within our test we
68:45 - want it to come back with a response and
68:47 - the response that we want is in the form
68:51 - of this so This Json return value ID one
68:56 - name joh do because in our service
68:59 - response as this Json that we're
69:02 - returning so if the status code is 200
69:05 - then where response Json is going to be
69:08 - returned and we want to say when this is
69:10 - returned and it's successful then it's
69:12 - going to look like this dictionary here
69:16 - and then we also want the status code so
69:18 - we're sending that to 200 and the reason
69:20 - why we're not just saying mock response
69:23 - Json equals dictionary is because the
69:26 - difference between status code and Json
69:29 - with our request.get response is that
69:31 - status code is actually a property and
69:34 - Json is actually a function or a method
69:37 - call so that's why we have to add this
69:39 - do return value so let's go ahead and
69:42 - test this
69:44 - now so clear and then Pi
69:49 - test
69:51 - test now we're outside so tests and then
69:54 - test
69:55 - service enter and we have two
69:59 - successes that means our data is this
70:03 - the value that we're mocking to json.
70:06 - return value and we can also
70:09 - say that or in our case it doesn't
70:12 - really matter we can't test this because
70:14 - our service is returning the response.
70:16 - Json anyway but to drive this a mocking
70:19 - Point further if we go back to our
70:22 - service we can see that if the status
70:25 - code is not A200 then we should get a
70:28 - HTTP error raised so we can go ahead and
70:31 - use our mocking power to make sure that
70:34 - that is the case so we'll say mock do
70:38 - patch and then
70:40 - requests.get
70:42 - and we'll do here test
70:45 - test get
70:48 - users
70:50 - error and then mock unor getet
70:54 - and within here what we'll do is say
70:56 - mock response so we'll take these
71:00 - two and paste that
71:03 - in and set the status code to
71:06 - 400 and then we'll say
71:10 - mock uh Moore getet dot return
71:16 - value equals mock response and then
71:20 - we'll say with it test. raises
71:24 - requests HTTP error and API or
71:30 - service. get users it should now work so
71:33 - let's go ahead and run it and once we
71:37 - run it we get a pass because we're
71:39 - saying that the status code is a 400 so
71:42 - with with that in mind we should get a
71:45 - raise a HTTP
71:48 - error now if we were to change that to a
71:51 - 200 and run it we get an error because
71:55 - it did not raise even though we have a
71:58 - 200 we were expecting a raise but
72:00 - instead we got a test fail so that
72:04 - should give you a good idea or hopefully
72:07 - gives you a good idea as to how mocking
72:10 - works with python testing now it might
72:13 - be a bit of a tricky thing to grasp at
72:15 - first it is a bit of a weird concept it
72:16 - was definitely for me however one rule
72:19 - of thumb that I would apply is when you
72:21 - want to use mocking or if you're kind in
72:23 - a bit of a dilemma if you want to use
72:25 - mocking or not I tend to use it when my
72:28 - tests are dependent on external programs
72:32 - that can give or cannot guarantee the
72:35 - same result each time for example if
72:37 - you're testing an API you cannot always
72:39 - guarantee that if you give it certain
72:41 - inputs you will get the exact same
72:43 - output each time because you know an API
72:46 - can of course crash it may have some
72:48 - downtime or whatever or may may take to
72:51 - some time to to actually give a response
72:53 - depending on the day or situation so you
72:56 - can't really guarantee that and your
72:57 - tests need to guarantee that you always
72:59 - have this result when you make a certain
73:02 - call to a function or a program so keep
73:05 - that one in mind and definitely play
73:07 - around with mocks as they can be very
73:09 - powerful when used correctly now let's
73:12 - move on to our final topic where we'll
73:15 - look at how we can use artificial
73:17 - intelligence to help us write our tests
73:21 - so in order to test AI when it comes to
73:24 - writing our test to see how well it can
73:27 - write python tests head over to
73:29 - open.com and there you'll have access to
73:32 - chat GPT by clicking on try try chat GPT
73:36 - now I already have an account I have a
73:38 - pro account which costs around I think
73:41 - $20 a month and it's definitely well
73:43 - worth it especially if you're a
73:44 - developer as the value that you get out
73:47 - of it is substantial but we'll also try
73:50 - it out on the free version so the 3.5
73:53 - version and on the more upto-date
73:56 - version chat GPT 4 so I've already
74:00 - signed in and this is my account so this
74:04 - is my prompt I can click on either chat
74:07 - GPT 3.5 or GPT 4 with the 3.5 model this
74:13 - is available on the three version so if
74:15 - you're not paying for it you will have
74:16 - access to this and let's go ahead and
74:18 - see how useful this will be when it
74:20 - comes to writing our tests but before we
74:22 - do any of that what we need to do is go
74:25 - ahead and write some more code so in our
74:28 - source I'm just going to go ahead and
74:30 - close all of
74:32 - this and what we'll do is create a
74:36 - new program or a new class inside of
74:40 - this we'll call this school
74:44 - dopy and now this will represent or this
74:47 - will hold a classroom and that classroom
74:50 - will have a teacher and a number of
74:51 - students so let's write it up let's go
74:53 - ahead and say class
74:59 - classroom
75:01 - and say in
75:03 - it can initialize it with a teacher and
75:08 - students and we say course
75:12 - title and then we'll say self. teer so
75:15 - all the standard stuff or initializing a
75:18 - class self do students equals
75:22 - students
75:24 - and self. course
75:28 - title equals course
75:31 - title all right then we'll have a
75:33 - function where we can add a
75:37 - student and we'll pass in a student to
75:41 - this and we'll say if the
75:45 - length we don't need the parentheses so
75:48 - if length of self. students is less less
75:53 - than or equal to say
75:56 - 10 then we will
76:00 - add a student so students. append and
76:06 - student otherwise we want to raise an
76:09 - exception let's create our own exception
76:11 - over here we'll say class too many
76:15 - students sohit from exception we'll say
76:19 - pass just here now back down here we
76:22 - will say
76:26 - otherwise
76:28 - raise too many
76:31 - students then we'll
76:34 - do remove students
76:37 - so
76:38 - remove
76:43 - student this will take in a name and
76:46 - we'll say for
76:48 - student in
76:50 - self. students
76:53 - then if student
76:56 - name is equal to
76:58 - name then self. students.
77:03 - remove and then student and finally
77:06 - we'll
77:07 - break and the last one we'll add is say
77:12 - change
77:14 - teacher and we'll say
77:18 - new
77:20 - teacher say self. teacher
77:23 - equals teacher or new
77:28 - teacher all right so that's our
77:30 - classroom the next thing that we'll add
77:33 - is a class that will just represent a
77:35 - person so nothing too fancy
77:41 - person and this will take
77:43 - in in
77:46 - name and self. name equals
77:51 - name and then class pass teacher We'll
77:55 - Inherit from
77:56 - person say pass and the same goes for
78:01 - the student so student inherit from
78:03 - person and we'll say pass as well all
78:07 - right so just to quickly run through
78:09 - what we have we have a an exception to
78:12 - many students uh which we use in the
78:14 - remove students so or in the ad students
78:18 - so if there're too many students if
78:19 - there are more than 10 students then the
78:23 - if it's the number of students is 10 or
78:25 - more or less then we'll add a student if
78:27 - it's more then we'll raise the exception
78:30 - then we have our
78:31 - initializer where we set our teacher our
78:33 - students and course title and we can
78:35 - also remove a student as well as change
78:38 - the teacher then we can then we have our
78:42 - person class and then that just takes in
78:44 - a name and our teacher and student
78:46 - inherits from that all right so let's
78:49 - see what our AI makes of this so I'm
78:51 - just going to copy all of of that and
78:54 - what I'm going to do is back I'm just
78:56 - going to close this and then back in
78:59 - here we'll say using p test
79:05 - and the functions that come from
79:10 - it such as
79:14 - fixtures
79:16 - parameterize about correctly I hope uh
79:21 - raises and
79:27 - Mark
79:29 - wherever
79:33 - necessary test the following code and
79:37 - theme it
79:40 - after Harry Potter because after all we
79:43 - are using the classroom teacher student
79:45 - so why not make it a bit more
79:48 - creative and colon and then paste in the
79:51 - code enter see what we get so using p
79:54 - test and the functions that come with it
79:56 - such as fixtures parameterize razes and
79:58 - Mark wherever necessary test the
80:00 - following code and theme it after Harry
80:02 - Potter maybe that could be worded a bit
80:04 - better but anyway so to test the given
80:06 - code and theme it after Harry Potter you
80:08 - can use P test along with fixtures
80:10 - parameterize raises and marks here's how
80:12 - you can write tests in for the classroom
80:14 - so let's see we have a fixture defined
80:18 - for us which is Harry Potter and it's
80:21 - setting Harry Potter as a t I don't know
80:23 - how to feel about that one
80:24 - maybe yeah that's that's weird because
80:27 - then hmani gr is a student and Ron weey
80:29 - is a student as well anyway maybe Harry
80:31 - Potter is doing well in class he's now
80:33 - been leveled up to being a teacher and
80:37 - then we have the Hogwarts classroom as a
80:39 - fixture has an empty list of students
80:42 - the teacher is Harry Potter then we have
80:45 - our students and the class is defense
80:47 - against the dark
80:48 - Hearts um so so far it's theming all
80:51 - right I think the only thing think it
80:52 - got it a bit wrong is Harry Potter being
80:54 - a teacher but anyway then test the cases
80:58 - for the classroom class so test
81:00 - classroom
81:02 - creation and teacher name Harry Potter
81:06 - this and then so what is this doing test
81:09 - cases or the classroom
81:11 - class oh okay it's just making sure that
81:13 - the fixture that we have is properly
81:16 - defined then test add student we're
81:19 - adding herione Granger to the class and
81:22 - Ron weas
81:23 - and the length of it is now two because
81:24 - originally we had zero okay that works
81:27 - test add too many students so now we're
81:29 - adding 10 students to this and then
81:33 - finally and that's just like random
81:35 - students
81:36 - so generic students set to the name
81:39 - student with P test raises too many
81:42 - students maybe I mean it is 10 students
81:45 - so I think parameterized would have been
81:46 - a bit too much here but the for Loop
81:48 - makes sense then we're adding a Min
81:50 - Granger and it should raise too many
81:51 - students because that is more more than
81:53 - 10 then test remove students so we're
81:56 - adding Hamman and Ron then we're saying
81:59 - remove hmani Granger the length of it
82:01 - should be one now and the name of the
82:05 - first student should be Ron Weasley then
82:07 - test change teacher we're changing the
82:09 - teacher to SRA Snape and if you're a big
82:12 - Harry Potter fan like me you'll know SRA
82:14 - Snape always wanted to teach defense
82:16 - against the dark carts so I guess his
82:17 - dream has been fulfilled in this test
82:20 - and then we're setting the name to
82:22 - server Snape all right it looks pretty
82:24 - good so let's go ahead and copy that and
82:27 - back in our codebase let's create a new
82:30 - file in
82:31 - test we'll say
82:34 - testore
82:38 - school and here let's just paste all of
82:40 - it in and let's just correct our import
82:44 - so we need Source do
82:47 - school and let's go ahead and run this
82:50 - so I'm just going to increase this this
82:53 - clear
82:54 - it keeps doing that clear it again all
82:57 - right let's run this test so Pi tests
83:00 - and then test and
83:02 - test School run and we get an error
83:06 - because this did not raise to many
83:08 - students let's see let's go back and ask
83:12 - it so we'll
83:16 - say this let's copy
83:20 - this this test is is
83:25 - failing see what we get I apologize for
83:28 - the oversight no worries all right
83:32 - change this all right it's telling us to
83:34 - change the code that we're testing
83:37 - itself so
83:40 - maybe ah okay the issue is this is this
83:44 - less than and equals to so let's go back
83:47 - and yeah maybe that's correct so if the
83:49 - length of students is less than 10 now
83:52 - let's run
83:53 - this then we get All Passes all right so
83:57 - maybe you kind of have to shake chat GPT
83:59 - up a bit but this is US changing the
84:01 - code itself which I'm not a huge fan of
84:03 - so if we set that to equal to if the
84:05 - length of the students is equal to 10
84:07 - then add a
84:09 - student and maybe actually this is
84:11 - actually our own error because we won
84:12 - only 10
84:14 - students and so yeah I guess it kind of
84:17 - made us rethink that a bit but it's been
84:21 - quite useful so that's the free version
84:22 - that's chat GPT 3.5 let's go ahead and
84:26 - try it out on chat GPT 4 so I've gone
84:29 - ahead and selected chat GPT 4 I'm using
84:32 - the default one and this is the version
84:36 - that comes with the paid one so it's
84:38 - only exclusive plus users I definitely
84:41 - recommend it it's definitely worth the
84:42 - $20 if you have it as the value that you
84:45 - get out of it is just fantastic so I'm
84:47 - going to go ahead and paste in the exact
84:49 - same query so using p test and the
84:53 - functions that come from it such as
84:54 - fixtures paramed razors and Mark
84:57 - wherever necessary test the following
84:59 - code and theme after Harry Potter let's
85:01 - see what we
85:02 - get all right
85:04 - so so far it's somewhat similar so we
85:08 - got this students and this fixture is
85:11 - returning a list of students so herione
85:14 - Harry Ron Draco Malfoy Luna love good
85:17 - nille long botom wow so it's really
85:19 - added like a whole load of students to
85:22 - this
85:24 - so it's really understood Harry Potter I
85:26 - guess and then the class is
85:28 - Transfiguration class and it's setting
85:30 - mcgonagal as and if I remember correctly
85:32 - mle is the teacher for
85:35 - Transfiguration and this is a fixture
85:38 - for
85:39 - that ADD test add student so adding
85:42 - jinny
85:43 - Weasley add student
85:47 - and a certain new student is in the list
85:50 - of students okay very nice and then we
85:54 - have the too many students
85:57 - Transfiguration class new student Dean
86:01 - Thomas and raises too many
86:04 - students Transfiguration class add new
86:08 - student and then prati
86:12 - Patel and then test remove student and
86:15 - he's using parameterize here so student
86:17 - name Ron weaseling Draco
86:19 - Malfoy that's pretty cool and then
86:22 - change teacher so it's changing alist
86:24 - Moody to
86:26 - that okay let's actually go ahead and
86:29 - copy this and let's actually just count
86:31 - how many tests do we have we have 1 2 3
86:35 - 4 and five if you count the other
86:38 - parameterize so let's say four in
86:42 - our test school we
86:46 - have one two three four five five tests
86:53 - okay so not a huge difference let's go
86:55 - ahead
86:56 - and take all of
86:58 - this delete it and paste in our new one
87:03 - uh we just need to correct this so we'll
87:04 - say source.
87:07 - School let's go ahead and run that let's
87:11 - clear this and run it and we get an
87:15 - error and that is because it's still we
87:17 - never changed
87:19 - our students or like when we we gave it
87:22 - the prompt we never gave it the updated
87:24 - one so what we'll do is let's just
87:27 - quickly fix that and we'll give AI the
87:30 - benefit of the
87:32 - doubt so maybe we get rid of a student
87:36 - let's get rid
87:39 - of Sheamus
87:43 - finan no hate just that he was at the
87:45 - end of the list so let's run that again
87:48 - and there we go we have five passes so
87:52 - in all honesty I would say that the chat
87:54 - GPT 41 performed only slightly better
87:57 - only because we have this parameterized
87:59 - that comes with it and the naming is a
88:02 - bit better as well like it's stayed in
88:04 - line with the theme but that doesn't
88:05 - really matter in terms of tests just to
88:07 - like spice it up creatively but that
88:10 - brings us end to this tutorial we've now
88:12 - seen how AI can also be useful when it
88:15 - comes to writing test I definitely
88:17 - recommend it as it allows you to kind of
88:19 - catch the areas that you tend to miss
88:21 - when writing test so definitely make use
88:23 - of it but otherwise subscribe to free
88:27 - code Camp you can also contact me which
88:30 - is the my channel is in the description
88:32 - along with my Twitter but otherwise stay
88:34 - healthy stay safe and see you soon

Cleaned transcript:

welcome to this comprehensive video course on py test the powerful testing framework for python throughout this course you'll gain a deep understanding of piie tests features best practices and the nuances of writing effective tests and at the end you'll learn how to use chat GPT to help you write tests quicker Farhan Ali created this course he is a freelance web developer who specializes in both design and full stack web development what is going on you guys and welcome to this video brought to you both by rhythmic and free code camp now in this video we're going to be covering testing in Python and this is aimed mainly at beginners to introduce you to this world but also for professionals as well who are also curious in using pest in their daytoday lives so first of all what is py test now py test is of course a testing framework it's in the name and also in the title of this video but what comes out of the box well first of all one of the great features of pie test is this thing called autodiscovery of tests now what does that mean well autodiscovery of tests all that means is that P test has the ability to pick up tests based on the way we name them so for example we can name a test test underscore and then the name of the file or we can have it as the name of the file and then underscore test and it will know that in this file there will be tests and usually IDE so for example if you're using py charm we'll also be able to detect this and you'll be able to just click play and run your test the other naming convention is also when we have test underscore and then the name of the function that that will then imply to the tpy tests that this is a test and you can also run those individually now another great thing around autodiscovery of tests is that there's no explicit registration needed so unlike some other Frameworks where you might need to build a list or a registry of tests manually P test automatically identifies which functions and methods are tests based on their names and it also simplifies test execution with autodiscovery you don't need to specify each test case to run manually you just run P test command and it will discover all the tests and you'll see that later on the next thing that comes with P test is Rich assertion introspection which sounds like a very fancy term but all that means is that with Rich assertion introspection that when a test fails in P test we get a really nice breakdown as to why that test failed so we get really nice clean reports that make it very easy for us the coder or the developer to understand so we know exactly where our test went wrong or not even just tests but what we're testing went wrong and another great thing that comes with P test is this support for parameterized and fixture based testing now what that allows us to do is it basically means that we can easily run a test function multiple times with different arguments ensuring that a broad test coverage with minimal code is that so we could test that a certain number will show up depending on the value and we can give it like a list of numbers and it will just run it for each one so we don't have to write each test manually which saves a lot of space and also provid us with a it makes it very readable for the uh developer now we've explained what pie test is the next is why do we need py test well first of all one of the great things with py test or the reason why you should be using p test is that it has a very simplified syntax pest allows you to write code or write test cases using plain assert statements which is the assert statement that comes with python without needing special assertion methods like assert equal or assert true which you may find in other uh python test testing libraries such as unit test or nose another one is of course Rich assertion introspection as mentioned earlier providing us with clear reports when our tests go wrong it also has a very powerful fixture system and what that means is pest fixture system is both flexible and Powerful allowing for setup and tear down operations so we can easily include operations to run before a test starts and also write in tear down code so when a test is finished we can clean it up we also have these scope or these fixtures can also have scope and auto use settings meaning we don't have to keep let's say we're testing an object we don't have to keep creating that object each time we can have a place where the object is created and we can use it for all of our tests this still might sound a bit confusing but we'll see it in the code and you'll get a better understanding of how powerful this fixture system actually is another great feature of py test or why you should use it is compatibility as py test can run tests for unit test or nose so other python testing libraries so you can kind of easily migrate over to py test if you're using another one and so it doesn't really get in the way if you want to try out a different testing Library P test will still work and that's why I want to focus on P test for beginners as once you understand the concepts of P test you can easily translate them over to different projects where you use different testing libraries and finally another reason why you should use py test is the extensibility now pest has a very rich plugin architecture with many third third party plugins available so for example if you have ajango application and you want to start testing it there is of course a pie test Django plugin that you can use there as well which is tailored towards Django and you can just plug that in and get rolling with it but otherwise that's the reasons why you should be using py test it's enough talk for me I mean it's one thing talking about the theory but now we need to see it in action so I've gone ahead and opened up a new project a new python project I am using virtual environment in this example however you don't necessarily need to as we're not building out a fully fledged project we're just using pie test the library P test so whether or not you want to use it it's a matter of preference at this point but I've opened up in py charm you can also use vs code however I do recommend py charm for testing especially testing and you can also use the community version I am here as well and that's because the the way tests are integrated into py charm it's very easy to get up and running with it however we're also going to use a command line for this as well so regardless if you're using VSS code to notepad it doesn't matter it still work so first of all we have our empty project we need to go ahead and make the necessary installations so the first one I'm going to to make and the only one I'm going to make is PIP install and then pie test hit enter and in this one we're using the version 742 which I think which I guess is the latest version right now it doesn't matter I guess if you're using a I guess modern version of it it shouldn't really matter because the principles of py test and the way you use P test doesn't necessarily change so we have this version pest 742 now we need something to actually test because we don't have we don't have any code so there's no point testing so let's go ahead and create some functions we create a new python package I'm just going to call this source and within that I'm going to create a new file and I'm going to call this my functions and we're not going to add anything special here first we're just going to demonstrate how to write test how to write the most basic P test you can so first of all in my test we're going to have a function and all that does is add two numbers so this may be a throwback for a few of you folks as I guess this is tends to be the example a lot of books or people tend to use so return number one plus number two all right and let's just do one more we'll say divide say number one and number two and return number one divided by number two so pretty standard stuff but in this case the reason why we have that here is because we want to test it now the reason why I'm getting these lines is because I need to reformat so you'll see me do that from time to time in the tutorial that's just to stop the IDE from complaining all right so we have our source next let's create a new directory inside of our main project so the root of it and we'll call this tests like so now if you remember from what I was saying earlier in the presentation that what pest does is it has a great ability to pick up or figure out where our tests are going to be located so because we're calling this test you'll have an idea that tests are actually in here and within that and also it's good for us because we also know that teser in here because it's labeled and named correctly let's go ahead and create a new file and we'll say testore mycore functions all right so what are we going to do here so we're going to test our functions add and divide so let's get started we'll say import and then py test and we'll say import Source my functions as mycore functions all right so let's test our first one we'll say testore add and if you see here on pie charm you may also get this you probably will actually this play button right next to it that's because it's detected that this here is a test so py charm already has this great integration of tests so you don't really have to use a terminal but you can pretty much click this button and then the test should run but we're going to use a terminal in this example so we'll say clear and we can actually run this now and you may have already guessed it that this test should pass so we'll say P test and then tests and then test my functions and there we go we have one passed and at 100% because we only have a one test function and that test function is actually not testing anything but this passes because there's no complaints coming from a failed assertion so let's go ahead and actually write something in there so we'll say result equals my functions add and we'll say one and four so now we have a result so we know from our own intuition that this is going to be five so we'll go ahead and say assert results equals five so if this assertion fails then this is going to this is going to break and our test will fail however if it passes then we get a pass let's go ahead and test that so Pi test and then test my or test my function and enter and there we go we have 100% pass no complaints but what if we were to change this value and say six let's run it again enter and there we go we get a fail so it's telling us that our test ad failed and down here it's saying that where it fails so what line exactly and it's saying that assert result equals 6 is failing because result is actually five and we're saying that we want it to be six so yeah it's telling us what value that should be we'll set that to five so if you're working on a real life application you may be expecting a certain value but you're not getting that value back at least then you will know okay maybe something's wrong so you may go back either to fix your tests or to fix the application itself so there we go with our test ad but let's just quickly go over what this assert statement actually is so in Python the assert statement is a debugging Aid that tests a condition as an aid to debugging if the condition is true the program continues executing as if nothing happened so in our case it continues and there's nothing to continue to continue so there's a pass however if the condition is false and assertion error exception is raised which interrupts the normal flow of the program so if we go back here and we look at our error that we got we get here that it's an assertion error so every time an assert an assertion fails we get this assertion error that's why we're getting that value but that quickly addresses how assert works so you can see here that if this is not basically rendering to be true then it's going to break now let's go ahead and write our divide test function so here we'll say what should we call it let's just say divide so test divide and it's always good to make sure that you're naming your tests properly so divide in this case it's very basic we're just testing that divide works so result equals my functions do divide and we'll say 10 by 5 and for you Geniuses out there you should know that 10 ID 5 is 2 so we'll say results equals two let's go ahead and run that so here just clear this and then Pi test tests and then test my functions enter and now we have two little dots here at 100% rate awesome so that covers our very basic P test examples where we're just throwing a simple Asser to make sure the value that we get back from functions are the values that we expect but what if we were to test this by saying number one divided by zero because we know you can't divide a number by zero so what would happen there well let's go and try it out and actually let's go ahead and try it out on a different function so we'll say test divide and divide SP properly divide by zero all right so here say result equals my functions do divide and then we'll say 10 and zero and then we'll say assert and let's right now just say assert true so if we say assert true then this will pass but let's see what we get when we test a test divide by zero so let's just go into just expand this and we'll say p test and tests test my functions and we get a fail even though we have this assert true so why is that the case so here in our divide our divide by zero um test here so it fails here on this my functions. divide and that's because if we scroll down a little bit we get this Zer division error so division by zero is the cause of this zero division error so what if we want to test that type what if we want to say okay if I divide a number by zero I'm expecting this zero division error so we can actually do that in P test and it's very simple what we can do is say something like the following so above this as we know it fails on the function call we can say with P test dot raises and then we can say zero division error all right and we don't need this result CU we don't care about it anymore we just want to call the function without storing it let's go ahead and try this out so back in the terminal let's go ahead clear all that and then P test run it again and there we go we get three passes because what we're saying here is that we're expecting a division error when we call this function so even though the function itself fails or there's an error in the function we can test to make sure that error is there and that can be very important let's say You're Building A an accounting tool and you're dividing by zero you want something there too but just to kind of drive this point further if we go back to our divide function we can say if number two equals zero then we can raise and let's change it to a value error let's do that now if we go back and we run this again and if I just clear all that run it we get an error because we're testing for a zero division error but in actuality we're getting a value error so all we have to do here is just change this to Value eror all right so that's our test pretty much summed up uh or our very basic test summed up excuse me but we're only testing for number numbers what about strings like how would that work well it work the exact same way and so what we can do is we can use the add function and we'll say test add strings we'll say results equals my functions. ADD and we'll pass in I like and we'll say burgers now we can say assert result equals I like burgers because it will concatenate it so if we run this now and we go into the terminal and we say p test test my functions we get an error and that's good because you can see here that there we made a mistake where we need to add an extra space here see there like I like bu Burgers like burgers one word and then the what we're expecting is I like burgers is three separate words so let's run that again and there we go we get four passes looking beautiful and that is what you want to aim for as a developer but that brings us to the end of the first part of this tutorial which is looking at how to write very basic tests and now let's go over and start looking at how we can write classbased tests because right now all of these are function based tests so for our class based test the first thing that we need to do is write some classes that we can actually test so write some extra code CU right now all we have are two very basic functions which you can throw into a class base test however I want to kind of you know spice it up a bit and add some more a bit more complex code so inside source I'm going to go ahead and create a new file and I'm going to go ahead and call this shapes So within shapes what we're going to have is a class called shape and we're just going to use this for inheritance so shape and this is going to have a function that we'll override called area and we'll have another one and that will calculate the perimeter of a shape let's go ahead and add that in now let's go ahead and create a class which is going to represent a Circle and I don't know what is wrong with my spelling and this is going to inherit from shape the init so init this will take in a radius and we'll say self. radius equals radius then let's do the area and in order to calculate the area of a circle if you remember back Frome Elementary is we need the or we need to do pi r 2 so math or return math do pi multiplied by radius and squared so double asteris and a two and then for the perimeter we'll say return two multiplied by math P pi and then by the radius and it'd be a bit embarrassing for me to say that I actually have to look this up quickly before just to make sure I'm right as uh yeah sometimes I forget these basic things but anyway so now we have our class our class uh circle now let's go ahead and test it using class based tests so what we need to do is create a new file and we'll call this test Circle and it's a good practice to just name your class or your your test classes or test files based on what you're testing so in this case we're testing the circle so everything related to the circle will be in this file and here we'll say import P test and we need to import Source do shapes as shapes all right so to define a classbased test we'll say class and then test and circle and let's just put pass there now and this should pick it up anytime soon if it doesn't let's go ahead and just add test one and we'll just say assert true and again if you're using py charm you should see these play buttons show up now if you're not if you're using VSS code you may have an extension or there may be an extension out there which I'm sure there is where you can have the exact same effect but I'm more familiar with running or writing most my python code on pycharm but anyway now let's go ahead and if we just run this if you remember from the last example with my functions when we had a test I didn't do much it would still run in our case it should pass anyway because we're asserting that it is true so we'll say high test and then test and test Circle and there we go it's working let's actually just jump into test because we're going to be running everything through there all right so one of the cool things about tests or classbased tests is that it comes with two functions that can be quite useful the first one is the setup method now the setup method is there or is defined to run setup code before each test method so for all the test classes or test functions or methods that we write inside our classbased test the setup method will run at the beginning of each test and then like as a partner to it or to complement it there is the tear down method and the tear down method is there or defined to run tear down code after each test me method so after each one runs there is a tear down method so let's go ahead and just show that off we'll say set upcore method and we'll pass in this argument method now now the method argument just represents the test method that we're about to run so we can just say here print and we'll have a setting up and then method and then we'll have another one and we'll say tear downcore method and throw method in there print and setting or in this case tearing down and then the method all right so if we test this let's go ahead and use the P test command and say test Circle hit enter so we get a test passed but if we look at what the report generated we're not getting anything else so we're not getting our prints and we're not getting our tear down and the reason why we're not doing that is because when we call or when we use the P test command in our terminal we need to add A s so we can say p test and then s and now we get our print statement so setting up and then the method name so bound method test Circle test one and so it's just printing out the name of this test function that we have and then it's called tear down so if we did another test let's just copy test one and then here we'll say test two and if we were to go back to the terminal run it all again now we have four so we have setting up test one tearing down test one setting up test two tearing down test two now you're saying to me okay this is all well and good but this is useless I mean we're just printing stuff out well one thing that can be quite useful is that in the setup method we can have some something like say self do Circle and we'll say shapes do Circle give it a radius say 10 now for every method that we have this a circle object is going to be created so now we can access it in test one and instead of calling it test one let's say test radius so test radius and then here we can say CT and then self. Circle radius equals and we will need the math function so let's just import math and we know that the radius has to be math and we need pi multiplied by self do Circle dot uh radius and this here should be area and we should name this part here to area I don't know why I put it as radius but area and then this should be multiplied and then squared now let's go back and inside the terminal we'll say high test and then test Circle and there we go we get our test and you can of course add the S as well um so like this but that is how the setup method can be useful now on our tear down we can also do something like delete self. Circle and in this case it's not necessary because it will be doing that anyway but for more complicated um more complicated programs that you're testing this tear down method can be quite useful along with the setup method however that's our class base test sorted out let's just clean it let's just finish it off really let's add a new test and say test perimeter because repetition with this helps and then we'll say result equals self. Circle do perimeter and then expected value equals 2 time math Pi Time by S do Circle radius and then we can say assert and result equals expected again spelling error expect am I just going crazy here oh yeah thought it was a spelling error we need to change that too sorry long day and there we go so that's our test parameter let's go ahead and test that out and we're all green cool so that's our class based tests like basically the overview of how class based test work how you can set it up and how you can use it with P test the next cool thing I want to show you are pie test fixtures so I'm back inside of the shapes file and what I want to do is go ahead and create another shape which we'll use to test well first of all we'll write our tests on and we'll then use fixtures to improve on those tests so down below I'm going to go ahead and create a new class this is going to represent a rectangle inherit from shape and we need to initialize it this will take in a length and a width self do length equals length and self. width equals width then let's calculate the area return self dot length by self. width and perimeter which we can do as return self dot length multiplied two and add that to self. width multipli 2 all right so we have now our rectangle now we need to go ahead and test it so let's create a new test file inside of the test directory we'll call this testore rectangle all right so let's just go ahead and use our functional tests and write the very basic test that we need so we know we need to test first let's just make the import import P test import Source do shapes as shapes then test area and here we'll say rectangle equals shapes Dot rectangle and we'll pass in 10 and 20 then we'll say assert rectangle do area equals or and rectangle or we'll say 10 multiplied by 20 all right new line reformat okay so we have our test area there now we can go ahead and run this just like we did before so we'll say test or P test and test rectangle and we have one pass all right now let's go ahead and create another test and we'll say test perimeter and here again we need a rectangle so we'll take this here paste it in and say assert rectangle. perimeter equals and that is 10 * 2 + 20 * by two now if we were to run this go back here clear and test it again we have two passes all right so nothing too special you're like okay we've seen this before what's so amazing about it well one thing we can do or one thing that you may have noticed is that our rectangle is being used and declared twice so we have two rectangles here both with a length of 10 and a width of 20 the values that don't really matter but the point is that we're repeating ourselves that we're needing a rectangle in both cases and we're creating a rectangle in both cases now if we were to use our where is it test Circle so if we were to use class based method we could or class base test we could of course have initialized it in the setup but what about with functional with functional we can use something called py test fixtures so we can do py test do fixture and then say how we can call it my rectangle you can name it whatever you want and all this will do is return a rectangle like so so now what we can do is we can literally plug this into each of our tests here so we can say my rectangle here and my rectangle here and we can remove this here this rectangle equals move it there as well and replace rectangle with my rectangle or whatever you named it so here and here go back up go back to the terminal let's clear that out High test and then test rectangle and there we go back to where we were but now we are using our py test fixture so just to kind of hone this in let's create another fixture and let's use that as well as our my rectangle so first of all let's just go back into shapes and I'm going to go ahead and create a new method which or not really create but at least overrides with the equals and here I'm going to say if is instance so if not is instance what we want to do here is say that if it's not a rectangle then we want to return false otherwise then we're going to check to see whether a rectangle is equal to to another so we'll say other and then rectangle and return false and then here we'll say return self do width equals other width and self do length equals other dot length so it's just a override for the equal so we can compare two different rectangles so now if we go back into test rectangle let's create a new fixture and we'll say fixture call this weird rectangle name it whatever you want I guess in a professional setting you'd want to name it something sensible but here we'll say shapes do rectangle and we'll say five and six all right now we can use this a weird rectangle and down below we'll say test not equal and we'll pass in my rectangle and a weird rectangle and we'll assert that my rectangle does not equal weird rectangle and we can go back to our terminal and just clear all that and say p test and test rectangle and there we go we have three passes but the important part here is that we're using our fixtures now one thing that is also important is that we can use something called con test so we can make our fixtures Global Within our tests so let's say for example you need the rectangle inside of test Circle for some reason um and you don't want to keep on declaring more um objects so you want it in a global play so you can access it easily now to do that is fairly simple all you need to do is inside of tests we have to create a file and we have to call this file conf test.py and in here this is is where we can Define our rectangles again so I'm going to go here and I'm just going to take this so my rectangle and weird rectangle I'm going to save that and go into com test paste it in of course we also need to import P test and shapes so import P test and import Source shapes as shapes there we go so now if we go back to test rectangle you can see that it's not complaining we can get rid of this and let's go ahead and run rectangle again so we'll say Pi test and test rectangle and there we go we have three clear tests and we have our my rectangle in use and our weird rectangle use which we' stored in a global place which is our com test we can also access in other files as well so inside let's say our test Circle we can do let's just come up with a silly example so test not same area rectangle and here we can pass in my rectangle like so and we'll say Circle equals self. Circle oh we already have the circle because we defined it up here so we can say assert does not equal or um self. Circle do area does not equal and then my rectangle do area all right now if we were to go into our terminal once again let's just clear all that and say p test and testore circle there we go everything is green and we're making use of our rectangle that we defined in com test accessible or we're using it in our test Circle file so this can be pretty useful especially if you've got like a really large code base where you have a lot of shared objects then the com test can of course be very helpful there so of course I wouldn't over abuse it like I wouldn't store everything in contest uh but this is just an example of how you can now the next thing that we're going to look at is something called pie test marking and parameterizing so the pie test Mark mechanism provides a way to add metadata to your test so you can think of it as tagging your test with labels that can influence how the test runs or is orted and the purpose of it is that you can label or tag your tests to categorize them for instance you might want to label some tests as being slow or some tests as be as to skip and um yeah which means that you can conditionally execute your tests so let's go ahead and do that so back in my functions we're just going to use add and divide as our examples because the purpose of Mark is just to demonstrate how they work not so much writing the test themselves so let's go ahead and if we I'm in my test we need my functions we need to go to test my functions so in here let's go ahead and let's look at the slow tag so let's say let's just import time at the top of this say import time go back down and we'll say test very slow um we will have let's take this here result actually let's just take all of this paste that in here and then above that what we'll do is just do time do sleep and we'll say 10 seconds so actually 10 seconds might be a bit too long for this video so let's do five so if we run this if we go into the terminal and say just clear that P test and then test my functions and it's still running cuz it's waiting for the last one and there we go it took 5 Seconds however this is a slow test and it didn't do anything it didn't alter the way our test work so everything passed and it managed to get to the end of this but it can be helpful for us to know that this test is going to be a slow one so we can say something like that so that's just telling us is ADD adding some metadata to state that this is a slow test so if you want to see the slow test or just or test the slow test we can say Pi test and then M and then slow and it will only run the test my functions one because that's the only one that has a mark of slow and we're getting a warning Mark slow is this a typo I guess in this case no um but anyway it passs anyway this is just a warning it wasn't a failure and let's go back so that's the slow one can be quite useful let's say if you're I don't know if you're calculating something that takes a while to calculate you might want to add that in the next one is the skip uh test so let's go ahead and say at P test Mark and then Skip and we can add a reason to it as well just for ourselves can be quite useful and here we'll say this feature is currently broken and here we'll say test uh ad and let's just assume the ad is broken in this case we'll go ahead and assert that my functions do add one and two equals 3 and give that some extra room now if we go to our terminal clear all this and we run it again so we'll say Pi test test my functions enter you can see here that there's one that has an S there as well that means skip so we're skipping one test the other one is a slow one but here we are like that's a way to skip your test so you just add that in there another one is the X fail so we can go here and say p test and then Mark and then X fail and we can add a reason to this as well we can say uh we know we cannot divide by zero and we'll go ahead and do exactly that so test divides zero um say broken let's assume V my Z is a broken function all right so um let's go ahead and say assert um well let's just make the cor because we know it fails so we'll say my functions divide three four and zero let's go ahead and run this now so clear that and then P test tests my functions give that a second and there we go so if you go back here we have the s that represents our skipped one then we have these Green Dots which represent our past and then we have this x which means that we know this is going to fail uh and you can see here this kind of this breakdown four P one skipped one failed One X failed so it didn't fail in the literal sense that tests themselves fail um it failed given that we marked it as something that can fail as well so this is how Mark or marking can work and it can be again quite beneficial to just add some extra information around your tests there may be some tests that you know will break and you don't want to fix those tests or there's certain reasons why you don't want to fix them you can of course use this xfil then there is the skip which just means that yeah you want to skip this test um and maybe you'll come back to it later on uh but you want the test in there just as a reminder and then it'll also be useful for other Engineers that you're working with so they know oh wait why is it skipped there's probably a reason for it and they'll know the reason so the mark pest Mark can be a very useful feature mainly for us as engineers and also for your testing as well depending on how you want to see it but anyway that's covered that or that covers P test marking now we'll look at parameterize so so for the example with parameterizing what we're going to do first is back inside our shape so we're going to add our last shape and that's going to be a square so we can actually inherit from our rectangle and the way we can do that is by saying class and then Square inherit from rectangle and here we'll say in it and it will just give it a side length and then here we can say super and we'll pass in the side length for the initializer and side length for the so for the width and the length all right so that's our Square sorted out so let's go ahead and create a new file inside of tests and we'll call this one test Square all right so for this let's go ahead and make the necessary Imports so P test and import Source do my functions actually shapes as shapes all right so what is this whole thing around parameterizing so imagine you have a light bulb and you want to test it with different brands of batteries to ensure that it works with all of them so instead of writing each uh separate test for each battery uh it would be more efficient to actually just write one test and run it for each battery brand now of course you can try this out with a full loop however full Loops can get a bit messy and it just kind of ruins readability after a while so instead what the team behind P test have done is created this parameterized concept so the way we can use it is let's say we want to calculate the area of a square but we want to give it multiple values so let's just first Define find it so test multiple Square areas and it will take in a side length and we'll Define that in a second as a parameter and a expected area and the way this will work is what we'll say is assert and then shapes do shape and pass in the side length do area equals the expect area now you're wondering okay where are these values coming from they're not coming from the com test because we haven't defined it there well the way we can do that is here we can say at pest. Mark in but this time parameterize and here we'll Define the first parameter which is side length and then comma and then expected area and then we need to give values for both side length and the expected area so to do that we'll say it's going to be a list the first value of this topple so we'll have a list of topples and inside the first topple the first element is going to refer to the side length and then the second one is going to refer to the expected area and let's create a few of them cuz right now that's just one and then we'll do four and 16 and we'll do say nine and 81 let me just format this to stop it from complaining all right so what do we have so we have this parameterized Mark that we've placed on top of this test multiple Square areas then we have side length and expected area now side length refers to the first elements of each of the topples that are in this list so 5 4 and 9 the expected area however is referring to the second element of each of these uh the second element of each topple so 25 16 and 81 now we can actually just go ahead and run this so let's go ahead and clear this out and we'll say Pi test and then test square and we get an error because shape takes no this meant to be square it's good job that we're testing to see this error and then run it again and there we go and you can see here that we get three dots and that's because we have three different topples inside of our list now you can of course create another one so we say random here and if you want to use that you have to add another value to this as well like so so that's how parameterizing works now let's go ahead and do a bit of practice let's use it again on the perimeter so we'll say here we'll first add add our decorator Mark and then parameterize and for the perimeter we'll have a side length and comma and we'll call this one expected perimeter and then what we can say in this is the topple is going to be first one let's say three and the perimeter for that is going to be 12 then we'll have another one we say four and the perimet that is going to be 16 and then we'll say do another final one five and the perimeter of that is 20 and then we'll say Define test multiple perimeters and then we'll say the side length and expected perimeter and we'll do the exact same thing so ass set and then shapes do shape and throw in side length do area equals the expected perimeter and this should not be area this instead should be the perimeter and there we go let's go back into our terminal and if we were to run this now we get a a bunch of M errors because we have fail test multiple Square areas in parameterize the number of names expected ah it's this one here we need to get rid of this random run that again shape again so another one so this has to be square don't know why I miss that but this should be square go again and there we go now we have six tests but we've only by looking at it at face value just written two tests so parameterized can be very useful if you want to try the same test with different values to see what output you get rather than writing like a for Loop where it gets all messy so yeah definitely use parameterize when you need to it can be very powerful and very useful for developers who are reading it later on so again yeah this covers the parameterize parameterizing with py test now let's move on to the next topic so for the next topic we're going to look at something a bit more advanced and that's called mocking now mocking is a powerful testing technique which is used to isolate the system that we're testing and replace the external dependencies with controlled implementations called mocks so when might you use mocking now imagine you're writing a or you're writing code that fetches data from an external API using let's say the request library and you when writing this test you don't want to actually call the API itself because it might be slow it might cost money or affect rate limits and depending on the api's actual data as that is subject to change it might cause your test to fail so we don't want to depend on the API itself let's say we just know what the API is going to respond and we want to test that the same may also go for for testing a database so you might have a test that is testing let's say getting a user from a database and you don't want to depend on the database itself as you know the connection might be disrupted and therefore your test might fail so that's where mocking can come into play now I'm talking a lot so let's go ahead and actually code an example up and see how useful mocking can be so first in the source directory I'm going to go ahead and create a new file I'm just going to going to call this service and within that what we'll do is create a dummy uh database where we'll get a user so we'll say our database equals and in there we'll say one that will represent the ID we'll have Alice in there two we'll have Bob in there and three let's say we'll have have Charlie in there all right now what we'll do is create a function which will get user from DB and it will take in a user ID and it will return our database. getet user ID so pretty much working a bit like if you're using an omm it might be similar but in this case we're just mocking it with a database or actually we're not mocking it in the sense of testing this is let's just say this is actually our database and we'll mock it in a second let me just format this and then let's create a new file inside of test and we'll call this one test service and enter all right so how do we actually mock this so first of all let's make the necessary Imports let's import py test we need to import Source do service let's say service and let's leave it at that so there is another import that we'll need and actually let's just do that now so let's go ahead and say import right there import and unit test and then mock as a mock all right so remember right at the beginning of this video we were talking about how you can use other testing libraries within P test without any issues so we're doing that exactly here and the reason why you don't need to install this is because unit test comes with python I think from 3.3 version 3.3 and onwards you'll have unit test with every python installation that you make so you don't have to make a installation here and mock is inside of there and we'll use that for this all right so let's go ahead and create our test so test get user from DB and let's just put pass there the first thing that we need to do is add a decorator to it and that will come from Mock and we'll say patch and then we need the route or the path to our basically the path to our function so we'll say Source do service. getet user from DB and so that's going into our source and then our service file and then our function which we called get user from DB then we need to map that to an argument here so a bit like how we did with fixtures so what we'll say or with parameterizing or parameterize as we looked at earlier we can say mock get user from DB and this doesn't have to match this um so this mock part this the naming convention there's nothing strict here I just named it that for readability but you can call this whatever you want so it doesn't matter then we'll say Mock and then get user from DB and we'll say that the return value is going to be mocked Alice and then we'll say username equals and we'll say service dot get user from DB we'll put in the ID one and then we can say assert and then username equals mocked Alice so let's just quickly go over what we've just done once again now we're using the patch function from mock to replace get user from DB so we're saying use this function that we've defined in our source service and replace that with mock get user from DB and then here we're saying that the return value from this function call so whenever we call it in this test so in this test get user from DB we want the result to be mocked Alle and then here that's where we're fetching from our database that's when we're actually making use of our get user from DB we call it we pass it in an ID and then we're saying assert username equals mocked Alice because we know as Engineers so in a real life setting you will know that when you call this it will return a string and so if anything changes you will have to adapt this test of course but that's how this is working here all right so so that sums up the database test let's actually go ahead and run it so let's go into terminal and we'll say p test and then test service enter and we get a pass so there we go now if we were just to replace this with say that and then we run this or maybe if I use a terminal instead so P test we're getting an error because a moed Alice the return value that we're getting from this so get from get user from DB does not equal ASDF ASDF so there you go so in this case we're not testing whether or not the database works or not we're just testing to make sure that the response we're getting is what we expect is what we would expect so that's where mock mocking can be quite useful but this is a very simple example of mocking let's actually use it with an API so the first thing that we need to do is back inside the root of our project let's pip install requests so we need this request Library I just installed it with Pip instore request just here now back inside service we're going to go ahead and make an API call with that so we'll say import requests and what we're going to do is make a call to this website called Json placeholder and you can go to Json placeholder do type I code.com and here it just gives like free fake API for testing and prototyping which can be quite useful for our case for example and we're going to use the users endpoint so this one here you can use whatever endpoint you want just going to go with the users so when we fetch or we do a get request we're going to get this here so back in our code let's go ahead and create a function which will get the users so down here we'll say get users then here we'll say response equals and we need to we've imported it yep requests.get and we need to paste in the URL so this URL here copy that paste it in with double quotes and then if if the response. status code equals 200 meaning that the request was successful we'll return response. Json and then here we'll say raise requests. HTTP error so if there is an issue if it's not 200 then we want to raise a HTTP error all right now let's test this so like I said when we started talking about our uh mocking is that you will use mocking for something like testing or fetching from an API but you don't want to test the API itself the API is someone else's responsibility we're just testing in our case that we get the response that we want uh or we're getting the expected data that we want so remember actually calling an API in a test might not be the most economical thing to do uh it might actually not be the most efficient thing to do as well because apis can be slow so let's go ahead and use or test our function so the first thing that we need to do is of course map it with the patch so we'll say this mock do patch and we want to mock the request.get and I'll explain it further in a second so requests so make sure it's s doget and then we'll say testore getet users and Mock undor getet and then we'll say pass so let's just quickly explain this so we're testing our get users but we don't want to test necessarily the function or we do want to test a function but we want to mock the request.get so whenever we call request.get within this which we will because we'll be testing the function then we want to mock we want want to get a certain response so let's go ahead and say mock response equals mock mock like that and then we'll say mock response. status code and don't worry if you're confused because I found this very confusing when I first learned it and then mock response. Json and then return value equals and we know that the data looks like this but because we already know that we can shorten it so we'll say something like ID usually you would use like an exact example of it but for the purpose of this it doesn't matter because we already have an idea name and then John do and then mock getet do return value equals mock response and then data equals API or service. get users and then we'll say SE data equals ID one and name John do okay so to explain it what we're doing here is where so let's start from line 18 so we're calling this get users and within get users we're using request.get and in our test this is what we're mocking so we're saying whenever this is going to be called within our test we want it to come back with a response and the response that we want is in the form of this so This Json return value ID one name joh do because in our service response as this Json that we're returning so if the status code is 200 then where response Json is going to be returned and we want to say when this is returned and it's successful then it's going to look like this dictionary here and then we also want the status code so we're sending that to 200 and the reason why we're not just saying mock response Json equals dictionary is because the difference between status code and Json with our request.get response is that status code is actually a property and Json is actually a function or a method call so that's why we have to add this do return value so let's go ahead and test this now so clear and then Pi test test now we're outside so tests and then test service enter and we have two successes that means our data is this the value that we're mocking to json. return value and we can also say that or in our case it doesn't really matter we can't test this because our service is returning the response. Json anyway but to drive this a mocking Point further if we go back to our service we can see that if the status code is not A200 then we should get a HTTP error raised so we can go ahead and use our mocking power to make sure that that is the case so we'll say mock do patch and then requests.get and we'll do here test test get users error and then mock unor getet and within here what we'll do is say mock response so we'll take these two and paste that in and set the status code to 400 and then we'll say mock uh Moore getet dot return value equals mock response and then we'll say with it test. raises requests HTTP error and API or service. get users it should now work so let's go ahead and run it and once we run it we get a pass because we're saying that the status code is a 400 so with with that in mind we should get a raise a HTTP error now if we were to change that to a 200 and run it we get an error because it did not raise even though we have a 200 we were expecting a raise but instead we got a test fail so that should give you a good idea or hopefully gives you a good idea as to how mocking works with python testing now it might be a bit of a tricky thing to grasp at first it is a bit of a weird concept it was definitely for me however one rule of thumb that I would apply is when you want to use mocking or if you're kind in a bit of a dilemma if you want to use mocking or not I tend to use it when my tests are dependent on external programs that can give or cannot guarantee the same result each time for example if you're testing an API you cannot always guarantee that if you give it certain inputs you will get the exact same output each time because you know an API can of course crash it may have some downtime or whatever or may may take to some time to to actually give a response depending on the day or situation so you can't really guarantee that and your tests need to guarantee that you always have this result when you make a certain call to a function or a program so keep that one in mind and definitely play around with mocks as they can be very powerful when used correctly now let's move on to our final topic where we'll look at how we can use artificial intelligence to help us write our tests so in order to test AI when it comes to writing our test to see how well it can write python tests head over to open.com and there you'll have access to chat GPT by clicking on try try chat GPT now I already have an account I have a pro account which costs around I think $20 a month and it's definitely well worth it especially if you're a developer as the value that you get out of it is substantial but we'll also try it out on the free version so the 3.5 version and on the more uptodate version chat GPT 4 so I've already signed in and this is my account so this is my prompt I can click on either chat GPT 3.5 or GPT 4 with the 3.5 model this is available on the three version so if you're not paying for it you will have access to this and let's go ahead and see how useful this will be when it comes to writing our tests but before we do any of that what we need to do is go ahead and write some more code so in our source I'm just going to go ahead and close all of this and what we'll do is create a new program or a new class inside of this we'll call this school dopy and now this will represent or this will hold a classroom and that classroom will have a teacher and a number of students so let's write it up let's go ahead and say class classroom and say in it can initialize it with a teacher and students and we say course title and then we'll say self. teer so all the standard stuff or initializing a class self do students equals students and self. course title equals course title all right then we'll have a function where we can add a student and we'll pass in a student to this and we'll say if the length we don't need the parentheses so if length of self. students is less less than or equal to say 10 then we will add a student so students. append and student otherwise we want to raise an exception let's create our own exception over here we'll say class too many students sohit from exception we'll say pass just here now back down here we will say otherwise raise too many students then we'll do remove students so remove student this will take in a name and we'll say for student in self. students then if student name is equal to name then self. students. remove and then student and finally we'll break and the last one we'll add is say change teacher and we'll say new teacher say self. teacher equals teacher or new teacher all right so that's our classroom the next thing that we'll add is a class that will just represent a person so nothing too fancy person and this will take in in name and self. name equals name and then class pass teacher We'll Inherit from person say pass and the same goes for the student so student inherit from person and we'll say pass as well all right so just to quickly run through what we have we have a an exception to many students uh which we use in the remove students so or in the ad students so if there're too many students if there are more than 10 students then the if it's the number of students is 10 or more or less then we'll add a student if it's more then we'll raise the exception then we have our initializer where we set our teacher our students and course title and we can also remove a student as well as change the teacher then we can then we have our person class and then that just takes in a name and our teacher and student inherits from that all right so let's see what our AI makes of this so I'm just going to copy all of of that and what I'm going to do is back I'm just going to close this and then back in here we'll say using p test and the functions that come from it such as fixtures parameterize about correctly I hope uh raises and Mark wherever necessary test the following code and theme it after Harry Potter because after all we are using the classroom teacher student so why not make it a bit more creative and colon and then paste in the code enter see what we get so using p test and the functions that come with it such as fixtures parameterize razes and Mark wherever necessary test the following code and theme it after Harry Potter maybe that could be worded a bit better but anyway so to test the given code and theme it after Harry Potter you can use P test along with fixtures parameterize raises and marks here's how you can write tests in for the classroom so let's see we have a fixture defined for us which is Harry Potter and it's setting Harry Potter as a t I don't know how to feel about that one maybe yeah that's that's weird because then hmani gr is a student and Ron weey is a student as well anyway maybe Harry Potter is doing well in class he's now been leveled up to being a teacher and then we have the Hogwarts classroom as a fixture has an empty list of students the teacher is Harry Potter then we have our students and the class is defense against the dark Hearts um so so far it's theming all right I think the only thing think it got it a bit wrong is Harry Potter being a teacher but anyway then test the cases for the classroom class so test classroom creation and teacher name Harry Potter this and then so what is this doing test cases or the classroom class oh okay it's just making sure that the fixture that we have is properly defined then test add student we're adding herione Granger to the class and Ron weas and the length of it is now two because originally we had zero okay that works test add too many students so now we're adding 10 students to this and then finally and that's just like random students so generic students set to the name student with P test raises too many students maybe I mean it is 10 students so I think parameterized would have been a bit too much here but the for Loop makes sense then we're adding a Min Granger and it should raise too many students because that is more more than 10 then test remove students so we're adding Hamman and Ron then we're saying remove hmani Granger the length of it should be one now and the name of the first student should be Ron Weasley then test change teacher we're changing the teacher to SRA Snape and if you're a big Harry Potter fan like me you'll know SRA Snape always wanted to teach defense against the dark carts so I guess his dream has been fulfilled in this test and then we're setting the name to server Snape all right it looks pretty good so let's go ahead and copy that and back in our codebase let's create a new file in test we'll say testore school and here let's just paste all of it in and let's just correct our import so we need Source do school and let's go ahead and run this so I'm just going to increase this this clear it keeps doing that clear it again all right let's run this test so Pi tests and then test and test School run and we get an error because this did not raise to many students let's see let's go back and ask it so we'll say this let's copy this this test is is failing see what we get I apologize for the oversight no worries all right change this all right it's telling us to change the code that we're testing itself so maybe ah okay the issue is this is this less than and equals to so let's go back and yeah maybe that's correct so if the length of students is less than 10 now let's run this then we get All Passes all right so maybe you kind of have to shake chat GPT up a bit but this is US changing the code itself which I'm not a huge fan of so if we set that to equal to if the length of the students is equal to 10 then add a student and maybe actually this is actually our own error because we won only 10 students and so yeah I guess it kind of made us rethink that a bit but it's been quite useful so that's the free version that's chat GPT 3.5 let's go ahead and try it out on chat GPT 4 so I've gone ahead and selected chat GPT 4 I'm using the default one and this is the version that comes with the paid one so it's only exclusive plus users I definitely recommend it it's definitely worth the $20 if you have it as the value that you get out of it is just fantastic so I'm going to go ahead and paste in the exact same query so using p test and the functions that come from it such as fixtures paramed razors and Mark wherever necessary test the following code and theme after Harry Potter let's see what we get all right so so far it's somewhat similar so we got this students and this fixture is returning a list of students so herione Harry Ron Draco Malfoy Luna love good nille long botom wow so it's really added like a whole load of students to this so it's really understood Harry Potter I guess and then the class is Transfiguration class and it's setting mcgonagal as and if I remember correctly mle is the teacher for Transfiguration and this is a fixture for that ADD test add student so adding jinny Weasley add student and a certain new student is in the list of students okay very nice and then we have the too many students Transfiguration class new student Dean Thomas and raises too many students Transfiguration class add new student and then prati Patel and then test remove student and he's using parameterize here so student name Ron weaseling Draco Malfoy that's pretty cool and then change teacher so it's changing alist Moody to that okay let's actually go ahead and copy this and let's actually just count how many tests do we have we have 1 2 3 4 and five if you count the other parameterize so let's say four in our test school we have one two three four five five tests okay so not a huge difference let's go ahead and take all of this delete it and paste in our new one uh we just need to correct this so we'll say source. School let's go ahead and run that let's clear this and run it and we get an error and that is because it's still we never changed our students or like when we we gave it the prompt we never gave it the updated one so what we'll do is let's just quickly fix that and we'll give AI the benefit of the doubt so maybe we get rid of a student let's get rid of Sheamus finan no hate just that he was at the end of the list so let's run that again and there we go we have five passes so in all honesty I would say that the chat GPT 41 performed only slightly better only because we have this parameterized that comes with it and the naming is a bit better as well like it's stayed in line with the theme but that doesn't really matter in terms of tests just to like spice it up creatively but that brings us end to this tutorial we've now seen how AI can also be useful when it comes to writing test I definitely recommend it as it allows you to kind of catch the areas that you tend to miss when writing test so definitely make use of it but otherwise subscribe to free code Camp you can also contact me which is the my channel is in the description along with my Twitter but otherwise stay healthy stay safe and see you soon
