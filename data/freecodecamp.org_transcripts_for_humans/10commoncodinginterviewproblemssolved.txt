With timestamps:

00:00 - In this course you'll learn how to solve 
10 Very popular coding interview problems,  
00:05 - and you'll learn the theory behind the solutions, 
so you'll be better equipped to solve other types  
00:10 - of problems as well. We'll come to the 10 
popular coding interview problems course 10  
00:16 - well chosen problems that cover different 
algorithms and data structures topics  
00:20 - to increase your knowledge 
and prepare for interviews.  
00:23 - Please try to solve before watching the solution 
prepare yourself and see you in the first lecture  
00:36 - Welcome to this video, where we will solve 
the first problem of this course valid anagram  
00:40 - acquired easy problem compared to Knucks wants we 
are given two strings s one and S two and we are  
00:47 - asked to check if their anagrams. Two strings are 
anagrams if they're made of the same characters  
00:54 - with the same frequency just in a different order. 
For example, with a string standard and garden,  
00:59 - we take one of them will rearrange its 
characters and we get the other one.  
01:05 - How are we going to solve this problem? We know 
the two strings are anagrams if they have the  
01:10 - same characters with the same frequency. So what 
we can do is to calculate the frequency of each  
01:15 - character and as one, calculate the frequency of 
each character in s two and compare the results.  
01:22 - But what structure do we use to do so we can use 
an array where each cell represents the number  
01:27 - of frequencies, they all start at zero, then for 
each character in the string will increment the  
01:32 - corresponding cell. This solution is suitable 
when the alphabet is small, while the number of  
01:38 - possible characters is not big. For example, 
if the strings can only be made of lowercase  
01:44 - alphabetical letters, would need an array of 26 
elements, it's fine. But it's not necessarily  
01:50 - the case. They can contain all the characters. 
And we have 1000s and 1000s of existing possible  
01:57 - characters, the array would take a lot of 
time and space to create it and traverse it.  
02:02 - The best structure for our problem is the hash 
table structure that maps unique keys to values.  
02:08 - In our case, the key will be the coke 
to other values number of occurrences.  
02:14 - For example, if you have nameless and salesman 
whose name was we get this hash table.  
02:18 - And the salesman we get this one. Do they have the 
same keys with the same values so they're equal?  
02:25 - It means that nameless and salesmen are anagrams.  
02:32 - Encode who first showed that both strings 
have the same length, because if they're not,  
02:36 - it's impossible for them to be anagrams. Then who 
grid our two hash tables, and we start to our C  
02:44 - for each character and as one if the key is 
already existing. And for one who does increment  
02:49 - else, we created a new set its value to one than 
for us to same logic, but with freq. Two. And  
02:57 - now that we filled them with each other, they 
have the same values. For each cane frog one,  
03:02 - if it doesn't exist in frog two, or for 
quality isn't able to frog to off key,  
03:06 - return false. It means that either the character 
of us one doesn't exist in our stew, or they don't  
03:11 - appear the same number of times after the loop, 
if we didn't find any difference, we return true.  
03:21 - And in Python, we don't ever need to 
write all this because we have a class  
03:24 - named counter in collections module that builds 
the table of occurrences just by passing the  
03:29 - string as an argument. And we can compare 
dictionaries with the equality operator.  
03:34 - So in reality, who does return count 
off as one equal to count off as two.  
03:41 - For the time complexity, in the worst case, as 
well as to have the same length. Let's name it  
03:47 - as we're traversing N characters at most three 
times, and Sujan. Inserting in a hash table  
03:53 - costs are one in average, got off, amp was off and 
was off and we'll give some of amp on complexity.  
04:00 - And for the space complexity, we have an hour 
for each table because they can contain up to n  
04:05 - keys each we got an often space complexity. 
We still have another solution to discuss.  
04:13 - You have to know the two anagrams how 
the same lexicographically sorted string,  
04:18 - for example, with nameless and salesman. If we 
sold nameless, we get a ELMN s s. I will salesman  
04:26 - same thing. So in the second solution, who 
do salt posturings and compare the results  
04:32 - in code, after the equal condition, 
returns sorted as one is equal to sorted  
04:39 - as two. But sorting a string of characters 
because of n log n time we're doing it twice  
04:45 - was after comparing. We've got an off n log n 
time complexity. And for the space complexity,  
04:51 - we have often for the sorted result twice, 
we'll get an off air space complexity.  
04:58 - Who's the end of this video? whistle 
the valid underground problem,  
05:02 - I hope that you understood the ball 
solutions and seen the next one  
05:13 - Welcome back to the course in this lecture 
rule. So the first and last position problem,  
05:18 - you are given a sorted array of integers are an 
integer target. And we're asked to find the index  
05:24 - of the first and last position of target and our 
if Target can't be found in our return minus one  
05:30 - minus one. For example, if our is 245-555-5799, 
and target is five, the author's would be to six  
05:39 - because the first position of target 
is to, and his last position is six.  
05:45 - First of all, because the array is sorted, 
all the elements with the same value will  
05:49 - be ages into each other. For example, here all 
positions of the value five are consecutive.  
05:55 - It means that the first possible solution is to 
start traversing the array from the beginning  
06:00 - for the first position of target, and keep 
walking until finding the last position.  
06:05 - With our example, we have two four, 
then five who found the first position  
06:10 - we can walk in, we have 5555. This one is the 
last one, we found the N position, we turn them  
06:19 - in code, we start traversing indexes of our and if 
our phi is equal to target, it means that we found  
06:25 - the start position. Now we keep walking while the 
next element exists and is equal to target y plus  
06:32 - one is smaller than length of our and our five 
plus one is equal to target increment i. After  
06:39 - the while loop. INR represents the position of 
the last occurrence. This is why we return start i  
06:46 - and if the fall ends without 
having returned the result,  
06:49 - it means that we didn't find target in 
our at all return minus one minus one.  
06:56 - Know that it's possible to have sought position 
equal to and position it happens when there  
07:01 - is only one occurrence of targeting our for 
the time complexity on target exists, which  
07:07 - covers the part befores first position, third 
sequence of occurrences and where it doesn't,  
07:13 - which covers a whole array. In both cases, which 
covers almost add elements, where n is the number  
07:18 - of elements of our we've got a time complexity 
of add a cost and space complexity because  
07:25 - we're just using n variables. This solution uses 
linear sir, to give an off on time complexity.  
07:35 - Both the resorted so we can think of using binary 
search. Let's try to use binary search to find the  
07:41 - start position. With binary search, you can find 
the position of an element in a sorted array.  
07:47 - But here, we're not searching for any position 
of target, we're searching for the first one.  
07:54 - R is the first position of target 
if r is equal to target, obviously,  
07:58 - but also r of i minus one has to be smaller 
than target smaller because the array is sorted.  
08:05 - So we will use binary search normally, but 
to add a second condition before returning.  
08:12 - Let's try it with our example. Left and right 
solid first and last element of our as usual.  
08:18 - Man, his left password divided by two, we get four 
here is true that our four is equal to target,  
08:24 - but it's not enough our four minus one is 
not smaller than target. So med is not the  
08:29 - starting position of target. But should you 
go to the left part or to the right part now,  
08:35 - our have made is not created on target. So the 
first position can only be in the left part  
08:41 - we continue made is now zero plus 
three divided by two we get one,  
08:46 - our phone is smaller than target. So the starting 
position can only be in the right part we continue  
08:52 - made is now two plus three divided by two which is 
to have meat is equal to target and our male minus  
08:58 - one is smaller than target. So meta represents 
the first position of target, we return it.  
09:05 - In code, we're going to first have an early 
exit condition for the case where the first  
09:09 - element is equal to target with DACA know that 
zero is the starting position returned zero.  
09:15 - By the way, in solutions based on binary 
search, put as much early exit conditions  
09:20 - as possible to handle edge cases 
and avoid out of bounds problems.  
09:25 - After it we initialize left and right 
at zero and minus one respectively.  
09:30 - Zero and r minus one are the indexes of the 
first and last element of R. Now while of is  
09:35 - smaller than or equal to right, we calculate mid 
index is left plus rho divided by two. Afterward,  
09:42 - we have three cases the case where both conditions 
are respected. where alpha is equal to target on  
09:48 - our beta minus one is smaller than target. It 
means that made is a sort of position we turn it  
09:55 - second case are made is smaller than 
target. It means that we're still before  
09:59 - the starting point. position. This is why we 
take left and mid plus one to start again in  
10:03 - the right part. Else, it means that we exceeded 
the consecutive sequence, or we're excited but  
10:10 - not other beginning. So start can only be in the 
left part, we take rato mid minus one of the wall  
10:19 - didn't return the result is means the target 
doesn't have an existing our return minus one.  
10:26 - Now we found this thought in the experts, 
we still need to find the end index,  
10:31 - we can think of just walking starting from 
start until we find the last position of target.  
10:36 - But it would ruin everything we 
did, because in the worst case,  
10:39 - we need to traverse the whole array, which 
results in an old Anton complexity same as  
10:44 - the first solution you guys did to find the 
end index, we will also use binary search.  
10:51 - But the condition is a bit different from the 
first time when searching for the start position  
10:56 - are of men how to be equal to target and our male 
minus one smaller than target. And for the end  
11:02 - position, our med has to be equal to target and 
our mid plus one has to be greeted on target.  
11:09 - Next element has to be greater because it 
would mean that from the right, we're not  
11:12 - in consecutive Target Elements anymore, so the 
actual position is the last position of target.  
11:20 - In code, we just change a few things, the only 
exit condition occurs now when the last element  
11:25 - is equal to talk, it means that the last position 
of target is in the last index of our n minus one  
11:31 - without a return. Then in the three cases, the 
cases where we will turn mid is when our made is  
11:37 - equal to target, and our met plus one is greater 
than target. For the two remaining ones, he won  
11:44 - our main is greater than target, then we exceeded 
the consecutive sequence, we'll go to the left  
11:49 - part, right becomes mere minus one else, it means 
that either will be for the consecutive sequence  
11:55 - or incited but not at the end, so and can only 
be in the right part, left becomes mid plus one.  
12:03 - Now we have our fine salt function, 
we have our Find and function,  
12:07 - we can move to the main solution function. First 
of all, we have some early exit conditions,  
12:14 - who can identify at least three cases 
where we can't find target role.  
12:18 - When the array has no elements, one target is 
smaller than the first element. And when target  
12:22 - is greater than the last element in the last two 
ones. Because the array is sorted, who can deduce  
12:28 - the target is not equal to all other elements. If 
at least one of these conditions is true, without  
12:39 - the return minus one minus one health who co 
found sought to give the stock position we  
12:40 - call font and to find the end position and wait 
on start. And if Target doesn't exist in our  
12:47 - sorted annual have returned minus one 
bath, we still got the expected result.  
12:54 - For the time complexity, we're using binary 
search twice. And binary search has an  
12:59 - awful lot and time complexity because 
we keep dividing the input size by two,  
13:03 - two times of work and gives us 
all of log n time complexity.  
13:08 - Add for the space complexity, you'll get all 
one because we're just using eight variables.  
13:15 - Before ending this lecture, I want to tell you 
that if you're not comfortable with binary search,  
13:20 - you should really work on it because 
it's a fundamental algorithm technique  
13:23 - that appears in many problems on this one, find 
peek first bad version, and many other ones.  
13:32 - Lose Hello this lecture, I hope that you 
understood the solutions and seen the next one.  
13:44 - Welcome back to the course in this lecture, we 
will solve the cliff largest element problem,  
13:49 - you are given an array of integers and 
an integer k. And we're asked to find  
13:53 - the K eighth largest element. For example, 
if you have are equal to four to 9756713  
14:00 - and k equal to four, the output would be 
six because the largest element is nine,  
14:05 - the second largest is seven, the third 
largest is seven and the fourth largest is six  
14:13 - Firstpost possible solution that we may think of 
is to remove the maximum element k minus one times  
14:19 - because after doing so, the next maximum 
represents the K eighth largest element.  
14:24 - For example with our array K is four. So 
we remove the maximum element three times  
14:30 - first iteration Max is mine we remove it, second 
iteration Max is seven we move it third iteration  
14:38 - Max is seven we remove it now that we finished 
the three iterations the maximum in the remaining  
14:44 - elements is the fifth largest element of the 
original array, it six here who returned it.  
14:51 - In code, we have a follow various repeated k 
minus one times one remove the maximum element  
14:57 - after the loop, return max of all But for the 
time complexity suited for the maximum cost of n,  
15:04 - where n is the number of elements and removing 
it from the array cost, and in the worst case,  
15:09 - because we may need to shift all the n minus 
one elements, and our loop is repeated k minus  
15:15 - one times we'll have k minus one times to add, 
plus add for finding the final largest element.  
15:22 - In total, we have k minus one times two n 
plus n, which is two times k times n minus n,  
15:28 - which gives us off k times our time complexity, 
where n is the number of elements of our  
15:35 - own, although in reality during the 
iterations, and will decrease because  
15:38 - we have less and less elements, but we get the 
sample complexity. And for the space complexity,  
15:44 - we're not using input size related variables, 
we have a constant space complexity.  
15:49 - This solution is a bit slow. Let's move to the 
next one. The idea of the second solution is to  
15:55 - start by sorting the array because by doing so, we 
know that the largest element is other last cell,  
16:00 - the second largest element just before it, the 
third largest just before it, and so on with our  
16:06 - array was sorted, and k is four. So return 
the fourth element starting from the end,  
16:12 - in a gentle way, we sold our and we turn our 
n minus k, and minus k represents the index  
16:18 - of the key elements starting from the end. For 
the time complexity, we have both analog and for  
16:24 - sorting the array and all one for accessing, 
we've got an O of n log n time complexity.  
16:30 - And for the space complexity, it depends on 
the space complexity or the sorting function.  
16:36 - This solution is way faster than the first 
one except in some cases, but we still have  
16:40 - an all the solution to discover. In the first 
solution we didn't have to solve to it is good,  
16:47 - but searching for the maximum cost at each 
iteration, which slows down the process.  
16:52 - What if instead of getting the maximum cost log 
out only yours is possible by using a priority  
16:58 - queue. A priority queue is a queue where the next 
element to be popped is not the first one that  
17:03 - entered with the one with the highest priority. 
And it's usually implemented with a heap. If you  
17:08 - don't know about heaps, and priority queues, 
you should really watch my YouTube video on  
17:12 - the subject, you will find the link below or you 
can just search for inside code heaps on YouTube.  
17:20 - And after building our priority queue, popping 
the next element because of work out holy,  
17:25 - so we just have to pay the cost of 
building the priority queue, which is add.  
17:29 - For example, with our array, this is what our 
heap would look like, you can see that the element  
17:34 - at the top is the greatest one who extracted 
and it costs of work and to rearrange notes.  
17:41 - second iteration will extract the root cause 
of work and to rearrange to maintain the order.  
17:47 - third iteration, same thing. Now that we do the k 
minus one iterations, the next extracted node is  
17:53 - the eighth largest element, we'll turn it here 
it's six. In Python, we have the hip Q module  
18:01 - with a problem is that it's implemented with a 
min heap, not a max heap. So the top will find  
18:06 - the smallest element not the greatest to counter 
that will just multiply values by minus one to  
18:11 - reverse the order. So we start by replacing our by 
minus ln for each element in our after doing so,  
18:18 - we heapify our to make it respect to heap 
property. And now we really do start extracting,  
18:24 - we extract from it k minus one times. After 
the loop, we extract the last time and return  
18:30 - the result multiplied by minus one, obviously, 
to get the original number though was in our,  
18:36 - for the time complexity, who have earned to build 
a new array with reverse values, and to heapify  
18:41 - it, go check the video to know why. And then 
we have k minus one iterations, each iteration  
18:47 - because of work and to extract after the loop, 
we have all worked out to extract one more time.  
18:54 - In total, we have two n plus k minus one times 
log n plus log n, which is two n plus k log n,  
19:01 - which gives a time complexity of of amples k 
log n, which is a bit better than the one of  
19:05 - the previous solution, because k can't exceed 
add. For this solution, stop giving interesting  
19:12 - time performance difference only when n is 
huge and case small. Because when k is close  
19:17 - to an off campus, k log n is close to O of n log 
n, the time complexity of the previous solution.  
19:17 - Pause When k is close to zero, O of n plus k log 
n is close to O of n for the space complexity  
19:31 - who have unfold the priority queue who got an 
offer and space complexity. We reached the end  
19:38 - of this video I hope that you understood the 
three solutions and see what the next one will  
19:49 - come back to the course in this lecture we will 
solve the symmetric tree problem. We have a binary  
19:55 - tree and we want to see if it's symmetric. 
In other words, if it's a mirror of it Self.  
20:01 - For example, this tree is symmetric, because 
if we take his left part, reverse it, who that  
20:06 - is right part. And vice versa, if we take its 
right part, we reverse it who got his left part.  
20:15 - But this one is not symmetric. For example, if 
we reverse its left part, we don't get the right  
20:19 - part. Okay how to solve this problem? To check 
if a tree is symmetric, what we really need  
20:27 - to check is that left and right sub trees are 
symmetric to each other. Who will focus on that  
20:34 - you need to know that for tree problems, 
the solution is usually don't coercively  
20:39 - we process the root, then we call the function 
on both sub trees and we combine the results.  
20:44 - For example, to get the sum of elements of a 
binary tree, we have the value of the root,  
20:49 - then recursively call the function on both 
sub trees to get the sum of their elements.  
20:53 - After doing so, we return root value plus some of 
left subtree plus some of right subtree. This way  
21:00 - of traversing is called depth first search, and 
it's how we solved the majority of tree problems.  
21:06 - Let's go back to our problem, we have two 
trees, route one and route two and want  
21:11 - to check if they're symmetric to each other. 
First case, both trees are empty. In that case,  
21:16 - we return true because they're still symmetric 
to each other, there is nothing that breaks the  
21:20 - condition. Second case, won't we exist, 
but the other one doesn't. In that case,  
21:26 - without let it use it and not symmetric 
because the node of the tree that exists  
21:31 - doesn't even exist in the other 
one, it's empty, we return false.  
21:37 - Third case, both trees exist, but the 
roots don't have the same value. Here also,  
21:41 - they're not symmetric, because in symmetric 
trees, the roots must have the same value,  
21:46 - because when we reverse the tree, the root 
position doesn't change. And last case, both trees  
21:52 - exist, and they have the same root value. In this 
case, we still can say that they're symmetric,  
21:58 - because Okay, the roots have the same value. 
But we still need to check their sub trees,  
22:03 - having the same root value is not 
enough to serve their symmetric.  
22:08 - And if we take two symmetric trees, we can 
notice that they have the same root value,  
22:12 - though the left subtree of the first one is 
symmetric to the right subtree of the second one,  
22:17 - and on the right subtree of the first one is 
symmetric to the left subtree of the second one.  
22:23 - We verified that root values are equal. So 
we need to try the remaining two conditions.  
22:29 - And how are we going to do so we're going to do 
so recursively, because if you think about it,  
22:34 - we're building a function that checks 
if two binary trees are symmetric,  
22:37 - which is exactly what we need. This 
is why we'll use the same function.  
22:42 - It may sound hard to understand, 
but this is what recursion about  
22:46 - a function calling itself. If you're not familiar 
with recursion, you should really have a look at  
22:51 - it before continuing this course because 
we will use it again in a further problem.  
22:56 - If you want to learn recursion, you come 
to the course I made on the subject.  
23:00 - It's a complete and well appreciated course 
that will let you be comfortable with recursion.  
23:06 - Let's go back to our problem. We saw that we use 
the function we're making, we saw that we use the  
23:12 - function we're making. We call it on route one 
dot left and route two dot right we're called  
23:16 - on route 1.1 and route dot left and we tell you 
at both calls return true, it means that both  
23:22 - conditions are verified, the left subtree of route 
one is symmetric to the right subtree of route  
23:27 - to other the rights of drove route one is 
symmetric to the left of Jove route two.  
23:32 - Let's quickly see an example. We want 
to check if this tree is symmetric,  
23:37 - so we check if it's sub trees 
are symmetric to each other.  
23:42 - They have the same root value, so we check the 
left subtree of root one with white socks off root  
23:44 - two, same root value, who took the left subtree 
of root one with right subtree of root two, same  
23:52 - root value, we check left and right, same root 
value. Other children are both normal they will  
23:58 - turn true. Same with value and symmetric children. 
All conditions are respected, it returns true.  
24:05 - Now right up to a fruit one with lots of to 
fruit two, they have the same root value.  
24:10 - Their children on both know both calls 
return true. All conditions are respected.  
24:15 - The caller turns true. Back to here, all 
conditions are respected. The Colita is true.  
24:22 - Now REITs offshore foot one with Latakia for 
two, they don't have the same root value,  
24:27 - the call returns false. Not all conditions 
are respected. The call returns false.  
24:33 - Who don't ever need to check the second call 
because we already have a non respected condition.  
24:38 - The call returns false. The initial call 
return false so our tree is not symmetric.  
24:45 - In code, let's first make our our symmetric 
function. It takes two trees as parameter  
24:50 - route one and route two. First case 
both don't exist without Q two and true.  
24:56 - Second case, one of them exists but the other 
one doesn't. Third case, they have a different  
25:01 - root value. In both of these cases, the 
trees are not symmetric, so return false  
25:07 - will write, if root one is non is not equal 
to root two is non, or root one dot val is  
25:09 - not equal to root two, that wall will 
return false. And now in the last case,  
25:17 - both trees exist and have the same root 
value, we still need to Chuck's up trees,  
25:22 - which are that would wander I'd love to see much 
to root to the droid. And that root wonder tried  
25:23 - is symmetric to root to the left, we do so by 
recursively, calling the function twice. Once with  
25:32 - root one dot left and root two dot right and once 
with root one or twice and route two dot left,  
25:38 - both of them need to return true. So we turn 
the results combined with the Add operator.  
25:44 - And now when our main solution function is 
symmetric, we first check that the input  
25:49 - tree exists because if it doesn't, we cannot 
return true, an empty tree is symmetric. Else,  
25:55 - whichever is sub trees are symmetric to 
each other with the function who made Now  
25:59 - we return our symmetric Rudolph left and rudos. 
Right. That's it. For the time complexity,  
26:06 - we're just performing a depth first 
search traversal of the input tree  
26:09 - and the first cause of anti m 
where n is the number of nodes.  
26:14 - And for the space complexity, a symmetric tree 
has to be balanced. And the call stack size  
26:19 - needed by a recursive function that traverses a 
balanced binary tree is an awful look at who got  
26:24 - an off walk and space complexity. That's it for 
this lecture, we've seen an interesting problem  
26:30 - on trees. I hope that you have been able to 
understand the solution seen with the next lecture  
26:42 - Welcome back to the course in this lecture, we 
will solve the Generate parenthesis problem,  
26:47 - a problem that we will solve using backtracking. 
By the way, in this course, I try to include  
26:53 - problems on different pattern spire research 
hash table backtracking, depth, first search,  
26:59 - and so on. But one problem and each is not enough. 
This is why you need to study more problems.  
27:05 - For that, I suggest you to have a look at my 
50 popular coding interview problems course.  
27:10 - It contains 50 Problems different from the ones 
in this course, about many data structures and  
27:15 - algorithmic techniques, you can have a look at 
the curriculum and reviews on the main page.  
27:22 - Anyway, let's go back to our problem. We 
are given an integer n and we're asked  
27:26 - to generate all valid combinations of N pairs of 
parenthesis. For example, with an equal to three,  
27:32 - here are all the valid combinations. First of 
all, what does a vowel combination mean and how  
27:38 - to check if a combination is valid. A combination 
that contains one type of paranthesis is valid.  
27:44 - If every opening parenthesis has its closing 
parenthesis, and it doesn't have a closing  
27:49 - parenthesis without having an end used opening 
parenthesis before it. Let's see some examples.  
27:57 - This combination is invalid because these opening 
parenthesis don't have closing parenthesis  
28:02 - the syntax is invalid. Second example 
this combination is invalid because we  
28:07 - have a closing parenthesis without an 
end use opening parenthesis before it.  
28:12 - Last example, this one is valid because each 
opening parenthesis has its closing one,  
28:16 - and there is no closing parenthesis 
without an unused opening one before it.  
28:22 - Now how to check if a combination is valid. To do 
so we can maintain a stack where we push one we  
28:28 - find an opening parenthesis and we pop one and 
find the closing one. The condition is that we  
28:33 - don't try to pop from the stack when it's empty, 
or the stack has to be empty after we finish  
28:38 - traversing the combination. Trying to perform 
the stock one is empty means that we have a  
28:43 - closing parenthesis without an available opening 
one before it all ones what we found before have  
28:48 - been popped by all the closing parentheses. And 
the second condition is that the stock must be  
28:53 - empty at the end. Because still having elements 
in the stack after traversing means that we have  
28:58 - opening parenthesis that didn't gather closing one 
yet. In both cases, the combination is not valid.  
29:07 - And because we have only one 
type of parenthesis around once,  
29:11 - we don't ever need the stock, who can do is use 
a variable div that represents the difference  
29:15 - between the number of opening parenthesis and the 
number of closing once. It has to be zero the end  
29:22 - and if it becomes negative during 
the process, then it's not valid.  
29:27 - Okay, but what's the relation with backtracking? 
In this problem, we're not asked to check if a  
29:31 - combination is valid. We're asked to generate 
all valid combinations of N pairs. And we use  
29:38 - backtracking because at each step of building the 
combination, we have two possibilities, adding an  
29:43 - opening parenthesis and adding a closing one. And 
because we want all combinations, we try them both  
29:50 - because we get new ones want to add an opening 
one, and all the ones want to add a closing one.  
29:56 - Also in backtracking. We can have a 
condition where we backtrack With continuing,  
30:01 - it's one we know that the actual branch won't 
lead us to a valid solution. In our case,  
30:06 - it's one death becomes negative, it means that 
the combination we built until now isn't valid,  
30:12 - it's useless to continue building it, we know 
that it won't give us a valid combination. Anyway.  
30:18 - Let's see an example. With n equal to 
three, we'll get this recursion tree.  
30:24 - If you're wondering why our sauce at six is 
because the n given us input represents the  
30:29 - number of pairs. And in n pairs, we have two 
advantages. So we multiply by two because we're  
30:34 - adding one parenthesis by level one, we go to 
the left to add an opening one and increment div.  
30:40 - And when we go to the right to add 
a closing one, and decrement, if  
30:46 - we can notice that we have branches 
that have been stopped earlier,  
30:49 - those are branches were diff becomes 
negative. As soon as they've becomes negative,  
30:53 - we stop also Evon with branches that created the 
combination of N pairs, we don't take all of them,  
31:00 - we take only those who are divisible to zero, 
remember the validity condition. So at the end,  
31:06 - here are the combinations that get 
added to our combinations array.  
31:13 - Encode who stopped by creating a recursive 
function rack that will fill the combinations  
31:17 - array, it takes us parameters and the 
number of remaining parentheses to add,  
31:22 - def the difference between opening and closing 
brackets COMM The actual combination that we're  
31:27 - building, and comps theory of combinations, the 
one that we're searching for in our problem.  
31:36 - The first base case is one difficult negative, hit 
it with Dr. Batra Kodaka return to go back to the  
31:42 - previous call. The second base case is one we've 
been able to add all the parenthesis we've been  
31:48 - able to build a combination. But in this case, 
we don't automatically add it to our comps array,  
31:54 - we first check if d f is equal to zero. Remember 
the condition. So if f is zero, we draw the  
32:00 - parenthesis of our combination to form a string 
and we add it to our valid combinations array.  
32:06 - Else, we have the recursive case, we 
said that we have two possibilities,  
32:11 - adding an opening parenthesis and adding a closing 
one. Therefore, who will have two recursive calls.  
32:17 - For the first one, we add an opening parenthesis 
to our combination, then when we call and becomes  
32:23 - n minus one because we have one less parent is 
to add and this becomes the plus one because  
32:29 - remember that to add one one will add an opening 
parenthesis. After the call, we move the opening  
32:36 - one we added to put a closing one. After doing 
so we call the function again. But this time  
32:42 - diff becomes diff minus one. Remember that we 
subtract one when we add a closing parenthesis.  
32:49 - And after the call, we remove the parenthesis 
we added to backtrack to the previous call.  
32:54 - And we made our function. By the way, we can ever 
optimize a little bit by dotclear. Returning if  
33:01 - div is greater than add because if is the case, 
it means that we don't have enough remaining  
33:06 - parenthesis to close all our opening parenthesis. 
div is greater than n. So we just return.  
33:13 - If you're confused about what's happening 
here, have a look again other recursion tree.  
33:18 - And most importantly, you should learn 
more about recursion and backtracking.  
33:22 - The method we're using here to 
generate all possible combinations,  
33:25 - it's common to a lot of problems, you 
should really be comfortable with it.  
33:31 - Now in the main solution function, we'll first 
create an array comps where we will put our valid  
33:35 - combinations and we call our QC function to fill 
it. But the tricky part here is that we pass two  
33:42 - times n as an argument not add, because the n 
given as input represents the number of pairs,  
33:47 - nor the number of parenthesis and a pair is 
made of two parentheses. So we pass two times,  
33:54 - our combinations will be of length two 
times. After filling comps, we just return it  
34:01 - for the time complexity. In the worst case, what 
add a zero, we have a cost of an to join the  
34:06 - parenthesis we write T of zero is equal to add 
n in the recursive case, and again moving from  
34:13 - the combination cost of one, but we have two 
calls where the input size gets reduced by one  
34:18 - and is becoming added minus one in total t of n 
is equal to two times u of r minus one plus one.  
34:27 - Now we keep replacing t of n is equal to two times 
t of n minus one plus one. So T of N minus one is  
34:30 - equal to two times t of n minus two plus one we 
replace or simplify and we got four times two  
34:40 - and minus two plus three. We replace again, t of 
n minus two is two times two of Armani three plus  
34:46 - one will replace will simplify and we get 
eight times T of animal is three plus seven.  
34:54 - This recurrence relation is a common one we can 
already notice the drill form. It's t of n is it  
35:00 - To power k times t of n minus k plus two power k 
minus one, we have the value of T of zero, so we  
35:07 - need to find the value of K to go to T of zero 
and minus k equal to zero. So k is equal to n,  
35:14 - where plus k by n, who got t of n is equal to two 
power n times T of zero plus to power n minus one.  
35:21 - We know that T of zero is earned workplace, 
we got t of n is equal to two power n times  
35:27 - n plus two power n minus one would give us 
an O of n times two power n time complexity.  
35:33 - Know that here and represents the length 
of the combination, which is two times  
35:37 - the number of pairs given us input. Also, 
n times two power n is not the exact power,  
35:43 - the number of operations will be less than that 
do two branches where we backtrack earlier,  
35:48 - O of n times two power n would be the exact 
bound if we had no condition on our combinations.  
35:55 - If you don't know the technique are used to find 
the time complexity over this recursive function.  
35:59 - It's called the substitution method, it's an 
important technique to know you should learn  
36:03 - about it. And for the space complexity, we have 
n plus one for the cost like size, the length  
36:10 - of the longest branch in the recursion tree. But 
we also need to count the required space to store  
36:15 - the combinations. The length of a combination 
is at and it has two possible characters. So  
36:22 - we have two power and possible combinations. 
And the length of each one of them is n. So we  
36:27 - need n times two power n space to solve them. We 
got off on times to power and space complexity.  
36:34 - But not all of them are valid, we will 
need way less than n times to power n,  
36:39 - n times two power n is just an upper bound. And 
we all t the required space for combinations  
36:45 - is n times the number of elements after 
filling the comms array. We reached the end  
36:51 - of this lecture, I hope that you understood this 
backtracking solution and see you in the next one.  
37:04 - Welcome back to the course in this lecture 
rules or the gas station problem are given  
37:09 - a circle a list of gas stations where we can 
go from Station II to the station i plus one,  
37:14 - and the last one goes back to the first one.  
37:18 - And we are asked to find the index of the station 
from where we start to be able to traverse all the  
37:22 - stations and go back to the initial one without 
running out of gas. Know that we can only move  
37:30 - forward the gas tanks thought empty gas of i 
represents the amount of gas at the station i  
37:35 - cost of iron presents the cost to go from the 
station out to the next one, the answer is  
37:40 - guaranteed to be unique. And if the station we're 
searching for doesn't exist return minus one we  
37:44 - did use or there will be at most one station 
for more we can traverse and be able to go back.  
37:52 - For example, if we have these 10 stations, the 
output is eight because when we start from station  
37:57 - eight, we can go back to it without running out 
of gas. We start with no gas, as mentioned the  
38:02 - the problem, we add for gas of station eight and 
we pay one to move to the next station, who add  
38:04 - five gas of station line and we pay two to move 
to the next station, we add one and pay five who  
38:11 - add five and pay two, or three and pay two, or 
three and pay eight, we add five and pay two,  
38:15 - or three and pay for we add one and pay two, or 
three and pay five, and we've been able to go back  
38:26 - to station eight, you could see that the amount of 
gas never became negative. Which is not the case  
38:32 - for Office stations, for example with station one 
who add five and pay two, or three and pay two,  
38:37 - or three. And if you pay the eight to move to the 
next station, the amount of gas becomes negative,  
38:44 - which means that we can't continue, the 
station we started from is not the right one.  
38:51 - Let's solve this problem. A brute force solution 
of a darkly comes in our mind is to simply  
38:56 - simulate what happens with every station and we 
find one that respects the condition who turn its  
39:02 - index. Let's try it with our example. With the 
first one, we add one with a five and the cost  
39:09 - becomes negative Dr eliminated. Next one, we add 
five and P two we have three and PE two, we have  
39:14 - three and PE eight air the amount of remaining 
gas became negative not this one. Next one, three  
39:22 - and PE two we have three NP eight and remaining 
became negative. Next one, we have three NP eight  
39:29 - remaining became negative. Next one, we add five 
and pay two or three and pay for we add one and  
39:35 - pay two or three and pay five and remaining became 
negative not this one. Next one, we add three and  
39:42 - pay for negative. Next one, we add one and pay 
to negative next one who has three and pay five  
39:48 - negative next one who have plus four minus one 
plus five minus two plus one minus five plus five  
39:56 - minus two plus three minus two plus three minus 
eight. was four minus two, plus three minus four,  
40:02 - plus one minus two plus three minus five. 
And we've been able to go back to the station  
40:07 - from where we started without the alternate 
because we know that the answer is unique.  
40:14 - In code, we create a function that takes 
us parameters, the array gas theory, cost,  
40:19 - and index of the station form where we thought 
the goal of this function is to tell us if we can  
40:25 - finish the cycle by starting from the stations 
thought, we first need a variable remaining  
40:31 - that source the remaining amount of gas, we also 
need the variable to store our actual position.  
40:36 - Our initial position is the station FOMO, 
we thought so initialize our add start.  
40:43 - And we also need a boolean variable started 
to know who started walking yet or not,  
40:48 - we need this variable in our loop condition. We 
need to keep looping until we go back to start,  
40:54 - we write why isn't equal to start or not 
started. Here not started is important,  
41:00 - because if we don't use it, we won't even enter 
the loop. Remember that I initialize a stock.  
41:06 - So I installed our equal, we want them to 
be equal. But after traversing the cycle,  
41:11 - not now this is why we need the variable started 
to know if we're in the case, where is equal to  
41:16 - start, because we didn't start yet. Or because 
we traverse a cycle, and I went back to start.  
41:23 - Let's continue inside the loop we saw started to 
true because we started then we update remaining.  
41:29 - We saw that on the station i We are the amount of 
gas in it, and we pay the cost to move to the next  
41:35 - one. So we add gas of our answer drug costs of I. 
After doing that, if we mainly becomes negative,  
41:42 - it means that we couldn't go back to salt, we 
don't have enough gas, we return false, else,  
41:48 - we move to the next station. The next station is 
usually i plus one. But we need to add modules  
41:54 - the number of stations to handle the case were of 
the last station i becomes i plus one add modules  
42:00 - and it goes back to zero, we right i becomes 
a plus one modules the number of stations.  
42:08 - And if we finish the loop, it means that we've 
been able to go back to start return true.  
42:14 - Now in our main solution function, we just 
tried the function we made on each station  
42:19 - as we did in the example. And we turn the actual 
station as soon as the function returns true.  
42:25 - And if the function fails with all stations 
will to n minus one for the time complexity,  
42:31 - because the answer is unique. A 
possible worst case is this one,  
42:35 - because by starting from station zero, which 
covers n stations before getting a negative amount  
42:40 - from station one, which covers n minus one from 
station two, which covers n minus two, and so on,  
42:47 - we get the sum n plus n minus one plus n minus 
two and so on until one. After simplifying,  
42:54 - we found that it's an O of n squared, we'll 
get an O of n squared time complexity,  
42:59 - or the constant space complexity because 
we're not using input size related variables  
43:06 - of n squared is low. For this problem, we're 
getting off n squared because for each station,  
43:10 - we're traversing again, almost all the stations, 
let's see how to optimize it. The main thing that  
43:16 - you need to understand for the second solution 
is that if we start from the station or the index  
43:21 - thought and reach a negative amount of the station 
I then all stations between Staten Island clauses  
43:27 - are not valid. We don't need to try them with 
Dr. John to Iboss one. Let me tell you why. We  
43:34 - have the case where gas of thought is smaller 
than cost of start. He the loop stops darkly  
43:39 - because remaining becomes negative, it stops us 
thought so there are no other stations involved.  
43:44 - Nothing to talk about here. But when gusoff Start 
is greater than or equal to cost of salt, the loop  
43:51 - moves to all the stations, it can traverse a bunch 
of stations before remaining becomes negative.  
43:57 - For example, here when we start at station four, 
remaining becomes negative at index seven. It  
44:02 - means the stations 456 and seven are all invalid. 
We'll start again from purpose one, eight. But why  
44:09 - girls will start is greater than or equal to cost 
of start. In our case, the difference is three.  
44:15 - Every three is considered as an advantage over 
starting from next stations is like a bonus by  
44:21 - starting from station four. We have three more gas 
and installing from the next one, station five.  
44:27 - And even with that bonus, we didn't have enough 
gas to do a full cycle. We stopped at station  
44:33 - seven avenue that bonus we couldn't go over 
station seven. So how do you want to go over  
44:38 - it without a bonus? It's like you have $500 and 
they aren't enough to buy a particle PC. Then you  
44:45 - say this $500 weren't enough. I'll try with four 
hundreds maybe they will be enough. It's a logical  
44:55 - and this is why when remaining becomes negative. 
We don't try again from the station that comes  
44:59 - after The one where we started, who skipped all 
the ones who traversed we started going from IPOs.  
45:05 - With our example, who start from the beginning, we 
may name becomes negative who's taught from IPOs  
45:10 - one at five and we pay two remaining becomes three 
who are three, we pay two remaining becomes four,  
45:17 - who else we pay eight remaining becomes minus 
one negative. What we're going to do now is to  
45:23 - dock the start again from here, without 
trying again, from stations to three,  
45:28 - who add follow up to remaining becomes three, who 
else we will pay for remaining become Sue, who  
45:33 - add one who pay two remaining becomes one who 
has free will by five remaining becomes minus one  
45:39 - negative. Once again, without his thought, again, 
from i plus one, we add four we pay one remaining  
45:46 - becomes three who add four who pay two remaining 
becomes six, and we finish traversing the array,  
45:52 - the candidate is station eight. But it doesn't 
mean that it can do a full cycle, it just means  
45:58 - that we can reach the end of the array without 
reaching a negative amount of gas. We didn't check  
46:03 - the pot before it. This is why I said candidate. 
It's a potential valve station. We don't know yet.  
46:10 - To say that a candidate station 
is valid by starting from their  
46:14 - remaining Miss never become negative one 
traversing the path from candidate to the end.  
46:18 - But also when traversing the path from the 
beginning of the array to candidate X clause.  
46:24 - The first part of the cycle is what we verified 
during the traversal. And for the second part of  
46:29 - the cycle, we just calculated the sum of gas from 
zero to candidate minus the sum of costs from zero  
46:35 - to candidate, the result represents the remaining 
gas after traversing that pot. And if by adding  
46:42 - it to remaining the result stays positive, then 
candidate is a valid station. Else we have no  
46:47 - valid station. For example, here the sum of 
gas from zero to candidate exclusive is 24.  
46:54 - The sum of course from zero to candidate exclusive 
is 30. The difference is minus six. What remained  
47:01 - from candidate to the end is six what remains in 
the pot before candidate is minus six by adding  
47:06 - them together we get zero which is positive. So 
candidate is the valid station. Question. What if  
47:12 - we got a negative result here, then with Akutan 
minus one because there is no valid stations.  
47:19 - But what if the valid station comes after 
the candidate, it's impossible. Once again,  
47:24 - the station forma we started candidate 
has an advantage over next stations,  
47:29 - we know that gas of candidate is greater than 
or equal to cost of candidate. So even if with  
47:34 - that bonus, we get a negative remaining amount of 
gas, it will also be the case for next stations.  
47:42 - Let's jump to the code on the side all of 
this remaining starts at zero. And same  
47:46 - thing for candidate because at the beginning, we 
assume that the first station is the candidate,  
47:51 - the potential valley station. Now we start 
traversing stations. For each station, we update  
47:58 - remaining gas, we are guests of our answer truck 
cost of AI. And if remaining becomes negative,  
48:04 - we sell that to start again from APL small, it 
becomes a new candidate, and remaining becomes  
48:09 - zero because we will start again. After the loop, 
we calculate the remaining gas of the pot before  
48:15 - candidate the sum of gas minus the sum of costs 
of the pot from zero to candidate X clause IV.  
48:22 - Now we have three possible cases we have 
the case or candidate is equal to and  
48:27 - it means that we reached the end of the 
array without finding a potential station,  
48:31 - no station made it to the end 
of the array, we return minus  
48:35 - one. So in case we have a candidate, but when 
adding prev remaining, we found the negative  
48:40 - result, it means that it stopped somewhere 
in the pot from zero to candidate return  
48:44 - minus one. And third case, we have a candidate and 
remaining plus prayer remaining is not negative.  
48:51 - So candidate is the false station for more we 
start to be able to do a full cycle, we return it.  
48:59 - In code. If candidates is equal to 
length of gas, the number of stations,  
49:03 - or remaining prosperity remaining is smaller than 
zero, we return minus one else we return candidate  
49:11 - who can even keep track of remaining in the first 
loop to avoid traversing again to calculate the  
49:16 - sums. For the time complexity, we just have a loop 
that does n iterations all other operations are in  
49:23 - over one, we get an off and on complexity, where n 
is the number of stations much better than O of n  
49:29 - squared. Add a constant space complexity because 
we're not using inputs all related variables.  
49:37 - Basically, in the solution, we search 
for the candidate the station that made  
49:40 - it to the end of the array without 
reaching a negative amount of gas.  
49:44 - Then we check if it still boosts up 
when traversing remaining stations,  
49:48 - those in the pot from the beginning of the 
array until going back to it who's the end  
49:54 - of this video. I hope that you understood the 
optimal solution and see what the next one  
50:06 - Welcome back to the course in this lecture 
rules of the course scheduled problem,  
50:10 - we have n courses labeled from zero to n 
minus one in clauses that we need to take.  
50:16 - But some of them are prerequisites the other, we 
cannot take a course before taking the other one.  
50:22 - And we have to determine if it's possible to 
finish all the courses. So we are given an integer  
50:28 - as representing the number of courses and an 
array prerequisites who are prerequisites of r is  
50:33 - equal to a b means that you first need to take the 
course P before taking the course a. For example,  
50:39 - if we have this input, the output should be false. 
Because to take course three, we must have taken  
50:43 - course zero, and to take her zero must have taken 
course one. And to take course one, we must have  
50:44 - taken course three, it is impossible, it's 
like we have a dependency cycle. This is  
50:55 - why we cannot finish all the courses return 
false. But with this input, the output is true,  
51:02 - we can take or zero then course three, then 
course one, then course five, then of course two,  
51:05 - that course for each course will have its 
prerequisite satisfied when taking it.  
51:12 - How to solve this problem. Here we have 
elements, courses and relationships between them,  
51:18 - of course being approved was that of a novel 
course. And every time we faced this situation,  
51:23 - having elements and relationships between 
them, you should think of using a graph.  
51:28 - I'm not saying that it will always give the best 
solution. But even if it doesn't, it will at least  
51:34 - give you a way to visualize the problem with 
vertices and links between them. In our case,  
51:40 - the vertices represent courses and edges 
represent dependencies and add from u to  
51:45 - v means that we first need to take the course 
you before being able to take the course fee.  
51:52 - Okay, now we build our graph, we got a 
directed graph what we will do with it.  
51:57 - Our goal now is to search for dependency cycle. 
If we find one, it means that it's impossible  
52:02 - to finish all the courses return false. Else if we 
don't find one at all, it means that it's possible  
52:08 - to finish the mole return true. Basically, we're 
searching for a cycle in a directed graph. In a  
52:16 - linked list, a classic way to check if there is a 
cycle is to traverse a linked lists while saving  
52:21 - visited nodes. And if we step on a node that we 
visited before, it means that there is a cycle.  
52:28 - We can think of applying the same logic for graph 
which covers with depth first search, for example,  
52:33 - while using a set of visited notes. And if we step 
on a node that has already been visited, it means  
52:38 - that we have a cycle return false. By the way, if 
you don't know about the full search, it's a way  
52:45 - of traversing trees and graphs by diving deep into 
a direction until we can move forward anymore.  
52:51 - Go back, try and all the way and so on. I made a 
huge video about the subject that you can watch.  
52:57 - You need to know about DFS before continuing 
this video is a prerequisite intended pun.  
53:04 - But this strategy doesn't always 
work. Here is a counter example.  
53:09 - We have this graph let's start traversing. We 
start for example from two we put it in visit it  
53:14 - we move to zero we pull it in visit it will 
move to three we pretend visit. This one has  
53:20 - no outgoing others, we backtrack, this one has 
no remaining neighbors to traverse we backtrack.  
53:27 - From here we move to the second neighbor one we 
put it in visit it will move to four we put it  
53:31 - in visited. Then from here we move to three 
and it's already in visited so our strategy  
53:36 - would return false. Which is wrong because 
we can totally finish all the courses here.  
53:42 - We can start with two then zero then three than 
one than four, all prerequisites are respected.  
53:50 - Was the solution done? Well, let me 
first talk about topological sort.  
53:55 - We have a directed graph where vertices represent 
tasks and an ad from u to v means that u is  
54:00 - a prerequisite of V. topological sort is the 
process of finding a linear ordering of vertices  
54:06 - such that each vertex comes after is perquisites. 
And all the words, for each edge from u to v,  
54:12 - V must come after you in the ordering. For 
example, for this graph here is a valid ordering.  
54:20 - Know that a valid ordering is not always unique, 
it's possible to find all the orderings that  
54:24 - satisfy the condition. But the logical sort is 
not always possible. It's not possible when the  
54:31 - graph contains a cycle like this one. B is a 
prerequisite of C, C is a prerequisite of D, D  
54:38 - is a prerequisite of E and E is a prerequisite of 
B, so we have no way to order them. Fortunately,  
54:45 - while performing the topological sort, we can 
detect the existence of a cycle. If it happens,  
54:50 - we just stop and say that we cannot have a valid 
ordering of vertices. And it's exactly what we  
54:56 - want to do in our problem who have courses. 
Some of them are prerequisites the other ones,  
55:01 - and we want to know if we can take all the courses 
and all the terms if a valid ordering exists.  
55:07 - Therefore, who will use the biological source 
and if during the process, we found the cycle  
55:12 - return false. Otherwise return true because it 
means that we've been able to make an ordering.  
55:19 - Okay, but how does topological salt work? A 
possible way to implement a biological source  
55:24 - is depth first search. Let's, for example, soft 
foam this vertex, we put it on the past stack,  
55:30 - the pastor contains the vertices of the actual 
path. B is its neighbor, we go to it, and we  
55:37 - put it on the past stack is his neighbor, we go 
to it, and we put it on the path stack. He is  
55:43 - his neighbor, we go to it, and 
we put it on the path stack.  
55:47 - Now it has no neighbors, it means that 
we can safely put it in our ordering,  
55:51 - because there are no vertices that have to come 
after it is perquisite of no one, we put it in the  
55:57 - order stack and we backtrack to the previous node. 
Next neighbor is I will go to it and we put it on  
56:04 - the path stack. Same again, it has no neighbors, 
who remove it from path stack and pull it  
56:10 - on all the stack. And we backtrack. Next neighbor 
is if we go to it, J is a neighbor, we go to it,  
56:18 - it has no neighbors, we move it from path stack, 
we put it on all their stack, and we backtrack.  
56:24 - Next neighbor is all but it's already visited. It 
has no more unvisited neighbors, so all vertices  
56:30 - have to come after it in the ordering our visit, 
we can safely put this one and we backtrack.  
56:37 - This one also has no more unvisited neighbors, 
we can put it in order staff, and we backtrack.  
56:44 - And the process continues like that. Until 
we traverse the whole graph of the end,  
56:49 - we get this ordering, we reverse it together from 
the beginning to the end. Now the opposite. encode  
56:57 - our DFS function takes us parameters to graph 
the vertex promo we start the path stock,  
57:02 - the oldest stack and the set of visited notes. We 
start by adding our vertex to the past, just when  
57:10 - we start traversing it, then for each unvisited 
neighbor, who first added to visit it, and we call  
57:16 - DFS with it as an argument to traverse it. After 
doing so for all the neighbors who can safely put  
57:22 - the actual vertex on the oldest stack will pop 
up from past stack and give it to all the stack.  
57:29 - And in our main top sort function, it takes us 
an argument the adjacency list of our graph,  
57:34 - it squares the visit itself, 
the Bastok, the older stack,  
57:38 - then it visits each unvisited vertex 
with DFS. After doing so, the other  
57:43 - stack is filled with turns reverse together the 
ordering from the first vertex to the last one.  
57:48 - Now the opposite. And starting from this 
algorithm, we can add instructions to detect cycle  
57:56 - we find the cycle when you find a back arch, 
and as that goes from vertex u to a vertex V,  
58:02 - where V is already in the path stack. Like here 
we have a B, C, D, E, then he has B as a neighbor,  
58:09 - which is already on the path stack. This graph 
contains a cycle B and E depends on each other.  
58:17 - In Code, our DFS function will not be a Boolean 
function. It returns if yes or no we've been  
58:22 - able to make an ordering. What we add is that 
before moving to a neighbor, we check if it's not  
58:28 - already in the stack. If it's the case, without 
a return false, we can't make a valid ordering.  
58:34 - Also, if traversing enable returns false, it means 
that we found a cycle one going from there. This  
58:40 - is why if the recursive code turns false, will 
also return false here. And if we've been able  
58:46 - to traverse neighbors without getting a negative 
result return true, we could make an ordering.  
58:53 - Know that to optimize checking for the 
existence of the actual vertex in the stack,  
58:57 - it's better to use a set instead of a list 
searching and assert is an old one time an average  
59:02 - pass doc now is of type set at the beginning we 
add our vertex to it after the Lupu move it out to  
59:08 - add it to all the stack. And in our main solution 
function, we first need to build the graph  
59:16 - because input will have the number of courses and 
the list of prerequisites. Now the adjacency list  
59:23 - to build the adjacency list, we know 
the number of vertices so we create  
59:27 - an array of N empty arrays. Each one 
will contain neighbors of the course I  
59:33 - know which are first prerequisites of the problem 
says that prerequisite of one has to come before  
59:38 - prerequisite of zero. So create an ad from 
prerequisite of one two prerequisite of zero.  
59:44 - In other words, who add prerequisite of 
02 neighbors have prerequisite of one.  
59:50 - Now that we've built the adjacency list, we can 
start traversing but before we create the visit  
59:55 - itself, the past arc which is also a set on 
the order stack, For each and visited course,  
60:02 - who added to visit, and if calling DFS with it 
returns false, it means that we couldn't build  
60:07 - the old, we found the cycle. So return 
false, who can't study all the courses  
60:13 - out of the loop doesn't return false, it means 
that we could find an ordering because all  
60:18 - the order courses return true. And we've been able 
to solve our problem. For the time complexity,  
60:26 - we're just performing dub for search on a graph. 
And the time complexity of DFS is often for v plus  
60:32 - length of E, will length of v is the number of 
vertices and length of E, the number of edges,  
60:38 - ie the number of vertices is the number 
of courses and, and the number of edges  
60:42 - is M for length of prerequisites list, who 
got an off campus and found complexity.  
60:49 - And for the space complexity, we have the space 
for the adjacency list length of v plus length  
60:53 - of E, the space for the visited set length of v, 
the space for the path stack, and the older stack  
60:59 - length of v and the space for the call stack 
length of v in total, who got full times length  
61:05 - of v plus length of v, which is an awful length 
of v plus length of v, who does have apples.  
61:12 - Know that you may find a similar solution. But 
with collars each vertex can have the color white,  
61:17 - gray or black. Compared to our solution, 
what means and visited. Green means visited  
61:23 - and in the past dark, and black means 
visited add not in the past anymore,  
61:28 - we've put it in the order. And if 
we found the neighbor that is great,  
61:32 - it means that it's in the actual path, and we 
found it again. So we have a cycle return false.  
61:42 - No implemented topological sort with depth 
first search. But we can also implement it  
61:46 - with breadth first search. Let me show you how. 
If you don't know about breadth first search,  
61:51 - I made a YouTube video about it, I recommend 
you to watch it before continuing this one.  
61:58 - The general idea of our second solution 
is to split our directed graph into levels  
62:03 - and the first level, we have vertices that have no 
prerequisites, we'll conduct this thought studying  
62:07 - them. Once we finish, we can remove them from 
the graph by removing them from the graph. So  
62:14 - vertices won't have prerequisites anymore, because 
their prerequisites were courses we just started  
62:19 - and they're satisfied. And these vertices 
represent the second level, we'll put them in  
62:25 - our ordering and remove them after removing them, 
so vertices won't have prerequisites anymore,  
62:32 - they represent the third level, we put 
them in our ordering and remove them.  
62:37 - And the process continues like that 
until we have no more vertices.  
62:44 - Both removing vertices from graph costs on time, 
because we need to update the adjacency list.  
62:49 - Instead, we'll keep track of 
the integral of each vertex  
62:53 - and when we traverse a vertex, we decrement 
the integral of all these neighbors,  
62:58 - the in degree of a vertex is the number of edges 
that are entering it. For example, the integral  
63:03 - of this vertex is to so when we remove a vertex 
that is going to it would decremented in degree  
63:10 - and if the integral of a vertex becomes zero, 
it feels at all its perquisites are satisfied,  
63:15 - who can traverse it, we put it in the queue. With 
his graph, we call the integral of each vertex,  
63:22 - we search for vertices with an integral 
of zero, we put them in the queue and you  
63:26 - apply classic BFS traversal. The difference 
is that when we pop a node from the queue,  
63:32 - who start by putting it in the ordering array 
because it has no remaining prerequisites,  
63:36 - also want to traverse a neighbor with 
decremented in degree, and if it becomes zero,  
63:41 - we put it in the queue. Last thing would 
not need a visited set, because we're not  
63:47 - putting a vertex in the queue until we finish 
traversing all vertices that are going to it.  
63:52 - So we don't have the risk of traversing a vertex 
again. With this graph, this is what happens.  
64:19 - Encode will create an array of an 
empty arrays as we did with DFS,  
64:24 - but we'll also add an array of N zeroes 
to solve the integral of each vertex.  
64:29 - Now when filling the adjacency list will also 
increment in degree of prerequisite of zero  
64:34 - because prerequisite of zero is the vertex 
where the edge enters, so incremented in degree  
64:40 - now we'll create an array where 
we'll put our ordering and a queue.  
64:44 - The queue initially contains 
vertices hoes in degrees zero,  
64:48 - after it will start traversing while the cool 
still contains elements will pop a vertex we  
64:54 - add it to ordering because it has no unsatisfied 
prerequisites, and we traverse its neighbors for  
64:59 - each With different methods in degree, and if it 
becomes zero, we incue it as explained earlier.  
65:06 - After the loop, the other array is not filled, we 
return it. This time, we don't need to reverse it  
65:11 - because we started by putting vertices of level 
zero than one and so on. With this topological  
65:18 - sort algorithm, we can also detect cycles. 
When the graph contains cycles. What happens  
65:23 - is that at some point of the process, we will 
have no more vertices with an index of zero,  
65:28 - which means that nothing will be inserted in the 
queue, the process stops earlier, the array will  
65:33 - contain less than the total number of vertices, 
who will deduce that the process couldn't continue  
65:38 - because there is a cycle. And in our problem, who 
just want to know if we can make an ordering or  
65:43 - not, this is why after the loop, who will just 
compare the length of the order array with add  
65:48 - the number of courses either equal, the 
algorithm returns true, else it returns false.  
65:56 - So we keep the same code who just changed 
the return statement with a length of order  
66:00 - equal to add. For the time complexity, 
we're just applying breadth first search,  
66:07 - which has an off length of the plus length of 
a time complexity O of n plus m in our problem.  
66:13 - And for the space complexity, we have length 
of v plus length of a for the adjacency list,  
66:18 - length of v for the in degree array, and 
length of v for the queue of the ordered array,  
66:23 - three times length of v plus length of 
V gives offline for v plus length of E,  
66:27 - which is of m plus m and our problem, 
we get an off campus M space complexity.  
66:34 - We reached the end of this video in this 
one, we solve the CO schedule problem  
66:38 - with two different ways. I hope that you 
understood them both and seen the next one.  
66:49 - Welcome back to the course in this lecture, we 
will solve the Kieth permutation problem with  
66:54 - a range of numbers from one to n in clause 
IV, who can make n factorial permutations.  
67:00 - by labeling them in order starting from one, 
you're asked to return the Keith permutation.  
67:06 - For example, with n equal to three and 
k equal to three, here are the three  
67:09 - factorial permutations of 123 labeled animateur K 
is three, so we turn the third one to one, three.  
67:18 - The first solution that may come in your 
mind is obviously the brute force solution,  
67:22 - generating all the permutations doesn't return 
the case one, we give to the function the range  
67:28 - from one to n in closet, then we return the one at 
index k minus one. Remember that an array is zero  
67:34 - indexed, so the Keith one is at index k minus one. 
But the problem with this solution is that with  
67:41 - n elements, we can make n factorial permutations 
of lung add that it costs n times n factorial to  
67:47 - generate them, we get n or m times n factorial 
time complexity Soulshine, which is extremely  
67:52 - slow. We did use the tree to solve this problem 
is to be able to find the permutation without  
67:59 - generating the permutations. And this is what 
we'll see now. Let's take n equal to four. Now  
68:06 - take a paper or notepad software, list all the 
permutations of 1234 in order and tell me what  
68:12 - do we notice, I want you to take some minutes 
to analyze the structure of those permutations.  
68:20 - Here are all the permutations we have a 
total of four factorial permutations 24.  
68:27 - Who can notice that these 24 permutations can be 
divided into four parts. The first one contains  
68:32 - permutations that start with one, the second 
one contains permutations that starts with two,  
68:37 - and so on. Let's suppose that we want to 
find a 16th permutation k equal to 16.  
68:45 - If we label them starting from zero, it means 
that we want to find the permutation 15.  
68:50 - Because 16 is one we label them starting from 
one. The question now is, can we find what part  
68:56 - among these four parts of permutation 15 will 
be? The answer is yes, by using math. We know  
69:03 - that the first part contains permutations from 
zero to five in clause, the second one from six  
69:08 - to 11 in closet, the third one from 12 to 17, in 
closet, and the last one from 18 to 23. In Closet.  
69:16 - To find which one we'll just divide K by the 
length of a part, which is six in our case.  
69:22 - 15 divided by six gives two so the permutation 15 
won't be in the pot zero won't be in the pot one,  
69:29 - but it will be in the part two. Now that 
we're working with zero index labeling,  
69:36 - we know that the part two contains permutations 
that starts with three. So we already know that  
69:41 - our Keith permutation will start with a three 
and it will be one of these permutations.  
69:47 - Let's continue. What's gonna happen now 
is that the search space will be reduced.  
69:52 - Now we know that our case permutation 
will be in these six permutations.  
69:56 - We need to update variables. K needs to be more 
Initially we were searching for permutation  
70:02 - 15 Among all the permutations, but in this 
group of six permutations, we're searching  
70:07 - for permutation three, why three, because 15 
and model six, the length of the pod is three.  
70:15 - Case 15, when we start from permutation zero, 
but in this particular part it will label  
70:20 - permutation starting from zero, whose solution for 
permutation three, and also represents the number  
70:27 - of remaining elements of the permutation to find 
and found one, so we decrement and becomes three  
70:34 - and factorial also changes it becomes three 
factorial six. Same thing for pot length,  
70:40 - it also gets updated six divided by three is two. 
We also remove three from a news elements because  
70:47 - we already found its place in the permutation, 
and our permutation doesn't contain duplicates.  
70:55 - Who can divide these six permutations into 
three parts of two elements, the first part  
70:59 - contains permutations holds the second element 
is one, the second part contains permutations  
71:04 - hosts the second element is to other third parts 
contains permutations who is the third element is  
71:11 - 41214. All the elements or two we 
didn't use it in our permutation.  
71:16 - Case three now can we find the pot case 
permutation belongs to yes once again we divide  
71:22 - by the pot length, three divided by two gives 
one so the case permutation will be in part one.  
71:29 - And we know that permutations of 
Part One have to our second element,  
71:33 - so the second element of our permutation will 
be to, again the search space will be reduced we  
71:39 - know that our kid permutation will be in these 
two permutations. This is why we update the  
71:44 - variables k gets modified as we did previously, 
it becomes k models the length of part three  
71:50 - models two gives one it means that among these two 
permutations, we're switching for permutation one,  
71:58 - and gets decremented it becomes two which changes 
the value of n factorial two factorial is two.  
72:03 - Which also changes the value part length, 
and factorial divided by n is two divided  
72:08 - by two which is one. We can divide these two 
permutations into two parts of one permutation,  
72:15 - the first part contains permutations 
holds the third element is one,  
72:19 - and the second part contains permutations 
holds the third element is for,  
72:24 - to know the path or case permutation belongs to, 
who divided by the port land, the path length here  
72:29 - is one and one divided by one gives one, our 
permutation will be in part one. permutations  
72:36 - of part one how for as a third element, so the 
third element of our permutation will be four.  
72:43 - We do use the search space we know that 
our permutation will be in this part of  
72:47 - one permutation, we update variables, k becomes k 
models the port length, one model is one zero, and  
72:54 - becomes one and factorial becomes one pot length 
becomes one and we move for from a news elements.  
73:01 - We divide this one permutation 
into one part of one permutation.  
73:05 - The first part will contain permutations host, 
one is the fourth element, the length of a part  
73:10 - is one, and k divided by one gives zero. So our K 
permutation will be in pod zero. And permutations  
73:18 - of pod zero have one is fourth element. So the 
fourth element of our permutation will be one  
73:26 - now and becomes zero and it gets 
decremented. So we'll finish the process.  
73:29 - The case permutation is 3241, who found it 
without generating all the permutations.  
73:39 - If you didn't understand what we've been doing 
here, let me show it to you in another way.  
73:44 - You first need to understand 
how our permutations generated  
73:47 - are the beginning who have no 
choices forming this example.  
73:51 - And because we want all the permutations, we try 
all possibilities. When we add one when we add  
73:56 - 212 and three, add one, add four, this is why 
you're seeing four branches are the beginning.  
74:03 - And we're talking about permutations without 
repetitions. So when we take an element,  
74:08 - we remove it from possible choices. This is why 
when we take two other beginning for example,  
74:13 - lat branch creates three branches only not 
411111, a three and one one, we add four,  
74:20 - you can see that we didn't add two 
again. And when we take four for example,  
74:25 - we have two choices left one or 
three, we get two new branches only.  
74:29 - Then when we take one of them, we have 
one choice left, the one we didn't take  
74:35 - part in our problem we want to find the case one. 
The way we solve this problem is by using math  
74:40 - to calculate what branch we should go from 
to reach the combination we searching for.  
74:48 - Imagine that you have 1000 books labeled from 
zero to 999. Let's say that you're searching  
74:54 - for the book 436 You remember that these books 
are organized into Turn boxes have 100 elements.  
75:02 - The first one contains books from zero 
to 99, the second one from 100, to 199,  
75:07 - and so on how to know which book to search, and 
you simply divide the number of the book you're  
75:13 - searching for by the size of a box, because here 
they have the same size. 436 divided by 100 is  
75:20 - four, we searched in box four, we still didn't 
find the book, but we reduce the search space.  
75:28 - Now, we will search for book 36 In this box of 
100. Why, because 436 modules 100, the pot length  
75:36 - gives the receipts. Once again, the 100 books 
of the books four are organized in 10 boxes of  
75:42 - 10 books each, the first one contains books from 
zero to nine after for hundreds, the second one  
75:48 - from 10 to 19, after for hundreds, and so on. 
The book size is 1036 divided by 10 gives three,  
75:55 - we search in box three. In that box three, we 
search for book six because 36 modulus 10 is six,  
76:04 - so on and so on until we found the 
book without traversing all the books.  
76:09 - And basically this is what 
we did to solve this problem.  
76:13 - Let's try to generalize or the beginning we'll 
have n k add in us that contains elements in the  
76:19 - range from one to adding clause if now while n is 
greater than zero, who stopped by calculating the  
76:24 - port length, it's an factorial divided by n. 
After it, we calculate the index of the next  
76:31 - element to put in the permutation. Remember that 
we calculated by dividing cable the port length,  
76:37 - after we calculated we add an use of either 
the permutation either deleted from unused  
76:43 - who add an use of oil because it represents the 
common element in the if part. Then we decrement  
76:50 - n and k becomes K model a spot length to get 
its new position in the path that we choose.  
76:58 - who keep repeating that and when a becomes 
zero, we have our case permutation and we  
77:03 - solve the problem. In code, we have a function 
that takes as parameters and key the given input  
77:10 - or create an empty array for the permutation 
we're searching for. Then you create and used,  
77:14 - it contains elements of the run want to 
add in clause if afterward to avoid all is  
77:20 - recalculating our factorial recruiting the very 
fact we're factoring it represents a factorial,  
77:26 - it contains n plus one elements to have the 
values from zero factorial to n factorial.  
77:32 - To fill it, we know that zero factorial is one. 
And for remaining elements, we just take the value  
77:37 - of the previous cell and we multiply it by I, for 
example, with five who got 1126 24 120. Now we  
77:47 - decrement k, because k represents the position 
of the permutation with one index labeling,  
77:53 - but we're working with zero index labeling, okay 
becomes k minus one to fit. We're working with  
77:59 - zero index labeling. To simplify the math, we get 
the right result when we divide and use modules.  
78:08 - Who can start the loop now, while n is greater 
than zero, Portland is an factorial factor of  
78:14 - n divided by an avant the index of the 
element to take is k divided by potluck.  
78:20 - After getting the index of 
the next element, which is I  
78:24 - who are unused of our to our permutation, and 
we delete the element at index i from N used  
78:30 - before moving to the next permutation with 
decrement N, and k becomes k models pot length.  
78:37 - After the loop, our permutation is built, we just 
join its elements into a string and return it  
78:43 - will return the case permutation 
as required by the problem.  
78:48 - Basically, the solution will may now use this 
math to keep calculating the part of the case  
78:52 - permutation belongs to, because by knowing it, we 
know what is the next element to take from unused  
78:58 - and use, which is the array of elements we 
didn't use yet. For the time complexity,  
79:04 - creating a news cost and creating factory 
costs are plus one and film get costs. And  
79:10 - then the while loop gets repeated while and 
is greater than zero. And Angus recommended  
79:14 - that each iteration, so the number of iterations 
is equal to the initial value of an inside it,  
79:21 - all operations are in all one, except popping the 
element I found and used can have the case where  
79:26 - we need to shift all the elements to the left 
and entered all the elements of the permutation  
79:33 - were four n plus n squared plus one who got an O 
of n squared time complexity, way better than O of  
79:39 - n times n factorial of the first solution. And 
for the space complexity, we have n for a news  
79:45 - and permutation and n plus one for fact array, two 
m plus one gives us an O of n space complexity.  
79:53 - Where is the end of this video? I hope that 
you at least understood the general idea of  
79:57 - the second solution, which is dividing the 
perimeter Asians into pause with a common  
80:01 - element and calculating which part of the key 
permutation belongs to see you the next lecture  
80:13 - Welcome back to the course in this lecture, we 
will solve the minimum window substring problem,  
80:19 - we have two strings SN T, and we're asked to 
find the shortest substring of us that contains  
80:24 - all characters of T. If such a substring 
doesn't exist, return the empty string.  
80:30 - For example, if we have this input as output, we 
get C E A, B, E, ba, is the shortest substring  
80:37 - of our salt contains all characters of t, in all 
the words, two A's, one B and one C. First of all,  
80:45 - how can we know that a string contains all 
characters of another one who can't know it by  
80:50 - having the counter frequencies of each string, 
the one we use in the valid anagram problem,  
80:56 - if record is the counter of as one and for to the 
counter of as two, for every distinct character of  
81:01 - as two for one of CH must be greater than or equal 
to for two of CH in other words, as one must have  
81:08 - at least the number of occurrences of CH and 
s to encode will write for each CH in for two.  
81:15 - If rec one of CH is smaller than freq, two of 
CH will return false after the loop return true.  
81:22 - Knowing this, we cannot really think of a 
solution, the brute force solution, which covers  
81:27 - all possible substrings of us while keeping track 
of the shortest wall that has all characters of t.  
81:33 - In Code, who can add an early exit condition. If 
t is longer than us, we can't find the substring  
81:39 - that satisfies the condition, there isn't enough 
characters without glue join the empty string.  
81:44 - Same result when t is empty, 
who can return the empty string,  
81:48 - because technically, the empty string contains 
all the characters of the empty string.  
81:54 - Else who first create a counter for T to 
know the frequency of each character in it,  
81:59 - let's name it for t. We also need the string 
shortest that represents the shortest valid  
82:04 - substring that we found until now, it initially 
has amples one characters to be sure that it gets  
82:10 - updated as soon as we found the valid sub train. 
Now we start traversing substrings of us to do so  
82:17 - we start by traversing the length, because we will 
start by traversing substrings of one character  
82:22 - than substrings of two characters and so on. 
This is why learn goes from one to adding clauses  
82:30 - inside it, whichever starting positions, because 
with the same length, we have the substring the  
82:35 - source at index zero, the water source at index 
one, and so on. But it doesn't go until the end  
82:43 - to avoid going out of bounds when adding the 
length I goes from zero to n minus length in  
82:49 - clause if we have the starting position, which is 
I will have the length of the actual substring.  
82:56 - So we can extract the actual substring is the one 
between I in clause 11 i plus length fix clauses.  
83:04 - Now that we got the substring, we'll create a 
counter for it. Let's name it for us, after it  
83:10 - will give the actual substring replaces 
the shortest one who found until now,  
83:15 - for that two conditions, the actual 
substring must contain all characters of t,  
83:20 - we can't know it when the function we made and 
it must be shorter than the actual shortest one.  
83:26 - The length of the actual substring is length. 
So if length is smaller than length of shortest  
83:31 - will replace shortest becomes the substring. 
After the loop who don't don't quote on shortest,  
83:38 - because it's possible that we didn't find any 
substring that contains all characters of T  
83:42 - to know that we took the length of 
shortest. If it's still n plus one,  
83:47 - it means that it doesn't get updated, we return 
the empty string as required by the problem,  
83:52 - else return shortest. Basically, we return 
shortest one is length is at most n.  
83:59 - For the time complexity, let's say that 
n and m all lengths of Sn T respectively,  
84:04 - will have N for building for T and n plus one for 
creating shortest. Then we have n iterations for  
84:10 - the outer loop animal's life plus one iterations 
for the inner loop. And inside it the cost of  
84:16 - extracting the substring. And generating the 
counter depends on length. We also have the  
84:21 - cost of checking if it contains all characters, 
which is because in the function which covers  
84:26 - characters of reg T, their number is at most m we 
get this sum which is equal to one divided by six  
84:33 - times n times m plus one times three M plus two 
and plus four was simplify. And in the worst case,  
84:40 - T is shorter than s. So M is smaller than 
n. We're going off and coupon complexity.  
84:46 - And for the space complexity, we have amphiphilic 
T amples, one for shortest and for sub n n for  
84:52 - fracas we'll get three and Paul samples one, 
which gives them off samples and space complexity.  
85:00 - This solution is obviously very slow is 
not the best one. This is why we will move  
85:04 - to the second solution. Inside the inner 
loop, we have a cost of length to extract  
85:10 - a cost of length who generate the counter and cost 
of arm to check if it contains all characters?  
85:16 - What if we try to reduce this cost to over one? 
To get a constant cost per in a loop iteration?  
85:22 - Follow me well, how can we extract 
the substring and old one? In reality,  
85:27 - we will need to extract the substring and our 
second solution, who will just work with the start  
85:32 - and end indexes of the substring? Which are i and 
i plus length, we already know them. Second thing,  
85:38 - how can we generate the counter of the actual 
substring and oh one, the trick is to not always  
85:44 - build the counter again, who will use the one 
of the previous substring. Let me show you how.  
85:51 - Emergent that we have this 
string, US ABC a D CB AC.  
85:58 - And the first sell triangle five characters has 
this counter two A's, one B, one C and one T.  
86:05 - Starting from this counter, how can we get the 
counter of the next substring of five characters,  
86:10 - which is this one? To do. So we'll just increment 
the number of occurrences of the character that  
86:15 - went out of the window and increment the number 
of occurrences of the character that went in  
86:20 - the window. The one that went out is a it was 
in the first substring, but not in the second  
86:26 - with decrement fracks of A, it becomes more 
than the one that went in is he it's in the  
86:33 - second substring, but not in the first one 
who increment for x of e, it becomes one.  
86:39 - And we got the new countering old one because 
no matter the length of the substring,  
86:44 - we need to work on two characters, only the 
one that went out and the one that went in,  
86:49 - there will always be only two because 
we're moving by one position at a time.  
86:55 - Then for the next substring. Same logic, the one 
that went out is B so with the command for X of B  
87:01 - and the one that went NTC. So increment for x 
of C. And the process continues like that for  
87:07 - all sub strings of length five. The technique 
we're using here is called sliding window.  
87:14 - In our example, we were using a window of length 
five. Then to move to the next substring we don't  
87:20 - start again from the beginning, we just move the 
window by performing the necessary changes. And we  
87:26 - just focus on what went out of the window and what 
entered not what's inside because it won't change.  
87:34 - Last thing to optimize the cost of 
checking if it contains all characters,  
87:38 - the cost is actually M because we need to 
traverse characters of rec T Mobile let me  
87:43 - show you how to optimize it. In our example, T is 
ABC a it has three distinct characters A, B and  
87:50 - C. So we have three conditions to respect to say 
that our substring contains all characters of t,  
87:57 - the conditions are at least two occurrences 
of a at least one occurrence of b, at least  
88:02 - one occurrence of C. The idea to avoid always 
traversing all the characters, which can cause  
88:08 - um, is to keep track of how many conditions 
are satisfied. And for the actual substring,  
88:14 - the number of satisfied conditions is equal to the 
length of reg T, which has a number of distinct  
88:19 - characters of t, then the actual substring 
contains all characters of T It's a valid one.  
88:26 - Okay, but some characters are going out of 
the window and some of them are accurate,  
88:30 - which means that when moving the window, some 
satisfied conditions can become unsatisfied,  
88:35 - and vice versa. Some unsatisfied conditions 
can become satisfied how to handle that.  
88:42 - To do so, after incrementing the number of 
occurrences of the counter that went in,  
88:47 - if it's in fact T and frakkers of want 
n becomes equal to FRAC to point n,  
88:52 - it means that we didn't have enough occurrences 
of the characters that went in. And now we do  
88:56 - so a new condition is satisfied, 
who increments satisfied.  
89:03 - And before decrementing, the number of 
occurrences of the character that went out  
89:07 - if it's in fact T and for us of one out is equal 
to for active one out, it means that we had enough  
89:12 - occurrences of the characters that went out, but 
after decrementing, we won't because for us of one  
89:18 - out will be smaller than what's required. This 
is why we Diekmann satisfied, a condition that  
89:23 - was satisfied before is not satisfied anymore. 
And we decrement for x of one out obviously.  
89:31 - For example here we have these strings SN t 
and we have this window of seven characters,  
89:36 - the conditions are at least two occurrences 
of a at least one occurrence of p  
89:41 - at least one occurrence of C. Here we have one 
occurrence of a two occurrences of B and one  
89:47 - occurrence of C. Only two conditions are satisfied 
not enough. Let's move the window. Now he wants  
89:54 - out but we don't care because it's not a character 
of t with the command for X but nothing happens.  
90:01 - And a went in who increment for X of A 
and it becomes equal to fracture of A,  
90:06 - we satisfied a new condition, the number 
of conditions is equal to length of rec t.  
90:11 - So the substring is valid, it contains all 
characters of reg T, all conditions are satisfied.  
90:19 - We move the window, now see what's out of the 
window, and is number of occurrences in the  
90:24 - substring is equal to the number of occurrences 
in t. So, when we decrement because it's one out,  
90:30 - the condition becomes unsatisfied. 
We don't have enough C's anymore.  
90:35 - And the answer is the window. But we 
don't care. It's not a character of t.  
90:40 - Now the number of satisfied conditions is smaller 
than what's required. This substring doesn't  
90:45 - contain all characters of t. And the process 
continues like that. Once again, no matter  
90:52 - the length of the window, we're dealing with two 
characters, only the one that went in and the one  
90:57 - that went out. So checking if the actual substring 
is valid because of one we've been able to  
91:04 - optimize extracting the substring, generating the 
counter and checking if the substring is valid.  
91:10 - We've seen how to do all these in old one. But he 
didn't see the code yet. Let's move to the code.  
91:18 - We keep the same old exit condition, we 
generate the counter of t. But now we don't  
91:22 - save the shortest string itself. We just save it 
started and position. Initially shortest sources  
91:29 - a string of samples one characters, so initialize 
thought and and zero and amples one respectively.  
91:36 - Now we start traversing lengths. What we were 
doing in the example is to update frogs according  
91:42 - to characters that went in and out compared to 
the previous position of the window. But to do so,  
91:48 - we first did an initial window that's 
also zero and hose the length is length  
91:53 - arrow, traverse it normally to fill frogs 
and count the number of satisfied conditions.  
91:59 - We create fracks and recreate satisfied a 
variable to keep track of the number of satisfied  
92:04 - conditions. It initially starts at zero because 
we didn't start traversing characters of as yet,  
92:10 - we didn't satisfy any condition. Then we 
traverse characters of the first window,  
92:16 - for each character ch will increment flux of 
ch. And if CH is a character of T and flux  
92:22 - of CH becomes equal to react, you have ch now 
the number of occurrences of CH became enough,  
92:28 - a new condition is satisfied, who increments 
satisfied. After processing the first window,  
92:34 - we check if it's a valid substring before moving 
to all the ones and if it should replace the  
92:39 - actual shortest one. If satisfied is equal to 
length of reg t, the number of conditions and  
92:45 - length is smaller than the length of the actual 
shortest substring, which is add minus thought  
92:50 - replace, start an N becomes zero and length 
respectively, the boundaries of the first window.  
92:58 - Now we can start traversing all the 
sub strings are the same length,  
93:02 - I start at one and zero 
because the first sub string,  
93:05 - which is the first window is already 
processed, we start from the second one.  
93:12 - We want to work with the character that went out 
of the window and the one that went in bought,  
93:16 - where are them. The actual substring is between 
indexes I in clauses when I post length exclusive,  
93:24 - the character that went out comes just before 
the window. So its index is i minus one.  
93:29 - And the one that went in is the last character of 
the window, its index is i plus length minus one,  
93:36 - we can start working, the character that entered 
the window is opposition ai plus length minus one.  
93:42 - So increment for x of s of Ai plus length minus 
one. Now if it's a character of T and its number  
93:48 - of occurrences and the substring became equal to 
the number in t, it means that the new condition  
93:53 - is satisfied, we write if as of apples length 
minus one in fact T and flux of hours of eyeballs  
93:59 - length minus one is equal to freq T of s of i 
plus length minus one, we increment satisfied.  
94:07 - After it, we work with a character that went out 
the one at index i minus one if it's a cocktail of  
94:14 - T and S number of occurrences and the substring 
is equal to its number of occurrences in t  
94:18 - it means that a condition was satisfied but not 
anymore, because we will decrement for x of s  
94:23 - of n minus one. So it will become smaller than 
freq T of s of i minus one not enough occurrences  
94:28 - of x of i minus one anymore. We write if as of i 
minus one in fact T and for x of s of i minus one  
94:36 - equal to T of s of i minus one with the 
cumin satisfied will also satisfied condition  
94:43 - after it with the CaroMont 
for x of s of i minus one.  
94:49 - Now that we know the number of satisfied 
conditions by the actual substring the one between  
94:54 - i and i plus Lang who can check if it replaces the 
actual shortest one, we write If satisfied equal  
95:00 - to the length of reg T and length is smaller 
than n minus thought, we replace thought and  
95:05 - by i and i plus length respectively, we found a 
shorter string that contains all characters of T.  
95:12 - After the loop, soften and represent the 
boundaries of the shortest substring,  
95:16 - but only found one. If underline his thought 
is greater than n, then we didn't update  
95:21 - start and end, we turned the empty string 
because we didn't find any valid substring.  
95:26 - Else, we told the part of us between starting 
clause event and X closet. What about the time  
95:35 - complexity, we'll have time for building for T 
n iterations for the outer loop. Then inside it,  
95:41 - we have linked iterations for the first loop, 
and one is length iterations for the second bond,  
95:46 - and all operations inside the mind of 
one plus n for returning the part of us  
95:52 - length plus and minus length gives n and we 
can ignore M, we've got an O of n squared  
95:57 - time complexity, the space complexity doesn't 
change. You can see that now we've been able to  
96:04 - reduce the time complexity from F and Q to off 
n squared isn't enough. No, we can do better.  
96:12 - When using sliding window, we have the case where 
the window size is fixed. For example, if we have  
96:17 - an array of integers and are asked to find the 
key consecutive elements with the greatest sum,  
96:22 - we use a window of size k, we will move 
it but we won't change its size because  
96:27 - we know that the array we're searching for 
is of length k. However, in our problem,  
96:33 - we don't know the size of the shortest 
substring that contains all characters.  
96:37 - This is why we tried all possible lengths, 
which are sub strings of length one  
96:41 - than those of them do, and so on, which 
resulted in an O of n squared time complexity.  
96:49 - But we have another way of manipulating the 
window, instead of sliding the window by  
96:53 - one position. In other words extended from the 
right by one and reduce it from the left by one,  
96:59 - what we can do is to extend it from the right by 
one, but reduce it from the left by a number of  
97:04 - times that is between zero and the length of 
the window. Depending on what we want to do.  
97:10 - Let's apply to our problem.  
97:14 - Theory of the strategy that we're going to use 
is to find the shortest substring that answer the  
97:18 - actual index of write that respects the condition, 
which is containing all characters of tea.  
97:25 - Obviously keeping track of shortest one among 
the more the one that will be returned our via  
97:32 - let's start for the first index, we find an A 
but no condition is satisfied, we need to as  
97:38 - next index, we find d, we don't care about it. 
Next index we find c a condition is satisfied.  
97:46 - Next index if we don't care. Next 
index e we don't care. Next index B,  
97:53 - the second condition is satisfied, but not all 
of them. Next index e we don't care. Next index  
98:00 - see we have two Cs now, better condition is still 
missing. Next index, he won't care. Next index  
98:08 - a, we now have two A's, which is 
enough to satisfy the last condition.  
98:14 - All conditions are satisfied now, it means that 
the substring from left to right in clause is  
98:18 - valid. But is it the shortest one that answer 
the index, right? Not true. Because we may  
98:24 - have characters that we don't care about by 
characters that we don't care about, I mean  
98:29 - characters that we can remove without breaking 
the validity of the actual string. And these  
98:35 - characters are characters that are not in TRL and 
calculus of t that are in excess in our substring.  
98:42 - For example, if we need to see is only and we have 
five C's in our substring who can remove the first  
98:47 - three wants to make the substring shorter while 
satisfying the condition. Remember that our goal  
98:53 - is to get the shortest valid substring. Who cannot 
remove from the metal because characters of a  
99:00 - substring must be ages. And we cannot remove from 
the right because we're searching for the shortest  
99:05 - valid substring that answer the actual position 
of right. So we can only remove from the left  
99:11 - will keep removing while the characters position 
left is a character we don't care about.  
99:18 - Here the character off left is a 
it's in T and it's not an excess.  
99:23 - We need two A's and we have exactly two. So 
this one is important. We cannot remove it.  
99:29 - We finish removing from the left. So the 
shortest substring that answer right is this one  
99:34 - is length is smaller than the actual shortest 
one, we update. We move to the next position of  
99:40 - Freud who find the be the one at left is still 
important. So the shortest one is this one.  
99:45 - But we don't update because it's not the global 
shortest one. Next position, we find an E the  
99:52 - counter left is still important. Next position we 
find to be the character left is still important.  
99:59 - Next addition, we found in a and here is where 
things change, because the character at left  
100:05 - is not important anymore. The reason behind it 
is that we found another A, which means that  
100:10 - the character is now in excess, we can remove 
the first one without breaking the Validate  
100:16 - he will move a and with the 
command is number of occurrences.  
100:20 - Let's see if we can continue removing D is not 
an important character is not in T, we move it  
100:27 - C is in T but we have more than enough 
we have two C's while we need only one  
100:32 - we move and decrement is number of occurrences 
of is not empty. Remove is not empty, remove it.  
100:40 - These in excess we remove it is not empty, we 
remove it. C is in T and it's not in excess.  
100:48 - So we stopped removing. We found out that the 
shortest valid substring that antithyroid is c  
100:53 - e a b e BA and it's like the seven smaller than 
the length of the actual shortest one replace.  
101:01 - Let's continue. We'll move to the next position of 
right. By the way, if you're wondering why aren't  
101:08 - we going back to the beginning going to increment 
right is because we know that characters before  
101:12 - the actual position of love aren't important. 
We don't need the for the actual substring.  
101:20 - Who found the D the cow top left is 
still important and we don't update  
101:24 - because the length is not smaller than seven.  
101:28 - Next position who find half the characters 
left is still important and we don't update.  
101:34 - Next position we find the seat which means that 
the character at left is not important anymore.  
101:39 - The character sees in excess we can remove it is 
not in T we also remove it is important because  
101:47 - it's in T and it's not in excess we stopped 
removing we get a B e b a DFC, which is not  
101:54 - shorter than the actual shortest. We don't update 
we continue with on D and A still important.  
102:01 - Next position we find f is still important. 
Next position, we find c an ACL important.  
102:08 - Basically it will continue like this for the next 
five positions. And there is no update because the  
102:13 - substring is getting longer. We're not being able 
to remove from the left and in the next position  
102:20 - we find an eight so the one on the left is not 
important anymore, we remove it. These in excess  
102:26 - we remove it is not empty, we move it be still in 
Excel. So remove it is not in Excel. So we stop  
102:36 - the substring is a DFC, DFC BFC BA, but not short 
enough to update. last index, we find d and a  
102:46 - still important, we don't update and we finish 
traversing as the global shortest substring that  
102:52 - contains all characters of t is the one between 
indexes seven and 13 and clauses, it c a b e BA,  
103:01 - take some seconds to process what you've 
seen until now before continuing the video.  
103:09 - Let's move to the code. We keep the same URL 
the exit condition we build for it as we did  
103:14 - previously, we initialize thought and add on 
zero and respectively. We initialize satisfied  
103:19 - zero regret for x which is empty at the beginning. 
And we add a variable left that represent the left  
103:25 - boundary of the window here and started on and not 
n plus one because now Andrew presents the last  
103:32 - nfo the window is in closet. Also, you can see 
that we created frogs and satisfied outside the  
103:38 - loop because we won't traverse lengths as we did 
in the previous solution. We don't need to do that  
103:43 - will darkly traverse positions of right the right 
boundary of the window for each position right  
103:50 - we increment the number of occurrences of the 
character obviously, an objective is satisfied a  
103:54 - condition as we did in the previous solution if 
as of right is in fact T and flux of arthritis  
104:00 - equal to for active as a Freud who satisfy the 
condition so increments satisfied. Basically the  
104:07 - path before satisfying all the conditions. This 
is what we need to do only incrementing the number  
104:12 - of occurrences and checking if we satisfied a 
condition remember that we're expanding from  
104:17 - the right only less remains zero. But once we 
satisfy all the conditions which we can verify  
104:25 - with this condition, satisfied equal to length 
of FRAC t we can start removing from the left.  
104:31 - We don't know how many characters are we going 
to remove from the window. So we use a while  
104:36 - loop. We saw that we keep removing characters 
while the character has left is an important  
104:42 - and a character that is not important. means 
that either is not a character of the origin  
104:47 - access means we have more than what's required. We 
write while as of last noted for akti or flux of  
104:53 - us have left greater than for active as of left. 
Inside the loop, we move the car out which means  
105:00 - that we decrement its number of occurrences 
in frogs and move left to the next position.  
105:06 - Now that we removed all unnecessary characters 
who go the shortest valid substring? That answer  
105:11 - the actual position of right is the 
one between left and rotting clause if  
105:17 - what do we do now, we check if it 
replaces the actual global shortest one.  
105:22 - The length of the substring, we found now is 
right minus left plus one plus one because  
105:27 - this time the right boundary, which is right 
is included in the window. And the length  
105:33 - of the actual global shortest one is and minus 
thought plus one plus one for the same reason.  
105:39 - So if right minus left plus one is smaller 
than and minus that plus one, we update,  
105:44 - start and end become left and respectively. 
After the loop, almost same return statement,  
105:51 - we just add plus one because and is included in 
the window. Now, if we could update at least once  
105:57 - we turned the part of ASP video installed and 
adding clause if else return the empty string.  
106:04 - By the way, you can see all of this time, we 
weren't checking if we lost a satisfied condition.  
106:09 - Because we stopped removing as soon as we reached 
the minimum required occurrences will never  
106:14 - go below it. This is why when the counter had 
left was important. We weren't removing at all,  
106:20 - not like in the previous solution when we were 
removing no matter what. For the time complexity,  
106:27 - we have an for building for T and 
the outer loop does n iterations  
106:32 - is true that we have an inner while loop where 
the tricky part is that its number of iterations  
106:36 - doesn't exceed n in total. I repeat in total. 
Why? Simply because at each iteration of the  
106:42 - while loop, we're removing a character and we 
have n characters. remaining operations are  
106:48 - owned over one. So the cost of the outer loop 
isn't over. And yes, oh if and only not more,  
106:55 - who else pause and for extracting the output. 
And in total, we have ample of ampersand,  
107:00 - we'll give some of ample time 
complexity better than O of n squared.  
107:06 - And for the space complexity, same as the previous 
solution of m plus m. And we've been able to solve  
107:13 - the problem in off campus m time only by 
using a bunch of interesting optimizations.  
107:19 - One was a tough problem, I hope that you 
understood how we built our optimal solution  
107:24 - that you will be able to use it to solve all the 
problems. We've reached the end of this video,  
107:30 - it was a long one. But I tried to detail 
each operation to let you understand what is  
107:34 - each line of code doing and how the algorithm 
works in general. See you in the next video.  
107:46 - Welcome back to the course in this lecture, we 
will solve the largest rectangle in histogram  
107:50 - problem. We are given an array heights that 
contains the height of each bar in the histogram.  
107:56 - And we're asked to return the area of 
the largest rectangle in the histogram.  
108:00 - Know that each bar has a width of one. For 
example, if we have this input here is the  
108:07 - largest rectangle. It's area seven times five, 
which gives 35. How can we solve this problem?  
108:14 - Let's for example, take this bar, it has a 
height of two. Now, can you tell me what's  
108:19 - the largest rectangle of high two that passes 
from this bar? Is this one. But how did we know?  
108:26 - Let's start from that bar and keep expanding? Can 
we expand to the left? Yes, three is greater? Can  
108:32 - we expand? No, because we have no more bar from 
the left? From the right now can we expand? Yes,  
108:38 - four is greater? Can we expand? Yes, five is 
greater than two. In other words, this bar is  
108:44 - higher so our rectangle can pass from it. Can we 
expand? Yes, seven is greed. Can we expand? Yes,  
108:50 - six is greed. Can we expand? No, we can't expand 
from here because one is smaller than two. So if  
108:56 - we expand, the rectangle won't be fully included 
in the histogram is not a valid rectangle.  
109:03 - We expanded as much as possible from both sides, 
we go the largest rectangle that passes the  
109:08 - initial bar is this one, it has an area of 12 Two 
times six, the height multiplied by the width.  
109:16 - And we can apply this strategy on each bar 
while keeping track of the greatest area  
109:21 - of the end who will have found the greatest 
area, because the largest rectangle necessarily  
109:26 - passes from a bar that has the same height as 
itself. The reason behind it is that if the  
109:31 - rectangle is shorter than all the bars it passes 
from, it means that it's not the largest one,  
109:36 - you can still make it bigger by increasing its 
height. And if it's taller than at least one bar  
109:41 - learn is not fully included in the histogram. 
It's not a valid rectangle. With this example,  
109:49 - with the first bar we get this rectangle with 
the second bar we get this rectangle and so on.  
109:59 - The end The greatest area that we 
find is 35. The area of this rectangle  
110:07 - encode we initialize Max area to zero because 
we didn't traverse any rectangle. Therefore,  
110:12 - each bar I expand from both sides from each side, 
we keep expanding while the bar is still higher or  
110:19 - as high as our bar. So we stopped when we found 
the shorter one, or when we have no more bars.  
110:27 - Left thoughts are the actual position, then 
while the previous bar exists and is at least  
110:31 - as high as the actual bar, we expand, we 
move left by one position to the left.  
110:37 - Same logic with the right side but 
by incrementing, right starts on I,  
110:41 - then while the next part exists, and is at 
least as high as the actual bar, we expand,  
110:46 - we move right by one position to the right. While 
right plus one smaller than N and height of right  
110:52 - plus one greater than or equal to height of 
AI, we increment y to take it to the right.  
110:58 - Now that we know boundaries of our 
rectangle, we need to calculate its area.  
111:03 - The area of a rectangle is the height multiplied 
by the width, the height here is the height of  
111:08 - the initial bar height of i, and for the width is 
the difference between left and right plus one,  
111:14 - right minus left plus one plus one because both 
left and right are included in the rectangle.  
111:21 - Now we check if replace Max area becomes 
the most between its actual value and the  
111:26 - area of the actual rectangle heights of our 
multiplied by right minus left postponed.  
111:32 - After the loop, we just return max area.  
111:36 - For the time complexity, we're traversing the N 
bars, and for each bar when searching for left  
111:41 - and right boundaries, who may traverse the whole 
histogram. This is why we get an O of n squared  
111:46 - time complexity. In the worst case, the worst 
case happens when all bars have the same height.  
111:53 - And for the space complexity, it's 
constant, we're just using eight variables.  
111:59 - This solution is slow. Let's move to the next one. 
There are interesting properties to know about the  
112:05 - shortest bar. The first one is that by starting 
to make a rectangle from it, we can expand it  
112:11 - until the boundaries of the histogram because 
there are no shorter ball to stop the expansion.  
112:17 - Second one, the rectangle starting from 
any other ball can't pass through it,  
112:21 - except if it has the same height, but 
we get the same rectangle in that case.  
112:26 - So the shortest part is like a wall, any other 
rectangle will either be on his left side or on  
112:31 - his right side. From these two information, we 
can make a solution based on divide and conquer.  
112:38 - We search for the shortest bar, and we have a 
rectangle that traverses the whole histogram  
112:43 - will also recursively search for the 
largest rectangle in the left side,  
112:46 - the largest rectangle in the right side, and 
we take the maximum among these rectangles,  
112:52 - it represents the largest rectangle in the 
whole histogram. The reason behind it is  
112:57 - that because our bar is the shortest one, we 
can't have a taller rectangle that joins the  
113:02 - left on the right side, a taller rectangle will 
either be in the left part or in the right part.  
113:08 - So we don't worry about missing the larger 
rectangle, we can search in each side separately.  
113:14 - We also consider the rectangle host the height 
is the height of the shortest bar, the one  
113:18 - that traverses the whole histogram, because 
it's possible for it to be the largest one,  
113:23 - even if it has the smallest height, but its 
width can make it the most interesting rectangle.  
113:31 - Encode recruiter recursive function that 
takes us parameters the array of heights,  
113:35 - but also low and high the boundaries of the part 
of the histogram we're searching in right now. Or  
113:42 - the beginning we search the whole histogram. So 
low and high will be initialized to the index of  
113:47 - the first and the last bar. The first base case is 
where the actual part is empty. While low exceeds  
113:53 - right, we just return zero, we have no rectangle. 
Second base case one, we have only one bar,  
114:00 - one low is equal to high. In those case, 
we just returned the height of that bar.  
114:06 - Else, we have the recursive case, we'll start by 
calculating the position of the shortest bar in  
114:10 - the actual part. For that, we calculated 
the smallest height in the actual part  
114:16 - between low and high in clause IV, then we 
search for its index in the outro part again.  
114:22 - Now that we have it, we recursively search for 
the greatest area and the left and right sides.  
114:28 - For the left part, we put postman minus one 
as the right boundary. And for the right part,  
114:33 - we put postman postman as the left boundary. 
URL for the short put wide rectangle, its height  
114:39 - is the minimum height we calculated before and 
its width is the whole path we're searching in  
114:45 - high minus low plus one. So we turn the maximum 
between from left form right and mean eight times  
114:52 - high minus low plus one. This one represents 
the area of the short but while rectangle  
114:58 - we also need a long question function to call 
this one, the initial values of low and high  
115:03 - are zero and n minus one, the index of 
the first and last bar respectively.  
115:08 - For the time complexity, in the best case, 
the shortest bar is always in the middle.  
115:13 - So in recursive cases, we divide the input size by 
two, we have infosearch. And for the men, and two  
115:19 - times t of n by two for cursive calls, we get t of 
n is equal to two times t of n divided by two plus  
115:25 - n. By using the master method, this recurrence 
relation gives off n log n time complexity.  
115:33 - But in the worst case, the shortest bar is always 
the first or the last bar. For example, when  
115:38 - it's the first one, from the love, the input size 
becomes zero, we get to zero. But from the right,  
115:44 - the input size becomes n minus one, we get to 
have animals one plus n to search for the minimum,  
115:50 - we got t of n is equal to t of n minus one plus n. 
And if we keep replacing, this recurrence relation  
115:57 - gives off n squared time complexity, same as 
the previous solution is like we didn't often  
116:04 - what's slowing down the process is finding the 
minimum its causes and to search for the minimum  
116:09 - in the run who are searching for. But we can 
optimize this by using a segment tree for example,  
116:14 - you can reduce the cost of searching for the 
minimum and arrange to look at the recurrence  
116:19 - relation becomes t of n is equal to t of n 
minus one plus log n, we get off n log n plus  
116:26 - n to build the segment tree, we've got an O of n 
log n time complexity, but if n over n squared.  
116:34 - But we still have two solutions to discover.  
116:39 - The strategy we use in our first solution is dot 
for each bar, we search for the next shorter bar  
116:44 - from the left the next shorter bar from the right, 
and we calculate the area of the rectangle bar  
116:50 - always traversing bars again to search resulted 
in an O of n squared time complexity. What if we  
116:56 - can traverse the histogram only wants to find the 
next shorter bar of each bar? Yes, it's possible  
117:02 - by using a stack, we can maintain a stack and 
in increasing order. For example, we have 2478,  
117:10 - then we want to insert five, but it wouldn't 
be increasing anymore. So we'll keep popping  
117:15 - until we find a smaller element. And we push 
it remains increasing. Then again, we'll have  
117:22 - six 910 12/3. To insert eight will pop 12 will 
pop done, we put mine and insert, and so on.  
117:36 - And we can use this principle for our problem 
will work with heights will maintain a stack and  
117:43 - to follow the next shorter bar from the left of 
the actual bar who keep popping into the top of  
117:47 - the stack becomes shorter after it will also 
push the actual bar for the next iterations.  
117:54 - Let me show you how it works with our example. 
We can add two bars of height minus one at  
118:00 - extremities to avoid having an empty stack minus 
one to be sure that they will be shorted at any  
118:05 - bar or the beginning, the stock contains 
the bar zero, and will start from bar one.  
118:12 - The top of the stack is shorter, who already 
found the next shorter is at index zero. And  
118:18 - we'll push the actual bar. Next index, the top 
of the stack is higher Ooh pop. Now it's smaller,  
118:25 - the index of the next shorter is zero, and we'll 
push the actual bar. Next bar top of the stack  
118:32 - is shorter, we already found next shorter is 
the bar index two and we push the actual one.  
118:39 - Next bar, same thing, top of the stack 
is shorter. Next bar same thing. Next  
118:44 - bar who performs and we find it next bar, we 
have to pop all of them except the last one  
118:51 - because they are all higher. Next bar, the top 
of the stack is all really short, its index is  
118:57 - seven, next bar are really shorter. And it 
continues like this for the whole histogram.  
119:19 - Now we got the index of nav shorter 
bar from the left of each bar.  
119:22 - But we still need the one from the right. So we 
can apply the same process but from the right.  
119:29 - The Start Now initially contains the rightmost 
bar, the one we added from there, who is the  
119:33 - height is minus one. First of all from the right, 
the top is already shorter, and we push. Next bar  
119:41 - we put once and we find the index we also push 
next bar already shorter. We write and we push.  
119:48 - Next bar, same thing we write and we push. 
Next bar same thing. Next bar, same thing.  
119:56 - Next bar we pop twice, we write and we push 
next bar, we put once we write, and we push,  
120:03 - next bar, we pump thrice, we write, and we 
push, and the process continues like that  
120:25 - now for each bar, we have the index of the next 
shorter bar from the left the index of the next  
120:30 - shorter bar from the right, we can calculate the 
largest rectangle that passes from the actual bar.  
120:35 - For example, for this one, next 
shorter bar from the left is zero.  
120:39 - From the right, it's seven. 
So we get this rectangle  
120:44 - to get the largest one in the whole histogram, 
whichever is largest rectangle of each bar,  
120:48 - while keeping track of the global largest 
one, as we did in the first solution,  
120:53 - but we don't need to search again here. And we've 
been able to solve the problem by traversing the  
120:59 - histogram only thrice instead of n times, which 
will reduce our time complexity to O of n.  
121:07 - Encode who first are those two bars of height 
minus one not extremities, then we create an array  
121:13 - from left or from left of it represents the index 
of the next shorter bar from the left of the bar,  
121:18 - I will also create a stack that initially 
contains the first bar, the one we added.  
121:25 - Now for each bar, except once on extremities, who 
keep popping, while the bar on top of the stack  
121:30 - is higher, or as high as the actual bar, we write 
wild heights of stock of minus one greater than or  
121:36 - equal to heights of oil, we pump stock of minus 
one represents the top element. After the loop,  
121:44 - the next shorter bar from the left is on top of 
the stack, we assign it to from left, I will also  
121:50 - push the index of the actual bar i. We finished 
filling from left, who will do the same thing from  
121:57 - the right, acquired from right, we initialize the 
stock by putting the last bar only and we start,  
122:04 - now we traversed bars, but in the reverse order. 
Remember that we start from the right and we move.  
122:11 - Same logic for what's inside the loop. 
But we assigned to from right of it now.  
122:17 - After having both arrays filled, we can start 
working to initialize Max area to zero, then for  
122:23 - each bar, who took it who replaced Max area, Max 
area becomes the maximum between its actual value  
122:29 - and the area of the rectangle of the actual 
bar. The height of the actual bar is height  
122:34 - of AI. And the width is fomite of i minus from 
left of i minus one minus one. Because the next  
122:40 - shorter bars are not included in the rectangle, 
we don't count their width. So the area is height  
122:47 - of I times from right of i minus from left of 
i minus one after the loop return max area.  
122:56 - For the time complexity, we have n to add those 
bars and integrate from left. And now for the loop  
123:03 - is true that we have a nested while loop where 
the total number of iterations won't exceed  
123:07 - and because each bar is pushed and 
popped only once. And we have an bars  
123:12 - so the cost is N. Same logic for the process 
from right, and we add on to search for Max area.  
123:19 - We're getting off on time complexity. And for 
the space complexity we have and for heights  
123:26 - and for the stack, and for from left. And and for 
form, right we're going off and space complexity.  
123:35 - In this ocean, whichever is the histogram 
thrice, but we have a solution where we  
123:39 - traverse it only wants let's talk about it. Okay, 
imagine that we have this bar as a first bar,  
123:46 - we can still expand it from the right because 
we didn't find the shorter one. The next bar  
123:51 - is this one, you can still expand them both, 
we found nothing that stops them. Third bar,  
123:57 - same thing. Fourth bar, same thing, you can still 
expand them all because the hearts are increasing.  
124:04 - And we're putting them in a stock by the way. 
Both for example, the next bar is this one,  
124:10 - this bar will love the previous three bars 
stop expanding because it's shorter than them.  
124:15 - In other words, all bars that 
are taller than it in the stack.  
124:21 - And because now we know where these bars stop, 
we can't calculate the largest rectangle, the  
124:26 - actual bars at index four, so they stop at index 
three. For this bar, here's the rectangle for the  
124:33 - next one of the stack. Two is the rectangle. 
And for the next one, here is the rectangle.  
124:39 - We stopped poppin because the top of the 
stack is shorter, so it can still expand.  
124:45 - You can see that what we're doing is that we're 
pushing our bars into a stack. Then when we found  
124:50 - the next shorter bar from the right, we know 
where they stop, we calculate their rectangle.  
124:57 - Now we push this point we continue this bar 
Higher, we have nothing to pop without clear  
125:02 - push it. But for this one is shorter. So we pop 
this one, and we calculate the rectangle. The  
125:09 - top is still taller, we pop on we calculate the 
rectangle, put weight with this bar, the largest  
125:16 - rectangle that we can make is not this one is this 
one. The reason behind this one result is that  
125:23 - the index of a bar is not necessarily for Maurice 
largest rectangles thoughts, in reality is largest  
125:26 - rectangle thought form where the last 
popped bar thought iterations thoughts.  
125:34 - For example, for this one, remember that we have 
three bars, this one was the last one, it means  
125:40 - that the largest rectangle starts from here. This 
is why when we push bar, we keep the same height,  
125:45 - both as index we put the index where the 
rectangle of the last popped bar starts.  
125:51 - Let's work with a greater example, the 
one we've been working with in this video,  
125:57 - we can add those two bars of height minus 
one extremities to avoid having an empty  
126:01 - stack. First bar, the bar on top is shorter, 
we totally put it on the stack. Next bar,  
126:08 - the bar on top of the stack is taller. So we 
found the end of its rectangle, its Imani spawn,  
126:14 - the top of the stack is not small anymore, who 
stopped poppin. But now when we push this bar,  
126:21 - as high throughput to both as index, we put the 
index of the last pop bar, which is one let's  
126:28 - continue for is taller, we just push with 
this index because we didn't pop anything.  
126:33 - Next bar, same thing. Next bar, same thing. 
Next bar we need to pop. And we found the end  
126:40 - of this bar here is it's rectangle. And 
when we put six as index, we put five.  
126:46 - Next bar, we need to pop here is the largest 
rectangle of the pop the bar is beginning is  
126:52 - the index we pushed and is and is i minus one, we 
can calculate the rectangle and see if it replaces  
126:58 - top is still higher, we pop top is still 
higher, we pop top is still higher, we pop,  
127:05 - you can see that for each prompt bar, you 
can easily find his largest rectangle,  
127:10 - top is not higher anymore, we stop. And the 
starting index of the last pop node is one.  
127:16 - So we put an index of one when pushing the actual 
bar. The reason behind it is that from the left,  
127:22 - our bar can extend until the index one from 
the road we don't know yet. Next bar higher  
127:29 - without the push, next bar, same thing. And 
the process continues like this until the end.  
127:45 - After finishing, we found the largest 
rectangle is this one, we turn this area.  
127:52 - And we've been able to solve the problem 
by traversing the histogram only once.  
127:58 - In code, we start by adding those bars 
of extremities will create Max area,  
128:03 - we'll create a stack and we'll start traversing 
bars. The stack initially contains the first bar,  
128:10 - the one that we added. And you can see that now 
we're storing both the index and the height.  
128:16 - In the previous solution, we stole the 
index only because we could calculate  
128:19 - the heart from the hearts array. But 
this time, the pushed index is not  
128:23 - necessarily the one where the bar is in the 
histogram. So we store both. And this time,  
128:29 - we need to traverse the bar of the right 
extremity to empty the stack to calculate  
128:34 - rectangles of bars that are still in the stack. 
So I start from one and goes until the last bar  
128:40 - at each bar, I will need a variable start that 
indicates for more the largest rectangle of  
128:45 - the bar our thoughts. Remember, that is the 
starting index of the last bar we popped.  
128:53 - But we didn't start popping yet. So we set it 
to I now we start poppin while the bar the top  
129:00 - of the stack is higher or as high as the bar our 
we bought, we put the index and the height into  
129:06 - variables. Remember that we need to calculate 
the largest rectangle of the pumped bar.  
129:11 - It's hard is the pushed height. It's taught 
index is the pushed index. And it's an index is  
129:17 - our minus one. So its width is i minus one minus 
top index plus one, which is I'm on a stop index.  
129:25 - We check if it replaces Max area Max 
area becomes max between its actual value  
129:30 - and top height times I'm on his top index.  
129:34 - And we're searching for the start index of 
the last pop bar. So start receive stop index.  
129:40 - After the loop stock moves the start index of 
the last popped bar and the height of the actual  
129:45 - bar is height of I we push start heights of AI and 
after the outer loop, we're done Max area thoughts  
129:56 - for the time complexity, once again the inner 
while loop will do a Most alliterations in total,  
130:01 - because each bar is pushed and popped only 
once we've got an O of n time complexity,  
130:06 - and for the space complexity off, and 
because of the stack and height array.  
130:12 - We've reached the end of this video. In this one, 
we've seen different solutions to this problem.  
130:16 - I hope that you understood them all. And 
that was the last problem of this course.  
130:24 - Congratulations for finishing this course. I hope 
that you learned a lot of new things from it,  
130:29 - and we'll be able to apply them in all 
the situations. To learn even more. You  
130:33 - can check the other courses I made, like the 
50 popular coding interview problems course,  
130:38 - check the links below. Also, please tell 
me what you thought about this course.  
130:43 - If it's good, if it's bad, what should be 
improved, etc. See you in another occasion.

Cleaned transcript:

In this course you'll learn how to solve 10 Very popular coding interview problems, and you'll learn the theory behind the solutions, so you'll be better equipped to solve other types of problems as well. We'll come to the 10 popular coding interview problems course 10 well chosen problems that cover different algorithms and data structures topics to increase your knowledge and prepare for interviews. Please try to solve before watching the solution prepare yourself and see you in the first lecture Welcome to this video, where we will solve the first problem of this course valid anagram acquired easy problem compared to Knucks wants we are given two strings s one and S two and we are asked to check if their anagrams. Two strings are anagrams if they're made of the same characters with the same frequency just in a different order. For example, with a string standard and garden, we take one of them will rearrange its characters and we get the other one. How are we going to solve this problem? We know the two strings are anagrams if they have the same characters with the same frequency. So what we can do is to calculate the frequency of each character and as one, calculate the frequency of each character in s two and compare the results. But what structure do we use to do so we can use an array where each cell represents the number of frequencies, they all start at zero, then for each character in the string will increment the corresponding cell. This solution is suitable when the alphabet is small, while the number of possible characters is not big. For example, if the strings can only be made of lowercase alphabetical letters, would need an array of 26 elements, it's fine. But it's not necessarily the case. They can contain all the characters. And we have 1000s and 1000s of existing possible characters, the array would take a lot of time and space to create it and traverse it. The best structure for our problem is the hash table structure that maps unique keys to values. In our case, the key will be the coke to other values number of occurrences. For example, if you have nameless and salesman whose name was we get this hash table. And the salesman we get this one. Do they have the same keys with the same values so they're equal? It means that nameless and salesmen are anagrams. Encode who first showed that both strings have the same length, because if they're not, it's impossible for them to be anagrams. Then who grid our two hash tables, and we start to our C for each character and as one if the key is already existing. And for one who does increment else, we created a new set its value to one than for us to same logic, but with freq. Two. And now that we filled them with each other, they have the same values. For each cane frog one, if it doesn't exist in frog two, or for quality isn't able to frog to off key, return false. It means that either the character of us one doesn't exist in our stew, or they don't appear the same number of times after the loop, if we didn't find any difference, we return true. And in Python, we don't ever need to write all this because we have a class named counter in collections module that builds the table of occurrences just by passing the string as an argument. And we can compare dictionaries with the equality operator. So in reality, who does return count off as one equal to count off as two. For the time complexity, in the worst case, as well as to have the same length. Let's name it as we're traversing N characters at most three times, and Sujan. Inserting in a hash table costs are one in average, got off, amp was off and was off and we'll give some of amp on complexity. And for the space complexity, we have an hour for each table because they can contain up to n keys each we got an often space complexity. We still have another solution to discuss. You have to know the two anagrams how the same lexicographically sorted string, for example, with nameless and salesman. If we sold nameless, we get a ELMN s s. I will salesman same thing. So in the second solution, who do salt posturings and compare the results in code, after the equal condition, returns sorted as one is equal to sorted as two. But sorting a string of characters because of n log n time we're doing it twice was after comparing. We've got an off n log n time complexity. And for the space complexity, we have often for the sorted result twice, we'll get an off air space complexity. Who's the end of this video? whistle the valid underground problem, I hope that you understood the ball solutions and seen the next one Welcome back to the course in this lecture rule. So the first and last position problem, you are given a sorted array of integers are an integer target. And we're asked to find the index of the first and last position of target and our if Target can't be found in our return minus one minus one. For example, if our is 2455555799, and target is five, the author's would be to six because the first position of target is to, and his last position is six. First of all, because the array is sorted, all the elements with the same value will be ages into each other. For example, here all positions of the value five are consecutive. It means that the first possible solution is to start traversing the array from the beginning for the first position of target, and keep walking until finding the last position. With our example, we have two four, then five who found the first position we can walk in, we have 5555. This one is the last one, we found the N position, we turn them in code, we start traversing indexes of our and if our phi is equal to target, it means that we found the start position. Now we keep walking while the next element exists and is equal to target y plus one is smaller than length of our and our five plus one is equal to target increment i. After the while loop. INR represents the position of the last occurrence. This is why we return start i and if the fall ends without having returned the result, it means that we didn't find target in our at all return minus one minus one. Know that it's possible to have sought position equal to and position it happens when there is only one occurrence of targeting our for the time complexity on target exists, which covers the part befores first position, third sequence of occurrences and where it doesn't, which covers a whole array. In both cases, which covers almost add elements, where n is the number of elements of our we've got a time complexity of add a cost and space complexity because we're just using n variables. This solution uses linear sir, to give an off on time complexity. Both the resorted so we can think of using binary search. Let's try to use binary search to find the start position. With binary search, you can find the position of an element in a sorted array. But here, we're not searching for any position of target, we're searching for the first one. R is the first position of target if r is equal to target, obviously, but also r of i minus one has to be smaller than target smaller because the array is sorted. So we will use binary search normally, but to add a second condition before returning. Let's try it with our example. Left and right solid first and last element of our as usual. Man, his left password divided by two, we get four here is true that our four is equal to target, but it's not enough our four minus one is not smaller than target. So med is not the starting position of target. But should you go to the left part or to the right part now, our have made is not created on target. So the first position can only be in the left part we continue made is now zero plus three divided by two we get one, our phone is smaller than target. So the starting position can only be in the right part we continue made is now two plus three divided by two which is to have meat is equal to target and our male minus one is smaller than target. So meta represents the first position of target, we return it. In code, we're going to first have an early exit condition for the case where the first element is equal to target with DACA know that zero is the starting position returned zero. By the way, in solutions based on binary search, put as much early exit conditions as possible to handle edge cases and avoid out of bounds problems. After it we initialize left and right at zero and minus one respectively. Zero and r minus one are the indexes of the first and last element of R. Now while of is smaller than or equal to right, we calculate mid index is left plus rho divided by two. Afterward, we have three cases the case where both conditions are respected. where alpha is equal to target on our beta minus one is smaller than target. It means that made is a sort of position we turn it second case are made is smaller than target. It means that we're still before the starting point. position. This is why we take left and mid plus one to start again in the right part. Else, it means that we exceeded the consecutive sequence, or we're excited but not other beginning. So start can only be in the left part, we take rato mid minus one of the wall didn't return the result is means the target doesn't have an existing our return minus one. Now we found this thought in the experts, we still need to find the end index, we can think of just walking starting from start until we find the last position of target. But it would ruin everything we did, because in the worst case, we need to traverse the whole array, which results in an old Anton complexity same as the first solution you guys did to find the end index, we will also use binary search. But the condition is a bit different from the first time when searching for the start position are of men how to be equal to target and our male minus one smaller than target. And for the end position, our med has to be equal to target and our mid plus one has to be greeted on target. Next element has to be greater because it would mean that from the right, we're not in consecutive Target Elements anymore, so the actual position is the last position of target. In code, we just change a few things, the only exit condition occurs now when the last element is equal to talk, it means that the last position of target is in the last index of our n minus one without a return. Then in the three cases, the cases where we will turn mid is when our made is equal to target, and our met plus one is greater than target. For the two remaining ones, he won our main is greater than target, then we exceeded the consecutive sequence, we'll go to the left part, right becomes mere minus one else, it means that either will be for the consecutive sequence or incited but not at the end, so and can only be in the right part, left becomes mid plus one. Now we have our fine salt function, we have our Find and function, we can move to the main solution function. First of all, we have some early exit conditions, who can identify at least three cases where we can't find target role. When the array has no elements, one target is smaller than the first element. And when target is greater than the last element in the last two ones. Because the array is sorted, who can deduce the target is not equal to all other elements. If at least one of these conditions is true, without the return minus one minus one health who co found sought to give the stock position we call font and to find the end position and wait on start. And if Target doesn't exist in our sorted annual have returned minus one bath, we still got the expected result. For the time complexity, we're using binary search twice. And binary search has an awful lot and time complexity because we keep dividing the input size by two, two times of work and gives us all of log n time complexity. Add for the space complexity, you'll get all one because we're just using eight variables. Before ending this lecture, I want to tell you that if you're not comfortable with binary search, you should really work on it because it's a fundamental algorithm technique that appears in many problems on this one, find peek first bad version, and many other ones. Lose Hello this lecture, I hope that you understood the solutions and seen the next one. Welcome back to the course in this lecture, we will solve the cliff largest element problem, you are given an array of integers and an integer k. And we're asked to find the K eighth largest element. For example, if you have are equal to four to 9756713 and k equal to four, the output would be six because the largest element is nine, the second largest is seven, the third largest is seven and the fourth largest is six Firstpost possible solution that we may think of is to remove the maximum element k minus one times because after doing so, the next maximum represents the K eighth largest element. For example with our array K is four. So we remove the maximum element three times first iteration Max is mine we remove it, second iteration Max is seven we move it third iteration Max is seven we remove it now that we finished the three iterations the maximum in the remaining elements is the fifth largest element of the original array, it six here who returned it. In code, we have a follow various repeated k minus one times one remove the maximum element after the loop, return max of all But for the time complexity suited for the maximum cost of n, where n is the number of elements and removing it from the array cost, and in the worst case, because we may need to shift all the n minus one elements, and our loop is repeated k minus one times we'll have k minus one times to add, plus add for finding the final largest element. In total, we have k minus one times two n plus n, which is two times k times n minus n, which gives us off k times our time complexity, where n is the number of elements of our own, although in reality during the iterations, and will decrease because we have less and less elements, but we get the sample complexity. And for the space complexity, we're not using input size related variables, we have a constant space complexity. This solution is a bit slow. Let's move to the next one. The idea of the second solution is to start by sorting the array because by doing so, we know that the largest element is other last cell, the second largest element just before it, the third largest just before it, and so on with our array was sorted, and k is four. So return the fourth element starting from the end, in a gentle way, we sold our and we turn our n minus k, and minus k represents the index of the key elements starting from the end. For the time complexity, we have both analog and for sorting the array and all one for accessing, we've got an O of n log n time complexity. And for the space complexity, it depends on the space complexity or the sorting function. This solution is way faster than the first one except in some cases, but we still have an all the solution to discover. In the first solution we didn't have to solve to it is good, but searching for the maximum cost at each iteration, which slows down the process. What if instead of getting the maximum cost log out only yours is possible by using a priority queue. A priority queue is a queue where the next element to be popped is not the first one that entered with the one with the highest priority. And it's usually implemented with a heap. If you don't know about heaps, and priority queues, you should really watch my YouTube video on the subject, you will find the link below or you can just search for inside code heaps on YouTube. And after building our priority queue, popping the next element because of work out holy, so we just have to pay the cost of building the priority queue, which is add. For example, with our array, this is what our heap would look like, you can see that the element at the top is the greatest one who extracted and it costs of work and to rearrange notes. second iteration will extract the root cause of work and to rearrange to maintain the order. third iteration, same thing. Now that we do the k minus one iterations, the next extracted node is the eighth largest element, we'll turn it here it's six. In Python, we have the hip Q module with a problem is that it's implemented with a min heap, not a max heap. So the top will find the smallest element not the greatest to counter that will just multiply values by minus one to reverse the order. So we start by replacing our by minus ln for each element in our after doing so, we heapify our to make it respect to heap property. And now we really do start extracting, we extract from it k minus one times. After the loop, we extract the last time and return the result multiplied by minus one, obviously, to get the original number though was in our, for the time complexity, who have earned to build a new array with reverse values, and to heapify it, go check the video to know why. And then we have k minus one iterations, each iteration because of work and to extract after the loop, we have all worked out to extract one more time. In total, we have two n plus k minus one times log n plus log n, which is two n plus k log n, which gives a time complexity of of amples k log n, which is a bit better than the one of the previous solution, because k can't exceed add. For this solution, stop giving interesting time performance difference only when n is huge and case small. Because when k is close to an off campus, k log n is close to O of n log n, the time complexity of the previous solution. Pause When k is close to zero, O of n plus k log n is close to O of n for the space complexity who have unfold the priority queue who got an offer and space complexity. We reached the end of this video I hope that you understood the three solutions and see what the next one will come back to the course in this lecture we will solve the symmetric tree problem. We have a binary tree and we want to see if it's symmetric. In other words, if it's a mirror of it Self. For example, this tree is symmetric, because if we take his left part, reverse it, who that is right part. And vice versa, if we take its right part, we reverse it who got his left part. But this one is not symmetric. For example, if we reverse its left part, we don't get the right part. Okay how to solve this problem? To check if a tree is symmetric, what we really need to check is that left and right sub trees are symmetric to each other. Who will focus on that you need to know that for tree problems, the solution is usually don't coercively we process the root, then we call the function on both sub trees and we combine the results. For example, to get the sum of elements of a binary tree, we have the value of the root, then recursively call the function on both sub trees to get the sum of their elements. After doing so, we return root value plus some of left subtree plus some of right subtree. This way of traversing is called depth first search, and it's how we solved the majority of tree problems. Let's go back to our problem, we have two trees, route one and route two and want to check if they're symmetric to each other. First case, both trees are empty. In that case, we return true because they're still symmetric to each other, there is nothing that breaks the condition. Second case, won't we exist, but the other one doesn't. In that case, without let it use it and not symmetric because the node of the tree that exists doesn't even exist in the other one, it's empty, we return false. Third case, both trees exist, but the roots don't have the same value. Here also, they're not symmetric, because in symmetric trees, the roots must have the same value, because when we reverse the tree, the root position doesn't change. And last case, both trees exist, and they have the same root value. In this case, we still can say that they're symmetric, because Okay, the roots have the same value. But we still need to check their sub trees, having the same root value is not enough to serve their symmetric. And if we take two symmetric trees, we can notice that they have the same root value, though the left subtree of the first one is symmetric to the right subtree of the second one, and on the right subtree of the first one is symmetric to the left subtree of the second one. We verified that root values are equal. So we need to try the remaining two conditions. And how are we going to do so we're going to do so recursively, because if you think about it, we're building a function that checks if two binary trees are symmetric, which is exactly what we need. This is why we'll use the same function. It may sound hard to understand, but this is what recursion about a function calling itself. If you're not familiar with recursion, you should really have a look at it before continuing this course because we will use it again in a further problem. If you want to learn recursion, you come to the course I made on the subject. It's a complete and well appreciated course that will let you be comfortable with recursion. Let's go back to our problem. We saw that we use the function we're making, we saw that we use the function we're making. We call it on route one dot left and route two dot right we're called on route 1.1 and route dot left and we tell you at both calls return true, it means that both conditions are verified, the left subtree of route one is symmetric to the right subtree of route to other the rights of drove route one is symmetric to the left of Jove route two. Let's quickly see an example. We want to check if this tree is symmetric, so we check if it's sub trees are symmetric to each other. They have the same root value, so we check the left subtree of root one with white socks off root two, same root value, who took the left subtree of root one with right subtree of root two, same root value, we check left and right, same root value. Other children are both normal they will turn true. Same with value and symmetric children. All conditions are respected, it returns true. Now right up to a fruit one with lots of to fruit two, they have the same root value. Their children on both know both calls return true. All conditions are respected. The caller turns true. Back to here, all conditions are respected. The Colita is true. Now REITs offshore foot one with Latakia for two, they don't have the same root value, the call returns false. Not all conditions are respected. The call returns false. Who don't ever need to check the second call because we already have a non respected condition. The call returns false. The initial call return false so our tree is not symmetric. In code, let's first make our our symmetric function. It takes two trees as parameter route one and route two. First case both don't exist without Q two and true. Second case, one of them exists but the other one doesn't. Third case, they have a different root value. In both of these cases, the trees are not symmetric, so return false will write, if root one is non is not equal to root two is non, or root one dot val is not equal to root two, that wall will return false. And now in the last case, both trees exist and have the same root value, we still need to Chuck's up trees, which are that would wander I'd love to see much to root to the droid. And that root wonder tried is symmetric to root to the left, we do so by recursively, calling the function twice. Once with root one dot left and root two dot right and once with root one or twice and route two dot left, both of them need to return true. So we turn the results combined with the Add operator. And now when our main solution function is symmetric, we first check that the input tree exists because if it doesn't, we cannot return true, an empty tree is symmetric. Else, whichever is sub trees are symmetric to each other with the function who made Now we return our symmetric Rudolph left and rudos. Right. That's it. For the time complexity, we're just performing a depth first search traversal of the input tree and the first cause of anti m where n is the number of nodes. And for the space complexity, a symmetric tree has to be balanced. And the call stack size needed by a recursive function that traverses a balanced binary tree is an awful look at who got an off walk and space complexity. That's it for this lecture, we've seen an interesting problem on trees. I hope that you have been able to understand the solution seen with the next lecture Welcome back to the course in this lecture, we will solve the Generate parenthesis problem, a problem that we will solve using backtracking. By the way, in this course, I try to include problems on different pattern spire research hash table backtracking, depth, first search, and so on. But one problem and each is not enough. This is why you need to study more problems. For that, I suggest you to have a look at my 50 popular coding interview problems course. It contains 50 Problems different from the ones in this course, about many data structures and algorithmic techniques, you can have a look at the curriculum and reviews on the main page. Anyway, let's go back to our problem. We are given an integer n and we're asked to generate all valid combinations of N pairs of parenthesis. For example, with an equal to three, here are all the valid combinations. First of all, what does a vowel combination mean and how to check if a combination is valid. A combination that contains one type of paranthesis is valid. If every opening parenthesis has its closing parenthesis, and it doesn't have a closing parenthesis without having an end used opening parenthesis before it. Let's see some examples. This combination is invalid because these opening parenthesis don't have closing parenthesis the syntax is invalid. Second example this combination is invalid because we have a closing parenthesis without an end use opening parenthesis before it. Last example, this one is valid because each opening parenthesis has its closing one, and there is no closing parenthesis without an unused opening one before it. Now how to check if a combination is valid. To do so we can maintain a stack where we push one we find an opening parenthesis and we pop one and find the closing one. The condition is that we don't try to pop from the stack when it's empty, or the stack has to be empty after we finish traversing the combination. Trying to perform the stock one is empty means that we have a closing parenthesis without an available opening one before it all ones what we found before have been popped by all the closing parentheses. And the second condition is that the stock must be empty at the end. Because still having elements in the stack after traversing means that we have opening parenthesis that didn't gather closing one yet. In both cases, the combination is not valid. And because we have only one type of parenthesis around once, we don't ever need the stock, who can do is use a variable div that represents the difference between the number of opening parenthesis and the number of closing once. It has to be zero the end and if it becomes negative during the process, then it's not valid. Okay, but what's the relation with backtracking? In this problem, we're not asked to check if a combination is valid. We're asked to generate all valid combinations of N pairs. And we use backtracking because at each step of building the combination, we have two possibilities, adding an opening parenthesis and adding a closing one. And because we want all combinations, we try them both because we get new ones want to add an opening one, and all the ones want to add a closing one. Also in backtracking. We can have a condition where we backtrack With continuing, it's one we know that the actual branch won't lead us to a valid solution. In our case, it's one death becomes negative, it means that the combination we built until now isn't valid, it's useless to continue building it, we know that it won't give us a valid combination. Anyway. Let's see an example. With n equal to three, we'll get this recursion tree. If you're wondering why our sauce at six is because the n given us input represents the number of pairs. And in n pairs, we have two advantages. So we multiply by two because we're adding one parenthesis by level one, we go to the left to add an opening one and increment div. And when we go to the right to add a closing one, and decrement, if we can notice that we have branches that have been stopped earlier, those are branches were diff becomes negative. As soon as they've becomes negative, we stop also Evon with branches that created the combination of N pairs, we don't take all of them, we take only those who are divisible to zero, remember the validity condition. So at the end, here are the combinations that get added to our combinations array. Encode who stopped by creating a recursive function rack that will fill the combinations array, it takes us parameters and the number of remaining parentheses to add, def the difference between opening and closing brackets COMM The actual combination that we're building, and comps theory of combinations, the one that we're searching for in our problem. The first base case is one difficult negative, hit it with Dr. Batra Kodaka return to go back to the previous call. The second base case is one we've been able to add all the parenthesis we've been able to build a combination. But in this case, we don't automatically add it to our comps array, we first check if d f is equal to zero. Remember the condition. So if f is zero, we draw the parenthesis of our combination to form a string and we add it to our valid combinations array. Else, we have the recursive case, we said that we have two possibilities, adding an opening parenthesis and adding a closing one. Therefore, who will have two recursive calls. For the first one, we add an opening parenthesis to our combination, then when we call and becomes n minus one because we have one less parent is to add and this becomes the plus one because remember that to add one one will add an opening parenthesis. After the call, we move the opening one we added to put a closing one. After doing so we call the function again. But this time diff becomes diff minus one. Remember that we subtract one when we add a closing parenthesis. And after the call, we remove the parenthesis we added to backtrack to the previous call. And we made our function. By the way, we can ever optimize a little bit by dotclear. Returning if div is greater than add because if is the case, it means that we don't have enough remaining parenthesis to close all our opening parenthesis. div is greater than n. So we just return. If you're confused about what's happening here, have a look again other recursion tree. And most importantly, you should learn more about recursion and backtracking. The method we're using here to generate all possible combinations, it's common to a lot of problems, you should really be comfortable with it. Now in the main solution function, we'll first create an array comps where we will put our valid combinations and we call our QC function to fill it. But the tricky part here is that we pass two times n as an argument not add, because the n given as input represents the number of pairs, nor the number of parenthesis and a pair is made of two parentheses. So we pass two times, our combinations will be of length two times. After filling comps, we just return it for the time complexity. In the worst case, what add a zero, we have a cost of an to join the parenthesis we write T of zero is equal to add n in the recursive case, and again moving from the combination cost of one, but we have two calls where the input size gets reduced by one and is becoming added minus one in total t of n is equal to two times u of r minus one plus one. Now we keep replacing t of n is equal to two times t of n minus one plus one. So T of N minus one is equal to two times t of n minus two plus one we replace or simplify and we got four times two and minus two plus three. We replace again, t of n minus two is two times two of Armani three plus one will replace will simplify and we get eight times T of animal is three plus seven. This recurrence relation is a common one we can already notice the drill form. It's t of n is it To power k times t of n minus k plus two power k minus one, we have the value of T of zero, so we need to find the value of K to go to T of zero and minus k equal to zero. So k is equal to n, where plus k by n, who got t of n is equal to two power n times T of zero plus to power n minus one. We know that T of zero is earned workplace, we got t of n is equal to two power n times n plus two power n minus one would give us an O of n times two power n time complexity. Know that here and represents the length of the combination, which is two times the number of pairs given us input. Also, n times two power n is not the exact power, the number of operations will be less than that do two branches where we backtrack earlier, O of n times two power n would be the exact bound if we had no condition on our combinations. If you don't know the technique are used to find the time complexity over this recursive function. It's called the substitution method, it's an important technique to know you should learn about it. And for the space complexity, we have n plus one for the cost like size, the length of the longest branch in the recursion tree. But we also need to count the required space to store the combinations. The length of a combination is at and it has two possible characters. So we have two power and possible combinations. And the length of each one of them is n. So we need n times two power n space to solve them. We got off on times to power and space complexity. But not all of them are valid, we will need way less than n times to power n, n times two power n is just an upper bound. And we all t the required space for combinations is n times the number of elements after filling the comms array. We reached the end of this lecture, I hope that you understood this backtracking solution and see you in the next one. Welcome back to the course in this lecture rules or the gas station problem are given a circle a list of gas stations where we can go from Station II to the station i plus one, and the last one goes back to the first one. And we are asked to find the index of the station from where we start to be able to traverse all the stations and go back to the initial one without running out of gas. Know that we can only move forward the gas tanks thought empty gas of i represents the amount of gas at the station i cost of iron presents the cost to go from the station out to the next one, the answer is guaranteed to be unique. And if the station we're searching for doesn't exist return minus one we did use or there will be at most one station for more we can traverse and be able to go back. For example, if we have these 10 stations, the output is eight because when we start from station eight, we can go back to it without running out of gas. We start with no gas, as mentioned the the problem, we add for gas of station eight and we pay one to move to the next station, who add five gas of station line and we pay two to move to the next station, we add one and pay five who add five and pay two, or three and pay two, or three and pay eight, we add five and pay two, or three and pay for we add one and pay two, or three and pay five, and we've been able to go back to station eight, you could see that the amount of gas never became negative. Which is not the case for Office stations, for example with station one who add five and pay two, or three and pay two, or three. And if you pay the eight to move to the next station, the amount of gas becomes negative, which means that we can't continue, the station we started from is not the right one. Let's solve this problem. A brute force solution of a darkly comes in our mind is to simply simulate what happens with every station and we find one that respects the condition who turn its index. Let's try it with our example. With the first one, we add one with a five and the cost becomes negative Dr eliminated. Next one, we add five and P two we have three and PE two, we have three and PE eight air the amount of remaining gas became negative not this one. Next one, three and PE two we have three NP eight and remaining became negative. Next one, we have three NP eight remaining became negative. Next one, we add five and pay two or three and pay for we add one and pay two or three and pay five and remaining became negative not this one. Next one, we add three and pay for negative. Next one, we add one and pay to negative next one who has three and pay five negative next one who have plus four minus one plus five minus two plus one minus five plus five minus two plus three minus two plus three minus eight. was four minus two, plus three minus four, plus one minus two plus three minus five. And we've been able to go back to the station from where we started without the alternate because we know that the answer is unique. In code, we create a function that takes us parameters, the array gas theory, cost, and index of the station form where we thought the goal of this function is to tell us if we can finish the cycle by starting from the stations thought, we first need a variable remaining that source the remaining amount of gas, we also need the variable to store our actual position. Our initial position is the station FOMO, we thought so initialize our add start. And we also need a boolean variable started to know who started walking yet or not, we need this variable in our loop condition. We need to keep looping until we go back to start, we write why isn't equal to start or not started. Here not started is important, because if we don't use it, we won't even enter the loop. Remember that I initialize a stock. So I installed our equal, we want them to be equal. But after traversing the cycle, not now this is why we need the variable started to know if we're in the case, where is equal to start, because we didn't start yet. Or because we traverse a cycle, and I went back to start. Let's continue inside the loop we saw started to true because we started then we update remaining. We saw that on the station i We are the amount of gas in it, and we pay the cost to move to the next one. So we add gas of our answer drug costs of I. After doing that, if we mainly becomes negative, it means that we couldn't go back to salt, we don't have enough gas, we return false, else, we move to the next station. The next station is usually i plus one. But we need to add modules the number of stations to handle the case were of the last station i becomes i plus one add modules and it goes back to zero, we right i becomes a plus one modules the number of stations. And if we finish the loop, it means that we've been able to go back to start return true. Now in our main solution function, we just tried the function we made on each station as we did in the example. And we turn the actual station as soon as the function returns true. And if the function fails with all stations will to n minus one for the time complexity, because the answer is unique. A possible worst case is this one, because by starting from station zero, which covers n stations before getting a negative amount from station one, which covers n minus one from station two, which covers n minus two, and so on, we get the sum n plus n minus one plus n minus two and so on until one. After simplifying, we found that it's an O of n squared, we'll get an O of n squared time complexity, or the constant space complexity because we're not using input size related variables of n squared is low. For this problem, we're getting off n squared because for each station, we're traversing again, almost all the stations, let's see how to optimize it. The main thing that you need to understand for the second solution is that if we start from the station or the index thought and reach a negative amount of the station I then all stations between Staten Island clauses are not valid. We don't need to try them with Dr. John to Iboss one. Let me tell you why. We have the case where gas of thought is smaller than cost of start. He the loop stops darkly because remaining becomes negative, it stops us thought so there are no other stations involved. Nothing to talk about here. But when gusoff Start is greater than or equal to cost of salt, the loop moves to all the stations, it can traverse a bunch of stations before remaining becomes negative. For example, here when we start at station four, remaining becomes negative at index seven. It means the stations 456 and seven are all invalid. We'll start again from purpose one, eight. But why girls will start is greater than or equal to cost of start. In our case, the difference is three. Every three is considered as an advantage over starting from next stations is like a bonus by starting from station four. We have three more gas and installing from the next one, station five. And even with that bonus, we didn't have enough gas to do a full cycle. We stopped at station seven avenue that bonus we couldn't go over station seven. So how do you want to go over it without a bonus? It's like you have $500 and they aren't enough to buy a particle PC. Then you say this $500 weren't enough. I'll try with four hundreds maybe they will be enough. It's a logical and this is why when remaining becomes negative. We don't try again from the station that comes after The one where we started, who skipped all the ones who traversed we started going from IPOs. With our example, who start from the beginning, we may name becomes negative who's taught from IPOs one at five and we pay two remaining becomes three who are three, we pay two remaining becomes four, who else we pay eight remaining becomes minus one negative. What we're going to do now is to dock the start again from here, without trying again, from stations to three, who add follow up to remaining becomes three, who else we will pay for remaining become Sue, who add one who pay two remaining becomes one who has free will by five remaining becomes minus one negative. Once again, without his thought, again, from i plus one, we add four we pay one remaining becomes three who add four who pay two remaining becomes six, and we finish traversing the array, the candidate is station eight. But it doesn't mean that it can do a full cycle, it just means that we can reach the end of the array without reaching a negative amount of gas. We didn't check the pot before it. This is why I said candidate. It's a potential valve station. We don't know yet. To say that a candidate station is valid by starting from their remaining Miss never become negative one traversing the path from candidate to the end. But also when traversing the path from the beginning of the array to candidate X clause. The first part of the cycle is what we verified during the traversal. And for the second part of the cycle, we just calculated the sum of gas from zero to candidate minus the sum of costs from zero to candidate, the result represents the remaining gas after traversing that pot. And if by adding it to remaining the result stays positive, then candidate is a valid station. Else we have no valid station. For example, here the sum of gas from zero to candidate exclusive is 24. The sum of course from zero to candidate exclusive is 30. The difference is minus six. What remained from candidate to the end is six what remains in the pot before candidate is minus six by adding them together we get zero which is positive. So candidate is the valid station. Question. What if we got a negative result here, then with Akutan minus one because there is no valid stations. But what if the valid station comes after the candidate, it's impossible. Once again, the station forma we started candidate has an advantage over next stations, we know that gas of candidate is greater than or equal to cost of candidate. So even if with that bonus, we get a negative remaining amount of gas, it will also be the case for next stations. Let's jump to the code on the side all of this remaining starts at zero. And same thing for candidate because at the beginning, we assume that the first station is the candidate, the potential valley station. Now we start traversing stations. For each station, we update remaining gas, we are guests of our answer truck cost of AI. And if remaining becomes negative, we sell that to start again from APL small, it becomes a new candidate, and remaining becomes zero because we will start again. After the loop, we calculate the remaining gas of the pot before candidate the sum of gas minus the sum of costs of the pot from zero to candidate X clause IV. Now we have three possible cases we have the case or candidate is equal to and it means that we reached the end of the array without finding a potential station, no station made it to the end of the array, we return minus one. So in case we have a candidate, but when adding prev remaining, we found the negative result, it means that it stopped somewhere in the pot from zero to candidate return minus one. And third case, we have a candidate and remaining plus prayer remaining is not negative. So candidate is the false station for more we start to be able to do a full cycle, we return it. In code. If candidates is equal to length of gas, the number of stations, or remaining prosperity remaining is smaller than zero, we return minus one else we return candidate who can even keep track of remaining in the first loop to avoid traversing again to calculate the sums. For the time complexity, we just have a loop that does n iterations all other operations are in over one, we get an off and on complexity, where n is the number of stations much better than O of n squared. Add a constant space complexity because we're not using inputs all related variables. Basically, in the solution, we search for the candidate the station that made it to the end of the array without reaching a negative amount of gas. Then we check if it still boosts up when traversing remaining stations, those in the pot from the beginning of the array until going back to it who's the end of this video. I hope that you understood the optimal solution and see what the next one Welcome back to the course in this lecture rules of the course scheduled problem, we have n courses labeled from zero to n minus one in clauses that we need to take. But some of them are prerequisites the other, we cannot take a course before taking the other one. And we have to determine if it's possible to finish all the courses. So we are given an integer as representing the number of courses and an array prerequisites who are prerequisites of r is equal to a b means that you first need to take the course P before taking the course a. For example, if we have this input, the output should be false. Because to take course three, we must have taken course zero, and to take her zero must have taken course one. And to take course one, we must have taken course three, it is impossible, it's like we have a dependency cycle. This is why we cannot finish all the courses return false. But with this input, the output is true, we can take or zero then course three, then course one, then course five, then of course two, that course for each course will have its prerequisite satisfied when taking it. How to solve this problem. Here we have elements, courses and relationships between them, of course being approved was that of a novel course. And every time we faced this situation, having elements and relationships between them, you should think of using a graph. I'm not saying that it will always give the best solution. But even if it doesn't, it will at least give you a way to visualize the problem with vertices and links between them. In our case, the vertices represent courses and edges represent dependencies and add from u to v means that we first need to take the course you before being able to take the course fee. Okay, now we build our graph, we got a directed graph what we will do with it. Our goal now is to search for dependency cycle. If we find one, it means that it's impossible to finish all the courses return false. Else if we don't find one at all, it means that it's possible to finish the mole return true. Basically, we're searching for a cycle in a directed graph. In a linked list, a classic way to check if there is a cycle is to traverse a linked lists while saving visited nodes. And if we step on a node that we visited before, it means that there is a cycle. We can think of applying the same logic for graph which covers with depth first search, for example, while using a set of visited notes. And if we step on a node that has already been visited, it means that we have a cycle return false. By the way, if you don't know about the full search, it's a way of traversing trees and graphs by diving deep into a direction until we can move forward anymore. Go back, try and all the way and so on. I made a huge video about the subject that you can watch. You need to know about DFS before continuing this video is a prerequisite intended pun. But this strategy doesn't always work. Here is a counter example. We have this graph let's start traversing. We start for example from two we put it in visit it we move to zero we pull it in visit it will move to three we pretend visit. This one has no outgoing others, we backtrack, this one has no remaining neighbors to traverse we backtrack. From here we move to the second neighbor one we put it in visit it will move to four we put it in visited. Then from here we move to three and it's already in visited so our strategy would return false. Which is wrong because we can totally finish all the courses here. We can start with two then zero then three than one than four, all prerequisites are respected. Was the solution done? Well, let me first talk about topological sort. We have a directed graph where vertices represent tasks and an ad from u to v means that u is a prerequisite of V. topological sort is the process of finding a linear ordering of vertices such that each vertex comes after is perquisites. And all the words, for each edge from u to v, V must come after you in the ordering. For example, for this graph here is a valid ordering. Know that a valid ordering is not always unique, it's possible to find all the orderings that satisfy the condition. But the logical sort is not always possible. It's not possible when the graph contains a cycle like this one. B is a prerequisite of C, C is a prerequisite of D, D is a prerequisite of E and E is a prerequisite of B, so we have no way to order them. Fortunately, while performing the topological sort, we can detect the existence of a cycle. If it happens, we just stop and say that we cannot have a valid ordering of vertices. And it's exactly what we want to do in our problem who have courses. Some of them are prerequisites the other ones, and we want to know if we can take all the courses and all the terms if a valid ordering exists. Therefore, who will use the biological source and if during the process, we found the cycle return false. Otherwise return true because it means that we've been able to make an ordering. Okay, but how does topological salt work? A possible way to implement a biological source is depth first search. Let's, for example, soft foam this vertex, we put it on the past stack, the pastor contains the vertices of the actual path. B is its neighbor, we go to it, and we put it on the past stack is his neighbor, we go to it, and we put it on the path stack. He is his neighbor, we go to it, and we put it on the path stack. Now it has no neighbors, it means that we can safely put it in our ordering, because there are no vertices that have to come after it is perquisite of no one, we put it in the order stack and we backtrack to the previous node. Next neighbor is I will go to it and we put it on the path stack. Same again, it has no neighbors, who remove it from path stack and pull it on all the stack. And we backtrack. Next neighbor is if we go to it, J is a neighbor, we go to it, it has no neighbors, we move it from path stack, we put it on all their stack, and we backtrack. Next neighbor is all but it's already visited. It has no more unvisited neighbors, so all vertices have to come after it in the ordering our visit, we can safely put this one and we backtrack. This one also has no more unvisited neighbors, we can put it in order staff, and we backtrack. And the process continues like that. Until we traverse the whole graph of the end, we get this ordering, we reverse it together from the beginning to the end. Now the opposite. encode our DFS function takes us parameters to graph the vertex promo we start the path stock, the oldest stack and the set of visited notes. We start by adding our vertex to the past, just when we start traversing it, then for each unvisited neighbor, who first added to visit it, and we call DFS with it as an argument to traverse it. After doing so for all the neighbors who can safely put the actual vertex on the oldest stack will pop up from past stack and give it to all the stack. And in our main top sort function, it takes us an argument the adjacency list of our graph, it squares the visit itself, the Bastok, the older stack, then it visits each unvisited vertex with DFS. After doing so, the other stack is filled with turns reverse together the ordering from the first vertex to the last one. Now the opposite. And starting from this algorithm, we can add instructions to detect cycle we find the cycle when you find a back arch, and as that goes from vertex u to a vertex V, where V is already in the path stack. Like here we have a B, C, D, E, then he has B as a neighbor, which is already on the path stack. This graph contains a cycle B and E depends on each other. In Code, our DFS function will not be a Boolean function. It returns if yes or no we've been able to make an ordering. What we add is that before moving to a neighbor, we check if it's not already in the stack. If it's the case, without a return false, we can't make a valid ordering. Also, if traversing enable returns false, it means that we found a cycle one going from there. This is why if the recursive code turns false, will also return false here. And if we've been able to traverse neighbors without getting a negative result return true, we could make an ordering. Know that to optimize checking for the existence of the actual vertex in the stack, it's better to use a set instead of a list searching and assert is an old one time an average pass doc now is of type set at the beginning we add our vertex to it after the Lupu move it out to add it to all the stack. And in our main solution function, we first need to build the graph because input will have the number of courses and the list of prerequisites. Now the adjacency list to build the adjacency list, we know the number of vertices so we create an array of N empty arrays. Each one will contain neighbors of the course I know which are first prerequisites of the problem says that prerequisite of one has to come before prerequisite of zero. So create an ad from prerequisite of one two prerequisite of zero. In other words, who add prerequisite of 02 neighbors have prerequisite of one. Now that we've built the adjacency list, we can start traversing but before we create the visit itself, the past arc which is also a set on the order stack, For each and visited course, who added to visit, and if calling DFS with it returns false, it means that we couldn't build the old, we found the cycle. So return false, who can't study all the courses out of the loop doesn't return false, it means that we could find an ordering because all the order courses return true. And we've been able to solve our problem. For the time complexity, we're just performing dub for search on a graph. And the time complexity of DFS is often for v plus length of E, will length of v is the number of vertices and length of E, the number of edges, ie the number of vertices is the number of courses and, and the number of edges is M for length of prerequisites list, who got an off campus and found complexity. And for the space complexity, we have the space for the adjacency list length of v plus length of E, the space for the visited set length of v, the space for the path stack, and the older stack length of v and the space for the call stack length of v in total, who got full times length of v plus length of v, which is an awful length of v plus length of v, who does have apples. Know that you may find a similar solution. But with collars each vertex can have the color white, gray or black. Compared to our solution, what means and visited. Green means visited and in the past dark, and black means visited add not in the past anymore, we've put it in the order. And if we found the neighbor that is great, it means that it's in the actual path, and we found it again. So we have a cycle return false. No implemented topological sort with depth first search. But we can also implement it with breadth first search. Let me show you how. If you don't know about breadth first search, I made a YouTube video about it, I recommend you to watch it before continuing this one. The general idea of our second solution is to split our directed graph into levels and the first level, we have vertices that have no prerequisites, we'll conduct this thought studying them. Once we finish, we can remove them from the graph by removing them from the graph. So vertices won't have prerequisites anymore, because their prerequisites were courses we just started and they're satisfied. And these vertices represent the second level, we'll put them in our ordering and remove them after removing them, so vertices won't have prerequisites anymore, they represent the third level, we put them in our ordering and remove them. And the process continues like that until we have no more vertices. Both removing vertices from graph costs on time, because we need to update the adjacency list. Instead, we'll keep track of the integral of each vertex and when we traverse a vertex, we decrement the integral of all these neighbors, the in degree of a vertex is the number of edges that are entering it. For example, the integral of this vertex is to so when we remove a vertex that is going to it would decremented in degree and if the integral of a vertex becomes zero, it feels at all its perquisites are satisfied, who can traverse it, we put it in the queue. With his graph, we call the integral of each vertex, we search for vertices with an integral of zero, we put them in the queue and you apply classic BFS traversal. The difference is that when we pop a node from the queue, who start by putting it in the ordering array because it has no remaining prerequisites, also want to traverse a neighbor with decremented in degree, and if it becomes zero, we put it in the queue. Last thing would not need a visited set, because we're not putting a vertex in the queue until we finish traversing all vertices that are going to it. So we don't have the risk of traversing a vertex again. With this graph, this is what happens. Encode will create an array of an empty arrays as we did with DFS, but we'll also add an array of N zeroes to solve the integral of each vertex. Now when filling the adjacency list will also increment in degree of prerequisite of zero because prerequisite of zero is the vertex where the edge enters, so incremented in degree now we'll create an array where we'll put our ordering and a queue. The queue initially contains vertices hoes in degrees zero, after it will start traversing while the cool still contains elements will pop a vertex we add it to ordering because it has no unsatisfied prerequisites, and we traverse its neighbors for each With different methods in degree, and if it becomes zero, we incue it as explained earlier. After the loop, the other array is not filled, we return it. This time, we don't need to reverse it because we started by putting vertices of level zero than one and so on. With this topological sort algorithm, we can also detect cycles. When the graph contains cycles. What happens is that at some point of the process, we will have no more vertices with an index of zero, which means that nothing will be inserted in the queue, the process stops earlier, the array will contain less than the total number of vertices, who will deduce that the process couldn't continue because there is a cycle. And in our problem, who just want to know if we can make an ordering or not, this is why after the loop, who will just compare the length of the order array with add the number of courses either equal, the algorithm returns true, else it returns false. So we keep the same code who just changed the return statement with a length of order equal to add. For the time complexity, we're just applying breadth first search, which has an off length of the plus length of a time complexity O of n plus m in our problem. And for the space complexity, we have length of v plus length of a for the adjacency list, length of v for the in degree array, and length of v for the queue of the ordered array, three times length of v plus length of V gives offline for v plus length of E, which is of m plus m and our problem, we get an off campus M space complexity. We reached the end of this video in this one, we solve the CO schedule problem with two different ways. I hope that you understood them both and seen the next one. Welcome back to the course in this lecture, we will solve the Kieth permutation problem with a range of numbers from one to n in clause IV, who can make n factorial permutations. by labeling them in order starting from one, you're asked to return the Keith permutation. For example, with n equal to three and k equal to three, here are the three factorial permutations of 123 labeled animateur K is three, so we turn the third one to one, three. The first solution that may come in your mind is obviously the brute force solution, generating all the permutations doesn't return the case one, we give to the function the range from one to n in closet, then we return the one at index k minus one. Remember that an array is zero indexed, so the Keith one is at index k minus one. But the problem with this solution is that with n elements, we can make n factorial permutations of lung add that it costs n times n factorial to generate them, we get n or m times n factorial time complexity Soulshine, which is extremely slow. We did use the tree to solve this problem is to be able to find the permutation without generating the permutations. And this is what we'll see now. Let's take n equal to four. Now take a paper or notepad software, list all the permutations of 1234 in order and tell me what do we notice, I want you to take some minutes to analyze the structure of those permutations. Here are all the permutations we have a total of four factorial permutations 24. Who can notice that these 24 permutations can be divided into four parts. The first one contains permutations that start with one, the second one contains permutations that starts with two, and so on. Let's suppose that we want to find a 16th permutation k equal to 16. If we label them starting from zero, it means that we want to find the permutation 15. Because 16 is one we label them starting from one. The question now is, can we find what part among these four parts of permutation 15 will be? The answer is yes, by using math. We know that the first part contains permutations from zero to five in clause, the second one from six to 11 in closet, the third one from 12 to 17, in closet, and the last one from 18 to 23. In Closet. To find which one we'll just divide K by the length of a part, which is six in our case. 15 divided by six gives two so the permutation 15 won't be in the pot zero won't be in the pot one, but it will be in the part two. Now that we're working with zero index labeling, we know that the part two contains permutations that starts with three. So we already know that our Keith permutation will start with a three and it will be one of these permutations. Let's continue. What's gonna happen now is that the search space will be reduced. Now we know that our case permutation will be in these six permutations. We need to update variables. K needs to be more Initially we were searching for permutation 15 Among all the permutations, but in this group of six permutations, we're searching for permutation three, why three, because 15 and model six, the length of the pod is three. Case 15, when we start from permutation zero, but in this particular part it will label permutation starting from zero, whose solution for permutation three, and also represents the number of remaining elements of the permutation to find and found one, so we decrement and becomes three and factorial also changes it becomes three factorial six. Same thing for pot length, it also gets updated six divided by three is two. We also remove three from a news elements because we already found its place in the permutation, and our permutation doesn't contain duplicates. Who can divide these six permutations into three parts of two elements, the first part contains permutations holds the second element is one, the second part contains permutations hosts the second element is to other third parts contains permutations who is the third element is 41214. All the elements or two we didn't use it in our permutation. Case three now can we find the pot case permutation belongs to yes once again we divide by the pot length, three divided by two gives one so the case permutation will be in part one. And we know that permutations of Part One have to our second element, so the second element of our permutation will be to, again the search space will be reduced we know that our kid permutation will be in these two permutations. This is why we update the variables k gets modified as we did previously, it becomes k models the length of part three models two gives one it means that among these two permutations, we're switching for permutation one, and gets decremented it becomes two which changes the value of n factorial two factorial is two. Which also changes the value part length, and factorial divided by n is two divided by two which is one. We can divide these two permutations into two parts of one permutation, the first part contains permutations holds the third element is one, and the second part contains permutations holds the third element is for, to know the path or case permutation belongs to, who divided by the port land, the path length here is one and one divided by one gives one, our permutation will be in part one. permutations of part one how for as a third element, so the third element of our permutation will be four. We do use the search space we know that our permutation will be in this part of one permutation, we update variables, k becomes k models the port length, one model is one zero, and becomes one and factorial becomes one pot length becomes one and we move for from a news elements. We divide this one permutation into one part of one permutation. The first part will contain permutations host, one is the fourth element, the length of a part is one, and k divided by one gives zero. So our K permutation will be in pod zero. And permutations of pod zero have one is fourth element. So the fourth element of our permutation will be one now and becomes zero and it gets decremented. So we'll finish the process. The case permutation is 3241, who found it without generating all the permutations. If you didn't understand what we've been doing here, let me show it to you in another way. You first need to understand how our permutations generated are the beginning who have no choices forming this example. And because we want all the permutations, we try all possibilities. When we add one when we add 212 and three, add one, add four, this is why you're seeing four branches are the beginning. And we're talking about permutations without repetitions. So when we take an element, we remove it from possible choices. This is why when we take two other beginning for example, lat branch creates three branches only not 411111, a three and one one, we add four, you can see that we didn't add two again. And when we take four for example, we have two choices left one or three, we get two new branches only. Then when we take one of them, we have one choice left, the one we didn't take part in our problem we want to find the case one. The way we solve this problem is by using math to calculate what branch we should go from to reach the combination we searching for. Imagine that you have 1000 books labeled from zero to 999. Let's say that you're searching for the book 436 You remember that these books are organized into Turn boxes have 100 elements. The first one contains books from zero to 99, the second one from 100, to 199, and so on how to know which book to search, and you simply divide the number of the book you're searching for by the size of a box, because here they have the same size. 436 divided by 100 is four, we searched in box four, we still didn't find the book, but we reduce the search space. Now, we will search for book 36 In this box of 100. Why, because 436 modules 100, the pot length gives the receipts. Once again, the 100 books of the books four are organized in 10 boxes of 10 books each, the first one contains books from zero to nine after for hundreds, the second one from 10 to 19, after for hundreds, and so on. The book size is 1036 divided by 10 gives three, we search in box three. In that box three, we search for book six because 36 modulus 10 is six, so on and so on until we found the book without traversing all the books. And basically this is what we did to solve this problem. Let's try to generalize or the beginning we'll have n k add in us that contains elements in the range from one to adding clause if now while n is greater than zero, who stopped by calculating the port length, it's an factorial divided by n. After it, we calculate the index of the next element to put in the permutation. Remember that we calculated by dividing cable the port length, after we calculated we add an use of either the permutation either deleted from unused who add an use of oil because it represents the common element in the if part. Then we decrement n and k becomes K model a spot length to get its new position in the path that we choose. who keep repeating that and when a becomes zero, we have our case permutation and we solve the problem. In code, we have a function that takes as parameters and key the given input or create an empty array for the permutation we're searching for. Then you create and used, it contains elements of the run want to add in clause if afterward to avoid all is recalculating our factorial recruiting the very fact we're factoring it represents a factorial, it contains n plus one elements to have the values from zero factorial to n factorial. To fill it, we know that zero factorial is one. And for remaining elements, we just take the value of the previous cell and we multiply it by I, for example, with five who got 1126 24 120. Now we decrement k, because k represents the position of the permutation with one index labeling, but we're working with zero index labeling, okay becomes k minus one to fit. We're working with zero index labeling. To simplify the math, we get the right result when we divide and use modules. Who can start the loop now, while n is greater than zero, Portland is an factorial factor of n divided by an avant the index of the element to take is k divided by potluck. After getting the index of the next element, which is I who are unused of our to our permutation, and we delete the element at index i from N used before moving to the next permutation with decrement N, and k becomes k models pot length. After the loop, our permutation is built, we just join its elements into a string and return it will return the case permutation as required by the problem. Basically, the solution will may now use this math to keep calculating the part of the case permutation belongs to, because by knowing it, we know what is the next element to take from unused and use, which is the array of elements we didn't use yet. For the time complexity, creating a news cost and creating factory costs are plus one and film get costs. And then the while loop gets repeated while and is greater than zero. And Angus recommended that each iteration, so the number of iterations is equal to the initial value of an inside it, all operations are in all one, except popping the element I found and used can have the case where we need to shift all the elements to the left and entered all the elements of the permutation were four n plus n squared plus one who got an O of n squared time complexity, way better than O of n times n factorial of the first solution. And for the space complexity, we have n for a news and permutation and n plus one for fact array, two m plus one gives us an O of n space complexity. Where is the end of this video? I hope that you at least understood the general idea of the second solution, which is dividing the perimeter Asians into pause with a common element and calculating which part of the key permutation belongs to see you the next lecture Welcome back to the course in this lecture, we will solve the minimum window substring problem, we have two strings SN T, and we're asked to find the shortest substring of us that contains all characters of T. If such a substring doesn't exist, return the empty string. For example, if we have this input as output, we get C E A, B, E, ba, is the shortest substring of our salt contains all characters of t, in all the words, two A's, one B and one C. First of all, how can we know that a string contains all characters of another one who can't know it by having the counter frequencies of each string, the one we use in the valid anagram problem, if record is the counter of as one and for to the counter of as two, for every distinct character of as two for one of CH must be greater than or equal to for two of CH in other words, as one must have at least the number of occurrences of CH and s to encode will write for each CH in for two. If rec one of CH is smaller than freq, two of CH will return false after the loop return true. Knowing this, we cannot really think of a solution, the brute force solution, which covers all possible substrings of us while keeping track of the shortest wall that has all characters of t. In Code, who can add an early exit condition. If t is longer than us, we can't find the substring that satisfies the condition, there isn't enough characters without glue join the empty string. Same result when t is empty, who can return the empty string, because technically, the empty string contains all the characters of the empty string. Else who first create a counter for T to know the frequency of each character in it, let's name it for t. We also need the string shortest that represents the shortest valid substring that we found until now, it initially has amples one characters to be sure that it gets updated as soon as we found the valid sub train. Now we start traversing substrings of us to do so we start by traversing the length, because we will start by traversing substrings of one character than substrings of two characters and so on. This is why learn goes from one to adding clauses inside it, whichever starting positions, because with the same length, we have the substring the source at index zero, the water source at index one, and so on. But it doesn't go until the end to avoid going out of bounds when adding the length I goes from zero to n minus length in clause if we have the starting position, which is I will have the length of the actual substring. So we can extract the actual substring is the one between I in clause 11 i plus length fix clauses. Now that we got the substring, we'll create a counter for it. Let's name it for us, after it will give the actual substring replaces the shortest one who found until now, for that two conditions, the actual substring must contain all characters of t, we can't know it when the function we made and it must be shorter than the actual shortest one. The length of the actual substring is length. So if length is smaller than length of shortest will replace shortest becomes the substring. After the loop who don't don't quote on shortest, because it's possible that we didn't find any substring that contains all characters of T to know that we took the length of shortest. If it's still n plus one, it means that it doesn't get updated, we return the empty string as required by the problem, else return shortest. Basically, we return shortest one is length is at most n. For the time complexity, let's say that n and m all lengths of Sn T respectively, will have N for building for T and n plus one for creating shortest. Then we have n iterations for the outer loop animal's life plus one iterations for the inner loop. And inside it the cost of extracting the substring. And generating the counter depends on length. We also have the cost of checking if it contains all characters, which is because in the function which covers characters of reg T, their number is at most m we get this sum which is equal to one divided by six times n times m plus one times three M plus two and plus four was simplify. And in the worst case, T is shorter than s. So M is smaller than n. We're going off and coupon complexity. And for the space complexity, we have amphiphilic T amples, one for shortest and for sub n n for fracas we'll get three and Paul samples one, which gives them off samples and space complexity. This solution is obviously very slow is not the best one. This is why we will move to the second solution. Inside the inner loop, we have a cost of length to extract a cost of length who generate the counter and cost of arm to check if it contains all characters? What if we try to reduce this cost to over one? To get a constant cost per in a loop iteration? Follow me well, how can we extract the substring and old one? In reality, we will need to extract the substring and our second solution, who will just work with the start and end indexes of the substring? Which are i and i plus length, we already know them. Second thing, how can we generate the counter of the actual substring and oh one, the trick is to not always build the counter again, who will use the one of the previous substring. Let me show you how. Emergent that we have this string, US ABC a D CB AC. And the first sell triangle five characters has this counter two A's, one B, one C and one T. Starting from this counter, how can we get the counter of the next substring of five characters, which is this one? To do. So we'll just increment the number of occurrences of the character that went out of the window and increment the number of occurrences of the character that went in the window. The one that went out is a it was in the first substring, but not in the second with decrement fracks of A, it becomes more than the one that went in is he it's in the second substring, but not in the first one who increment for x of e, it becomes one. And we got the new countering old one because no matter the length of the substring, we need to work on two characters, only the one that went out and the one that went in, there will always be only two because we're moving by one position at a time. Then for the next substring. Same logic, the one that went out is B so with the command for X of B and the one that went NTC. So increment for x of C. And the process continues like that for all sub strings of length five. The technique we're using here is called sliding window. In our example, we were using a window of length five. Then to move to the next substring we don't start again from the beginning, we just move the window by performing the necessary changes. And we just focus on what went out of the window and what entered not what's inside because it won't change. Last thing to optimize the cost of checking if it contains all characters, the cost is actually M because we need to traverse characters of rec T Mobile let me show you how to optimize it. In our example, T is ABC a it has three distinct characters A, B and C. So we have three conditions to respect to say that our substring contains all characters of t, the conditions are at least two occurrences of a at least one occurrence of b, at least one occurrence of C. The idea to avoid always traversing all the characters, which can cause um, is to keep track of how many conditions are satisfied. And for the actual substring, the number of satisfied conditions is equal to the length of reg T, which has a number of distinct characters of t, then the actual substring contains all characters of T It's a valid one. Okay, but some characters are going out of the window and some of them are accurate, which means that when moving the window, some satisfied conditions can become unsatisfied, and vice versa. Some unsatisfied conditions can become satisfied how to handle that. To do so, after incrementing the number of occurrences of the counter that went in, if it's in fact T and frakkers of want n becomes equal to FRAC to point n, it means that we didn't have enough occurrences of the characters that went in. And now we do so a new condition is satisfied, who increments satisfied. And before decrementing, the number of occurrences of the character that went out if it's in fact T and for us of one out is equal to for active one out, it means that we had enough occurrences of the characters that went out, but after decrementing, we won't because for us of one out will be smaller than what's required. This is why we Diekmann satisfied, a condition that was satisfied before is not satisfied anymore. And we decrement for x of one out obviously. For example here we have these strings SN t and we have this window of seven characters, the conditions are at least two occurrences of a at least one occurrence of p at least one occurrence of C. Here we have one occurrence of a two occurrences of B and one occurrence of C. Only two conditions are satisfied not enough. Let's move the window. Now he wants out but we don't care because it's not a character of t with the command for X but nothing happens. And a went in who increment for X of A and it becomes equal to fracture of A, we satisfied a new condition, the number of conditions is equal to length of rec t. So the substring is valid, it contains all characters of reg T, all conditions are satisfied. We move the window, now see what's out of the window, and is number of occurrences in the substring is equal to the number of occurrences in t. So, when we decrement because it's one out, the condition becomes unsatisfied. We don't have enough C's anymore. And the answer is the window. But we don't care. It's not a character of t. Now the number of satisfied conditions is smaller than what's required. This substring doesn't contain all characters of t. And the process continues like that. Once again, no matter the length of the window, we're dealing with two characters, only the one that went in and the one that went out. So checking if the actual substring is valid because of one we've been able to optimize extracting the substring, generating the counter and checking if the substring is valid. We've seen how to do all these in old one. But he didn't see the code yet. Let's move to the code. We keep the same old exit condition, we generate the counter of t. But now we don't save the shortest string itself. We just save it started and position. Initially shortest sources a string of samples one characters, so initialize thought and and zero and amples one respectively. Now we start traversing lengths. What we were doing in the example is to update frogs according to characters that went in and out compared to the previous position of the window. But to do so, we first did an initial window that's also zero and hose the length is length arrow, traverse it normally to fill frogs and count the number of satisfied conditions. We create fracks and recreate satisfied a variable to keep track of the number of satisfied conditions. It initially starts at zero because we didn't start traversing characters of as yet, we didn't satisfy any condition. Then we traverse characters of the first window, for each character ch will increment flux of ch. And if CH is a character of T and flux of CH becomes equal to react, you have ch now the number of occurrences of CH became enough, a new condition is satisfied, who increments satisfied. After processing the first window, we check if it's a valid substring before moving to all the ones and if it should replace the actual shortest one. If satisfied is equal to length of reg t, the number of conditions and length is smaller than the length of the actual shortest substring, which is add minus thought replace, start an N becomes zero and length respectively, the boundaries of the first window. Now we can start traversing all the sub strings are the same length, I start at one and zero because the first sub string, which is the first window is already processed, we start from the second one. We want to work with the character that went out of the window and the one that went in bought, where are them. The actual substring is between indexes I in clauses when I post length exclusive, the character that went out comes just before the window. So its index is i minus one. And the one that went in is the last character of the window, its index is i plus length minus one, we can start working, the character that entered the window is opposition ai plus length minus one. So increment for x of s of Ai plus length minus one. Now if it's a character of T and its number of occurrences and the substring became equal to the number in t, it means that the new condition is satisfied, we write if as of apples length minus one in fact T and flux of hours of eyeballs length minus one is equal to freq T of s of i plus length minus one, we increment satisfied. After it, we work with a character that went out the one at index i minus one if it's a cocktail of T and S number of occurrences and the substring is equal to its number of occurrences in t it means that a condition was satisfied but not anymore, because we will decrement for x of s of n minus one. So it will become smaller than freq T of s of i minus one not enough occurrences of x of i minus one anymore. We write if as of i minus one in fact T and for x of s of i minus one equal to T of s of i minus one with the cumin satisfied will also satisfied condition after it with the CaroMont for x of s of i minus one. Now that we know the number of satisfied conditions by the actual substring the one between i and i plus Lang who can check if it replaces the actual shortest one, we write If satisfied equal to the length of reg T and length is smaller than n minus thought, we replace thought and by i and i plus length respectively, we found a shorter string that contains all characters of T. After the loop, soften and represent the boundaries of the shortest substring, but only found one. If underline his thought is greater than n, then we didn't update start and end, we turned the empty string because we didn't find any valid substring. Else, we told the part of us between starting clause event and X closet. What about the time complexity, we'll have time for building for T n iterations for the outer loop. Then inside it, we have linked iterations for the first loop, and one is length iterations for the second bond, and all operations inside the mind of one plus n for returning the part of us length plus and minus length gives n and we can ignore M, we've got an O of n squared time complexity, the space complexity doesn't change. You can see that now we've been able to reduce the time complexity from F and Q to off n squared isn't enough. No, we can do better. When using sliding window, we have the case where the window size is fixed. For example, if we have an array of integers and are asked to find the key consecutive elements with the greatest sum, we use a window of size k, we will move it but we won't change its size because we know that the array we're searching for is of length k. However, in our problem, we don't know the size of the shortest substring that contains all characters. This is why we tried all possible lengths, which are sub strings of length one than those of them do, and so on, which resulted in an O of n squared time complexity. But we have another way of manipulating the window, instead of sliding the window by one position. In other words extended from the right by one and reduce it from the left by one, what we can do is to extend it from the right by one, but reduce it from the left by a number of times that is between zero and the length of the window. Depending on what we want to do. Let's apply to our problem. Theory of the strategy that we're going to use is to find the shortest substring that answer the actual index of write that respects the condition, which is containing all characters of tea. Obviously keeping track of shortest one among the more the one that will be returned our via let's start for the first index, we find an A but no condition is satisfied, we need to as next index, we find d, we don't care about it. Next index we find c a condition is satisfied. Next index if we don't care. Next index e we don't care. Next index B, the second condition is satisfied, but not all of them. Next index e we don't care. Next index see we have two Cs now, better condition is still missing. Next index, he won't care. Next index a, we now have two A's, which is enough to satisfy the last condition. All conditions are satisfied now, it means that the substring from left to right in clause is valid. But is it the shortest one that answer the index, right? Not true. Because we may have characters that we don't care about by characters that we don't care about, I mean characters that we can remove without breaking the validity of the actual string. And these characters are characters that are not in TRL and calculus of t that are in excess in our substring. For example, if we need to see is only and we have five C's in our substring who can remove the first three wants to make the substring shorter while satisfying the condition. Remember that our goal is to get the shortest valid substring. Who cannot remove from the metal because characters of a substring must be ages. And we cannot remove from the right because we're searching for the shortest valid substring that answer the actual position of right. So we can only remove from the left will keep removing while the characters position left is a character we don't care about. Here the character off left is a it's in T and it's not an excess. We need two A's and we have exactly two. So this one is important. We cannot remove it. We finish removing from the left. So the shortest substring that answer right is this one is length is smaller than the actual shortest one, we update. We move to the next position of Freud who find the be the one at left is still important. So the shortest one is this one. But we don't update because it's not the global shortest one. Next position, we find an E the counter left is still important. Next position we find to be the character left is still important. Next addition, we found in a and here is where things change, because the character at left is not important anymore. The reason behind it is that we found another A, which means that the character is now in excess, we can remove the first one without breaking the Validate he will move a and with the command is number of occurrences. Let's see if we can continue removing D is not an important character is not in T, we move it C is in T but we have more than enough we have two C's while we need only one we move and decrement is number of occurrences of is not empty. Remove is not empty, remove it. These in excess we remove it is not empty, we remove it. C is in T and it's not in excess. So we stopped removing. We found out that the shortest valid substring that antithyroid is c e a b e BA and it's like the seven smaller than the length of the actual shortest one replace. Let's continue. We'll move to the next position of right. By the way, if you're wondering why aren't we going back to the beginning going to increment right is because we know that characters before the actual position of love aren't important. We don't need the for the actual substring. Who found the D the cow top left is still important and we don't update because the length is not smaller than seven. Next position who find half the characters left is still important and we don't update. Next position we find the seat which means that the character at left is not important anymore. The character sees in excess we can remove it is not in T we also remove it is important because it's in T and it's not in excess we stopped removing we get a B e b a DFC, which is not shorter than the actual shortest. We don't update we continue with on D and A still important. Next position we find f is still important. Next position, we find c an ACL important. Basically it will continue like this for the next five positions. And there is no update because the substring is getting longer. We're not being able to remove from the left and in the next position we find an eight so the one on the left is not important anymore, we remove it. These in excess we remove it is not empty, we move it be still in Excel. So remove it is not in Excel. So we stop the substring is a DFC, DFC BFC BA, but not short enough to update. last index, we find d and a still important, we don't update and we finish traversing as the global shortest substring that contains all characters of t is the one between indexes seven and 13 and clauses, it c a b e BA, take some seconds to process what you've seen until now before continuing the video. Let's move to the code. We keep the same URL the exit condition we build for it as we did previously, we initialize thought and add on zero and respectively. We initialize satisfied zero regret for x which is empty at the beginning. And we add a variable left that represent the left boundary of the window here and started on and not n plus one because now Andrew presents the last nfo the window is in closet. Also, you can see that we created frogs and satisfied outside the loop because we won't traverse lengths as we did in the previous solution. We don't need to do that will darkly traverse positions of right the right boundary of the window for each position right we increment the number of occurrences of the character obviously, an objective is satisfied a condition as we did in the previous solution if as of right is in fact T and flux of arthritis equal to for active as a Freud who satisfy the condition so increments satisfied. Basically the path before satisfying all the conditions. This is what we need to do only incrementing the number of occurrences and checking if we satisfied a condition remember that we're expanding from the right only less remains zero. But once we satisfy all the conditions which we can verify with this condition, satisfied equal to length of FRAC t we can start removing from the left. We don't know how many characters are we going to remove from the window. So we use a while loop. We saw that we keep removing characters while the character has left is an important and a character that is not important. means that either is not a character of the origin access means we have more than what's required. We write while as of last noted for akti or flux of us have left greater than for active as of left. Inside the loop, we move the car out which means that we decrement its number of occurrences in frogs and move left to the next position. Now that we removed all unnecessary characters who go the shortest valid substring? That answer the actual position of right is the one between left and rotting clause if what do we do now, we check if it replaces the actual global shortest one. The length of the substring, we found now is right minus left plus one plus one because this time the right boundary, which is right is included in the window. And the length of the actual global shortest one is and minus thought plus one plus one for the same reason. So if right minus left plus one is smaller than and minus that plus one, we update, start and end become left and respectively. After the loop, almost same return statement, we just add plus one because and is included in the window. Now, if we could update at least once we turned the part of ASP video installed and adding clause if else return the empty string. By the way, you can see all of this time, we weren't checking if we lost a satisfied condition. Because we stopped removing as soon as we reached the minimum required occurrences will never go below it. This is why when the counter had left was important. We weren't removing at all, not like in the previous solution when we were removing no matter what. For the time complexity, we have an for building for T and the outer loop does n iterations is true that we have an inner while loop where the tricky part is that its number of iterations doesn't exceed n in total. I repeat in total. Why? Simply because at each iteration of the while loop, we're removing a character and we have n characters. remaining operations are owned over one. So the cost of the outer loop isn't over. And yes, oh if and only not more, who else pause and for extracting the output. And in total, we have ample of ampersand, we'll give some of ample time complexity better than O of n squared. And for the space complexity, same as the previous solution of m plus m. And we've been able to solve the problem in off campus m time only by using a bunch of interesting optimizations. One was a tough problem, I hope that you understood how we built our optimal solution that you will be able to use it to solve all the problems. We've reached the end of this video, it was a long one. But I tried to detail each operation to let you understand what is each line of code doing and how the algorithm works in general. See you in the next video. Welcome back to the course in this lecture, we will solve the largest rectangle in histogram problem. We are given an array heights that contains the height of each bar in the histogram. And we're asked to return the area of the largest rectangle in the histogram. Know that each bar has a width of one. For example, if we have this input here is the largest rectangle. It's area seven times five, which gives 35. How can we solve this problem? Let's for example, take this bar, it has a height of two. Now, can you tell me what's the largest rectangle of high two that passes from this bar? Is this one. But how did we know? Let's start from that bar and keep expanding? Can we expand to the left? Yes, three is greater? Can we expand? No, because we have no more bar from the left? From the right now can we expand? Yes, four is greater? Can we expand? Yes, five is greater than two. In other words, this bar is higher so our rectangle can pass from it. Can we expand? Yes, seven is greed. Can we expand? Yes, six is greed. Can we expand? No, we can't expand from here because one is smaller than two. So if we expand, the rectangle won't be fully included in the histogram is not a valid rectangle. We expanded as much as possible from both sides, we go the largest rectangle that passes the initial bar is this one, it has an area of 12 Two times six, the height multiplied by the width. And we can apply this strategy on each bar while keeping track of the greatest area of the end who will have found the greatest area, because the largest rectangle necessarily passes from a bar that has the same height as itself. The reason behind it is that if the rectangle is shorter than all the bars it passes from, it means that it's not the largest one, you can still make it bigger by increasing its height. And if it's taller than at least one bar learn is not fully included in the histogram. It's not a valid rectangle. With this example, with the first bar we get this rectangle with the second bar we get this rectangle and so on. The end The greatest area that we find is 35. The area of this rectangle encode we initialize Max area to zero because we didn't traverse any rectangle. Therefore, each bar I expand from both sides from each side, we keep expanding while the bar is still higher or as high as our bar. So we stopped when we found the shorter one, or when we have no more bars. Left thoughts are the actual position, then while the previous bar exists and is at least as high as the actual bar, we expand, we move left by one position to the left. Same logic with the right side but by incrementing, right starts on I, then while the next part exists, and is at least as high as the actual bar, we expand, we move right by one position to the right. While right plus one smaller than N and height of right plus one greater than or equal to height of AI, we increment y to take it to the right. Now that we know boundaries of our rectangle, we need to calculate its area. The area of a rectangle is the height multiplied by the width, the height here is the height of the initial bar height of i, and for the width is the difference between left and right plus one, right minus left plus one plus one because both left and right are included in the rectangle. Now we check if replace Max area becomes the most between its actual value and the area of the actual rectangle heights of our multiplied by right minus left postponed. After the loop, we just return max area. For the time complexity, we're traversing the N bars, and for each bar when searching for left and right boundaries, who may traverse the whole histogram. This is why we get an O of n squared time complexity. In the worst case, the worst case happens when all bars have the same height. And for the space complexity, it's constant, we're just using eight variables. This solution is slow. Let's move to the next one. There are interesting properties to know about the shortest bar. The first one is that by starting to make a rectangle from it, we can expand it until the boundaries of the histogram because there are no shorter ball to stop the expansion. Second one, the rectangle starting from any other ball can't pass through it, except if it has the same height, but we get the same rectangle in that case. So the shortest part is like a wall, any other rectangle will either be on his left side or on his right side. From these two information, we can make a solution based on divide and conquer. We search for the shortest bar, and we have a rectangle that traverses the whole histogram will also recursively search for the largest rectangle in the left side, the largest rectangle in the right side, and we take the maximum among these rectangles, it represents the largest rectangle in the whole histogram. The reason behind it is that because our bar is the shortest one, we can't have a taller rectangle that joins the left on the right side, a taller rectangle will either be in the left part or in the right part. So we don't worry about missing the larger rectangle, we can search in each side separately. We also consider the rectangle host the height is the height of the shortest bar, the one that traverses the whole histogram, because it's possible for it to be the largest one, even if it has the smallest height, but its width can make it the most interesting rectangle. Encode recruiter recursive function that takes us parameters the array of heights, but also low and high the boundaries of the part of the histogram we're searching in right now. Or the beginning we search the whole histogram. So low and high will be initialized to the index of the first and the last bar. The first base case is where the actual part is empty. While low exceeds right, we just return zero, we have no rectangle. Second base case one, we have only one bar, one low is equal to high. In those case, we just returned the height of that bar. Else, we have the recursive case, we'll start by calculating the position of the shortest bar in the actual part. For that, we calculated the smallest height in the actual part between low and high in clause IV, then we search for its index in the outro part again. Now that we have it, we recursively search for the greatest area and the left and right sides. For the left part, we put postman minus one as the right boundary. And for the right part, we put postman postman as the left boundary. URL for the short put wide rectangle, its height is the minimum height we calculated before and its width is the whole path we're searching in high minus low plus one. So we turn the maximum between from left form right and mean eight times high minus low plus one. This one represents the area of the short but while rectangle we also need a long question function to call this one, the initial values of low and high are zero and n minus one, the index of the first and last bar respectively. For the time complexity, in the best case, the shortest bar is always in the middle. So in recursive cases, we divide the input size by two, we have infosearch. And for the men, and two times t of n by two for cursive calls, we get t of n is equal to two times t of n divided by two plus n. By using the master method, this recurrence relation gives off n log n time complexity. But in the worst case, the shortest bar is always the first or the last bar. For example, when it's the first one, from the love, the input size becomes zero, we get to zero. But from the right, the input size becomes n minus one, we get to have animals one plus n to search for the minimum, we got t of n is equal to t of n minus one plus n. And if we keep replacing, this recurrence relation gives off n squared time complexity, same as the previous solution is like we didn't often what's slowing down the process is finding the minimum its causes and to search for the minimum in the run who are searching for. But we can optimize this by using a segment tree for example, you can reduce the cost of searching for the minimum and arrange to look at the recurrence relation becomes t of n is equal to t of n minus one plus log n, we get off n log n plus n to build the segment tree, we've got an O of n log n time complexity, but if n over n squared. But we still have two solutions to discover. The strategy we use in our first solution is dot for each bar, we search for the next shorter bar from the left the next shorter bar from the right, and we calculate the area of the rectangle bar always traversing bars again to search resulted in an O of n squared time complexity. What if we can traverse the histogram only wants to find the next shorter bar of each bar? Yes, it's possible by using a stack, we can maintain a stack and in increasing order. For example, we have 2478, then we want to insert five, but it wouldn't be increasing anymore. So we'll keep popping until we find a smaller element. And we push it remains increasing. Then again, we'll have six 910 12/3. To insert eight will pop 12 will pop done, we put mine and insert, and so on. And we can use this principle for our problem will work with heights will maintain a stack and to follow the next shorter bar from the left of the actual bar who keep popping into the top of the stack becomes shorter after it will also push the actual bar for the next iterations. Let me show you how it works with our example. We can add two bars of height minus one at extremities to avoid having an empty stack minus one to be sure that they will be shorted at any bar or the beginning, the stock contains the bar zero, and will start from bar one. The top of the stack is shorter, who already found the next shorter is at index zero. And we'll push the actual bar. Next index, the top of the stack is higher Ooh pop. Now it's smaller, the index of the next shorter is zero, and we'll push the actual bar. Next bar top of the stack is shorter, we already found next shorter is the bar index two and we push the actual one. Next bar, same thing, top of the stack is shorter. Next bar same thing. Next bar who performs and we find it next bar, we have to pop all of them except the last one because they are all higher. Next bar, the top of the stack is all really short, its index is seven, next bar are really shorter. And it continues like this for the whole histogram. Now we got the index of nav shorter bar from the left of each bar. But we still need the one from the right. So we can apply the same process but from the right. The Start Now initially contains the rightmost bar, the one we added from there, who is the height is minus one. First of all from the right, the top is already shorter, and we push. Next bar we put once and we find the index we also push next bar already shorter. We write and we push. Next bar, same thing we write and we push. Next bar same thing. Next bar, same thing. Next bar we pop twice, we write and we push next bar, we put once we write, and we push, next bar, we pump thrice, we write, and we push, and the process continues like that now for each bar, we have the index of the next shorter bar from the left the index of the next shorter bar from the right, we can calculate the largest rectangle that passes from the actual bar. For example, for this one, next shorter bar from the left is zero. From the right, it's seven. So we get this rectangle to get the largest one in the whole histogram, whichever is largest rectangle of each bar, while keeping track of the global largest one, as we did in the first solution, but we don't need to search again here. And we've been able to solve the problem by traversing the histogram only thrice instead of n times, which will reduce our time complexity to O of n. Encode who first are those two bars of height minus one not extremities, then we create an array from left or from left of it represents the index of the next shorter bar from the left of the bar, I will also create a stack that initially contains the first bar, the one we added. Now for each bar, except once on extremities, who keep popping, while the bar on top of the stack is higher, or as high as the actual bar, we write wild heights of stock of minus one greater than or equal to heights of oil, we pump stock of minus one represents the top element. After the loop, the next shorter bar from the left is on top of the stack, we assign it to from left, I will also push the index of the actual bar i. We finished filling from left, who will do the same thing from the right, acquired from right, we initialize the stock by putting the last bar only and we start, now we traversed bars, but in the reverse order. Remember that we start from the right and we move. Same logic for what's inside the loop. But we assigned to from right of it now. After having both arrays filled, we can start working to initialize Max area to zero, then for each bar, who took it who replaced Max area, Max area becomes the maximum between its actual value and the area of the rectangle of the actual bar. The height of the actual bar is height of AI. And the width is fomite of i minus from left of i minus one minus one. Because the next shorter bars are not included in the rectangle, we don't count their width. So the area is height of I times from right of i minus from left of i minus one after the loop return max area. For the time complexity, we have n to add those bars and integrate from left. And now for the loop is true that we have a nested while loop where the total number of iterations won't exceed and because each bar is pushed and popped only once. And we have an bars so the cost is N. Same logic for the process from right, and we add on to search for Max area. We're getting off on time complexity. And for the space complexity we have and for heights and for the stack, and for from left. And and for form, right we're going off and space complexity. In this ocean, whichever is the histogram thrice, but we have a solution where we traverse it only wants let's talk about it. Okay, imagine that we have this bar as a first bar, we can still expand it from the right because we didn't find the shorter one. The next bar is this one, you can still expand them both, we found nothing that stops them. Third bar, same thing. Fourth bar, same thing, you can still expand them all because the hearts are increasing. And we're putting them in a stock by the way. Both for example, the next bar is this one, this bar will love the previous three bars stop expanding because it's shorter than them. In other words, all bars that are taller than it in the stack. And because now we know where these bars stop, we can't calculate the largest rectangle, the actual bars at index four, so they stop at index three. For this bar, here's the rectangle for the next one of the stack. Two is the rectangle. And for the next one, here is the rectangle. We stopped poppin because the top of the stack is shorter, so it can still expand. You can see that what we're doing is that we're pushing our bars into a stack. Then when we found the next shorter bar from the right, we know where they stop, we calculate their rectangle. Now we push this point we continue this bar Higher, we have nothing to pop without clear push it. But for this one is shorter. So we pop this one, and we calculate the rectangle. The top is still taller, we pop on we calculate the rectangle, put weight with this bar, the largest rectangle that we can make is not this one is this one. The reason behind this one result is that the index of a bar is not necessarily for Maurice largest rectangles thoughts, in reality is largest rectangle thought form where the last popped bar thought iterations thoughts. For example, for this one, remember that we have three bars, this one was the last one, it means that the largest rectangle starts from here. This is why when we push bar, we keep the same height, both as index we put the index where the rectangle of the last popped bar starts. Let's work with a greater example, the one we've been working with in this video, we can add those two bars of height minus one extremities to avoid having an empty stack. First bar, the bar on top is shorter, we totally put it on the stack. Next bar, the bar on top of the stack is taller. So we found the end of its rectangle, its Imani spawn, the top of the stack is not small anymore, who stopped poppin. But now when we push this bar, as high throughput to both as index, we put the index of the last pop bar, which is one let's continue for is taller, we just push with this index because we didn't pop anything. Next bar, same thing. Next bar, same thing. Next bar we need to pop. And we found the end of this bar here is it's rectangle. And when we put six as index, we put five. Next bar, we need to pop here is the largest rectangle of the pop the bar is beginning is the index we pushed and is and is i minus one, we can calculate the rectangle and see if it replaces top is still higher, we pop top is still higher, we pop top is still higher, we pop, you can see that for each prompt bar, you can easily find his largest rectangle, top is not higher anymore, we stop. And the starting index of the last pop node is one. So we put an index of one when pushing the actual bar. The reason behind it is that from the left, our bar can extend until the index one from the road we don't know yet. Next bar higher without the push, next bar, same thing. And the process continues like this until the end. After finishing, we found the largest rectangle is this one, we turn this area. And we've been able to solve the problem by traversing the histogram only once. In code, we start by adding those bars of extremities will create Max area, we'll create a stack and we'll start traversing bars. The stack initially contains the first bar, the one that we added. And you can see that now we're storing both the index and the height. In the previous solution, we stole the index only because we could calculate the heart from the hearts array. But this time, the pushed index is not necessarily the one where the bar is in the histogram. So we store both. And this time, we need to traverse the bar of the right extremity to empty the stack to calculate rectangles of bars that are still in the stack. So I start from one and goes until the last bar at each bar, I will need a variable start that indicates for more the largest rectangle of the bar our thoughts. Remember, that is the starting index of the last bar we popped. But we didn't start popping yet. So we set it to I now we start poppin while the bar the top of the stack is higher or as high as the bar our we bought, we put the index and the height into variables. Remember that we need to calculate the largest rectangle of the pumped bar. It's hard is the pushed height. It's taught index is the pushed index. And it's an index is our minus one. So its width is i minus one minus top index plus one, which is I'm on a stop index. We check if it replaces Max area Max area becomes max between its actual value and top height times I'm on his top index. And we're searching for the start index of the last pop bar. So start receive stop index. After the loop stock moves the start index of the last popped bar and the height of the actual bar is height of I we push start heights of AI and after the outer loop, we're done Max area thoughts for the time complexity, once again the inner while loop will do a Most alliterations in total, because each bar is pushed and popped only once we've got an O of n time complexity, and for the space complexity off, and because of the stack and height array. We've reached the end of this video. In this one, we've seen different solutions to this problem. I hope that you understood them all. And that was the last problem of this course. Congratulations for finishing this course. I hope that you learned a lot of new things from it, and we'll be able to apply them in all the situations. To learn even more. You can check the other courses I made, like the 50 popular coding interview problems course, check the links below. Also, please tell me what you thought about this course. If it's good, if it's bad, what should be improved, etc. See you in another occasion.
