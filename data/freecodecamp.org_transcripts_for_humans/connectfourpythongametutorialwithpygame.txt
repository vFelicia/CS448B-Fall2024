With timestamps:

00:00 - what's up guys
00:01 - in this video i'm going to show you how
00:02 - to program connect 4 in python
00:06 - by the end of these videos you'll build
00:08 - something that looks like this
00:12 - it's a simple
00:14 - two-player connect 4 game with graphics
00:17 - i think this is a really good exercise
00:19 - for your beginner to intermediate level
00:21 - python programmers who want to build
00:22 - their skills
00:24 - i'll just finish up a game real quick
00:26 - just so you can see how
00:28 - this fully works
00:30 - as you can see i have the diagonal and
00:31 - it says player one wins cool we're gonna
00:34 - do something a little bit simpler and
00:35 - then build up to that graphic based
00:37 - connect four game
00:38 - it's a command line connect four game
00:41 - where you actually manually type in
00:42 - numbers to drop your pieces so you see
00:44 - the one there
00:45 - the two etcetera all right so let's
00:47 - start building that
00:49 - just quickly i want to mention that i'll
00:50 - be programming in python 3 and then
00:53 - using sublime text 2 as my editor i
00:55 - posted a link to a video on how to set
00:57 - up these things in the description
01:00 - so one of the first questions i asked
01:01 - myself when i was writing this game is
01:03 - what is the best way to represent the
01:04 - board
01:05 - so if i drag on a connect 4 board real
01:07 - quick you can see that it is 6 rows by 7
01:10 - columns and to me this looks like the
01:12 - perfect structure to represent as a
01:14 - matrix in python so that's what we'll do
01:17 - so we'll define a function called create
01:19 - board
01:21 - and that's not going to accept any
01:22 - inputs
01:23 - then we're going to make a
01:24 - a matrix of all zeros with the
01:26 - dimensions six by seven and to help us
01:29 - do this we're going to import a package
01:30 - called numpy
01:33 - and if you haven't already installed
01:35 - this you can open up a terminal window
01:37 - and just type in pip install numpy
01:41 - and as you can see i already have it
01:43 - so we're going to use this as follows
01:44 - we're going to say board equals
01:47 - numpy dot zeros and that's going to make
01:49 - a matrix of all zeros which is good for
01:52 - our initial state and then the
01:53 - dimensions six rows by seven columns
01:56 - cool and then we just need to return
01:58 - that board
02:00 - and we can test to make sure that worked
02:01 - by doing the following create board
02:04 - and then
02:05 - print
02:06 - board and as you can see if i run oh no
02:09 - what happened as you can see if i run
02:11 - that
02:12 - um we we do in fact have this six by
02:15 - seven matrix of all zeros so that looks
02:17 - good we can begin writing the main game
02:19 - loop now
02:21 - so we're going to write a loop that says
02:23 - while not
02:25 - game over
02:27 - and so
02:28 - our loop is going to be running as long
02:30 - as
02:31 - this game over variable is false
02:34 - and the only way it becomes true is if
02:36 - someone has a four in a row so we need
02:37 - to initialize the game over to be false
02:39 - to begin with
02:42 - equals false and the only way that's
02:43 - going to switch to true is if someone
02:45 - got a four in a row
02:47 - so now we're going to need to we're also
02:49 - going to want to real quick
02:50 - make our board initialize before we
02:52 - start the game
02:54 - just so we have something to put pieces
02:56 - into
02:56 - so we have our board we have our game
02:58 - over variable and now we're going to
03:00 - want to be able to ask
03:04 - for player 1 input
03:08 - and then we're also going to want to
03:09 - eventually be able to ask
03:13 - ask
03:14 - for player 2 input
03:18 - so this kind of leads us to the problem
03:19 - of oh how do we differentiate between
03:21 - whether it's player 1 or player 2's turn
03:23 - so we're always going to define another
03:24 - variable up here called turn that's just
03:26 - going to initialize to 0. so what we're
03:28 - going to say is
03:29 - if turn
03:31 - equals equals zero
03:33 - then we're going to want to ask for
03:34 - player one input
03:36 - all right so in python there's a
03:39 - function a built-in function called
03:40 - input as you can see it highlights blue
03:42 - for me
03:43 - so
03:44 - we're gonna say
03:46 - selection equals
03:49 - input and then
03:52 - we're gonna say player one
03:56 - make your selection so this is what the
03:58 - player one is gonna see and then the way
04:01 - we're going to initialize this game is
04:02 - we're going to just say they can type in
04:03 - between 0 and 6. so
04:06 - this is what the
04:07 - player 1 should see so if i build this
04:10 - you see we run into this error
04:12 - so this is because um sublime text
04:15 - doesn't accept this input
04:17 - function
04:18 - so my work around for this was i
04:20 - installed a package in sublime called
04:22 - sublime repl i'll put a link in the
04:24 - description on how to install this
04:26 - and i can run
04:28 - the input function through that so now
04:30 - you can see player one make your
04:32 - selection three
04:33 - and it doesn't do anything with that
04:35 - input right now but you can see that
04:37 - it's asking me that and i can type in
04:38 - hit enter
04:40 - all right cool so we also just want to
04:42 - make sure that it saves our selection
04:45 - properly so we're going to print
04:48 - selection
04:49 - and i also just want to see you know if
04:51 - i type in a number does it actually give
04:53 - me the number
04:55 - or does it give me a string that
04:56 - represents the number so i'm going to
04:57 - also print in type of selection i just
05:00 - want to see what we're getting so i'm
05:02 - going to run that again and as you can
05:03 - see error again but we're going to go to
05:06 - slime rpl and the link is in the
05:08 - description as i just said run current
05:10 - files so
05:11 - two
05:12 - and as you can see it gets two but it
05:14 - says it's a string so we're going to
05:15 - want to make sure that it's actually a
05:18 - integer
05:19 - so we can just surround this with int
05:23 - input one and this should work so let's
05:25 - see
05:26 - run that again
05:28 - and you can also run this through the
05:30 - command line so if you run this in your
05:31 - terminal go to the the directory that
05:34 - the file is in and type in python and
05:36 - then file name it will also run just as
05:39 - i'm running it in this sublime repl
05:43 - player one make your selection three
05:45 - cool and now you see it says three and
05:47 - it says the class of that is an int so
05:49 - that looks good to me
05:51 - so
05:52 - now you can save some sort of selection
05:54 - from the user and you can also
05:57 - edit this so that it
06:00 - requires you to make a specific
06:02 - num type in a specific number but we'll
06:04 - just leave it as like we'll imagine our
06:06 - players are following the directions
06:08 - right now
06:09 - all right cool we have that and then
06:11 - we're also going to want to be able to
06:12 - ask for player 2's input so that's going
06:14 - to happen else otherwise so if the turn
06:17 - is not equal to zero
06:20 - um
06:21 - then we want to ask for player two input
06:23 - so selection equals
06:26 - and we'll just copy this from above
06:31 - and we'll just have to change this to
06:32 - say player two make your selection
06:35 - all right
06:37 - cool
06:38 - and now at the end of the turn no matter
06:40 - whose turn it is we're gonna want to
06:42 - increase
06:43 - um
06:44 - our turn by one so turn plus e or plus
06:47 - equals one so i'll make it increment it
06:50 - by one and then we're also what we're
06:52 - going to also want to do is
06:54 - we're going to just make this odd even
06:56 - so
06:57 - we're going to use mod division so it's
06:59 - going to be turn mod to turn equals
07:03 - turn
07:04 - mod
07:05 - 2 and this is just basically making it
07:08 - go uh take the remainder of whatever our
07:10 - turn is divided by 2.
07:13 - so this is just going to alternate it
07:14 - between 0 and 1. so it will alternate
07:17 - between player 1's turn and player 2's
07:19 - turn so
07:20 - let's just see if this works properly so
07:24 - we're going to run this
07:26 - build python current file
07:29 - player one make your selection two
07:31 - player two make your selection four
07:32 - player one make your selection two oh
07:34 - that looks good it's alternating between
07:35 - our player one and our player two
07:38 - cool
07:39 - okay and now we're gonna wanna start
07:41 - building our actual functionality we're
07:42 - gonna wanna be able to make this
07:44 - selection right here actually drop a
07:46 - piece into our board
07:48 - so i'm going to find another function up
07:50 - here called
07:52 - definition drop
07:54 - piece
07:56 - and we might define a couple functions
07:57 - so maybe have a drop piece and then
07:59 - we'll just do pass for now and maybe
08:01 - we'll also have like
08:03 - is valid location
08:05 - so that will check whatever number that
08:07 - the
08:09 - player typed in we'll check to see if
08:11 - that's a valid location
08:14 - we'll also define a function called get
08:17 - next
08:18 - open row
08:20 - and how all these functions are going to
08:21 - work together is as follows so it all
08:24 - begins with the player making a
08:26 - selection the 0 to 6 here represents the
08:29 - column that they want to drop their
08:31 - piece in so maybe a more appropriate
08:33 - title for this would be
08:34 - col representing column
08:37 - col
08:38 - next we're going to take this column and
08:40 - the current board we have
08:42 - and pass it into this is valid location
08:45 - function so board column
08:48 - and to visualize how we can check to see
08:50 - if the column they selected is a valid
08:53 - location
08:54 - we will
08:55 - print out the board real quick
09:02 - so as you can see
09:05 - imagine this is the
09:07 - zeroth row is the first row second row
09:10 - all the way up to the fifth row here and
09:11 - then this is the zeroth column first
09:14 - column second column etc we're starting
09:16 - at zero as our first index
09:19 - so if we wanted to check if the column
09:22 - that the user selected let's just assume
09:24 - that the user always types in a valid
09:26 - number zero to six if we wanted to check
09:28 - to see if it's valid all we need to do
09:31 - is make sure that this top row
09:33 - for that specific column is not been
09:36 - filled
09:37 - so
09:38 - let's imagine that we're putting ones in
09:40 - for player one going and two's in for
09:42 - player two going so if this top row
09:45 - is still zero for the specific column we
09:48 - selected then we know that it's okay for
09:51 - us to drop a piece in that row
09:53 - or in that column it hasn't been filled
09:55 - all the way to the top
09:57 - so to do that so this is the fifth row
09:59 - so all i'm going to do is just check to
10:01 - see whether or not
10:02 - the
10:03 - position at the fifth row and let's say
10:07 - you know whatever column we select is
10:09 - zero and if it is that means the column
10:12 - is still free if it's not then
10:15 - that's not a valid location we'll have
10:16 - to have the user try something else
10:19 - so to do that let's just do board
10:21 - so we're going to return
10:23 - board
10:25 - and then the
10:27 - the row is 5
10:29 - and the column is whatever the user
10:30 - selected so here
10:33 - so
10:34 - and we're going to make sure that's
10:35 - equal equals zero so if that's true then
10:38 - we're good to
10:40 - we're good to
10:42 - let them drop the piece there
10:44 - if that's not true then that means the
10:46 - column has been filled up all the way
10:48 - and one thing i'll note that will
10:50 - probably change in a future video is
10:51 - that it's kind of getting messy my code
10:54 - a little bit with just throwing these
10:55 - random numbers here all the way all over
10:57 - the place and programming these are
10:58 - called magic numbers you kind of don't
11:00 - know where they come from so i'll clean
11:02 - those up in
11:03 - some of the future videos in this series
11:06 - so return board five column equals
11:08 - equals zero and that is just checking to
11:10 - make sure that that column has an empty
11:12 - slot okay so now that we've gotten the
11:14 - valid location let's get the next open
11:16 - row in that column
11:20 - so if we think back to our board
11:22 - that's just checking to see when we drop
11:24 - it in let's say
11:26 - the zeroth column here on the the left
11:29 - checking to see which
11:31 - row of these if the piece will fall on
11:35 - so to do this we're going to write a
11:36 - quick little loop
11:38 - so we're going to do
11:42 - for
11:44 - and we're gonna also have to pass in
11:47 - the board and the column into this one
11:50 - so the loop we're gonna write here is
11:52 - for r and range
11:55 - and i'm actually going to start
11:57 - getting rid of some of these magic
11:58 - numbers so i'm going to initialize
12:01 - a
12:03 - global variable called row count
12:06 - and often globals are capitalized just
12:08 - to show that or
12:11 - static variables that don't change or
12:12 - capitalize just to show that they're a
12:14 - non-changing variable so the number of
12:16 - rows we have is six and the number of
12:18 - columns we have
12:20 - is seven
12:22 - so i'm going to do for r so for row in
12:26 - range so the number of rows we have so
12:28 - row count
12:31 - we're going to check the board position
12:34 - we're going to see
12:37 - if board
12:39 - r
12:41 - position or so the column
12:44 - equals equals zero
12:47 - then we want to return that row so
12:50 - basically if the row is equal to zero so
12:53 - imagine we're filling this whole board
12:55 - up with ones and twos
12:57 - if the slot is still zero that means
12:59 - it's empty still so we're going to
13:01 - return the first instance that it's
13:03 - empty so
13:04 - this
13:05 - r is going to count from zero to uh
13:08 - row count minus one
13:11 - and we're going to return that first
13:12 - case where it equals zero
13:16 - okay so now we've got the next open row
13:17 - and then finally what we're going to
13:19 - want to do is drop the piece so this is
13:21 - going to take in the board
13:23 - the row
13:24 - and the column and then we'll also add
13:26 - something we'll just call it
13:28 - the piece so whether it's player one or
13:31 - two going so
13:33 - all this is going to do is go
13:35 - board
13:37 - row
13:38 - column
13:40 - equals equals the piece
13:42 - so we're going to make it fill in
13:45 - the board with whatever piece that the
13:47 - player just dropped so let's put this
13:49 - all together in our loop so first
13:52 - we got the column and now we're going to
13:53 - check
13:55 - if is valid location of the board
13:58 - in the column
14:00 - and then we can start getting the next
14:02 - empty row so row equals get next open
14:05 - row
14:06 - and that takes in the board and column
14:08 - as well so
14:09 - get next input and row
14:11 - board
14:12 - column
14:14 - and then we're going to finally drop
14:16 - piece
14:17 - and we're gonna take in the board
14:19 - the row the column and then for player
14:21 - one the piece is just the one
14:24 - and we're gonna copy this in
14:28 - to player two as well because player one
14:31 - and player two the functionality
14:33 - of what they're doing is the same but
14:35 - we'll just have to change the piece here
14:38 - to two so
14:40 - now and then finally probably after the
14:42 - player goes we'll probably want to
14:46 - print out the board so we'll print the
14:48 - board here
14:50 - and let's see what happens now so
14:54 - tools build
14:56 - oh shoot sorry supply more ipl python
15:00 - run current file so player one selection
15:02 - we're gonna drop our piece right in the
15:04 - middle so that's zero one two three this
15:06 - is the third column so three
15:10 - uh what happened why did it not fill in
15:12 - let's figure out what exactly went wrong
15:15 - there so
15:18 - should have updated the board but for
15:19 - some reason it did not
15:21 - um so let's see
15:26 - okay i see what i did wrong here so
15:30 - i accidentally put in
15:32 - two equal sign here and what we're
15:34 - really trying to do is an assignment
15:35 - we're not trying to set see if the
15:37 - boardrow column position is equal to
15:40 - that so i didn't assign it so now it
15:42 - should work so
15:44 - we'll rerun this so tools supply maripl
15:49 - python run current file player one make
15:52 - your selection
15:53 - we'll say go to the middle three
15:56 - player two make your selection we'll do
15:57 - three as well
15:59 - player one make your selection and as
16:00 - you can see one issue we're having right
16:02 - now is that the pieces are
16:04 - starting at the top and going downwards
16:06 - and so the reason for this is
16:08 - our convention was to say that this was
16:10 - the zero zero index
16:12 - but
16:13 - in the actual numpy
16:15 - they represent this right here as the
16:17 - zero zero index
16:19 - so i'm just going to add an additional
16:21 - function real quick called
16:24 - print board
16:25 - and all that's going to do
16:27 - is change the orientation
16:29 - so that what we're seeing is actually
16:30 - the
16:31 - they flipped over the way we're
16:33 - expecting to see a connect 4 board kind
16:35 - of be building
16:36 - from bottom up
16:38 - so print board and we just need to pass
16:40 - in the board and all we're going to do
16:41 - is
16:42 - there's a command
16:44 - in dumpy
16:46 - so the command is
16:50 - let me just remember it it is
16:52 - np.flip
16:55 - i'm going to do
16:57 - board and then you have to flip it over
17:00 - you have to specify the axis so the 0 is
17:01 - the axis we're going to flip the board
17:05 - over the
17:06 - x-axis
17:08 - so that should get it upside the right
17:10 - side up again so instead of doing
17:13 - a print board here we're going to now
17:14 - call our new print function so print
17:17 - board
17:18 - and then board
17:21 - and we can also do that
17:22 - down here if we want to
17:24 - print
17:27 - it doesn't matter i guess to start but
17:28 - print board whatever
17:30 - okay now let's run it again
17:33 - tools it's primary pl python run current
17:36 - file
17:37 - player will make your selection three
17:39 - three
17:40 - three and as you can see now it's
17:42 - building up from with ones and twos
17:45 - just how we expect
17:49 - the one problem with this is that if i
17:52 - actually won this game so as you can see
17:55 - i just went with player one down the
17:56 - bottom
17:57 - the game doesn't let me know at all that
17:59 - i won so we need to implement that
18:01 - functionality so we're going to define a
18:03 - function called
18:05 - winning
18:07 - move
18:09 - and we're going to have that taking the
18:11 - board and then the last piece that was
18:14 - dropped
18:17 - so winning move there's a bunch of
18:18 - different ways to implement this
18:20 - and
18:21 - the way we're going to do
18:22 - is not the most efficient method but
18:24 - it's probably the easiest to describe in
18:26 - a video so that's kind of why i'm
18:28 - selecting it but we're going to manually
18:30 - check all the different
18:32 - possible places you could win in connect
18:35 - four so all the horizontals all the
18:37 - verticals and all the diagonals
18:39 - and check to see
18:41 - if there is a winning combination on the
18:43 - board
18:44 - and because we're doing this after every
18:46 - turn we're going to pick up the first
18:47 - instance of that winning combination so
18:50 - we'll know who won
18:52 - probably the more practical way would be
18:54 - to just check around the spaces where
18:57 - the last piece was dropped but that code
19:00 - got a little bit messier when i was
19:01 - doing it before so i'm going to just do
19:03 - it this way so we're going to first
19:05 - check
19:06 - all the horizontal
19:08 - locations
19:13 - and to do that we'll have a loop that
19:15 - iterates over the columns so for c in
19:19 - ca range
19:21 - column count and so we defined a column
19:23 - count up here above and that's seven
19:26 - and one thing uh i think would be a cool
19:28 - challenge for you guys to try that i
19:30 - don't think my game is going to be able
19:32 - to do at this point in time is a very
19:34 - well designed like connect four game you
19:36 - would be able to change these numbers so
19:39 - like i could change it to say like 12 or
19:41 - something
19:42 - and this to like eight
19:44 - and the game would still be able to work
19:46 - you still have like a connect four game
19:47 - but just a bigger board and so that's a
19:49 - kind of a cool
19:51 - way to make sure like you've designed
19:52 - things
19:53 - in a smart way where you don't have just
19:56 - these random like magic numbers popping
19:57 - up all over the place and i'm actually
19:59 - going to change this real quick to row
20:01 - count
20:02 - and
20:04 - column count just because i'm going to
20:06 - try to eliminate the magic numbers where
20:08 - i can and we'll clean this up to
20:11 - uh row count
20:13 - minus one so this is the last row the
20:15 - left index of the last row okay getting
20:18 - back to winning move so
20:20 - we want to check horizontal locations
20:22 - for the win so we're going to first loop
20:23 - over all the
20:25 - columns and then we're also going to
20:27 - have a loop over all of the
20:30 - rows
20:31 - and what this loop is going to be over
20:33 - is not
20:34 - every single position but over all the
20:37 - possible starting positions for a
20:40 - horizontal wind
20:41 - so if we think about our board a
20:43 - horizontal wind can start
20:46 - this spot this spot this spot and this
20:48 - spot it can't start here because you
20:50 - can't go
20:51 - four over from this uh location so
20:55 - this is our last column the third column
20:58 - in terms of indices and then
20:59 - upwards we can go all the way to the top
21:02 - vertically because it can so
21:05 - this half sorry you can't really see but
21:08 - we're making a box around that half is
21:11 - where our starting locations can be for
21:13 - this first
21:14 - um
21:16 - this first check so we're iterating over
21:19 - the columns so it can only be
21:21 - the number of columns and then we have
21:23 - to subtract three because three of those
21:25 - columns
21:26 - couldn't actually work
21:28 - so we're subtracting three off of that
21:30 - one and then all the rows could work so
21:32 - that's totally fine so now we're going
21:34 - to check
21:35 - all the
21:36 - four in a row location so
21:39 - this is going to look like something
21:40 - like this so
21:42 - if
21:43 - board
21:45 - row
21:47 - column so this is just indexing the
21:49 - matrix
21:51 - equals equals piece
21:54 - and
21:55 - board
21:56 - row
21:58 - c plus one so this is
22:01 - taking the next one to the right so
22:03 - we're checking horizontally so we're
22:04 - only changing the columns equals equals
22:07 - piece
22:08 - and board
22:10 - our c plus two
22:14 - equals equals piece
22:16 - and then finally and board this is the
22:19 - fourth
22:20 - piece in a row board
22:23 - c plus three equals equals
22:27 - peace
22:31 - then we're going to return true
22:35 - so we want to return true the first time
22:37 - this happens we're not going to return
22:39 - this expression because that would
22:42 - return that would break out of this loop
22:43 - before we wanted it to
22:45 - okay and so what
22:47 - we write again this is not the mo the
22:49 - best way probably to write it you know
22:50 - we have these magic numbers popping up
22:53 - but it's just a very simple way to check
22:55 - for all those horizontal locations right
22:57 - so let's do the same thing with
22:59 - vertical locations
23:02 - locations for when
23:06 - and actually before i do that let's just
23:08 - uh check to see if we can get some
23:10 - functionality
23:11 - on this so if validation we're gonna
23:13 - also write a
23:15 - if statement that says if
23:17 - winning
23:18 - move
23:21 - and
23:23 - so we're going to say
23:26 - board and then the piece is one
23:30 - so if it's winning move we're gonna just
23:32 - print out
23:34 - uh player
23:37 - one
23:38 - wins
23:40 - congrats
23:41 - yay
23:45 - okay let's just see if that works with
23:46 - the horizontal real quick and then we're
23:48 - also going to want to set this game over
23:50 - variable
23:52 - uh to true because the game is in fact
23:54 - over if the move is winning so let's
23:56 - just run that real quick
23:59 - python run current file okay player one
24:02 - make your selection three
24:10 - yay it says player one wins and we i
24:12 - guess accidentally printed the board out
24:14 - one extra time but you know we did get
24:17 - that functionality it did check that
24:18 - horizontal wind so i think that looks
24:20 - good
24:21 - obviously
24:22 - um
24:23 - you'd want to test these like very
24:26 - thoroughly
24:27 - but for the sake of the time of this
24:29 - video i'm going to just start going to
24:31 - the horizontal the vertical location so
24:34 - think about where vertical locations can
24:36 - start
24:37 - um
24:38 - can start
24:39 - we need four up so it can start it's
24:41 - pretty much the opposite of the
24:43 - horizontal so vertical could start
24:46 - all of this bottom section because we
24:49 - need four up but it can be in any column
24:51 - so it's gonna be pretty similar to the
24:53 - last
24:54 - loop but we're gonna have to change the
24:56 - row
24:59 - so you'll see in a sec shift tab tab
25:05 - we're gonna have to change
25:06 - instead of the column count doing uh for
25:09 - c and column count minus three we're
25:10 - gonna have to do row count minus three
25:12 - because we can't start at the top row
25:15 - and then we're gonna have to add these
25:17 - pluses to the rows actually
25:21 - row plus one
25:24 - row plus
25:26 - two and the last one is
25:30 - row plus three and
25:32 - once again like
25:34 - see if you could figure out how to
25:36 - manipulate this
25:38 - um these equations to work for
25:41 - any length of a board and also let's say
25:44 - maybe we wanted to make a game that was
25:45 - like connect six like it would be a cool
25:47 - challenge for you guys to try to
25:49 - build these functions so that they could
25:51 - be any
25:53 - number of columns any number of rows and
25:55 - any number of
25:57 - pieces for the winning length okay so
25:59 - let's check to see if the vertical
26:00 - locations now work we're going to run
26:02 - this again
26:03 - real quick
26:04 - so tools
26:07 - python
26:08 - current file
26:10 - three
26:15 - cool it works again so we see you have
26:18 - the four in a row with the ones right
26:20 - here and it says player one wins
26:21 - congrats
26:22 - so that looks good
26:24 - uh now we have to get to the little bit
26:25 - of the trickier
26:28 - um
26:28 - things we're gonna have to check for the
26:32 - first we'll check for the positively
26:37 - sloped diagonals
26:40 - and we're also going to
26:43 - make a separate method to check for the
26:46 - negatively sloped
26:49 - and you'll see why we need to do this in
26:51 - a sec diagonals
26:55 - all right so let's think about it we're
26:57 - going to think about it the same way
26:58 - where are our possible starting
27:00 - locations
27:01 - that we could have a positively sloped
27:04 - diagonal
27:05 - well we can start here and go up we can
27:07 - start here and go up here and go up
27:10 - so i think the last piece we can start
27:13 - here and go up so this is going to be
27:16 - the top row
27:17 - and we can't go any farther than this
27:19 - piece right here so that looks like
27:21 - we're doing
27:22 - row count minus three and column count
27:24 - minus three
27:27 - so
27:30 - all right
27:32 - so we're gonna we'll just copy this code
27:34 - see oh no what happened
27:37 - see and i'll paste that in right here
27:40 - all right so we're gonna have to
27:41 - subtract three from column count and
27:43 - from row count and then how this is
27:45 - going to increment is you start with
27:47 - that initial starting location and then
27:49 - we need to plus one
27:51 - to both things because it's a
27:54 - slope it's not just a horizontal or
27:56 - vertical now so we have to
27:58 - do the addition step for both of these
28:02 - okay cool and as we've been doing let's
28:04 - just check to see if we can get a
28:06 - diagonal win here
28:10 - so player one maker selection i'll just
28:11 - start in the
28:23 - all right we're almost there
28:30 - uh so close
28:32 - don't screw this up now keith okay and
28:35 - we'll check here
28:37 - cool the diagonal there worked so that
28:39 - looks like it's working too
28:42 - and then finally we need to do the
28:43 - negatively sloped diagonals
28:48 - and so if we think about negatively
28:50 - slope diagonals they can start at the
28:52 - top and go downwards
28:54 - but they couldn't start any lower than
28:56 - this right here this is the the last one
28:59 - they could start at because they have to
29:01 - go down four
29:02 - so
29:03 - that looks like it would be
29:05 - the top rows
29:07 - and then also
29:09 - the
29:11 - columns minus three so we're going to
29:13 - start the rows at three
29:15 - and we're going to have to start the
29:18 - columns in the normal normal location so
29:21 - this is going to start from
29:23 - three to
29:25 - the row count
29:27 - and so it's three because
29:29 - if you think about it z this is the
29:31 - zeroth row
29:32 - this is the first row second row
29:35 - third row so even though it's actually
29:37 - the fourth up it's third index so that's
29:39 - why we're starting at three
29:41 - and that's going to go all the way to
29:42 - the top and the column count is actually
29:44 - good as it is and so this is going to
29:46 - have to now go
29:48 - it's going to go
29:50 - positively over in the column direction
29:52 - but it's going to go down a row so
29:54 - negative 1 here
29:57 - negative 2 here
29:59 - and this is just a negative slope you
30:01 - you know you have one direction positive
30:03 - one direction negative
30:05 - and this will be
30:06 - negative three so let's test to see if
30:08 - this works come on
30:11 - rpl python
30:14 - current file
30:17 - okay
30:18 - we'll just build up the left side first
30:27 - okay
30:28 - two
30:31 - okay
30:34 - okay okay okay we're almost into the
30:36 - negative diagonal there so player one
30:38 - you can go three
30:40 - and then player two
30:42 - two and then two
30:44 - cool the negative diagonals work now too
30:46 - okay so that looks like we have all the
30:48 - possible winning directions you should
30:50 - more thoroughly test to make sure the
30:51 - all the edge cases work but to me that
30:54 - looks pretty good so we're also going to
30:57 - implement the functionality for
30:59 - player 2 in this main game loop
31:04 - okay so this is player two
31:07 - player two wins congrats game over true
31:11 - okay
31:13 - and if you wanted to you could just
31:15 - break out of the
31:17 - the loop
31:19 - if you didn't want to see this board and
31:20 - the turns changing at the end okay so
31:23 - that's
31:24 - we've now finished the
31:26 - command line version of the game
31:31 - so we're going to take this game
31:34 - and we're going to expand on it to
31:35 - actually make it look nice so the first
31:37 - thing we're going to do to do that is
31:38 - import a library called pie game
31:42 - and just like the numpy library if you
31:44 - don't have pi game installed just open
31:45 - up a new terminal window and type in pip
31:47 - install pi game
31:50 - as you can see i already have it
31:52 - cool
31:53 - all right and now what we're going to do
31:54 - is we're going to have to start out by
31:56 - initializing pot pie game so this you
31:58 - have to do in any pie game project so
32:00 - before our game loop starts we're going
32:02 - to do pie game dot init
32:09 - okay
32:10 - and then what we're going to have to do
32:11 - is define our screen size how big do we
32:14 - want our game to be
32:15 - so
32:16 - if i real quick just build the finished
32:18 - version i have
32:20 - you can see that you know it's
32:23 - pretty
32:24 - you know you can kind of break this game
32:26 - down into squares i would say you have
32:29 - squares that represent each column in
32:30 - each row
32:32 - and then i have this one extra row at
32:34 - the top
32:35 - so we're going to define each one of
32:36 - those squares
32:38 - as
32:40 - 100 pixels so
32:42 - the sizes we're going to talk about
32:43 - right now are all in pixels so the
32:45 - square size is going to be 100 pixels
32:48 - and then our width
32:49 - for our screen is going to be
32:51 - the number of columns so the column
32:53 - count
32:54 - times the square size
32:57 - cool
32:58 - and the height
33:00 - is going to be the row count
33:02 - times the square size
33:05 - and actually if you saw my
33:07 - the game i just dragged in i'll drag it
33:08 - in one more time
33:11 - i actually added one additional row
33:13 - because i wanted this spot where i could
33:15 - display this circle that i'm dropping
33:18 - so we'll actually make this row count
33:20 - plus one times square size for the
33:23 - height
33:25 - and that will be packaged together
33:27 - nicely in a variable called size which
33:29 - will be a tuple of width comma height
33:32 - and then to get pygame to actually read
33:34 - that we need to type in the following
33:37 - screen
33:39 - equals pie game dot display dot set
33:43 - mode
33:45 - and then
33:46 - we'll
33:47 - have it read in the size
33:50 - and if you're wondering where i'm kind
33:52 - of just magically getting these
33:53 - functions from i'm looking at the
33:56 - documentation on the pi game site so if
33:58 - you go to pygame.org docs you can find
34:02 - all the kind of functions that i'm using
34:04 - i'll post a link to that in the
34:06 - description
34:13 - i'm going to real quick test to see our
34:14 - screen is actually working so you can
34:16 - just
34:17 - run control b
34:19 - and as you can see the window popped up
34:20 - and then it disappeared we'll handle why
34:23 - it's disappearing in a second
34:25 - so it looked like though it is reading
34:27 - in that screen
34:28 - cool so let's now create a function
34:31 - called
34:34 - do a couple things
34:35 - so i think first we'll define a function
34:37 - called drawboard
34:39 - and this will just be like print board
34:41 - that we defined up here but now we're
34:43 - actually going to draw it with the
34:46 - pi game graphic so draw board is gonna
34:48 - have to take in the board and that's
34:49 - about it and i'll actually pass this for
34:52 - now because we're gonna make some
34:53 - changes to our loop before we
34:55 - do this draw board
34:57 - so the first major change we're going to
34:59 - do to our loop
35:01 - is pi game is an event based
35:03 - game library
35:05 - so pi game kind of works and allows you
35:07 - to function in the game by just reading
35:10 - all of your movements of your you know
35:12 - the keys you press the mouse buttons you
35:14 - click the mouse like how you move your
35:16 - mouse it reads those all in as
35:17 - individual events so that looks like
35:20 - something like this so for event
35:22 - in pygame dot event dot get
35:26 - and as i just said events are like mouse
35:28 - motion mouse button down key down
35:31 - etc
35:34 - so we're going to read in we're going to
35:36 - drop a piece by clicking down so that's
35:38 - one of the important events we'll have
35:39 - to get
35:41 - so we're going to first do just kind of
35:44 - follow me on this one event type
35:46 - if event type equals equals pie game dot
35:49 - quit
35:51 - so this is just something you want to
35:52 - handle in all of your games that you
35:53 - make
35:54 - just allowing your game to properly exit
35:57 - out if you click the button here in the
35:59 - top right that x out x is out of it so
36:02 - if that happens
36:04 - we have to do a system exit just so it
36:06 - properly shuts down
36:08 - and to get this cis right here we're
36:10 - gonna have to import that into our
36:11 - project as well that means system and
36:13 - that comes default in any python
36:15 - installation
36:18 - okay
36:19 - system exit now to get to the more
36:21 - interesting stuff
36:23 - the event that we really are gonna care
36:25 - about to start is
36:29 - mouse button down so if event dot type
36:31 - equals equals pie game dot mouse button
36:36 - down and all the different events you
36:37 - can also find on the
36:39 - pie game website under the docs
36:43 - the game is going to run by us
36:46 - clicking down on a specific spot on the
36:48 - screen where we want to drop the piece
36:51 - so instead of reading in the column we
36:53 - want to drop it in as we did previously
36:55 - now this column is going to be populated
36:57 - by where we click
36:59 - so i'm going to real quick
37:01 - put all of this stuff all this behavior
37:04 - into this mouse button down event type
37:07 - because now the events of us dropping
37:10 - the piece always happen when we click
37:11 - the mouse button down so we don't want
37:13 - it to happen otherwise we don't want it
37:14 - to be asking for this input
37:16 - alright so column equals
37:18 - and this is going to be where we click
37:20 - on the screen so just
37:22 - for now i'm going to
37:26 - just kind of comment out this stuff just
37:28 - so it doesn't run on us while we're
37:30 - testing
37:32 - control
37:33 - and that's just real quick see if this
37:35 - fixed our error of
37:38 - the screen disappearing right when it
37:40 - pops up
37:42 - ah what happened
37:52 - print
37:56 - and as you can see now we have this
37:58 - screen and it's
38:00 - not
38:00 - you know it's staying here so that's
38:03 - because we actually added in this event
38:05 - loop here
38:06 - it knows to kind of continue while these
38:08 - events are happening and the exit out
38:10 - will be handled properly by this the
38:12 - system exit cool
38:14 - all right so
38:15 - we have our screen looking pretty good
38:17 - but doesn't have any
38:19 - graphics obviously
38:25 - so we're going to implement the
38:26 - drawboard function now
38:29 - so if we think about it
38:31 - i'll drag in the finished one i have
38:33 - again
38:34 - we're going to draw
38:36 - some sort of
38:37 - rectangle for each of these slots and
38:40 - then a black circle inside those
38:42 - rectangles
38:44 - and then we'll have to draw this
38:45 - afterwards this piece that we drop and
38:47 - then whenever we do drop a piece
38:49 - the the one or two that's in our command
38:51 - line based game will become like a red
38:53 - circle or a yellow circle based on
38:56 - what we're doing so
38:58 - let's uh implement this
39:02 - so
39:05 - first we're going to iterate through
39:08 - kind of every spot in our board so for
39:11 - r
39:12 - or for
39:13 - we'll say c in
39:15 - range
39:17 - column count
39:19 - and then we'll do the same thing for
39:21 - r and range
39:24 - row
39:26 - count just as we did above here when
39:29 - we're editing through all the the spots
39:32 - well
39:33 - we need to initially just draw it as
39:35 - like an open
39:38 - you know a
39:39 - blue blue rectangle and then in that
39:41 - blue rectangle we want a black circle so
39:44 - we're going to
39:45 - do a pie game.draw function so first
39:48 - we're going to draw a
39:49 - blue rectangle
39:52 - so that looks like kind of our game
39:54 - board and then the black circle inside
39:56 - of that will be the open slot
39:58 - so we're going to draw that on the
40:00 - screen and i'm going to drag in again
40:02 - the
40:03 - the light the library so i can see
40:06 - exactly what i'm doing so as you can see
40:08 - here pygame.dry wrecked we need to take
40:11 - in the surface the color
40:13 - the rectangle we want to draw
40:15 - and then the width
40:17 - so
40:18 - the screen is the surface we want to
40:20 - draw it on the color is we want a blue
40:22 - color so i'm going to define blue as a
40:25 - global variable a global static variable
40:27 - up above this is going to be an rgb
40:29 - value so we're going to say it's 0 0
40:33 - comma 200 and that means or 255 or so so
40:36 - that's going to be a very blue
40:38 - um
40:40 - rgb value because this means red this
40:42 - means green and this means blue and the
40:44 - only color that's
40:45 - actually has some value is the blue here
40:48 - so the color we're going to say is blue
40:50 - we just defined that that's the rgb
40:52 - value now we need to find our rectangle
40:56 - so our rectangle
40:57 - is going to be
41:00 - the you need to have four different
41:02 - things to define your rectangle you need
41:04 - to have
41:05 - the size of the width and height and
41:07 - then also the position
41:10 - so the position is going to be this
41:12 - might be take a little playing around
41:13 - with to get this but it's going to be c
41:16 - times so these are numbers 0 to
41:19 - you know the column count and zero to
41:21 - the row count there's gonna be c times
41:24 - square size
41:26 - because we want the actual this is the
41:28 - top left corner of it
41:30 - and
41:32 - that's going to the
41:43 - and then our
41:44 - position on the y-axis is going to be r
41:47 - times the square size
41:53 - and our height and width
41:56 - are going to be the other two parameters
41:58 - of this
41:59 - what that make up a rectangle object and
42:01 - that's just going to be it's going to be
42:03 - a square so it's square size square size
42:05 - height and width are the same
42:07 - and the width op argument that i showed
42:10 - was in the documentation as you can see
42:12 - it's defined as 0 so that's optional i
42:15 - think that's just the
42:16 - outline like uh the line that surrounds
42:19 - the square so we don't need to implement
42:21 - that all right let's test to see if just
42:23 - these rectangles draw properly so
42:26 - down here we'll just do a
42:29 - draw a board
42:31 - taking the board
42:33 - um as we did here and then what we have
42:35 - to do whenever we want to update our
42:37 - display is do pi game dot display dot
42:40 - update and that will make sure that we
42:41 - actually see what we're supposed to see
42:43 - so we'll build that real quick
42:45 - oh and as you can see we have this just
42:47 - giant mound of blue and the one problem
42:50 - i see right now is it's not actually
42:51 - opening up the i wanted the top to be
42:53 - open so we could have a piece that uh
42:55 - swings around it so it shows us where
42:57 - we're dropping it
42:58 - so i think the problem with that is
43:00 - because our axis starts at zero zero
43:02 - we actually need to
43:04 - to shift down by one square size to kind
43:07 - of account for that
43:09 - offset that we left for that space so
43:12 - we're gonna have to add a square size
43:14 - here
43:16 - now we build this again and as you can
43:18 - see it looks proper
43:19 - now we'll need to fill in some circles
43:21 - to represent the
43:23 - the slots
43:25 - so we'll do that by drawing a circle in
43:27 - pi game and that's also in the
43:28 - documentation so we go
43:29 - pygame.draw.circle
43:33 - and that's going to take in the surface
43:35 - of a screen
43:36 - and now we need a color
43:38 - so i think a good color
43:41 - would be just black so we'll define
43:43 - black up above too
43:45 - and black in rgb is just zero everything
43:49 - zero
43:50 - zero zero
43:53 - okay so this is black
43:56 - and then let's drag in the documentation
43:58 - real quick to see how we're going to
44:00 - finish off this circle so circle circle
44:02 - circle
44:04 - okay position and then radius so this is
44:06 - going to be the position of the center
44:08 - of the circle as you see in the
44:09 - documentation and the radius will
44:10 - probably want to be a little bit smaller
44:12 - than our square size just so there's
44:16 - the circles aren't touching
44:18 - so let's define a radius 2.
44:21 - so our radius is going to be
44:25 - define that under
44:26 - the width and height and whatnot so our
44:29 - radius is going to be
44:31 - a little bit less than the square size
44:33 - so
44:34 - we'll do i'm going to make this also
44:36 - they have to be integer values i believe
44:38 - so once we start getting into division
44:40 - it might get a little bit messy so it's
44:42 - going to be int square size
44:45 - divided by 2 because it needs to be the
44:47 - radius is half the diameter and the
44:49 - diameter would be the full square size
44:51 - then we'll just minus an arbitrary like
44:54 - integer value off of that
44:57 - so now we can draw our circle with that
45:00 - radius
45:01 - but we'll have to do the position first
45:04 - so the position
45:05 - where is it i forget oh it's in
45:07 - dropboard
45:09 - the position is going to be so if this
45:10 - is the top left of the rectangle
45:14 - our position for the center of the
45:15 - circle is going to have to
45:17 - be that
45:19 - and then with some offset
45:21 - so square size then r times
45:25 - square size
45:26 - plus square size
45:30 - and the offset is going to have to be
45:31 - like half of it because we're talking
45:33 - about the radius so half of the
45:35 - rectangle is going to be
45:37 - adding an additional square size
45:40 - divided by 2.
45:45 - adding a square size
45:48 - divided by two
45:50 - all right let's see what happens now oh
45:52 - and then actually we're gonna have to do
45:53 - the
45:54 - actually specify the radius so the
45:55 - radius is what we defined just a second
45:57 - ago
45:58 - build
46:00 - what happened uh
46:02 - yeah integer argument expected
46:04 - okay so it looks like this division
46:06 - caused us to have some floats in our
46:08 - code so we're gonna have to actually
46:09 - make this int
46:10 - yeah pi game it seems like only accepts
46:13 - integers so make sure that everything
46:15 - you
46:16 - every position and radius
46:18 - value you make a integer
46:21 - come on baby let's go
46:26 - cool yeah we got a board
46:30 - we'll finish implementing this graphics
46:32 - we'll implement the piece dropping and
46:34 - then a nice little piece follower up
46:36 - here
46:37 - so to start this video
46:39 - navigate down to the main game loop
46:43 - before when we were selecting which
46:44 - column we wanted to drop a piece in
46:47 - we mainly typed in a number between 0
46:49 - and 6 to specify this
46:52 - now that we have a graphic
46:54 - we want the column that we dropped the
46:56 - piece in to be dependent on where we
46:58 - click so if i click on the left side of
46:59 - the screen
47:01 - we want it to drop the piece in the left
47:02 - column if i click the middle the middle
47:04 - column etc
47:06 - so where we drop the piece depends on
47:08 - the x position
47:11 - of our mouse pointer
47:13 - so luckily for us pygame makes
47:16 - using the getting the x position of your
47:18 - mouse
47:19 - super easy
47:21 - so if you go to the pi game
47:23 - documentations under the events
47:26 - it lists all of these events and then it
47:27 - lists the properties you can get on
47:29 - these events so for us we care about
47:31 - mouse button down
47:33 - and we care about
47:35 - the position so position gives us an x
47:37 - comma y tuple
47:39 - of where we clicked
47:42 - and i can use that as follows
47:44 - so i can do print
47:46 - event dot position
47:49 - and then i can rerun our game and so as
47:52 - i click on the screen you'll be able to
47:53 - see in the bottom left the
47:55 - positions where i'm clicking so if i
47:58 - click in the top left of the screen it's
48:00 - about zero comma zero that's where our
48:02 - axis starts if i click on the bottom
48:04 - right of the screen that's the
48:06 - the full dimension of our game and we
48:08 - specified that to be 700 700 so these
48:11 - are the pixel values of where we're
48:13 - clicking
48:16 - to develop a
48:18 - kind of way to select the column based
48:21 - on where we click we need to try to find
48:22 - a pattern on clicking in these different
48:26 - columns so i'm going to do that real
48:28 - quick
48:29 - and if we look at all these clicks i
48:30 - just made we can see the first click is
48:33 - between 0 and 100 second click is
48:35 - between 100 and 200
48:38 - 200 and 300 etc so the last column is
48:41 - between 600 and 700 so we can somehow
48:44 - round these numbers down to just give us
48:46 - zero to six we're back at where we were
48:49 - when we mainly typed in those numbers
48:52 - so we're going to do that real quick so
48:54 - let's we can go ahead and uncomment
48:57 - all this code and actually this is
48:59 - supposed to be a comment so we can
49:00 - uncomment
49:02 - this code right here and we can just
49:04 - comment this out for now
49:07 - so
49:08 - column so we want that to be
49:12 - we'll say that the x position so this is
49:14 - a tuple in the x values first so the
49:17 - position of x
49:18 - is equal to event dot position and then
49:22 - it's the zeroth element of that
49:27 - the column now is going to be so this is
49:29 - between 0 and 700.
49:33 - so the column we can get using we're
49:36 - going to also just to make this our
49:37 - lives easier we're going to import a
49:38 - library called math this comes default
49:40 - in any python installation
49:43 - so we are going to get what we want to
49:46 - drop it by doing
49:54 - position x
49:56 - then
49:57 - we're gonna divide everything by a
49:58 - hundred because this would give us a
50:00 - range between zero and seven instead of
50:03 - zero in seven hundred so the first thing
50:05 - we're gonna do is divide it by a hundred
50:08 - and a hundred remember is what we define
50:10 - our square size sizes so to make our
50:11 - code a little bit more robust to changes
50:14 - we're going to do position x divided by
50:16 - square size
50:18 - and then we want this to be a whole
50:21 - number an integer value so we're going
50:22 - to have to take the floor of this
50:24 - division so that will round it down to
50:26 - the nearest integer so we're going to do
50:29 - math.floor
50:32 - and then the final change we're going to
50:34 - have to make
50:35 - is we just need to make sure that the
50:37 - column is an integer
50:39 - because we don't we can't take the index
50:41 - of a float value of decimal value so
50:44 - we'll just
50:45 - ensure that it's integer by just
50:46 - surrounding it with an int
50:49 - and now we should be able to see when we
50:53 - click on the screen we should see our
50:55 - board building up and we can copy the
50:57 - same thing for player two
50:59 - and we'll uncomment this
51:03 - comment that
51:05 - uncomment all of this and then we'll
51:08 - make player two be able to select the
51:10 - piece in the same way so
51:13 - we'll say position x equals event event
51:15 - opposition zero
51:17 - and then
51:19 - the column
51:21 - now
51:24 - oh my god messy
51:27 - okay we'll delete this line cool so
51:30 - let's see what happens when we build the
51:32 - game
51:33 - so now we have this uh where's the
51:36 - actual game window what happened oh it
51:38 - like didn't pop up for some reason
51:41 - so click down the middle
51:43 - if you can see over here in the bottom
51:45 - right our game did pick up that click so
51:47 - i click on the middle again
51:49 - keep clicking on the middle and it keeps
51:51 - reading that i'm dropping the pieces in
51:53 - so that looks really good now we
51:54 - actually have to just represent that on
51:56 - the screen
51:58 - so to do this we'll just make a small
52:00 - change to our
52:01 - draw board function that draws the
52:04 - graphics
52:06 - so navigate to drawboard
52:09 - and we'll just do a if statement here
52:12 - just say so the rectangle is always
52:15 - drawn the blue rectangles that make up
52:17 - the the board the black circle
52:19 - represents the empty square so
52:21 - if
52:23 - board
52:24 - i mean uh
52:25 - board
52:26 - row
52:29 - column
52:30 - equals equals zero then we want it to be
52:32 - a black we want it to be empty
52:35 - if
52:38 - else if board
52:40 - our
52:42 - row column so this is just indexing our
52:44 - matrix equals equals one so that's what
52:46 - we see here player one dropped it in the
52:49 - middle
52:50 - then we want to draw a circle so we can
52:53 - just copy this line because we know this
52:55 - is in the right position
52:57 - but we're just gonna have to change the
52:58 - color up
53:01 - so
53:02 - we don't want it to be black we'll just
53:03 - use red and yellow player one will be
53:05 - red so this is going to be red
53:08 - and this is not a built-in thing we're
53:10 - gonna have to define red
53:12 - so we'll define red right below black
53:15 - these are rgb values so r needs to be
53:18 - have a value and the other two can be
53:20 - zeros so this will give us a nice bright
53:23 - red
53:24 - and then while i'm up here doing this
53:26 - i'm also going to define yellow
53:28 - yellow is both red and green it's a
53:31 - combination of both red and green and
53:32 - rgb so 255 235 0.
53:35 - so now we have red and yellow for
53:38 - player 1 and player 2.
53:44 - where was that
53:45 - okay yeah it's red and then one last
53:48 - line
53:49 - which will be
53:53 - the else condition that'll be if board r
53:57 - comma or r c is two
54:00 - so that's going to be pi game well
54:02 - actually i'll just paste this in again
54:03 - pi game and then instead of black
54:06 - we'll make this one
54:08 - yellow
54:13 - and then one thing that might not be
54:15 - intuitive is that whenever we
54:18 - make changes to our
54:20 - game board
54:22 - after this is all done this loop has
54:23 - been iterated through we're going to
54:25 - want to call
54:26 - pygame.display.update that will
54:28 - re-render the screen with the new
54:30 - changes
54:32 - so let us let us and also we're going to
54:33 - have to add
54:35 - the drawboard we used we were printing
54:37 - board on every turn but we're going to
54:39 - draw a board
54:40 - here as well
54:43 - okay moment of truth clicking right here
54:47 - no what happened
54:50 - so it looks like it's populating it's
54:52 - just populating it in the wrong spot
54:54 - and the reason for this is because of
54:57 - how our axis is set up
55:00 - so
55:02 - as you recall when i click down on the
55:04 - top left this is the zero zero
55:07 - and this is the 700 700 space
55:11 - so
55:12 - in our game though this is the zero zero
55:16 - piece
55:17 - but it just kind of flipped so when we
55:19 - printed the board we called that np.flip
55:21 - function so we're just going to have to
55:23 - figure out a way to offset
55:25 - this to actually be on the bottom of the
55:27 - screen as opposed to the top
55:29 - so
55:30 - to do that
55:31 - we can just
55:32 - use our height smartly so what we really
55:35 - need to do is we're starting at the
55:37 - bottom
55:38 - so we need to subtract whatever we're
55:40 - actually trying to build up from the
55:41 - bottom
55:42 - from our height so height
55:44 - minus this
55:46 - height
55:49 - minus this let's try running this
55:54 - what is happening
55:56 - all right
55:57 - so we still having our issue and the
55:59 - reason we're now having an issue is
56:01 - because this
56:03 - piece right here is still filling in the
56:04 - old fashioned way so they're kind of
56:06 - like filling in black and red and yellow
56:08 - tiles all on different axes
56:11 - so what we're going to do make our lives
56:12 - easier
56:14 - is we're going to
56:16 - take out
56:18 - these two lines into another loop
56:22 - so i'm going to delete those real quick
56:25 - and
56:26 - we're just going to do a whole another
56:27 - loop
56:28 - of so just try to bear with me here i'm
56:31 - going to copy this stuff we're going to
56:33 - iterate through everything again
56:35 - this might not be the smartest way but
56:37 - it's just going to be very clean for us
56:38 - to deal with because we're always going
56:41 - to
56:43 - build our
56:45 - we're always going to build our
56:46 - background and then fill in the piece
56:48 - afterwards as opposed to like try to
56:50 - fill in our pieces as we're building the
56:52 - back round
56:54 - so i'm thinking this will work well uh
56:57 - this spacing is just messing me up and
56:59 - these lines are so long
57:01 - there we go
57:02 - okay so
57:04 - if board rc is one we're going to fill
57:07 - it with that
57:08 - then we can just delete this line
57:12 - bring this back
57:15 - okay so now we have two loops running
57:17 - but this will kind of
57:19 - fix our problem of
57:20 - them
57:21 - building our board out on different
57:23 - axises so let's try running it again
57:26 - what the heck
57:29 - if board rc equals one uh we're gonna
57:32 - have to make this an elsif otherwise
57:33 - it's gonna fill out the board uh
57:38 - for all the empty spaces at the start of
57:40 - the game equals two
57:43 - all right
57:44 - cool let's see what happens now
57:48 - it looks like it's working properly but
57:49 - it's just offset by one
57:52 - square size and that's because of this
57:55 - right here we are initially accounting
57:57 - when we're building downwards we're
57:58 - initially accounting for this but now
58:00 - that we're building upwards we can
58:01 - delete that from it
58:03 - from the height so we're going to delete
58:05 - this square size here
58:07 - we're going to delete this square size
58:09 - here
58:09 - and we should now fully have it working
58:13 - build
58:16 - yay it looks pretty good huh
58:20 - all right cool so now that we've pretty
58:22 - much fully implemented a game with
58:23 - graphics we're going to add a couple
58:25 - additional features so the first feature
58:27 - we're going to add is add this little
58:29 - scroll wheel so that before we drop a
58:31 - piece we can see what color the piece is
58:33 - and where we're going to drop it so to
58:36 - do that we're going to add a new event
58:38 - we're going to track a new event
58:40 - and that's going to be the event type
58:42 - equal to pie game dot mouse motion and
58:46 - once again all the different events you
58:48 - can use are listed in the
58:50 - pi game documentation
58:52 - and just like
58:54 - mouse button down
58:55 - the
58:56 - mouse motion also has
59:00 - a position property so i can do position
59:05 - x equals event dot position zero so this
59:09 - is going to get me a lot more events
59:11 - though because it's always tracking
59:12 - whenever i'm making any motion
59:14 - so this is going to be constantly
59:15 - updating so now we're going to use this
59:18 - position
59:19 - and
59:20 - draw some circles based on where that
59:22 - position is so if the turn
59:24 - equals equals zero
59:27 - that's a player one's going then we're
59:28 - gonna do pygame dot draw dot circle
59:33 - screen
59:34 - to the surface color is red because it's
59:37 - player one
59:38 - um
59:40 - the next thing we need to put in the
59:41 - circle is the position so the x position
59:43 - this is the center of the circle it's
59:45 - going to be at position x wherever our
59:47 - mouse is
59:48 - then we just want it to be offset enough
59:50 - so that the full circle can draw so
59:52 - we'll just make this
59:54 - square size
59:55 - divided by two
59:57 - and then finally we need to specify the
59:59 - height of
60:01 - or the the radius of the circle and
60:02 - that's just the radius we've been using
60:04 - for all the tiles
60:05 - else
60:06 - this means it's turn equals equals one
60:08 - it's player two's turn and we'll just
60:11 - copy this
60:12 - and draw it
60:15 - and now it's going to be actually yellow
60:17 - so let's look what that looks like if we
60:19 - build that
60:24 - all right
60:25 - build
60:27 - oh okay i forgot to get the display
60:30 - update just like we did in
60:32 - the draw function so
60:33 - pygame.display.update
60:37 - build
60:39 - oh it looks good but it's just not ever
60:41 - deleting the circles so what we're going
60:43 - to do to fix this is right before we
60:46 - actually
60:48 - draw the circle we'll just draw a
60:51 - rectangle that's black that will black
60:52 - out any previous circles that we have
60:54 - drawn so pygame.draw.rectangle
60:58 - surfaces of the screen
61:00 - color is black
61:03 - position is going to start at the top
61:04 - left so that's zero zero
61:07 - it's going to have width the whole width
61:09 - of the screen and then the height will
61:11 - be a square size because that's how big
61:13 - that buffer bar kind of at the top is
61:16 - and
61:17 - that should be good
61:19 - i think i might have one extra no oh
61:22 - yeah i have one extra
61:24 - parenthesis there
61:26 - yay looks good so now we have this game
61:28 - over drop
61:31 - drop
61:32 - drop
61:34 - drop
61:35 - drop
61:36 - that looks good cool
61:38 - and so one thing that you also might
61:40 - want to change is that if i win the game
61:42 - so i'll win the game real quick with red
61:46 - it automatically closes right away so
61:48 - one thing we can do
61:49 - is we can add a weight pi game has a
61:52 - built-in weight
61:53 - function so what we can do is if the
61:56 - game over condition is true so if game
61:59 - over we'll call pygame.time.wait
62:03 - and this is the milliseconds you want to
62:05 - wait so 3000 would equal three seconds
62:07 - so if i run this again
62:12 - one
62:13 - two
62:13 - three
62:15 - it'll shut down automatically
62:17 - cool
62:18 - and then right before it shuts down we
62:19 - wanted some notification that the player
62:21 - actually won so initially we were
62:22 - printing it but now we'll actually
62:24 - render the print function on our screen
62:27 - so that will look something like
62:31 - as
62:32 - follows so we're going to
62:35 - delete the line that says player 1 wins
62:38 - and we're going to initialize
62:40 - a font up top so that will look like
62:44 - we'll do it right below the first update
62:47 - so we'll do my font equals
62:50 - pygame dot font dot system font this is
62:54 - all in the documentation i'm just
62:55 - copying some previous code i wrote
62:57 - and the last time i wrote this i'd use a
62:59 - font called mono
63:01 - but there's other options you can look
63:03 - at the documentation for all the details
63:05 - and we'll do font size 75
63:08 - that's just an arbitrary number that i
63:09 - found worked and then if we go down
63:12 - below
63:13 - to actually render that on the screen
63:15 - horizontally
63:16 - i can type the following i can say
63:19 - label
63:20 - equals my font dot render
63:24 - player one
63:26 - wins exclamation
63:28 - and then
63:30 - i believe this one right here that i
63:31 - just put in specifies the axes
63:34 - that it's on i'm not actually sure i
63:36 - might play around with that to check
63:38 - and then we want the color to be red
63:40 - because uh it's rendering that text red
63:43 - because player one one and then what we
63:45 - have to do to get that on the screen
63:47 - do it quickly we could also use the
63:48 - pygame
63:50 - display.update function but i'm gonna do
63:51 - something a little different here
63:53 - i'm gonna do a screen.blit and that just
63:56 - updates that specific part of the screen
63:58 - and i
64:00 - toyed around with these values before i
64:02 - found that
64:03 - the xy pair where this will start at the
64:05 - top left of corner of this text starting
64:07 - at 40 comma 10 worked pretty well so
64:09 - let's see what happens when i run that
64:11 - so we're gonna have red win
64:15 - player one wins
64:18 - and
64:25 - the one thing is that tile gets in the
64:26 - way
64:28 - um
64:29 - what we could potentially do we could
64:30 - potentially draw another black rectangle
64:32 - if we wanted to
64:34 - um
64:36 - i don't know i'm not too bothered by it
64:37 - we'll fix it in one sec we're going to
64:38 - copy this for player two
64:44 - and i'll say player two wins and the
64:46 - color is gonna be yellow now
64:51 - build so what happens if yellow wins
64:57 - i'm making this so hard on myself
65:01 - player two wins yay
65:05 - all right and
65:08 - maybe what we'll do is at the start of
65:10 - the mouse button down
65:12 - we will draw that black rectangle as
65:14 - well so we don't have that annoying
65:18 - annoying tile getting in our way so
65:20 - right before we click the mouse button
65:21 - down that will make the thing disappear
65:24 - run it one more time
65:29 - player one wins it looks good and you
65:31 - can mess around with that as you see fit
65:34 - okay i mean that's like a pretty
65:36 - good game i'm pretty happy with it if
65:38 - you have any questions about it leave a
65:40 - comment below
65:41 - peace

Cleaned transcript:

what's up guys in this video i'm going to show you how to program connect 4 in python by the end of these videos you'll build something that looks like this it's a simple twoplayer connect 4 game with graphics i think this is a really good exercise for your beginner to intermediate level python programmers who want to build their skills i'll just finish up a game real quick just so you can see how this fully works as you can see i have the diagonal and it says player one wins cool we're gonna do something a little bit simpler and then build up to that graphic based connect four game it's a command line connect four game where you actually manually type in numbers to drop your pieces so you see the one there the two etcetera all right so let's start building that just quickly i want to mention that i'll be programming in python 3 and then using sublime text 2 as my editor i posted a link to a video on how to set up these things in the description so one of the first questions i asked myself when i was writing this game is what is the best way to represent the board so if i drag on a connect 4 board real quick you can see that it is 6 rows by 7 columns and to me this looks like the perfect structure to represent as a matrix in python so that's what we'll do so we'll define a function called create board and that's not going to accept any inputs then we're going to make a a matrix of all zeros with the dimensions six by seven and to help us do this we're going to import a package called numpy and if you haven't already installed this you can open up a terminal window and just type in pip install numpy and as you can see i already have it so we're going to use this as follows we're going to say board equals numpy dot zeros and that's going to make a matrix of all zeros which is good for our initial state and then the dimensions six rows by seven columns cool and then we just need to return that board and we can test to make sure that worked by doing the following create board and then print board and as you can see if i run oh no what happened as you can see if i run that um we we do in fact have this six by seven matrix of all zeros so that looks good we can begin writing the main game loop now so we're going to write a loop that says while not game over and so our loop is going to be running as long as this game over variable is false and the only way it becomes true is if someone has a four in a row so we need to initialize the game over to be false to begin with equals false and the only way that's going to switch to true is if someone got a four in a row so now we're going to need to we're also going to want to real quick make our board initialize before we start the game just so we have something to put pieces into so we have our board we have our game over variable and now we're going to want to be able to ask for player 1 input and then we're also going to want to eventually be able to ask ask for player 2 input so this kind of leads us to the problem of oh how do we differentiate between whether it's player 1 or player 2's turn so we're always going to define another variable up here called turn that's just going to initialize to 0. so what we're going to say is if turn equals equals zero then we're going to want to ask for player one input all right so in python there's a function a builtin function called input as you can see it highlights blue for me so we're gonna say selection equals input and then we're gonna say player one make your selection so this is what the player one is gonna see and then the way we're going to initialize this game is we're going to just say they can type in between 0 and 6. so this is what the player 1 should see so if i build this you see we run into this error so this is because um sublime text doesn't accept this input function so my work around for this was i installed a package in sublime called sublime repl i'll put a link in the description on how to install this and i can run the input function through that so now you can see player one make your selection three and it doesn't do anything with that input right now but you can see that it's asking me that and i can type in hit enter all right cool so we also just want to make sure that it saves our selection properly so we're going to print selection and i also just want to see you know if i type in a number does it actually give me the number or does it give me a string that represents the number so i'm going to also print in type of selection i just want to see what we're getting so i'm going to run that again and as you can see error again but we're going to go to slime rpl and the link is in the description as i just said run current files so two and as you can see it gets two but it says it's a string so we're going to want to make sure that it's actually a integer so we can just surround this with int input one and this should work so let's see run that again and you can also run this through the command line so if you run this in your terminal go to the the directory that the file is in and type in python and then file name it will also run just as i'm running it in this sublime repl player one make your selection three cool and now you see it says three and it says the class of that is an int so that looks good to me so now you can save some sort of selection from the user and you can also edit this so that it requires you to make a specific num type in a specific number but we'll just leave it as like we'll imagine our players are following the directions right now all right cool we have that and then we're also going to want to be able to ask for player 2's input so that's going to happen else otherwise so if the turn is not equal to zero um then we want to ask for player two input so selection equals and we'll just copy this from above and we'll just have to change this to say player two make your selection all right cool and now at the end of the turn no matter whose turn it is we're gonna want to increase um our turn by one so turn plus e or plus equals one so i'll make it increment it by one and then we're also what we're going to also want to do is we're going to just make this odd even so we're going to use mod division so it's going to be turn mod to turn equals turn mod 2 and this is just basically making it go uh take the remainder of whatever our turn is divided by 2. so this is just going to alternate it between 0 and 1. so it will alternate between player 1's turn and player 2's turn so let's just see if this works properly so we're going to run this build python current file player one make your selection two player two make your selection four player one make your selection two oh that looks good it's alternating between our player one and our player two cool okay and now we're gonna wanna start building our actual functionality we're gonna wanna be able to make this selection right here actually drop a piece into our board so i'm going to find another function up here called definition drop piece and we might define a couple functions so maybe have a drop piece and then we'll just do pass for now and maybe we'll also have like is valid location so that will check whatever number that the player typed in we'll check to see if that's a valid location we'll also define a function called get next open row and how all these functions are going to work together is as follows so it all begins with the player making a selection the 0 to 6 here represents the column that they want to drop their piece in so maybe a more appropriate title for this would be col representing column col next we're going to take this column and the current board we have and pass it into this is valid location function so board column and to visualize how we can check to see if the column they selected is a valid location we will print out the board real quick so as you can see imagine this is the zeroth row is the first row second row all the way up to the fifth row here and then this is the zeroth column first column second column etc we're starting at zero as our first index so if we wanted to check if the column that the user selected let's just assume that the user always types in a valid number zero to six if we wanted to check to see if it's valid all we need to do is make sure that this top row for that specific column is not been filled so let's imagine that we're putting ones in for player one going and two's in for player two going so if this top row is still zero for the specific column we selected then we know that it's okay for us to drop a piece in that row or in that column it hasn't been filled all the way to the top so to do that so this is the fifth row so all i'm going to do is just check to see whether or not the position at the fifth row and let's say you know whatever column we select is zero and if it is that means the column is still free if it's not then that's not a valid location we'll have to have the user try something else so to do that let's just do board so we're going to return board and then the the row is 5 and the column is whatever the user selected so here so and we're going to make sure that's equal equals zero so if that's true then we're good to we're good to let them drop the piece there if that's not true then that means the column has been filled up all the way and one thing i'll note that will probably change in a future video is that it's kind of getting messy my code a little bit with just throwing these random numbers here all the way all over the place and programming these are called magic numbers you kind of don't know where they come from so i'll clean those up in some of the future videos in this series so return board five column equals equals zero and that is just checking to make sure that that column has an empty slot okay so now that we've gotten the valid location let's get the next open row in that column so if we think back to our board that's just checking to see when we drop it in let's say the zeroth column here on the the left checking to see which row of these if the piece will fall on so to do this we're going to write a quick little loop so we're going to do for and we're gonna also have to pass in the board and the column into this one so the loop we're gonna write here is for r and range and i'm actually going to start getting rid of some of these magic numbers so i'm going to initialize a global variable called row count and often globals are capitalized just to show that or static variables that don't change or capitalize just to show that they're a nonchanging variable so the number of rows we have is six and the number of columns we have is seven so i'm going to do for r so for row in range so the number of rows we have so row count we're going to check the board position we're going to see if board r position or so the column equals equals zero then we want to return that row so basically if the row is equal to zero so imagine we're filling this whole board up with ones and twos if the slot is still zero that means it's empty still so we're going to return the first instance that it's empty so this r is going to count from zero to uh row count minus one and we're going to return that first case where it equals zero okay so now we've got the next open row and then finally what we're going to want to do is drop the piece so this is going to take in the board the row and the column and then we'll also add something we'll just call it the piece so whether it's player one or two going so all this is going to do is go board row column equals equals the piece so we're going to make it fill in the board with whatever piece that the player just dropped so let's put this all together in our loop so first we got the column and now we're going to check if is valid location of the board in the column and then we can start getting the next empty row so row equals get next open row and that takes in the board and column as well so get next input and row board column and then we're going to finally drop piece and we're gonna take in the board the row the column and then for player one the piece is just the one and we're gonna copy this in to player two as well because player one and player two the functionality of what they're doing is the same but we'll just have to change the piece here to two so now and then finally probably after the player goes we'll probably want to print out the board so we'll print the board here and let's see what happens now so tools build oh shoot sorry supply more ipl python run current file so player one selection we're gonna drop our piece right in the middle so that's zero one two three this is the third column so three uh what happened why did it not fill in let's figure out what exactly went wrong there so should have updated the board but for some reason it did not um so let's see okay i see what i did wrong here so i accidentally put in two equal sign here and what we're really trying to do is an assignment we're not trying to set see if the boardrow column position is equal to that so i didn't assign it so now it should work so we'll rerun this so tools supply maripl python run current file player one make your selection we'll say go to the middle three player two make your selection we'll do three as well player one make your selection and as you can see one issue we're having right now is that the pieces are starting at the top and going downwards and so the reason for this is our convention was to say that this was the zero zero index but in the actual numpy they represent this right here as the zero zero index so i'm just going to add an additional function real quick called print board and all that's going to do is change the orientation so that what we're seeing is actually the they flipped over the way we're expecting to see a connect 4 board kind of be building from bottom up so print board and we just need to pass in the board and all we're going to do is there's a command in dumpy so the command is let me just remember it it is np.flip i'm going to do board and then you have to flip it over you have to specify the axis so the 0 is the axis we're going to flip the board over the xaxis so that should get it upside the right side up again so instead of doing a print board here we're going to now call our new print function so print board and then board and we can also do that down here if we want to print it doesn't matter i guess to start but print board whatever okay now let's run it again tools it's primary pl python run current file player will make your selection three three three and as you can see now it's building up from with ones and twos just how we expect the one problem with this is that if i actually won this game so as you can see i just went with player one down the bottom the game doesn't let me know at all that i won so we need to implement that functionality so we're going to define a function called winning move and we're going to have that taking the board and then the last piece that was dropped so winning move there's a bunch of different ways to implement this and the way we're going to do is not the most efficient method but it's probably the easiest to describe in a video so that's kind of why i'm selecting it but we're going to manually check all the different possible places you could win in connect four so all the horizontals all the verticals and all the diagonals and check to see if there is a winning combination on the board and because we're doing this after every turn we're going to pick up the first instance of that winning combination so we'll know who won probably the more practical way would be to just check around the spaces where the last piece was dropped but that code got a little bit messier when i was doing it before so i'm going to just do it this way so we're going to first check all the horizontal locations and to do that we'll have a loop that iterates over the columns so for c in ca range column count and so we defined a column count up here above and that's seven and one thing uh i think would be a cool challenge for you guys to try that i don't think my game is going to be able to do at this point in time is a very well designed like connect four game you would be able to change these numbers so like i could change it to say like 12 or something and this to like eight and the game would still be able to work you still have like a connect four game but just a bigger board and so that's a kind of a cool way to make sure like you've designed things in a smart way where you don't have just these random like magic numbers popping up all over the place and i'm actually going to change this real quick to row count and column count just because i'm going to try to eliminate the magic numbers where i can and we'll clean this up to uh row count minus one so this is the last row the left index of the last row okay getting back to winning move so we want to check horizontal locations for the win so we're going to first loop over all the columns and then we're also going to have a loop over all of the rows and what this loop is going to be over is not every single position but over all the possible starting positions for a horizontal wind so if we think about our board a horizontal wind can start this spot this spot this spot and this spot it can't start here because you can't go four over from this uh location so this is our last column the third column in terms of indices and then upwards we can go all the way to the top vertically because it can so this half sorry you can't really see but we're making a box around that half is where our starting locations can be for this first um this first check so we're iterating over the columns so it can only be the number of columns and then we have to subtract three because three of those columns couldn't actually work so we're subtracting three off of that one and then all the rows could work so that's totally fine so now we're going to check all the four in a row location so this is going to look like something like this so if board row column so this is just indexing the matrix equals equals piece and board row c plus one so this is taking the next one to the right so we're checking horizontally so we're only changing the columns equals equals piece and board our c plus two equals equals piece and then finally and board this is the fourth piece in a row board c plus three equals equals peace then we're going to return true so we want to return true the first time this happens we're not going to return this expression because that would return that would break out of this loop before we wanted it to okay and so what we write again this is not the mo the best way probably to write it you know we have these magic numbers popping up but it's just a very simple way to check for all those horizontal locations right so let's do the same thing with vertical locations locations for when and actually before i do that let's just uh check to see if we can get some functionality on this so if validation we're gonna also write a if statement that says if winning move and so we're going to say board and then the piece is one so if it's winning move we're gonna just print out uh player one wins congrats yay okay let's just see if that works with the horizontal real quick and then we're also going to want to set this game over variable uh to true because the game is in fact over if the move is winning so let's just run that real quick python run current file okay player one make your selection three yay it says player one wins and we i guess accidentally printed the board out one extra time but you know we did get that functionality it did check that horizontal wind so i think that looks good obviously um you'd want to test these like very thoroughly but for the sake of the time of this video i'm going to just start going to the horizontal the vertical location so think about where vertical locations can start um can start we need four up so it can start it's pretty much the opposite of the horizontal so vertical could start all of this bottom section because we need four up but it can be in any column so it's gonna be pretty similar to the last loop but we're gonna have to change the row so you'll see in a sec shift tab tab we're gonna have to change instead of the column count doing uh for c and column count minus three we're gonna have to do row count minus three because we can't start at the top row and then we're gonna have to add these pluses to the rows actually row plus one row plus two and the last one is row plus three and once again like see if you could figure out how to manipulate this um these equations to work for any length of a board and also let's say maybe we wanted to make a game that was like connect six like it would be a cool challenge for you guys to try to build these functions so that they could be any number of columns any number of rows and any number of pieces for the winning length okay so let's check to see if the vertical locations now work we're going to run this again real quick so tools python current file three cool it works again so we see you have the four in a row with the ones right here and it says player one wins congrats so that looks good uh now we have to get to the little bit of the trickier um things we're gonna have to check for the first we'll check for the positively sloped diagonals and we're also going to make a separate method to check for the negatively sloped and you'll see why we need to do this in a sec diagonals all right so let's think about it we're going to think about it the same way where are our possible starting locations that we could have a positively sloped diagonal well we can start here and go up we can start here and go up here and go up so i think the last piece we can start here and go up so this is going to be the top row and we can't go any farther than this piece right here so that looks like we're doing row count minus three and column count minus three so all right so we're gonna we'll just copy this code see oh no what happened see and i'll paste that in right here all right so we're gonna have to subtract three from column count and from row count and then how this is going to increment is you start with that initial starting location and then we need to plus one to both things because it's a slope it's not just a horizontal or vertical now so we have to do the addition step for both of these okay cool and as we've been doing let's just check to see if we can get a diagonal win here so player one maker selection i'll just start in the all right we're almost there uh so close don't screw this up now keith okay and we'll check here cool the diagonal there worked so that looks like it's working too and then finally we need to do the negatively sloped diagonals and so if we think about negatively slope diagonals they can start at the top and go downwards but they couldn't start any lower than this right here this is the the last one they could start at because they have to go down four so that looks like it would be the top rows and then also the columns minus three so we're going to start the rows at three and we're going to have to start the columns in the normal normal location so this is going to start from three to the row count and so it's three because if you think about it z this is the zeroth row this is the first row second row third row so even though it's actually the fourth up it's third index so that's why we're starting at three and that's going to go all the way to the top and the column count is actually good as it is and so this is going to have to now go it's going to go positively over in the column direction but it's going to go down a row so negative 1 here negative 2 here and this is just a negative slope you you know you have one direction positive one direction negative and this will be negative three so let's test to see if this works come on rpl python current file okay we'll just build up the left side first okay two okay okay okay okay we're almost into the negative diagonal there so player one you can go three and then player two two and then two cool the negative diagonals work now too okay so that looks like we have all the possible winning directions you should more thoroughly test to make sure the all the edge cases work but to me that looks pretty good so we're also going to implement the functionality for player 2 in this main game loop okay so this is player two player two wins congrats game over true okay and if you wanted to you could just break out of the the loop if you didn't want to see this board and the turns changing at the end okay so that's we've now finished the command line version of the game so we're going to take this game and we're going to expand on it to actually make it look nice so the first thing we're going to do to do that is import a library called pie game and just like the numpy library if you don't have pi game installed just open up a new terminal window and type in pip install pi game as you can see i already have it cool all right and now what we're going to do is we're going to have to start out by initializing pot pie game so this you have to do in any pie game project so before our game loop starts we're going to do pie game dot init okay and then what we're going to have to do is define our screen size how big do we want our game to be so if i real quick just build the finished version i have you can see that you know it's pretty you know you can kind of break this game down into squares i would say you have squares that represent each column in each row and then i have this one extra row at the top so we're going to define each one of those squares as 100 pixels so the sizes we're going to talk about right now are all in pixels so the square size is going to be 100 pixels and then our width for our screen is going to be the number of columns so the column count times the square size cool and the height is going to be the row count times the square size and actually if you saw my the game i just dragged in i'll drag it in one more time i actually added one additional row because i wanted this spot where i could display this circle that i'm dropping so we'll actually make this row count plus one times square size for the height and that will be packaged together nicely in a variable called size which will be a tuple of width comma height and then to get pygame to actually read that we need to type in the following screen equals pie game dot display dot set mode and then we'll have it read in the size and if you're wondering where i'm kind of just magically getting these functions from i'm looking at the documentation on the pi game site so if you go to pygame.org docs you can find all the kind of functions that i'm using i'll post a link to that in the description i'm going to real quick test to see our screen is actually working so you can just run control b and as you can see the window popped up and then it disappeared we'll handle why it's disappearing in a second so it looked like though it is reading in that screen cool so let's now create a function called do a couple things so i think first we'll define a function called drawboard and this will just be like print board that we defined up here but now we're actually going to draw it with the pi game graphic so draw board is gonna have to take in the board and that's about it and i'll actually pass this for now because we're gonna make some changes to our loop before we do this draw board so the first major change we're going to do to our loop is pi game is an event based game library so pi game kind of works and allows you to function in the game by just reading all of your movements of your you know the keys you press the mouse buttons you click the mouse like how you move your mouse it reads those all in as individual events so that looks like something like this so for event in pygame dot event dot get and as i just said events are like mouse motion mouse button down key down etc so we're going to read in we're going to drop a piece by clicking down so that's one of the important events we'll have to get so we're going to first do just kind of follow me on this one event type if event type equals equals pie game dot quit so this is just something you want to handle in all of your games that you make just allowing your game to properly exit out if you click the button here in the top right that x out x is out of it so if that happens we have to do a system exit just so it properly shuts down and to get this cis right here we're gonna have to import that into our project as well that means system and that comes default in any python installation okay system exit now to get to the more interesting stuff the event that we really are gonna care about to start is mouse button down so if event dot type equals equals pie game dot mouse button down and all the different events you can also find on the pie game website under the docs the game is going to run by us clicking down on a specific spot on the screen where we want to drop the piece so instead of reading in the column we want to drop it in as we did previously now this column is going to be populated by where we click so i'm going to real quick put all of this stuff all this behavior into this mouse button down event type because now the events of us dropping the piece always happen when we click the mouse button down so we don't want it to happen otherwise we don't want it to be asking for this input alright so column equals and this is going to be where we click on the screen so just for now i'm going to just kind of comment out this stuff just so it doesn't run on us while we're testing control and that's just real quick see if this fixed our error of the screen disappearing right when it pops up ah what happened print and as you can see now we have this screen and it's not you know it's staying here so that's because we actually added in this event loop here it knows to kind of continue while these events are happening and the exit out will be handled properly by this the system exit cool all right so we have our screen looking pretty good but doesn't have any graphics obviously so we're going to implement the drawboard function now so if we think about it i'll drag in the finished one i have again we're going to draw some sort of rectangle for each of these slots and then a black circle inside those rectangles and then we'll have to draw this afterwards this piece that we drop and then whenever we do drop a piece the the one or two that's in our command line based game will become like a red circle or a yellow circle based on what we're doing so let's uh implement this so first we're going to iterate through kind of every spot in our board so for r or for we'll say c in range column count and then we'll do the same thing for r and range row count just as we did above here when we're editing through all the the spots well we need to initially just draw it as like an open you know a blue blue rectangle and then in that blue rectangle we want a black circle so we're going to do a pie game.draw function so first we're going to draw a blue rectangle so that looks like kind of our game board and then the black circle inside of that will be the open slot so we're going to draw that on the screen and i'm going to drag in again the the light the library so i can see exactly what i'm doing so as you can see here pygame.dry wrecked we need to take in the surface the color the rectangle we want to draw and then the width so the screen is the surface we want to draw it on the color is we want a blue color so i'm going to define blue as a global variable a global static variable up above this is going to be an rgb value so we're going to say it's 0 0 comma 200 and that means or 255 or so so that's going to be a very blue um rgb value because this means red this means green and this means blue and the only color that's actually has some value is the blue here so the color we're going to say is blue we just defined that that's the rgb value now we need to find our rectangle so our rectangle is going to be the you need to have four different things to define your rectangle you need to have the size of the width and height and then also the position so the position is going to be this might be take a little playing around with to get this but it's going to be c times so these are numbers 0 to you know the column count and zero to the row count there's gonna be c times square size because we want the actual this is the top left corner of it and that's going to the and then our position on the yaxis is going to be r times the square size and our height and width are going to be the other two parameters of this what that make up a rectangle object and that's just going to be it's going to be a square so it's square size square size height and width are the same and the width op argument that i showed was in the documentation as you can see it's defined as 0 so that's optional i think that's just the outline like uh the line that surrounds the square so we don't need to implement that all right let's test to see if just these rectangles draw properly so down here we'll just do a draw a board taking the board um as we did here and then what we have to do whenever we want to update our display is do pi game dot display dot update and that will make sure that we actually see what we're supposed to see so we'll build that real quick oh and as you can see we have this just giant mound of blue and the one problem i see right now is it's not actually opening up the i wanted the top to be open so we could have a piece that uh swings around it so it shows us where we're dropping it so i think the problem with that is because our axis starts at zero zero we actually need to to shift down by one square size to kind of account for that offset that we left for that space so we're gonna have to add a square size here now we build this again and as you can see it looks proper now we'll need to fill in some circles to represent the the slots so we'll do that by drawing a circle in pi game and that's also in the documentation so we go pygame.draw.circle and that's going to take in the surface of a screen and now we need a color so i think a good color would be just black so we'll define black up above too and black in rgb is just zero everything zero zero zero okay so this is black and then let's drag in the documentation real quick to see how we're going to finish off this circle so circle circle circle okay position and then radius so this is going to be the position of the center of the circle as you see in the documentation and the radius will probably want to be a little bit smaller than our square size just so there's the circles aren't touching so let's define a radius 2. so our radius is going to be define that under the width and height and whatnot so our radius is going to be a little bit less than the square size so we'll do i'm going to make this also they have to be integer values i believe so once we start getting into division it might get a little bit messy so it's going to be int square size divided by 2 because it needs to be the radius is half the diameter and the diameter would be the full square size then we'll just minus an arbitrary like integer value off of that so now we can draw our circle with that radius but we'll have to do the position first so the position where is it i forget oh it's in dropboard the position is going to be so if this is the top left of the rectangle our position for the center of the circle is going to have to be that and then with some offset so square size then r times square size plus square size and the offset is going to have to be like half of it because we're talking about the radius so half of the rectangle is going to be adding an additional square size divided by 2. adding a square size divided by two all right let's see what happens now oh and then actually we're gonna have to do the actually specify the radius so the radius is what we defined just a second ago build what happened uh yeah integer argument expected okay so it looks like this division caused us to have some floats in our code so we're gonna have to actually make this int yeah pi game it seems like only accepts integers so make sure that everything you every position and radius value you make a integer come on baby let's go cool yeah we got a board we'll finish implementing this graphics we'll implement the piece dropping and then a nice little piece follower up here so to start this video navigate down to the main game loop before when we were selecting which column we wanted to drop a piece in we mainly typed in a number between 0 and 6 to specify this now that we have a graphic we want the column that we dropped the piece in to be dependent on where we click so if i click on the left side of the screen we want it to drop the piece in the left column if i click the middle the middle column etc so where we drop the piece depends on the x position of our mouse pointer so luckily for us pygame makes using the getting the x position of your mouse super easy so if you go to the pi game documentations under the events it lists all of these events and then it lists the properties you can get on these events so for us we care about mouse button down and we care about the position so position gives us an x comma y tuple of where we clicked and i can use that as follows so i can do print event dot position and then i can rerun our game and so as i click on the screen you'll be able to see in the bottom left the positions where i'm clicking so if i click in the top left of the screen it's about zero comma zero that's where our axis starts if i click on the bottom right of the screen that's the the full dimension of our game and we specified that to be 700 700 so these are the pixel values of where we're clicking to develop a kind of way to select the column based on where we click we need to try to find a pattern on clicking in these different columns so i'm going to do that real quick and if we look at all these clicks i just made we can see the first click is between 0 and 100 second click is between 100 and 200 200 and 300 etc so the last column is between 600 and 700 so we can somehow round these numbers down to just give us zero to six we're back at where we were when we mainly typed in those numbers so we're going to do that real quick so let's we can go ahead and uncomment all this code and actually this is supposed to be a comment so we can uncomment this code right here and we can just comment this out for now so column so we want that to be we'll say that the x position so this is a tuple in the x values first so the position of x is equal to event dot position and then it's the zeroth element of that the column now is going to be so this is between 0 and 700. so the column we can get using we're going to also just to make this our lives easier we're going to import a library called math this comes default in any python installation so we are going to get what we want to drop it by doing position x then we're gonna divide everything by a hundred because this would give us a range between zero and seven instead of zero in seven hundred so the first thing we're gonna do is divide it by a hundred and a hundred remember is what we define our square size sizes so to make our code a little bit more robust to changes we're going to do position x divided by square size and then we want this to be a whole number an integer value so we're going to have to take the floor of this division so that will round it down to the nearest integer so we're going to do math.floor and then the final change we're going to have to make is we just need to make sure that the column is an integer because we don't we can't take the index of a float value of decimal value so we'll just ensure that it's integer by just surrounding it with an int and now we should be able to see when we click on the screen we should see our board building up and we can copy the same thing for player two and we'll uncomment this comment that uncomment all of this and then we'll make player two be able to select the piece in the same way so we'll say position x equals event event opposition zero and then the column now oh my god messy okay we'll delete this line cool so let's see what happens when we build the game so now we have this uh where's the actual game window what happened oh it like didn't pop up for some reason so click down the middle if you can see over here in the bottom right our game did pick up that click so i click on the middle again keep clicking on the middle and it keeps reading that i'm dropping the pieces in so that looks really good now we actually have to just represent that on the screen so to do this we'll just make a small change to our draw board function that draws the graphics so navigate to drawboard and we'll just do a if statement here just say so the rectangle is always drawn the blue rectangles that make up the the board the black circle represents the empty square so if board i mean uh board row column equals equals zero then we want it to be a black we want it to be empty if else if board our row column so this is just indexing our matrix equals equals one so that's what we see here player one dropped it in the middle then we want to draw a circle so we can just copy this line because we know this is in the right position but we're just gonna have to change the color up so we don't want it to be black we'll just use red and yellow player one will be red so this is going to be red and this is not a builtin thing we're gonna have to define red so we'll define red right below black these are rgb values so r needs to be have a value and the other two can be zeros so this will give us a nice bright red and then while i'm up here doing this i'm also going to define yellow yellow is both red and green it's a combination of both red and green and rgb so 255 235 0. so now we have red and yellow for player 1 and player 2. where was that okay yeah it's red and then one last line which will be the else condition that'll be if board r comma or r c is two so that's going to be pi game well actually i'll just paste this in again pi game and then instead of black we'll make this one yellow and then one thing that might not be intuitive is that whenever we make changes to our game board after this is all done this loop has been iterated through we're going to want to call pygame.display.update that will rerender the screen with the new changes so let us let us and also we're going to have to add the drawboard we used we were printing board on every turn but we're going to draw a board here as well okay moment of truth clicking right here no what happened so it looks like it's populating it's just populating it in the wrong spot and the reason for this is because of how our axis is set up so as you recall when i click down on the top left this is the zero zero and this is the 700 700 space so in our game though this is the zero zero piece but it just kind of flipped so when we printed the board we called that np.flip function so we're just going to have to figure out a way to offset this to actually be on the bottom of the screen as opposed to the top so to do that we can just use our height smartly so what we really need to do is we're starting at the bottom so we need to subtract whatever we're actually trying to build up from the bottom from our height so height minus this height minus this let's try running this what is happening all right so we still having our issue and the reason we're now having an issue is because this piece right here is still filling in the old fashioned way so they're kind of like filling in black and red and yellow tiles all on different axes so what we're going to do make our lives easier is we're going to take out these two lines into another loop so i'm going to delete those real quick and we're just going to do a whole another loop of so just try to bear with me here i'm going to copy this stuff we're going to iterate through everything again this might not be the smartest way but it's just going to be very clean for us to deal with because we're always going to build our we're always going to build our background and then fill in the piece afterwards as opposed to like try to fill in our pieces as we're building the back round so i'm thinking this will work well uh this spacing is just messing me up and these lines are so long there we go okay so if board rc is one we're going to fill it with that then we can just delete this line bring this back okay so now we have two loops running but this will kind of fix our problem of them building our board out on different axises so let's try running it again what the heck if board rc equals one uh we're gonna have to make this an elsif otherwise it's gonna fill out the board uh for all the empty spaces at the start of the game equals two all right cool let's see what happens now it looks like it's working properly but it's just offset by one square size and that's because of this right here we are initially accounting when we're building downwards we're initially accounting for this but now that we're building upwards we can delete that from it from the height so we're going to delete this square size here we're going to delete this square size here and we should now fully have it working build yay it looks pretty good huh all right cool so now that we've pretty much fully implemented a game with graphics we're going to add a couple additional features so the first feature we're going to add is add this little scroll wheel so that before we drop a piece we can see what color the piece is and where we're going to drop it so to do that we're going to add a new event we're going to track a new event and that's going to be the event type equal to pie game dot mouse motion and once again all the different events you can use are listed in the pi game documentation and just like mouse button down the mouse motion also has a position property so i can do position x equals event dot position zero so this is going to get me a lot more events though because it's always tracking whenever i'm making any motion so this is going to be constantly updating so now we're going to use this position and draw some circles based on where that position is so if the turn equals equals zero that's a player one's going then we're gonna do pygame dot draw dot circle screen to the surface color is red because it's player one um the next thing we need to put in the circle is the position so the x position this is the center of the circle it's going to be at position x wherever our mouse is then we just want it to be offset enough so that the full circle can draw so we'll just make this square size divided by two and then finally we need to specify the height of or the the radius of the circle and that's just the radius we've been using for all the tiles else this means it's turn equals equals one it's player two's turn and we'll just copy this and draw it and now it's going to be actually yellow so let's look what that looks like if we build that all right build oh okay i forgot to get the display update just like we did in the draw function so pygame.display.update build oh it looks good but it's just not ever deleting the circles so what we're going to do to fix this is right before we actually draw the circle we'll just draw a rectangle that's black that will black out any previous circles that we have drawn so pygame.draw.rectangle surfaces of the screen color is black position is going to start at the top left so that's zero zero it's going to have width the whole width of the screen and then the height will be a square size because that's how big that buffer bar kind of at the top is and that should be good i think i might have one extra no oh yeah i have one extra parenthesis there yay looks good so now we have this game over drop drop drop drop drop that looks good cool and so one thing that you also might want to change is that if i win the game so i'll win the game real quick with red it automatically closes right away so one thing we can do is we can add a weight pi game has a builtin weight function so what we can do is if the game over condition is true so if game over we'll call pygame.time.wait and this is the milliseconds you want to wait so 3000 would equal three seconds so if i run this again one two three it'll shut down automatically cool and then right before it shuts down we wanted some notification that the player actually won so initially we were printing it but now we'll actually render the print function on our screen so that will look something like as follows so we're going to delete the line that says player 1 wins and we're going to initialize a font up top so that will look like we'll do it right below the first update so we'll do my font equals pygame dot font dot system font this is all in the documentation i'm just copying some previous code i wrote and the last time i wrote this i'd use a font called mono but there's other options you can look at the documentation for all the details and we'll do font size 75 that's just an arbitrary number that i found worked and then if we go down below to actually render that on the screen horizontally i can type the following i can say label equals my font dot render player one wins exclamation and then i believe this one right here that i just put in specifies the axes that it's on i'm not actually sure i might play around with that to check and then we want the color to be red because uh it's rendering that text red because player one one and then what we have to do to get that on the screen do it quickly we could also use the pygame display.update function but i'm gonna do something a little different here i'm gonna do a screen.blit and that just updates that specific part of the screen and i toyed around with these values before i found that the xy pair where this will start at the top left of corner of this text starting at 40 comma 10 worked pretty well so let's see what happens when i run that so we're gonna have red win player one wins and the one thing is that tile gets in the way um what we could potentially do we could potentially draw another black rectangle if we wanted to um i don't know i'm not too bothered by it we'll fix it in one sec we're going to copy this for player two and i'll say player two wins and the color is gonna be yellow now build so what happens if yellow wins i'm making this so hard on myself player two wins yay all right and maybe what we'll do is at the start of the mouse button down we will draw that black rectangle as well so we don't have that annoying annoying tile getting in our way so right before we click the mouse button down that will make the thing disappear run it one more time player one wins it looks good and you can mess around with that as you see fit okay i mean that's like a pretty good game i'm pretty happy with it if you have any questions about it leave a comment below peace
