With timestamps:

00:00 - I thank you for coming like most of you
00:13 - I used to be a Java developer for ten
00:17 - years our twist TDD design patterns
00:22 - solid principle and then two years ago I
00:25 - joined big panda and I switched to a
00:29 - functional Scala and after a while I
00:33 - realized that the wearer's writing and
00:36 - reading code was very different
00:39 - I was thinking way less and in a good
00:43 - way
00:44 - so my day as a Java developer would look
00:49 - like this I would start with some code
00:52 - and in my mind I have a mental stack and
00:56 - I start to read a function and it might
01:00 - want exception it might not so the thing
01:03 - I have to do is to go with the
01:06 - implementation see the possible
01:09 - exception put it in my mental stack and
01:12 - go on and then I would continue I would
01:17 - read another function that would go to
01:19 - the database and again there might be an
01:23 - exception that might be other kind of
01:26 - errors so I would go to the
01:28 - implementation put this in the back of
01:30 - my mind and continue and again and again
01:34 - so what happen at the end is basically
01:39 - overflow right too much stuff to track
01:43 - and that's something you don't want to
01:47 - do so I'm gonna give you a few
01:50 - techniques to avoid that and we're gonna
01:54 - talk about functions about the data and
01:58 - then about patterns and then we do a
02:01 - quick summary and we have questions at
02:04 - the end so the first tool I'm going to
02:08 - talk about is function signatures
02:12 - the way I think about function
02:14 - signatures this way like a newspaper
02:17 - send a newspaper
02:20 - you have articles and you have titles
02:24 - and a good title should tell you enough
02:27 - about the content of the article you
02:30 - should enough to go and read the full
02:33 - article so a good function signature
02:36 - should be the same way right so let's
02:39 - take a look at this function what's
02:42 - going on here well we have an input it's
02:46 - an int and we have an output you to
02:48 - string so the way to visualize this
02:51 - thing would be like this we have types
02:53 - right it's this circle right ends and
02:57 - strings and we have values and values
03:01 - would be 1 2 3 4 ends or ABC whatever
03:07 - for Strings and the function is simply
03:12 - the mapping between those values right
03:15 - and I don't really need to know anything
03:19 - about the implementation what matters
03:21 - here is the function signature when I
03:25 - see this visual I get the full picture
03:27 - right so let's take a look at this
03:30 - function what's going on here to divide
03:33 - functions it takes two int and it gives
03:37 - me back an int right I'm dividing two
03:39 - values and I give it your back 1 and if
03:44 - I give you 0 I throw an exception so the
03:47 - way to visualize this thing would be
03:50 - like this right so I'll give you 2 is 5
03:55 - & 5 and you'll give me back one I'll
03:58 - give you 10 and 5 you give me back to
04:00 - write this visual is straightforward but
04:04 - what happen if I feed it 0 what happened
04:07 - to the visual right well this thing
04:10 - happens why there is an hour that goes
04:13 - to some value that is not defined
04:16 - something not natural is going on here
04:18 - this behind the circle right there is
04:23 - the
04:23 - exception thingy and the way right
04:27 - that's a bad function signature right
04:30 - you want why is it bad
04:32 - right why is this function signature bad
04:34 - well it lies it doesn't tell you the
04:36 - truth you have to go and read
04:39 - implementation to understand what it
04:41 - does and you have to keep this exception
04:44 - in the back of your mind and that's only
04:47 - one function imagine a lot of those you
04:50 - have to change those and you have to put
04:52 - on top of your mental stack again and
04:55 - again why you don't want that so the way
04:58 - to avoid that is to use total functions
05:03 - total functions are very simple for
05:07 - every single input they have a
05:09 - corresponding output so the visual is
05:12 - very clean right here we have the
05:14 - increment function I'll give you one you
05:16 - give me back to give you two you're
05:19 - giving back three it's very
05:20 - straightforward the function signature
05:23 - is trustworthy right it doesn't lie to
05:26 - me I can just I don't care about
05:29 - implementation what I care is the
05:33 - signature here and it tells me the truth
05:35 - the trust is back and what okay so let's
05:39 - go back now to the divide function we'll
05:42 - come back to divide function after we're
05:43 - just gonna move to the pure function
05:46 - first this is the same function as
05:48 - before right the Inc function here
05:50 - that's the same it's something different
05:53 - up in here what's different here is it a
05:57 - total function oh yeah it's the same
06:00 - function if I give you one key thing
06:02 - back to but something hell's going on
06:04 - here there is a printing in the middle
06:07 - here right and what is this why it
06:10 - doesn't look so bad right now but it
06:13 - could be anything instead of printing it
06:15 - could go to the database and drop the
06:18 - full database it could launch missiles
06:21 - the point is I don't know from the
06:25 - function signature what this function
06:27 - does again it's lying to me so you have
06:30 - to go you have to read the function and
06:33 - then you have to put this in the back of
06:35 - your mind
06:37 - this thing is called a side effect so
06:41 - you want function data side-effect free
06:45 - and this functioned I call pure
06:47 - functions right and when you use pure
06:50 - function you think less about the
06:53 - implementation what matters is the
06:57 - function signature not the
06:58 - implementation all right so let's go
07:01 - back to this divide function and it's
07:04 - try to fix it so the way to do it right
07:07 - is to use this container type called
07:11 - either and it will tell the reader of
07:14 - the function that there might be an
07:17 - error in the in the function right what
07:21 - is doing basically it's bubbling up the
07:23 - internal of the function at the level of
07:26 - the function signature this either type
07:29 - will tell you on the left side that's
07:32 - the errors right and on the right side
07:34 - the good value so now as a reader I
07:38 - don't have to go and read the
07:41 - implementation I can just look at the
07:43 - function signature and that's it I get
07:47 - the full picture here right we're going
07:50 - to talk about these container types now
07:52 - with you the most common ones quickly
07:56 - right in the standard library in job in
07:59 - SCARA sorry so one of the most common
08:03 - one is option so I would have a function
08:06 - like that which is middle name not
08:08 - everybody as a mineral name and when I
08:11 - read this function signature it will
08:13 - tell me they might be a return value or
08:16 - they might not right it's all about
08:18 - readability and to express yourself to
08:22 - the reader of this function either right
08:32 - basically this container type just wrap
08:35 - the simple type right that's what we do
08:37 - here you see with this brackety thing e
08:39 - so inside you put the type that you
08:42 - would like to return and here again it
08:45 - will tell you this function might return
08:47 - errors
08:49 - we have a list and this is a little bit
08:51 - different it's talking more about the
08:54 - shape of the output when you read this
08:57 - function right it will tell you you
08:59 - might have multiple output values it's a
09:02 - little bit different than before we
09:03 - don't talk about errors we talk about
09:05 - the shape of the output values and then
09:10 - a future that's also very interesting
09:12 - future will tell the reader of the
09:15 - function that the value that is
09:17 - expecting might be or might not be
09:20 - available right now it's more about when
09:23 - this value is available all right so
09:28 - let's recap quickly we talked about
09:31 - total functions and now for every input
09:35 - you have a corresponding output we
09:38 - talked about pure functions that have no
09:40 - side effect and then we talked about
09:43 - container types right we saw how we fix
09:46 - this divide function with either and you
09:50 - have to when you use all these
09:52 - techniques right you get you enrich your
09:55 - signature right you give a new meaning
09:57 - to your signature think about the
10:00 - newspaper right you want a good title
10:02 - you don't want the reader to go and you
10:06 - read the for article you just want to
10:08 - give him a good headline so good
10:13 - function signatures make you think less
10:16 - about the implementation that's the
10:19 - whole point right the mantle stock thing
10:21 - you don't want to go and read
10:24 - implementation every time that's what I
10:26 - used to in Java always I would just to
10:29 - click on the function everybody is doing
10:31 - this look look it up what is it doing
10:34 - you don't want to do that you don't have
10:36 - to do that when you use total functions
10:38 - when you use pure functions when use
10:41 - container types you have good signatures
10:43 - and you don't have to think about
10:46 - implementation alright now we're going
10:51 - to talk about another property of
10:55 - functions and it's a little bit
10:57 - different this was a big aha moment for
11:00 - me in functional programming
11:02 - it's not so much about if I care about
11:06 - the implementation but more about how
11:10 - many ways could you implement the
11:12 - functions it's very interesting think
11:15 - about writing the function signature and
11:19 - I give you a pen right and it could be
11:23 - 10 pens
11:25 - you don't know how to write this
11:27 - function there are so many possibilities
11:29 - so let's take a look at this function
11:32 - right and this is a parametric function
11:35 - so we have a parametric type a this
11:40 - thing tells you in the bracket what it
11:43 - tells you that you could replace this a
11:46 - with any type could be a string could be
11:49 - alone and int a list whatever that's
11:53 - what you have to think when you see this
11:55 - parametric type and the question is how
11:59 - many way
12:00 - could you implement this thing could you
12:03 - implement this function of course you
12:06 - think total functions pure functions we
12:09 - don't use side effects we don't throw
12:11 - exceptions and we wish treating
12:14 - ourselves not to use all this magic
12:16 - hashcode function to string functions
12:19 - all this stuff that comes from the
12:22 - object Java class right so how many ways
12:27 - 2 3 4 what turns out there is only one
12:33 - way to do it right and what's
12:37 - interesting here is why is that why is
12:40 - there only one way to implement this
12:42 - function so the answer is easy we don't
12:47 - know anything about a this thing is so
12:50 - abstract that I don't know its values if
12:54 - I tell you int right you can draw the
12:56 - circle of ends in your mind and you know
12:58 - the value 1 2 3 4 bit if I tell you a
13:01 - you draw this circle you don't know
13:04 - its values you don't know any function
13:06 - on a so you put into a corner here you
13:10 - have no choice you have to return the
13:12 - input you have only one way to implement
13:15 - that
13:16 - what if I do that what if I enrich the
13:22 - type signature with a container type
13:24 - right with list I'm doing a small thing
13:27 - here I'm just changing this a into a
13:30 - list of a and I'm returning a list of it
13:33 - so what I'm telling to the reader is the
13:36 - shape of the input could be multiple
13:39 - eight and the output could be multiple
13:42 - eyes how is it going to affect the
13:45 - number of implementation how many ways
13:48 - could you implement this function now
13:50 - what did it do to the implementation
13:54 - space well we can implement it a little
13:59 - bit more right you have a little bit
14:01 - more possibilities we can switch the
14:04 - head and the tail we can do some some
14:07 - stuff but not so many right we can't
14:13 - sort this thing we don't have any
14:14 - ordering or nays right we don't sort the
14:16 - list so what what happen here basically
14:20 - we just enrich the function signature
14:23 - with a container type and we get a
14:25 - little bit more of implementation space
14:28 - the way for you to write this function
14:32 - is a little bit more there is a little
14:35 - bit more ways for you to do it and the
14:39 - last one would be to do something like
14:41 - that what would this do to the
14:43 - implementation space of the function
14:45 - what did I do here I just remove the a
14:49 - as a return value and put an int right
14:52 - and think about it again this int you
14:56 - can draw it in your mind it's a circle
14:58 - with the values 1 2 3 4 so how many ways
15:03 - can you implement this well one can
15:07 - written 1 2 3 4 5 the number of ends
15:10 - right so what happened here well what
15:13 - happened let's think about that we just
15:16 - jump here to another dimension of number
15:19 - of implementation that's interesting we
15:22 - started with something very abstract
15:24 - with one a right and we are not in one
15:28 - way
15:29 - to implement it and then we enrich the
15:31 - signature with a list we add a little
15:34 - bit more implementation possibilities
15:37 - but not so much not so much and we
15:40 - finished within and we just jumped to
15:42 - another dimension so what does it mean
15:45 - this thing
15:46 - well this notion is called pyometra City
15:49 - and it's very interesting why is it
15:51 - important to you because when you use a
15:54 - parametric function right the more it's
15:57 - abstract the less way you have to
16:00 - implement it the less possibilities for
16:04 - you to make a mistake right it's like
16:07 - giving you a blank page and I'll give
16:09 - you one thing or if I give you 10 pens
16:13 - so what you have so many choice that you
16:16 - could make mistakes but here when you
16:19 - use permit Rissa tea to more abstract it
16:22 - is the less you have to think about how
16:25 - to implement the function right it's not
16:27 - so much about what implementation is
16:30 - with the function signatures it's more
16:32 - about for you as a developer how to
16:35 - write the code right you have to think
16:37 - less about it makes you think less about
16:40 - your implementation so we talked about
16:43 - functions right about total functions
16:47 - pure functions parametric functions but
16:52 - of course functional programming is
16:55 - programming with functions but we all
16:57 - know that software is not only functions
17:01 - right function like software is about
17:05 - designing data and designing behavior
17:10 - it's beyond functions right there is
17:12 - something else there if you want to
17:14 - build a full-fledged application you
17:17 - can't just start writing functions it's
17:19 - it's not going to work out and is there
17:24 - a way we're going to start with data so
17:26 - is there a way to encode data that would
17:29 - make you think less that we have this
17:31 - property for you as a developer to think
17:33 - less in a good sense right so the way to
17:37 - do it is to use some types
17:40 - some types is a way to encode data so
17:46 - it's very simple here we have a
17:48 - developer trait which is basically an
17:51 - interface and you would have a DevOps
17:54 - which extends this developer trait then
17:58 - you would have a full stacker with a
18:00 - salary net and then you would have an ml
18:02 - developer with a salary in long and what
18:08 - does it really mean this thing right why
18:10 - would you want to encode the data this
18:12 - way why would you want to use this some
18:15 - type button this button some types is
18:18 - also referred as algebraic data types so
18:22 - keep this in mind and why would you want
18:24 - to do that why would you want to use
18:26 - that why is it a good thing well first
18:30 - the compiler will be with you when you
18:35 - use this thing right if I were to
18:37 - function say hi that takes a developer
18:40 - and I pattern match on it if I forget a
18:43 - case the compiler will tell you you
18:47 - forgot the ML case right something that
18:51 - is extremely powerful in Java the
18:55 - compiler will only check the syntax if
18:58 - you forget a semicolon or like a bracket
19:01 - well in Scala it will check the
19:03 - correctness for you something that is
19:06 - very powerful a lot of functional
19:10 - programmers will tell you you know if it
19:11 - compiles it works well comes from that
19:14 - because the compiler is not only
19:17 - checking the syntax but checking the
19:20 - correctness of your code that's why they
19:23 - would say that also this ADT's these
19:28 - subtypes were all the immutable so you
19:31 - don't have to think so much about
19:34 - concurrency bugs shared mutable states
19:37 - you can't change this stuff right this
19:40 - developer you can't really change if you
19:42 - want in your instance of it you have to
19:44 - create a new one so you don't have to
19:47 - think about all this possible mutable
19:50 - short state
19:54 - all right so what about this function
19:57 - the load use of function but you've seen
19:59 - it in a lot of code bases you know these
20:04 - strings everywhere this ends
20:06 - these Long's you don't really know what
20:08 - it is right here this load user could
20:10 - use the ID could use the email you don't
20:13 - know you want to encode your data to
20:16 - make you think less about all these
20:17 - possibilities you want the compiler to
20:20 - work for you and the way to put some
20:25 - domain knowledge in your values right I
20:28 - want this load user function to take an
20:31 - email so the way to do it is to use
20:33 - value classes and basically this value
20:37 - classes is just a simple pattern you
20:40 - wrap your simple type and you extend any
20:43 - var and now you get a nice type right my
20:46 - lord user takes an email what is it
20:48 - doing what is why this thing important
20:50 - because you put in two main knowledge
20:53 - inside your types the compiler now will
20:58 - be behind you
20:59 - to catch you when you make a mistake you
21:02 - don't have to think so much about what
21:05 - these strings don't you know what they
21:08 - mean this doubles is it money is it time
21:11 - no one knows right but if you type it
21:13 - properly with value classes you don't
21:16 - have to think about that all right let's
21:19 - recap we talked about ADT's right about
21:23 - some types and how they encode immutable
21:26 - data and how the compiler will check the
21:30 - correctness of your code when you forget
21:33 - an edge case there is basically
21:34 - basically there is normal edge cases you
21:37 - don't have to think about forgetting and
21:40 - a case the compiler will do it for you
21:43 - we talked about value classes and now
21:46 - how we can just put domain knowledge
21:48 - inside the types so the compiler will
21:52 - also help us to write code that is more
21:56 - correct
21:58 - so all these techniques right about data
22:01 - will make you think less about the
22:04 - correctness you don't have to think so
22:06 - much
22:07 - before the compiler will check the
22:10 - correctness for you something that I
22:13 - believe is extremely powerful and Java
22:16 - doesn't give you right all right so we
22:23 - talked about functions we talked about
22:26 - data and what's left or patterns right
22:31 - the way to design software in the old
22:37 - world would be like that design patterns
22:41 - we all shred it
22:45 - it's what what are these design patterns
22:47 - well
22:49 - the elaborate class hierarchies actually
22:51 - they have the good value right this
22:56 - stuff if you used it you see that it's
22:58 - very valuable all these buttons do
23:01 - emerge in your software you do see them
23:04 - you do see abstract factories visitors
23:07 - and stuff like that but you know they
23:11 - sit in a book somewhere right every team
23:14 - that you worked on I'm sure you've seen
23:16 - it will implement these buttons in a
23:19 - different way also when you start
23:24 - learning those it might have happened to
23:26 - it happened to me you start using them
23:28 - everywhere so what you get is all these
23:31 - over-engineered
23:32 - code bases it takes a long time to
23:35 - internalize these patterns so is there a
23:40 - way right and to fit this in your mentor
23:42 - stack all these patterns it is not that
23:45 - easy right so is there a way to design
23:50 - patterns to have patterns that make you
23:54 - think less about that would make you
24:00 - think less right you won't have to fit
24:02 - all this stuff in your mind so let's go
24:05 - back to the function world and try to do
24:08 - patterns at the functional level okay so
24:12 - how would you spot patterns the old way
24:15 - well you would look at your code you
24:17 - will refactor and then you will see a
24:19 - lot of similarities so here is the
24:21 - it's exactly the same thing you have to
24:24 - look at your functions and try to
24:26 - support the similarities right and what
24:29 - are the similarities at the function
24:30 - level Wow the number of parameters the
24:34 - number of outputs the type right if the
24:37 - tides are the same the shape of the
24:39 - functions so here I have 1 plus 1 Aiken
24:43 - can't be least 1 2 3 that I want to come
24:47 - cut with least 4 5 6 so what does all of
24:51 - this stuff has in common let's try to
24:54 - find a pattern here well they have the
24:59 - same number of parameters right I give
25:01 - you 2 inch you give me back one I give
25:05 - you 2 strings you give me back one right
25:09 - so that the same number of time it is
25:11 - also the type is the same right
25:16 - I'll give you int + int you give you
25:18 - back in need that's the type of
25:20 - similarities you have to pay attention
25:22 - now right it's very different from
25:24 - design patterns now you don't look at
25:27 - classes in IR keys you just look at your
25:30 - functions at your types at your
25:32 - parameters and you try to see
25:35 - similarities so this stuff you would
25:39 - refactor it to this type of function
25:41 - right combined ends I'll give you two
25:43 - int you'll give me back one combined
25:46 - strings the same I'll give you two of
25:49 - strings you'll give me back a string
25:50 - something with lists and what is the
25:53 - essence of this stuff right what is what
25:57 - transpire I love this pattern
25:59 - how can you capture that well it's this
26:01 - thing right you can feel it it's one a
26:03 - and another and I'll give you back an h1
26:06 - type two of the same types and I give
26:09 - you back what
26:11 - and I would you encode this thing in
26:13 - code how would you do that well the way
26:18 - to encode this is to use type classes
26:22 - that's the way to extract the
26:26 - similarities at the function level and
26:28 - type classes are not classes they are
26:31 - trait right it's an interface they are
26:35 - my parameter we see here a and the
26:39 - function that we wanted to extract here
26:41 - this combined thing is here it takes two
26:45 - A's and give you back an A it's very
26:47 - abstract
26:48 - we don't have an implementation but we
26:50 - can fill that this is the right encoding
26:53 - and this is a parametric function that's
26:56 - the tool for the job right a parametric
26:59 - function it's very abstract right so all
27:02 - right now I have this stuff what I do
27:06 - with it right what do I do with this how
27:09 - do I use this thing right it's so
27:10 - abstract well one way to do it would be
27:15 - to implement instances so it's very
27:18 - tedious right it's manual you just doing
27:22 - you and you override this combined with
27:26 - your own type so here we do for internet
27:28 - and we'd be and which supply the
27:31 - implementation for combining to it here
27:33 - we decided to do a plus same thing for
27:36 - Strings right I override this combined
27:40 - method with string and string and I give
27:42 - you back my implementation of it you can
27:45 - also do it for your own types right here
27:48 - I created my own class foo and it takes
27:52 - an INT and a string so I can also
27:55 - implement the combined method for foo
27:58 - right it's my own implementation and I
28:01 - tell you how to do it so we take the
28:03 - first parameter and the second one and
28:06 - we give you back a new foo this stuff
28:10 - also you can pay attention use and
28:12 - places that's the to wait a bit so why
28:15 - we use implicit because we want to
28:17 - summon the stuff and get it magically
28:21 - with the implicitly syntax right it's
28:25 - very nice you see I give a and B I get a
28:28 - B 1 in 1 I get 2 and same thing for food
28:33 - great ok that's a nice refactoring it's
28:39 - very nice but did we really gain
28:41 - anything here did we gain something
28:43 - right from the old way
28:45 - well first of all we don't use
28:48 - la siroque is right all this scary like
28:53 - XML stuff just doesn't exist anymore
28:56 - right
28:57 - we work at a function level right so we
29:00 - talk we don't you we didn't use any
29:02 - inheritance here right we just choose
29:05 - overloading we didn't use inheritance
29:07 - and like design pattern this stuff as a
29:11 - name right - one of the strongest aspect
29:14 - of design pattern is the other name so
29:17 - if I'm in a team and I tell my coworker
29:20 - I used an abstract Factory it's supposed
29:23 - to know what it is the same thing with
29:25 - these functions with this pattern these
29:27 - patterns of a name and this combine of
29:30 - all thing which would that we just
29:31 - discovered it's official name is a mano
29:36 - it right so this stuff right all this
29:41 - and that's not the only pattern to it
29:43 - with a lot of these patterns and a mano
29:46 - it it's the same thing you see the
29:47 - combined method is the exactly the same
29:49 - thing right takes two of the same give
29:52 - you back one of the same it's the same
29:54 - trade also it has an empty we will need
29:58 - that later but basically for the plus
30:01 - right for in the empty would be zero
30:03 - right you want one plus zero equal one
30:07 - so you need this so great but you know
30:13 - what well you don't have to know this
30:18 - stuff and you don't have to discover it
30:20 - you can just import them that's
30:22 - something that is extremely powerful
30:25 - right you can do that you can import
30:28 - mono it from cats opens ecology we can
30:32 - also import the instances right you
30:35 - remember I wrote them right for ins for
30:37 - Strings where you don't have to do that
30:39 - anymore
30:41 - from the library and think about it
30:43 - right think about our power for this
30:46 - thing is when you want assign pattern
30:50 - everybody would go to the book and would
30:53 - implemented its own way there is no
30:55 - libraries for design patterns just does
30:57 - not exist here not only you have the
31:02 - check interfaces you also have the
31:04 - instance someone very smart wrote this
31:08 - code for you you just have to take it
31:10 - and to use it right so if I import this
31:14 - stuff I can do the same thing I get this
31:17 - magical combined method on one on the
31:20 - value itself I got this combined method
31:22 - I can just use it one combined one two
31:24 - same thing on string I did not have to
31:27 - write any code distinct em for free
31:31 - right same thing for list 1 2 3 4 5 6
31:36 - this thing is great and of course that's
31:41 - one pattern but as Rob Norris would say
31:45 - everything sufficiently polymorphic and
31:48 - useful already exist what does it mean
31:52 - it means everybody that worked on these
31:56 - patterns why they already discovered for
31:59 - you ok there is a big community out
32:01 - there that worked on those already and
32:03 - just supply this stuff for you in this
32:06 - libraries you just have to look up the
32:08 - documentation take what you need and put
32:12 - it in your project that's something that
32:14 - is very powerful that does not exist in
32:17 - the old world these design patterns
32:19 - don't have that you don't have this
32:21 - libraries with implementation to use and
32:24 - you can just go and take what you need
32:27 - also because these patterns are so
32:32 - common right is mono there is a huge
32:34 - ecosystem building on top of this
32:37 - libraries all these type classes well
32:40 - you can also get you CDs full class that
32:44 - we define before and I had to write
32:46 - manually the implementation if I want I
32:48 - can use this library called kittens I
32:50 - just imported and it will magically
32:53 - figure out what is my mono it instance
32:57 - it will give you magically this combined
32:59 - method for free right that's very
33:01 - powerful all these libraries work with
33:04 - this functional pattern so you get all
33:06 - this stuff for free and this is an
33:11 - example right you could add what
33:14 - you read about tight glasses it's not
33:16 - only that you get this free thing where
33:18 - it is combined you also get a lot of
33:20 - what's called the right function so
33:23 - let's take a look at our model again the
33:26 - combined method that we discovered is
33:28 - called the function that the definitive
33:31 - function where it's defining the type
33:34 - class but we also have and this the
33:41 - right function here is for example
33:43 - combined all these top you also get free
33:47 - and that's a very interesting I just
33:50 - want to show you the implementation you
33:52 - don't have to implement it right because
33:54 - you get it for free but that's the way
33:57 - to implement it think about parametric
33:58 - City what we talked about before the way
34:02 - I mean not so many right you know you
34:10 - have to use this empty and combined look
34:14 - at this function it's only defined in
34:17 - terms of these two abstract methods
34:21 - right about empty and combined you know
34:23 - you have to use them you know you get a
34:25 - lot of inputs so you know and you have
34:27 - to get one so there is only one thing
34:30 - you can do is to take all these values
34:32 - and holden that's it to write this
34:35 - function is so easy because you don't
34:37 - have so many options
34:39 - that's parametric City in action right
34:42 - there so you can just import this stuff
34:48 - and you get this combined all for free
34:49 - right now I can combine lists alright I
34:52 - can give you one two three I will get
34:54 - six ABC I will get ABC and Foods and it
34:58 - works
34:59 - right so let's wake up quickly about
35:04 - this functional pattern how do you
35:09 - encode functional patterns while you use
35:11 - type classes these type classes of
35:14 - parametric function and also the way to
35:19 - implement these type classes would be to
35:22 - write instances we saw that you can use
35:26 - cats or Scalzi
35:28 - and import it directly into your
35:30 - codebase and you don't even have to
35:33 - write your own instances this thing will
35:35 - give it for free also we saw that we
35:39 - have all these libraries that build on
35:42 - top of all these functional patterns and
35:45 - something very important right all this
35:48 - knowledge all this functional knowledge
35:50 - you keep it with you as opposed to
35:53 - spring or Ivan eight or whatever
35:55 - framework these things does not get all
35:59 - right all these patterns two way to
36:01 - encode functions well these things is
36:04 - forever whatever language you use
36:07 - framework these things stay with you
36:09 - right throughout your career you grow
36:12 - into it and you don't have to think each
36:15 - time when you move to a new team I need
36:18 - to learn this and you to learn that well
36:20 - this stuff is universal right so it's do
36:25 - a quick summary we talked about function
36:27 - signatures now you can use total
36:29 - functions pure functions and container
36:33 - types to write great function signatures
36:36 - so you don't have to think about what is
36:39 - the implementation the mental stack
36:41 - again you want it free of clutter we
36:44 - talked about ADT's right about data and
36:47 - how to encode data in a way that would
36:51 - make you think less about the
36:53 - correctness of your code the compiler
36:55 - will catch all your edge cases and then
36:59 - we finished with design part with
37:01 - functional patterns and now they would
37:04 - make you think less about you don't even
37:08 - have to think about the implement you
37:10 - get them for free from all these
37:12 - libraries you also don't have to think
37:14 - about all these class hierarchies that
37:16 - used to be in this all design patterns
37:19 - you just get them for free from cuts and
37:22 - Scalzi so use this stuff right think
37:29 - less about your code thank you very much
37:32 - [Applause]
37:36 - [Music]

Cleaned transcript:

I thank you for coming like most of you I used to be a Java developer for ten years our twist TDD design patterns solid principle and then two years ago I joined big panda and I switched to a functional Scala and after a while I realized that the wearer's writing and reading code was very different I was thinking way less and in a good way so my day as a Java developer would look like this I would start with some code and in my mind I have a mental stack and I start to read a function and it might want exception it might not so the thing I have to do is to go with the implementation see the possible exception put it in my mental stack and go on and then I would continue I would read another function that would go to the database and again there might be an exception that might be other kind of errors so I would go to the implementation put this in the back of my mind and continue and again and again so what happen at the end is basically overflow right too much stuff to track and that's something you don't want to do so I'm gonna give you a few techniques to avoid that and we're gonna talk about functions about the data and then about patterns and then we do a quick summary and we have questions at the end so the first tool I'm going to talk about is function signatures the way I think about function signatures this way like a newspaper send a newspaper you have articles and you have titles and a good title should tell you enough about the content of the article you should enough to go and read the full article so a good function signature should be the same way right so let's take a look at this function what's going on here well we have an input it's an int and we have an output you to string so the way to visualize this thing would be like this we have types right it's this circle right ends and strings and we have values and values would be 1 2 3 4 ends or ABC whatever for Strings and the function is simply the mapping between those values right and I don't really need to know anything about the implementation what matters here is the function signature when I see this visual I get the full picture right so let's take a look at this function what's going on here to divide functions it takes two int and it gives me back an int right I'm dividing two values and I give it your back 1 and if I give you 0 I throw an exception so the way to visualize this thing would be like this right so I'll give you 2 is 5 & 5 and you'll give me back one I'll give you 10 and 5 you give me back to write this visual is straightforward but what happen if I feed it 0 what happened to the visual right well this thing happens why there is an hour that goes to some value that is not defined something not natural is going on here this behind the circle right there is the exception thingy and the way right that's a bad function signature right you want why is it bad right why is this function signature bad well it lies it doesn't tell you the truth you have to go and read implementation to understand what it does and you have to keep this exception in the back of your mind and that's only one function imagine a lot of those you have to change those and you have to put on top of your mental stack again and again why you don't want that so the way to avoid that is to use total functions total functions are very simple for every single input they have a corresponding output so the visual is very clean right here we have the increment function I'll give you one you give me back to give you two you're giving back three it's very straightforward the function signature is trustworthy right it doesn't lie to me I can just I don't care about implementation what I care is the signature here and it tells me the truth the trust is back and what okay so let's go back now to the divide function we'll come back to divide function after we're just gonna move to the pure function first this is the same function as before right the Inc function here that's the same it's something different up in here what's different here is it a total function oh yeah it's the same function if I give you one key thing back to but something hell's going on here there is a printing in the middle here right and what is this why it doesn't look so bad right now but it could be anything instead of printing it could go to the database and drop the full database it could launch missiles the point is I don't know from the function signature what this function does again it's lying to me so you have to go you have to read the function and then you have to put this in the back of your mind this thing is called a side effect so you want function data sideeffect free and this functioned I call pure functions right and when you use pure function you think less about the implementation what matters is the function signature not the implementation all right so let's go back to this divide function and it's try to fix it so the way to do it right is to use this container type called either and it will tell the reader of the function that there might be an error in the in the function right what is doing basically it's bubbling up the internal of the function at the level of the function signature this either type will tell you on the left side that's the errors right and on the right side the good value so now as a reader I don't have to go and read the implementation I can just look at the function signature and that's it I get the full picture here right we're going to talk about these container types now with you the most common ones quickly right in the standard library in job in SCARA sorry so one of the most common one is option so I would have a function like that which is middle name not everybody as a mineral name and when I read this function signature it will tell me they might be a return value or they might not right it's all about readability and to express yourself to the reader of this function either right basically this container type just wrap the simple type right that's what we do here you see with this brackety thing e so inside you put the type that you would like to return and here again it will tell you this function might return errors we have a list and this is a little bit different it's talking more about the shape of the output when you read this function right it will tell you you might have multiple output values it's a little bit different than before we don't talk about errors we talk about the shape of the output values and then a future that's also very interesting future will tell the reader of the function that the value that is expecting might be or might not be available right now it's more about when this value is available all right so let's recap quickly we talked about total functions and now for every input you have a corresponding output we talked about pure functions that have no side effect and then we talked about container types right we saw how we fix this divide function with either and you have to when you use all these techniques right you get you enrich your signature right you give a new meaning to your signature think about the newspaper right you want a good title you don't want the reader to go and you read the for article you just want to give him a good headline so good function signatures make you think less about the implementation that's the whole point right the mantle stock thing you don't want to go and read implementation every time that's what I used to in Java always I would just to click on the function everybody is doing this look look it up what is it doing you don't want to do that you don't have to do that when you use total functions when you use pure functions when use container types you have good signatures and you don't have to think about implementation alright now we're going to talk about another property of functions and it's a little bit different this was a big aha moment for me in functional programming it's not so much about if I care about the implementation but more about how many ways could you implement the functions it's very interesting think about writing the function signature and I give you a pen right and it could be 10 pens you don't know how to write this function there are so many possibilities so let's take a look at this function right and this is a parametric function so we have a parametric type a this thing tells you in the bracket what it tells you that you could replace this a with any type could be a string could be alone and int a list whatever that's what you have to think when you see this parametric type and the question is how many way could you implement this thing could you implement this function of course you think total functions pure functions we don't use side effects we don't throw exceptions and we wish treating ourselves not to use all this magic hashcode function to string functions all this stuff that comes from the object Java class right so how many ways 2 3 4 what turns out there is only one way to do it right and what's interesting here is why is that why is there only one way to implement this function so the answer is easy we don't know anything about a this thing is so abstract that I don't know its values if I tell you int right you can draw the circle of ends in your mind and you know the value 1 2 3 4 bit if I tell you a you draw this circle you don't know its values you don't know any function on a so you put into a corner here you have no choice you have to return the input you have only one way to implement that what if I do that what if I enrich the type signature with a container type right with list I'm doing a small thing here I'm just changing this a into a list of a and I'm returning a list of it so what I'm telling to the reader is the shape of the input could be multiple eight and the output could be multiple eyes how is it going to affect the number of implementation how many ways could you implement this function now what did it do to the implementation space well we can implement it a little bit more right you have a little bit more possibilities we can switch the head and the tail we can do some some stuff but not so many right we can't sort this thing we don't have any ordering or nays right we don't sort the list so what what happen here basically we just enrich the function signature with a container type and we get a little bit more of implementation space the way for you to write this function is a little bit more there is a little bit more ways for you to do it and the last one would be to do something like that what would this do to the implementation space of the function what did I do here I just remove the a as a return value and put an int right and think about it again this int you can draw it in your mind it's a circle with the values 1 2 3 4 so how many ways can you implement this well one can written 1 2 3 4 5 the number of ends right so what happened here well what happened let's think about that we just jump here to another dimension of number of implementation that's interesting we started with something very abstract with one a right and we are not in one way to implement it and then we enrich the signature with a list we add a little bit more implementation possibilities but not so much not so much and we finished within and we just jumped to another dimension so what does it mean this thing well this notion is called pyometra City and it's very interesting why is it important to you because when you use a parametric function right the more it's abstract the less way you have to implement it the less possibilities for you to make a mistake right it's like giving you a blank page and I'll give you one thing or if I give you 10 pens so what you have so many choice that you could make mistakes but here when you use permit Rissa tea to more abstract it is the less you have to think about how to implement the function right it's not so much about what implementation is with the function signatures it's more about for you as a developer how to write the code right you have to think less about it makes you think less about your implementation so we talked about functions right about total functions pure functions parametric functions but of course functional programming is programming with functions but we all know that software is not only functions right function like software is about designing data and designing behavior it's beyond functions right there is something else there if you want to build a fullfledged application you can't just start writing functions it's it's not going to work out and is there a way we're going to start with data so is there a way to encode data that would make you think less that we have this property for you as a developer to think less in a good sense right so the way to do it is to use some types some types is a way to encode data so it's very simple here we have a developer trait which is basically an interface and you would have a DevOps which extends this developer trait then you would have a full stacker with a salary net and then you would have an ml developer with a salary in long and what does it really mean this thing right why would you want to encode the data this way why would you want to use this some type button this button some types is also referred as algebraic data types so keep this in mind and why would you want to do that why would you want to use that why is it a good thing well first the compiler will be with you when you use this thing right if I were to function say hi that takes a developer and I pattern match on it if I forget a case the compiler will tell you you forgot the ML case right something that is extremely powerful in Java the compiler will only check the syntax if you forget a semicolon or like a bracket well in Scala it will check the correctness for you something that is very powerful a lot of functional programmers will tell you you know if it compiles it works well comes from that because the compiler is not only checking the syntax but checking the correctness of your code that's why they would say that also this ADT's these subtypes were all the immutable so you don't have to think so much about concurrency bugs shared mutable states you can't change this stuff right this developer you can't really change if you want in your instance of it you have to create a new one so you don't have to think about all this possible mutable short state all right so what about this function the load use of function but you've seen it in a lot of code bases you know these strings everywhere this ends these Long's you don't really know what it is right here this load user could use the ID could use the email you don't know you want to encode your data to make you think less about all these possibilities you want the compiler to work for you and the way to put some domain knowledge in your values right I want this load user function to take an email so the way to do it is to use value classes and basically this value classes is just a simple pattern you wrap your simple type and you extend any var and now you get a nice type right my lord user takes an email what is it doing what is why this thing important because you put in two main knowledge inside your types the compiler now will be behind you to catch you when you make a mistake you don't have to think so much about what these strings don't you know what they mean this doubles is it money is it time no one knows right but if you type it properly with value classes you don't have to think about that all right let's recap we talked about ADT's right about some types and how they encode immutable data and how the compiler will check the correctness of your code when you forget an edge case there is basically basically there is normal edge cases you don't have to think about forgetting and a case the compiler will do it for you we talked about value classes and now how we can just put domain knowledge inside the types so the compiler will also help us to write code that is more correct so all these techniques right about data will make you think less about the correctness you don't have to think so much before the compiler will check the correctness for you something that I believe is extremely powerful and Java doesn't give you right all right so we talked about functions we talked about data and what's left or patterns right the way to design software in the old world would be like that design patterns we all shred it it's what what are these design patterns well the elaborate class hierarchies actually they have the good value right this stuff if you used it you see that it's very valuable all these buttons do emerge in your software you do see them you do see abstract factories visitors and stuff like that but you know they sit in a book somewhere right every team that you worked on I'm sure you've seen it will implement these buttons in a different way also when you start learning those it might have happened to it happened to me you start using them everywhere so what you get is all these overengineered code bases it takes a long time to internalize these patterns so is there a way right and to fit this in your mentor stack all these patterns it is not that easy right so is there a way to design patterns to have patterns that make you think less about that would make you think less right you won't have to fit all this stuff in your mind so let's go back to the function world and try to do patterns at the functional level okay so how would you spot patterns the old way well you would look at your code you will refactor and then you will see a lot of similarities so here is the it's exactly the same thing you have to look at your functions and try to support the similarities right and what are the similarities at the function level Wow the number of parameters the number of outputs the type right if the tides are the same the shape of the functions so here I have 1 plus 1 Aiken can't be least 1 2 3 that I want to come cut with least 4 5 6 so what does all of this stuff has in common let's try to find a pattern here well they have the same number of parameters right I give you 2 inch you give me back one I give you 2 strings you give me back one right so that the same number of time it is also the type is the same right I'll give you int + int you give you back in need that's the type of similarities you have to pay attention now right it's very different from design patterns now you don't look at classes in IR keys you just look at your functions at your types at your parameters and you try to see similarities so this stuff you would refactor it to this type of function right combined ends I'll give you two int you'll give me back one combined strings the same I'll give you two of strings you'll give me back a string something with lists and what is the essence of this stuff right what is what transpire I love this pattern how can you capture that well it's this thing right you can feel it it's one a and another and I'll give you back an h1 type two of the same types and I give you back what and I would you encode this thing in code how would you do that well the way to encode this is to use type classes that's the way to extract the similarities at the function level and type classes are not classes they are trait right it's an interface they are my parameter we see here a and the function that we wanted to extract here this combined thing is here it takes two A's and give you back an A it's very abstract we don't have an implementation but we can fill that this is the right encoding and this is a parametric function that's the tool for the job right a parametric function it's very abstract right so all right now I have this stuff what I do with it right what do I do with this how do I use this thing right it's so abstract well one way to do it would be to implement instances so it's very tedious right it's manual you just doing you and you override this combined with your own type so here we do for internet and we'd be and which supply the implementation for combining to it here we decided to do a plus same thing for Strings right I override this combined method with string and string and I give you back my implementation of it you can also do it for your own types right here I created my own class foo and it takes an INT and a string so I can also implement the combined method for foo right it's my own implementation and I tell you how to do it so we take the first parameter and the second one and we give you back a new foo this stuff also you can pay attention use and places that's the to wait a bit so why we use implicit because we want to summon the stuff and get it magically with the implicitly syntax right it's very nice you see I give a and B I get a B 1 in 1 I get 2 and same thing for food great ok that's a nice refactoring it's very nice but did we really gain anything here did we gain something right from the old way well first of all we don't use la siroque is right all this scary like XML stuff just doesn't exist anymore right we work at a function level right so we talk we don't you we didn't use any inheritance here right we just choose overloading we didn't use inheritance and like design pattern this stuff as a name right one of the strongest aspect of design pattern is the other name so if I'm in a team and I tell my coworker I used an abstract Factory it's supposed to know what it is the same thing with these functions with this pattern these patterns of a name and this combine of all thing which would that we just discovered it's official name is a mano it right so this stuff right all this and that's not the only pattern to it with a lot of these patterns and a mano it it's the same thing you see the combined method is the exactly the same thing right takes two of the same give you back one of the same it's the same trade also it has an empty we will need that later but basically for the plus right for in the empty would be zero right you want one plus zero equal one so you need this so great but you know what well you don't have to know this stuff and you don't have to discover it you can just import them that's something that is extremely powerful right you can do that you can import mono it from cats opens ecology we can also import the instances right you remember I wrote them right for ins for Strings where you don't have to do that anymore from the library and think about it right think about our power for this thing is when you want assign pattern everybody would go to the book and would implemented its own way there is no libraries for design patterns just does not exist here not only you have the check interfaces you also have the instance someone very smart wrote this code for you you just have to take it and to use it right so if I import this stuff I can do the same thing I get this magical combined method on one on the value itself I got this combined method I can just use it one combined one two same thing on string I did not have to write any code distinct em for free right same thing for list 1 2 3 4 5 6 this thing is great and of course that's one pattern but as Rob Norris would say everything sufficiently polymorphic and useful already exist what does it mean it means everybody that worked on these patterns why they already discovered for you ok there is a big community out there that worked on those already and just supply this stuff for you in this libraries you just have to look up the documentation take what you need and put it in your project that's something that is very powerful that does not exist in the old world these design patterns don't have that you don't have this libraries with implementation to use and you can just go and take what you need also because these patterns are so common right is mono there is a huge ecosystem building on top of this libraries all these type classes well you can also get you CDs full class that we define before and I had to write manually the implementation if I want I can use this library called kittens I just imported and it will magically figure out what is my mono it instance it will give you magically this combined method for free right that's very powerful all these libraries work with this functional pattern so you get all this stuff for free and this is an example right you could add what you read about tight glasses it's not only that you get this free thing where it is combined you also get a lot of what's called the right function so let's take a look at our model again the combined method that we discovered is called the function that the definitive function where it's defining the type class but we also have and this the right function here is for example combined all these top you also get free and that's a very interesting I just want to show you the implementation you don't have to implement it right because you get it for free but that's the way to implement it think about parametric City what we talked about before the way I mean not so many right you know you have to use this empty and combined look at this function it's only defined in terms of these two abstract methods right about empty and combined you know you have to use them you know you get a lot of inputs so you know and you have to get one so there is only one thing you can do is to take all these values and holden that's it to write this function is so easy because you don't have so many options that's parametric City in action right there so you can just import this stuff and you get this combined all for free right now I can combine lists alright I can give you one two three I will get six ABC I will get ABC and Foods and it works right so let's wake up quickly about this functional pattern how do you encode functional patterns while you use type classes these type classes of parametric function and also the way to implement these type classes would be to write instances we saw that you can use cats or Scalzi and import it directly into your codebase and you don't even have to write your own instances this thing will give it for free also we saw that we have all these libraries that build on top of all these functional patterns and something very important right all this knowledge all this functional knowledge you keep it with you as opposed to spring or Ivan eight or whatever framework these things does not get all right all these patterns two way to encode functions well these things is forever whatever language you use framework these things stay with you right throughout your career you grow into it and you don't have to think each time when you move to a new team I need to learn this and you to learn that well this stuff is universal right so it's do a quick summary we talked about function signatures now you can use total functions pure functions and container types to write great function signatures so you don't have to think about what is the implementation the mental stack again you want it free of clutter we talked about ADT's right about data and how to encode data in a way that would make you think less about the correctness of your code the compiler will catch all your edge cases and then we finished with design part with functional patterns and now they would make you think less about you don't even have to think about the implement you get them for free from all these libraries you also don't have to think about all these class hierarchies that used to be in this all design patterns you just get them for free from cuts and Scalzi so use this stuff right think less about your code thank you very much
