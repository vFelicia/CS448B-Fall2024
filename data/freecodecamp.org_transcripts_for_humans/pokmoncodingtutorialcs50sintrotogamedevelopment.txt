With timestamps:

00:16 - SPEAKER 1: All right,
welcome to GD 50, lecture 7.
00:19 - This week we'll be talking about one
of my favorite franchises of all time,
00:22 - a core part of my childhood--
00:24 - Pokemon as shown by the Poke
Ball on the screen there.
00:27 - So back in 1997 I think
it was, the first Pokemon
00:32 - game was released, Red and Blue.
00:34 - I believe it was released a
year earlier in Japan where it
00:36 - was released as Red, Blue, and Green.
00:39 - And the overall goal of the
game was fairly straightforward.
00:42 - You were a Pokemon trainer.
00:43 - Your goal was to go out into
the world and try and capture
00:47 - any number of 151 different
types of these creatures called
00:51 - Pokemon that were based on a whole
bunch of different types of creatures.
00:56 - Shown in the screenshot here, there's
a Weepinbell fighting and Geodude.
01:00 - A Geodude was a rock type,
Weepinbeel was a grass type.
01:03 - You had different types of Pokemon.
01:05 - When they fight each other, some
types were better than other types,
01:08 - like this sort of very large rock,
paper, scissors relationship.
01:12 - And it was just a very
addicting formula.
01:14 - You'd have a team of these creatures
that you had caught and raised
01:17 - and battled, and you'd
fight other trainers.
01:20 - And the awesome part of
this was you could go
01:23 - and you could actually
fight your friends,
01:25 - or trade Pokemon with your
friends that they had caught.
01:28 - And you would often share
stories back and forth
01:30 - about the different rare creatures
that you would have encountered,
01:32 - and all sorts of things.
01:34 - You'd have a customized party
that was sort of a part of you.
01:37 - And so this is Pokemon Red.
01:38 - The series has evolved over time.
01:40 - This is a screenshot of Gold and Silver,
which was released a couple of years
01:43 - afterwards for the Gameboy Color.
01:45 - Again, this was released
for the regular Gameboy.
01:48 - Gold and Silver introduced a bunch
of new features including breeding,
01:51 - and a day, night cycle,
and a lot of other things
01:53 - that became part of the core series.
01:55 - Here is Ruby and Sapphire, which
was for the Gameboy Advance
01:58 - and got a significant graphical
update, but the core formula
02:01 - stayed much the same.
02:03 - Here is Diamond and Pearl,
which is for the DS, which
02:08 - it made use of two screens, as
seen on the top and bottom there.
02:11 - Here is Black and White,
which was another step forward
02:14 - in that it introduced three dimensional
graphics for the over world,
02:18 - so you could actually see some sort of
3D for the first time in the franchise.
02:21 - And then more recently, we've seen
for the 3DS, games like X and Y,
02:26 - which is shown here, and
Omega Sapphire, Alpha Ruby--
02:29 - Alpha Sapphire and Omega
Ruby, and Moon and Sun.
02:33 - And so this is a great
illustration of why
02:37 - the RPG genre of video
games, role playing game,
02:41 - even though it's sort of its
own unique take on the formula.
02:44 - But it allows us to, we can sort
of dissect this and take a look
02:47 - at what makes an RPG and what
makes a Pokemon game altogether
02:51 - for a nice cool demonstration.
02:52 - So today, we'll be talking
about a few new things.
02:54 - We'll be doing things a lot
differently in this lecture example
02:58 - relative to other examples, because
we're transitioning away from the state
03:03 - machine and talking about a construct
called the state stack, which
03:07 - is effectively a more advanced
version of the state machine.
03:10 - Whereas before, we had a state machine
that was in one state at a time,
03:15 - whereby we could be in the play
state or the start state or what
03:19 - not, we can now actually
have multiple states
03:22 - that exist in parallel that are on a
stack of data structure, which you've
03:25 - seen in CS 50 if you've
taken, where we can have,
03:29 - for example, the field state, the
play state at the very bottom,
03:32 - which is always there, and then
we can push states onto the stack
03:36 - as we need to for
example, a dialog state
03:39 - so that we can actually
display some dialog,
03:41 - some text to the screen without
getting rid of the play state
03:44 - that we had there before.
03:46 - It allows us to render multiple
things at the same time,
03:50 - and then also return
back to prior states,
03:52 - rather than completely
create new states every time
03:55 - we want to make a transition.
03:57 - We'll be talking about
turn based systems.
03:58 - So an RPGs like Pokemon
and others, there
04:02 - are often battle
systems that are usually
04:06 - turn based in this particular genre
where you're fighting-- you have
04:09 - one team or one character fighting
against against one other team or one
04:11 - other character, and you take
turns fighting each other.
04:13 - And you have an indefinite amount
of time to make your decision
04:16 - and then form some sort
of strategy as to how
04:18 - you want to approach the problem.
04:20 - We'll be taking a look at a very
primitive turn based system,
04:23 - but a fully functional one today.
04:26 - Another huge aspect of this genre
is graphical user interfaces or GUIs
04:32 - as they're shortened.
04:33 - Things like panels, and scroll
bars, and text boxes, and menus, all
04:37 - sorts of these things that allow us
to get a more visual sort of look
04:42 - at our data, and allow us to navigate
a much more complex game ecosystem more
04:46 - efficiently.
04:47 - And to tie it all together,
RPG mechanics at large,
04:50 - we'll be looking at things
like leveling up and experience
04:53 - and how to calculate the damage that
one party does to the other party
04:57 - throughout the course of a battle.
04:59 - And so it will be a fairly
complicated set of examples,
05:04 - but fairly illustrative
of the genre as a whole.
05:08 - So I'd like to demonstrate sort of
the example that I put together.
05:11 - If I could get a volunteer from the
audience to come up and take a look.
05:15 - Tony that'd be awesome,
thank you so much.
05:18 - So this is my simple but fully featured,
more or less, demonstration of Pokemon.
05:23 - So if you want to enter or return.
05:27 - So this is a--
05:29 - so here we have a--
05:30 - we can see right off the bat, we
have a text box and a play state
05:35 - like we did before.
05:36 - So this text box is actually a state
that's layered above the place.
05:41 - So you can see it has some instructions
about, if you want to press P,
05:43 - you can heal your Pokemon.
05:45 - You can press Enter to dismiss.
05:46 - So if you go ahead and
press Enter, you'll
05:47 - be able to actually move around now.
05:49 - And so something to note is
before, input was actually
05:52 - halted while the dialogue was on the
top of the screen for the play state.
05:57 - You're actually not allowed to
access or update this bottom state,
06:01 - because the state stack is only
allowing input to the top state.
06:05 - And so I have limited the
play here just to this box,
06:09 - but if we walk in the tall
grass down here, in Pokemon,
06:13 - in order to actually
initiate an encounter
06:15 - with another Pokemon or another
wild Pokemon, you walk in the grass.
06:19 - So here we've walked in the grass.
06:20 - There's a random chance for this
to happen, there's a 1 in 10 chance
06:25 - basically.
06:26 - So it's saying that a
wild Bamboon appeared.
06:28 - So a wild creature appeared.
06:29 - He's level 5, we're level 5,
should be a fairly even battle.
06:32 - So you can press Enter,
and it will say go
06:34 - the name of your Pokemon, which
is an Aardart in this case,
06:37 - and it's randomly
allocated at the moment.
06:39 - So go ahead and press
Enter one more time.
06:41 - Now we can see on the bottom
right, we have a menu.
06:43 - So we can fight or we can
run, so those two choices.
06:46 - So we can go ahead and fight.
06:47 - So we fight, whichever
Pokemon has the higher
06:49 - speed will go first and do damage.
06:51 - We obviously, do a lot more damage,
but he's a little bit faster,
06:55 - so he's going to go first.
06:56 - So we fight one more time.
07:00 - We should be able to knock him out.
07:03 - So as soon as we do, we get a victory
message, we get a victory song.
07:06 - If we press Enter, we'll
actually get some experience
07:08 - for defeating that enemy.
07:10 - So we've got quite a bit of
experience, we got 65 XP.
07:12 - In that bottom bar, we can see
we have all these GUI elements,
07:15 - we've got a panel here, we have
text boxes, we have progress bars,
07:19 - all these pieces are coming together to
give us sort of this turn based system.
07:24 - And so after this, we may
level up just to demonstrate
07:27 - leveling, which is part of the
RPG mechanic side of this game.
07:31 - So we have to press this one more time.
07:34 - We did, perfectly.
07:35 - So they leveled up.
07:36 - And so now we're level 6, so we can see
the 6 changed above our progress bars.
07:44 - So now will be a little
bit stronger every time.
07:46 - And the stats aren't shown here, it's
actually a part of the assignment
07:49 - is to create a menu that will
actually show you how you leveled up,
07:52 - what stats actually increased.
07:54 - But underneath the
hood, behind the scenes,
07:57 - you actually are getting stat increases.
07:59 - And so here we can see that if we
our HP goes all the way down to zero,
08:03 - we faint.
08:04 - And when we faint, the screen
instead of fading to white
08:06 - will actually fade to black
to illustrate the difference
08:09 - between the two transitions.
08:11 - And so that we can keep
playing indefinitely,
08:13 - the game will restore your
Pokemon back to full health.
08:16 - And so this will go on forever.
08:18 - This is effectively what
the simulator is, it's just
08:20 - a simple series of infinite battles.
08:22 - There are random Pokemon in the grass.
08:24 - There's five total that you can fight.
08:27 - But all the core pieces of
what make the game are here.
08:30 - So actually, let's
illustrate running too
08:31 - if you wouldn't mind, just so that
we can see if there is a difference.
08:34 - So we can actually flee, and then
battle we'll get cut short there.
08:37 - We won't get any XP, we
won't faint, but we still
08:39 - get taken back to the play state.
08:41 - So that's all for the Pokemon demo.
08:43 - Thanks so much Tony for
coming up to demo it.
08:45 - Well, there's a lot of pieces
involved here, but as we will see,
08:53 - once we have a lot of these sort
of foundational pieces implemented,
08:56 - it's not too difficult to start
layering more and more of these
09:00 - onto the game to make it even more rich.
09:02 - In fact, the assignment is to--
09:05 - and we'll see this at the end,
I'll recap this at the end--
09:08 - but the assignments goal is
for you to implement a menu--
09:12 - similar to the menu that we saw
where fight and run were shown--
09:16 - that will show you what your current
stat is for each of your stats,
09:19 - there's attack, defense,
speed, and your HP.
09:22 - It will show you what your stat
is before leveling, the amount
09:25 - that it will increase by,
and then the final amount,
09:28 - which is sort of similar to how
the actual Pokemon games work,
09:31 - so you can see rather than just seeing,
oh I increased my level from 5 to 6,
09:35 - 6 to 7, you can see, oh, my
strength increased from 12 to 14.
09:38 - I'm a little bit stronger, I'm going
to do more damage on the next play
09:41 - through.
09:43 - So our goal here, we're going to take
a look at the field state, the play
09:47 - state, and the battle state.
09:49 - And there's a common dichotomy
in most of these sorts of games,
09:53 - be it Final Fantasy, or
Dragon Quest, or Pokemon
09:55 - where there is a field,
where you are walking around,
09:58 - you're character interacting with a game
world with NPCs, going through towns,
10:02 - and what have you.
10:03 - And then a battle mode,
sort of a battle state
10:05 - where you're actually fighting
against some sort of enemy,
10:08 - or a series of enemies, a
party or a single creature.
10:11 - And so we've implemented simple
versions of both of these to illustrate
10:14 - and also the transitions between them.
10:17 - Before we start, I want to
make another sort of plug
10:21 - for this howtomakeanrpg.com, this book,
I actually learned a lot from this
10:26 - and about using LUA in the
context of game development.
10:28 - And I pitched this I think in
one of the earlier lectures,
10:30 - but if you want a deeper dive
into a lot of these constructs,
10:34 - and to sort of get a sense for how you
might do something like cut scenes,
10:38 - or more complicated battle
layouts, and a lot more like--
10:42 - it goes into a lot of detail
about a lot of awesome things,
10:44 - definitely check it out.
10:45 - It's not free, but if you're
interested in this genre, which I am,
10:49 - it's definitely worthwhile.
10:50 - Here's what the sprite sheets
look like that we'll be
10:53 - using for this sort of demonstration.
10:55 - The Pokemon aside, which
are individual textures.
10:58 - Here we're using a simple
sprite sheet, which
11:00 - just has a bunch of tiles,
most of which we did not use.
11:03 - Note that the bush, the tall grass
is not on any sort of background.
11:08 - And therefore, we need
to layer, basically
11:13 - have two separate tile maps as opposed
to one, which we didn't do last time.
11:17 - And we were reusing the sprite sheet
that we used in the Zelda lecture.
11:22 - Before, we used it for all the
enemies, the skeletons, ghosts,
11:24 - and slimes, et cetera.
11:26 - But now we're actually using it
for the PCs that it contains.
11:28 - Specifically, just the male NPC
here, which is our main character.
11:34 - The foundational class that
we're using in this lecture
11:37 - that sort of everything else
revolves around and makes this work
11:42 - is the state stack.
11:44 - And so before, what we had
was a state machine, right,
11:49 - where we were in one state at a time.
11:51 - So you can almost think of
it like, we have a box here,
11:55 - and it just has one socket.
11:57 - And then we're always
looking at this one socket,
11:59 - whether it's the play
state, or the battle state,
12:02 - or a transition of some kind.
12:05 - And now we're transitioning
into the idea of, instead,
12:08 - of just one state that we can only
see at once, we'll make it a stack.
12:14 - And so what we can do with this
is, rather than just having one,
12:18 - we can therefore render multiple
states at a time, right?
12:22 - So let's say this is like the
field, right, or the play state.
12:27 - And then maybe this is like a
dialogue, or something, right?
12:31 - Like we saw before in the
field, we had a text box.
12:34 - We can actually layer
things on top of each other.
12:37 - And then maybe this is like a
fade out, right, or a fade in.
12:42 - So we start with the play state
maybe, and we're walking around,
12:45 - and we interact with in NPC.
12:47 - Rather than transition the
play state to a dialog state,
12:50 - which would, in our previous model,
completely eliminate the play state,
12:55 - because there's only one state
that could be active at a time.
12:58 - Now we just render, however many
states we have in our stack,
13:02 - we just render them sequentially based
on the order that they were popped in.
13:05 - We would rendered this first, we
basically render from the bottom up.
13:09 - Render the play state, then
the dialogue, then the fade in.
13:12 - And this will have the effect of doing
a whole bunch of different things, which
13:15 - we'll see in the distro.
13:17 - But we only really ever need
to update one state at a time,
13:21 - right, because if we have the play
state active and the dialog state active
13:26 - and the fade in state active,
in this order, as a stack,
13:29 - right, we were pushing the operation
for pushing for getting something
13:33 - onto the stack is called
a push, and getting it off
13:36 - is called a pop if unfamiliar.
13:38 - If we're pushing all of these
states on, then usually,
13:41 - we only need to update
whatever's on top, right?
13:44 - If there's no fade in
for example, and we only
13:46 - have a dialog state active,
or a dialogue and a place
13:49 - state in that order top
to bottom, then we usually
13:53 - don't want him update what's
going on in the play state.
13:55 - We're only concerned with the
dialogue that's taking place.
13:58 - We only want that to take input.
14:00 - And when we press Spacebar,
Enter, or whatever
14:02 - button clears that dialog
state, we pop it off, right,
14:06 - and then we're back to the play state.
14:08 - Then we're just updating the play state.
14:10 - And so being able to update
just what's on top while
14:14 - being able to render
everything that's on bottom.
14:16 - And this doesn't hold true
for all game formulas,
14:18 - there's certainly some games where you
can have a dialogue and a play state
14:22 - both get updated, but that's still
using a state stack of sorts,
14:28 - you're just then updating
things in a top down way.
14:31 - But this allows us to do all
kinds of things like transitions,
14:35 - and preserving-- like for example,
the fact that we have a play state
14:38 - and we can pop a battle
state on top of that,
14:40 - where we don't see the
play state underneath it,
14:43 - we only see the battle state,
and that's all updating.
14:45 - But it is we pop the
battle state off, we're
14:47 - right back where we just
were in the play state.
14:49 - It's preserved its state, for lack
of a better word, from before.
14:53 - And this is something that this
model affords us comfortably.
14:58 - And so that's sort of the
foundational class that's
15:01 - implemented in this
distro, which will allow
15:03 - us to do all kinds of awesome things.
15:06 - So let's go ahead and take a
look at what that looks like.
15:09 - I have state stack open here.
15:11 - So state stack has just
a set of states here.
15:18 - And then whenever we
want to insert a state,
15:20 - it's going to be at the
end of the state stack.
15:23 - So it's going to be whatever the last--
15:25 - so if we're looking at it as
a series of states in a table,
15:28 - it'll be whatever the last
index is in the table.
15:31 - That will be our, the top of our stack.
15:35 - And you can implement this either
way in reverse if you wanted to.
15:38 - It's just easier, because you can just
do a simple table.remove to get rid
15:44 - of the--
15:48 - table.remove on that table
to get rid of the last state
15:52 - without having to shift back everything.
15:54 - So if we did it starting at index one,
you'd have to shift everything back.
15:57 - And it would also be a little bit
weird, because you would start at one,
16:00 - and then things would go left.
16:03 - But basically, in order to
update whatever our end state is,
16:07 - we just do at #self.states, which will
be however large our state stack is,
16:13 - we just call update on that state.
16:16 - And then process AI is here,
although we're not using it.
16:19 - But if you had AI, it
would be the same thing
16:21 - as basically an update for artificial
intelligence for your state.
16:26 - Rather than rendering
just one state at a time,
16:29 - we iterate through
all of our states here
16:32 - using ipairs, which will
iterate through them numerically
16:35 - starting at one going to the end.
16:38 - So we call for istate, and
ipairs of self.state, render it,
16:41 - so that will render everything
back to front, or bottom to top,
16:47 - and allow us to get
this layered look where
16:49 - we have a play state going
on underneath for example,
16:51 - and then a dialogue on top.
16:54 - Or we have a battle state
going at the very top,
16:56 - and maybe that battle state
itself pushes a dialogue
16:59 - state to the top of the stack,
or a bunch of other states,
17:02 - a transition, whatever you would like.
17:05 - To clear it, we just reset
the table to an empty table.
17:08 - To push a state, we just do an
insert on that state, and then
17:12 - we call enter on that state.
17:14 - As we did before, sort of similarly with
state machine, when we changed a state,
17:19 - we would call enter on it
and exit, but now we're
17:21 - just calling enter when we push.
17:23 - And then to pop, all we do
is call exit on whatever
17:26 - the last state is in our
state stack, and then just
17:30 - call table.remove on self.states.
17:32 - And by default, when you call
table.remove on a table, just a table
17:36 - with no other arguments,
it'll remove whatever
17:40 - the last index is of that table.
17:43 - Does that makes sense?
17:44 - Anybody have any questions as
to how the state stack works?
17:49 - All right, awesome.
17:51 - So let's take a look
then at the start state.
17:56 - So this is the start date.
18:03 - Fairly simple, we just have
a couple of text labels,
18:06 - and then we have just a randomly
assigned sprite going left to right.
18:10 - How do we think we're
achieving the movement?
18:14 - Yep, timer.tween, and
then we're just drawing
18:17 - an ellipse, right, pretty simple.
18:19 - And then when we press
Enter, note the transition.
18:24 - Notice that there's a fade to
white, and then fade to transparent.
18:31 - And so if we recall from when we looked
at match three, how do we do this,
18:34 - do we remember?
18:36 - AUDIENCE: [INAUDIBLE]
18:42 - SPEAKER 1: Exactly, and the
rectangle was stored where?
18:50 - Sorry, to repeat for the
camera, we had a rectangle
18:52 - that filled the entire screen, and we
just tween the transparency for it,
18:56 - which is true.
18:57 - The rectangle there
before though was stored
19:01 - in whatever state was active at the
time, which was like the start date,
19:04 - or the I think begin
game state was the name.
19:08 - The actual state that wasn't
necessarily relevant at the transition.
19:13 - But using a state stack, we can
actually decouple this idea.
19:18 - We can take the concept of a
transition, and because imagine
19:21 - if we wanted to make a transition
between every single state
19:24 - that existed in our game, right?
19:25 - If we wanted to transition
from the battle to the field,
19:28 - or the field to the battle, or whatever
else we might want, like the start
19:33 - to the field, we would need a
rectangle in every single one
19:36 - of those that has an opacity
that we're keeping track of.
19:39 - And that's not necessarily germane
to the purpose of that state, right?
19:44 - So because we now have a
state stack, we can actually
19:47 - abstract out this idea of a transition,
and turn it into its own state.
19:52 - We can have a transition state.
19:56 - And recall that since we're
just layering everything
19:59 - [? off ?] all these states, and
we're rendering them sequentially,
20:03 - having a state that possesses it's
own for example, opacity rectangle,
20:07 - we can just layer that, push that
onto the stack, and render that,
20:12 - and it'll give us the illusion
of having this transition.
20:16 - But we don't need to actually
have it be part of the state
20:19 - that we're trying to
transition out of and into.
20:21 - Does that make sense?
20:23 - So let's take a look,
for example, at the--
20:27 - let's take a look at
the start state first,
20:29 - just so we can see where that
actually gets kicked off.
20:32 - So the start state, we kick off
some music, we have a sprite,
20:36 - and a sprite x and y.
20:37 - These are values that are relevant to
the sprite that's moving, actually,
20:40 - we only have one sprite
ever moving left to right.
20:43 - It just gets teleported to
the right edge of the screen
20:45 - as soon as it gets taken to one edge.
20:47 - So we only have one sprite, one x and y.
20:51 - And then every three
seconds as we see here,
20:53 - we have a callback function that will
tween the sprites x to negative 64
20:59 - over 0.2 seconds, so really quickly.
21:03 - And then on finish,
teleport it to the right.
21:06 - And then do the same
exact thing, but tween it
21:08 - to the center over 0.2 seconds.
21:11 - And then as soon as we press
Enter or Return, note this here,
21:18 - we have gStateStack, not
a gStateMachine anymore,
21:22 - and we're pushing on
to it a fade in state,
21:27 - which takes an RGB, a duration,
and a callback function.
21:32 - Now if you look at
main.lua, this is relevant,
21:38 - because now we no longer
have a state machine, right?
21:42 - We previously had a global
state machine, gStateMachine.
21:45 - We would give it a list of indexes
into functions, anonymous functions.
21:49 - Those would return the
instantiation of a state.
21:53 - And then when we called
change, the state machine will
21:55 - index into its list of states,
and call that anonymous function,
22:00 - which would have the result of
changing the state to some state
22:04 - that we've implemented
as a class, right?
22:07 - Now we just create a
state stack and we just
22:09 - push a new start state onto the class.
22:14 - And so what this will do is
effectively the same thing, only now
22:18 - we can layer things onto the
start state, right, or play state,
22:23 - or whatever we want to, and we're
not going to ever get rid of it.
22:25 - I mean, we can get rid of
it, but we don't have to.
22:28 - For the play state, especially, we
want that to pretty much never get
22:32 - popped off the stack,
because that's going
22:35 - to preserve all of our information.
22:36 - We're going to default back to that to
store all of our character information,
22:40 - our Pokemon information,
whatever else we might
22:43 - want to add onto this shell
of a game in inventory,
22:46 - et cetera, a world state at large.
22:49 - We want to preserve that and keep that
consistent across all of our battle
22:53 - states and so forth.
22:54 - And the battle states will just
pull information from that world,
22:58 - from that play state, and
construct a battle as needed.
23:01 - Does that makes sense?
23:04 - OK, so here we're effectively, the
only real changes we've made to main
23:08 - are no longer a state machine,
now we have a state stack,
23:11 - going to push start
state, that start state
23:14 - has some behavior just like any other
state that we've implemented before.
23:22 - And what I was about to get into before
was here on line 36 of the start state,
23:29 - we're pushing another
state onto the stack.
23:32 - So there's already a start state, and
it's from within the start state itself
23:36 - actually.
23:40 - We're going to take that stack,
which is just one level deep,
23:42 - and then we're going to
make it two levels deep now.
23:44 - So now we're going to
add a fade in state.
23:46 - And the fade in state as we
can see, takes in an RGB.
23:49 - Does anybody have a guess as to
what the RGB is relevant for?
23:55 - AUDIENCE: [INAUDIBLE]
23:58 - SPEAKER 1: To whether you want
to fade in black or white?
24:00 - Yes, any color.
24:02 - We can make this, we can make it
a fade to red if we wanted to,
24:04 - or fade to blue.
24:06 - But we don't have to create two
separate classes for a fade in white,
24:10 - fade in black, fade out
black, fade out white.
24:13 - We can just give it a color.
24:16 - And then I mean, we could even
go a level further with this,
24:20 - and make it take in an opacity as well,
so that we don't need a fade in state,
24:23 - or a fade out state, we just
need a fade state, right?
24:26 - And the fade state will
determine, based on whatever
24:30 - last opacity parameter we give it,
the right way to fade in and out.
24:37 - But in this case, the difference
between the fade in state
24:40 - and the fade out state is one knows
to go to 0, one knows to go to 255.
24:44 - That's really the only key difference.
24:46 - And then this 1, the duration, right,
we need to tell it how long to fade.
24:51 - And then this last bit
here is a function.
24:55 - We're giving it an anonymous
function, this is a callback function,
24:59 - because the fade in state by
nature is an asynchronous state.
25:06 - It does its behavior over time.
25:08 - So we need a way, we
need to tell it, OK,
25:10 - when you finished doing what
you're doing, call this bit of code
25:14 - here, so that we can do
something not immediately,
25:19 - we can sort of defer its
execution till later.
25:22 - And this is something that we'll
see common throughout this lecture,
25:26 - because we have this implemented
also in like dialogue for example,
25:29 - because we don't know when the user is
going to press Spacebar on the dialog
25:34 - state and clear the window.
25:36 - But what if we want that window,
the clearing of that dialog
25:39 - to trigger some sort of event, right?
25:41 - For example, if they press Enter
when they're in the battle,
25:44 - we want it to go to the next action.
25:46 - We don't necessarily know
when it's going to happen,
25:48 - so we'll just pass in an anonymous
function to that dialogue state
25:54 - that the class will call whenever the
close function is called on that dialog
25:59 - state.
26:00 - It says, when closed, execute
this anonymous function.
26:03 - And then that anonymous function
can do whatever you want to do.
26:06 - It could pop another other
several states onto the stack.
26:09 - But this is what allows us to
chain asynchronous behavior.
26:12 - That's the key here.
26:15 - So this anonymous function-- so
we'll take a look now actually
26:18 - at the fade in state, just so
we can see what this looks like.
26:23 - So we see here, fade in state,
right, takes in the color.
26:26 - We saw before, that will
be the color we fade to.
26:30 - The length of time that it'll take us
to actually perform the transition.
26:34 - And what are we using for the transition
do we think, timer.tween, right?
26:46 - So most everything
that we'll do actually
26:51 - throughout the course of this lecture
that has asynchronous behavior,
26:55 - we can implement it with
timer, which is nice.
26:57 - It allows us to fairly
succinctly and declaratively tell
27:01 - right out what exactly we
want to have happen over time.
27:04 - In this case, we're going to
tween over the course of time
27:07 - the opacity of our self to 255.
27:11 - So the fade in is going to fade
into the full color of whatever we
27:15 - have given it.
27:16 - So it's going to go from 0, which
is shown here by default, to 255.
27:22 - And then as soon as
we finish that tween,
27:27 - that is when we pop the fade in state.
27:32 - We're going to pop ourselves off
the state effectively, off the stack
27:35 - effectively.
27:37 - And then here, we're
calling on fade complete.
27:41 - And that's where the
anonymous function is.
27:43 - On fade complete is passed in here.
27:45 - So by putting that function into the
finish function of the tween operation,
27:52 - we've allowed ourselves to defer that
function that we've written up in the--
27:58 - it's in the start state.
28:01 - We defer the execution of this function
until after that tween operation
28:04 - takes place.
28:05 - Does that make sense?
28:08 - OK, awesome.
28:09 - And that's effectively what it is.
28:11 - And that's a common theme that we'll see
if you're looking through the distro,
28:13 - you'll see it in a lot of places.
28:15 - Anonymous functions
or callback functions
28:17 - rather being passed into things
like the dialogs, and the fades,
28:24 - and a few other places.
28:26 - In the take turns state
for example, there's
28:28 - a function that takes in at
a callback function as well.
28:30 - And that's effectively how you can
chain asynchronous behavior that
28:38 - executes over time, rather
than it being blocking.
28:41 - Does anybody have any questions so
far as to how this works, at all?
28:47 - All right, so when the fade is done--
28:51 - we're still the start state here--
28:54 - at this point, the fade is done, we're
executing this anonymous function.
28:58 - We're going to pop the start state
off of the stack in this case.
29:09 - And then we're going to push a--
29:12 - we're going to do two pushes here.
29:15 - One is to push a play state, which
recall is where the NPC [INAUDIBLE]
29:20 - character walking around.
29:23 - And another one is to
push a dialogue state.
29:27 - And so what this will have the
effect of doing is rather than us
29:29 - immediately going into the play
state and being able to walk around,
29:33 - we're actually put
right into a world where
29:35 - there is a message waiting
for us that we have
29:37 - to press Enter on in order to continue.
29:40 - And when we press Enter, because
we're pushing the play state first,
29:45 - and then the dialogue
state, the dialogue state
29:47 - is at the top of the stack,
right, because things
29:49 - get pushed onto like a stack of plates.
29:53 - You put a play state plate on the
bottom and then another plate on top,
29:56 - and that plate is the
dialogue state in this case.
30:00 - And you can only interact with the top--
30:02 - we're only updating the top
plate at once in this model.
30:06 - We could obviously make
a more complicated state
30:08 - stack that allows us to have several
layers of states being updated at once,
30:14 - but for simplicity, we only opted to
allow the top layer to be updated.
30:19 - The dialog state is going
to be the active state,
30:21 - it's going to be receiving input.
30:23 - All of them are going
to be rendered, so we're
30:25 - going to render things
from the bottom up.
30:27 - We're going to render
the play state, then
30:28 - we're going to render the dialog
state, but the dialog state's
30:31 - going to be active.
30:31 - We're only going to be able to
press anything on that state.
30:35 - And then lastly, actually,
even beyond the dialogue state,
30:40 - we're pushing another state,
we're pushing a fade out state.
30:43 - And in this case, it's the
opposite of the fade in state,
30:47 - it just takes in an RGB, and
we'll go from 255 opacity
30:51 - to zero opacity in that case.
30:54 - And so what that allows us
to do for playing right,
31:00 - we're here in the start
state, pressing Enter.
31:03 - That's our fade in state was there.
31:06 - And then we pushed to the play state
and the dialogue state and the fade
31:11 - out state at once, so
you would almost think
31:15 - that we push a fade in
and then the fade out,
31:18 - but we have to lay that
foundation before we
31:21 - put the fade out state
on top of the stack,
31:24 - right, because the top
layer gets updated.
31:27 - So we have to push the fade out
state on top of all of those.
31:30 - That will get updated,
that will fade out,
31:32 - and then we're back to the
two states that we push
31:34 - before we pushed the fadeout state.
31:36 - Does that make since?
31:39 - OK.
31:40 - Does anybody have any questions
as to how that sort of flow works?
31:44 - Cool.
31:47 - All right, so that's
the gist behind, I mean,
31:49 - that's essentially the core
of what we're doing today
31:54 - is the state stack
pushing multiple states.
31:56 - And then just figuring
out the right order
31:58 - the need to push them in to get the
desired appearance that you want,
32:02 - right?
32:03 - We push the fade out state
while we're in the start state,
32:07 - or fade in state rather.
32:08 - That will take us to
white, and then like sort
32:10 - of, almost like underneath the-- behind
the curtain, we're popping everything,
32:17 - and then we're adding the play,
dialogue, and then another fade out
32:20 - state.
32:21 - And so you sort of have to balance the
order that you put things in in order
32:25 - to achieve the desired results.
32:26 - It may not necessarily be
exactly as you intuitively
32:28 - think until you think about just
how we're updating and rendering
32:32 - things on a stack.
32:34 - And so that's the ultimate hurdle I
think in really getting comfortable
32:38 - with the distro, but once you've gotten
that, everything else sort of falls
32:41 - into place.
32:42 - That and the sort of abundance of
asynchronous functions, as we'll
32:46 - see pretty shortly when we look
at GUIs, and how we've implemented
32:49 - a lot of basic GUI functionality.
32:51 - A lot of that is very,
very call back driven,
32:54 - just because of the nature of it
being based on user input, right?
32:58 - You don't know when the
user's going to do any input,
33:00 - so defer whatever happens
with that GUI code
33:04 - with the triggers involved
when the user presses Spacebar,
33:08 - Enter, and then call that function that
you've passed into that GUI widget.
33:13 - All right, so we've taken
a look at the state stack.
33:17 - We've taken a look at the
start state, the fade in state,
33:20 - let's take a look now at the play state.
33:25 - So the play state--
33:26 - a lot of this is actually
very similar to what
33:28 - we did back with Zelda, which is a
very similar type of game top down.
33:35 - View, the only difference really
with that was RPGs of this nature--
33:40 - Final Fantasy, Pokemon,
Dragon Quest, they're
33:42 - tile based to the degree of even
your movement is tile based.
33:47 - And so we've striven to
implement that with this lecture.
33:51 - So when we move our
player, our character,
33:57 - it doesn't have free motion like
we did with Zelda for example.
34:02 - So I'll demonstrate this.
34:03 - So I can go to the field state
here, the play state, sorry.
34:07 - And then when I move,
if I press right, he
34:09 - moves in that direction at
a perfect grid interval.
34:13 - So if I move up, I'm taking
my hand instantly away,
34:16 - he's going to keep moving, and he's
going to stick hard set to this grid.
34:20 - And that's just a sort of trend
that these games have implemented.
34:25 - It allows you to stay perfectly
aligned with the grid, and helps you
34:29 - I guess certain game--
34:30 - I don't think it's strictly
necessary for probably
34:33 - most of the games that
choose to implement this.
34:37 - I think it was a symptom of tile
based games from the NES and Gameboy
34:41 - era being easier to
design and implement,
34:47 - because they're very tile based systems.
34:51 - But I mean, even as an aesthetic
choice, I suppose it makes sense,
34:55 - because everything
aligns very perfectly.
34:57 - So that's the core difference really
with the field state in this game.
35:00 - So how can we go about implementing a
grid aligned movement system like this
35:09 - with our player relative to how
we did it in Zelda for example?
35:16 - How do we think-- sure yeah?
35:18 - AUDIENCE: So we don't x and y's,
we just have the tile positions.
35:23 - SPEAKER 1: So you don't have x and
y's, we just have the tile positions.
35:26 - Close, I would say it's more
focused on the tile positions,
35:30 - but you still do need an x
and a y, because you still
35:33 - need to draw that sprite
at that exact position.
35:37 - Right, yes Tony?
35:38 - AUDIENCE: Well, when you need
to move the sprite, instead
35:42 - of moving at every update, you tween
it between the two tile locations.
35:47 - SPEAKER 1: Exactly, so
rather than moving the sprite
35:51 - at exact pixel positions per update, you
tween the sprite when you receive input
35:57 - to a specific location.
35:59 - And then we actually stop
input at that point as well.
36:02 - There's no use for us having any input
when we're not exactly at a given tile,
36:08 - so we disable input while
he's walking effectively.
36:12 - And so this is implemented, if we're
looking at the distro in the entity
36:16 - class, there is a--
36:19 - I believe it's in here--
36:24 - maybe player, hold on.
36:32 - Oh sorry, no it's entity
walk state, not the entity.
36:35 - Entity is just a container for
the information that's relevant.
36:38 - So here in the entity walk
state, we have attempt move.
36:42 - And so what attempt
move does is essentially
36:45 - it looks to make sure that we're
within the bounds of the map, right?
36:49 - And then if we are--
36:51 - every entity in this game now has a
map y and x, and a regular y and x.
36:56 - And so the regular y and
x, we still need in order
36:59 - to draw our sprite at a
specific location on the map.
37:01 - We still need to draw it going between
240 something and 230 something, right?
37:09 - But we need a map x and a
map y to basically say, OK,
37:12 - the sprite should be at
this position on the map.
37:15 - And then we'll just tween it
between that position times 16,
37:19 - and it's the position
plus or minus x or y
37:22 - times 16, which will give us
the exact x and y value that we
37:26 - need to draw it onto the map.
37:27 - And so that's what we're doing here.
37:28 - So were going to call
attempt move on input.
37:32 - So anytime we do any input--
37:34 - and this is done in the player
like idle, or player, yeah, player
37:39 - idle class--
37:41 - player idle state.
37:43 - We change the animation
to write animation.
37:46 - And then we get it's
current map x and y.
37:48 - And then based on whatever
direction the player is looking,
37:51 - or the entity is looking, we could use
this for an NPC class, or the like.
37:56 - We just modify our 2x and 2y.
37:59 - So to 2x and 2y is going to be the value
that we're tweening towards times 16,
38:04 - right?
38:05 - And so if we're trying to go
outside the map boundaries,
38:10 - just changing us back to
idle won't let us do that.
38:13 - Otherwise, set our map y and map
x to that position immediately,
38:19 - right, because that's just a
minus or plus one operation.
38:22 - And then over the course of 0.5
seconds, actually tween to that value.
38:28 - And we can see here, we're
tweening to the tile size,
38:30 - and actually to the tile size minus
self.entity.height divided by 2.
38:35 - Do we know why that is?
38:40 - We do that, because if we're looking
at the field, we can see here,
38:45 - notice that we're not perfectly
lined up with the grass, right?
38:48 - It's kind of like
we're halfway above it,
38:50 - because it looks just a little
bit more natural this way,
38:53 - this is how most sort of games look.
38:54 - And if you're in a game
like this and you're
38:56 - like walking up against
a wall for example,
38:58 - this will allow you to
sort of look as if you're
39:00 - up against the wall
rather than sort of being
39:03 - at the edge of where the bottom of the
wall is, and kind of looks unnatural.
39:06 - Hence why we minus 1/2
our height right there.
39:12 - And then when we're
finished, we actually
39:15 - test to see whether we're still
pressing a key, and if we are,
39:18 - then change our state
to walk again, which
39:20 - we'll just repeat this process depending
on which direction we're looking at.
39:24 - And that's effectively it.
39:25 - And that's what allows us to
get this grid based movement.
39:28 - Any questions as to how this works?
39:33 - Cool.
39:37 - Let's take a look then at the
play state, let's go back to it.
39:43 - So we have a level, the
level contains our entity,
39:46 - and it can contain all of
our entities, and whatever
39:49 - objects you want it to contain.
39:53 - In this case, when we're
in the play state as well,
39:55 - we're going to check
to see if we press P,
39:57 - because that's recall, where
we can heal our Pokemon,
39:59 - just a little game hack just to
make demoing it a little bit easier.
40:05 - But if we press P, we play
the heal sound, we take our--
40:11 - and we'll look a little bit more detail
as to this, all this in a little bit.
40:16 - But self.level.player.pa
rty.pokemon@index1.currenthp
40:24 - equals
self.level.player.party.pokemon@1.hp.
40:29 - So the difference is current HP
is whatever you currently have,
40:32 - you could have taken damage.
40:33 - HP is whatever your max HP is.
40:35 - And this is like in a
nutshell how you get
40:38 - like stat changes in games and
RPGs, and health and mp differences.
40:44 - You've got to keep track of a max and a
current value for all of those things,
40:48 - and then depending on whether
you're buffed or debugged,
40:50 - or whether you have taken damage
or not, or used spells or not,
40:54 - you can have an accurate
reflection of where
40:56 - your character is and then
always return back to that state
41:01 - whenever you need to.
41:03 - The interesting thing here, the
slightly more complicated thing
41:06 - is when we press P, we want
to show a dialog that says,
41:10 - and I'll demonstrate this,
we want to show a dialog just
41:13 - like this one that says, we press P,
your Pokemon has been healed, right?
41:18 - Now I can't move.
41:19 - I'm pressing the arrow keys.
41:20 - I can't move my character at
all, because this dialog state--
41:23 - we're in a new state, well, we've
pushed a new state onto the state stack.
41:28 - And that's the dialog state
here, which has taken a value.
41:32 - And because it's the top layer of
the stack, it can't get updated,
41:37 - or it's being updated, and we
can't update the play state, right,
41:40 - based on how we've modeled our state
stacks operation, or how it works.
41:44 - And then as soon as I press
Enter, it gets popped off,
41:47 - we've just popped it off.
41:49 - Now the place states at
the top, I can move again.
41:51 - So that's what's going on.
41:52 - So the dialog state then is actually
very similar in a sense, to the fade
42:02 - in and fade out state in that, notice
that it takes an anonymous function.
42:06 - When does this anonymous
function get called?
42:09 - Do we know?
42:12 - At the end of what?
42:16 - AUDIENCE: [INAUDIBLE]
42:18 - SPEAKER 1: Yeah, well, when the
user closes the dialog box, correct.
42:24 - So let's take a look at
the dialog state then.
42:27 - And we can see, it's actually
pretty simple, it's pretty small.
42:32 - We have a text that it
takes and a callback, right?
42:36 - The text is used here.
42:39 - We instantiate, and this we'll see in
detail when we start looking at GUIs,
42:42 - and all the widgets
they've implemented here.
42:45 - This text box gets put at a hard coded
position, and it receives this text.
42:52 - And then we set our self.callback
to that callback function.
42:56 - If we have closed the
text box, meaning, we're
43:00 - looking to see at
self.textbox.isClosed, which
43:03 - is a function of the text box class.
43:07 - If it's closed, then execute
self.callback, and then pop
43:12 - this dialog state of the stack, right?
43:15 - So it's similar in a sense,
to the fade in and fade out,
43:19 - and then it takes anonymous function.
43:21 - The only difference is
in how it gets executed.
43:23 - With the fade in state,
the anonymous function
43:25 - was called at the end of
the finish function, which
43:28 - is part of the tween object.
43:30 - In this case, we're executing the
callback function explicitly when
43:33 - we've closed the text box.
43:35 - So we're waiting for user input versus
waiting for some asynchronous operation
43:40 - to finish.
43:42 - And then of course, we
call text box render,
43:45 - and then we'll see all of these methods
shortly as part of these widgets,
43:49 - but at a glance, this is all that's
really happening with the dialog state.
43:52 - Very simple, using the
same pattern that we've
43:55 - seen of deferring future
behavior to anonymous functions.
44:01 - Any questions as to how this
works, or anything so far?
44:07 - Cool.
44:09 - All right, let's take a
look back at the play state,
44:11 - I believe we're getting close to
being finished with the play state.
44:14 - Yes, so everything, that's basically
what the play state is in this game.
44:18 - And then a lot of what's going on
takes place in a level as well.
44:22 - So in a nutshell, we have
two maps, two layers, right,
44:29 - because the grass in the tile sheet
is its own sort of [? alphaed ?]
44:32 - out object, it's got
transparency around it.
44:36 - We keep a layer of the base, a
layer of the grass underneath,
44:40 - and then a separate
layer for the tall grass.
44:43 - And then we can just
look and to see when
44:45 - we're walking in the player walk state
when we've walked over tall grass.
44:51 - And then what do we need to do
to start a random encounter?
45:01 - Yes?
45:01 - AUDIENCE: [INAUDIBLE]
45:04 - SPEAKER 1: Yes, how do
we initiated though?
45:07 - That what are we looking for?
45:08 - We do push a battle state as
soon as we've triggered one,
45:11 - but how do we trigger one?
45:12 - What are we looking for?
45:13 - AUDIENCE: [INAUDIBLE]
player is in the grass.
45:17 - I don't know if it's on
moving to a new grass,
45:20 - or if it's time spent in the grass.
45:22 - Yeah, we do a random chance
whenever the players on grass.
45:25 - And it's whenever they start to walk
and there on grass in this case.
45:29 - But you can do it either
way, you can do it
45:31 - when they're leaving the
grass, walking into the grass.
45:33 - In this case, it's whenever
you press the button,
45:35 - and they happen to be on grass,
it'll do a random chance, one in 10.
45:38 - And if it's equal to 1, 10%
chance it'll trigger an encounter.
45:43 - So that's the gist behind
triggering a random encounter,
45:46 - and a lot of these games really--
45:48 - some games do it differently.
45:49 - They'll sometimes make it more
likely the more steps you've taken,
45:52 - they'll like sort of keep a counter
to say, oh, I've taken 100 steps,
45:55 - it should be a lot more likely now.
45:57 - Some games will just be completely
random, 1 in 10, 1 in 5,
46:01 - depending on how the developers
decided to implement their game.
46:05 - The former is a bit more robust.
46:08 - But for simplicity, we just
chose, math.random10 equals 1.
46:14 - So yeah, we create the tile maps
here, pretty straightforward.
46:19 - And then the actual random encountering
takes place in the player walk state.
46:26 - So here we have check for encounter.
46:29 - And so what this does is whenever
we enter the walk state, which
46:33 - is we press the button
to enter, or to walk,
46:37 - this entire function
gets called, because we
46:40 - do the transition to the player
walk state in the state machine.
46:43 - All of the entities are still
using just a regular state machine
46:45 - not a state stack.
46:46 - Wasn't necessary for this
demonstration, though I'm sure
46:49 - there are some used cases for
using a state stack for an entity.
46:52 - In this case, we're just
using a regular state machine.
46:55 - So when we change to the walk state,
we are calling enter as we've seen.
46:59 - And then we call self,
checkForEncounter.
47:02 - And so self, checkForEncounter
will set a flag
47:07 - if we have not started an encounter
basically and will allow us to move.
47:14 - And if we have checked
for an encounter, it will,
47:17 - or if we have triggered an encounter,
it will push in checkForEncounter,
47:21 - it'll actually push a
battle state onto the stack.
47:26 - So checkForEncounter just
basically does what we said before.
47:30 - If the grass layer,
because we have two layers,
47:34 - right, we have the base
layer and the grass layer.
47:37 - So if the layer at yx where yx
is are entities map x and map y.
47:43 - If the ID of that is
equal to tall grass,
47:46 - and we have just a global
constant table called
47:50 - Tile IDs, which has all these IDs.
47:52 - And math.random10 is equal to 1,
OK, change the entity state to idle,
47:57 - so don't let them keep walking.
48:00 - Pause the field music
rather than stopping,
48:02 - so that way when we come back to
the field later and we press play,
48:06 - it will be at the exact
point that it was before.
48:09 - Triggered the battle music, and then,
we've seen this already, fade in state,
48:14 - push to the stack, right?
48:16 - So over one second, we're
going to fade to white.
48:19 - So this will have the effect
of the music starting,
48:22 - but we're fading to
white right away, which
48:23 - is very sort of similar
to how most RPGs do it.
48:27 - And then we have our
callback function, which
48:29 - will execute as soon as the
fade in state's done, right?
48:32 - In this case, push to battle state.
48:35 - Battle state takes an
entity, and the entity
48:37 - has all of our Pokemon
information, that's
48:39 - why we're passing that
into the battle state.
48:41 - So the battle state can say,
oh, what Pokemon do you have?
48:44 - OK, I'll be able to look at your
party and say, OK, your first Pokemon
48:49 - is this, send him out to
battle, et cetera, right?
48:52 - And then lastly, push a
fade out state, right,
48:56 - because now we've got the battle
state on top of the play state,
49:02 - but we want to fade into it, right?
49:05 - So we're going to fade, we're going
to put the battle state first,
49:08 - and then because we're
using a stack, we're
49:10 - going to put the fate out state on top
of that, and then fade out to that,
49:14 - pop that off the stack.
49:15 - And then we have our battle
state that we just pushed, right?
49:19 - And then self.encounterFound
get's set here.
49:21 - And that's creating an
encounter, checking randomly,
49:25 - pushing the right things
under the stack, battle state,
49:27 - fade state, fade in, fade out.
49:30 - And then you're set to go.
49:32 - So that's effectively what the--
49:35 - it's known in RPGs as the field
versus the battle or encounter state.
49:41 - Even though we're calling it play
state here, we've left the field,
49:44 - we've gone into the
battle at this point.
49:46 - And so now we've seen
basically everything
49:48 - that the field has to offer us.
49:51 - And we've covered everything
that's relevant there.
49:54 - So we're going to take a break
now for five to 10 minutes,
49:59 - and then when we get
back from the break,
50:01 - we'll talk about GUI
elements, panels, text boxes,
50:04 - and then we'll dive into the sort
of mechanics of the battle state.
50:09 - All right, welcome back
to lecture 7, Pokemon.
50:12 - So before the break, we
talked about the play state,
50:14 - we talked about the states
stack more importantly,
50:17 - and then we talked about how
a anonymous functions are
50:20 - sort of the backbone to how we
get a lot of this asynchronous
50:25 - and deferred behavior for our
game, which is very common in RPGs,
50:29 - and I mean, a lot of genres, a lot
of complicated genres of this sort.
50:34 - Another big key part of games
like this are the graphical user
50:39 - interfaces, or GUIs as
they're shortened to.
50:42 - Things like panels on the
screen, things like labels--
50:46 - text labels that move around, things
like lists, text boxes, scroll bars,
50:53 - and you can get a lot crazier with it.
50:56 - In this particular lecture, we'll be
talking mostly about panels, labels,
51:03 - text boxes, and scroll bars--
51:05 - progress bars rather, not scroll bars.
51:08 - But the sort of the
first I think corner--
51:12 - or the first sort of
like keystone GUI widget
51:17 - that we should take into
consideration is the panel.
51:21 - So a panel is [INAUDIBLE].
51:33 - So if we look at this in a game--
51:41 - just pretend this is a panel I guess.
51:44 - So this is effectively
all a panel is, right?
51:47 - It's just sort of a rectangle.
51:49 - It allows us to-- if you're
looking at most user interfaces,
51:54 - like text boxes on your screen,
or if you're on Facebook
51:56 - and you're looking at almost
anything, like your little message
52:00 - window, a lot of those things at
the very core, the very bottom,
52:03 - the foundational part is just a panel.
52:05 - So any guesses to how in Love2D,
we can make a simple panel?
52:11 - AUDIENCE: Two rectangles
of different colors.
52:12 - SPEAKER 1: Two rectangles
of different colors,
52:14 - that's exactly what we end up doing.
52:16 - So that's effectively
how we can make a panel.
52:18 - There's another way of making a panel,
which we won't do in this lecture,
52:24 - but it's called--
52:26 - we use as a construct
called a nine patch.
52:30 - So a nine patch is--
52:37 - imagine taking this little image
here, and it's of some arbitrary size,
52:41 - but it's very small.
52:42 - And this is very similar
to how a lot of games
52:44 - implemented their panels
or their graphical user
52:48 - interfaces back in the 80s and 90s, I
mean, to a lot of games till this day.
52:52 - But back when hardware was
fundamentally tile based,
52:58 - you could take a image like this,
split it up into nine pieces--
53:06 - nine patch is where the
terminology comes from.
53:11 - And sort of similar to how we actually
constructed the Zelda dungeon, recall,
53:15 - where you have corner pieces, and then
a top, bottom, right, and left side.
53:20 - You just layer this,
one of each of these,
53:24 - first off, right, of the corner pieces.
53:28 - And then however many you
need of these on the sides
53:33 - to create this rectangle, right?
53:36 - So imagine we've created--
53:39 - these are all, if we can visualize
these as being a bunch of tiles, right?
53:52 - So just imagine that we've
taken these corner pieces,
53:55 - these are the corner pieces,
we've taken one of each of those.
53:58 - And then we take these side pieces,
and we just like draw a bunch of them
54:02 - like that.
54:04 - And then we take this
centerpiece, and then we
54:06 - can either layer it, or tile it a
bunch of times, or just stretch it.
54:11 - And stretching it has a bunch of nice
bonuses associated with it depending
54:15 - on how you've set your filter mode,
love.graphics.setdefaultfilter,
54:18 - if you set it to
bilinear versus nearest,
54:21 - you can actually get a nice gradient.
54:23 - And if you set it to nearest,
you get a nice pixelated look.
54:26 - But you'll see this often, and
Unity has nice support for this.
54:29 - Take an image that has maybe
more complicated than you could
54:32 - get with just two rectangles, right?
54:34 - Something that actually has a design
and maybe a gradient color, and actually
54:37 - layer--
54:40 - I mean, create a arbitrarily
sized text box to fit your needs.
54:46 - And if these aren't even increments
or whatever your tile size
54:49 - is on your 9 patch, you could just scale
the top, bottom, left, and right side
54:53 - as well just to keep it
scaled, the centerpiece.
54:56 - So does that makes sense.
54:58 - So this is common, we won't
be using that in our lecture,
55:01 - but it's a very, very common piece to a
lot of graphical user interface design.
55:06 - In a lot of games, you'll see it a lot
if you get more into game development,
55:09 - so it's definitely worth talking about.
55:12 - Another piece that we'll be talking
about today is the text box.
55:17 - So I mean, what's a guess
as to what the text box,
55:20 - how we can implement a text box, and
how we will implement a text box?
55:27 - So what foundational
piece can we start with?
55:33 - We already have-- yeah?
55:35 - AUDIENCE: You just
put use the love print
55:37 - to the screen over one of those boxes.
55:40 - SPEAKER 1: So use the love print to the
screen over one of the boxes, exactly.
55:43 - Yep.
55:44 - So maintain a list of
text items, right, text.
55:49 - And then just draw them inside
a panel, and there's a text box.
55:57 - You've taken two ideas, and
sort of mix them together.
56:00 - A selection is kind of the same thing.
56:03 - It's a the only difference
being that with a selection--
56:07 - so a selection is another
thing if we think about,
56:10 - for example a menu where we
have fight, and like run,
56:15 - and it may be in a more fleshed out
game, we have like an item thing,
56:20 - right?
56:21 - So that's a menu effectively.
56:25 - It is very similar to what
we get with a text box,
56:28 - but it's got a set of ingredients
here, fight, item, run,
56:32 - which they aren't set to wrap, they're
not one like contiguous set of text.
56:40 - It's just a bunch of items.
56:42 - And then nice thing about
a selection is that you can
56:45 - have a cursor on your selection, right?
56:49 - And then what do we need to
associate with like, for example,
56:53 - if we want this to
actually do something,
56:54 - and if we think about what
we've been doing so far,
56:57 - how do we go about
implementing functionality
56:59 - with a selection like this?
57:00 - Like what needs to get associated with
each of those entries in our selection?
57:08 - Callback function, right?
57:09 - Just as we've done with everything else.
57:11 - If you have a fight item here, each
of these, if we think of the selection
57:15 - as being just this part
of what we're looking at,
57:19 - right, because this background part is
just a panel, we don't care about that.
57:22 - We care about the
selection at the moment.
57:24 - The selection is the items
and the arrow, right?
57:27 - When as we'll see in the
assignment, your goal will actually
57:30 - be to take selection and get
rid of the arrow functionality,
57:33 - because for the
assignment, you don't need
57:36 - or want to have a selection
active, a cursor active.
57:40 - You just want a list of things.
57:43 - But based on what the cursor is pointing
at and when we press Enter or whatnot,
57:52 - we should index into
the selection, and then
57:55 - execute a callback that's
associated with each of these items.
57:59 - And that's how we can get
behavior out of the selection,
58:02 - rather than just being a list of
things that we render to the screen.
58:05 - If we have fight, and we
click Enter, a callback
58:08 - is set to maybe push a
state onto the stack that
58:12 - will trigger an interaction between
the two entities on the screen, right?
58:15 - The first one will
attack the second one,
58:17 - the second one will
attack the first one.
58:18 - And that's sort of its own asynchronous
set of states that do its own thing,
58:21 - but it's kicked off via
an anonymous function
58:24 - that we've associated with
each of these things, right?
58:27 - An item pushes another state, which is
like an item mini state, where then you
58:32 - open up a brand new set of menus that
you can look through all your items,
58:36 - and each of those items has a
callback associated with it, right?
58:40 - Your potion has a callback
associated with it
58:42 - that says, when I click on
this, either by default,
58:45 - just restore the HP
of my active Pokemon,
58:48 - or let me choose who to restore.
58:50 - So therefore, push another state,
which is like a select Pokemon
58:53 - screen with its own set of callbacks
associated with each of those.
58:58 - It's just in order to get all of
this sort of complicated behavior
59:01 - that you need to, it's really
ultimately just pushing states
59:04 - and adding callback functions to
all of these different options
59:07 - that you can select.
59:09 - And then run, push a fade
state, and then pop this state,
59:13 - and then push a fade out state.
59:14 - And that's really all we're doing.
59:16 - And so this look at all
of these GUI widgets
59:20 - here is just sort of a conceptual look,
but we'll take a look very shortly
59:24 - at some actual implementation.
59:25 - The last one that I want to
look at is the progress bar.
59:34 - So a progress bar for
example, the HP that we've
59:37 - seen in the actual battle where when
we take damage, it goes from right to
59:45 - left.
59:46 - Any guesses as to how we've
implemented a progress bar?
59:48 - Yes, Tony?
59:48 - AUDIENCE: Once again, two rectangles.
59:50 - SPEAKER 1: Two rectangles, yes, exactly.
59:52 - One, and then the nice thing
about rectangles in Love2D
59:55 - is you can set the edges on
them to be rounded or not
60:00 - via an optional parameter.
60:02 - So without anything more
complicated than a rectangle
60:05 - we can just create these sort
of almost ellipsoid progress
60:09 - bars, very simple progress bars.
60:11 - Ones the red, right, the
red that's the background.
60:14 - And then ones the outline, the black.
60:15 - And one is set to fill
with the first parameter,
60:18 - one's set to line with
the first parameter.
60:21 - Now how do we go about
animating whether or not,
60:24 - how do we animate the decreasing
amount of health when we take damage?
60:29 - Yes?
60:29 - AUDIENCE: Between the width.
60:31 - SPEAKER 1: Between the width, exactly.
60:33 - And what are we tweening it by?
60:34 - How are we tweening it?
60:36 - How would we calculate how
much we need to tween it?
60:38 - AUDIENCE: Well, you could just have
your width equal your health remaining.
60:44 - SPEAKER 1: If your width is set
to equal your health remaining,
60:47 - then your health is maybe 10.
60:49 - And you want your health
bar to be like 100 pixels
60:52 - long, how is that going to work though?
60:54 - AUDIENCE: Multiply it.
60:55 - SPEAKER 1: You could
multiply it, but if you
60:57 - know the width that you want
your progress bar to be,
61:01 - you can just multiply the
width by the ratio of the max
61:05 - value of your HP, or sorry, the ratio
of your current HP over your max HP,
61:12 - right?
61:12 - So if you're missing-- if you have
50 HP, and you're missing 5 HP,
61:16 - your ratio is 45 over 50.
61:18 - And if you multiply that by your width,
you get the exact amount of width
61:22 - that you need regardless of how
wide you want the bar to be,
61:26 - if you want to be 1,000 pixels,
if you want it to be 50 pixels,
61:29 - as long as you multiply current health
over max health times the width,
61:35 - you'll get that ratio no matter what.
61:37 - Does that makes sense?
61:38 - Cool.
61:39 - So that's a look at all the GUI widgets
that we're looking at, how they sort
61:43 - relate to what we're doing.
61:46 - We'll take a look at
their implementation here.
61:48 - So I'm going to go ahead
and open up the panel.
61:51 - And I'm going to move
a little bit quickly
61:52 - so we can get into sort of
the meat of the battle here.
61:57 - The panel is as we've said before
just two rectangles, right?
62:03 - It takes in an xy within a height.
62:06 - And then we would just
draw two rectangles.
62:08 - One is larger than the other.
62:09 - The bottom rectangle is slightly
larger than the top rectangle.
62:12 - So the first rectangle gets
drawn and it's whitish.
62:16 - And then-- oh, I'm
sorry, sorry about that.
62:21 - We have a xy within a height.
62:23 - And then we're drawing two
rectangles to the screen.
62:26 - We have the background
rectangle, which is drawn first,
62:29 - which is going to be the full xy
width and height of the panel.
62:32 - And then we're going to draw that
at a white color, and then draw--
62:36 - in the context of this game-- we're
drawing everything at the same color,
62:39 - but we can change the color.
62:40 - If we wanted to parameterize
it, we could do that.
62:42 - We could set, we could have a color
option here in the constructor.
62:46 - We're not doing that, we're just
drawing everything the same color.
62:49 - But that's how you would
get like customized menus,
62:51 - some RPGs let you do that.
62:54 - And then what we're doing here is we're
just within a small slightly smaller
62:57 - boundary.
62:58 - So just two pixels
smaller on the x and y.
63:02 - Where you are going to
draw the second rectangle,
63:04 - which is a kind of dark shade of gray.
63:06 - And that is a panel,
that is all panel is.
63:09 - And then we could just
have a function called
63:11 - toggle, which sets it to
visible or not visible.
63:14 - And if it's visible, get rid of it,
or if it's visible, sorry, draw it.
63:19 - Otherwise, don't draw anything
when it gets rendered.
63:21 - So that's a panel in a nutshell.
63:23 - Any questions?
63:26 - Cool.
63:26 - So the next thing that we
should look at is the text box.
63:32 - So a text box--
63:33 - so the text box is a little bit
more complicated than a panel.
63:37 - A text box in a nutshell needs to
take in some arbitrary body of text,
63:41 - and it needs to chop it up based
on how wide your text box is.
63:45 - And if it surpasses the
height of your text box,
63:49 - right, ideally, you should page your
text so that you can press Space bar,
63:54 - Enter and go through pages of text
until you've exhausted all of your text.
64:00 - And you press Enter one last time,
and you get rid of that text box.
64:06 - And so we have a panel here, which
we have an xy width and height
64:11 - in our constructor for the text box.
64:12 - And we have our text as well.
64:14 - And then we have a font if
we want to explicitly decide
64:16 - what font we want to use.
64:19 - In this case, or at
large, we're going to say
64:25 - that we instantiate a panel at xy
width and height, nothing too fancy.
64:30 - And then the fancyish part, the
slightly more complicated part
64:35 - is here on line 20
where we say, underscore
64:38 - self.textChucks gets self.font,
getWrap, self.text, self.width minus 12.
64:46 - So anybody know what this function
does or want to take a guess?
64:55 - Yes?
64:55 - AUDIENCE: Is that the page
thing you were talking about?
64:58 - SPEAKER 1: Exactly, it's
the paging of the text.
65:01 - Is the chunking of the text rather.
65:02 - Not the paging of the text, so much
as is the chunking of the text, which
65:07 - we will use to page the text.
65:08 - So we take some you know
arbitrarily large body of text,
65:12 - it can be as large as we
want it to be, and given--
65:16 - this is actually a function
of to Love2D font object.
65:20 - So this is given to us from Love2D.
65:23 - Get wrap will return two
values, the second of which
65:26 - is all of the pieces of text that
the main big body is divided into
65:32 - based on the width.
65:33 - So this self.width of
minus 12, that's how wide
65:37 - it's going to divide our
text into chunks of up to,
65:39 - it could be slightly smaller
than, because it divides it
65:42 - based on the word.
65:44 - But no piece of text will ever
exceed self.width minus 12 width.
65:51 - And this will allow us to then render
several lines of text within our text
65:57 - box, and they will never
exceed the boundary, right?
66:01 - And so the paging functionality
is actually in next chunks.
66:05 - So we call self next here at
the end of [? knitt ?] function.
66:09 - And then self next basically checks to
see, OK, are we at the end of the text?
66:13 - If we are, then we're not
going to display any text,
66:16 - and we're going to close the window.
66:18 - We're going to close the panel.
66:20 - But if we are not at the end of the
text, like we still get text left,
66:24 - what we want to do is new table.
66:26 - And then we're going to,
up to three iterations,
66:30 - we keep track of where we
are in our chunks, right?
66:33 - We get self.text chunks equal
to all of those chunks, right.
66:36 - And that could be an arbitrary number.
66:38 - It can be only one chunk, there
could be like 30 chunks, right?
66:41 - We need a counter to
keep track of where we
66:43 - are in terms of like based
on what page we're on, right,
66:47 - and however many lines we
rendered to the screen thus far.
66:51 - So starting at I, and
I get's chunk counter,
66:55 - and chunk counter will
get incremented by three
66:57 - every time we call next
chunks, which is every page.
67:00 - We could have easily just
called this next page as well.
67:04 - It's going to insert
into that chunks table
67:05 - that we just created,
self.textChucks at i.
67:08 - And once we've reached
the number of chunks total
67:12 - that we returned from get wrap,
we're going to flag end of text
67:16 - as being true, and then
we're going to return it.
67:19 - And so what this will
do is, eventually, we're
67:22 - going to be equal to the number of
chunks that we got from font get wrap,
67:26 - right?
67:28 - And once we are, that
will signal with next
67:31 - that it's time to close the
text box, because end of text
67:34 - will have been set to true at the
end of that last chunking process.
67:38 - And then we can see here,
when we update text box,
67:41 - and that whenever it's
on the top of the stack,
67:43 - remember, we're looking for
a Space or an Enter press,
67:47 - and then we just call self next.
67:48 - And that will have the effect of
eventually closing our text box.
67:53 - And then is closed recall, we
looked at that earlier, we checked
67:56 - to see it is the text box closed?
67:59 - And that's just a flag that we set here.
68:01 - And then for rendering purposes,
we render the panel first.
68:06 - And then for each of our displaying
chunks, so we only have up to three
68:10 - displaying chunks at one time, which
gets set by the next chunks function.
68:16 - We just print that to the screen
using i as a multiplier on our y.
68:22 - And so that will render up two or
three lines, i, i plus 1, i plus 2.
68:29 - Any questions as to
how the text box works?
68:34 - It's a little more work
than the panel for sure,
68:36 - but it's fairly straightforward.
68:38 - We're just keeping a list
of a bunch of text things,
68:40 - and then we're just chunking
them based on how wide the text
68:46 - box is, the dimensions thereof.
68:50 - And then let's take one
look at this selection.
68:53 - So a selection is basically, a list
of text items with a cursor, right?
69:01 - And as I said before when we were
looking at the screen over there,
69:04 - each of those text items has a
text value and a callback function.
69:08 - And the callback function
is what allows us
69:10 - to assign behavior to this selection
object beyond just displaying things,
69:16 - right?
69:16 - Because when you have a menu,
when you have a selection
69:18 - and you select something, you
want behavior to happen, right?
69:22 - So each of these items indef.items will
expect to have a callback function.
69:29 - And then here, when we update
the selection, what we're doing
69:32 - is we're updating whatever our
current selection is, which is just
69:35 - a number between 1 and the number of
items in that selection making sure
69:38 - that if we're at one and we go minus
one, that we go back to the bottom.
69:42 - And if we're at the bottom
when we press, and we go up,
69:45 - we go back to the top.
69:47 - And we play sounds,
cutesy, things like that.
69:51 - And then for each--
69:52 - and for our selection here,
from one to number of items,
69:56 - we calculate how much
padding that we need.
69:58 - And we draw the cursor
at our current selection,
70:01 - and then we draw each item based
on i and whatever our gap width is
70:06 - of our panel, which we assign it to.
70:08 - So we divide our panel up,
and then basically just
70:11 - keep track of where
current y is and draw
70:14 - the actual selection
and the cursor if that's
70:17 - the current selection to the screen.
70:21 - Any questions as to how a
selection sort of works?
70:29 - Notice here, if we press Return,
if our selection is being updated,
70:35 - self.items at
self.currentSelection.onSelect.
70:40 - So it's expected that that item will
have an onSelect function, which
70:44 - is that callback function.
70:47 - OK, and lastly, we'll
take a look at the menu.
70:50 - And then we'll finally
take a look at the battle,
70:52 - which is where sort of everything kind
of comes together with all of this.
70:55 - And that'll be it.
70:56 - And then we'll talk
about the assignment.
70:59 - So the menu is a panel
and a selection together.
71:01 - That's the gist behind what
a menu is in this game.
71:05 - You can define a menu
to be a lot of things,
71:07 - and you can get a lot more complicated
with a menu, but in this example,
71:11 - in this implementation, we're
just saying a menu is a selection
71:15 - and a panel put together as one item.
71:17 - And we've seen it in the game,
[? if we're ?] going to run it.
71:24 - That's just a text box.
71:26 - Going to look for a battle.
71:32 - OK, so here's a battle.
71:33 - That's just an empty panel
at the bottom, regular panel,
71:35 - but now it's a text box.
71:36 - We push the text box onto the stack.
71:38 - Push another text box onto the stack.
71:40 - And so this is a menu right here.
71:42 - Notice that there is
a cursor and there's
71:45 - a selection embedded within a panel.
71:47 - And each of those items,
the fight and the run,
71:50 - those have a callback
associated with them.
71:54 - The purpose of the fight callback
is to trigger a new state
71:56 - where the two Pokemon asynchronously
attack each other, in chain behavior
72:02 - one after the other.
72:03 - And then run pushes a dialogue,
then pushes a fade state,
72:07 - then pops both of them, and
then pushes a fade out state
72:11 - and puts us back to the play state.
72:13 - So that's effectively
what's going on and that's
72:15 - an example of what the menu looked like.
72:18 - And so a menu, just a selection
with a panel put together.
72:21 - When we draw the menu, we draw
the panel and then the selection.
72:26 - And then when we update the menu,
we only update the selection,
72:29 - because that's all we care about.
72:32 - And that's basically it.
72:34 - And so the menu itself
will get a def, that def
72:37 - should have items, that items
will get passed to the selection.
72:44 - That's pretty much, that's it for the--
72:46 - oh, progress bar as well.
72:47 - We'll look at progress bars when
we get to the actual battle state.
72:51 - So now, let's take a look at a few
of the classes and data structures
72:55 - that are pertinent to
the Pokemon themselves.
72:57 - So if you look at party
as are first class, very
73:00 - simple class, literally just this--
73:03 - self.pokemon is def.pokemon is
just a container at this point.
73:07 - You can take this--
73:09 - I mean, even in I think
a fully fleshed game,
73:12 - you wouldn't really need
much more than just this.
73:15 - But if you needed to expand
upon this idea at all
73:18 - and you know preserve metadata
that exists for the party,
73:21 - this would be a perfect way to do it.
73:24 - The actual pokemon class itself is
not a whole lot more than effectively
73:31 - a bunch of stats.
73:33 - And that's a lot of what an RPG is.
73:36 - This genre is-- it's
mostly just numbers.
73:38 - You're just comparing
numbers against numbers
73:40 - and then adding a roll of the dice.
73:42 - That's effectively, that's what
Dungeons & Dragons, a lot of it is.
73:46 - And that's-- yes?
73:47 - AUDIENCE: Would it make
more sense to store
73:49 - just delta per level and your initial
one, so you can have fewer variables?
73:57 - SPEAKER 1: Say it one more time.
73:58 - AUDIENCE: Wouldn't it
make more sense, instead
74:00 - of storing your HP and
everything for each level
74:03 - to store your initial
stats in each area,
74:06 - and how much you would go up per level.
74:09 - SPEAKER 1: Would it make more sense
to store the amount that you go up
74:14 - per level for your Pokemon?
74:16 - Yes, that is what we're doing.
74:19 - So we have a base--
74:20 - so here's how the split works for
the stats in this case, right?
74:24 - We have base HP, base attack,
base defense, and base speed.
74:28 - A level 1 Pokemon
has-- a level 0 Pokemon
74:31 - has these stats of this species, right?
74:35 - Every Bamboon or whatever
Pokemon that we choose
74:39 - will have whatever we've
allocated it to be it's base HP,
74:42 - base, attack, base defense, base speed.
74:45 - And then the thing about Pokemon
and I mean, a lot of RPGs
74:50 - will sort of do this
thing, but we need some way
74:52 - of leveling up the Pokemon in an
necessarily non-deterministic way.
74:58 - Like two Piggies that level up may
not have the same stats, right?
75:02 - One might have slightly
higher attack than the other,
75:04 - one might have slightly
higher defense than the other.
75:07 - We do this using what's called an IV,
and that's what Pokemon itself does.
75:11 - And it's short for individual
value, this is sort of
75:13 - like the DNA of your Pokemon, right?
75:16 - So this HP IV is separate from your
base attack, base speed, base et cetera.
75:23 - And this basically, it gets compared
against a dice roll every time
75:26 - you level up three times.
75:31 - And this is how I've programmed
it, it's not necessarily
75:34 - how Pokemon itself does it, but
you will roll a dice six times,
75:38 - or three times, one through
six like a normal die.
75:42 - And you'll look to see if that roll
is greater than your IV, right?
75:49 - Or it'll check to see whether your IV
is less than or equal to that dice roll.
75:55 - And if it is--
75:57 - or sorry, if it's greater than
or equal to that dice roll.
76:00 - And if it is, it will increment that
stat by 1 for those three dice rolls.
76:06 - So you can get up to three more,
or you can increase the stat
76:11 - by up to three times per level.
76:14 - But you can only have an IV up to five.
76:16 - So you're rolling against a six, and
you will occasionally not roll a 6.
76:23 - It checks to see
whether or not the IV is
76:27 - greater than or equal to the dice roll.
76:29 - And if it's not greater than or
equal to the dice roll in the event
76:32 - that it is a six, or if
the IV is up to a four
76:36 - for example, which means a
five or six will go against it,
76:39 - then it will not get a stat increase.
76:41 - And this is a sort of simple way of
implementing this DNA based system.
76:44 - It's randomized, but
it's a weighted, right?
76:47 - If you have a higher IV,
you have a higher likelihood
76:50 - of being greater than or
equal to the dice roll.
76:53 - And so that's how we
implement stat increases.
76:55 - And then we need a way of keeping
track of what our stats are,
77:03 - like our actual stats.
77:04 - So our actual HP, our actual
attack, our actual defense,
77:07 - and actual speed that's been
calculated level by level,
77:10 - we need a way to keep track of that.
77:11 - We need level, we need
our current XP, and then
77:14 - we need our-- and the
amount of XP to gain
77:15 - a level, which will get higher and
higher per level, as you can see here,
77:19 - because it takes in the
self.level times self.level.
77:24 - And then it multiplies
that by five times 0.75.
77:28 - And then your current HP.
77:32 - So we're really not storing
our value level by level,
77:38 - we need the base because we
need to know what our base was.
77:42 - I mean, we could effectively
globally reference these variables,
77:46 - but it's minor efficiency
gains at that point.
77:49 - But we need the IVs and we need the--
77:52 - I mean, we need a reference to the IVs,
we need a reference to the base HP,
77:56 - and we need to keep track of
whatever our actual stats are,
78:01 - and then our current HP
always, because our current HP
78:04 - can differ from our actual HP.
78:07 - And in the actual game, you
can have your attack, defense,
78:10 - and speed also vary match
by match, because you
78:13 - have moves that lower your
speed, lower your attack,
78:17 - lower your defense, et cetera.
78:19 - In this case, we haven't
implemented that,
78:21 - so we don't have a current
attack, current defense.
78:23 - But in a more complete implementation,
you would have that sort of thing.
78:26 - Does that sort of answer your question?
78:28 - Is that in the right vain?
78:29 - OK.
78:32 - And so here's the level up code.
78:35 - So like I said, three
dice rolls, one to three.
78:38 - If six is less than or equal to our IV,
so it could be a six, in which case,
78:43 - it would be greater than what
are max IV could possibly be.
78:47 - IVs range from one to five, but if
it's less than or equal to that IV,
78:52 - then we're going to consider
that a stat increase.
78:54 - It's a weighted odd to determine
whether or not we get a stat boost.
79:03 - And it does this for every stat, and
then it returns all of the increases.
79:07 - And this is relevant, this line
95 for a return HP increase,
79:11 - return attack increase,
defense increase.
79:13 - This will be relevant for
assignment 7, because your goal is
79:16 - to take these increases and actually
display them to this user in the battle
79:20 - state when he gets a victory,
or he or she gets a victory
79:23 - and has gained a level.
79:25 - You will display a menu with a
selection that has all of these things,
79:29 - and you'll need this value.
79:30 - So it returns these values here, and
you'll be calling this function any way
79:36 - from your battle state stats level up.
79:39 - Or we'll be calling level up rather,
which returns self stats level up.
79:45 - And that's all a Pokemon is.
79:47 - It's effectively mostly
a data structure.
79:50 - And we use this in our battles to
throw dice effectively back and forth,
79:57 - and have a victor and a loser, and
then gain XP and gain levels that way.
80:05 - So any questions as to how a
Pokemon object class works?
80:12 - Cool.
80:13 - We'll take a quick look at what
the actual definitions look like,
80:16 - which you can probably take a guess.
80:18 - It's very simple, just key names.
80:20 - And then we have the actual
name, we have the sprite names,
80:24 - we have the HP, attack, defense--
80:26 - all the things that get
put into the actual object,
80:29 - they need a reference
to in the definitions.
80:31 - And so Pokemon ultimately
are just this, they're
80:34 - just data, right, which is what we
talked about in a prior lecture, data
80:37 - driven design.
80:38 - The more you can take
all of your Pokemon
80:40 - and make them into, or
anything, Pokemon or any object,
80:44 - and turn it into an easy to
write data structure like this,
80:47 - the easier it is for you to add more.
80:49 - We could easily add, it wouldn't
take too long to create 150 of these.
80:53 - I mean, they wouldn't
be all that interesting,
80:55 - because we don't have
moves implemented yet.
80:58 - But in an ideal world, we'd find
a way to also model moves as data,
81:03 - and therefore, you can just link
moves to your data structure,
81:07 - to your Pokemon object like this.
81:09 - Yes Tony, did you have a question?
81:10 - AUDIENCE: Well, I just wanted
to mention that the paradox
81:13 - games are very good about that.
81:15 - [INAUDIBLE]
81:16 - SPEAKER 1: Oh, like Crusader Kings?
81:18 - AUDIENCE: Yeah.
81:21 - SPEAKER 1: The comment was Paradox Games
are very good about data driven design.
81:25 - I'm assuming you've dug
through their files?
81:28 - AUDIENCE: To some extent,
and also it's just
81:30 - if you play their games for awhile,
it's everywhere, like to the extent
81:33 - that sometimes on the Wiki,
they put the source code up.
81:36 - SPEAKER 1: Oh, yeah.
81:37 - Yeah, no, it's just good game design.
81:40 - Ultimately, if you want to--
81:41 - and their games are large,
they have a lot of content.
81:44 - If you want to have a lot
of content in your game,
81:46 - you need to find a way to take
the burden off the programmer
81:49 - and put it onto the
designer, or at least make
81:51 - it easier for the programmer,
because making source code
81:53 - and debugging source code all day long,
especially for very complicated things
81:56 - is not easy.
81:57 - And it's ultimately not a
desired thing to do, right?
82:01 - It's a lot easier for me to whip up
a new creature in 10 lines of code
82:04 - here and feel good about it than hard
coding a lot of these sort of things,
82:10 - right?
82:11 - So shifting as much of it to data as you
possibly can should be your end goal.
82:17 - So that's what Pokemon defs look like.
82:19 - Before we get into the
actual battle, we want
82:21 - to take a look at what
a battle sprite is.
82:23 - So a battle sprite is what was
rendering onto the screen, right?
82:27 - So we take a look here.
82:29 - That's not a battle sprite,
but almost a battle sprite.
82:33 - That was just a texture.
82:35 - So if we get into a
battle, slowly but surely.
82:43 - All right, so these are battle sprites,
and they don't look much different
82:46 - than a regular sprite,
and they're not that much
82:48 - different than a regular sprite.
82:50 - But they have some functionality that's
important, mainly that functionality
82:55 - where one is flashing, and then
one was being opaque, right?
83:01 - So in order to do both of those things,
we need to store some sort of data
83:07 - within our sprite, right?
83:09 - Yes?
83:10 - AUDIENCE: Zelda for the
invulnerability flashing.
83:14 - SPEAKER 1: Yes, exactly.
83:15 - For what we used in Zelda for
the invulnerability flashing.
83:18 - For the enemy, or I should say, for
whoever is getting attacked, yes.
83:24 - They are getting an opacity flag stored.
83:28 - They have an opacity flag stored in
their object that we can tween, right,
83:32 - we can tween on and off
over the course of time.
83:34 - That's what we did with the entity
in Zelda when it took damage.
83:38 - And we set it to invulnerable,
and while it was invulnerable,
83:40 - it was flashing on and off.
83:42 - But we can't necessarily do that with
the sprite that's blinking white,
83:47 - because there's not really
a like white flag, right?
83:52 - We can't make something
completely white with just a flag.
83:55 - That's something that we actually
need to use a shader for.
83:59 - And so a shader, and we're not going
to get into too much detail about this,
84:03 - shaders are pretty complex,
a little arcane at first.
84:07 - But what they are is effectively
a little program that
84:10 - runs on your graphics card, and that
looks at when you're drawing something,
84:13 - it looks at every pixel depending
on what kind of shader you're doing.
84:16 - But for the sake of this demonstration,
we'll look at every pixel
84:19 - that you're drawing to the screen,
and perform some sort of function
84:23 - on that pixel, and produce
a new value, right?
84:27 - And this is how you get a lot of
really crazy awesome things to happen,
84:31 - but it can be pretty insane.
84:34 - Shader Toy, I think is the website
that has a ton of really cool--
84:39 - I'm not going to pull it up now, just
'cause I don't remember the name,
84:42 - I believe it's shader toy.
84:44 - There's a website where people post
all the shaders that they've written,
84:47 - and you can see a lot of
really crazy stuff, things
84:49 - that you would never imagined were
possible with just code like this
84:53 - effectively, looking
at positions of pixels
84:56 - and [? pictures ?] on
the screen and whatnot.
84:58 - But effectively what this does, this is
a white shader, the goal of this shader
85:05 - is to just turn a
sprite completely white.
85:07 - That's all the goal of this shader is.
85:10 - So it gets a float called white
factor, which [? you'd ?] say here.
85:14 - And then white factor
effectively is just
85:17 - going to be summed onto
whatever the RGB is
85:20 - of that pixel, whatever pixel that
we're drawing when the shader is active.
85:25 - What that has the effect of doing
is, white factor, if it's equal to 1.
85:29 - Here's the thing about shaders
and a lot of this stuff,
85:32 - a lot of the data
structures within shaders
85:35 - are based on floats that
are from zero to one.
85:37 - So if we assign the RGB of something
to a vec 3 that's 1, which is 111,
85:43 - that's going to be 255, 255, 255.
85:46 - Therefore, that pixels RGB
is white, pure white, right?
85:50 - And so what we're doing here is on
our battle sprite, self.blinking
85:58 - and one or zero, remember, that's
the LUA [? turnerri ?] operations.
86:01 - So we're saying, if self.blinking
is true, one else zero.
86:07 - So send our shader white factor based
on whatever value self.blinking is.
86:15 - And so that will have the effect of
the shader getting a one or a zero,
86:19 - and adding a one or a zero
to the RGB of that sprite.
86:22 - And if blinking is set
to true, the sprite's
86:25 - going to basically be drawn
every pixel at 255, 255, 255.
86:29 - Otherwise, it'll get drawn with
whatever that image's pixel value is
86:33 - at that position.
86:35 - Does that makes sense?
86:37 - OK.
86:37 - The syntax is a little
bit weird, but that's
86:39 - what's happening here in this shader.
86:42 - And there's a link here
where I found the shader,
86:44 - but it's a very simple,
very simple shader,
86:47 - probably like one of the
simplest shaders you could write.
86:50 - But it's a great example of what you
can do with a shader, and pretty simply.
86:55 - And it's nice, because you can take
like texture coordinates and do math
86:59 - based on that, or pixel coordinates
and do math based on that.
87:02 - You can pass in like a sine
function for example, in your file,
87:04 - and have that sine function perform work
on like RG or B value of your sprite
87:09 - and do all kinds of cool stuff.
87:10 - It's really neat, like the possibilities
are limitless with shaders.
87:14 - But that's how we get
it to blink, because you
87:16 - can't do that outside of this--
87:18 - I mean, there's probably some weird
way could get it to work as well,
87:21 - but this is probably the simplest way
we can get our sprites blinking white.
87:28 - And so self.blinking just gets
a timer.every0.1 or whatever.
87:36 - We'll actually see that
in the attack state.
87:41 - But that'll flick to self.blinking
between true and false.
87:45 - It'll negate itself over and over again.
87:49 - All right, so that's the battle sprite.
87:51 - Last thing we'll look at is another
extremely simple class, opponent.
87:56 - All the opponent is is it
has a party, that's it.
87:59 - But in a fully fleshed
game, your opponent
88:01 - might have a like trainer sprite.
88:03 - A message that it
says, like a full party
88:06 - of Pokemon, a gold value that
will give you when you defeat it,
88:08 - all kinds of things.
88:09 - But it's here just as
a simple illustration.
88:12 - Yeah?
88:12 - AUDIENCE: [INAUDIBLE] put
a method for on defeat
88:14 - if you want to maybe
have it kind of collapse
88:17 - the room or something like that.
88:19 - That would be another
thing that you could do.
88:21 - SPEAKER 1: Oh, a method?
88:22 - Yeah, we can associate a method
with an opponent called on defeat,
88:26 - or whatnot that will do arbitrary
things, collapse the room,
88:29 - or otherwise.
88:30 - Yes, absolutely.
88:31 - Or even push a new state,
like to like teleport
88:34 - us to a new location in the world map.
88:36 - Maybe we like cleared
the elite four and we
88:38 - want to get teleported to
like the end credits, exactly.
88:42 - Limitless possibility.
88:45 - So let's go ahead and take a look now
while we have just like 20 more minutes
88:48 - or so left.
88:49 - We'll take a look at the battle
state, because the battle
88:51 - state and the states that they're in
are probably the more complicated side
88:56 - of how this works.
88:59 - So a battle state, we have a player, we
have a bottom panel, the bottom panel
89:03 - for when we start the
state just for that part,
89:05 - but otherwise, we're always
pushing things onto it.
89:08 - Whether we've started the battle or
not, because when we are fading in--
89:14 - sorry, yeah.
89:16 - Because when we initialize this state,
we also push a fadeout state onto it.
89:28 - But we don't want to trigger
the tween of the Pokemon sliding
89:32 - from left to right until
after that state gets popped.
89:35 - So we have a flag here, which will get
set to true on the very first update
89:38 - iteration.
89:39 - And then when that
gets set to true, we'll
89:41 - actually tween the Pokemon
going left to right,
89:44 - and kick off all the other
sort of asynchronous processes
89:46 - that exist thereafter.
89:50 - But let's look at the battle one more
time just to see what's going on.
89:56 - So I'm going to walk
until I get into a battle.
89:58 - OK, we got a battle.
89:59 - So notice here, the fade
in happens as soon as the--
90:05 - the slide in happens as soon
as the fade starts, right,
90:08 - as soon as the fade
finishes, I should say.
90:10 - We get a message popped
onto the screen, right?
90:12 - It says a wild X appears.
90:14 - Right, that's the enemy Pokemon.
90:16 - We hit Enter.
90:17 - Turn this down a little bit.
90:19 - We hit Enter, and then we pop another--
90:21 - push another state onto the stack,
another battle message, which
90:24 - is very similar to a dialog state.
90:26 - Says go our Pokemon.
90:30 - And then we push a menu
onto the screen, right?
90:34 - We've got a menu that says,
fight or run, a selection.
90:37 - It's a menu, which has a selection.
90:39 - And then now, this is the
top of the stack, right?
90:42 - So it's the only thing getting input.
90:44 - Everything else is rendering beneath
it, but nothing's getting input.
90:48 - So we have the option
to either fight or run.
90:49 - Let's say we fight.
90:51 - We fight, we got a new state
now, we're in an attack state.
90:55 - Several things just happened.
90:57 - So what happens as soon as
we kick off the attack state?
91:01 - Yeah?
91:02 - AUDIENCE: You get a text
box saying, x attacked y.
91:04 - SPEAKER 1: Yep, so the
first thing we have happened
91:06 - is, a text box that
says, x attacked y, where
91:10 - it could be either us or
the opponent, because it's
91:12 - based on whoever has the higher speed.
91:14 - And then what happens next?
91:16 - AUDIENCE: [INAUDIBLE].
91:17 - SPEAKER 1: Well, it does.
91:19 - So let's take a look at
it right now and tell
91:21 - me what exactly happens as
soon as the text box pops up.
91:27 - So what were the pieces
that happened there?
91:30 - AUDIENCE: Flash.
91:31 - SPEAKER 1: OK, so the
attacker flashes white,
91:34 - right, which is the
shader that we looked at.
91:36 - That's the shader blinking on and off.
91:38 - There's some timer that says,
every 0.1 seconds, blink on or off.
91:41 - And then what happens?
91:43 - AUDIENCE: Then the damage
is dealt. [INAUDIBLE]..
91:46 - SPEAKER 1: Well, damage is dealt,
yes, but what happens visually as soon
91:50 - as the white blinks?
91:53 - AUDIENCE: The other one blinks.
91:54 - SPEAKER 1: The other one blinks.
91:56 - What's the other one blinking?
91:59 - AUDIENCE: I'm not sure.
92:00 - SPEAKER 1: So it's opacity, right?
92:02 - So remember, we're doing the exact
same thing we just did with that white,
92:05 - with the blinking, but we're
tweening every 0.1 seconds
92:08 - the opacity of the defending Pokemon.
92:11 - And then we take damage.
92:13 - Then what happens when we take damage?
92:15 - AUDIENCE: The reverse basically.
92:17 - SPEAKER 1: Well, what gets animated
when the thing takes damage?
92:20 - We've animated the blinking,
we've animated the opacity.
92:22 - AUDIENCE: [INAUDIBLE].
92:24 - SPEAKER 1: The health bar drops, right?
92:26 - So we're chaining
several things together.
92:28 - We're chaining-- first, we're doing
them every 0.1 seconds for six times,
92:32 - blink white.
92:34 - Then blink the other
thing opacity, right?
92:37 - And we're playing sound
effects at the same time too,
92:40 - we're playing a sound effect for the
attack, sound effect for the hit.
92:43 - And then once that's finished,
tween the health bar, right?
92:46 - So we've modified the health
of the defending Pokemon.
92:51 - And then what happens after the first
one, after that process is finished.
92:57 - AUDIENCE: Repeat for the other side?
92:59 - SPEAKER 1: Exactly, repeat the exact
same thing, but for the other side.
93:04 - But what are we doing in
between each of those?
93:06 - We have to do something.
93:07 - AUDIENCE: Checking if somebody dies.
93:08 - SPEAKER 1: Checking if
somebody dies, exactly.
93:10 - And if somebody dies--
93:12 - let's say we die, what happens?
93:14 - AUDIENCE: [INAUDIBLE].
93:16 - SPEAKER 1: Well, we yeah, we
go back to the play state.
93:19 - We fade out to black, and then
we go back to the play state.
93:22 - What happens if we knock out the enemy?
93:24 - AUDIENCE: Go to this screen.
93:25 - SPEAKER 1: Exactly, and
what happens on this screen?
93:28 - So what's the first thing that happens?
93:29 - Well, so recall, what happened
when the Pokemon died?
93:32 - What happened?
93:32 - AUDIENCE: It fell off
its platform thing.
93:34 - SPEAKER 1: Exactly, so that's a tween
probably, right, on his y value.
93:39 - Then what happens?
93:40 - AUDIENCE: [INAUDIBLE].
93:42 - SPEAKER 1: Exactly, we've pushed a
battle message state onto the screen.
93:46 - And then what happens
when we press Enter?
93:48 - AUDIENCE: [INAUDIBLE].
93:50 - SPEAKER 1: What just
happened right there?
93:52 - AUDIENCE: [INAUDIBLE]
text box that says,
93:53 - you earned whatever experience points.
93:55 - Then you get your XP goes up.
93:57 - And presumably, it
checks if you leveled up.
93:59 - SPEAKER 1: Yes, correct.
94:00 - AUDIENCE: [INAUDIBLE] to level up.
94:03 - SPEAKER 1: Exactly, so
when push a dialogue
94:05 - to the screen that says you've earned
x experience points, the XP bar tweens,
94:09 - right?
94:10 - We've gone up to however our ratio
of current XP to next level XP is.
94:15 - We animate our text bar that
way, or progress bar that way.
94:19 - Then we push a fade in
state, right, to white.
94:23 - And then we have to pop
everything off the stack,
94:27 - and then push a fade out
state to the top of the stack,
94:32 - and then we're back to the play state.
94:34 - But if we do level up, we need to play
the right music, play the right sound,
94:41 - and then part of the assignment will
be actually, in that exact function,
94:45 - you're going to need to add
some behavior that will do what?
94:48 - AUDIENCE: [INAUDIBLE]
display the change basically,
94:50 - and what the new one will be.
94:51 - SPEAKER 1: Yes, and what
are we going to need to do.
94:53 - What will we need to do in order to?
94:55 - AUDIENCE: [? Explain, ?]
what was it called?
94:57 - The selection box, but without
the selection part basically.
95:00 - SPEAKER 1: Yes, so once we've
taken-- once we've leveled up
95:03 - and we're in that victory state
of the battle state, right,
95:07 - we need to push a new state,
a new menu state, which
95:13 - has all of those stats and the
amount that they've increased.
95:17 - And then when we press
Enter, presumably, we
95:19 - should pop that off, and then pop
everything else back to the play state,
95:24 - and then do the fade in as normal.
95:26 - And that is the battle
state in a nutshell,
95:29 - a lot of pieces that sort of are waiting
on each other and input and stuff
95:32 - like that.
95:33 - But fairly easy to understand, just
because a lot of it is very simple
95:37 - things that are just chained
together over and over
95:40 - again to produce this sort
of interesting behavior.
95:45 - So here we have sprites,
recall the sprites are what
95:47 - we're going to need to animate those.
95:49 - We have health bars, which
are progress bars, which
95:52 - are just two rectangles that are--
95:55 - ones a line, a black line, and ones
a fill that fills beneath the line,
95:59 - so that we get a sense of
how much is missing, right?
96:06 - We get the width, the height, a color.
96:08 - We can give our progress
bar any color we want to,
96:10 - which is how we get the difference
between, say, a health bar and an XP
96:13 - bar.
96:14 - We just make one red and one blue, and
we draw them in different spots, right,
96:17 - but they're both equally progress bars.
96:20 - And then they get a value.
96:21 - Their value is whatever sort of
determines how much of the rectangle
96:28 - is scaled.
96:29 - And the max is how much that
should be divided by in order
96:33 - to produce a ratio for the total width--
96:36 - a scaler for the total
width, which will allow us
96:38 - to get the sense of an amount missing.
96:43 - And then a player circle
x, opponent circle
96:45 - x for the ellipses, just the graphical
details for the actual Pokemon,
96:51 - so that we can get their stats, so that
we can actually do dice rolls, or not
96:54 - really dice rolls in this case,
but so that we can add or subtract
96:58 - HP based on attack and defense.
97:03 - And so here was the update,
so trigger slide in.
97:06 - So what trigger slide in
does, is a one second tween,
97:09 - which you talked about, right?
97:10 - The Pokemon going left to right,
or left to right, right to left.
97:14 - There x values, just
tweening in over one second.
97:18 - As soon as that's finished, we're
going to trigger starting dialogue.
97:22 - So the starting dialogue is push a
battle message state onto the stack.
97:26 - The battle message state is just like a
dialogue state in that it gets a string
97:30 - here, so a wild something appears.
97:33 - It gets a callback function for
once we press Enter on that.
97:36 - And the callback function is itself
another push of a battle message state
97:41 - that says, go, and then our Pokemon.
97:43 - So notice that we're referencing the
self.opponent.party.pokemon there,
97:47 - and self.player.party.pokemon
there to get the actual name.
97:52 - And then once we've popped that off,
then we push a battle menu state here,
97:59 - right?
98:00 - So let's take a look at
the battle menu state.
98:02 - So this is interesting, because
this is where we actually define
98:06 - the behavior for our menu works, right?
98:08 - Recall, we need something to tells
us what happens when we press Fight,
98:12 - and what happens when we click Run.
98:13 - So when we click Fight,
notice here items,
98:16 - right, self.battlemenu gets
menu, and menu expects items.
98:20 - This items key, this table gets fed
right into the selection, right?
98:30 - And the selection, it
expects remember, a text,
98:33 - because it has to know what
to render at that index.
98:36 - And then an on select function.
98:37 - And that on select
function is the callback
98:39 - that gets executed when you press
Enter at that particular location
98:42 - in the menu.
98:43 - In this case, fight, what that does is
it pops this battle menu state where
98:48 - we no longer need the menu, so pop it.
98:51 - And then push a new take turn state.
98:54 - And then take turn state in this game is
the Pokemon fighting each other, that's
98:58 - what the take turn state is.
99:00 - And it could have been called
fight state, for example,
99:03 - but take turn state is
a little more versatile.
99:05 - If we wanted to maybe make,
maybe one Pokemon wants to run,
99:07 - the enemy wants to run and
we want to fight, right?
99:10 - But you can't always run,
so they should try to run,
99:13 - and then we can still fight them.
99:15 - Or they can use an item, or
we can use an item, right?
99:18 - There's a lot of different
things you can do.
99:20 - Or we want to throw a Poke
ball at them, and if we fail,
99:24 - then they should fight us, right?
99:25 - Take turn is just a
general purpose state
99:27 - that we could repurpose
for whatever use we
99:31 - want to with any interaction
between us and the opponent,
99:35 - whether it's fighting, running away,
or using items, catching them, any
99:38 - of these combinations of things.
99:39 - But in this case, for the sake
of this example, for simplicity,
99:43 - we've only implemented fighting.
99:44 - The we and the opponent fight each
other during this state, which
99:49 - is, one attacks the other,
and then we check for deaths
99:51 - in between both of those.
99:52 - And then go to victory or feinting
depending on which of those holds true,
99:57 - if either.
100:00 - Running is slightly different.
100:01 - So if we run, I've programmed it to be
100%, it will 100% of the time work.
100:07 - In Pokemon, you actually
have a chance to run
100:10 - based on what the delta is
between you and your enemy.
100:12 - So if they're stronger than you, you
actually aren't guaranteed to run away.
100:16 - So what we do here in my implementation
is, we just pop the battle menu,
100:23 - so it's gone.
100:24 - And then we push, you fled successfully
to the screen, this battle message.
100:30 - But there's a difference here versus the
other battle messages that we've shown.
100:36 - I mean, it's not really different,
but it's something to keep in mind.
100:40 - So I'm going to get into a battle.
100:45 - And so first of all, with that message
that you just saw on the screen,
100:48 - I had to actually press Enter, right?
100:50 - I discarded it explicitly
by pressing Enter.
100:56 - And that holds true
also for these messages.
100:58 - It won't do anything
until I press Enter.
101:00 - So I press Enter, and then I press
Enter, and it does it's thing.
101:03 - But notice the difference
between when I hit Run.
101:06 - I'm going to hit Run, I fled,
and it does it on its own.
101:10 - It's not waiting for input, right?
101:14 - So how have we implemented that?
101:19 - Yeah?
101:20 - AUDIENCE: Using timer,
you'd automatically
101:24 - do it the same way you would afterwards,
instead of waiting for you input,
101:29 - you just wait for the timer to end.
101:31 - SPEAKER 1: Exactly, so we use a timer,
and then when the timer is finished,
101:34 - we pop the battle message just like we
would have popped it by pressing Enter.
101:40 - This false flag is what
allows us to do that.
101:43 - We press false and false
is, can we input or not?
101:46 - And we can't.
101:47 - So actually, if we didn't do
any timer thing after this,
101:51 - and we just did that false flag, the
battle message would be there forever,
101:54 - and we could never get rid of it, ever.
101:56 - It would get stuck forever.
101:58 - So we got to be responsible and
say, OK, we're going to put a timer,
102:03 - we're going to call timer.after
0.5 seconds immediately after that.
102:08 - We're going to push a fade in state.
102:11 - And then we're going to do these two pop
operations here as soon as that fade in
102:15 - happens.
102:16 - This first pop will pop the
message, right, this message here
102:19 - that we didn't pop through input.
102:22 - So this is actually garbage
collecting, in a sense, for us.
102:26 - It's discarding the message that
we couldn't discard automatically.
102:31 - And then we're going to pop
the battle state, right?
102:33 - So running will push the battle
message, trigger a timer tween
102:38 - for our timer.after five seconds,
sorry, push a fade in state.
102:44 - And then after the fade in states
done, then pop both of those states.
102:48 - The message and the battle state
take us back to the play state.
102:53 - And that's where we'll be
as soon as that's all done.
102:56 - And that's all that's in
the battle menu state.
103:00 - Any questions as to how the battle menu
works, the difference between fight
103:04 - and run and sort of how those operate?
103:08 - OK.
103:09 - So let's take a look
then at the take turn
103:13 - state, which is the last piece
and the largest piece I would say.
103:19 - This is the most relevant
to the assignment.
103:24 - So we maintain a reference to which
Pokemon is first or second to go,
103:28 - which sprite is first or second
to go, and which progress bar is
103:31 - first or second to go up here.
103:33 - And we do that, like I
said, based on speed.
103:36 - So whichever Pokemon is
faster, and we could have also
103:40 - made this a little bit shorter, just
by keeping the sprites and the progress
103:45 - bars as members of the
Pokemon object, or the class,
103:49 - but since they're kind of
separated, like we don't necessarily
103:53 - want a Pokemon to have a reference
to it's progress bar at all times,
103:56 - or I mean, you could.
103:58 - There's nothing preventing
you from doing it.
103:59 - It would only serve the purpose
of shortening this code here.
104:04 - But we need to keep a reference to
this so that we can call attack here,
104:10 - which is this large bit of
code twice, without needing
104:16 - to duplicate all of that code twice.
104:18 - Does that makes sense?
104:21 - So Tony, did you have a question?
104:22 - AUDIENCE: Well, I was just
thinking, you could probably
104:24 - put that into a helper
function where you just
104:26 - change the order you pass it in.
104:29 - SPEAKER 1: Sorry?
104:30 - Say it again.
104:30 - AUDIENCE: I just kind of feel like,
I guess you could take the code,
104:33 - and you could avoid
duplicating that I guess.
104:36 - 'Cause it's just reversed, so
what you could do is you could--
104:40 - if you passed into a helper
function, which you would just,
104:44 - instead of passing it first--
104:48 - instead of passing it, opponent
Pokemon, player Pokemon,
104:50 - you would pass it, player
Pokemon, opponent Pokemon.
104:53 - And that would probably work I think.
104:55 - SPEAKER 1: Well, you also have
to take into consideration--
104:57 - so the comment was, you could pass in
the player Pokemon and the opponent
105:04 - Pokemon into a function, and then
you reverse them in that function,
105:08 - I'm assuming, have reverence
them and reverse them.
105:10 - But the sprites are
decoupled from the Pokemon,
105:13 - and the progress bars are also
decoupled from the Pokemon.
105:17 - So we could shorten this by making
these four things here fields
105:27 - of the Pokemon objects,
but they're not strictly
105:31 - pertinent to the operation
of the Pokemon object.
105:34 - And it sort of kind of makes
the Pokemon objects a little
105:39 - too, not basically abstract
or lightweight enough,
105:43 - and it only serves the
purpose of this point,
105:45 - of just shortening this bit of code.
105:47 - There's probably a more elegant
way to do it, but it's hard to say.
105:53 - If this code were to get larger, maybe.
105:56 - But the gist of this
is basically to have
105:58 - a pointer to whatever Pokemon, progress
bars, and sprites should operate first
106:04 - in the attack versus what
should operate second.
106:06 - And then the two will trade blows in
order based on who's first and who
106:10 - second.
106:12 - So when we enter the
take turn state, we're
106:14 - going to trigger that attack, here this
function attack, which we'll take in
106:18 - first, second, first, second,
first, second for the Pokemon
106:22 - sprite and progress bars.
106:24 - And then anonymous function,
which get's executed as
106:27 - soon as the attack is finished, right?
106:31 - So this is a code that will pop a
message that gets pushed in attack,
106:35 - and then this is where we
actually check deaths, right?
106:39 - And it will determine whether we go
to victory or faint screen or not.
106:42 - If not, and we return if so.
106:44 - If not, we're going to do
another attack, but see,
106:47 - everything is reversed now.
106:48 - Now it's second, first,
second, first, second, first.
106:53 - So we have the same
function, self attack,
106:55 - which just takes in the attacker.
106:57 - And it's effectively, attacker,
defender, attacker, defender, attacker,
107:00 - defender for the Pokemon
sprites and progress bars.
107:05 - And so the attack function
here first pushes a--
107:09 - well, OK.
107:10 - What does the attack--
107:11 - let's go over it one more time.
107:12 - What do we think the attack
function does in order.
107:18 - We covered them just
a moment ago, but what
107:20 - was the order that happens when
something attacks another thing?
107:24 - Yeah?
107:25 - AUDIENCE: The attacker blinks white.
107:27 - SPEAKER 1: Attacker blinks white.
107:28 - AUDIENCE: Then the
defender blinks opacity.
107:33 - SPEAKER 1: The defender
toggles it's opacity.
107:36 - AUDIENCE: And the health bar shrinks.
107:38 - SPEAKER 1: Health bar shrinks.
107:42 - Exactly, and then that's
basically it for attack, right?
107:45 - Blink, play a sound, blink,
play a sound, shrink the bar,
107:49 - and also we're doing damage
in that function as well.
107:52 - We actually have to change
the status of the Pokemon.
107:59 - So this is effectively
where it starts, right?
108:02 - We place a battle message
state onto the stack that says,
108:05 - the attacker name attacks
the defender name.
108:10 - Notice that it gets false
just like the run message
108:15 - did, because we're not
accepting input here.
108:17 - But it's up to us actually, it done
up here at line 42 of the enter state.
108:25 - But we're going to after 0.5
seconds, play the attack animation.
108:32 - So power up sound every 0.1 second.
108:36 - We're going to member the
blinking flag on the sprite,
108:39 - we're going to toggle it by
setting it not to itself.
108:42 - So if something is not itself, if
it's a truthy value, it becomes falsy,
108:46 - if it's falsy, it becomes truthy.
108:48 - So basically, toggling
between true and false.
108:51 - Limit of six, right,
because remember, every will
108:53 - do something every amount
of time indefinitely,
108:56 - unless you pass in a limit of some
value, in this case, a limit of six.
109:00 - So we're saying, only execute this code
six times, only blink six times, right,
109:04 - only toggle six times,
blink three times, right,
109:07 - because it has to go on and off.
109:09 - And then as soon as those
six iterations are completed,
109:12 - we call the finished function
on that timer object,
109:16 - which takes an honest function.
109:18 - As soon as that happens, we
do the opacity bit, right?
109:22 - We blinked the attackers, so now
we've got to blink the defender.
109:25 - So we play the hit sound.
109:27 - We do the exact same thing that we
just did for the blinking, only now,
109:32 - every 0.1 second, we are setting
its opacity to either 64 or 255,
109:37 - depending on what the value
of its opacity is, right?
109:40 - So we are toggling between 64 and 255.
109:43 - Limit of six, take a
function, calculate damage,
109:47 - which we've just very simply done it,
attack minus defense, right, up to 1
109:53 - though.
109:53 - So if the defense is actually
higher than the attack,
109:55 - which will still do at least one damage.
109:58 - And then over 0.5 seconds,
we take the defenders bar,
110:03 - and we tween the value equal to
their current HP minus damage, right?
110:08 - And then that will set in the bar, in
the progress bar, it'll set its value.
110:15 - And even though the progress
bar is behind state wise,
110:21 - right, it's on the bottom of the stack,
because it's on the battle state.
110:24 - And we're in currently
the take turn state,
110:27 - but because we're still manipulating
the values of that state,
110:30 - and we're rendering every state,
we're actually still manipulating
110:33 - that state regardless of the fact
that it's not on the top of the stack.
110:37 - So that allows us to shrink that
Pokemon's progress bar regardless of it
110:43 - being on the top of the stock or not.
110:45 - Then once that's finished,
once the tween is finished,
110:47 - actually set the current
HP to that amount,
110:49 - because we're only tweening the
progress bar's value, which is
110:52 - independent from the Pokemon's value.
110:55 - And then that's the end of the attack.
110:56 - The attack is completely
finished at that point.
110:59 - So any questions as to
how the attack works?
111:02 - Just a chain of tweens basically.
111:06 - So we do an attack, then check
deaths is the next function.
111:10 - And we're almost finished, I'm going to
kind of go quickly here, it's at 7:30.
111:14 - Check deaths is the player Pokemon
current HP less and equal to 0,
111:18 - or is the opponent Pokemon
current HP less and equal to zero.
111:21 - If the former's true, we need to
faint, and if the latter is true,
111:24 - we need to go to victory.
111:25 - So faint is effectively a battle state,
right, when it says, you fainted.
111:32 - And then what?
111:33 - Remember what happens when we faint?
111:36 - AUDIENCE: [INAUDIBLE] text
box, and then it leaves.
111:41 - SPEAKER 1: It leaves,
do you remember how
111:44 - it leaves as it differs from
like running away, for example?
111:46 - AUDIENCE: [INAUDIBLE].
111:48 - SPEAKER 1: Well, beyond
that, aesthetically,
111:50 - do you remember how it's different?
111:52 - AUDIENCE: [INAUDIBLE]
differently to black, I think.
111:55 - SPEAKER 1: It does.
111:55 - It fades to black instead.
111:57 - So that's how we can
differentiate when we're fainting
111:59 - versus when we're running away.
112:00 - And so that's what we're doing here.
112:02 - Notice that the fade in state
RGB is zero, all of those.
112:06 - So it's going to fade in to 000255,
as opposed to 255, 255, 255, 255.
112:12 - So it's going to be a black
fade in versus a white fade in.
112:17 - And then once we've--
112:18 - this it just sort of a
thing that I implemented so
112:20 - that we can keep playing indefinitely.
112:21 - But once that's finished, restore
the player Pokemon to full health,
112:25 - resume all the field music stuff.
112:27 - And then once we've pushed
a fade out state, 000,
112:31 - and then we've gone back
to the field, let's push.
112:34 - Notice that here it takes a function,
right, after the fade out state's done.
112:38 - Once the fade out is finished-- so as
soon as we're back to the play state,
112:42 - push a dialogue state
that says, your Pokemon
112:44 - has been fully restored, try again.
112:47 - Which will take the context,
and we'll [INAUDIBLE]
112:49 - to press Enter to get past it.
112:51 - That's fainting.
112:54 - Victory is a little bit more robust.
112:58 - So victory is-- do you remember
what happen when we get a victory?
113:06 - AUDIENCE: Well, it has to
check leveling up as well.
113:11 - It says, you've defeated your
opponent, then your XP bar increases.
113:17 - Then if you've leveled up, it
tells you that you leveled up,
113:20 - and then it leaves.
113:21 - SPEAKER 1: So it tells you you defeated
your opponent, XP bar increases,
113:27 - checks for a level up, and then leaves.
113:30 - After displaying the level
up message or not, it leaves.
113:35 - It pops everything back to
the play state, exactly.
113:39 - So remember, the very
first thing that happens
113:42 - though, the opponent sprite gets
tweened over the course of 0.2 seconds,
113:46 - it's y value to virtual
height, which means,
113:49 - all the way to the bottom
of the screen, right?
113:50 - The typical defeated your opponent
from Pokemon sort of animation.
113:56 - Once that's finished,
play victory music,
113:58 - push a battle message state
that says, victory, right?
114:01 - Once that's popped of the
stack, calculate the XP,
114:04 - which is, I just chose arbitrarily
sum all the IVs of that Pokemon times
114:09 - it's level, and that's the XP you got.
114:12 - Push a state that says,
you earned x XP, right?
114:18 - It's false, so that means
it doesn't take input.
114:21 - So that means it's up to us in
order to pop that off the stack.
114:24 - So after 1.5 seconds, we play a sound,
and then we tween that XP bar going up,
114:29 - right?
114:31 - So that's what's going on here,
self.battleState.playerxpbar,
114:34 - we're tweening of the
math.men, of the XP plus XP,
114:40 - or XP to level, because if we don't, it
could go past the edge of the XP bar,
114:45 - because we could go over
our XP to level, right?
114:49 - Let's say we have 10 XP till we
gain a level, we could gain 20 XP.
114:52 - We'd be 10 XP overboard.
114:53 - So we don't want to tween our XP
bar past the edge of the XP bar,
114:58 - it would be a graphical glitch.
115:00 - So a math.men our XP plus
XP, and our XP to level,
115:05 - which will take the
lesser of the two values.
115:08 - Once that's done, it's tweened,
we're going to pop the message off,
115:12 - and then we're going to
actually add the XP, level up.
115:15 - So this is where we level up if
the XP is greater than XP to level.
115:19 - Play a sound, set the XP to the
current XP minus our 2 level XP,
115:26 - which will mean that we'll
have some carry over, right?
115:30 - And then actually call
the level up function.
115:32 - Now here is where--
115:35 - oh, and also after that,
congratulations, you've leveled up.
115:37 - Fadeout white, which is
just a white fade out here.
115:40 - I used it twice, so I
made a function for it.
115:43 - Just pushes a fade in state.
115:46 - Stop the victory music, play the field
music, pop, push a fade out state.
115:50 - So either way, when we've got a victory,
we're going to push a fade out white,
115:56 - or we're going to call
fade out white, correct?
115:58 - So push a battle message
state, and then as soon
116:02 - as we press Enter, because we
leveled up, fade out to white.
116:06 - And if we didn't level up,
but we still got to victory,
116:08 - we still need to fade out white.
116:10 - And so this is where your
assignment is, assignment 7.
116:13 - Assignments 7 is, notice that we
have self.playerPokemon level up.
116:17 - The key thing that we are
going to need to do here
116:19 - is add a menu that shows
us how we leveled up.
116:23 - And if you recall, playerPokemon
level up returns all the stats
116:27 - that you've increased this level.
116:29 - So you can show a menu that just
says, your HP plus that amount, right?
116:34 - You're going to get all four values.
116:36 - It's going to explode to
all four of those values.
116:38 - And then you're going
to create a new battle--
116:42 - or not new battle menu, but a
new menu of whatever you want,
116:46 - but probably on the right side of
some vertical height for items.
116:51 - The only difference
here, the only key thing
116:53 - that you're going to
take into consideration
116:55 - is, and I'll go back to the
slides, because we're actually
116:59 - done at this point going over the code.
117:01 - But the selection items, you won't
be able to actually select anything,
117:07 - it's just going to be purely visual.
117:09 - So you're going to need to edit
selection to have the option
117:12 - to not have a cursor.
117:13 - And this is detailed in the
spec, which was actually
117:15 - released before lecture today.
117:17 - So you can take a look at that.
117:18 - But you'll need to make
a change to selection.
117:21 - But all the pieces are there.
117:23 - It should be a fairly
easy assignment as long
117:24 - as you understand how the
states work, how the menu works,
117:28 - and how to create a menu
based on those values,
117:33 - and how to actually get
the values from level up.
117:35 - So some missing features that we didn't
talk about, which we didn't implement
117:38 - are, for example, the
detailed level of screen,
117:41 - which is your assignment,
monster catching, right?
117:45 - We only have a party of one Pokemon
throughout this whole entire thing,
117:49 - but one of the arguably main appeals of
the game is to be able to catch more.
117:53 - So that would be something to add, to
prioritize probably adding to the game.
117:57 - A field menu so can actually look
at all the Pokemon you've caught.
118:00 - That would be nice, so you can
actually see how much HP they have.
118:04 - In item inventory, because the
game, the regular games have items.
118:07 - You can use potions, you
can find gold nuggets
118:10 - that you sell for a ton of money.
118:12 - Different abilities, currently we only
have basically one fight operation,
118:15 - which is like a tackle.
118:16 - And the game itself,
the regular game has
118:19 - like over 100 different moves
that have elemental attributes,
118:22 - and do different things,
and cause status effects,
118:25 - buff you or your opponent.
118:27 - So adding those is
appealing, and maybe being
118:30 - able to represent them
as data is nice to.
118:33 - Trainers that you can encounter in
the game that have their own preset
118:36 - or randomized Pokemon for to fight.
118:38 - Monster evolution, because that's
like one of the funnest things
118:41 - is taking a really weak
Pokemon, and like raising
118:43 - it to become really strong, and
evolving it at a certain level.
118:46 - Towns, routes, other levels
beyond just our basic square area.
118:52 - Monster breeding, which is
introduced in the second series,
118:55 - so that you can take two
Pokemon and have a chance
118:58 - to get an egg with really good stats
or a really rare Pokemon from it.
119:02 - And then like a day night cycle maybe
where different Pokemon come out
119:04 - at different times of the day.
119:06 - So you are incentivize to
play at different times
119:11 - of the day for that purpose.
119:14 - But that was it for Pokemon.
119:16 - Next week we'll actually
be diving into Unity.
119:19 - So we're actually done with
LOVE 2D, which is a lot of fun,
119:23 - but now we'll be going
into how to make 3D games.
119:26 - So this is a screenshot from the
game we'll be making next week,
119:28 - which is a 3D sort of side scrolling
Flappy Bird esque helicopter
119:32 - game based on a famous web
game called Helicopter Game.
119:38 - And it was sort of one of the
early ancestors to Flappy Bird.
119:44 - On the Wikipedia page, it
actually says that too.
119:46 - I remember playing, it was back in like
2007, or 2006, or something like that.
119:51 - But your goal in this game-- this
is a modified version of that--
119:54 - your goal is your-- everything is 3D,
but it's a side scrolling perspective.
119:58 - So this is called 2.5D for that reason.
120:01 - You're controlling a helicopter,
you're the purple helicopter.
120:04 - And your goal is to in an
infinitely scrolling world.
120:07 - So we'll revisit infinite scrolling,
but in 3D, avoid skyscrapers.
120:11 - So you can see there is a green
skyscraper, crudely modeled.
120:15 - Collect coins, so you can see
there's a coin there, it's a 3D coin,
120:18 - it will always be spinning.
120:20 - Your coins are up at the top right.
120:22 - You'll see a background
that's infinitely scrolling.
120:24 - And then you'll have
jets that will randomly
120:26 - fly above you to sort of give you
another sort of layer or dimension
120:31 - of obstacles to watch out for.
120:32 - And this will teach us a lot of
the basics of how unity works,
120:36 - so we can start getting into even more
interesting things like a first person
120:41 - like sort of core exploration game.
120:43 - And then lastly, when we end
the semester with Portal,
120:45 - we'll look at a couple
of fancy things there.
120:48 - But that was it for Pokemon.
120:49 - Thanks for coming, and
I'll see you guys next
120:51 - time.

Cleaned transcript:

SPEAKER 1 All right, welcome to GD 50, lecture 7. This week we'll be talking about one of my favorite franchises of all time, a core part of my childhood Pokemon as shown by the Poke Ball on the screen there. So back in 1997 I think it was, the first Pokemon game was released, Red and Blue. I believe it was released a year earlier in Japan where it was released as Red, Blue, and Green. And the overall goal of the game was fairly straightforward. You were a Pokemon trainer. Your goal was to go out into the world and try and capture any number of 151 different types of these creatures called Pokemon that were based on a whole bunch of different types of creatures. Shown in the screenshot here, there's a Weepinbell fighting and Geodude. A Geodude was a rock type, Weepinbeel was a grass type. You had different types of Pokemon. When they fight each other, some types were better than other types, like this sort of very large rock, paper, scissors relationship. And it was just a very addicting formula. You'd have a team of these creatures that you had caught and raised and battled, and you'd fight other trainers. And the awesome part of this was you could go and you could actually fight your friends, or trade Pokemon with your friends that they had caught. And you would often share stories back and forth about the different rare creatures that you would have encountered, and all sorts of things. You'd have a customized party that was sort of a part of you. And so this is Pokemon Red. The series has evolved over time. This is a screenshot of Gold and Silver, which was released a couple of years afterwards for the Gameboy Color. Again, this was released for the regular Gameboy. Gold and Silver introduced a bunch of new features including breeding, and a day, night cycle, and a lot of other things that became part of the core series. Here is Ruby and Sapphire, which was for the Gameboy Advance and got a significant graphical update, but the core formula stayed much the same. Here is Diamond and Pearl, which is for the DS, which it made use of two screens, as seen on the top and bottom there. Here is Black and White, which was another step forward in that it introduced three dimensional graphics for the over world, so you could actually see some sort of 3D for the first time in the franchise. And then more recently, we've seen for the 3DS, games like X and Y, which is shown here, and Omega Sapphire, Alpha Ruby Alpha Sapphire and Omega Ruby, and Moon and Sun. And so this is a great illustration of why the RPG genre of video games, role playing game, even though it's sort of its own unique take on the formula. But it allows us to, we can sort of dissect this and take a look at what makes an RPG and what makes a Pokemon game altogether for a nice cool demonstration. So today, we'll be talking about a few new things. We'll be doing things a lot differently in this lecture example relative to other examples, because we're transitioning away from the state machine and talking about a construct called the state stack, which is effectively a more advanced version of the state machine. Whereas before, we had a state machine that was in one state at a time, whereby we could be in the play state or the start state or what not, we can now actually have multiple states that exist in parallel that are on a stack of data structure, which you've seen in CS 50 if you've taken, where we can have, for example, the field state, the play state at the very bottom, which is always there, and then we can push states onto the stack as we need to for example, a dialog state so that we can actually display some dialog, some text to the screen without getting rid of the play state that we had there before. It allows us to render multiple things at the same time, and then also return back to prior states, rather than completely create new states every time we want to make a transition. We'll be talking about turn based systems. So an RPGs like Pokemon and others, there are often battle systems that are usually turn based in this particular genre where you're fighting you have one team or one character fighting against against one other team or one other character, and you take turns fighting each other. And you have an indefinite amount of time to make your decision and then form some sort of strategy as to how you want to approach the problem. We'll be taking a look at a very primitive turn based system, but a fully functional one today. Another huge aspect of this genre is graphical user interfaces or GUIs as they're shortened. Things like panels, and scroll bars, and text boxes, and menus, all sorts of these things that allow us to get a more visual sort of look at our data, and allow us to navigate a much more complex game ecosystem more efficiently. And to tie it all together, RPG mechanics at large, we'll be looking at things like leveling up and experience and how to calculate the damage that one party does to the other party throughout the course of a battle. And so it will be a fairly complicated set of examples, but fairly illustrative of the genre as a whole. So I'd like to demonstrate sort of the example that I put together. If I could get a volunteer from the audience to come up and take a look. Tony that'd be awesome, thank you so much. So this is my simple but fully featured, more or less, demonstration of Pokemon. So if you want to enter or return. So this is a so here we have a we can see right off the bat, we have a text box and a play state like we did before. So this text box is actually a state that's layered above the place. So you can see it has some instructions about, if you want to press P, you can heal your Pokemon. You can press Enter to dismiss. So if you go ahead and press Enter, you'll be able to actually move around now. And so something to note is before, input was actually halted while the dialogue was on the top of the screen for the play state. You're actually not allowed to access or update this bottom state, because the state stack is only allowing input to the top state. And so I have limited the play here just to this box, but if we walk in the tall grass down here, in Pokemon, in order to actually initiate an encounter with another Pokemon or another wild Pokemon, you walk in the grass. So here we've walked in the grass. There's a random chance for this to happen, there's a 1 in 10 chance basically. So it's saying that a wild Bamboon appeared. So a wild creature appeared. He's level 5, we're level 5, should be a fairly even battle. So you can press Enter, and it will say go the name of your Pokemon, which is an Aardart in this case, and it's randomly allocated at the moment. So go ahead and press Enter one more time. Now we can see on the bottom right, we have a menu. So we can fight or we can run, so those two choices. So we can go ahead and fight. So we fight, whichever Pokemon has the higher speed will go first and do damage. We obviously, do a lot more damage, but he's a little bit faster, so he's going to go first. So we fight one more time. We should be able to knock him out. So as soon as we do, we get a victory message, we get a victory song. If we press Enter, we'll actually get some experience for defeating that enemy. So we've got quite a bit of experience, we got 65 XP. In that bottom bar, we can see we have all these GUI elements, we've got a panel here, we have text boxes, we have progress bars, all these pieces are coming together to give us sort of this turn based system. And so after this, we may level up just to demonstrate leveling, which is part of the RPG mechanic side of this game. So we have to press this one more time. We did, perfectly. So they leveled up. And so now we're level 6, so we can see the 6 changed above our progress bars. So now will be a little bit stronger every time. And the stats aren't shown here, it's actually a part of the assignment is to create a menu that will actually show you how you leveled up, what stats actually increased. But underneath the hood, behind the scenes, you actually are getting stat increases. And so here we can see that if we our HP goes all the way down to zero, we faint. And when we faint, the screen instead of fading to white will actually fade to black to illustrate the difference between the two transitions. And so that we can keep playing indefinitely, the game will restore your Pokemon back to full health. And so this will go on forever. This is effectively what the simulator is, it's just a simple series of infinite battles. There are random Pokemon in the grass. There's five total that you can fight. But all the core pieces of what make the game are here. So actually, let's illustrate running too if you wouldn't mind, just so that we can see if there is a difference. So we can actually flee, and then battle we'll get cut short there. We won't get any XP, we won't faint, but we still get taken back to the play state. So that's all for the Pokemon demo. Thanks so much Tony for coming up to demo it. Well, there's a lot of pieces involved here, but as we will see, once we have a lot of these sort of foundational pieces implemented, it's not too difficult to start layering more and more of these onto the game to make it even more rich. In fact, the assignment is to and we'll see this at the end, I'll recap this at the end but the assignments goal is for you to implement a menu similar to the menu that we saw where fight and run were shown that will show you what your current stat is for each of your stats, there's attack, defense, speed, and your HP. It will show you what your stat is before leveling, the amount that it will increase by, and then the final amount, which is sort of similar to how the actual Pokemon games work, so you can see rather than just seeing, oh I increased my level from 5 to 6, 6 to 7, you can see, oh, my strength increased from 12 to 14. I'm a little bit stronger, I'm going to do more damage on the next play through. So our goal here, we're going to take a look at the field state, the play state, and the battle state. And there's a common dichotomy in most of these sorts of games, be it Final Fantasy, or Dragon Quest, or Pokemon where there is a field, where you are walking around, you're character interacting with a game world with NPCs, going through towns, and what have you. And then a battle mode, sort of a battle state where you're actually fighting against some sort of enemy, or a series of enemies, a party or a single creature. And so we've implemented simple versions of both of these to illustrate and also the transitions between them. Before we start, I want to make another sort of plug for this howtomakeanrpg.com, this book, I actually learned a lot from this and about using LUA in the context of game development. And I pitched this I think in one of the earlier lectures, but if you want a deeper dive into a lot of these constructs, and to sort of get a sense for how you might do something like cut scenes, or more complicated battle layouts, and a lot more like it goes into a lot of detail about a lot of awesome things, definitely check it out. It's not free, but if you're interested in this genre, which I am, it's definitely worthwhile. Here's what the sprite sheets look like that we'll be using for this sort of demonstration. The Pokemon aside, which are individual textures. Here we're using a simple sprite sheet, which just has a bunch of tiles, most of which we did not use. Note that the bush, the tall grass is not on any sort of background. And therefore, we need to layer, basically have two separate tile maps as opposed to one, which we didn't do last time. And we were reusing the sprite sheet that we used in the Zelda lecture. Before, we used it for all the enemies, the skeletons, ghosts, and slimes, et cetera. But now we're actually using it for the PCs that it contains. Specifically, just the male NPC here, which is our main character. The foundational class that we're using in this lecture that sort of everything else revolves around and makes this work is the state stack. And so before, what we had was a state machine, right, where we were in one state at a time. So you can almost think of it like, we have a box here, and it just has one socket. And then we're always looking at this one socket, whether it's the play state, or the battle state, or a transition of some kind. And now we're transitioning into the idea of, instead, of just one state that we can only see at once, we'll make it a stack. And so what we can do with this is, rather than just having one, we can therefore render multiple states at a time, right? So let's say this is like the field, right, or the play state. And then maybe this is like a dialogue, or something, right? Like we saw before in the field, we had a text box. We can actually layer things on top of each other. And then maybe this is like a fade out, right, or a fade in. So we start with the play state maybe, and we're walking around, and we interact with in NPC. Rather than transition the play state to a dialog state, which would, in our previous model, completely eliminate the play state, because there's only one state that could be active at a time. Now we just render, however many states we have in our stack, we just render them sequentially based on the order that they were popped in. We would rendered this first, we basically render from the bottom up. Render the play state, then the dialogue, then the fade in. And this will have the effect of doing a whole bunch of different things, which we'll see in the distro. But we only really ever need to update one state at a time, right, because if we have the play state active and the dialog state active and the fade in state active, in this order, as a stack, right, we were pushing the operation for pushing for getting something onto the stack is called a push, and getting it off is called a pop if unfamiliar. If we're pushing all of these states on, then usually, we only need to update whatever's on top, right? If there's no fade in for example, and we only have a dialog state active, or a dialogue and a place state in that order top to bottom, then we usually don't want him update what's going on in the play state. We're only concerned with the dialogue that's taking place. We only want that to take input. And when we press Spacebar, Enter, or whatever button clears that dialog state, we pop it off, right, and then we're back to the play state. Then we're just updating the play state. And so being able to update just what's on top while being able to render everything that's on bottom. And this doesn't hold true for all game formulas, there's certainly some games where you can have a dialogue and a play state both get updated, but that's still using a state stack of sorts, you're just then updating things in a top down way. But this allows us to do all kinds of things like transitions, and preserving like for example, the fact that we have a play state and we can pop a battle state on top of that, where we don't see the play state underneath it, we only see the battle state, and that's all updating. But it is we pop the battle state off, we're right back where we just were in the play state. It's preserved its state, for lack of a better word, from before. And this is something that this model affords us comfortably. And so that's sort of the foundational class that's implemented in this distro, which will allow us to do all kinds of awesome things. So let's go ahead and take a look at what that looks like. I have state stack open here. So state stack has just a set of states here. And then whenever we want to insert a state, it's going to be at the end of the state stack. So it's going to be whatever the last so if we're looking at it as a series of states in a table, it'll be whatever the last index is in the table. That will be our, the top of our stack. And you can implement this either way in reverse if you wanted to. It's just easier, because you can just do a simple table.remove to get rid of the table.remove on that table to get rid of the last state without having to shift back everything. So if we did it starting at index one, you'd have to shift everything back. And it would also be a little bit weird, because you would start at one, and then things would go left. But basically, in order to update whatever our end state is, we just do at #self.states, which will be however large our state stack is, we just call update on that state. And then process AI is here, although we're not using it. But if you had AI, it would be the same thing as basically an update for artificial intelligence for your state. Rather than rendering just one state at a time, we iterate through all of our states here using ipairs, which will iterate through them numerically starting at one going to the end. So we call for istate, and ipairs of self.state, render it, so that will render everything back to front, or bottom to top, and allow us to get this layered look where we have a play state going on underneath for example, and then a dialogue on top. Or we have a battle state going at the very top, and maybe that battle state itself pushes a dialogue state to the top of the stack, or a bunch of other states, a transition, whatever you would like. To clear it, we just reset the table to an empty table. To push a state, we just do an insert on that state, and then we call enter on that state. As we did before, sort of similarly with state machine, when we changed a state, we would call enter on it and exit, but now we're just calling enter when we push. And then to pop, all we do is call exit on whatever the last state is in our state stack, and then just call table.remove on self.states. And by default, when you call table.remove on a table, just a table with no other arguments, it'll remove whatever the last index is of that table. Does that makes sense? Anybody have any questions as to how the state stack works? All right, awesome. So let's take a look then at the start state. So this is the start date. Fairly simple, we just have a couple of text labels, and then we have just a randomly assigned sprite going left to right. How do we think we're achieving the movement? Yep, timer.tween, and then we're just drawing an ellipse, right, pretty simple. And then when we press Enter, note the transition. Notice that there's a fade to white, and then fade to transparent. And so if we recall from when we looked at match three, how do we do this, do we remember? AUDIENCE [INAUDIBLE] SPEAKER 1 Exactly, and the rectangle was stored where? Sorry, to repeat for the camera, we had a rectangle that filled the entire screen, and we just tween the transparency for it, which is true. The rectangle there before though was stored in whatever state was active at the time, which was like the start date, or the I think begin game state was the name. The actual state that wasn't necessarily relevant at the transition. But using a state stack, we can actually decouple this idea. We can take the concept of a transition, and because imagine if we wanted to make a transition between every single state that existed in our game, right? If we wanted to transition from the battle to the field, or the field to the battle, or whatever else we might want, like the start to the field, we would need a rectangle in every single one of those that has an opacity that we're keeping track of. And that's not necessarily germane to the purpose of that state, right? So because we now have a state stack, we can actually abstract out this idea of a transition, and turn it into its own state. We can have a transition state. And recall that since we're just layering everything [? off ?] all these states, and we're rendering them sequentially, having a state that possesses it's own for example, opacity rectangle, we can just layer that, push that onto the stack, and render that, and it'll give us the illusion of having this transition. But we don't need to actually have it be part of the state that we're trying to transition out of and into. Does that make sense? So let's take a look, for example, at the let's take a look at the start state first, just so we can see where that actually gets kicked off. So the start state, we kick off some music, we have a sprite, and a sprite x and y. These are values that are relevant to the sprite that's moving, actually, we only have one sprite ever moving left to right. It just gets teleported to the right edge of the screen as soon as it gets taken to one edge. So we only have one sprite, one x and y. And then every three seconds as we see here, we have a callback function that will tween the sprites x to negative 64 over 0.2 seconds, so really quickly. And then on finish, teleport it to the right. And then do the same exact thing, but tween it to the center over 0.2 seconds. And then as soon as we press Enter or Return, note this here, we have gStateStack, not a gStateMachine anymore, and we're pushing on to it a fade in state, which takes an RGB, a duration, and a callback function. Now if you look at main.lua, this is relevant, because now we no longer have a state machine, right? We previously had a global state machine, gStateMachine. We would give it a list of indexes into functions, anonymous functions. Those would return the instantiation of a state. And then when we called change, the state machine will index into its list of states, and call that anonymous function, which would have the result of changing the state to some state that we've implemented as a class, right? Now we just create a state stack and we just push a new start state onto the class. And so what this will do is effectively the same thing, only now we can layer things onto the start state, right, or play state, or whatever we want to, and we're not going to ever get rid of it. I mean, we can get rid of it, but we don't have to. For the play state, especially, we want that to pretty much never get popped off the stack, because that's going to preserve all of our information. We're going to default back to that to store all of our character information, our Pokemon information, whatever else we might want to add onto this shell of a game in inventory, et cetera, a world state at large. We want to preserve that and keep that consistent across all of our battle states and so forth. And the battle states will just pull information from that world, from that play state, and construct a battle as needed. Does that makes sense? OK, so here we're effectively, the only real changes we've made to main are no longer a state machine, now we have a state stack, going to push start state, that start state has some behavior just like any other state that we've implemented before. And what I was about to get into before was here on line 36 of the start state, we're pushing another state onto the stack. So there's already a start state, and it's from within the start state itself actually. We're going to take that stack, which is just one level deep, and then we're going to make it two levels deep now. So now we're going to add a fade in state. And the fade in state as we can see, takes in an RGB. Does anybody have a guess as to what the RGB is relevant for? AUDIENCE [INAUDIBLE] SPEAKER 1 To whether you want to fade in black or white? Yes, any color. We can make this, we can make it a fade to red if we wanted to, or fade to blue. But we don't have to create two separate classes for a fade in white, fade in black, fade out black, fade out white. We can just give it a color. And then I mean, we could even go a level further with this, and make it take in an opacity as well, so that we don't need a fade in state, or a fade out state, we just need a fade state, right? And the fade state will determine, based on whatever last opacity parameter we give it, the right way to fade in and out. But in this case, the difference between the fade in state and the fade out state is one knows to go to 0, one knows to go to 255. That's really the only key difference. And then this 1, the duration, right, we need to tell it how long to fade. And then this last bit here is a function. We're giving it an anonymous function, this is a callback function, because the fade in state by nature is an asynchronous state. It does its behavior over time. So we need a way, we need to tell it, OK, when you finished doing what you're doing, call this bit of code here, so that we can do something not immediately, we can sort of defer its execution till later. And this is something that we'll see common throughout this lecture, because we have this implemented also in like dialogue for example, because we don't know when the user is going to press Spacebar on the dialog state and clear the window. But what if we want that window, the clearing of that dialog to trigger some sort of event, right? For example, if they press Enter when they're in the battle, we want it to go to the next action. We don't necessarily know when it's going to happen, so we'll just pass in an anonymous function to that dialogue state that the class will call whenever the close function is called on that dialog state. It says, when closed, execute this anonymous function. And then that anonymous function can do whatever you want to do. It could pop another other several states onto the stack. But this is what allows us to chain asynchronous behavior. That's the key here. So this anonymous function so we'll take a look now actually at the fade in state, just so we can see what this looks like. So we see here, fade in state, right, takes in the color. We saw before, that will be the color we fade to. The length of time that it'll take us to actually perform the transition. And what are we using for the transition do we think, timer.tween, right? So most everything that we'll do actually throughout the course of this lecture that has asynchronous behavior, we can implement it with timer, which is nice. It allows us to fairly succinctly and declaratively tell right out what exactly we want to have happen over time. In this case, we're going to tween over the course of time the opacity of our self to 255. So the fade in is going to fade into the full color of whatever we have given it. So it's going to go from 0, which is shown here by default, to 255. And then as soon as we finish that tween, that is when we pop the fade in state. We're going to pop ourselves off the state effectively, off the stack effectively. And then here, we're calling on fade complete. And that's where the anonymous function is. On fade complete is passed in here. So by putting that function into the finish function of the tween operation, we've allowed ourselves to defer that function that we've written up in the it's in the start state. We defer the execution of this function until after that tween operation takes place. Does that make sense? OK, awesome. And that's effectively what it is. And that's a common theme that we'll see if you're looking through the distro, you'll see it in a lot of places. Anonymous functions or callback functions rather being passed into things like the dialogs, and the fades, and a few other places. In the take turns state for example, there's a function that takes in at a callback function as well. And that's effectively how you can chain asynchronous behavior that executes over time, rather than it being blocking. Does anybody have any questions so far as to how this works, at all? All right, so when the fade is done we're still the start state here at this point, the fade is done, we're executing this anonymous function. We're going to pop the start state off of the stack in this case. And then we're going to push a we're going to do two pushes here. One is to push a play state, which recall is where the NPC [INAUDIBLE] character walking around. And another one is to push a dialogue state. And so what this will have the effect of doing is rather than us immediately going into the play state and being able to walk around, we're actually put right into a world where there is a message waiting for us that we have to press Enter on in order to continue. And when we press Enter, because we're pushing the play state first, and then the dialogue state, the dialogue state is at the top of the stack, right, because things get pushed onto like a stack of plates. You put a play state plate on the bottom and then another plate on top, and that plate is the dialogue state in this case. And you can only interact with the top we're only updating the top plate at once in this model. We could obviously make a more complicated state stack that allows us to have several layers of states being updated at once, but for simplicity, we only opted to allow the top layer to be updated. The dialog state is going to be the active state, it's going to be receiving input. All of them are going to be rendered, so we're going to render things from the bottom up. We're going to render the play state, then we're going to render the dialog state, but the dialog state's going to be active. We're only going to be able to press anything on that state. And then lastly, actually, even beyond the dialogue state, we're pushing another state, we're pushing a fade out state. And in this case, it's the opposite of the fade in state, it just takes in an RGB, and we'll go from 255 opacity to zero opacity in that case. And so what that allows us to do for playing right, we're here in the start state, pressing Enter. That's our fade in state was there. And then we pushed to the play state and the dialogue state and the fade out state at once, so you would almost think that we push a fade in and then the fade out, but we have to lay that foundation before we put the fade out state on top of the stack, right, because the top layer gets updated. So we have to push the fade out state on top of all of those. That will get updated, that will fade out, and then we're back to the two states that we push before we pushed the fadeout state. Does that make since? OK. Does anybody have any questions as to how that sort of flow works? Cool. All right, so that's the gist behind, I mean, that's essentially the core of what we're doing today is the state stack pushing multiple states. And then just figuring out the right order the need to push them in to get the desired appearance that you want, right? We push the fade out state while we're in the start state, or fade in state rather. That will take us to white, and then like sort of, almost like underneath the behind the curtain, we're popping everything, and then we're adding the play, dialogue, and then another fade out state. And so you sort of have to balance the order that you put things in in order to achieve the desired results. It may not necessarily be exactly as you intuitively think until you think about just how we're updating and rendering things on a stack. And so that's the ultimate hurdle I think in really getting comfortable with the distro, but once you've gotten that, everything else sort of falls into place. That and the sort of abundance of asynchronous functions, as we'll see pretty shortly when we look at GUIs, and how we've implemented a lot of basic GUI functionality. A lot of that is very, very call back driven, just because of the nature of it being based on user input, right? You don't know when the user's going to do any input, so defer whatever happens with that GUI code with the triggers involved when the user presses Spacebar, Enter, and then call that function that you've passed into that GUI widget. All right, so we've taken a look at the state stack. We've taken a look at the start state, the fade in state, let's take a look now at the play state. So the play state a lot of this is actually very similar to what we did back with Zelda, which is a very similar type of game top down. View, the only difference really with that was RPGs of this nature Final Fantasy, Pokemon, Dragon Quest, they're tile based to the degree of even your movement is tile based. And so we've striven to implement that with this lecture. So when we move our player, our character, it doesn't have free motion like we did with Zelda for example. So I'll demonstrate this. So I can go to the field state here, the play state, sorry. And then when I move, if I press right, he moves in that direction at a perfect grid interval. So if I move up, I'm taking my hand instantly away, he's going to keep moving, and he's going to stick hard set to this grid. And that's just a sort of trend that these games have implemented. It allows you to stay perfectly aligned with the grid, and helps you I guess certain game I don't think it's strictly necessary for probably most of the games that choose to implement this. I think it was a symptom of tile based games from the NES and Gameboy era being easier to design and implement, because they're very tile based systems. But I mean, even as an aesthetic choice, I suppose it makes sense, because everything aligns very perfectly. So that's the core difference really with the field state in this game. So how can we go about implementing a grid aligned movement system like this with our player relative to how we did it in Zelda for example? How do we think sure yeah? AUDIENCE So we don't x and y's, we just have the tile positions. SPEAKER 1 So you don't have x and y's, we just have the tile positions. Close, I would say it's more focused on the tile positions, but you still do need an x and a y, because you still need to draw that sprite at that exact position. Right, yes Tony? AUDIENCE Well, when you need to move the sprite, instead of moving at every update, you tween it between the two tile locations. SPEAKER 1 Exactly, so rather than moving the sprite at exact pixel positions per update, you tween the sprite when you receive input to a specific location. And then we actually stop input at that point as well. There's no use for us having any input when we're not exactly at a given tile, so we disable input while he's walking effectively. And so this is implemented, if we're looking at the distro in the entity class, there is a I believe it's in here maybe player, hold on. Oh sorry, no it's entity walk state, not the entity. Entity is just a container for the information that's relevant. So here in the entity walk state, we have attempt move. And so what attempt move does is essentially it looks to make sure that we're within the bounds of the map, right? And then if we are every entity in this game now has a map y and x, and a regular y and x. And so the regular y and x, we still need in order to draw our sprite at a specific location on the map. We still need to draw it going between 240 something and 230 something, right? But we need a map x and a map y to basically say, OK, the sprite should be at this position on the map. And then we'll just tween it between that position times 16, and it's the position plus or minus x or y times 16, which will give us the exact x and y value that we need to draw it onto the map. And so that's what we're doing here. So were going to call attempt move on input. So anytime we do any input and this is done in the player like idle, or player, yeah, player idle class player idle state. We change the animation to write animation. And then we get it's current map x and y. And then based on whatever direction the player is looking, or the entity is looking, we could use this for an NPC class, or the like. We just modify our 2x and 2y. So to 2x and 2y is going to be the value that we're tweening towards times 16, right? And so if we're trying to go outside the map boundaries, just changing us back to idle won't let us do that. Otherwise, set our map y and map x to that position immediately, right, because that's just a minus or plus one operation. And then over the course of 0.5 seconds, actually tween to that value. And we can see here, we're tweening to the tile size, and actually to the tile size minus self.entity.height divided by 2. Do we know why that is? We do that, because if we're looking at the field, we can see here, notice that we're not perfectly lined up with the grass, right? It's kind of like we're halfway above it, because it looks just a little bit more natural this way, this is how most sort of games look. And if you're in a game like this and you're like walking up against a wall for example, this will allow you to sort of look as if you're up against the wall rather than sort of being at the edge of where the bottom of the wall is, and kind of looks unnatural. Hence why we minus 1/2 our height right there. And then when we're finished, we actually test to see whether we're still pressing a key, and if we are, then change our state to walk again, which we'll just repeat this process depending on which direction we're looking at. And that's effectively it. And that's what allows us to get this grid based movement. Any questions as to how this works? Cool. Let's take a look then at the play state, let's go back to it. So we have a level, the level contains our entity, and it can contain all of our entities, and whatever objects you want it to contain. In this case, when we're in the play state as well, we're going to check to see if we press P, because that's recall, where we can heal our Pokemon, just a little game hack just to make demoing it a little bit easier. But if we press P, we play the heal sound, we take our and we'll look a little bit more detail as to this, all this in a little bit. But self.level.player.pa rty.pokemon@index1.currenthp equals self.level.player.party.pokemon@1.hp. So the difference is current HP is whatever you currently have, you could have taken damage. HP is whatever your max HP is. And this is like in a nutshell how you get like stat changes in games and RPGs, and health and mp differences. You've got to keep track of a max and a current value for all of those things, and then depending on whether you're buffed or debugged, or whether you have taken damage or not, or used spells or not, you can have an accurate reflection of where your character is and then always return back to that state whenever you need to. The interesting thing here, the slightly more complicated thing is when we press P, we want to show a dialog that says, and I'll demonstrate this, we want to show a dialog just like this one that says, we press P, your Pokemon has been healed, right? Now I can't move. I'm pressing the arrow keys. I can't move my character at all, because this dialog state we're in a new state, well, we've pushed a new state onto the state stack. And that's the dialog state here, which has taken a value. And because it's the top layer of the stack, it can't get updated, or it's being updated, and we can't update the play state, right, based on how we've modeled our state stacks operation, or how it works. And then as soon as I press Enter, it gets popped off, we've just popped it off. Now the place states at the top, I can move again. So that's what's going on. So the dialog state then is actually very similar in a sense, to the fade in and fade out state in that, notice that it takes an anonymous function. When does this anonymous function get called? Do we know? At the end of what? AUDIENCE [INAUDIBLE] SPEAKER 1 Yeah, well, when the user closes the dialog box, correct. So let's take a look at the dialog state then. And we can see, it's actually pretty simple, it's pretty small. We have a text that it takes and a callback, right? The text is used here. We instantiate, and this we'll see in detail when we start looking at GUIs, and all the widgets they've implemented here. This text box gets put at a hard coded position, and it receives this text. And then we set our self.callback to that callback function. If we have closed the text box, meaning, we're looking to see at self.textbox.isClosed, which is a function of the text box class. If it's closed, then execute self.callback, and then pop this dialog state of the stack, right? So it's similar in a sense, to the fade in and fade out, and then it takes anonymous function. The only difference is in how it gets executed. With the fade in state, the anonymous function was called at the end of the finish function, which is part of the tween object. In this case, we're executing the callback function explicitly when we've closed the text box. So we're waiting for user input versus waiting for some asynchronous operation to finish. And then of course, we call text box render, and then we'll see all of these methods shortly as part of these widgets, but at a glance, this is all that's really happening with the dialog state. Very simple, using the same pattern that we've seen of deferring future behavior to anonymous functions. Any questions as to how this works, or anything so far? Cool. All right, let's take a look back at the play state, I believe we're getting close to being finished with the play state. Yes, so everything, that's basically what the play state is in this game. And then a lot of what's going on takes place in a level as well. So in a nutshell, we have two maps, two layers, right, because the grass in the tile sheet is its own sort of [? alphaed ?] out object, it's got transparency around it. We keep a layer of the base, a layer of the grass underneath, and then a separate layer for the tall grass. And then we can just look and to see when we're walking in the player walk state when we've walked over tall grass. And then what do we need to do to start a random encounter? Yes? AUDIENCE [INAUDIBLE] SPEAKER 1 Yes, how do we initiated though? That what are we looking for? We do push a battle state as soon as we've triggered one, but how do we trigger one? What are we looking for? AUDIENCE [INAUDIBLE] player is in the grass. I don't know if it's on moving to a new grass, or if it's time spent in the grass. Yeah, we do a random chance whenever the players on grass. And it's whenever they start to walk and there on grass in this case. But you can do it either way, you can do it when they're leaving the grass, walking into the grass. In this case, it's whenever you press the button, and they happen to be on grass, it'll do a random chance, one in 10. And if it's equal to 1, 10% chance it'll trigger an encounter. So that's the gist behind triggering a random encounter, and a lot of these games really some games do it differently. They'll sometimes make it more likely the more steps you've taken, they'll like sort of keep a counter to say, oh, I've taken 100 steps, it should be a lot more likely now. Some games will just be completely random, 1 in 10, 1 in 5, depending on how the developers decided to implement their game. The former is a bit more robust. But for simplicity, we just chose, math.random10 equals 1. So yeah, we create the tile maps here, pretty straightforward. And then the actual random encountering takes place in the player walk state. So here we have check for encounter. And so what this does is whenever we enter the walk state, which is we press the button to enter, or to walk, this entire function gets called, because we do the transition to the player walk state in the state machine. All of the entities are still using just a regular state machine not a state stack. Wasn't necessary for this demonstration, though I'm sure there are some used cases for using a state stack for an entity. In this case, we're just using a regular state machine. So when we change to the walk state, we are calling enter as we've seen. And then we call self, checkForEncounter. And so self, checkForEncounter will set a flag if we have not started an encounter basically and will allow us to move. And if we have checked for an encounter, it will, or if we have triggered an encounter, it will push in checkForEncounter, it'll actually push a battle state onto the stack. So checkForEncounter just basically does what we said before. If the grass layer, because we have two layers, right, we have the base layer and the grass layer. So if the layer at yx where yx is are entities map x and map y. If the ID of that is equal to tall grass, and we have just a global constant table called Tile IDs, which has all these IDs. And math.random10 is equal to 1, OK, change the entity state to idle, so don't let them keep walking. Pause the field music rather than stopping, so that way when we come back to the field later and we press play, it will be at the exact point that it was before. Triggered the battle music, and then, we've seen this already, fade in state, push to the stack, right? So over one second, we're going to fade to white. So this will have the effect of the music starting, but we're fading to white right away, which is very sort of similar to how most RPGs do it. And then we have our callback function, which will execute as soon as the fade in state's done, right? In this case, push to battle state. Battle state takes an entity, and the entity has all of our Pokemon information, that's why we're passing that into the battle state. So the battle state can say, oh, what Pokemon do you have? OK, I'll be able to look at your party and say, OK, your first Pokemon is this, send him out to battle, et cetera, right? And then lastly, push a fade out state, right, because now we've got the battle state on top of the play state, but we want to fade into it, right? So we're going to fade, we're going to put the battle state first, and then because we're using a stack, we're going to put the fate out state on top of that, and then fade out to that, pop that off the stack. And then we have our battle state that we just pushed, right? And then self.encounterFound get's set here. And that's creating an encounter, checking randomly, pushing the right things under the stack, battle state, fade state, fade in, fade out. And then you're set to go. So that's effectively what the it's known in RPGs as the field versus the battle or encounter state. Even though we're calling it play state here, we've left the field, we've gone into the battle at this point. And so now we've seen basically everything that the field has to offer us. And we've covered everything that's relevant there. So we're going to take a break now for five to 10 minutes, and then when we get back from the break, we'll talk about GUI elements, panels, text boxes, and then we'll dive into the sort of mechanics of the battle state. All right, welcome back to lecture 7, Pokemon. So before the break, we talked about the play state, we talked about the states stack more importantly, and then we talked about how a anonymous functions are sort of the backbone to how we get a lot of this asynchronous and deferred behavior for our game, which is very common in RPGs, and I mean, a lot of genres, a lot of complicated genres of this sort. Another big key part of games like this are the graphical user interfaces, or GUIs as they're shortened to. Things like panels on the screen, things like labels text labels that move around, things like lists, text boxes, scroll bars, and you can get a lot crazier with it. In this particular lecture, we'll be talking mostly about panels, labels, text boxes, and scroll bars progress bars rather, not scroll bars. But the sort of the first I think corner or the first sort of like keystone GUI widget that we should take into consideration is the panel. So a panel is [INAUDIBLE]. So if we look at this in a game just pretend this is a panel I guess. So this is effectively all a panel is, right? It's just sort of a rectangle. It allows us to if you're looking at most user interfaces, like text boxes on your screen, or if you're on Facebook and you're looking at almost anything, like your little message window, a lot of those things at the very core, the very bottom, the foundational part is just a panel. So any guesses to how in Love2D, we can make a simple panel? AUDIENCE Two rectangles of different colors. SPEAKER 1 Two rectangles of different colors, that's exactly what we end up doing. So that's effectively how we can make a panel. There's another way of making a panel, which we won't do in this lecture, but it's called we use as a construct called a nine patch. So a nine patch is imagine taking this little image here, and it's of some arbitrary size, but it's very small. And this is very similar to how a lot of games implemented their panels or their graphical user interfaces back in the 80s and 90s, I mean, to a lot of games till this day. But back when hardware was fundamentally tile based, you could take a image like this, split it up into nine pieces nine patch is where the terminology comes from. And sort of similar to how we actually constructed the Zelda dungeon, recall, where you have corner pieces, and then a top, bottom, right, and left side. You just layer this, one of each of these, first off, right, of the corner pieces. And then however many you need of these on the sides to create this rectangle, right? So imagine we've created these are all, if we can visualize these as being a bunch of tiles, right? So just imagine that we've taken these corner pieces, these are the corner pieces, we've taken one of each of those. And then we take these side pieces, and we just like draw a bunch of them like that. And then we take this centerpiece, and then we can either layer it, or tile it a bunch of times, or just stretch it. And stretching it has a bunch of nice bonuses associated with it depending on how you've set your filter mode, love.graphics.setdefaultfilter, if you set it to bilinear versus nearest, you can actually get a nice gradient. And if you set it to nearest, you get a nice pixelated look. But you'll see this often, and Unity has nice support for this. Take an image that has maybe more complicated than you could get with just two rectangles, right? Something that actually has a design and maybe a gradient color, and actually layer I mean, create a arbitrarily sized text box to fit your needs. And if these aren't even increments or whatever your tile size is on your 9 patch, you could just scale the top, bottom, left, and right side as well just to keep it scaled, the centerpiece. So does that makes sense. So this is common, we won't be using that in our lecture, but it's a very, very common piece to a lot of graphical user interface design. In a lot of games, you'll see it a lot if you get more into game development, so it's definitely worth talking about. Another piece that we'll be talking about today is the text box. So I mean, what's a guess as to what the text box, how we can implement a text box, and how we will implement a text box? So what foundational piece can we start with? We already have yeah? AUDIENCE You just put use the love print to the screen over one of those boxes. SPEAKER 1 So use the love print to the screen over one of the boxes, exactly. Yep. So maintain a list of text items, right, text. And then just draw them inside a panel, and there's a text box. You've taken two ideas, and sort of mix them together. A selection is kind of the same thing. It's a the only difference being that with a selection so a selection is another thing if we think about, for example a menu where we have fight, and like run, and it may be in a more fleshed out game, we have like an item thing, right? So that's a menu effectively. It is very similar to what we get with a text box, but it's got a set of ingredients here, fight, item, run, which they aren't set to wrap, they're not one like contiguous set of text. It's just a bunch of items. And then nice thing about a selection is that you can have a cursor on your selection, right? And then what do we need to associate with like, for example, if we want this to actually do something, and if we think about what we've been doing so far, how do we go about implementing functionality with a selection like this? Like what needs to get associated with each of those entries in our selection? Callback function, right? Just as we've done with everything else. If you have a fight item here, each of these, if we think of the selection as being just this part of what we're looking at, right, because this background part is just a panel, we don't care about that. We care about the selection at the moment. The selection is the items and the arrow, right? When as we'll see in the assignment, your goal will actually be to take selection and get rid of the arrow functionality, because for the assignment, you don't need or want to have a selection active, a cursor active. You just want a list of things. But based on what the cursor is pointing at and when we press Enter or whatnot, we should index into the selection, and then execute a callback that's associated with each of these items. And that's how we can get behavior out of the selection, rather than just being a list of things that we render to the screen. If we have fight, and we click Enter, a callback is set to maybe push a state onto the stack that will trigger an interaction between the two entities on the screen, right? The first one will attack the second one, the second one will attack the first one. And that's sort of its own asynchronous set of states that do its own thing, but it's kicked off via an anonymous function that we've associated with each of these things, right? An item pushes another state, which is like an item mini state, where then you open up a brand new set of menus that you can look through all your items, and each of those items has a callback associated with it, right? Your potion has a callback associated with it that says, when I click on this, either by default, just restore the HP of my active Pokemon, or let me choose who to restore. So therefore, push another state, which is like a select Pokemon screen with its own set of callbacks associated with each of those. It's just in order to get all of this sort of complicated behavior that you need to, it's really ultimately just pushing states and adding callback functions to all of these different options that you can select. And then run, push a fade state, and then pop this state, and then push a fade out state. And that's really all we're doing. And so this look at all of these GUI widgets here is just sort of a conceptual look, but we'll take a look very shortly at some actual implementation. The last one that I want to look at is the progress bar. So a progress bar for example, the HP that we've seen in the actual battle where when we take damage, it goes from right to left. Any guesses as to how we've implemented a progress bar? Yes, Tony? AUDIENCE Once again, two rectangles. SPEAKER 1 Two rectangles, yes, exactly. One, and then the nice thing about rectangles in Love2D is you can set the edges on them to be rounded or not via an optional parameter. So without anything more complicated than a rectangle we can just create these sort of almost ellipsoid progress bars, very simple progress bars. Ones the red, right, the red that's the background. And then ones the outline, the black. And one is set to fill with the first parameter, one's set to line with the first parameter. Now how do we go about animating whether or not, how do we animate the decreasing amount of health when we take damage? Yes? AUDIENCE Between the width. SPEAKER 1 Between the width, exactly. And what are we tweening it by? How are we tweening it? How would we calculate how much we need to tween it? AUDIENCE Well, you could just have your width equal your health remaining. SPEAKER 1 If your width is set to equal your health remaining, then your health is maybe 10. And you want your health bar to be like 100 pixels long, how is that going to work though? AUDIENCE Multiply it. SPEAKER 1 You could multiply it, but if you know the width that you want your progress bar to be, you can just multiply the width by the ratio of the max value of your HP, or sorry, the ratio of your current HP over your max HP, right? So if you're missing if you have 50 HP, and you're missing 5 HP, your ratio is 45 over 50. And if you multiply that by your width, you get the exact amount of width that you need regardless of how wide you want the bar to be, if you want to be 1,000 pixels, if you want it to be 50 pixels, as long as you multiply current health over max health times the width, you'll get that ratio no matter what. Does that makes sense? Cool. So that's a look at all the GUI widgets that we're looking at, how they sort relate to what we're doing. We'll take a look at their implementation here. So I'm going to go ahead and open up the panel. And I'm going to move a little bit quickly so we can get into sort of the meat of the battle here. The panel is as we've said before just two rectangles, right? It takes in an xy within a height. And then we would just draw two rectangles. One is larger than the other. The bottom rectangle is slightly larger than the top rectangle. So the first rectangle gets drawn and it's whitish. And then oh, I'm sorry, sorry about that. We have a xy within a height. And then we're drawing two rectangles to the screen. We have the background rectangle, which is drawn first, which is going to be the full xy width and height of the panel. And then we're going to draw that at a white color, and then draw in the context of this game we're drawing everything at the same color, but we can change the color. If we wanted to parameterize it, we could do that. We could set, we could have a color option here in the constructor. We're not doing that, we're just drawing everything the same color. But that's how you would get like customized menus, some RPGs let you do that. And then what we're doing here is we're just within a small slightly smaller boundary. So just two pixels smaller on the x and y. Where you are going to draw the second rectangle, which is a kind of dark shade of gray. And that is a panel, that is all panel is. And then we could just have a function called toggle, which sets it to visible or not visible. And if it's visible, get rid of it, or if it's visible, sorry, draw it. Otherwise, don't draw anything when it gets rendered. So that's a panel in a nutshell. Any questions? Cool. So the next thing that we should look at is the text box. So a text box so the text box is a little bit more complicated than a panel. A text box in a nutshell needs to take in some arbitrary body of text, and it needs to chop it up based on how wide your text box is. And if it surpasses the height of your text box, right, ideally, you should page your text so that you can press Space bar, Enter and go through pages of text until you've exhausted all of your text. And you press Enter one last time, and you get rid of that text box. And so we have a panel here, which we have an xy width and height in our constructor for the text box. And we have our text as well. And then we have a font if we want to explicitly decide what font we want to use. In this case, or at large, we're going to say that we instantiate a panel at xy width and height, nothing too fancy. And then the fancyish part, the slightly more complicated part is here on line 20 where we say, underscore self.textChucks gets self.font, getWrap, self.text, self.width minus 12. So anybody know what this function does or want to take a guess? Yes? AUDIENCE Is that the page thing you were talking about? SPEAKER 1 Exactly, it's the paging of the text. Is the chunking of the text rather. Not the paging of the text, so much as is the chunking of the text, which we will use to page the text. So we take some you know arbitrarily large body of text, it can be as large as we want it to be, and given this is actually a function of to Love2D font object. So this is given to us from Love2D. Get wrap will return two values, the second of which is all of the pieces of text that the main big body is divided into based on the width. So this self.width of minus 12, that's how wide it's going to divide our text into chunks of up to, it could be slightly smaller than, because it divides it based on the word. But no piece of text will ever exceed self.width minus 12 width. And this will allow us to then render several lines of text within our text box, and they will never exceed the boundary, right? And so the paging functionality is actually in next chunks. So we call self next here at the end of [? knitt ?] function. And then self next basically checks to see, OK, are we at the end of the text? If we are, then we're not going to display any text, and we're going to close the window. We're going to close the panel. But if we are not at the end of the text, like we still get text left, what we want to do is new table. And then we're going to, up to three iterations, we keep track of where we are in our chunks, right? We get self.text chunks equal to all of those chunks, right. And that could be an arbitrary number. It can be only one chunk, there could be like 30 chunks, right? We need a counter to keep track of where we are in terms of like based on what page we're on, right, and however many lines we rendered to the screen thus far. So starting at I, and I get's chunk counter, and chunk counter will get incremented by three every time we call next chunks, which is every page. We could have easily just called this next page as well. It's going to insert into that chunks table that we just created, self.textChucks at i. And once we've reached the number of chunks total that we returned from get wrap, we're going to flag end of text as being true, and then we're going to return it. And so what this will do is, eventually, we're going to be equal to the number of chunks that we got from font get wrap, right? And once we are, that will signal with next that it's time to close the text box, because end of text will have been set to true at the end of that last chunking process. And then we can see here, when we update text box, and that whenever it's on the top of the stack, remember, we're looking for a Space or an Enter press, and then we just call self next. And that will have the effect of eventually closing our text box. And then is closed recall, we looked at that earlier, we checked to see it is the text box closed? And that's just a flag that we set here. And then for rendering purposes, we render the panel first. And then for each of our displaying chunks, so we only have up to three displaying chunks at one time, which gets set by the next chunks function. We just print that to the screen using i as a multiplier on our y. And so that will render up two or three lines, i, i plus 1, i plus 2. Any questions as to how the text box works? It's a little more work than the panel for sure, but it's fairly straightforward. We're just keeping a list of a bunch of text things, and then we're just chunking them based on how wide the text box is, the dimensions thereof. And then let's take one look at this selection. So a selection is basically, a list of text items with a cursor, right? And as I said before when we were looking at the screen over there, each of those text items has a text value and a callback function. And the callback function is what allows us to assign behavior to this selection object beyond just displaying things, right? Because when you have a menu, when you have a selection and you select something, you want behavior to happen, right? So each of these items indef.items will expect to have a callback function. And then here, when we update the selection, what we're doing is we're updating whatever our current selection is, which is just a number between 1 and the number of items in that selection making sure that if we're at one and we go minus one, that we go back to the bottom. And if we're at the bottom when we press, and we go up, we go back to the top. And we play sounds, cutesy, things like that. And then for each and for our selection here, from one to number of items, we calculate how much padding that we need. And we draw the cursor at our current selection, and then we draw each item based on i and whatever our gap width is of our panel, which we assign it to. So we divide our panel up, and then basically just keep track of where current y is and draw the actual selection and the cursor if that's the current selection to the screen. Any questions as to how a selection sort of works? Notice here, if we press Return, if our selection is being updated, self.items at self.currentSelection.onSelect. So it's expected that that item will have an onSelect function, which is that callback function. OK, and lastly, we'll take a look at the menu. And then we'll finally take a look at the battle, which is where sort of everything kind of comes together with all of this. And that'll be it. And then we'll talk about the assignment. So the menu is a panel and a selection together. That's the gist behind what a menu is in this game. You can define a menu to be a lot of things, and you can get a lot more complicated with a menu, but in this example, in this implementation, we're just saying a menu is a selection and a panel put together as one item. And we've seen it in the game, [? if we're ?] going to run it. That's just a text box. Going to look for a battle. OK, so here's a battle. That's just an empty panel at the bottom, regular panel, but now it's a text box. We push the text box onto the stack. Push another text box onto the stack. And so this is a menu right here. Notice that there is a cursor and there's a selection embedded within a panel. And each of those items, the fight and the run, those have a callback associated with them. The purpose of the fight callback is to trigger a new state where the two Pokemon asynchronously attack each other, in chain behavior one after the other. And then run pushes a dialogue, then pushes a fade state, then pops both of them, and then pushes a fade out state and puts us back to the play state. So that's effectively what's going on and that's an example of what the menu looked like. And so a menu, just a selection with a panel put together. When we draw the menu, we draw the panel and then the selection. And then when we update the menu, we only update the selection, because that's all we care about. And that's basically it. And so the menu itself will get a def, that def should have items, that items will get passed to the selection. That's pretty much, that's it for the oh, progress bar as well. We'll look at progress bars when we get to the actual battle state. So now, let's take a look at a few of the classes and data structures that are pertinent to the Pokemon themselves. So if you look at party as are first class, very simple class, literally just this self.pokemon is def.pokemon is just a container at this point. You can take this I mean, even in I think a fully fleshed game, you wouldn't really need much more than just this. But if you needed to expand upon this idea at all and you know preserve metadata that exists for the party, this would be a perfect way to do it. The actual pokemon class itself is not a whole lot more than effectively a bunch of stats. And that's a lot of what an RPG is. This genre is it's mostly just numbers. You're just comparing numbers against numbers and then adding a roll of the dice. That's effectively, that's what Dungeons & Dragons, a lot of it is. And that's yes? AUDIENCE Would it make more sense to store just delta per level and your initial one, so you can have fewer variables? SPEAKER 1 Say it one more time. AUDIENCE Wouldn't it make more sense, instead of storing your HP and everything for each level to store your initial stats in each area, and how much you would go up per level. SPEAKER 1 Would it make more sense to store the amount that you go up per level for your Pokemon? Yes, that is what we're doing. So we have a base so here's how the split works for the stats in this case, right? We have base HP, base attack, base defense, and base speed. A level 1 Pokemon has a level 0 Pokemon has these stats of this species, right? Every Bamboon or whatever Pokemon that we choose will have whatever we've allocated it to be it's base HP, base, attack, base defense, base speed. And then the thing about Pokemon and I mean, a lot of RPGs will sort of do this thing, but we need some way of leveling up the Pokemon in an necessarily nondeterministic way. Like two Piggies that level up may not have the same stats, right? One might have slightly higher attack than the other, one might have slightly higher defense than the other. We do this using what's called an IV, and that's what Pokemon itself does. And it's short for individual value, this is sort of like the DNA of your Pokemon, right? So this HP IV is separate from your base attack, base speed, base et cetera. And this basically, it gets compared against a dice roll every time you level up three times. And this is how I've programmed it, it's not necessarily how Pokemon itself does it, but you will roll a dice six times, or three times, one through six like a normal die. And you'll look to see if that roll is greater than your IV, right? Or it'll check to see whether your IV is less than or equal to that dice roll. And if it is or sorry, if it's greater than or equal to that dice roll. And if it is, it will increment that stat by 1 for those three dice rolls. So you can get up to three more, or you can increase the stat by up to three times per level. But you can only have an IV up to five. So you're rolling against a six, and you will occasionally not roll a 6. It checks to see whether or not the IV is greater than or equal to the dice roll. And if it's not greater than or equal to the dice roll in the event that it is a six, or if the IV is up to a four for example, which means a five or six will go against it, then it will not get a stat increase. And this is a sort of simple way of implementing this DNA based system. It's randomized, but it's a weighted, right? If you have a higher IV, you have a higher likelihood of being greater than or equal to the dice roll. And so that's how we implement stat increases. And then we need a way of keeping track of what our stats are, like our actual stats. So our actual HP, our actual attack, our actual defense, and actual speed that's been calculated level by level, we need a way to keep track of that. We need level, we need our current XP, and then we need our and the amount of XP to gain a level, which will get higher and higher per level, as you can see here, because it takes in the self.level times self.level. And then it multiplies that by five times 0.75. And then your current HP. So we're really not storing our value level by level, we need the base because we need to know what our base was. I mean, we could effectively globally reference these variables, but it's minor efficiency gains at that point. But we need the IVs and we need the I mean, we need a reference to the IVs, we need a reference to the base HP, and we need to keep track of whatever our actual stats are, and then our current HP always, because our current HP can differ from our actual HP. And in the actual game, you can have your attack, defense, and speed also vary match by match, because you have moves that lower your speed, lower your attack, lower your defense, et cetera. In this case, we haven't implemented that, so we don't have a current attack, current defense. But in a more complete implementation, you would have that sort of thing. Does that sort of answer your question? Is that in the right vain? OK. And so here's the level up code. So like I said, three dice rolls, one to three. If six is less than or equal to our IV, so it could be a six, in which case, it would be greater than what are max IV could possibly be. IVs range from one to five, but if it's less than or equal to that IV, then we're going to consider that a stat increase. It's a weighted odd to determine whether or not we get a stat boost. And it does this for every stat, and then it returns all of the increases. And this is relevant, this line 95 for a return HP increase, return attack increase, defense increase. This will be relevant for assignment 7, because your goal is to take these increases and actually display them to this user in the battle state when he gets a victory, or he or she gets a victory and has gained a level. You will display a menu with a selection that has all of these things, and you'll need this value. So it returns these values here, and you'll be calling this function any way from your battle state stats level up. Or we'll be calling level up rather, which returns self stats level up. And that's all a Pokemon is. It's effectively mostly a data structure. And we use this in our battles to throw dice effectively back and forth, and have a victor and a loser, and then gain XP and gain levels that way. So any questions as to how a Pokemon object class works? Cool. We'll take a quick look at what the actual definitions look like, which you can probably take a guess. It's very simple, just key names. And then we have the actual name, we have the sprite names, we have the HP, attack, defense all the things that get put into the actual object, they need a reference to in the definitions. And so Pokemon ultimately are just this, they're just data, right, which is what we talked about in a prior lecture, data driven design. The more you can take all of your Pokemon and make them into, or anything, Pokemon or any object, and turn it into an easy to write data structure like this, the easier it is for you to add more. We could easily add, it wouldn't take too long to create 150 of these. I mean, they wouldn't be all that interesting, because we don't have moves implemented yet. But in an ideal world, we'd find a way to also model moves as data, and therefore, you can just link moves to your data structure, to your Pokemon object like this. Yes Tony, did you have a question? AUDIENCE Well, I just wanted to mention that the paradox games are very good about that. [INAUDIBLE] SPEAKER 1 Oh, like Crusader Kings? AUDIENCE Yeah. SPEAKER 1 The comment was Paradox Games are very good about data driven design. I'm assuming you've dug through their files? AUDIENCE To some extent, and also it's just if you play their games for awhile, it's everywhere, like to the extent that sometimes on the Wiki, they put the source code up. SPEAKER 1 Oh, yeah. Yeah, no, it's just good game design. Ultimately, if you want to and their games are large, they have a lot of content. If you want to have a lot of content in your game, you need to find a way to take the burden off the programmer and put it onto the designer, or at least make it easier for the programmer, because making source code and debugging source code all day long, especially for very complicated things is not easy. And it's ultimately not a desired thing to do, right? It's a lot easier for me to whip up a new creature in 10 lines of code here and feel good about it than hard coding a lot of these sort of things, right? So shifting as much of it to data as you possibly can should be your end goal. So that's what Pokemon defs look like. Before we get into the actual battle, we want to take a look at what a battle sprite is. So a battle sprite is what was rendering onto the screen, right? So we take a look here. That's not a battle sprite, but almost a battle sprite. That was just a texture. So if we get into a battle, slowly but surely. All right, so these are battle sprites, and they don't look much different than a regular sprite, and they're not that much different than a regular sprite. But they have some functionality that's important, mainly that functionality where one is flashing, and then one was being opaque, right? So in order to do both of those things, we need to store some sort of data within our sprite, right? Yes? AUDIENCE Zelda for the invulnerability flashing. SPEAKER 1 Yes, exactly. For what we used in Zelda for the invulnerability flashing. For the enemy, or I should say, for whoever is getting attacked, yes. They are getting an opacity flag stored. They have an opacity flag stored in their object that we can tween, right, we can tween on and off over the course of time. That's what we did with the entity in Zelda when it took damage. And we set it to invulnerable, and while it was invulnerable, it was flashing on and off. But we can't necessarily do that with the sprite that's blinking white, because there's not really a like white flag, right? We can't make something completely white with just a flag. That's something that we actually need to use a shader for. And so a shader, and we're not going to get into too much detail about this, shaders are pretty complex, a little arcane at first. But what they are is effectively a little program that runs on your graphics card, and that looks at when you're drawing something, it looks at every pixel depending on what kind of shader you're doing. But for the sake of this demonstration, we'll look at every pixel that you're drawing to the screen, and perform some sort of function on that pixel, and produce a new value, right? And this is how you get a lot of really crazy awesome things to happen, but it can be pretty insane. Shader Toy, I think is the website that has a ton of really cool I'm not going to pull it up now, just 'cause I don't remember the name, I believe it's shader toy. There's a website where people post all the shaders that they've written, and you can see a lot of really crazy stuff, things that you would never imagined were possible with just code like this effectively, looking at positions of pixels and [? pictures ?] on the screen and whatnot. But effectively what this does, this is a white shader, the goal of this shader is to just turn a sprite completely white. That's all the goal of this shader is. So it gets a float called white factor, which [? you'd ?] say here. And then white factor effectively is just going to be summed onto whatever the RGB is of that pixel, whatever pixel that we're drawing when the shader is active. What that has the effect of doing is, white factor, if it's equal to 1. Here's the thing about shaders and a lot of this stuff, a lot of the data structures within shaders are based on floats that are from zero to one. So if we assign the RGB of something to a vec 3 that's 1, which is 111, that's going to be 255, 255, 255. Therefore, that pixels RGB is white, pure white, right? And so what we're doing here is on our battle sprite, self.blinking and one or zero, remember, that's the LUA [? turnerri ?] operations. So we're saying, if self.blinking is true, one else zero. So send our shader white factor based on whatever value self.blinking is. And so that will have the effect of the shader getting a one or a zero, and adding a one or a zero to the RGB of that sprite. And if blinking is set to true, the sprite's going to basically be drawn every pixel at 255, 255, 255. Otherwise, it'll get drawn with whatever that image's pixel value is at that position. Does that makes sense? OK. The syntax is a little bit weird, but that's what's happening here in this shader. And there's a link here where I found the shader, but it's a very simple, very simple shader, probably like one of the simplest shaders you could write. But it's a great example of what you can do with a shader, and pretty simply. And it's nice, because you can take like texture coordinates and do math based on that, or pixel coordinates and do math based on that. You can pass in like a sine function for example, in your file, and have that sine function perform work on like RG or B value of your sprite and do all kinds of cool stuff. It's really neat, like the possibilities are limitless with shaders. But that's how we get it to blink, because you can't do that outside of this I mean, there's probably some weird way could get it to work as well, but this is probably the simplest way we can get our sprites blinking white. And so self.blinking just gets a timer.every0.1 or whatever. We'll actually see that in the attack state. But that'll flick to self.blinking between true and false. It'll negate itself over and over again. All right, so that's the battle sprite. Last thing we'll look at is another extremely simple class, opponent. All the opponent is is it has a party, that's it. But in a fully fleshed game, your opponent might have a like trainer sprite. A message that it says, like a full party of Pokemon, a gold value that will give you when you defeat it, all kinds of things. But it's here just as a simple illustration. Yeah? AUDIENCE [INAUDIBLE] put a method for on defeat if you want to maybe have it kind of collapse the room or something like that. That would be another thing that you could do. SPEAKER 1 Oh, a method? Yeah, we can associate a method with an opponent called on defeat, or whatnot that will do arbitrary things, collapse the room, or otherwise. Yes, absolutely. Or even push a new state, like to like teleport us to a new location in the world map. Maybe we like cleared the elite four and we want to get teleported to like the end credits, exactly. Limitless possibility. So let's go ahead and take a look now while we have just like 20 more minutes or so left. We'll take a look at the battle state, because the battle state and the states that they're in are probably the more complicated side of how this works. So a battle state, we have a player, we have a bottom panel, the bottom panel for when we start the state just for that part, but otherwise, we're always pushing things onto it. Whether we've started the battle or not, because when we are fading in sorry, yeah. Because when we initialize this state, we also push a fadeout state onto it. But we don't want to trigger the tween of the Pokemon sliding from left to right until after that state gets popped. So we have a flag here, which will get set to true on the very first update iteration. And then when that gets set to true, we'll actually tween the Pokemon going left to right, and kick off all the other sort of asynchronous processes that exist thereafter. But let's look at the battle one more time just to see what's going on. So I'm going to walk until I get into a battle. OK, we got a battle. So notice here, the fade in happens as soon as the the slide in happens as soon as the fade starts, right, as soon as the fade finishes, I should say. We get a message popped onto the screen, right? It says a wild X appears. Right, that's the enemy Pokemon. We hit Enter. Turn this down a little bit. We hit Enter, and then we pop another push another state onto the stack, another battle message, which is very similar to a dialog state. Says go our Pokemon. And then we push a menu onto the screen, right? We've got a menu that says, fight or run, a selection. It's a menu, which has a selection. And then now, this is the top of the stack, right? So it's the only thing getting input. Everything else is rendering beneath it, but nothing's getting input. So we have the option to either fight or run. Let's say we fight. We fight, we got a new state now, we're in an attack state. Several things just happened. So what happens as soon as we kick off the attack state? Yeah? AUDIENCE You get a text box saying, x attacked y. SPEAKER 1 Yep, so the first thing we have happened is, a text box that says, x attacked y, where it could be either us or the opponent, because it's based on whoever has the higher speed. And then what happens next? AUDIENCE [INAUDIBLE]. SPEAKER 1 Well, it does. So let's take a look at it right now and tell me what exactly happens as soon as the text box pops up. So what were the pieces that happened there? AUDIENCE Flash. SPEAKER 1 OK, so the attacker flashes white, right, which is the shader that we looked at. That's the shader blinking on and off. There's some timer that says, every 0.1 seconds, blink on or off. And then what happens? AUDIENCE Then the damage is dealt. [INAUDIBLE].. SPEAKER 1 Well, damage is dealt, yes, but what happens visually as soon as the white blinks? AUDIENCE The other one blinks. SPEAKER 1 The other one blinks. What's the other one blinking? AUDIENCE I'm not sure. SPEAKER 1 So it's opacity, right? So remember, we're doing the exact same thing we just did with that white, with the blinking, but we're tweening every 0.1 seconds the opacity of the defending Pokemon. And then we take damage. Then what happens when we take damage? AUDIENCE The reverse basically. SPEAKER 1 Well, what gets animated when the thing takes damage? We've animated the blinking, we've animated the opacity. AUDIENCE [INAUDIBLE]. SPEAKER 1 The health bar drops, right? So we're chaining several things together. We're chaining first, we're doing them every 0.1 seconds for six times, blink white. Then blink the other thing opacity, right? And we're playing sound effects at the same time too, we're playing a sound effect for the attack, sound effect for the hit. And then once that's finished, tween the health bar, right? So we've modified the health of the defending Pokemon. And then what happens after the first one, after that process is finished. AUDIENCE Repeat for the other side? SPEAKER 1 Exactly, repeat the exact same thing, but for the other side. But what are we doing in between each of those? We have to do something. AUDIENCE Checking if somebody dies. SPEAKER 1 Checking if somebody dies, exactly. And if somebody dies let's say we die, what happens? AUDIENCE [INAUDIBLE]. SPEAKER 1 Well, we yeah, we go back to the play state. We fade out to black, and then we go back to the play state. What happens if we knock out the enemy? AUDIENCE Go to this screen. SPEAKER 1 Exactly, and what happens on this screen? So what's the first thing that happens? Well, so recall, what happened when the Pokemon died? What happened? AUDIENCE It fell off its platform thing. SPEAKER 1 Exactly, so that's a tween probably, right, on his y value. Then what happens? AUDIENCE [INAUDIBLE]. SPEAKER 1 Exactly, we've pushed a battle message state onto the screen. And then what happens when we press Enter? AUDIENCE [INAUDIBLE]. SPEAKER 1 What just happened right there? AUDIENCE [INAUDIBLE] text box that says, you earned whatever experience points. Then you get your XP goes up. And presumably, it checks if you leveled up. SPEAKER 1 Yes, correct. AUDIENCE [INAUDIBLE] to level up. SPEAKER 1 Exactly, so when push a dialogue to the screen that says you've earned x experience points, the XP bar tweens, right? We've gone up to however our ratio of current XP to next level XP is. We animate our text bar that way, or progress bar that way. Then we push a fade in state, right, to white. And then we have to pop everything off the stack, and then push a fade out state to the top of the stack, and then we're back to the play state. But if we do level up, we need to play the right music, play the right sound, and then part of the assignment will be actually, in that exact function, you're going to need to add some behavior that will do what? AUDIENCE [INAUDIBLE] display the change basically, and what the new one will be. SPEAKER 1 Yes, and what are we going to need to do. What will we need to do in order to? AUDIENCE [? Explain, ?] what was it called? The selection box, but without the selection part basically. SPEAKER 1 Yes, so once we've taken once we've leveled up and we're in that victory state of the battle state, right, we need to push a new state, a new menu state, which has all of those stats and the amount that they've increased. And then when we press Enter, presumably, we should pop that off, and then pop everything else back to the play state, and then do the fade in as normal. And that is the battle state in a nutshell, a lot of pieces that sort of are waiting on each other and input and stuff like that. But fairly easy to understand, just because a lot of it is very simple things that are just chained together over and over again to produce this sort of interesting behavior. So here we have sprites, recall the sprites are what we're going to need to animate those. We have health bars, which are progress bars, which are just two rectangles that are ones a line, a black line, and ones a fill that fills beneath the line, so that we get a sense of how much is missing, right? We get the width, the height, a color. We can give our progress bar any color we want to, which is how we get the difference between, say, a health bar and an XP bar. We just make one red and one blue, and we draw them in different spots, right, but they're both equally progress bars. And then they get a value. Their value is whatever sort of determines how much of the rectangle is scaled. And the max is how much that should be divided by in order to produce a ratio for the total width a scaler for the total width, which will allow us to get the sense of an amount missing. And then a player circle x, opponent circle x for the ellipses, just the graphical details for the actual Pokemon, so that we can get their stats, so that we can actually do dice rolls, or not really dice rolls in this case, but so that we can add or subtract HP based on attack and defense. And so here was the update, so trigger slide in. So what trigger slide in does, is a one second tween, which you talked about, right? The Pokemon going left to right, or left to right, right to left. There x values, just tweening in over one second. As soon as that's finished, we're going to trigger starting dialogue. So the starting dialogue is push a battle message state onto the stack. The battle message state is just like a dialogue state in that it gets a string here, so a wild something appears. It gets a callback function for once we press Enter on that. And the callback function is itself another push of a battle message state that says, go, and then our Pokemon. So notice that we're referencing the self.opponent.party.pokemon there, and self.player.party.pokemon there to get the actual name. And then once we've popped that off, then we push a battle menu state here, right? So let's take a look at the battle menu state. So this is interesting, because this is where we actually define the behavior for our menu works, right? Recall, we need something to tells us what happens when we press Fight, and what happens when we click Run. So when we click Fight, notice here items, right, self.battlemenu gets menu, and menu expects items. This items key, this table gets fed right into the selection, right? And the selection, it expects remember, a text, because it has to know what to render at that index. And then an on select function. And that on select function is the callback that gets executed when you press Enter at that particular location in the menu. In this case, fight, what that does is it pops this battle menu state where we no longer need the menu, so pop it. And then push a new take turn state. And then take turn state in this game is the Pokemon fighting each other, that's what the take turn state is. And it could have been called fight state, for example, but take turn state is a little more versatile. If we wanted to maybe make, maybe one Pokemon wants to run, the enemy wants to run and we want to fight, right? But you can't always run, so they should try to run, and then we can still fight them. Or they can use an item, or we can use an item, right? There's a lot of different things you can do. Or we want to throw a Poke ball at them, and if we fail, then they should fight us, right? Take turn is just a general purpose state that we could repurpose for whatever use we want to with any interaction between us and the opponent, whether it's fighting, running away, or using items, catching them, any of these combinations of things. But in this case, for the sake of this example, for simplicity, we've only implemented fighting. The we and the opponent fight each other during this state, which is, one attacks the other, and then we check for deaths in between both of those. And then go to victory or feinting depending on which of those holds true, if either. Running is slightly different. So if we run, I've programmed it to be 100%, it will 100% of the time work. In Pokemon, you actually have a chance to run based on what the delta is between you and your enemy. So if they're stronger than you, you actually aren't guaranteed to run away. So what we do here in my implementation is, we just pop the battle menu, so it's gone. And then we push, you fled successfully to the screen, this battle message. But there's a difference here versus the other battle messages that we've shown. I mean, it's not really different, but it's something to keep in mind. So I'm going to get into a battle. And so first of all, with that message that you just saw on the screen, I had to actually press Enter, right? I discarded it explicitly by pressing Enter. And that holds true also for these messages. It won't do anything until I press Enter. So I press Enter, and then I press Enter, and it does it's thing. But notice the difference between when I hit Run. I'm going to hit Run, I fled, and it does it on its own. It's not waiting for input, right? So how have we implemented that? Yeah? AUDIENCE Using timer, you'd automatically do it the same way you would afterwards, instead of waiting for you input, you just wait for the timer to end. SPEAKER 1 Exactly, so we use a timer, and then when the timer is finished, we pop the battle message just like we would have popped it by pressing Enter. This false flag is what allows us to do that. We press false and false is, can we input or not? And we can't. So actually, if we didn't do any timer thing after this, and we just did that false flag, the battle message would be there forever, and we could never get rid of it, ever. It would get stuck forever. So we got to be responsible and say, OK, we're going to put a timer, we're going to call timer.after 0.5 seconds immediately after that. We're going to push a fade in state. And then we're going to do these two pop operations here as soon as that fade in happens. This first pop will pop the message, right, this message here that we didn't pop through input. So this is actually garbage collecting, in a sense, for us. It's discarding the message that we couldn't discard automatically. And then we're going to pop the battle state, right? So running will push the battle message, trigger a timer tween for our timer.after five seconds, sorry, push a fade in state. And then after the fade in states done, then pop both of those states. The message and the battle state take us back to the play state. And that's where we'll be as soon as that's all done. And that's all that's in the battle menu state. Any questions as to how the battle menu works, the difference between fight and run and sort of how those operate? OK. So let's take a look then at the take turn state, which is the last piece and the largest piece I would say. This is the most relevant to the assignment. So we maintain a reference to which Pokemon is first or second to go, which sprite is first or second to go, and which progress bar is first or second to go up here. And we do that, like I said, based on speed. So whichever Pokemon is faster, and we could have also made this a little bit shorter, just by keeping the sprites and the progress bars as members of the Pokemon object, or the class, but since they're kind of separated, like we don't necessarily want a Pokemon to have a reference to it's progress bar at all times, or I mean, you could. There's nothing preventing you from doing it. It would only serve the purpose of shortening this code here. But we need to keep a reference to this so that we can call attack here, which is this large bit of code twice, without needing to duplicate all of that code twice. Does that makes sense? So Tony, did you have a question? AUDIENCE Well, I was just thinking, you could probably put that into a helper function where you just change the order you pass it in. SPEAKER 1 Sorry? Say it again. AUDIENCE I just kind of feel like, I guess you could take the code, and you could avoid duplicating that I guess. 'Cause it's just reversed, so what you could do is you could if you passed into a helper function, which you would just, instead of passing it first instead of passing it, opponent Pokemon, player Pokemon, you would pass it, player Pokemon, opponent Pokemon. And that would probably work I think. SPEAKER 1 Well, you also have to take into consideration so the comment was, you could pass in the player Pokemon and the opponent Pokemon into a function, and then you reverse them in that function, I'm assuming, have reverence them and reverse them. But the sprites are decoupled from the Pokemon, and the progress bars are also decoupled from the Pokemon. So we could shorten this by making these four things here fields of the Pokemon objects, but they're not strictly pertinent to the operation of the Pokemon object. And it sort of kind of makes the Pokemon objects a little too, not basically abstract or lightweight enough, and it only serves the purpose of this point, of just shortening this bit of code. There's probably a more elegant way to do it, but it's hard to say. If this code were to get larger, maybe. But the gist of this is basically to have a pointer to whatever Pokemon, progress bars, and sprites should operate first in the attack versus what should operate second. And then the two will trade blows in order based on who's first and who second. So when we enter the take turn state, we're going to trigger that attack, here this function attack, which we'll take in first, second, first, second, first, second for the Pokemon sprite and progress bars. And then anonymous function, which get's executed as soon as the attack is finished, right? So this is a code that will pop a message that gets pushed in attack, and then this is where we actually check deaths, right? And it will determine whether we go to victory or faint screen or not. If not, and we return if so. If not, we're going to do another attack, but see, everything is reversed now. Now it's second, first, second, first, second, first. So we have the same function, self attack, which just takes in the attacker. And it's effectively, attacker, defender, attacker, defender, attacker, defender for the Pokemon sprites and progress bars. And so the attack function here first pushes a well, OK. What does the attack let's go over it one more time. What do we think the attack function does in order. We covered them just a moment ago, but what was the order that happens when something attacks another thing? Yeah? AUDIENCE The attacker blinks white. SPEAKER 1 Attacker blinks white. AUDIENCE Then the defender blinks opacity. SPEAKER 1 The defender toggles it's opacity. AUDIENCE And the health bar shrinks. SPEAKER 1 Health bar shrinks. Exactly, and then that's basically it for attack, right? Blink, play a sound, blink, play a sound, shrink the bar, and also we're doing damage in that function as well. We actually have to change the status of the Pokemon. So this is effectively where it starts, right? We place a battle message state onto the stack that says, the attacker name attacks the defender name. Notice that it gets false just like the run message did, because we're not accepting input here. But it's up to us actually, it done up here at line 42 of the enter state. But we're going to after 0.5 seconds, play the attack animation. So power up sound every 0.1 second. We're going to member the blinking flag on the sprite, we're going to toggle it by setting it not to itself. So if something is not itself, if it's a truthy value, it becomes falsy, if it's falsy, it becomes truthy. So basically, toggling between true and false. Limit of six, right, because remember, every will do something every amount of time indefinitely, unless you pass in a limit of some value, in this case, a limit of six. So we're saying, only execute this code six times, only blink six times, right, only toggle six times, blink three times, right, because it has to go on and off. And then as soon as those six iterations are completed, we call the finished function on that timer object, which takes an honest function. As soon as that happens, we do the opacity bit, right? We blinked the attackers, so now we've got to blink the defender. So we play the hit sound. We do the exact same thing that we just did for the blinking, only now, every 0.1 second, we are setting its opacity to either 64 or 255, depending on what the value of its opacity is, right? So we are toggling between 64 and 255. Limit of six, take a function, calculate damage, which we've just very simply done it, attack minus defense, right, up to 1 though. So if the defense is actually higher than the attack, which will still do at least one damage. And then over 0.5 seconds, we take the defenders bar, and we tween the value equal to their current HP minus damage, right? And then that will set in the bar, in the progress bar, it'll set its value. And even though the progress bar is behind state wise, right, it's on the bottom of the stack, because it's on the battle state. And we're in currently the take turn state, but because we're still manipulating the values of that state, and we're rendering every state, we're actually still manipulating that state regardless of the fact that it's not on the top of the stack. So that allows us to shrink that Pokemon's progress bar regardless of it being on the top of the stock or not. Then once that's finished, once the tween is finished, actually set the current HP to that amount, because we're only tweening the progress bar's value, which is independent from the Pokemon's value. And then that's the end of the attack. The attack is completely finished at that point. So any questions as to how the attack works? Just a chain of tweens basically. So we do an attack, then check deaths is the next function. And we're almost finished, I'm going to kind of go quickly here, it's at 730. Check deaths is the player Pokemon current HP less and equal to 0, or is the opponent Pokemon current HP less and equal to zero. If the former's true, we need to faint, and if the latter is true, we need to go to victory. So faint is effectively a battle state, right, when it says, you fainted. And then what? Remember what happens when we faint? AUDIENCE [INAUDIBLE] text box, and then it leaves. SPEAKER 1 It leaves, do you remember how it leaves as it differs from like running away, for example? AUDIENCE [INAUDIBLE]. SPEAKER 1 Well, beyond that, aesthetically, do you remember how it's different? AUDIENCE [INAUDIBLE] differently to black, I think. SPEAKER 1 It does. It fades to black instead. So that's how we can differentiate when we're fainting versus when we're running away. And so that's what we're doing here. Notice that the fade in state RGB is zero, all of those. So it's going to fade in to 000255, as opposed to 255, 255, 255, 255. So it's going to be a black fade in versus a white fade in. And then once we've this it just sort of a thing that I implemented so that we can keep playing indefinitely. But once that's finished, restore the player Pokemon to full health, resume all the field music stuff. And then once we've pushed a fade out state, 000, and then we've gone back to the field, let's push. Notice that here it takes a function, right, after the fade out state's done. Once the fade out is finished so as soon as we're back to the play state, push a dialogue state that says, your Pokemon has been fully restored, try again. Which will take the context, and we'll [INAUDIBLE] to press Enter to get past it. That's fainting. Victory is a little bit more robust. So victory is do you remember what happen when we get a victory? AUDIENCE Well, it has to check leveling up as well. It says, you've defeated your opponent, then your XP bar increases. Then if you've leveled up, it tells you that you leveled up, and then it leaves. SPEAKER 1 So it tells you you defeated your opponent, XP bar increases, checks for a level up, and then leaves. After displaying the level up message or not, it leaves. It pops everything back to the play state, exactly. So remember, the very first thing that happens though, the opponent sprite gets tweened over the course of 0.2 seconds, it's y value to virtual height, which means, all the way to the bottom of the screen, right? The typical defeated your opponent from Pokemon sort of animation. Once that's finished, play victory music, push a battle message state that says, victory, right? Once that's popped of the stack, calculate the XP, which is, I just chose arbitrarily sum all the IVs of that Pokemon times it's level, and that's the XP you got. Push a state that says, you earned x XP, right? It's false, so that means it doesn't take input. So that means it's up to us in order to pop that off the stack. So after 1.5 seconds, we play a sound, and then we tween that XP bar going up, right? So that's what's going on here, self.battleState.playerxpbar, we're tweening of the math.men, of the XP plus XP, or XP to level, because if we don't, it could go past the edge of the XP bar, because we could go over our XP to level, right? Let's say we have 10 XP till we gain a level, we could gain 20 XP. We'd be 10 XP overboard. So we don't want to tween our XP bar past the edge of the XP bar, it would be a graphical glitch. So a math.men our XP plus XP, and our XP to level, which will take the lesser of the two values. Once that's done, it's tweened, we're going to pop the message off, and then we're going to actually add the XP, level up. So this is where we level up if the XP is greater than XP to level. Play a sound, set the XP to the current XP minus our 2 level XP, which will mean that we'll have some carry over, right? And then actually call the level up function. Now here is where oh, and also after that, congratulations, you've leveled up. Fadeout white, which is just a white fade out here. I used it twice, so I made a function for it. Just pushes a fade in state. Stop the victory music, play the field music, pop, push a fade out state. So either way, when we've got a victory, we're going to push a fade out white, or we're going to call fade out white, correct? So push a battle message state, and then as soon as we press Enter, because we leveled up, fade out to white. And if we didn't level up, but we still got to victory, we still need to fade out white. And so this is where your assignment is, assignment 7. Assignments 7 is, notice that we have self.playerPokemon level up. The key thing that we are going to need to do here is add a menu that shows us how we leveled up. And if you recall, playerPokemon level up returns all the stats that you've increased this level. So you can show a menu that just says, your HP plus that amount, right? You're going to get all four values. It's going to explode to all four of those values. And then you're going to create a new battle or not new battle menu, but a new menu of whatever you want, but probably on the right side of some vertical height for items. The only difference here, the only key thing that you're going to take into consideration is, and I'll go back to the slides, because we're actually done at this point going over the code. But the selection items, you won't be able to actually select anything, it's just going to be purely visual. So you're going to need to edit selection to have the option to not have a cursor. And this is detailed in the spec, which was actually released before lecture today. So you can take a look at that. But you'll need to make a change to selection. But all the pieces are there. It should be a fairly easy assignment as long as you understand how the states work, how the menu works, and how to create a menu based on those values, and how to actually get the values from level up. So some missing features that we didn't talk about, which we didn't implement are, for example, the detailed level of screen, which is your assignment, monster catching, right? We only have a party of one Pokemon throughout this whole entire thing, but one of the arguably main appeals of the game is to be able to catch more. So that would be something to add, to prioritize probably adding to the game. A field menu so can actually look at all the Pokemon you've caught. That would be nice, so you can actually see how much HP they have. In item inventory, because the game, the regular games have items. You can use potions, you can find gold nuggets that you sell for a ton of money. Different abilities, currently we only have basically one fight operation, which is like a tackle. And the game itself, the regular game has like over 100 different moves that have elemental attributes, and do different things, and cause status effects, buff you or your opponent. So adding those is appealing, and maybe being able to represent them as data is nice to. Trainers that you can encounter in the game that have their own preset or randomized Pokemon for to fight. Monster evolution, because that's like one of the funnest things is taking a really weak Pokemon, and like raising it to become really strong, and evolving it at a certain level. Towns, routes, other levels beyond just our basic square area. Monster breeding, which is introduced in the second series, so that you can take two Pokemon and have a chance to get an egg with really good stats or a really rare Pokemon from it. And then like a day night cycle maybe where different Pokemon come out at different times of the day. So you are incentivize to play at different times of the day for that purpose. But that was it for Pokemon. Next week we'll actually be diving into Unity. So we're actually done with LOVE 2D, which is a lot of fun, but now we'll be going into how to make 3D games. So this is a screenshot from the game we'll be making next week, which is a 3D sort of side scrolling Flappy Bird esque helicopter game based on a famous web game called Helicopter Game. And it was sort of one of the early ancestors to Flappy Bird. On the Wikipedia page, it actually says that too. I remember playing, it was back in like 2007, or 2006, or something like that. But your goal in this game this is a modified version of that your goal is your everything is 3D, but it's a side scrolling perspective. So this is called 2.5D for that reason. You're controlling a helicopter, you're the purple helicopter. And your goal is to in an infinitely scrolling world. So we'll revisit infinite scrolling, but in 3D, avoid skyscrapers. So you can see there is a green skyscraper, crudely modeled. Collect coins, so you can see there's a coin there, it's a 3D coin, it will always be spinning. Your coins are up at the top right. You'll see a background that's infinitely scrolling. And then you'll have jets that will randomly fly above you to sort of give you another sort of layer or dimension of obstacles to watch out for. And this will teach us a lot of the basics of how unity works, so we can start getting into even more interesting things like a first person like sort of core exploration game. And then lastly, when we end the semester with Portal, we'll look at a couple of fancy things there. But that was it for Pokemon. Thanks for coming, and I'll see you guys next time.
