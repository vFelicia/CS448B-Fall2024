With timestamps:

00:00 - Hey everyone, my name is Andrew Kubo. And I 
will be your instructor for this blockchain  
00:04 - development course all about querying data on web 
three decentralized applications. In this course,  
00:11 - you will get an introduction into indexing 
and querying data on the Ethereum blockchain,  
00:16 - and understand why querying data on decentralized 
networks is so different to what we are used to  
00:23 - on the traditional web. Goodbye HTTP requests, 
hello, some graphs. We will be doing this with  
00:30 - some explainer sections, as well as some hands 
on experience by building your own querying  
00:35 - technology. By the end of this course, you 
will have the knowledge to query data from  
00:42 - the Etherium main net, as well as a variety 
of chains on the hosted service in order to  
00:49 - build your own decentralized apps. This course 
is made possible with a grant from the graph  
00:55 - creators of the tool we will be using in this 
video. But first, let's cover just exactly what  
01:01 - we will be looking at in this course. First off, 
we are going to start off by looking at the graph,  
01:07 - a decentralized protocol for indexing and querying 
data from blockchains. This will include why it  
01:13 - was built in the first place and how to use it. 
Next, we will move on to looking at some graphs,  
01:20 - which are open API's. We'll discuss how sub graphs 
help you get the data you need to create and power  
01:26 - your own decentralized applications or Dapps. We 
will then move on to the more hands on approach  
01:32 - and cover how to build out subgraph with a step 
by step tutorial, then move on to how to query a  
01:38 - subgraph from a front end application, and how 
to manage your API keys. Once we have built a  
01:44 - subgraph, it will then be time to put it to 
some good use and make some queries with it.  
01:49 - Using tools such as the Graph Explorer, 
which we will go into how to use together,  
01:54 - you will be glad to know that this course will 
take a very beginner approach. So this is your  
02:01 - first time working with Blockchain related topics, 
you are in safe hands. The only prerequisites  
02:08 - I ask of you before starting this course is 
to have a basic understanding of JavaScript,  
02:13 - no GS and Graph QL. However, if you're not 
super familiar with both, please have a go  
02:19 - at following along anyway, as there is still 
plenty to learn without coding, I think.  
02:24 - Okay, so a very packed course for you today. I'm 
excited, let's get to it. As always that please  
02:32 - do give us that sub. If you like this video, 
as this is the way this channel can grow.  
02:37 - And we can continue to create free content 
for everyone in the Freako camp community.  
02:43 - So we have already covered what the graph is a 
decentralized protocol for indexing and querying  
02:50 - data from blockchains. But why do we need a 
protocol for doing so? Well, as some of you  
02:56 - may or may not know, most of our activity online 
today happens on an internet referred to as web  
03:03 - two. Web two is widely considered to be an 
internet dominated by companies that provide  
03:09 - services in exchange for your personal data. This 
was considered the norm until the introduction of  
03:15 - web three. Web three bypasses all the large 
corporations and companies that web two  
03:22 - relies on by communicating in a peer to peer way. 
With web three, we are no longer relying on the  
03:29 - company as as our central hub for our services. 
But rather than rely on peer to peer protocols.  
03:34 - In Web two, users are able to utilize free 
services in exchange for their personal data.  
03:40 - And then web three uses pay protocols to work for 
them in exchange for self sovereignty and privacy.  
03:46 - In other words, web three is decentralized and 
looks a lot like this. This meant that whatever we  
03:53 - built on web three, is less reliant on centralized 
companies whose servers may go down causing an app  
03:59 - to crash as one of the many examples are more 
reliant on a distributed network of lots and lots  
04:05 - of individuals. Two great examples of this peer 
to peer networks or in other words, decentralized  
04:11 - networks, either Ethereum network and IPFS, 
or the interplanetary file system network.  
04:19 - Let's start with Aetherium. Now, what you might 
not know is that it is actually very difficult  
04:26 - to query data on the Ethereum blockchain directly. 
This is because so much of what is stored on the  
04:32 - blockchain is stored in a very complex way. So 
currently, what do you want to find a file on  
04:37 - web to you tell the browser exactly where to 
look for the file you're searching for? This  
04:42 - location is essentially your URL. And this method 
for accessing files is called location based  
04:49 - addressing. This works fine until you guessed 
it, the server where your files are stored, goes  
04:55 - offline, or hackers managed to take something down 
and you can't act says your files anymore. Web  
05:02 - three overcomes this issue with content base 
addressing. This means that with web three,  
05:09 - when requesting a specific resource, you do not 
request its location, you request what you are  
05:15 - looking for instead, and it is most likely spread 
all over web three, and not just in one location.  
05:21 - So super safe, but hard to query. So why you 
are able to find a specific thing that you are  
05:29 - looking for more advanced real world queries and 
operations like aggregation. Such relationships,  
05:37 - non trivial filtering, or other things you're 
used to doing with simple structures are just not  
05:44 - possible. To get this data, you would have to 
process every event ever emitted by a smart  
05:50 - contract. Two phrases we will be looking at Next, 
read the metadata from IPFS using the token ID and  
05:58 - IPFS hash, and then aggregate it even for these 
types of relatively simple queries. It will take  
06:05 - hours or even days for a decentralized application 
running in a browser to get a response.  
06:13 - You could also build out your own server process 
the transactions there, save them to a database  
06:19 - and build an API endpoint on top of it all in 
order to query the data. However, this option  
06:26 - is resource intensive needs maintenance presents 
a single point of failure and brutes important  
06:32 - security properties required for decentralization. 
This is where the graph comes in. The graph solves  
06:40 - this problem by indexing blockchain data. Once 
blockchain data is indexed, the graph creates a  
06:46 - sub graph that can be queried with your standard 
Graph QL API. Some graphs are just open API's. The  
06:54 - graph knows which data to index for your sub graph 
based on something called your sub graph manifest  
07:00 - that you define. So now thanks to the sub graph 
manifests and the graph, you are able to query  
07:07 - data on the blockchain and our problem is solved. 
And not only that, we can view the results of our  
07:13 - queries and there's neat UI right here. Let's have 
a deeper look at some graphs and writing sub graph  
07:19 - manifests in the next section. As we mentioned, 
a sub graph manifest also known as a subgraph.  
07:25 - Description is something that the graph uses to 
index the data that you need on the blockchain.  
07:31 - We also mentioned that this is something that 
you define yourself. For example, you can  
07:36 - define a subgraph manifest to query these smart 
contracts you are interested in for a subgraph  
07:43 - the events in those contracts to pay attention to 
and how to map event data to data that the graph  
07:49 - will store in its database. smart contracts on 
the blockchain, for those of you coming across the  
07:55 - time for the first time, in a nutshell, are pieces 
of repeatable executable code, they are stored on  
08:02 - the blockchain and run when certain conditions are 
met. So think if this happens, then that happens,  
08:09 - you can even think of them as a sort of function 
if you wish. It could be to do with releasing  
08:13 - money to stakeholders, sending notifications 
or anything really all in an encrypted way.  
08:20 - When conditions are met, smart contracts can 
emit events. In fact, events are the way you can  
08:26 - communicate with your smart contract in general. 
So when something happens, events are emitted  
08:31 - and laws are written to the blockchain, that then 
your front end applications can pick up so we know  
08:37 - what is going on. Once you have defined your 
sub graph manifest, you can use the graph CLI or  
08:45 - command line interface to store the definitions 
on the blockchain and tell the indexer to start  
08:50 - indexing data for that sub graph. Okay, so think 
what you want to query, define it, then run the  
08:57 - indexer. And that's it. Once you are happy with 
what you have built and tested it out to see you  
09:03 - are getting the correct data back, you can publish 
your subgraph to the decentralized network.  
09:09 - This now means that by using your subgraph and 
your definition of it, applications can query data  
09:15 - so by what is called a query market, comprised of 
a network of indexes, or competing to provide the  
09:22 - best indexing service at the best price. This is 
opposed to how we query things today on web two,  
09:29 - which involves going through a centralized 
server that just offers one service at one price.  
09:37 - building apps or in this case, decentralized 
apps, also known as D apps is very different  
09:43 - from what we are used to today. When building on 
the blockchain. As we touched on briefly already,  
09:49 - data is not stored in an organized way. It is 
scattered all over the place. This is done by  
09:54 - design and in laymen terms is the reason it 
is so secure, as it is decentralized. and not  
10:00 - reliant on a centralized source on the traditional 
centralized web databases and API's query filter,  
10:08 - sort paginate group and join data before 
returning it back to your front end applications.  
10:14 - Usually thanks to some sort of HTTP request. 
This is possible as data is organized and index  
10:21 - on the blockchain, we are missing both these 
things, the organization and the indexing  
10:26 - layer. This would mean that if someone wanted 
to build a decentralized app, they would have  
10:33 - to build a way to index data by building an 
operating proprietary indexing servers. This  
10:39 - will require a lot of time and energy and each 
company would probably be doing the same thing.  
10:44 - The demand to build a tool that everyone could 
use, that would also standardize the way data  
10:50 - was queried was that and to the graph, the 
graph was essentially born out of this quote,  
10:57 - market meat. Today, the graph is one of the most 
use blockchain protocols and has saved a number  
11:03 - of companies and developers time and money by 
building a data querying tool that they no longer  
11:09 - have to build themselves. By now, we know why 
the graph was invented, as well as what we as  
11:18 - developers need to do in order to query data on 
the blockchain. But how do we actually do it,  
11:24 - we have now reached the practical part of this 
course. So let's get about Tonneaus. Because I'm  
11:29 - going to show you have first we are going to have 
to install the graph CLI as this is the main thing  
11:36 - we will need in order to create our first sub 
graph. So let's jump right into it and get going.  
11:43 - Okay, so as mentioned before, as a developer, 
we can choose to either use a subgraph that  
11:50 - was already developed by another developer, or we 
can make our own so we're going to make our own.  
11:57 - In this tutorial, we are going to build a 
subgraph for querying NFT data from the foundation  
12:03 - smart contract, which you can see here, we are 
going to write a query for fetching NF T's as  
12:12 - well as the owners and build relationships between 
them so that by the end, when we essentially look  
12:18 - all over the Ethereum network, our data will 
come back like this. Foundation also has a  
12:25 - developer portal where they have information about 
their smart contract code, as well as links to  
12:30 - their own subgraphs if you want to check this out 
later. So before we get going with this tutorial,  
12:38 - please make sure to have a Node js installed on 
your machine. Here, you can find ways to do this.  
12:45 - And for this tutorial, we are going to be using 
nvm to manage Node js versions. So if you don't  
12:52 - have those installed, please just go ahead and do 
that now. gravitate towards this page right here.  
12:59 - And just download this onto your machine, 
as well as nvm, like so. So all I'm going  
13:08 - to do is just take this script right here 
and just put it in my terminal and run it.  
13:16 - Okay, so once we have these two things done, let's 
carry on. First off, I'm just going to gravitate  
13:24 - to the graph.com. And on here, I'm going to select 
the drop down hosted services. Once here, you have  
13:33 - to essentially make an account, I have signed 
up using my GitHub account. This has already  
13:39 - been done. So it's just going to take me straight 
to the platform. And I'm going to choose to go on  
13:45 - to my dashboard, where you can see some sub graphs 
I have already made as testers as well as my own.  
13:53 - Now, to create our own, just go ahead and 
click add sub graph right here, we're going  
14:00 - to have to name our sub graph something. So 
because we are working from the foundation  
14:06 - app, I'm just going to call this foundation 
app sub graph and give it a quick subtitle. So  
14:14 - this can of course, be wherever you wish, I'm 
just going to fill it out for best practice.  
14:20 - And then let's go ahead and leave these two 
blank. And then we can fill out a description,  
14:29 - and we can give it a GitHub URL. These two 
things are optional. Please feel free to fill  
14:35 - them out if you wish. And just go ahead and click 
Create Graph. And great. Now you should be taken  
14:42 - to this page right here with some more steps. 
The first thing we need to do is initialize a  
14:48 - new subgraph using the graph CLI. So all I'm 
going to do is view the CLI commands here.  
14:59 - So all I'm going to do is view the commands 
right here to be able to install the graph CLI.  
15:06 - Now gravitate to a directory that you want 
to work in for me, it's going to be called  
15:10 - WebStorm projects. Once again, I'm using npm. So 
I'm going to choose npm install, and I'm going to  
15:15 - install it globally GS for globally. And I'm going 
to install Graph Protocol for slash graph CLI.  
15:24 - Now I'm going to leave that to run, once that 
has been installed, we can essentially initialize  
15:32 - a new sub graph with the init command. Okay, so 
just go ahead and wait for that to finish running,  
15:41 - I might as well just zoom this right 
here. So look. And once that is done,  
15:46 - let's just gravitate to here. And I'm just 
going to copy the first command that I see.  
15:55 - So this command is to initialize a new sub 
graph. So all I'm going to do is grab the  
16:02 - command and replace the GitHub name with 
my gab name, and replace this sub graph  
16:08 - name with foundation up sub graph, 
which is what I called my sub graph.  
16:15 - And once again, I'm just going to hit Enter on 
that. Now, there will be some prompts for you.  
16:22 - So just go ahead and make sure to select the 
Etherium option. And then on the subgraph name,  
16:30 - I'm just going to hit Enter. I'm happy with 
that. I'm also happy with the directory that  
16:37 - this wants to be created in. And also happy with 
the directory, it's going to create my subgraph in  
16:43 - so I can view the code. I'm currently once again 
in my WebStorm projects directory on my computer.  
16:50 - And I'm just going to hit Enter on that.  
16:54 - Now here, please select main net, of course, 
you can choose whatever you wish in the future,  
17:00 - but just for this tutorial we're going to be 
doing on Etherium main net. Now, when I asked  
17:05 - for contract address, this essentially is the 
contact address taken from the foundation NFT  
17:15 - contract. Okay, so I have taken this just take the 
same one exact same one that you are seeing here.  
17:24 - Pause if you need to take longer on this 
section, I'm just going to go ahead and  
17:29 - click Enter for now. And when it next asks you for 
a contract name, just go ahead and write token.  
17:40 - Now, if we hit enter, this command will 
essentially generate a basic subgraph based on  
17:46 - the contract address passed into the argument. So 
all the little numbers that the contract address,  
17:52 - it's going to generate a subgraph for us based on 
this. Okay, so if we now go ahead and look in our  
18:03 - directory, we should see a directory called 
foundation subgraph that has been generated  
18:10 - for us, thanks to the command above all with the 
template code that we need to get started. Okay,  
18:18 - so there is a project for those of you using VS 
code, you can just open it up using the command  
18:24 - code.if You have that installed, or you're going 
to open it up with whatever code editor you wish,  
18:30 - I'm going to choose all WebStorm. So I'm just 
going to go ahead and find that now. And open  
18:37 - it up so that we go. And as you will see in 
here, there we go. There are all our files  
18:45 - that have been generated for us. Now I'm going to 
just go ahead and talk you through some of these,  
18:53 - as we mentioned in the explainer, the sub graph 
manifest, or in other words, how we define our sub  
19:02 - graph manifest is this sub graph dot Yamo file. 
Okay, so we've talked that one through once again,  
19:11 - this is how we define our subgraph. And 
next, we also have the schema Graph QL file,  
19:20 - which is a Graph QL schema that defines what data 
is stored for your subgraph and how to query it  
19:26 - via Graph QL. So at the moment, you just see a 
example entity that has an ID account an owner  
19:36 - and approved. So while we are here, actually, I'm 
going to ask you to change the content of this  
19:42 - file to essentially let us query the NF T's in a 
way that we want. So let's go ahead and do that.  
19:54 - So all I'm going to do is paste this 
piece of code that I have pre written  
19:58 - here now Let's talk it through a little bit. 
This is essentially Graph QL. With Graph QL,  
20:06 - we can define entity types just as we have 
done here with the type token and type user.  
20:14 - The graph will essentially take this and generate 
top level fields for querying single instances and  
20:20 - collections of that entity type. Now, this is 
important, each type that should be an entity is  
20:27 - required to be annotated with an entity directive. 
So what we are saying is that we want to index  
20:35 - these two entities, okay, these two entities that 
we are indexing are going to be the token and the  
20:42 - user. This way we can index the tokens created 
by the users as well as the users themselves.  
20:48 - What is also interesting is this derived from 
right here, by adding this derive from field  
20:56 - we can now do reverse lookups. So essentially, 
what is happening is we are creating a virtual  
21:02 - field on the entity that may be queried that 
cannot be set manually through the mappings API.  
21:08 - Rather, it is derived from the relationship 
defined on the other entity. For such  
21:13 - relationships, it rarely makes sense to store both 
sides of the relationship. And both indexing and  
21:18 - query performance will be better when only one 
side is stored, and the other is derived. Okay,  
21:24 - great. So now that we have defined our 
schema, essentially, for the entities, we can  
21:30 - generate the entities locally. With one simple 
command, we're going to use the command graph  
21:37 - cogent in order to spin up some code. 
So let's just go ahead and do that.  
21:47 - And now if we look in the TS file, some 
code would have been generated for us,  
21:53 - based on the two schema that we wrote. If 
you haven't come across this command before,  
22:00 - this command essentially generates assembly script 
types from a combination of a subclass graph, QL,  
22:05 - schema, and the contract ABS 
included in the data sources.  
22:10 - By using this command, we are essentially making 
everything type safe. Now, let's move on to the  
22:17 - subgraph Yamo file, we're gonna have to update 
some things based on what we have just done.  
22:22 - So the first thing I'm going to ask you to do 
is just head over to the data sources, mapping  
22:26 - entities, and just add the user and the token 
entities, just like so. Next up, let's move on  
22:36 - to the data sources, mapping event handlers. And 
I'm going to actually get rid of all these event  
22:41 - handlers as we don't need them anymore, that will 
just the template code. And I'm just going to add  
22:47 - these two events right here. Along with these 
two handlers, make sure to keep the indentation  
22:54 - the exact same as this will cause issues for you 
if you don't. And finally, we need to update the  
23:01 - configurations, add the start block and choose 
the contract address to the main approxi contract  
23:08 - address. So once again, I just going to use this 
right here, make sure to use the exact same as me.  
23:17 - Now go ahead and open up the source 
mappings TS file where we're going  
23:22 - to write the mappings that were defined in our 
subgraph subgraph event handlers. So once again,  
23:28 - I have pre done this for you. And we're 
just going to get rid of all this code,  
23:32 - all of this template code and make it reflect what 
we want, which is the token and the user schemas.  
23:39 - And here is the code. So once again, 
if you need this, I will be putting  
23:44 - this in the description below. This 
is a great template for you to have.  
23:52 - Now, these mappings will essentially handle events 
for when a new token is created, transferred or  
23:58 - updated. When these events fire, the mappings will 
say the data into the subgraph. And there we go,  
24:06 - we are all done. Now let's run a build. So we're 
going to do this using the built command like so  
24:15 - making sure that we are definitely 
in the project that we need to be.  
24:20 - And next we are going to have to go back here and 
run the following command of the deploy section of  
24:27 - the tutorial. So all I'm going to do is grab this 
command graph off. And once again, I'm just going  
24:36 - to replace the necessary fields. So this time, 
I'm going to need the access token which is going  
24:43 - to be unique to you and you can find it right 
here. And I'm just going to run that command.  
24:49 - Now we're just going to have to wait for that 
to do its thing. And finally I'm just going to  
24:54 - grab this command to deploy our graph, making 
sure to once again Replace the GitHub name  
25:01 - and the sub graph name. So this is my GitHub name, 
please go ahead and use your own. And whatever you  
25:07 - call your sub graph, just make sure that is the 
same, and run the command. And there we have it,  
25:14 - we have deployed our sub graph, you can see it 
here. And then if you go back to your dashboard,  
25:21 - you will see the sub graphs show up right? There. 
Wonderful. So once we have that we have deployed  
25:29 - our sub graph, it is now time to start querying 
the foundation app NFT space to see if we can  
25:37 - return back and of tears as well as the owners IDs 
and so on. So let's do it. So this should spin up  
25:45 - a playground similar to probably once you've 
seen before, if you have used Graph QL. Before,  
25:52 - as you will see there are some schemas on 
the right you will see the other schemes  
25:56 - that we defined, so the token schema and the user 
schema that we can use now to write our queries.  
26:05 - A query has been generated for us also the example 
query. So if I click this button right here, it  
26:12 - will run. And you will see the URI for 
the content, as well as the token IDs,  
26:20 - and the token IPFS paths. So wonderful. This is 
looking good. Now let's try write our own query.  
26:30 - So I'm going to do this from scratch. And I 
can also use the schema to help me do this.  
26:36 - So for example, if I want to query tokens, these 
are the things that I can get returned back to me.  
26:43 - So I'm just going to go ahead and start doing 
this. Now, this is the syntax for querying things  
26:48 - using Graph QL. So I just want to return back 
tokens like so. And the tokens that I want to  
26:56 - return, well, I want to get back each tokens I 
D, as you can see here, as well as each tokens.  
27:08 - Token ID, which is a different type of ID. And 
I also want to pick out the token IPFS path. So  
27:19 - as you can see, we don't need to pick all the 
fields, these are the only three that I want to  
27:24 - return. So I can literally pick and choose what 
I want returned, I could have put the owner,  
27:30 - I could have picked the Creator, I could have 
put the timestamp, I could have put the name,  
27:35 - but I've just chosen these three. And if we 
run that, there we go. Another neat thing  
27:44 - that can be done is that I can order the order 
in which I want these tokens to come back to me  
27:50 - in. So if I want to do this, all I have to do is 
write the order by an order by the ID as well as  
27:58 - add an order direction. So making sure that is 
in between two parenthesis, I'm going to choose  
28:04 - the order direction to be descending. And if I run 
this, you will see the token ID starts at 99999.  
28:14 - And if I go ahead and put ascending, so ASC for 
ascending, it will start at one. So there we go.  
28:23 - Let's just change that back to descending maybe 
for now, I can also skip the first 100. So for  
28:30 - example, if I put Skip 100, just like so, and run 
this, then the first 100 tokens will be skipped.  
28:40 - Great. Now let's perhaps look at the users. So 
once again, I'm just going to use this syntax  
28:47 - to return back the users. And if we have a look at 
the schema, we can see that we can choose the ID,  
28:55 - the tokens. And because we have derive this, I 
can now use the token schema to get back tokens.  
29:05 - Okay, so hopefully you can 
see what we have done there.  
29:08 - With the derived prom tag that you saw earlier. 
I am essentially using the user token schema.  
29:16 - And I've now sort of made a relationship 
between the token schema and the user schema.  
29:23 - So now once again, I can choose to order the 
tokens just like we did before. And this time  
29:32 - perhaps let's do it by the timestamp, so I 
could just choose created at timestamp option.  
29:40 - and wonderful. Please do have a go around 
our playing here before moving on to the next  
29:46 - section. In this part of the tutorial, I'm going 
to be showing you how to build a front end using  
29:54 - react quickly in order to display the data in 
all browsers. So all the data that you see here,  
30:02 - I'm going to be showing you how to get it to here. 
Okay, so let's get to it super simple, let's do  
30:10 - it. If you do not know react or would like to use 
some sort of other framework for the front end,  
30:16 - please feel free. But please do have a go at 
watching long anyway, to get the general concepts.  
30:23 - The two packages that we are going to need for 
this part of dictatorial arco and Graph QL,  
30:28 - you will see them right here. Our code allows 
us to rapidly use Graph QL in our applications  
30:35 - without complex configuration, or large API 
overhead. And the Graph QL package will allow  
30:42 - us to write queries in this format right here 
in our front end. So to get going, we're gonna  
30:50 - have to grab our query HTTP path. In fact, if you 
would like to actually use any of the sub graphs,  
30:57 - you can go ahead and do so. So I'm just going 
to show you how to do that before moving on.  
31:02 - So right on here, just select the Graph Explorer. 
And we can choose any of these really. So perhaps,  
31:10 - let's go ahead and choose the art blocks one, and 
then you will be able to view the query the URL  
31:18 - query that you will need. So for example, to use 
our blocks, I would need to get this query URL.  
31:25 - Okay. And that's really it. So now that we know 
that, let's go ahead and get our own query URL  
31:32 - from the subgraph we have made. So I'm just going 
to gravitate back to my dashboard where we made  
31:39 - the foundation app subgraph. And I'm 
just going to go ahead and click on it.  
31:45 - And here we go. Here is my query URL, that 
is the URL that I need to make the queries.  
31:53 - So just make a mental note of that. Now, 
let's get to creating our front end app.  
32:00 - So all I'm going to do is once again gravitate 
to my WebStorm projects. And in this directory,  
32:06 - I'm going to use the command MPX create react app, 
and then whatever I want to call my app. So I'm  
32:12 - just going to call it my graph studio in order to 
spin up a React app fast with configuration with  
32:18 - files. So everything will essentially be done for 
me. If you want to read more about this command,  
32:24 - please go ahead and check it out here. It is one 
that I use often my project so that we can get to  
32:30 - the coding part quickly. So once this has finished 
running at the moment, it's just getting all the  
32:36 - necessary files I need and all the configuration, 
then we should get ready to start project.  
32:44 - And there we go. We are now done. So now 
I just need to go into the project I made.  
32:51 - So I called it my graph projects, I'm going to 
go into there. And I now need to install the  
32:57 - packages that I discussed. So ACO and Graph QL. 
And I'm just going to wait for those to install.  
33:05 - And I'm just going to open up my project. So once 
again, I am using WebStorm. So I'm just going to  
33:11 - open up WebStorm again, and there you will see 
foundation up so graph that we made in the last  
33:15 - section. And I'm just going to open up the newest 
directory that we have made, which is called my  
33:21 - graph project. And in here, tada, you will see all 
the files necessary to get going with create react  
33:30 - app. So I'm not going to talk you through 
these, hopefully, you know this command already.  
33:37 - And now to start the app, I'm just going 
to use the command npm. Run start like so.  
33:45 - And that will spin up my app on localhost 3000. 
There we go. This is what it should look like.  
33:54 - Now, if we look back in our projects, 
and check out the package, Jason,  
33:58 - you will see the actual package. And you will also 
see the graph your package along with our version.  
34:04 - So if anything is not working for you right now, 
it could be because you're using a newer version.  
34:09 - If that is so just revert back to this version 
and run NPM i So npm install, again to re install  
34:17 - all these packages. Okay, let's move on. Now 
the first thing I'm going to do is just in  
34:25 - the app js file, I'm going to import create client 
from arco. So the package that we just installed,  
34:32 - and I'm also going to import to use effect and you 
state from react. Okay, so those are literally the  
34:38 - only three things we need. Now even though we are 
not importing Graph QL here, we still do need it.  
34:45 - So don't think that that was installed without 
a reason. Next, I'm going to put my URL in here,  
34:50 - so the query URL and want to save it in this 
project. Let's save it as consew URL and let's  
34:56 - just go ahead and grab it. So I'm just going 
to get back here, and just paste as a string  
35:02 - like. So the next thing we need to do is use our 
query. So I'm going to define this as query. and I  
35:12 - are going to put some backticks in here, because 
we need the backticks, in order for this to work,  
35:17 - and I'm just going to get this query the example 
query that we have in our playground. Okay,  
35:23 - if I run it, it should return this data. 
So that's the data that I want returned.  
35:28 - So let's grab it. And let's just paste it in our 
project, like so. So super simple. There we go.  
35:36 - The next thing that I want to do is actually 
start a client. So let's define our client.  
35:42 - And I'm going to use create client that we 
imported from the package our call, and then  
35:48 - we're just going to pass through the URL, maybe 
let's call this something different, I'm going to  
35:53 - call this API URL like so. And the next thing 
that I'm going to do is just fetch the data.  
36:00 - So for this, I'm gonna write a function. It's 
called Fetch Data, and it's an async function.  
36:06 - And in here, I'm going to use the client 
that I defined, and I'm going to use query,  
36:12 - which is a method that comes with it and 
pause through the query, and then use the  
36:17 - method to promise on it. So again, this is just 
the query that we have defined. And I'm going to  
36:23 - await this and then catch the response once 
it resolves. So once the promise resolves,  
36:30 - and I'm just going to console log it 
out, so we can see it in our browser.  
36:35 - Now, this function, I'm going to put in a use 
effect. So just go ahead and do that in order  
36:41 - for this to work. And let's check it up. So 
now if I inspect the browser, you should see  
36:49 - a response with the object, which has the data and 
the tokens, and the users coming back to me. Okay,  
36:59 - so exactly the same. As we saw on our playground, 
we are now seeing this in our browser. Wonderful.  
37:06 - Okay, so this is pretty much it. If you 
want to actually see in the browser as well,  
37:10 - I'm just going to quickly show you how to do 
that. Maybe let's just show the content URI  
37:16 - and the token ID. So all I'm going to do is 
just save the tokens to state, we can do this  
37:23 - using use state or the use state react hook. So 
let's go ahead and do that now. const tokens,  
37:31 - and then set tokens and I'm going to start off 
with state being now. So at the moment tokens  
37:37 - is now and we're going to use set tokens in order 
to change the value of tokens to something else.  
37:43 - So I am now going to get the response data 
tokens because we just want the tokens really,  
37:50 - and I'm going to use set tokens in 
order to change the value of tokens  
37:54 - to the tokens that are coming back to 
us with the response. And once again,  
38:01 - we want to display this in the browser. So I'm 
just going to get rid of all this template code.  
38:06 - And if tokens exists, I want to map each token. 
Once again, we need the index as well, because  
38:12 - we're going to have to add a key to the wrapping 
div. So let's make a wrapping div and then just  
38:20 - pass through the key of index, we're not using it. 
So I'm just going to put in an underscore like so.  
38:29 - And now, we aren't going to have to I'm going 
to make these a tags. And if we click on them,  
38:38 - it's going to take us to the token 
content URI, it's going to open up a new  
38:43 - new tab. And then perhaps let's also have 
the, let's have the token ID. So Tada.  
38:53 - Now, if we click on the token, Uri, it will take 
us to all of this information here. This is pretty  
39:01 - neat. And then we can also see our token ID next 
to it. Wonderful. So we're getting the data back,  
39:08 - we're displaying it of course, please be more 
inventive, feel free to display your data however  
39:14 - you wish. This is essentially the steps into 
getting that data showing up on your front end.  
39:21 - If you want to use perhaps a different subgraph 
that might come back with different data that you  
39:26 - can use in different ways as well. So the 
world is really your oyster with this.  
39:33 - Okay, so we've covered a lot so far. Now the 
final part is going to be all about managing  
39:40 - your API keys and billing for your studio. So 
we're just going to head over to the subgraph  
39:46 - studio by navigating here. Now the first thing 
that you are going to need is to have a wallet set  
39:53 - up. I'm going to be using meta mask for this 
tutorial. So I'm just going to show you quickly  
39:58 - how to get set up So I'm just going to show 
you quickly how to get set up with Metamask,  
40:03 - just in case that you haven't before. First 
off, just gravitate towards metamath. So I O,  
40:11 - and simply install the Chrome extension. Once that 
is done, you should see a little fox show up here.  
40:17 - And if you click on it, this browser should show 
up. Now let's go ahead and click Get Started. As  
40:24 - we are new, I'm going to go ahead and create a 
new wallet and just go through these steps. Go  
40:30 - ahead and create your password making sure that 
is unique to you. Finally, after clicking Next,  
40:37 - you're going to get some secret recovery phrases. 
These are super important, don't disclose them to  
40:43 - anyone, I'm going to be sharing them with you 
here as my wallet is not going to be active.  
40:47 - So here are my secret words. And I'm just going 
to have to confirm my secret recovery phrases  
40:53 - by dragging and dropping them in the correct 
order. So once again, do not save this with  
40:59 - anyone keep it super safe, as if anyone 
has this they will be able to access your  
41:04 - wallet. And there we go. So that is it. We are now 
set up I have a Metamask wallet. Let's continue.  
41:14 - So now it's going to prompt me to connect with my 
wallet, I am going to go ahead and do that and my  
41:20 - wallet should pop up in the corner like so. And 
there we go. Super simple. Just go ahead and click  
41:28 - Next through these. And once we are done, go ahead 
and click on the billing tab. Here you will see  
41:35 - your billing balance as well as any costs that you 
have incurred in the billing period. Now to enable  
41:42 - billing, this is important you must have ether and 
grt in your Metamask Wallet. So these two things  
41:50 - are important in order to get set up. This is what 
your dashboard should look like. If they are it  
41:56 - should give you the option to deposit gr T to your 
billing balance. Billing is covered on the Matic  
42:04 - side chain or to decrease transaction times 
as well as transaction costs. In this step,  
42:11 - we are going to move grt to the Matic network. 
So I'm just going to put in the value of 25  
42:17 - and approve and confirm. Once the GRT is 
successfully moved to the Matic network,  
42:24 - we can now switch to the Matic network. To 
view more details on the Matic network, please  
42:30 - visit docstoc Matic dot network forward slash 
Doc's develop network details slash network.  
42:36 - As you can see in the URL right here. Here you 
will see the details that we need to import  
42:41 - into a meta mask wallet, including the network 
name, the chain ID, and the RPC address. So now  
42:52 - let's go ahead and add that to our meta mask 
Wallet. So I'm just going to click on settings  
42:57 - and gravitate towards networks. And now we're 
going to manually add the network. So once again,  
43:02 - I'm just going to add the network name, the chain 
ID, and the RPC. Once the network is configured  
43:12 - in your meta mask wallet, we can now move on to 
the next step, we can now move our grt from our  
43:19 - wallet balance into our billing balance. So let's 
just go ahead and confirm this IGRT and confirm.  
43:38 - And great, you will see avillion 
balance has been updated.  
43:43 - After all these steps have been taken, we are 
now ready to create our API key. So all I'm  
43:49 - going to do is gravitate towards the API key drop 
down, and I'm simply going to create an API key.  
43:59 - So we can obviously rename it here and let's 
go a head. Once our new API key is created,  
44:06 - we can now scope it down to authorize 
subgraphs and authorized domains.  
44:11 - To scope an API key to a sub graph, we first 
need the subgraph ID subgraph IDs can be found  
44:19 - here. So just go ahead and find the subgraph ID 
you need. So this one right here and paste it like  
44:27 - so. And there we go. So the whole reason we did 
this is so that we are now enabled to use the pool  
44:34 - together. subgraph. Okay, we are now authorized to 
use it, thanks to this API key. And there we have  
44:43 - it. We have now finished the tutorial all about 
querying on the blockchain. So in conclusion, what  
44:50 - we have learned is how to build sub graphs, how 
to hook up a front end to use our sub graph, and  
44:57 - then how to manage our data. API keys below Thanks 
so much for watching and I'll see you again soon

Cleaned transcript:

Hey everyone, my name is Andrew Kubo. And I will be your instructor for this blockchain development course all about querying data on web three decentralized applications. In this course, you will get an introduction into indexing and querying data on the Ethereum blockchain, and understand why querying data on decentralized networks is so different to what we are used to on the traditional web. Goodbye HTTP requests, hello, some graphs. We will be doing this with some explainer sections, as well as some hands on experience by building your own querying technology. By the end of this course, you will have the knowledge to query data from the Etherium main net, as well as a variety of chains on the hosted service in order to build your own decentralized apps. This course is made possible with a grant from the graph creators of the tool we will be using in this video. But first, let's cover just exactly what we will be looking at in this course. First off, we are going to start off by looking at the graph, a decentralized protocol for indexing and querying data from blockchains. This will include why it was built in the first place and how to use it. Next, we will move on to looking at some graphs, which are open API's. We'll discuss how sub graphs help you get the data you need to create and power your own decentralized applications or Dapps. We will then move on to the more hands on approach and cover how to build out subgraph with a step by step tutorial, then move on to how to query a subgraph from a front end application, and how to manage your API keys. Once we have built a subgraph, it will then be time to put it to some good use and make some queries with it. Using tools such as the Graph Explorer, which we will go into how to use together, you will be glad to know that this course will take a very beginner approach. So this is your first time working with Blockchain related topics, you are in safe hands. The only prerequisites I ask of you before starting this course is to have a basic understanding of JavaScript, no GS and Graph QL. However, if you're not super familiar with both, please have a go at following along anyway, as there is still plenty to learn without coding, I think. Okay, so a very packed course for you today. I'm excited, let's get to it. As always that please do give us that sub. If you like this video, as this is the way this channel can grow. And we can continue to create free content for everyone in the Freako camp community. So we have already covered what the graph is a decentralized protocol for indexing and querying data from blockchains. But why do we need a protocol for doing so? Well, as some of you may or may not know, most of our activity online today happens on an internet referred to as web two. Web two is widely considered to be an internet dominated by companies that provide services in exchange for your personal data. This was considered the norm until the introduction of web three. Web three bypasses all the large corporations and companies that web two relies on by communicating in a peer to peer way. With web three, we are no longer relying on the company as as our central hub for our services. But rather than rely on peer to peer protocols. In Web two, users are able to utilize free services in exchange for their personal data. And then web three uses pay protocols to work for them in exchange for self sovereignty and privacy. In other words, web three is decentralized and looks a lot like this. This meant that whatever we built on web three, is less reliant on centralized companies whose servers may go down causing an app to crash as one of the many examples are more reliant on a distributed network of lots and lots of individuals. Two great examples of this peer to peer networks or in other words, decentralized networks, either Ethereum network and IPFS, or the interplanetary file system network. Let's start with Aetherium. Now, what you might not know is that it is actually very difficult to query data on the Ethereum blockchain directly. This is because so much of what is stored on the blockchain is stored in a very complex way. So currently, what do you want to find a file on web to you tell the browser exactly where to look for the file you're searching for? This location is essentially your URL. And this method for accessing files is called location based addressing. This works fine until you guessed it, the server where your files are stored, goes offline, or hackers managed to take something down and you can't act says your files anymore. Web three overcomes this issue with content base addressing. This means that with web three, when requesting a specific resource, you do not request its location, you request what you are looking for instead, and it is most likely spread all over web three, and not just in one location. So super safe, but hard to query. So why you are able to find a specific thing that you are looking for more advanced real world queries and operations like aggregation. Such relationships, non trivial filtering, or other things you're used to doing with simple structures are just not possible. To get this data, you would have to process every event ever emitted by a smart contract. Two phrases we will be looking at Next, read the metadata from IPFS using the token ID and IPFS hash, and then aggregate it even for these types of relatively simple queries. It will take hours or even days for a decentralized application running in a browser to get a response. You could also build out your own server process the transactions there, save them to a database and build an API endpoint on top of it all in order to query the data. However, this option is resource intensive needs maintenance presents a single point of failure and brutes important security properties required for decentralization. This is where the graph comes in. The graph solves this problem by indexing blockchain data. Once blockchain data is indexed, the graph creates a sub graph that can be queried with your standard Graph QL API. Some graphs are just open API's. The graph knows which data to index for your sub graph based on something called your sub graph manifest that you define. So now thanks to the sub graph manifests and the graph, you are able to query data on the blockchain and our problem is solved. And not only that, we can view the results of our queries and there's neat UI right here. Let's have a deeper look at some graphs and writing sub graph manifests in the next section. As we mentioned, a sub graph manifest also known as a subgraph. Description is something that the graph uses to index the data that you need on the blockchain. We also mentioned that this is something that you define yourself. For example, you can define a subgraph manifest to query these smart contracts you are interested in for a subgraph the events in those contracts to pay attention to and how to map event data to data that the graph will store in its database. smart contracts on the blockchain, for those of you coming across the time for the first time, in a nutshell, are pieces of repeatable executable code, they are stored on the blockchain and run when certain conditions are met. So think if this happens, then that happens, you can even think of them as a sort of function if you wish. It could be to do with releasing money to stakeholders, sending notifications or anything really all in an encrypted way. When conditions are met, smart contracts can emit events. In fact, events are the way you can communicate with your smart contract in general. So when something happens, events are emitted and laws are written to the blockchain, that then your front end applications can pick up so we know what is going on. Once you have defined your sub graph manifest, you can use the graph CLI or command line interface to store the definitions on the blockchain and tell the indexer to start indexing data for that sub graph. Okay, so think what you want to query, define it, then run the indexer. And that's it. Once you are happy with what you have built and tested it out to see you are getting the correct data back, you can publish your subgraph to the decentralized network. This now means that by using your subgraph and your definition of it, applications can query data so by what is called a query market, comprised of a network of indexes, or competing to provide the best indexing service at the best price. This is opposed to how we query things today on web two, which involves going through a centralized server that just offers one service at one price. building apps or in this case, decentralized apps, also known as D apps is very different from what we are used to today. When building on the blockchain. As we touched on briefly already, data is not stored in an organized way. It is scattered all over the place. This is done by design and in laymen terms is the reason it is so secure, as it is decentralized. and not reliant on a centralized source on the traditional centralized web databases and API's query filter, sort paginate group and join data before returning it back to your front end applications. Usually thanks to some sort of HTTP request. This is possible as data is organized and index on the blockchain, we are missing both these things, the organization and the indexing layer. This would mean that if someone wanted to build a decentralized app, they would have to build a way to index data by building an operating proprietary indexing servers. This will require a lot of time and energy and each company would probably be doing the same thing. The demand to build a tool that everyone could use, that would also standardize the way data was queried was that and to the graph, the graph was essentially born out of this quote, market meat. Today, the graph is one of the most use blockchain protocols and has saved a number of companies and developers time and money by building a data querying tool that they no longer have to build themselves. By now, we know why the graph was invented, as well as what we as developers need to do in order to query data on the blockchain. But how do we actually do it, we have now reached the practical part of this course. So let's get about Tonneaus. Because I'm going to show you have first we are going to have to install the graph CLI as this is the main thing we will need in order to create our first sub graph. So let's jump right into it and get going. Okay, so as mentioned before, as a developer, we can choose to either use a subgraph that was already developed by another developer, or we can make our own so we're going to make our own. In this tutorial, we are going to build a subgraph for querying NFT data from the foundation smart contract, which you can see here, we are going to write a query for fetching NF T's as well as the owners and build relationships between them so that by the end, when we essentially look all over the Ethereum network, our data will come back like this. Foundation also has a developer portal where they have information about their smart contract code, as well as links to their own subgraphs if you want to check this out later. So before we get going with this tutorial, please make sure to have a Node js installed on your machine. Here, you can find ways to do this. And for this tutorial, we are going to be using nvm to manage Node js versions. So if you don't have those installed, please just go ahead and do that now. gravitate towards this page right here. And just download this onto your machine, as well as nvm, like so. So all I'm going to do is just take this script right here and just put it in my terminal and run it. Okay, so once we have these two things done, let's carry on. First off, I'm just going to gravitate to the graph.com. And on here, I'm going to select the drop down hosted services. Once here, you have to essentially make an account, I have signed up using my GitHub account. This has already been done. So it's just going to take me straight to the platform. And I'm going to choose to go on to my dashboard, where you can see some sub graphs I have already made as testers as well as my own. Now, to create our own, just go ahead and click add sub graph right here, we're going to have to name our sub graph something. So because we are working from the foundation app, I'm just going to call this foundation app sub graph and give it a quick subtitle. So this can of course, be wherever you wish, I'm just going to fill it out for best practice. And then let's go ahead and leave these two blank. And then we can fill out a description, and we can give it a GitHub URL. These two things are optional. Please feel free to fill them out if you wish. And just go ahead and click Create Graph. And great. Now you should be taken to this page right here with some more steps. The first thing we need to do is initialize a new subgraph using the graph CLI. So all I'm going to do is view the CLI commands here. So all I'm going to do is view the commands right here to be able to install the graph CLI. Now gravitate to a directory that you want to work in for me, it's going to be called WebStorm projects. Once again, I'm using npm. So I'm going to choose npm install, and I'm going to install it globally GS for globally. And I'm going to install Graph Protocol for slash graph CLI. Now I'm going to leave that to run, once that has been installed, we can essentially initialize a new sub graph with the init command. Okay, so just go ahead and wait for that to finish running, I might as well just zoom this right here. So look. And once that is done, let's just gravitate to here. And I'm just going to copy the first command that I see. So this command is to initialize a new sub graph. So all I'm going to do is grab the command and replace the GitHub name with my gab name, and replace this sub graph name with foundation up sub graph, which is what I called my sub graph. And once again, I'm just going to hit Enter on that. Now, there will be some prompts for you. So just go ahead and make sure to select the Etherium option. And then on the subgraph name, I'm just going to hit Enter. I'm happy with that. I'm also happy with the directory that this wants to be created in. And also happy with the directory, it's going to create my subgraph in so I can view the code. I'm currently once again in my WebStorm projects directory on my computer. And I'm just going to hit Enter on that. Now here, please select main net, of course, you can choose whatever you wish in the future, but just for this tutorial we're going to be doing on Etherium main net. Now, when I asked for contract address, this essentially is the contact address taken from the foundation NFT contract. Okay, so I have taken this just take the same one exact same one that you are seeing here. Pause if you need to take longer on this section, I'm just going to go ahead and click Enter for now. And when it next asks you for a contract name, just go ahead and write token. Now, if we hit enter, this command will essentially generate a basic subgraph based on the contract address passed into the argument. So all the little numbers that the contract address, it's going to generate a subgraph for us based on this. Okay, so if we now go ahead and look in our directory, we should see a directory called foundation subgraph that has been generated for us, thanks to the command above all with the template code that we need to get started. Okay, so there is a project for those of you using VS code, you can just open it up using the command code.if You have that installed, or you're going to open it up with whatever code editor you wish, I'm going to choose all WebStorm. So I'm just going to go ahead and find that now. And open it up so that we go. And as you will see in here, there we go. There are all our files that have been generated for us. Now I'm going to just go ahead and talk you through some of these, as we mentioned in the explainer, the sub graph manifest, or in other words, how we define our sub graph manifest is this sub graph dot Yamo file. Okay, so we've talked that one through once again, this is how we define our subgraph. And next, we also have the schema Graph QL file, which is a Graph QL schema that defines what data is stored for your subgraph and how to query it via Graph QL. So at the moment, you just see a example entity that has an ID account an owner and approved. So while we are here, actually, I'm going to ask you to change the content of this file to essentially let us query the NF T's in a way that we want. So let's go ahead and do that. So all I'm going to do is paste this piece of code that I have pre written here now Let's talk it through a little bit. This is essentially Graph QL. With Graph QL, we can define entity types just as we have done here with the type token and type user. The graph will essentially take this and generate top level fields for querying single instances and collections of that entity type. Now, this is important, each type that should be an entity is required to be annotated with an entity directive. So what we are saying is that we want to index these two entities, okay, these two entities that we are indexing are going to be the token and the user. This way we can index the tokens created by the users as well as the users themselves. What is also interesting is this derived from right here, by adding this derive from field we can now do reverse lookups. So essentially, what is happening is we are creating a virtual field on the entity that may be queried that cannot be set manually through the mappings API. Rather, it is derived from the relationship defined on the other entity. For such relationships, it rarely makes sense to store both sides of the relationship. And both indexing and query performance will be better when only one side is stored, and the other is derived. Okay, great. So now that we have defined our schema, essentially, for the entities, we can generate the entities locally. With one simple command, we're going to use the command graph cogent in order to spin up some code. So let's just go ahead and do that. And now if we look in the TS file, some code would have been generated for us, based on the two schema that we wrote. If you haven't come across this command before, this command essentially generates assembly script types from a combination of a subclass graph, QL, schema, and the contract ABS included in the data sources. By using this command, we are essentially making everything type safe. Now, let's move on to the subgraph Yamo file, we're gonna have to update some things based on what we have just done. So the first thing I'm going to ask you to do is just head over to the data sources, mapping entities, and just add the user and the token entities, just like so. Next up, let's move on to the data sources, mapping event handlers. And I'm going to actually get rid of all these event handlers as we don't need them anymore, that will just the template code. And I'm just going to add these two events right here. Along with these two handlers, make sure to keep the indentation the exact same as this will cause issues for you if you don't. And finally, we need to update the configurations, add the start block and choose the contract address to the main approxi contract address. So once again, I just going to use this right here, make sure to use the exact same as me. Now go ahead and open up the source mappings TS file where we're going to write the mappings that were defined in our subgraph subgraph event handlers. So once again, I have pre done this for you. And we're just going to get rid of all this code, all of this template code and make it reflect what we want, which is the token and the user schemas. And here is the code. So once again, if you need this, I will be putting this in the description below. This is a great template for you to have. Now, these mappings will essentially handle events for when a new token is created, transferred or updated. When these events fire, the mappings will say the data into the subgraph. And there we go, we are all done. Now let's run a build. So we're going to do this using the built command like so making sure that we are definitely in the project that we need to be. And next we are going to have to go back here and run the following command of the deploy section of the tutorial. So all I'm going to do is grab this command graph off. And once again, I'm just going to replace the necessary fields. So this time, I'm going to need the access token which is going to be unique to you and you can find it right here. And I'm just going to run that command. Now we're just going to have to wait for that to do its thing. And finally I'm just going to grab this command to deploy our graph, making sure to once again Replace the GitHub name and the sub graph name. So this is my GitHub name, please go ahead and use your own. And whatever you call your sub graph, just make sure that is the same, and run the command. And there we have it, we have deployed our sub graph, you can see it here. And then if you go back to your dashboard, you will see the sub graphs show up right? There. Wonderful. So once we have that we have deployed our sub graph, it is now time to start querying the foundation app NFT space to see if we can return back and of tears as well as the owners IDs and so on. So let's do it. So this should spin up a playground similar to probably once you've seen before, if you have used Graph QL. Before, as you will see there are some schemas on the right you will see the other schemes that we defined, so the token schema and the user schema that we can use now to write our queries. A query has been generated for us also the example query. So if I click this button right here, it will run. And you will see the URI for the content, as well as the token IDs, and the token IPFS paths. So wonderful. This is looking good. Now let's try write our own query. So I'm going to do this from scratch. And I can also use the schema to help me do this. So for example, if I want to query tokens, these are the things that I can get returned back to me. So I'm just going to go ahead and start doing this. Now, this is the syntax for querying things using Graph QL. So I just want to return back tokens like so. And the tokens that I want to return, well, I want to get back each tokens I D, as you can see here, as well as each tokens. Token ID, which is a different type of ID. And I also want to pick out the token IPFS path. So as you can see, we don't need to pick all the fields, these are the only three that I want to return. So I can literally pick and choose what I want returned, I could have put the owner, I could have picked the Creator, I could have put the timestamp, I could have put the name, but I've just chosen these three. And if we run that, there we go. Another neat thing that can be done is that I can order the order in which I want these tokens to come back to me in. So if I want to do this, all I have to do is write the order by an order by the ID as well as add an order direction. So making sure that is in between two parenthesis, I'm going to choose the order direction to be descending. And if I run this, you will see the token ID starts at 99999. And if I go ahead and put ascending, so ASC for ascending, it will start at one. So there we go. Let's just change that back to descending maybe for now, I can also skip the first 100. So for example, if I put Skip 100, just like so, and run this, then the first 100 tokens will be skipped. Great. Now let's perhaps look at the users. So once again, I'm just going to use this syntax to return back the users. And if we have a look at the schema, we can see that we can choose the ID, the tokens. And because we have derive this, I can now use the token schema to get back tokens. Okay, so hopefully you can see what we have done there. With the derived prom tag that you saw earlier. I am essentially using the user token schema. And I've now sort of made a relationship between the token schema and the user schema. So now once again, I can choose to order the tokens just like we did before. And this time perhaps let's do it by the timestamp, so I could just choose created at timestamp option. and wonderful. Please do have a go around our playing here before moving on to the next section. In this part of the tutorial, I'm going to be showing you how to build a front end using react quickly in order to display the data in all browsers. So all the data that you see here, I'm going to be showing you how to get it to here. Okay, so let's get to it super simple, let's do it. If you do not know react or would like to use some sort of other framework for the front end, please feel free. But please do have a go at watching long anyway, to get the general concepts. The two packages that we are going to need for this part of dictatorial arco and Graph QL, you will see them right here. Our code allows us to rapidly use Graph QL in our applications without complex configuration, or large API overhead. And the Graph QL package will allow us to write queries in this format right here in our front end. So to get going, we're gonna have to grab our query HTTP path. In fact, if you would like to actually use any of the sub graphs, you can go ahead and do so. So I'm just going to show you how to do that before moving on. So right on here, just select the Graph Explorer. And we can choose any of these really. So perhaps, let's go ahead and choose the art blocks one, and then you will be able to view the query the URL query that you will need. So for example, to use our blocks, I would need to get this query URL. Okay. And that's really it. So now that we know that, let's go ahead and get our own query URL from the subgraph we have made. So I'm just going to gravitate back to my dashboard where we made the foundation app subgraph. And I'm just going to go ahead and click on it. And here we go. Here is my query URL, that is the URL that I need to make the queries. So just make a mental note of that. Now, let's get to creating our front end app. So all I'm going to do is once again gravitate to my WebStorm projects. And in this directory, I'm going to use the command MPX create react app, and then whatever I want to call my app. So I'm just going to call it my graph studio in order to spin up a React app fast with configuration with files. So everything will essentially be done for me. If you want to read more about this command, please go ahead and check it out here. It is one that I use often my project so that we can get to the coding part quickly. So once this has finished running at the moment, it's just getting all the necessary files I need and all the configuration, then we should get ready to start project. And there we go. We are now done. So now I just need to go into the project I made. So I called it my graph projects, I'm going to go into there. And I now need to install the packages that I discussed. So ACO and Graph QL. And I'm just going to wait for those to install. And I'm just going to open up my project. So once again, I am using WebStorm. So I'm just going to open up WebStorm again, and there you will see foundation up so graph that we made in the last section. And I'm just going to open up the newest directory that we have made, which is called my graph project. And in here, tada, you will see all the files necessary to get going with create react app. So I'm not going to talk you through these, hopefully, you know this command already. And now to start the app, I'm just going to use the command npm. Run start like so. And that will spin up my app on localhost 3000. There we go. This is what it should look like. Now, if we look back in our projects, and check out the package, Jason, you will see the actual package. And you will also see the graph your package along with our version. So if anything is not working for you right now, it could be because you're using a newer version. If that is so just revert back to this version and run NPM i So npm install, again to re install all these packages. Okay, let's move on. Now the first thing I'm going to do is just in the app js file, I'm going to import create client from arco. So the package that we just installed, and I'm also going to import to use effect and you state from react. Okay, so those are literally the only three things we need. Now even though we are not importing Graph QL here, we still do need it. So don't think that that was installed without a reason. Next, I'm going to put my URL in here, so the query URL and want to save it in this project. Let's save it as consew URL and let's just go ahead and grab it. So I'm just going to get back here, and just paste as a string like. So the next thing we need to do is use our query. So I'm going to define this as query. and I are going to put some backticks in here, because we need the backticks, in order for this to work, and I'm just going to get this query the example query that we have in our playground. Okay, if I run it, it should return this data. So that's the data that I want returned. So let's grab it. And let's just paste it in our project, like so. So super simple. There we go. The next thing that I want to do is actually start a client. So let's define our client. And I'm going to use create client that we imported from the package our call, and then we're just going to pass through the URL, maybe let's call this something different, I'm going to call this API URL like so. And the next thing that I'm going to do is just fetch the data. So for this, I'm gonna write a function. It's called Fetch Data, and it's an async function. And in here, I'm going to use the client that I defined, and I'm going to use query, which is a method that comes with it and pause through the query, and then use the method to promise on it. So again, this is just the query that we have defined. And I'm going to await this and then catch the response once it resolves. So once the promise resolves, and I'm just going to console log it out, so we can see it in our browser. Now, this function, I'm going to put in a use effect. So just go ahead and do that in order for this to work. And let's check it up. So now if I inspect the browser, you should see a response with the object, which has the data and the tokens, and the users coming back to me. Okay, so exactly the same. As we saw on our playground, we are now seeing this in our browser. Wonderful. Okay, so this is pretty much it. If you want to actually see in the browser as well, I'm just going to quickly show you how to do that. Maybe let's just show the content URI and the token ID. So all I'm going to do is just save the tokens to state, we can do this using use state or the use state react hook. So let's go ahead and do that now. const tokens, and then set tokens and I'm going to start off with state being now. So at the moment tokens is now and we're going to use set tokens in order to change the value of tokens to something else. So I am now going to get the response data tokens because we just want the tokens really, and I'm going to use set tokens in order to change the value of tokens to the tokens that are coming back to us with the response. And once again, we want to display this in the browser. So I'm just going to get rid of all this template code. And if tokens exists, I want to map each token. Once again, we need the index as well, because we're going to have to add a key to the wrapping div. So let's make a wrapping div and then just pass through the key of index, we're not using it. So I'm just going to put in an underscore like so. And now, we aren't going to have to I'm going to make these a tags. And if we click on them, it's going to take us to the token content URI, it's going to open up a new new tab. And then perhaps let's also have the, let's have the token ID. So Tada. Now, if we click on the token, Uri, it will take us to all of this information here. This is pretty neat. And then we can also see our token ID next to it. Wonderful. So we're getting the data back, we're displaying it of course, please be more inventive, feel free to display your data however you wish. This is essentially the steps into getting that data showing up on your front end. If you want to use perhaps a different subgraph that might come back with different data that you can use in different ways as well. So the world is really your oyster with this. Okay, so we've covered a lot so far. Now the final part is going to be all about managing your API keys and billing for your studio. So we're just going to head over to the subgraph studio by navigating here. Now the first thing that you are going to need is to have a wallet set up. I'm going to be using meta mask for this tutorial. So I'm just going to show you quickly how to get set up So I'm just going to show you quickly how to get set up with Metamask, just in case that you haven't before. First off, just gravitate towards metamath. So I O, and simply install the Chrome extension. Once that is done, you should see a little fox show up here. And if you click on it, this browser should show up. Now let's go ahead and click Get Started. As we are new, I'm going to go ahead and create a new wallet and just go through these steps. Go ahead and create your password making sure that is unique to you. Finally, after clicking Next, you're going to get some secret recovery phrases. These are super important, don't disclose them to anyone, I'm going to be sharing them with you here as my wallet is not going to be active. So here are my secret words. And I'm just going to have to confirm my secret recovery phrases by dragging and dropping them in the correct order. So once again, do not save this with anyone keep it super safe, as if anyone has this they will be able to access your wallet. And there we go. So that is it. We are now set up I have a Metamask wallet. Let's continue. So now it's going to prompt me to connect with my wallet, I am going to go ahead and do that and my wallet should pop up in the corner like so. And there we go. Super simple. Just go ahead and click Next through these. And once we are done, go ahead and click on the billing tab. Here you will see your billing balance as well as any costs that you have incurred in the billing period. Now to enable billing, this is important you must have ether and grt in your Metamask Wallet. So these two things are important in order to get set up. This is what your dashboard should look like. If they are it should give you the option to deposit gr T to your billing balance. Billing is covered on the Matic side chain or to decrease transaction times as well as transaction costs. In this step, we are going to move grt to the Matic network. So I'm just going to put in the value of 25 and approve and confirm. Once the GRT is successfully moved to the Matic network, we can now switch to the Matic network. To view more details on the Matic network, please visit docstoc Matic dot network forward slash Doc's develop network details slash network. As you can see in the URL right here. Here you will see the details that we need to import into a meta mask wallet, including the network name, the chain ID, and the RPC address. So now let's go ahead and add that to our meta mask Wallet. So I'm just going to click on settings and gravitate towards networks. And now we're going to manually add the network. So once again, I'm just going to add the network name, the chain ID, and the RPC. Once the network is configured in your meta mask wallet, we can now move on to the next step, we can now move our grt from our wallet balance into our billing balance. So let's just go ahead and confirm this IGRT and confirm. And great, you will see avillion balance has been updated. After all these steps have been taken, we are now ready to create our API key. So all I'm going to do is gravitate towards the API key drop down, and I'm simply going to create an API key. So we can obviously rename it here and let's go a head. Once our new API key is created, we can now scope it down to authorize subgraphs and authorized domains. To scope an API key to a sub graph, we first need the subgraph ID subgraph IDs can be found here. So just go ahead and find the subgraph ID you need. So this one right here and paste it like so. And there we go. So the whole reason we did this is so that we are now enabled to use the pool together. subgraph. Okay, we are now authorized to use it, thanks to this API key. And there we have it. We have now finished the tutorial all about querying on the blockchain. So in conclusion, what we have learned is how to build sub graphs, how to hook up a front end to use our sub graph, and then how to manage our data. API keys below Thanks so much for watching and I'll see you again soon
